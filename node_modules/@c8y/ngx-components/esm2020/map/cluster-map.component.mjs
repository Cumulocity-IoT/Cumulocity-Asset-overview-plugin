import { Component, EventEmitter, Inject, Input, IterableDiffers, Optional, Output, SimpleChange } from '@angular/core';
import { ColorService, ManagedObjectRealtimeService } from '@c8y/ngx-components';
import { TranslateService } from '@ngx-translate/core';
import { BehaviorSubject, from, fromEvent, interval, merge, NEVER, of, Subject } from 'rxjs';
import { debounceTime, filter, first, map, mergeMap, switchMap, takeUntil, tap } from 'rxjs/operators';
import { ClusterMap } from './cluster-map';
import { MapComponent } from './map.component';
import { ClusterSize, defaultLayer, defaultMapConfig, MAP_DEFAULT_CONFIG, MAP_TILE_LAYER } from './map.model';
import { MapService } from './map.service';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components";
import * as i2 from "./map.service";
import * as i3 from "@ngx-translate/core";
export class ClusterMapComponent extends MapComponent {
    constructor(moRealtimeService, mapService, layers, defaultConfig, translateService, iterable, colorService) {
        super(moRealtimeService, mapService, layers, defaultConfig, translateService);
        this.moRealtimeService = moRealtimeService;
        this.mapService = mapService;
        this.layers = layers;
        this.defaultConfig = defaultConfig;
        this.translateService = translateService;
        this.iterable = iterable;
        this.colorService = colorService;
        this.isLoading$ = new BehaviorSubject(false);
        this.msUntilRefresh$ = new BehaviorSubject(5000);
        this.showClusterColor = false;
        this.mapChange = new EventEmitter();
        this.reloadTrigger$ = new BehaviorSubject(false);
        this.clusters = [];
        this.MIN_INTERVAL = 5000;
        this.EVENT_THROTTLE_TIME = 750;
        if (!this.layers) {
            this.layers = [defaultLayer];
        }
        if (!this.defaultConfig) {
            this.defaultConfig = defaultMapConfig;
        }
        this.config = {
            center: this.defaultConfig.center
        };
    }
    async ngOnChanges(changes) {
        if (changes.config?.firstChange) {
            return;
        }
        if (changes.rootNode?.previousValue !== changes.rootNode?.currentValue) {
            this.changeRootNode(changes.rootNode.currentValue);
        }
        if (changes.config?.currentValue) {
            this.changeConfig(changes.config);
        }
    }
    changeConfig(change) {
        // on following, cancel reload to avoid stale state
        if (change.currentValue.follow === true) {
            this.cancelReload();
            this.isLoading$.next(false);
        }
        if (change.currentValue.refreshInterval !== change.previousValue.refreshInterval) {
            this.reload();
        }
        super.changeConfig(change);
    }
    async ngAfterViewInit() {
        if (!this.leaflet) {
            this.leaflet = await this.mapService.getLeaflet();
        }
        this.initMap();
        this.changeRootNode(this.rootNode);
        this.changeConfig(new SimpleChange({}, this.config, false));
    }
    async reset() {
        this.ngOnDestroy();
        await this.ngAfterViewInit();
    }
    reload() {
        this.reloadTrigger$.next(true);
    }
    cancelReload() {
        this.reloadTrigger$.next(false);
    }
    listenToClusterChanges() {
        const timerStart$ = new Subject();
        const timerEnd$ = new Subject();
        const documentHiddenEvent$ = fromEvent(document, 'visibilitychange').pipe(takeUntil(this.destroy$));
        const interval$ = timerStart$.pipe(map(() => this.config.refreshInterval), switchMap(configInterval => {
            if (!configInterval) {
                return NEVER;
            }
            return interval(1000).pipe(map(value => value * 1000), tap(value => this.msUntilRefresh$.next(configInterval - value)), filter(value => value >= this.MIN_INTERVAL && value >= configInterval), first(), takeUntil(timerEnd$));
        }), switchMap(() => (document.hidden ? documentHiddenEvent$ : of(true))), takeUntil(this.destroy$));
        const mapChange$ = merge(fromEvent(this.map, 'move'), fromEvent(this.map, 'moveend')).pipe(debounceTime(this.EVENT_THROTTLE_TIME), tap(event => this.mapChange.emit(event)), takeUntil(this.destroy$));
        merge(this.reloadTrigger$, mapChange$, interval$)
            .pipe(tap(() => {
            timerEnd$.next(true);
            this.msUntilRefresh$.next(0);
            this.isLoading$.next(true);
        }), switchMap(value => value === false
            ? of([])
            : from(this.mapService.getClusterSize(this.map.getBounds())).pipe(mergeMap((clusterSize) => this.getClusterRects(clusterSize, this.map.getBounds())), mergeMap(rects => this.createOrUpdateCluster(rects)))), takeUntil(this.destroy$))
            .subscribe((clusters) => {
            clusters.forEach(cluster => cluster.render(this.map));
            this.isLoading$.next(false);
            timerStart$.next();
            this.msUntilRefresh$.next(this.config.refreshInterval);
        });
    }
    refreshMarkers() {
        if (this.assets) {
            super.refreshMarkers();
            return;
        }
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.reload();
    }
    changeRootNode(mo) {
        this.unsubscribeAllListeners();
        this.clearMarkers();
        this.clearClusters();
        const isPositionDevice = mo?.c8y_Position && mo?.c8y_IsDevice;
        if (isPositionDevice) {
            this.assets = mo;
            this.refreshMarkers();
            return;
        }
        this.assets = null;
        this.listenToClusterChanges();
        this.reload();
    }
    async getClusterRects(levelThreshold = ClusterSize.FOUR, viewBounds, level = 0) {
        let rects = [];
        if (levelThreshold === ClusterSize.NONE) {
            const rect = await this.getRect(viewBounds);
            rects.push(rect);
            return rects;
        }
        if (level >= levelThreshold) {
            return rects;
        }
        level++;
        const { lat: x1, lng: y1 } = viewBounds.getSouthWest();
        const { lat: x2, lng: y2 } = viewBounds.getNorthEast();
        const newX2 = (x1 + x2) / 2;
        const newY2 = (y1 + y2) / 2;
        const bounds = [
            [
                [x1, y1],
                [newX2, newY2]
            ],
            [
                [newX2, newY2],
                [x2, y2]
            ],
            [
                [x1, newY2],
                [newX2, y2]
            ],
            [
                [newX2, y1],
                [x2, newY2]
            ]
        ];
        for (const bound of bounds) {
            const latLngBound = this.leaflet.latLngBounds(bound);
            const rect = await this.getRect(latLngBound);
            rects = [...rects, ...(await this.getClusterRects(levelThreshold, latLngBound, level))];
            if (level === levelThreshold) {
                rects.push(rect);
            }
        }
        return rects;
    }
    async getRect(latLngBound) {
        let color = 'none';
        if (this.showClusterColor) {
            color = await this.colorService.generateColor(latLngBound.toBBoxString());
        }
        const rect = this.leaflet.rectangle(latLngBound, {
            color,
            weight: color === 'none' ? 0 : 1,
            interactive: false
        });
        return rect;
    }
    clearClusters() {
        this.clusters.forEach(cluster => {
            cluster.clear(this.map);
        });
        this.clusters = [];
    }
    async updateCluster(cluster) {
        const clusterCount = await this.mapService.getPositionMOsFromBoundCount(cluster.rect.getBounds(), this.rootNode);
        if (clusterCount > this.mapService.MAX_DEVICE_PER_CLUSTER) {
            cluster.setClusterToBigMarker(this.map, clusterCount, this.leaflet);
            cluster.positions = [];
            return cluster;
        }
        cluster.removeClusterToBigMarker();
        cluster.positions = await this.mapService.getPositionMOs(cluster.rect.getBounds(), this.rootNode);
        return cluster;
    }
    createOrUpdateCluster(rects) {
        const isNew = rects.length !== this.clusters.length;
        if (isNew) {
            this.clearClusters();
        }
        const updatePromise = rects.map((rect, index) => {
            if (isNew) {
                const cluster = new ClusterMap(this.iterable, asset => this.getAssetMarker(asset), this.translateService);
                this.clusters.push(cluster);
            }
            this.clusters[index].rect = rect;
            return this.updateCluster(this.clusters[index]);
        });
        return Promise.all(updatePromise);
    }
}
ClusterMapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: ClusterMapComponent, deps: [{ token: i1.ManagedObjectRealtimeService }, { token: i2.MapService }, { token: MAP_TILE_LAYER, optional: true }, { token: MAP_DEFAULT_CONFIG, optional: true }, { token: i3.TranslateService }, { token: i0.IterableDiffers }, { token: i1.ColorService }], target: i0.ɵɵFactoryTarget.Component });
ClusterMapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.6", type: ClusterMapComponent, selector: "c8y-cluster-map", inputs: { config: "config", rootNode: "rootNode", assets: ["asset", "assets"], showClusterColor: "showClusterColor" }, outputs: { mapChange: "mapChange" }, providers: [ManagedObjectRealtimeService], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: ClusterMapComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-cluster-map', providers: [ManagedObjectRealtimeService], template: "<div class=\"c8y-map\">\n  <div #map></div>\n</div>\n<ng-content></ng-content>\n" }]
        }], ctorParameters: function () { return [{ type: i1.ManagedObjectRealtimeService }, { type: i2.MapService }, { type: Array, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_TILE_LAYER]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MAP_DEFAULT_CONFIG]
                }] }, { type: i3.TranslateService }, { type: i0.IterableDiffers }, { type: i1.ColorService }]; }, propDecorators: { config: [{
                type: Input
            }], rootNode: [{
                type: Input
            }], assets: [{
                type: Input,
                args: ['asset']
            }], showClusterColor: [{
                type: Input
            }], mapChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2x1c3Rlci1tYXAuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vbWFwL2NsdXN0ZXItbWFwLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uL21hcC9jbHVzdGVyLW1hcC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLGVBQWUsRUFDZixRQUFRLEVBQ1IsTUFBTSxFQUNOLFlBQVksRUFFYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsWUFBWSxFQUFFLDRCQUE0QixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDakYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFdkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0YsT0FBTyxFQUNMLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUNMLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxFQUNULFNBQVMsRUFDVCxHQUFHLEVBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBRUwsV0FBVyxFQUNYLFlBQVksRUFDWixnQkFBZ0IsRUFHaEIsa0JBQWtCLEVBQ2xCLGNBQWMsRUFFZixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7OztBQU8zQyxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsWUFBWTtJQXdCbkQsWUFDWSxpQkFBK0MsRUFDL0MsVUFBc0IsRUFDYyxN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c0VDNUMzQyxrRkFJQTsyRkQwQ2EsbUJBQW1CO2tCQUwvQixTQUFTOytCQUNFLGlCQUFpQixhQUVoQixDQUFDLDRCQUE0QixDQUFDOzhIQTZCZSxLQUFLOzBCQUExRCxRQUFROzswQkFBSSxNQUFNOzJCQUFDLGNBQWM7OzBCQUNqQyxRQUFROzswQkFBSSxNQUFNOzJCQUFDLGtCQUFrQjtvSUF2QnhDLE1BQU07c0JBREwsS0FBSztnQkFJTixRQUFRO3NCQURQLEtBQUs7Z0JBSU4sTUFBTTtzQkFETCxLQUFLO3VCQUFDLE9BQU87Z0JBSWQsZ0JBQWdCO3NCQURmLEtBQUs7Z0JBSU4sU0FBUztzQkFEUixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIEl0ZXJhYmxlRGlmZmVycyxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2ltcGxlQ2hhbmdlLFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU1hbmFnZWRPYmplY3QgfSBmcm9tICdAYzh5L2NsaWVudCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UsIE1hbmFnZWRPYmplY3RSZWFsdGltZVNlcnZpY2UgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB0eXBlICogYXMgTCBmcm9tICdsZWFmbGV0JztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgZnJvbSwgZnJvbUV2ZW50LCBpbnRlcnZhbCwgbWVyZ2UsIE5FVkVSLCBvZiwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgZGVib3VuY2VUaW1lLFxuICBmaWx0ZXIsXG4gIGZpcnN0LFxuICBtYXAsXG4gIG1lcmdlTWFwLFxuICBzd2l0Y2hNYXAsXG4gIHRha2VVbnRpbCxcbiAgdGFwXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENsdXN0ZXJNYXAgfSBmcm9tICcuL2NsdXN0ZXItbWFwJztcbmltcG9ydCB7IE1hcENvbXBvbmVudCB9IGZyb20gJy4vbWFwLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICBDbHVzdGVyTWFwQ29uZmlnLFxuICBDbHVzdGVyU2l6ZSxcbiAgZGVmYXVsdExheWVyLFxuICBkZWZhdWx0TWFwQ29uZmlnLFxuICBNYXBEZWZhdWx0Q29uZmlnLFxuICBNYXBUaWxlTGF5ZXIsXG4gIE1BUF9ERUZBVUxUX0NPTkZJRyxcbiAgTUFQX1RJTEVfTEFZRVIsXG4gIFBvc2l0aW9uTWFuYWdlZE9iamVjdFxufSBmcm9tICcuL21hcC5tb2RlbCc7XG5pbXBvcnQgeyBNYXBTZXJ2aWNlIH0gZnJvbSAnLi9tYXAuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1jbHVzdGVyLW1hcCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jbHVzdGVyLW1hcC5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW01hbmFnZWRPYmplY3RSZWFsdGltZVNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIENsdXN0ZXJNYXBDb21wb25lbnQgZXh0ZW5kcyBNYXBDb21wb25lbnQge1xuICBpc0xvYWRpbmckID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gIG1zVW50aWxSZWZyZXNoJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoNTAwMCk7XG5cbiAgQElucHV0KClcbiAgY29uZmlnOiBDbHVzdGVyTWFwQ29uZmlnO1xuXG4gIEBJbnB1dCgpXG4gIHJvb3ROb2RlOiBJTWFuYWdlZE9iamVjdDtcblxuICBASW5wdXQoJ2Fzc2V0JylcbiAgYXNzZXRzOiBQb3NpdGlvbk1hbmFnZWRPYmplY3Q7XG5cbiAgQElucHV0KClcbiAgc2hvd0NsdXN0ZXJDb2xvciA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKVxuICBtYXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEwuTGVhZmxldEV2ZW50PigpO1xuXG4gIHByaXZhdGUgcmVsb2FkVHJpZ2dlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgcHJpdmF0ZSBjbHVzdGVyczogQ2x1c3Rlck1hcFtdID0gW107XG4gIHByaXZhdGUgcmVhZG9ubHkgTUlOX0lOVEVSVkFMID0gNTAwMDtcbiAgcHJpdmF0ZSByZWFkb25seSBFVkVOVF9USFJPVFRMRV9USU1FID0gNzUwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCBtb1JlYWx0aW1lU2VydmljZTogTWFuYWdlZE9iamVjdFJlYWx0aW1lU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE1BUF9USUxFX0xBWUVSKSBwcm90ZWN0ZWQgbGF5ZXJzOiBBcnJheTxNYXBUaWxlTGF5ZXIgfCBNYXBUaWxlTGF5ZXJbXT4sXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNQVBfREVGQVVMVF9DT05GSUcpIHByb3RlY3RlZCBkZWZhdWx0Q29uZmlnOiBNYXBEZWZhdWx0Q29uZmlnLFxuICAgIHByb3RlY3RlZCB0cmFuc2xhdGVTZXJ2aWNlOiBUcmFuc2xhdGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgaXRlcmFibGU6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICBwcml2YXRlIGNvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKG1vUmVhbHRpbWVTZXJ2aWNlLCBtYXBTZXJ2aWNlLCBsYXllcnMsIGRlZmF1bHRDb25maWcsIHRyYW5zbGF0ZVNlcnZpY2UpO1xuICAgIGlmICghdGhpcy5sYXllcnMpIHtcbiAgICAgIHRoaXMubGF5ZXJzID0gW2RlZmF1bHRMYXllcl07XG4gICAgfVxuICAgIGlmICghdGhpcy5kZWZhdWx0Q29uZmlnKSB7XG4gICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBkZWZhdWx0TWFwQ29uZmlnO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGNlbnRlcjogdGhpcy5kZWZhdWx0Q29uZmlnLmNlbnRlclxuICAgIH07XG4gIH1cblxuICBhc3luYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXMuY29uZmlnPy5maXJzdENoYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLnJvb3ROb2RlPy5wcmV2aW91c1ZhbHVlICE9PSBjaGFuZ2VzLnJvb3ROb2RlPy5jdXJyZW50VmFsdWUpIHtcbiAgICAgIHRoaXMuY2hhbmdlUm9vdE5vZGUoY2hhbmdlcy5yb290Tm9kZS5jdXJyZW50VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmNvbmZpZz8uY3VycmVudFZhbHVlKSB7XG4gICAgICB0aGlzLmNoYW5nZUNvbmZpZyhjaGFuZ2VzLmNvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlQ29uZmlnKGNoYW5nZTogU2ltcGxlQ2hhbmdlKSB7XG4gICAgLy8gb24gZm9sbG93aW5nLCBjYW5jZWwgcmVsb2FkIHRvIGF2b2lkIHN0YWxlIHN0YXRlXG4gICAgaWYgKGNoYW5nZS5jdXJyZW50VmFsdWUuZm9sbG93ID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmNhbmNlbFJlbG9hZCgpO1xuICAgICAgdGhpcy5pc0xvYWRpbmckLm5leHQoZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2UuY3VycmVudFZhbHVlLnJlZnJlc2hJbnRlcnZhbCAhPT0gY2hhbmdlLnByZXZpb3VzVmFsdWUucmVmcmVzaEludGVydmFsKSB7XG4gICAgICB0aGlzLnJlbG9hZCgpO1xuICAgIH1cbiAgICBzdXBlci5jaGFuZ2VDb25maWcoY2hhbmdlKTtcbiAgfVxuXG4gIGFzeW5jIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAoIXRoaXMubGVhZmxldCkge1xuICAgICAgdGhpcy5sZWFmbGV0ID0gYXdhaXQgdGhpcy5tYXBTZXJ2aWNlLmdldExlYWZsZXQoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0TWFwKCk7XG4gICAgdGhpcy5jaGFuZ2VSb290Tm9kZSh0aGlzLnJvb3ROb2RlKTtcbiAgICB0aGlzLmNoYW5nZUNvbmZpZyhuZXcgU2ltcGxlQ2hhbmdlKHt9LCB0aGlzLmNvbmZpZywgZmFsc2UpKTtcbiAgfVxuXG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRoaXMubmdPbkRlc3Ryb3koKTtcbiAgICBhd2FpdCB0aGlzLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuICB9XG5cbiAgcmVsb2FkKCkge1xuICAgIHRoaXMucmVsb2FkVHJpZ2dlciQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIGNhbmNlbFJlbG9hZCgpIHtcbiAgICB0aGlzLnJlbG9hZFRyaWdnZXIkLm5leHQoZmFsc2UpO1xuICB9XG5cbiAgbGlzdGVuVG9DbHVzdGVyQ2hhbmdlcygpIHtcbiAgICBjb25zdCB0aW1lclN0YXJ0JCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgY29uc3QgdGltZXJFbmQkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNvbnN0IGRvY3VtZW50SGlkZGVuRXZlbnQkID0gZnJvbUV2ZW50PGJvb2xlYW4+KGRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScpLnBpcGUoXG4gICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICApO1xuXG4gICAgY29uc3QgaW50ZXJ2YWwkID0gdGltZXJTdGFydCQucGlwZShcbiAgICAgIG1hcCgoKSA9PiB0aGlzLmNvbmZpZy5yZWZyZXNoSW50ZXJ2YWwpLFxuICAgICAgc3dpdGNoTWFwKGNvbmZpZ0ludGVydmFsID0+IHtcbiAgICAgICAgaWYgKCFjb25maWdJbnRlcnZhbCkge1xuICAgICAgICAgIHJldHVybiBORVZFUjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJ2YWwoMTAwMCkucGlwZShcbiAgICAgICAgICBtYXAodmFsdWUgPT4gdmFsdWUgKiAxMDAwKSxcbiAgICAgICAgICB0YXAodmFsdWUgPT4gdGhpcy5tc1VudGlsUmVmcmVzaCQubmV4dChjb25maWdJbnRlcnZhbCAtIHZhbHVlKSksXG4gICAgICAgICAgZmlsdGVyKHZhbHVlID0+IHZhbHVlID49IHRoaXMuTUlOX0lOVEVSVkFMICYmIHZhbHVlID49IGNvbmZpZ0ludGVydmFsKSxcbiAgICAgICAgICBmaXJzdCgpLFxuICAgICAgICAgIHRha2VVbnRpbCh0aW1lckVuZCQpXG4gICAgICAgICk7XG4gICAgICB9KSxcbiAgICAgIHN3aXRjaE1hcCgoKSA9PiAoZG9jdW1lbnQuaGlkZGVuID8gZG9jdW1lbnRIaWRkZW5FdmVudCQgOiBvZih0cnVlKSkpLFxuICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgKTtcblxuICAgIGNvbnN0IG1hcENoYW5nZSQgPSBtZXJnZShcbiAgICAgIGZyb21FdmVudDxMLkxlYWZsZXRFdmVudD4odGhpcy5tYXAsICdtb3ZlJyksXG4gICAgICBmcm9tRXZlbnQ8TC5MZWFmbGV0RXZlbnQ+KHRoaXMubWFwLCAnbW92ZWVuZCcpXG4gICAgKS5waXBlKFxuICAgICAgZGVib3VuY2VUaW1lKHRoaXMuRVZFTlRfVEhST1RUTEVfVElNRSksXG4gICAgICB0YXAoZXZlbnQgPT4gdGhpcy5tYXBDaGFuZ2UuZW1pdChldmVudCkpLFxuICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgKTtcblxuICAgIG1lcmdlKHRoaXMucmVsb2FkVHJpZ2dlciQsIG1hcENoYW5nZSQsIGludGVydmFsJClcbiAgICAgIC5waXBlKFxuICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgIHRpbWVyRW5kJC5uZXh0KHRydWUpO1xuICAgICAgICAgIHRoaXMubXNVbnRpbFJlZnJlc2gkLm5leHQoMCk7XG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmckLm5leHQodHJ1ZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBzd2l0Y2hNYXAodmFsdWUgPT5cbiAgICAgICAgICB2YWx1ZSA9PT0gZmFsc2VcbiAgICAgICAgICAgID8gb2YoW10pXG4gICAgICAgICAgICA6IGZyb20odGhpcy5tYXBTZXJ2aWNlLmdldENsdXN0ZXJTaXplKHRoaXMubWFwLmdldEJvdW5kcygpKSkucGlwZShcbiAgICAgICAgICAgICAgICBtZXJnZU1hcCgoY2x1c3RlclNpemU6IENsdXN0ZXJTaXplKSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDbHVzdGVyUmVjdHMoY2x1c3RlclNpemUsIHRoaXMubWFwLmdldEJvdW5kcygpKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgbWVyZ2VNYXAocmVjdHMgPT4gdGhpcy5jcmVhdGVPclVwZGF0ZUNsdXN0ZXIocmVjdHMpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoY2x1c3RlcnM6IENsdXN0ZXJNYXBbXSkgPT4ge1xuICAgICAgICBjbHVzdGVycy5mb3JFYWNoKGNsdXN0ZXIgPT4gY2x1c3Rlci5yZW5kZXIodGhpcy5tYXApKTtcblxuICAgICAgICB0aGlzLmlzTG9hZGluZyQubmV4dChmYWxzZSk7XG4gICAgICAgIHRpbWVyU3RhcnQkLm5leHQoKTtcbiAgICAgICAgdGhpcy5tc1VudGlsUmVmcmVzaCQubmV4dCh0aGlzLmNvbmZpZy5yZWZyZXNoSW50ZXJ2YWwpO1xuICAgICAgfSk7XG4gIH1cblxuICByZWZyZXNoTWFya2VycygpIHtcbiAgICBpZiAodGhpcy5hc3NldHMpIHtcbiAgICAgIHN1cGVyLnJlZnJlc2hNYXJrZXJzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2x1c3RlcnMuZm9yRWFjaChjbHVzdGVyID0+IHtcbiAgICAgIGNsdXN0ZXIuY2xlYXIodGhpcy5tYXApO1xuICAgIH0pO1xuICAgIHRoaXMucmVsb2FkKCk7XG4gIH1cblxuICBwcml2YXRlIGNoYW5nZVJvb3ROb2RlKG1vOiBJTWFuYWdlZE9iamVjdCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLmNsZWFyTWFya2VycygpO1xuICAgIHRoaXMuY2xlYXJDbHVzdGVycygpO1xuXG4gICAgY29uc3QgaXNQb3NpdGlvbkRldmljZSA9IG1vPy5jOHlfUG9zaXRpb24gJiYgbW8/LmM4eV9Jc0RldmljZTtcbiAgICBpZiAoaXNQb3NpdGlvbkRldmljZSkge1xuICAgICAgdGhpcy5hc3NldHMgPSBtbyBhcyBQb3NpdGlvbk1hbmFnZWRPYmplY3Q7XG4gICAgICB0aGlzLnJlZnJlc2hNYXJrZXJzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXNzZXRzID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlblRvQ2x1c3RlckNoYW5nZXMoKTtcbiAgICB0aGlzLnJlbG9hZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDbHVzdGVyUmVjdHMoXG4gICAgbGV2ZWxUaHJlc2hvbGQ6IENsdXN0ZXJTaXplID0gQ2x1c3RlclNpemUuRk9VUixcbiAgICB2aWV3Qm91bmRzOiBMLkxhdExuZ0JvdW5kcyxcbiAgICBsZXZlbCA9IDBcbiAgKTogUHJvbWlzZTxMLlJlY3RhbmdsZVtdPiB7XG4gICAgbGV0IHJlY3RzID0gW107XG5cbiAgICBpZiAobGV2ZWxUaHJlc2hvbGQgPT09IENsdXN0ZXJTaXplLk5PTkUpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBhd2FpdCB0aGlzLmdldFJlY3Qodmlld0JvdW5kcyk7XG4gICAgICByZWN0cy5wdXNoKHJlY3QpO1xuICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cblxuICAgIGlmIChsZXZlbCA+PSBsZXZlbFRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIHJlY3RzO1xuICAgIH1cbiAgICBsZXZlbCsrO1xuXG4gICAgY29uc3QgeyBsYXQ6IHgxLCBsbmc6IHkxIH0gPSB2aWV3Qm91bmRzLmdldFNvdXRoV2VzdCgpO1xuICAgIGNvbnN0IHsgbGF0OiB4MiwgbG5nOiB5MiB9ID0gdmlld0JvdW5kcy5nZXROb3J0aEVhc3QoKTtcbiAgICBjb25zdCBuZXdYMiA9ICh4MSArIHgyKSAvIDI7XG4gICAgY29uc3QgbmV3WTIgPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgY29uc3QgYm91bmRzOiBbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV1bXSA9IFtcbiAgICAgIFtcbiAgICAgICAgW3gxLCB5MV0sXG4gICAgICAgIFtuZXdYMiwgbmV3WTJdXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICBbbmV3WDIsIG5ld1kyXSxcbiAgICAgICAgW3gyLCB5Ml1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFt4MSwgbmV3WTJdLFxuICAgICAgICBbbmV3WDIsIHkyXVxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgW25ld1gyLCB5MV0sXG4gICAgICAgIFt4MiwgbmV3WTJdXG4gICAgICBdXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGJvdW5kIG9mIGJvdW5kcykge1xuICAgICAgY29uc3QgbGF0TG5nQm91bmQgPSB0aGlzLmxlYWZsZXQubGF0TG5nQm91bmRzKGJvdW5kKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBhd2FpdCB0aGlzLmdldFJlY3QobGF0TG5nQm91bmQpO1xuICAgICAgcmVjdHMgPSBbLi4ucmVjdHMsIC4uLihhd2FpdCB0aGlzLmdldENsdXN0ZXJSZWN0cyhsZXZlbFRocmVzaG9sZCwgbGF0TG5nQm91bmQsIGxldmVsKSldO1xuXG4gICAgICBpZiAobGV2ZWwgPT09IGxldmVsVGhyZXNob2xkKSB7XG4gICAgICAgIHJlY3RzLnB1c2gocmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3RzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRSZWN0KGxhdExuZ0JvdW5kOiBMLkxhdExuZ0JvdW5kcykge1xuICAgIGxldCBjb2xvciA9ICdub25lJztcbiAgICBpZiAodGhpcy5zaG93Q2x1c3RlckNvbG9yKSB7XG4gICAgICBjb2xvciA9IGF3YWl0IHRoaXMuY29sb3JTZXJ2aWNlLmdlbmVyYXRlQ29sb3IobGF0TG5nQm91bmQudG9CQm94U3RyaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCByZWN0ID0gdGhpcy5sZWFmbGV0LnJlY3RhbmdsZShsYXRMbmdCb3VuZCwge1xuICAgICAgY29sb3IsXG4gICAgICB3ZWlnaHQ6IGNvbG9yID09PSAnbm9uZScgPyAwIDogMSxcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhckNsdXN0ZXJzKCkge1xuICAgIHRoaXMuY2x1c3RlcnMuZm9yRWFjaChjbHVzdGVyID0+IHtcbiAgICAgIGNsdXN0ZXIuY2xlYXIodGhpcy5tYXApO1xuICAgIH0pO1xuICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlQ2x1c3RlcihjbHVzdGVyOiBDbHVzdGVyTWFwKSB7XG4gICAgY29uc3QgY2x1c3RlckNvdW50ID0gYXdhaXQgdGhpcy5tYXBTZXJ2aWNlLmdldFBvc2l0aW9uTU9zRnJvbUJvdW5kQ291bnQoXG4gICAgICBjbHVzdGVyLnJlY3QuZ2V0Qm91bmRzKCksXG4gICAgICB0aGlzLnJvb3ROb2RlXG4gICAgKTtcbiAgICBpZiAoY2x1c3RlckNvdW50ID4gdGhpcy5tYXBTZXJ2aWNlLk1BWF9ERVZJQ0VfUEVSX0NMVVNURVIpIHtcbiAgICAgIGNsdXN0ZXIuc2V0Q2x1c3RlclRvQmlnTWFya2VyKHRoaXMubWFwLCBjbHVzdGVyQ291bnQsIHRoaXMubGVhZmxldCk7XG4gICAgICBjbHVzdGVyLnBvc2l0aW9ucyA9IFtdO1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfVxuXG4gICAgY2x1c3Rlci5yZW1vdmVDbHVzdGVyVG9CaWdNYXJrZXIoKTtcbiAgICBjbHVzdGVyLnBvc2l0aW9ucyA9IGF3YWl0IHRoaXMubWFwU2VydmljZS5nZXRQb3NpdGlvbk1PcyhcbiAgICAgIGNsdXN0ZXIucmVjdC5nZXRCb3VuZHMoKSxcbiAgICAgIHRoaXMucm9vdE5vZGVcbiAgICApO1xuICAgIHJldHVybiBjbHVzdGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVPclVwZGF0ZUNsdXN0ZXIocmVjdHM6IEwuUmVjdGFuZ2xlPHVua25vd24+W10pIHtcbiAgICBjb25zdCBpc05ldyA9IHJlY3RzLmxlbmd0aCAhPT0gdGhpcy5jbHVzdGVycy5sZW5ndGg7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICB0aGlzLmNsZWFyQ2x1c3RlcnMoKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlUHJvbWlzZSA9IHJlY3RzLm1hcCgocmVjdCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpc05ldykge1xuICAgICAgICBjb25zdCBjbHVzdGVyID0gbmV3IENsdXN0ZXJNYXAoXG4gICAgICAgICAgdGhpcy5pdGVyYWJsZSxcbiAgICAgICAgICBhc3NldCA9PiB0aGlzLmdldEFzc2V0TWFya2VyKGFzc2V0KSxcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVNlcnZpY2VcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbHVzdGVyc1tpbmRleF0ucmVjdCA9IHJlY3Q7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVDbHVzdGVyKHRoaXMuY2x1c3RlcnNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbCh1cGRhdGVQcm9taXNlKTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImM4eS1tYXBcIj5cbiAgPGRpdiAjbWFwPjwvZGl2PlxuPC9kaXY+XG48bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4iXX0=