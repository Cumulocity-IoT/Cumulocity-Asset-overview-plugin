import { Component, Input, Optional } from '@angular/core';
import { MeasurementRealtimeService } from '@c8y/ngx-components';
import { combineLatest, NEVER } from 'rxjs';
import { distinctUntilChanged, filter, map, pairwise, startWith, tap } from 'rxjs/operators';
import { ContextDashboardComponent } from '@c8y/ngx-components/context-dashboard';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components";
import * as i2 from "@c8y/ngx-components/context-dashboard";
import * as i3 from "@angular/common";
var ColorClass;
(function (ColorClass) {
    ColorClass["danger"] = "text-danger";
    ColorClass["warning"] = "text-warning";
    ColorClass["unknown"] = "";
})(ColorClass || (ColorClass = {}));
export class KpiWidgetViewComponent {
    constructor(measurementRealtime, dashboard) {
        this.measurementRealtime = measurementRealtime;
        this.dashboard = dashboard;
        this.config = { datapoints: [] };
        this.state$ = NEVER;
        // used to differentiate between loading state and empty state
        this.noDataInitiallyInDB = false;
    }
    async ngOnInit() {
        const datapoints = this.config.datapoints || [];
        const datapoint = datapoints.find(tmp => tmp.__active);
        if (!datapoint) {
            return;
        }
        this.state$ = this.setupObservable(datapoint);
    }
    setupObservable(datapoint) {
        this.assignContextFromContextDashboard(datapoint);
        const latestMeasurement$ = this.getLatestMeasurement$(datapoint);
        const lastTwoValues$ = this.getLastTwoValuesOfObservable$(latestMeasurement$);
        const previousValue$ = lastTwoValues$.pipe(map(([previousVal]) => previousVal), startWith(undefined));
        const unit$ = latestMeasurement$.pipe(map(latestMeasurementValue => datapoint.unit || latestMeasurementValue.unit || ''), startWith(''), distinctUntilChanged());
        return combineLatest([
            latestMeasurement$,
            previousValue$,
            this.getTrendOfLatestMeasurements$(lastTwoValues$),
            unit$,
            this.getColorClass$(latestMeasurement$, datapoint)
        ]).pipe(map(([latestMeasurement, previousValue, trend, unit, colorClass]) => {
            return {
                latestMeasurement,
                previousValue,
                trend,
                unit,
                colorClass
            };
        }));
    }
    getLatestMeasurement$(datapoint) {
        return this.measurementRealtime
            .latestValueOfSpecificMeasurement$(datapoint.fragment, datapoint.series, datapoint.__target, 
        // we only need the last two values in case we want to show a trend
        this.config.showTrend ? 2 : 1, 
        // null will be emitted in case no measurement was found initially
        true)
            .pipe(tap(measurement => {
            if (!measurement) {
                this.noDataInitiallyInDB = true;
            }
        }), filter(measurement => !!measurement), map(measurement => {
            return {
                unit: measurement[datapoint.fragment][datapoint.series].unit,
                value: measurement[datapoint.fragment][datapoint.series].value,
                date: measurement.time
            };
        }));
    }
    getColorClass$(measurementAndDatapointCombination$, datapoint) {
        return measurementAndDatapointCombination$.pipe(map(latestMeasurementValue => {
            if (this.inRangeOf(datapoint, latestMeasurementValue.value, 'redRangeMin', 'redRangeMax')) {
                return ColorClass.danger;
            }
            if (this.inRangeOf(datapoint, latestMeasurementValue.value, 'yellowRangeMin', 'yellowRangeMax')) {
                return ColorClass.warning;
            }
            return ColorClass.unknown;
        }), startWith(ColorClass.unknown), distinctUntilChanged());
    }
    getLastTwoValuesOfObservable$(input$) {
        return input$.pipe(pairwise());
    }
    getTrendOfLatestMeasurements$(latestMeasurement$) {
        return latestMeasurement$.pipe(map(res => {
            if (res.length === 2) {
                const oldValue = res[0].value;
                const newValue = res[1].value;
                if (oldValue < newValue) {
                    return '45deg';
                }
                if (oldValue > newValue) {
                    return '135deg';
                }
            }
            return '90deg';
        }), startWith('90deg'), distinctUntilChanged());
    }
    inRangeOf(datapoint, measurementValue, minAttribute, maxAttribute) {
        if (typeof datapoint[minAttribute] === 'number' &&
            typeof datapoint[maxAttribute] === 'number') {
            if (measurementValue >= datapoint[minAttribute] &&
                measurementValue < datapoint[maxAttribute]) {
                return true;
            }
        }
        return false;
    }
    assignContextFromContextDashboard(datapoint) {
        if (!this.dashboard?.isDeviceTypeDashboard) {
            return;
        }
        const context = this.dashboard?.context;
        if (context?.id) {
            const { name, id } = context;
            datapoint.__target = { name, id };
        }
    }
}
KpiWidgetViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: KpiWidgetViewComponent, deps: [{ token: i1.MeasurementRealtimeService }, { token: i2.ContextDashboardComponent, optional: true }], target: i0.ɵɵFactoryTarget.Component });
KpiWidgetViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.6", type: KpiWidgetViewComponent, selector: "c8y-kpi-widget-view", inputs: { config: "config" }, providers: [MeasurementRealtimeService], ngImport: i0, template: "<div\n  class=\"kpi-widget__container d-flex d-col fit-h fit-w a-i-center j-c-center\"\n  *ngIf=\"state$ | async as lastState; else noMeasurementFound\"\n>\n  <div class=\"d-flex a-i-center j-c-center fit-w\">\n    <div\n      class=\"m-r-16 flex-no-shrink text-muted\"\n      [ngClass]=\"lastState.colorClass\"\n      *ngIf=\"config.icon && config.showIcon\"\n    >\n      <i class=\"icon-32\" [c8yIcon]=\"config.icon\"></i>\n    </div>\n    <div class=\"text-truncate\">\n      <span\n        class=\"text-truncate text-medium\"\n        [ngClass]=\"lastState.colorClass\"\n        [ngStyle]=\"{ 'font-size': (config.fontSize || '36') + 'px' }\"\n        title=\"{{\n          lastState.colorClass === 'text-danger'\n            ? ('Within red range:' | translate)\n            : lastState.colorClass === 'text-warning'\n            ? ('Within yellow range:' | translate)\n            : ''\n        }} {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }} {{ lastState.unit || '' }}\"\n      >\n        {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }}\n        <small class=\"text-regular\">{{ lastState.unit || '' }}</small>\n      </span>\n    </div>\n    <div\n      class=\"dot dot-info dot-30 m-l-16 flex-no-shrink\"\n      *ngIf=\"config?.showTrend && lastState.previousValue as previousValue\"\n    >\n      <i\n        class=\"icon-20\"\n        [title]=\"\n          ('Previous value' | translate) +\n          ': ' +\n          (previousValue.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')) +\n          ' (' +\n          (previousValue.date | date: 'medium') +\n          ')'\n        \"\n        c8yIcon=\"arrow-dotted-up\"\n        [ngStyle]=\"{ transform: 'rotate(' + lastState.trend + ')' }\"\n      ></i>\n    </div>\n  </div>\n  <div class=\"d-flex j-c-center\">\n    <p *ngIf=\"config?.showTimestamp\" class=\"icon-flex text-center text-muted small\">\n      <i c8yIcon=\"calendar\"></i>\n      {{ lastState.latestMeasurement.date | date: 'medium' }}\n    </p>\n  </div>\n</div>\n\n<ng-template #noMeasurementFound>\n  <div class=\"d-flex fit-h fit-w j-c-center a-i-center\">\n    <c8y-ui-empty-state\n      *ngIf=\"noDataInitiallyInDB\"\n      class=\"fit-w\"\n      [icon]=\"'line-chart'\"\n      [title]=\"'No measurement to display.' | translate\"\n      [subtitle]=\"'Waiting for measurements to be created.' | translate\"\n      [horizontal]=\"true\"\n    ></c8y-ui-empty-state>\n    <c8y-loading *ngIf=\"!noDataInitiallyInDB\"></c8y-loading>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "component", type: i1.EmptyStateComponent, selector: "c8y-ui-empty-state", inputs: ["icon", "title", "subtitle", "horizontal"] }, { kind: "directive", type: i1.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: i1.LoadingComponent, selector: "c8y-loading" }, { kind: "pipe", type: i1.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.DecimalPipe, name: "number" }, { kind: "pipe", type: i3.DatePipe, name: "date" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: KpiWidgetViewComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-kpi-widget-view', providers: [MeasurementRealtimeService], template: "<div\n  class=\"kpi-widget__container d-flex d-col fit-h fit-w a-i-center j-c-center\"\n  *ngIf=\"state$ | async as lastState; else noMeasurementFound\"\n>\n  <div class=\"d-flex a-i-center j-c-center fit-w\">\n    <div\n      class=\"m-r-16 flex-no-shrink text-muted\"\n      [ngClass]=\"lastState.colorClass\"\n      *ngIf=\"config.icon && config.showIcon\"\n    >\n      <i class=\"icon-32\" [c8yIcon]=\"config.icon\"></i>\n    </div>\n    <div class=\"text-truncate\">\n      <span\n        class=\"text-truncate text-medium\"\n        [ngClass]=\"lastState.colorClass\"\n        [ngStyle]=\"{ 'font-size': (config.fontSize || '36') + 'px' }\"\n        title=\"{{\n          lastState.colorClass === 'text-danger'\n            ? ('Within red range:' | translate)\n            : lastState.colorClass === 'text-warning'\n            ? ('Within yellow range:' | translate)\n            : ''\n        }} {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }} {{ lastState.unit || '' }}\"\n      >\n        {{\n          lastState.latestMeasurement.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')\n        }}\n        <small class=\"text-regular\">{{ lastState.unit || '' }}</small>\n      </span>\n    </div>\n    <div\n      class=\"dot dot-info dot-30 m-l-16 flex-no-shrink\"\n      *ngIf=\"config?.showTrend && lastState.previousValue as previousValue\"\n    >\n      <i\n        class=\"icon-20\"\n        [title]=\"\n          ('Previous value' | translate) +\n          ': ' +\n          (previousValue.value\n            | number\n              : '1.' +\n                  (config.numberOfDecimalPlaces || '0') +\n                  '-' +\n                  (config.numberOfDecimalPlaces || '0')) +\n          ' (' +\n          (previousValue.date | date: 'medium') +\n          ')'\n        \"\n        c8yIcon=\"arrow-dotted-up\"\n        [ngStyle]=\"{ transform: 'rotate(' + lastState.trend + ')' }\"\n      ></i>\n    </div>\n  </div>\n  <div class=\"d-flex j-c-center\">\n    <p *ngIf=\"config?.showTimestamp\" class=\"icon-flex text-center text-muted small\">\n      <i c8yIcon=\"calendar\"></i>\n      {{ lastState.latestMeasurement.date | date: 'medium' }}\n    </p>\n  </div>\n</div>\n\n<ng-template #noMeasurementFound>\n  <div class=\"d-flex fit-h fit-w j-c-center a-i-center\">\n    <c8y-ui-empty-state\n      *ngIf=\"noDataInitiallyInDB\"\n      class=\"fit-w\"\n      [icon]=\"'line-chart'\"\n      [title]=\"'No measurement to display.' | translate\"\n      [subtitle]=\"'Waiting for measurements to be created.' | translate\"\n      [horizontal]=\"true\"\n    ></c8y-ui-empty-state>\n    <c8y-loading *ngIf=\"!noDataInitiallyInDB\"></c8y-loading>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.MeasurementRealtimeService }, { type: i2.ContextDashboardComponent, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { config: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia3BpLXdpZGdldC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3dpZGdldHMvaW1wbGVtZW50YXRpb25zL2twaS9rcGktd2lkZ2V0LXZpZXcva3BpLXdpZGdldC12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3dpZGdldHMvaW1wbGVtZW50YXRpb25zL2twaS9rcGktd2lkZ2V0LXZpZXcva3BpLXdpZGdldC12aWV3LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVqRSxPQUFPLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUN4RCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdGLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHVDQUF1QyxDQUFDOzs7OztBQVNsRixJQUFLLFVBSUo7QUFKRCxXQUFLLFVBQVU7SUFDYixvQ0FBc0IsQ0FBQTtJQUN0QixzQ0FBd0IsQ0FBQTtJQUN4QiwwQkFBWSxDQUFBO0FBQ2QsQ0FBQyxFQUpJLFVBQVUsS0FBVixVQUFVLFFBSWQ7QUFPRCxNQUFNLE9BQU8sc0JBQXNCO0lBYWpDLFlBQ1UsbUJBQStDLEVBQ25DLFNBQW9DO1FBRGhELHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBNEI7UUFDbkMsY0FBUyxHQUFULFNBQVMsQ0FBMkI7UUFkakQsV0FBTSxHQUFvQixFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUN0RCxXQUFNLEdBTUQsS0FBSyxDQUFDO1FBRVgsOERB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QXFCLGFBRXBCLENBQUMsMEJBQTBCLENBQUM7OzBCQWlCcEMsUUFBUTs0Q0FkRixNQUFNO3NCQUFkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgS1BJRGV0YWlscyB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvZGF0YXBvaW50LXNlbGVjdG9yJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QsIE5FVkVSLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHBhaXJ3aXNlLCBzdGFydFdpdGgsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENvbnRleHREYXNoYm9hcmRDb21wb25lbnQgfSBmcm9tICdAYzh5L25neC1jb21wb25lbnRzL2NvbnRleHQtZGFzaGJvYXJkJztcbmltcG9ydCB7IEtwaVdpZGdldENvbmZpZyB9IGZyb20gJy4uL2twaS13aWRnZXQubW9kZWwnO1xuXG5pbnRlcmZhY2UgTWVhc3VyZW1lbnRWYWx1ZSB7XG4gIHVuaXQ/OiBzdHJpbmc7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGRhdGU6IHN0cmluZztcbn1cblxuZW51bSBDb2xvckNsYXNzIHtcbiAgZGFuZ2VyID0gJ3RleHQtZGFuZ2VyJyxcbiAgd2FybmluZyA9ICd0ZXh0LXdhcm5pbmcnLFxuICB1bmtub3duID0gJydcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYzh5LWtwaS13aWRnZXQtdmlldycsXG4gIHRlbXBsYXRlVXJsOiAnLi9rcGktd2lkZ2V0LXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgS3BpV2lkZ2V0Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgpIGNvbmZpZzogS3BpV2lkZ2V0Q29uZmlnID0geyBkYXRhcG9pbnRzOiBbXSB9O1xuICBzdGF0ZSQ6IE9ic2VydmFibGU8e1xuICAgIGxhdGVzdE1lYXN1cmVtZW50OiBNZWFzdXJlbWVudFZhbHVlO1xuICAgIHByZXZpb3VzVmFsdWU6IE1lYXN1cmVtZW50VmFsdWUgfCB1bmRlZmluZWQ7XG4gICAgdHJlbmQ6IHN0cmluZztcbiAgICB1bml0OiBzdHJpbmc7XG4gICAgY29sb3JDbGFzczogQ29sb3JDbGFzcztcbiAgfT4gPSBORVZFUjtcblxuICAvLyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsb2FkaW5nIHN0YXRlIGFuZCBlbXB0eSBzdGF0ZVxuICBub0RhdGFJbml0aWFsbHlJbkRCID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBtZWFzdXJlbWVudFJlYWx0aW1lOiBNZWFzdXJlbWVudFJlYWx0aW1lU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRhc2hib2FyZDogQ29udGV4dERhc2hib2FyZENvbXBvbmVudFxuICApIHt9XG5cbiAgYXN5bmMgbmdPbkluaXQoKSB7XG4gICAgY29uc3QgZGF0YXBvaW50cyA9IHRoaXMuY29uZmlnLmRhdGFwb2ludHMgfHwgW107XG4gICAgY29uc3QgZGF0YXBvaW50OiBLUElEZXRhaWxzID0gZGF0YXBvaW50cy5maW5kKHRtcCA9PiB0bXAuX19hY3RpdmUpO1xuICAgIGlmICghZGF0YXBvaW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSQgPSB0aGlzLnNldHVwT2JzZXJ2YWJsZShkYXRhcG9pbnQpO1xuICB9XG5cbiAgc2V0dXBPYnNlcnZhYmxlKGRhdGFwb2ludDogS1BJRGV0YWlscyk6IE9ic2VydmFibGU8e1xuICAgIGxhdGVzdE1lYXN1cmVtZW50OiBNZWFzdXJlbWVudFZhbHVlO1xuICAgIHByZXZpb3VzVmFsdWU6IE1lYXN1cmVtZW50VmFsdWUgfCB1bmRlZmluZWQ7XG4gICAgdHJlbmQ6IHN0cmluZztcbiAgICB1bml0OiBzdHJpbmc7XG4gICAgY29sb3JDbGFzczogQ29sb3JDbGFzcztcbiAgfT4ge1xuICAgIHRoaXMuYXNzaWduQ29udGV4dEZyb21Db250ZXh0RGFzaGJvYXJkKGRhdGFwb2ludCk7XG4gICAgY29uc3QgbGF0ZXN0TWVhc3VyZW1lbnQkID0gdGhpcy5nZXRMYXRlc3RNZWFzdXJlbWVudCQoZGF0YXBvaW50KTtcbiAgICBjb25zdCBsYXN0VHdvVmFsdWVzJCA9IHRoaXMuZ2V0TGFzdFR3b1ZhbHVlc09mT2JzZXJ2YWJsZSQobGF0ZXN0TWVhc3VyZW1lbnQkKTtcblxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUkID0gbGFzdFR3b1ZhbHVlcyQucGlwZShcbiAgICAgIG1hcCgoW3ByZXZpb3VzVmFsXSkgPT4gcHJldmlvdXNWYWwpLFxuICAgICAgc3RhcnRXaXRoKHVuZGVmaW5lZCBhcyBNZWFzdXJlbWVudFZhbHVlIHwgdW5kZWZpbmVkKVxuICAgICk7XG5cbiAgICBjb25zdCB1bml0JCA9IGxhdGVzdE1lYXN1cmVtZW50JC5waXBlKFxuICAgICAgbWFwKGxhdGVzdE1lYXN1cmVtZW50VmFsdWUgPT4gZGF0YXBvaW50LnVuaXQgfHwgbGF0ZXN0TWVhc3VyZW1lbnRWYWx1ZS51bml0IHx8ICcnKSxcbiAgICAgIHN0YXJ0V2l0aCgnJyksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKTtcblxuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtcbiAgICAgIGxhdGVzdE1lYXN1cmVtZW50JCxcbiAgICAgIHByZXZpb3VzVmFsdWUkLFxuICAgICAgdGhpcy5nZXRUcmVuZE9mTGF0ZXN0TWVhc3VyZW1lbnRzJChsYXN0VHdvVmFsdWVzJCksXG4gICAgICB1bml0JCxcbiAgICAgIHRoaXMuZ2V0Q29sb3JDbGFzcyQobGF0ZXN0TWVhc3VyZW1lbnQkLCBkYXRhcG9pbnQpXG4gICAgXSkucGlwZShcbiAgICAgIG1hcCgoW2xhdGVzdE1lYXN1cmVtZW50LCBwcmV2aW91c1ZhbHVlLCB0cmVuZCwgdW5pdCwgY29sb3JDbGFzc10pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYXRlc3RNZWFzdXJlbWVudCxcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgIHRyZW5kLFxuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgY29sb3JDbGFzc1xuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMYXRlc3RNZWFzdXJlbWVudCQoZGF0YXBvaW50OiBLUElEZXRhaWxzKTogT2JzZXJ2YWJsZTxNZWFzdXJlbWVudFZhbHVlPiB7XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZW1lbnRSZWFsdGltZVxuICAgICAgLmxhdGVzdFZhbHVlT2ZTcGVjaWZpY01lYXN1cmVtZW50JChcbiAgICAgICAgZGF0YXBvaW50LmZyYWdtZW50LFxuICAgICAgICBkYXRhcG9pbnQuc2VyaWVzLFxuICAgICAgICBkYXRhcG9pbnQuX190YXJnZXQsXG4gICAgICAgIC8vIHdlIG9ubHkgbmVlZCB0aGUgbGFzdCB0d28gdmFsdWVzIGluIGNhc2Ugd2Ugd2FudCB0byBzaG93IGEgdHJlbmRcbiAgICAgICAgdGhpcy5jb25maWcuc2hvd1RyZW5kID8gMiA6IDEsXG4gICAgICAgIC8vIG51bGwgd2lsbCBiZSBlbWl0dGVkIGluIGNhc2Ugbm8gbWVhc3VyZW1lbnQgd2FzIGZvdW5kIGluaXRpYWxseVxuICAgICAgICB0cnVlXG4gICAgICApXG4gICAgICAucGlwZShcbiAgICAgICAgdGFwKG1lYXN1cmVtZW50ID0+IHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm5vRGF0YUluaXRpYWxseUluREIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcihtZWFzdXJlbWVudCA9PiAhIW1lYXN1cmVtZW50KSxcbiAgICAgICAgbWFwKG1lYXN1cmVtZW50ID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5pdDogbWVhc3VyZW1lbnRbZGF0YXBvaW50LmZyYWdtZW50XVtkYXRhcG9pbnQuc2VyaWVzXS51bml0LFxuICAgICAgICAgICAgdmFsdWU6IG1lYXN1cmVtZW50W2RhdGFwb2ludC5mcmFnbWVudF1bZGF0YXBvaW50LnNlcmllc10udmFsdWUsXG4gICAgICAgICAgICBkYXRlOiBtZWFzdXJlbWVudC50aW1lIGFzIHN0cmluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2xvckNsYXNzJChcbiAgICBtZWFzdXJlbWVudEFuZERhdGFwb2ludENvbWJpbmF0aW9uJDogT2JzZXJ2YWJsZTxNZWFzdXJlbWVudFZhbHVlPixcbiAgICBkYXRhcG9pbnQ6IEtQSURldGFpbHNcbiAgKTogT2JzZXJ2YWJsZTxDb2xvckNsYXNzPiB7XG4gICAgcmV0dXJuIG1lYXN1cmVtZW50QW5kRGF0YXBvaW50Q29tYmluYXRpb24kLnBpcGUoXG4gICAgICBtYXAobGF0ZXN0TWVhc3VyZW1lbnRWYWx1ZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmluUmFuZ2VPZihkYXRhcG9pbnQsIGxhdGVzdE1lYXN1cmVtZW50VmFsdWUudmFsdWUsICdyZWRSYW5nZU1pbicsICdyZWRSYW5nZU1heCcpKSB7XG4gICAgICAgICAgcmV0dXJuIENvbG9yQ2xhc3MuZGFuZ2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuaW5SYW5nZU9mKFxuICAgICAgICAgICAgZGF0YXBvaW50LFxuICAgICAgICAgICAgbGF0ZXN0TWVhc3VyZW1lbnRWYWx1ZS52YWx1ZSxcbiAgICAgICAgICAgICd5ZWxsb3dSYW5nZU1pbicsXG4gICAgICAgICAgICAneWVsbG93UmFuZ2VNYXgnXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gQ29sb3JDbGFzcy53YXJuaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvbG9yQ2xhc3MudW5rbm93bjtcbiAgICAgIH0pLFxuICAgICAgc3RhcnRXaXRoKENvbG9yQ2xhc3MudW5rbm93biksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGFzdFR3b1ZhbHVlc09mT2JzZXJ2YWJsZSQ8VD4oaW5wdXQkOiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gaW5wdXQkLnBpcGUocGFpcndpc2UoKSk7XG4gIH1cblxuICBwcml2YXRlIGdldFRyZW5kT2ZMYXRlc3RNZWFzdXJlbWVudHMkKGxhdGVzdE1lYXN1cmVtZW50JDogT2JzZXJ2YWJsZTxNZWFzdXJlbWVudFZhbHVlW10+KSB7XG4gICAgcmV0dXJuIGxhdGVzdE1lYXN1cmVtZW50JC5waXBlKFxuICAgICAgbWFwKHJlcyA9PiB7XG4gICAgICAgIGlmIChyZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSByZXNbMF0udmFsdWU7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSByZXNbMV0udmFsdWU7XG4gICAgICAgICAgaWYgKG9sZFZhbHVlIDwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAnNDVkZWcnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkVmFsdWUgPiBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcxMzVkZWcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzkwZGVnJztcbiAgICAgIH0pLFxuICAgICAgc3RhcnRXaXRoKCc5MGRlZycpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGluUmFuZ2VPZihcbiAgICBkYXRhcG9pbnQ6IEtQSURldGFpbHMsXG4gICAgbWVhc3VyZW1lbnRWYWx1ZTogbnVtYmVyLFxuICAgIG1pbkF0dHJpYnV0ZTogc3RyaW5nLFxuICAgIG1heEF0dHJpYnV0ZTogc3RyaW5nXG4gICk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkYXRhcG9pbnRbbWluQXR0cmlidXRlXSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiBkYXRhcG9pbnRbbWF4QXR0cmlidXRlXSA9PT0gJ251bWJlcidcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgbWVhc3VyZW1lbnRWYWx1ZSA+PSBkYXRhcG9pbnRbbWluQXR0cmlidXRlXSAmJlxuICAgICAgICBtZWFzdXJlbWVudFZhbHVlIDwgZGF0YXBvaW50W21heEF0dHJpYnV0ZV1cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NpZ25Db250ZXh0RnJvbUNvbnRleHREYXNoYm9hcmQoZGF0YXBvaW50OiBLUElEZXRhaWxzKSB7XG4gICAgaWYgKCF0aGlzLmRhc2hib2FyZD8uaXNEZXZpY2VUeXBlRGFzaGJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmRhc2hib2FyZD8uY29udGV4dDtcbiAgICBpZiAoY29udGV4dD8uaWQpIHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgaWQgfSA9IGNvbnRleHQ7XG4gICAgICBkYXRhcG9pbnQuX190YXJnZXQgPSB7IG5hbWUsIGlkIH07XG4gICAgfVxuICB9XG59XG4iLCI8ZGl2XG4gIGNsYXNzPVwia3BpLXdpZGdldF9fY29udGFpbmVyIGQtZmxleCBkLWNvbCBmaXQtaCBmaXQtdyBhLWktY2VudGVyIGotYy1jZW50ZXJcIlxuICAqbmdJZj1cInN0YXRlJCB8IGFzeW5jIGFzIGxhc3RTdGF0ZTsgZWxzZSBub01lYXN1cmVtZW50Rm91bmRcIlxuPlxuICA8ZGl2IGNsYXNzPVwiZC1mbGV4IGEtaS1jZW50ZXIgai1jLWNlbnRlciBmaXQtd1wiPlxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwibS1yLTE2IGZsZXgtbm8tc2hyaW5rIHRleHQtbXV0ZWRcIlxuICAgICAgW25nQ2xhc3NdPVwibGFzdFN0YXRlLmNvbG9yQ2xhc3NcIlxuICAgICAgKm5nSWY9XCJjb25maWcuaWNvbiAmJiBjb25maWcuc2hvd0ljb25cIlxuICAgID5cbiAgICAgIDxpIGNsYXNzPVwiaWNvbi0zMlwiIFtjOHlJY29uXT1cImNvbmZpZy5pY29uXCI+PC9pPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ0ZXh0LXRydW5jYXRlXCI+XG4gICAgICA8c3BhblxuICAgICAgICBjbGFzcz1cInRleHQtdHJ1bmNhdGUgdGV4dC1tZWRpdW1cIlxuICAgICAgICBbbmdDbGFzc109XCJsYXN0U3RhdGUuY29sb3JDbGFzc1wiXG4gICAgICAgIFtuZ1N0eWxlXT1cInsgJ2ZvbnQtc2l6ZSc6IChjb25maWcuZm9udFNpemUgfHwgJzM2JykgKyAncHgnIH1cIlxuICAgICAgICB0aXRsZT1cInt7XG4gICAgICAgICAgbGFzdFN0YXRlLmNvbG9yQ2xhc3MgPT09ICd0ZXh0LWRhbmdlcidcbiAgICAgICAgICAgID8gKCdXaXRoaW4gcmVkIHJhbmdlOicgfCB0cmFuc2xhdGUpXG4gICAgICAgICAgICA6IGxhc3RTdGF0ZS5jb2xvckNsYXNzID09PSAndGV4dC13YXJuaW5nJ1xuICAgICAgICAgICAgPyAoJ1dpdGhpbiB5ZWxsb3cgcmFuZ2U6JyB8IHRyYW5zbGF0ZSlcbiAgICAgICAgICAgIDogJydcbiAgICAgICAgfX0ge3tcbiAgICAgICAgICBsYXN0U3RhdGUubGF0ZXN0TWVhc3VyZW1lbnQudmFsdWVcbiAgICAgICAgICAgIHwgbnVtYmVyXG4gICAgICAgICAgICAgIDogJzEuJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpICtcbiAgICAgICAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpXG4gICAgICAgIH19IHt7IGxhc3RTdGF0ZS51bml0IHx8ICcnIH19XCJcbiAgICAgID5cbiAgICAgICAge3tcbiAgICAgICAgICBsYXN0U3RhdGUubGF0ZXN0TWVhc3VyZW1lbnQudmFsdWVcbiAgICAgICAgICAgIHwgbnVtYmVyXG4gICAgICAgICAgICAgIDogJzEuJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpICtcbiAgICAgICAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpXG4gICAgICAgIH19XG4gICAgICAgIDxzbWFsbCBjbGFzcz1cInRleHQtcmVndWxhclwiPnt7IGxhc3RTdGF0ZS51bml0IHx8ICcnIH19PC9zbWFsbD5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICBjbGFzcz1cImRvdCBkb3QtaW5mbyBkb3QtMzAgbS1sLTE2IGZsZXgtbm8tc2hyaW5rXCJcbiAgICAgICpuZ0lmPVwiY29uZmlnPy5zaG93VHJlbmQgJiYgbGFzdFN0YXRlLnByZXZpb3VzVmFsdWUgYXMgcHJldmlvdXNWYWx1ZVwiXG4gICAgPlxuICAgICAgPGlcbiAgICAgICAgY2xhc3M9XCJpY29uLTIwXCJcbiAgICAgICAgW3RpdGxlXT1cIlxuICAgICAgICAgICgnUHJldmlvdXMgdmFsdWUnIHwgdHJhbnNsYXRlKSArXG4gICAgICAgICAgJzogJyArXG4gICAgICAgICAgKHByZXZpb3VzVmFsdWUudmFsdWVcbiAgICAgICAgICAgIHwgbnVtYmVyXG4gICAgICAgICAgICAgIDogJzEuJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpICtcbiAgICAgICAgICAgICAgICAgICctJyArXG4gICAgICAgICAgICAgICAgICAoY29uZmlnLm51bWJlck9mRGVjaW1hbFBsYWNlcyB8fCAnMCcpKSArXG4gICAgICAgICAgJyAoJyArXG4gICAgICAgICAgKHByZXZpb3VzVmFsdWUuZGF0ZSB8IGRhdGU6ICdtZWRpdW0nKSArXG4gICAgICAgICAgJyknXG4gICAgICAgIFwiXG4gICAgICAgIGM4eUljb249XCJhcnJvdy1kb3R0ZWQtdXBcIlxuICAgICAgICBbbmdTdHlsZV09XCJ7IHRyYW5zZm9ybTogJ3JvdGF0ZSgnICsgbGFzdFN0YXRlLnRyZW5kICsgJyknIH1cIlxuICAgICAgPjwvaT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJkLWZsZXggai1jLWNlbnRlclwiPlxuICAgIDxwICpuZ0lmPVwiY29uZmlnPy5zaG93VGltZXN0YW1wXCIgY2xhc3M9XCJpY29uLWZsZXggdGV4dC1jZW50ZXIgdGV4dC1tdXRlZCBzbWFsbFwiPlxuICAgICAgPGkgYzh5SWNvbj1cImNhbGVuZGFyXCI+PC9pPlxuICAgICAge3sgbGFzdFN0YXRlLmxhdGVzdE1lYXN1cmVtZW50LmRhdGUgfCBkYXRlOiAnbWVkaXVtJyB9fVxuICAgIDwvcD5cbiAgPC9kaXY+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNub01lYXN1cmVtZW50Rm91bmQ+XG4gIDxkaXYgY2xhc3M9XCJkLWZsZXggZml0LWggZml0LXcgai1jLWNlbnRlciBhLWktY2VudGVyXCI+XG4gICAgPGM4eS11aS1lbXB0eS1zdGF0ZVxuICAgICAgKm5nSWY9XCJub0RhdGFJbml0aWFsbHlJbkRCXCJcbiAgICAgIGNsYXNzPVwiZml0LXdcIlxuICAgICAgW2ljb25dPVwiJ2xpbmUtY2hhcnQnXCJcbiAgICAgIFt0aXRsZV09XCInTm8gbWVhc3VyZW1lbnQgdG8gZGlzcGxheS4nIHwgdHJhbnNsYXRlXCJcbiAgICAgIFtzdWJ0aXRsZV09XCInV2FpdGluZyBmb3IgbWVhc3VyZW1lbnRzIHRvIGJlIGNyZWF0ZWQuJyB8IHRyYW5zbGF0ZVwiXG4gICAgICBbaG9yaXpvbnRhbF09XCJ0cnVlXCJcbiAgICA+PC9jOHktdWktZW1wdHktc3RhdGU+XG4gICAgPGM4eS1sb2FkaW5nICpuZ0lmPVwiIW5vRGF0YUluaXRpYWxseUluREJcIj48L2M4eS1sb2FkaW5nPlxuICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG4iXX0=