import { Component, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { DashboardChildActionComponent } from './dashboard-child-action.component';
import { DashboardChildComponent } from './dashboard-child.component';
import { WidgetsDashboardEventService } from './widgets-dashboard-event.service';
import { FormGroup } from '@angular/forms';
import { gettext } from '../i18n';
import { ActivatedRoute, Router } from '@angular/router';
import { filter } from 'rxjs/operators';
import { DateContextQueryParams, TimeSpanInMs } from './widget-time-context.model';
import * as i0 from "@angular/core";
import * as i1 from "./widgets-dashboard-event.service";
import * as i2 from "./dashboard-child.component";
import * as i3 from "@angular/router";
import * as i4 from "../common/icon.directive";
import * as i5 from "../i18n/c8y-translate.directive";
import * as i6 from "@angular/common";
import * as i7 from "../action-bar/action-bar-item.component";
import * as i8 from "ngx-bootstrap/dropdown";
import * as i9 from "@angular/forms";
import * as i10 from "@ngx-formly/core";
import * as i11 from "./dashboard-child-action.component";
import * as i12 from "../i18n/c8y-translate.pipe";
import * as i13 from "../common/date.pipe";
export class WidgetTimeContextComponent {
    /**
     * @ignore only DI.
     */
    constructor(widgetEventService, dashboardChild, router, activatedRoute) {
        this.widgetEventService = widgetEventService;
        this.dashboardChild = dashboardChild;
        this.router = router;
        this.activatedRoute = activatedRoute;
        /**
         * Indicates if the component can decouple or not.
         */
        this.canDecouple = true;
        /**
         * Emits each change as an array of dates [from, to].
         */
        this.dateContextChange = new EventEmitter();
        /**
         * Indicates if the time context is bound to the global scope.
         */
        this.isCoupled = true;
        this.decoupleTimeContextLabel = gettext('Decouple time context');
        this.coupleTimeContextLabel = gettext('Couple time context');
        this.currentPredefinedTimeSpan = null;
        this.setPredefinedDates();
    }
    /**
     * @ignore Subscribing to the global context.
     */
    ngOnInit() {
        const initialDate = this.getInitialDate();
        this.initForm(initialDate);
        this.subscribeToGlobalContext();
        this.update(initialDate);
        this.subscribeToQueryParamsChange();
    }
    /**
     * @ignore Adding custom actions.
     */
    ngAfterViewInit() {
        if (this.canDecouple) {
            this.dashboardChild.addActions([this.action]);
        }
    }
    /**
     * Toggles the coupling on or off.
     */
    toggleDecoupling() {
        this.isCoupled = !this.isCoupled;
        if (this.isCoupled) {
            this.subscribeToGlobalContext();
            this.globalDate = this.widgetEventService.getLastValue('TIME_CONTEXT');
            this.updateFormValues(this.globalDate);
            this.dateContextChange.emit(this.globalDate);
        }
        else {
            this.unsubscribeFromGlobalContext();
            if (!this.localDate) {
                this.localDate = this.globalDate;
            }
            this.updateFormValues(this.localDate);
        }
    }
    /**
     * Applies form value to global or local date context.
     */
    applyDatetimeContext() {
        this.update([new Date(this.form.value.fromDate), new Date(this.form.value.toDate)]);
    }
    /**
     * Resets form to initial value and update context.
     */
    reset() {
        this.updateDefaultDate();
        this.updateFormValues(this.defaultDate);
        this.update(this.defaultDate);
    }
    /**
     * @ignore unsubscribing.
     */
    ngOnDestroy() {
        this.unsubscribeFromGlobalContext();
    }
    predefinedDateFromSelected(selectedDateFrom) {
        this.updateDefaultDate();
        const calculatedDateFrom = new Date(this.defaultDate[1].valueOf() - selectedDateFrom.timeSpanInMs);
        this.update([calculatedDateFrom, this.defaultDate[1]], selectedDateFrom);
    }
    updateDefaultDate() {
        const todayDate = new Date();
        const yesterdayDate = new Date(todayDate.valueOf() - 1000 * 60 * 60 * 24);
        this.defaultDate = [yesterdayDate, todayDate];
    }
    setPredefinedDates() {
        this.updateDefaultDate();
        const todayDateCopy = new Date(this.defaultDate[1].valueOf());
        const lastMonthTimeSpan = todayDateCopy.valueOf() -
            new Date(todayDateCopy.setMonth(todayDateCopy.getMonth() - 1)).valueOf();
        this.predefinedTimeSpanList = [
            { title: gettext('Last minute'), timeSpanInMs: TimeSpanInMs.MINUTE },
            { title: gettext('Last hour'), timeSpanInMs: TimeSpanInMs.HOUR },
            { title: gettext('Last day'), timeSpanInMs: TimeSpanInMs.DAY },
            { title: gettext('Last week'), timeSpanInMs: TimeSpanInMs.WEEK },
            { title: gettext('Last month'), timeSpanInMs: lastMonthTimeSpan }
        ];
    }
    /**
     * Initializes datetime picker form with proper fields and initial value.
     * @param initialValue Value to fill form with.
     */
    initForm(initialValue) {
        this.form = new FormGroup({});
        this.fields = [
            {
                type: 'date-time',
                key: 'fromDate',
                templateOptions: {
                    label: gettext('From`date`')
                },
                expressionProperties: {
                    'templateOptions.maxDate': (model) => model?.toDate
                }
            },
            {
                type: 'date-time',
                key: 'toDate',
                templateOptions: {
                    label: gettext('To`date`')
                },
                expressionProperties: {
                    'templateOptions.minDate': (model) => model?.fromDate
                }
            }
        ];
        this.model = {
            fromDate: initialValue[0].toISOString(),
            toDate: initialValue[1].toISOString()
        };
    }
    /**
     * Fires a new WidgetChangeEvent either on the local change emitter or on the global one.
     * @param dateRange The event data to send.
     * @param predefinedDateFrom Time range selected from dropdown.
     */
    update(dateRange, predefinedDateFrom) {
        if (this.isCoupled) {
            this.widgetEventService.emit({ type: 'TIME_CONTEXT', data: dateRange });
        }
        else {
            this.localDate = dateRange;
            this.dateContextChange.emit(dateRange);
        }
        this.currentPredefinedTimeSpan =
            predefinedDateFrom || this.getCurrentPredefinedTimeSpan(dateRange);
    }
    subscribeToGlobalContext() {
        const event$ = this.widgetEventService.getObservable('TIME_CONTEXT');
        this.subscription = event$.subscribe((dateContextChange) => {
            this.globalDate = dateContextChange;
            this.dateContextChange.emit(dateContextChange);
            this.updateFormValues(dateContextChange);
            this.setDateContextQueryParams();
        });
    }
    updateFormValues(value) {
        this.model = {
            fromDate: value[0].toISOString(),
            toDate: value[1].toISOString()
        };
    }
    unsubscribeFromGlobalContext() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    getInitialDate() {
        const dateContextFrom = this.activatedRoute.snapshot.queryParams[DateContextQueryParams.DATE_CONTEXT_FROM];
        const dateContextTo = this.activatedRoute.snapshot.queryParams[DateContextQueryParams.DATE_CONTEXT_TO];
        if (this.isValidDateRange(dateContextFrom, dateContextTo)) {
            return [new Date(dateContextFrom), new Date(dateContextTo)];
        }
        return this.widgetEventService.getLastValue('TIME_CONTEXT') || this.defaultDate;
    }
    isValidDateRange(stringifiedDateFrom, stringifiedDateTo) {
        const dateFrom = new Date(stringifiedDateFrom);
        const dateTo = new Date(stringifiedDateTo);
        if (dateFrom instanceof Date &&
            !isNaN(dateFrom?.getTime()) &&
            dateTo instanceof Date &&
            !isNaN(dateTo?.getTime())) {
            return dateFrom < dateTo;
        }
        return false;
    }
    /**
     * Sets date context as url query params.
     */
    setDateContextQueryParams() {
        const queryParams = {
            dateContextFrom: this.globalDate[0].toISOString(),
            dateContextTo: this.globalDate[1].toISOString()
        };
        this.router.navigate([], {
            relativeTo: this.activatedRoute,
            queryParams,
            queryParamsHandling: 'merge'
        });
    }
    subscribeToQueryParamsChange() {
        this.activatedRoute.queryParams
            .pipe(filter(({ dateContextFrom, dateContextTo }) => {
            return (this.isValidDateRange(dateContextFrom, dateContextTo) &&
                (this.globalDate[0].toISOString() !== dateContextFrom ||
                    this.globalDate[1].toISOString() !== dateContextTo));
        }))
            .subscribe(({ dateContextFrom, dateContextTo }) => {
            const dateContext = [new Date(dateContextFrom), new Date(dateContextTo)];
            this.widgetEventService.emit({ type: 'TIME_CONTEXT', data: dateContext });
        });
    }
    getCurrentPredefinedTimeSpan(dateRange) {
        if (dateRange[1].toISOString() !== this.defaultDate[1].toISOString()) {
            return;
        }
        const timeSpan = dateRange[1].valueOf() - dateRange[0].valueOf();
        return this.predefinedTimeSpanList.find(predefTimeSpan => predefTimeSpan.timeSpanInMs === timeSpan);
    }
}
WidgetTimeContextComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: WidgetTimeContextComponent, deps: [{ token: i1.WidgetsDashboardEventService }, { token: i2.DashboardChildComponent }, { token: i3.Router }, { token: i3.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Component });
WidgetTimeContextComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.6", type: WidgetTimeContextComponent, selector: "c8y-widget-time-context", inputs: { canDecouple: "canDecouple" }, outputs: { dateContextChange: "dateContextChange" }, host: { classAttribute: "d-flex a-i-center gap-4" }, viewQueries: [{ propertyName: "action", first: true, predicate: DashboardChildActionComponent, descendants: true }], ngImport: i0, template: "<c8y-action-bar-item\n  *ngIf=\"isCoupled\"\n  [groupId]=\"'timecontext'\"\n  [placement]=\"'left'\"\n  itemClass=\"navbar-form\"\n>\n  <ng-container\n    [ngTemplateOutlet]=\"dateTimePicker\"\n    [ngTemplateOutletContext]=\"{ date: globalDate }\"\n  ></ng-container>\n</c8y-action-bar-item>\n\n<ng-container\n  *ngIf=\"!isCoupled\"\n  [ngTemplateOutlet]=\"dateTimePicker\"\n  [ngTemplateOutletContext]=\"{ date: localDate }\"\n></ng-container>\n\n<ng-template #dateTimePicker let-date=\"date\">\n  <label>{{ 'Time range' | translate }}</label>\n  <div\n    class=\"dropdown m-r-4\"\n    dropdown\n    #dropdown=\"bs-dropdown\"\n    container=\"body\"\n    [insideClick]=\"true\"\n  >\n    <button\n      class=\"dropdown-toggle form-control l-h-1 d-flex a-i-center\"\n      dropdownToggle\n      title=\"{{ date[0] | c8yDate: 'short' }} \u2014 {{ date[1] | c8yDate: 'short' }}\"\n      aria-haspopup=\"true\"\n    >\n      <span>{{ date[0] | c8yDate: 'shortDate' }} \u2014 {{ date[1] | c8yDate: 'shortDate' }}</span>\n      <span class=\"caret m-r-8 m-l-4\"></span>\n    </button>\n\n    <div *dropdownMenu class=\"dropdown-menu dropdown-menu--date-range\">\n      <div class=\"p-16\">\n        <formly-form [form]=\"form\" [fields]=\"fields\" [model]=\"model\"></formly-form>\n      </div>\n      <div class=\"p-16 d-flex gap-8 separator-top\">\n        <button\n          class=\"btn btn-default btn-sm flex-grow\"\n          (click)=\"reset(); dropdown.isOpen = false\"\n          title=\"{{ 'Reset' | translate }}\"\n          type=\"button\"\n          translate\n        >\n          Reset\n        </button>\n\n        <button\n          class=\"btn btn-primary btn-sm flex-grow\"\n          (click)=\"applyDatetimeContext(); dropdown.isOpen = false\"\n          [disabled]=\"(form.pristine && form.untouched) || form.invalid\"\n          title=\"{{ 'Apply' | translate }}\"\n          type=\"button\"\n          translate\n        >\n          Apply\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"c8y-select-wrapper\">\n    <select\n      class=\"form-control\"\n      [attr.aria-label]=\"'Range' | translate\"\n      [ngModel]=\"currentPredefinedTimeSpan\"\n      (ngModelChange)=\"predefinedDateFromSelected($event)\"\n    >\n      <option value=\"undefined\" disabled=\"true\">{{ 'Custom range`time`' | translate }}</option>\n      <option *ngFor=\"let dateFrom of predefinedTimeSpanList\" [ngValue]=\"dateFrom\">\n        {{ dateFrom.title }}\n      </option>\n    </select>\n    <span></span>\n  </div>\n</ng-template>\n\n<c8y-dashboard-child-action>\n  <button (click)=\"toggleDecoupling();\" type=\"button\">\n    <i [c8yIcon]=\"isCoupled ? 'schedule1' : 'today'\"></i>\n    <span class=\"m-l-4\">\n      {{ (isCoupled ? decoupleTimeContextLabel : coupleTimeContextLabel) | translate }}\n    </span>\n  </button>\n</c8y-dashboard-child-action>\n", dependencies: [{ kind: "directive", type: i4.IconDirective, selector: "[c8yIcon]", inputs: ["c8yIcon"] }, { kind: "directive", type: i5.C8yTranslateDirective, selector: "[translate],[ngx-translate]" }, { kind: "directive", type: i6.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i6.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i7.ActionBarItemComponent, selector: "c8y-action-bar-item", inputs: ["placement", "priority", "itemClass", "injector", "groupId"] }, { kind: "directive", type: i8.BsDropdownMenuDirective, selector: "[bsDropdownMenu],[dropdownMenu]", exportAs: ["bs-dropdown-menu"] }, { kind: "directive", type: i8.BsDropdownToggleDirective, selector: "[bsDropdownToggle],[dropdownToggle]", exportAs: ["bs-dropdown-toggle"] }, { kind: "directive", type: i8.BsDropdownDirective, selector: "[bsDropdown], [dropdown]", inputs: ["placement", "triggers", "container", "dropup", "autoClose", "isAnimated", "insideClick", "isDisabled", "isOpen"], outputs: ["isOpenChange", "onShown", "onHidden"], exportAs: ["bs-dropdown"] }, { kind: "directive", type: i9.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i9.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i9.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i9.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i10.FormlyForm, selector: "formly-form", inputs: ["form", "model", "fields", "options"], outputs: ["modelChange"] }, { kind: "component", type: i11.DashboardChildActionComponent, selector: "c8y-dashboard-child-action" }, { kind: "pipe", type: i12.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i13.DatePipe, name: "c8yDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: WidgetTimeContextComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-widget-time-context', host: { class: 'd-flex a-i-center gap-4' }, template: "<c8y-action-bar-item\n  *ngIf=\"isCoupled\"\n  [groupId]=\"'timecontext'\"\n  [placement]=\"'left'\"\n  itemClass=\"navbar-form\"\n>\n  <ng-container\n    [ngTemplateOutlet]=\"dateTimePicker\"\n    [ngTemplateOutletContext]=\"{ date: globalDate }\"\n  ></ng-container>\n</c8y-action-bar-item>\n\n<ng-container\n  *ngIf=\"!isCoupled\"\n  [ngTemplateOutlet]=\"dateTimePicker\"\n  [ngTemplateOutletContext]=\"{ date: localDate }\"\n></ng-container>\n\n<ng-template #dateTimePicker let-date=\"date\">\n  <label>{{ 'Time range' | translate }}</label>\n  <div\n    class=\"dropdown m-r-4\"\n    dropdown\n    #dropdown=\"bs-dropdown\"\n    container=\"body\"\n    [insideClick]=\"true\"\n  >\n    <button\n      class=\"dropdown-toggle form-control l-h-1 d-flex a-i-center\"\n      dropdownToggle\n      title=\"{{ date[0] | c8yDate: 'short' }} \u2014 {{ date[1] | c8yDate: 'short' }}\"\n      aria-haspopup=\"true\"\n    >\n      <span>{{ date[0] | c8yDate: 'shortDate' }} \u2014 {{ date[1] | c8yDate: 'shortDate' }}</span>\n      <span class=\"caret m-r-8 m-l-4\"></span>\n    </button>\n\n    <div *dropdownMenu class=\"dropdown-menu dropdown-menu--date-range\">\n      <div class=\"p-16\">\n        <formly-form [form]=\"form\" [fields]=\"fields\" [model]=\"model\"></formly-form>\n      </div>\n      <div class=\"p-16 d-flex gap-8 separator-top\">\n        <button\n          class=\"btn btn-default btn-sm flex-grow\"\n          (click)=\"reset(); dropdown.isOpen = false\"\n          title=\"{{ 'Reset' | translate }}\"\n          type=\"button\"\n          translate\n        >\n          Reset\n        </button>\n\n        <button\n          class=\"btn btn-primary btn-sm flex-grow\"\n          (click)=\"applyDatetimeContext(); dropdown.isOpen = false\"\n          [disabled]=\"(form.pristine && form.untouched) || form.invalid\"\n          title=\"{{ 'Apply' | translate }}\"\n          type=\"button\"\n          translate\n        >\n          Apply\n        </button>\n      </div>\n    </div>\n  </div>\n\n  <div class=\"c8y-select-wrapper\">\n    <select\n      class=\"form-control\"\n      [attr.aria-label]=\"'Range' | translate\"\n      [ngModel]=\"currentPredefinedTimeSpan\"\n      (ngModelChange)=\"predefinedDateFromSelected($event)\"\n    >\n      <option value=\"undefined\" disabled=\"true\">{{ 'Custom range`time`' | translate }}</option>\n      <option *ngFor=\"let dateFrom of predefinedTimeSpanList\" [ngValue]=\"dateFrom\">\n        {{ dateFrom.title }}\n      </option>\n    </select>\n    <span></span>\n  </div>\n</ng-template>\n\n<c8y-dashboard-child-action>\n  <button (click)=\"toggleDecoupling();\" type=\"button\">\n    <i [c8yIcon]=\"isCoupled ? 'schedule1' : 'today'\"></i>\n    <span class=\"m-l-4\">\n      {{ (isCoupled ? decoupleTimeContextLabel : coupleTimeContextLabel) | translate }}\n    </span>\n  </button>\n</c8y-dashboard-child-action>\n" }]
        }], ctorParameters: function () { return [{ type: i1.WidgetsDashboardEventService }, { type: i2.DashboardChildComponent }, { type: i3.Router }, { type: i3.ActivatedRoute }]; }, propDecorators: { canDecouple: [{
                type: Input
            }], dateContextChange: [{
                type: Output
            }], action: [{
                type: ViewChild,
                args: [DashboardChildActionComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0LXRpbWUtY29udGV4dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL2Rhc2hib2FyZC93aWRnZXQtdGltZS1jb250ZXh0LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL2NvcmUvZGFzaGJvYXJkL3dpZGdldC10aW1lLWNvbnRleHQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUdMLE1BQU0sRUFDTixTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDbkYsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDdEUsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFakYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDbEMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEMsT0FBTyxFQUNMLHNCQUFzQixFQUV0QixZQUFZLEVBQ2IsTUFBTSw2QkFBNkIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FBT3JDLE1BQU0sT0FBTywwQkFBMEI7SUE4Q3JDOztPQUVHO0lBQ0gsWUFDVSxrQkFBZ0QsRUFDaEQsY0FBdUMsRUFDdkMsTUFBYyxFQUNkLGNBQThCO1FBSDlCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBOEI7UUFDaEQsbUJBQWMsR0FBZCxjQUFjLENBQXlCO1FBQ3ZDLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFw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RCxNQUFNLFFBQVEsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pFLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FDckMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsWUFBWSxLQUFLLFFBQVEsQ0FDM0QsQ0FBQztJQUNKLENBQUM7O3VIQXRTVSwwQkFBMEI7MkdBQTFCLDBCQUEwQix5UEF1QjFCLDZCQUE2QixnREN0RDFDLDAwRkEwRkE7MkZEM0RhLDBCQUEwQjtrQkFMdEMsU0FBUzsrQkFDRSx5QkFBeUIsUUFFN0IsRUFBRSxLQUFLLEVBQUUseUJBQXlCLEVBQUU7Mk1BTzFDLFdBQVc7c0JBRFYsS0FBSztnQkFlTixpQkFBaUI7c0JBRGhCLE1BQU07Z0JBS21DLE1BQU07c0JBQS9DLFNBQVM7dUJBQUMsNkJBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhc2hib2FyZENoaWxkQWN0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9kYXNoYm9hcmQtY2hpbGQtYWN0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRDaGlsZENvbXBvbmVudCB9IGZyb20gJy4vZGFzaGJvYXJkLWNoaWxkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBXaWRnZXRzRGFzaGJvYXJkRXZlbnRTZXJ2aWNlIH0gZnJvbSAnLi93aWRnZXRzLWRhc2hib2FyZC1ldmVudC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVUaW1lQ29udGV4dCwgVGltZUNvbnRleHRFdmVudCB9IGZyb20gJy4vd2lkZ2V0LWNoYW5nZS1ldmVudC5tb2RlbCc7XG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBGb3JtbHlGaWVsZENvbmZpZyB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuaW1wb3J0IHsgZ2V0dGV4dCB9IGZyb20gJy4uL2kxOG4nO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUsIFJvdXRlciB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBEYXRlQ29udGV4dFF1ZXJ5UGFyYW1zLFxuICBQcmVkZWZpbmVkVGltZVNwYW4sXG4gIFRpbWVTcGFuSW5Nc1xufSBmcm9tICcuL3dpZGdldC10aW1lLWNvbnRleHQubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjOHktd2lkZ2V0LXRpbWUtY29udGV4dCcsXG4gIHRlbXBsYXRlVXJsOiAnLi93aWRnZXQtdGltZS1jb250ZXh0LmNvbXBvbmVudC5odG1sJyxcbiAgaG9zdDogeyBjbGFzczogJ2QtZmxleCBhLWktY2VudGVyIGdhcC00JyB9XG59KVxuZXhwb3J0IGNsYXNzIFdpZGdldFRpbWVDb250ZXh0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjb21wb25lbnQgY2FuIGRlY291cGxlIG9yIG5vdC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGNhbkRlY291cGxlID0gdHJ1ZTtcbiAgLyoqXG4gICAqIFRoZSBkYXRlcyB0byBzZXQgYXMgZGVmYXVsdCBbZnJvbSwgdG9dLlxuICAgKi9cbiAgZGVmYXVsdERhdGU6IERhdGVUaW1lQ29udGV4dDtcbiAgLyoqXG4gICAqIFRoZSBnbG9iYWwgdGltZSBjb250ZXh0IHZhbHVlLlxuICAgKi9cbiAgZ2xvYmFsRGF0ZTogRGF0ZVRpbWVDb250ZXh0O1xuXG4gIC8qKlxuICAgKiBFbWl0cyBlYWNoIGNoYW5nZSBhcyBhbiBhcnJheSBvZiBkYXRlcyBbZnJvbSwgdG9dLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIGRhdGVDb250ZXh0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlVGltZUNvbnRleHQ+KCk7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBAVmlld0NoaWxkKERhc2hib2FyZENoaWxkQWN0aW9uQ29tcG9uZW50KSBhY3Rpb246IERhc2hib2FyZENoaWxkQWN0aW9uQ29tcG9uZW50O1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSBpZiBkZWNvdXBsZWQuXG4gICAqL1xuICBsb2NhbERhdGU6IERhdGVUaW1lQ29udGV4dDtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgdGltZSBjb250ZXh0IGlzIGJvdW5kIHRvIHRoZSBnbG9iYWwgc2NvcGUuXG4gICAqL1xuICBpc0NvdXBsZWQgPSB0cnVlO1xuICBkZWNvdXBsZVRpbWVDb250ZXh0TGFiZWwgPSBnZXR0ZXh0KCdEZWNvdXBsZSB0aW1lIGNvbnRleHQnKTtcbiAgY291cGxlVGltZUNvbnRleHRMYWJlbCA9IGdldHRleHQoJ0NvdXBsZSB0aW1lIGNvbnRleHQnKTtcbiAgZm9ybTogRm9ybUdyb3VwO1xuICBmaWVsZHM6IEZvcm1seUZpZWxkQ29uZmlnW107XG4gIG1vZGVsOiB7XG4gICAgZnJvbURhdGU6IHN0cmluZztcbiAgICB0b0RhdGU6IHN0cmluZztcbiAgfTtcblxuICBwcmVkZWZpbmVkVGltZVNwYW5MaXN0OiBQcmVkZWZpbmVkVGltZVNwYW5bXTtcbiAgY3VycmVudFByZWRlZmluZWRUaW1lU3BhbjogUHJlZGVmaW5lZFRpbWVTcGFuID0gbnVsbDtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBAaWdub3JlIG9ubHkgREkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHdpZGdldEV2ZW50U2VydmljZTogV2lkZ2V0c0Rhc2hib2FyZEV2ZW50U2VydmljZSxcbiAgICBwcml2YXRlIGRhc2hib2FyZENoaWxkOiBEYXNoYm9hcmRDaGlsZENvbXBvbmVudCxcbiAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyLFxuICAgIHByaXZhdGUgYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlXG4gICkge1xuICAgIHRoaXMuc2V0UHJlZGVmaW5lZERhdGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQGlnbm9yZSBTdWJzY3JpYmluZyB0byB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAqL1xuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBjb25zdCBpbml0aWFsRGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbERhdGUoKTtcblxuICAgIHRoaXMuaW5pdEZvcm0oaW5pdGlhbERhdGUpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9HbG9iYWxDb250ZXh0KCk7XG4gICAgdGhpcy51cGRhdGUoaW5pdGlhbERhdGUpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9RdWVyeVBhcmFtc0NoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmUgQWRkaW5nIGN1c3RvbSBhY3Rpb25zLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbkRlY291cGxlKSB7XG4gICAgICB0aGlzLmRhc2hib2FyZENoaWxkLmFkZEFjdGlvbnMoW3RoaXMuYWN0aW9uXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGNvdXBsaW5nIG9uIG9yIG9mZi5cbiAgICovXG4gIHRvZ2dsZURlY291cGxpbmcoKSB7XG4gICAgdGhpcy5pc0NvdXBsZWQgPSAhdGhpcy5pc0NvdXBsZWQ7XG4gICAgaWYgKHRoaXMuaXNDb3VwbGVkKSB7XG4gICAgICB0aGlzLnN1YnNjcmliZVRvR2xvYmFsQ29udGV4dCgpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRlID0gdGhpcy53aWRnZXRFdmVudFNlcnZpY2UuZ2V0TGFzdFZhbHVlKCdUSU1FX0NPTlRFWFQnKTtcbiAgICAgIHRoaXMudXBkYXRlRm9ybVZhbHVlcyh0aGlzLmdsb2JhbERhdGUpO1xuICAgICAgdGhpcy5kYXRlQ29udGV4dENoYW5nZS5lbWl0KHRoaXMuZ2xvYmFsRGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tR2xvYmFsQ29udGV4dCgpO1xuICAgICAgaWYgKCF0aGlzLmxvY2FsRGF0ZSkge1xuICAgICAgICB0aGlzLmxvY2FsRGF0ZSA9IHRoaXMuZ2xvYmFsRGF0ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRm9ybVZhbHVlcyh0aGlzLmxvY2FsRGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZm9ybSB2YWx1ZSB0byBnbG9iYWwgb3IgbG9jYWwgZGF0ZSBjb250ZXh0LlxuICAgKi9cbiAgYXBwbHlEYXRldGltZUNvbnRleHQoKSB7XG4gICAgdGhpcy51cGRhdGUoW25ldyBEYXRlKHRoaXMuZm9ybS52YWx1ZS5mcm9tRGF0ZSksIG5ldyBEYXRlKHRoaXMuZm9ybS52YWx1ZS50b0RhdGUpXSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGZvcm0gdG8gaW5pdGlhbCB2YWx1ZSBhbmQgdXBkYXRlIGNvbnRleHQuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnVwZGF0ZURlZmF1bHREYXRlKCk7XG4gICAgdGhpcy51cGRhdGVGb3JtVmFsdWVzKHRoaXMuZGVmYXVsdERhdGUpO1xuICAgIHRoaXMudXBkYXRlKHRoaXMuZGVmYXVsdERhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpZ25vcmUgdW5zdWJzY3JpYmluZy5cbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tR2xvYmFsQ29udGV4dCgpO1xuICB9XG5cbiAgcHJlZGVmaW5lZERhdGVGcm9tU2VsZWN0ZWQoc2VsZWN0ZWREYXRlRnJvbTogUHJlZGVmaW5lZFRpbWVTcGFuKSB7XG4gICAgdGhpcy51cGRhdGVEZWZhdWx0RGF0ZSgpO1xuICAgIGNvbnN0IGNhbGN1bGF0ZWREYXRlRnJvbSA9IG5ldyBEYXRlKFxuICAgICAgdGhpcy5kZWZhdWx0RGF0ZVsxXS52YWx1ZU9mKCkgLSBzZWxlY3RlZERhdGVGcm9tLnRpbWVTcGFuSW5Nc1xuICAgICk7XG4gICAgdGhpcy51cGRhdGUoW2NhbGN1bGF0ZWREYXRlRnJvbSwgdGhpcy5kZWZhdWx0RGF0ZVsxXV0sIHNlbGVjdGVkRGF0ZUZyb20pO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVEZWZhdWx0RGF0ZSgpIHtcbiAgICBjb25zdCB0b2RheURhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHllc3RlcmRheURhdGUgPSBuZXcgRGF0ZSh0b2RheURhdGUudmFsdWVPZigpIC0gMTAwMCAqIDYwICogNjAgKiAyNCk7XG4gICAgdGhpcy5kZWZhdWx0RGF0ZSA9IFt5ZXN0ZXJkYXlEYXRlLCB0b2RheURhdGVdO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQcmVkZWZpbmVkRGF0ZXMoKSB7XG4gICAgdGhpcy51cGRhdGVEZWZhdWx0RGF0ZSgpO1xuICAgIGNvbnN0IHRvZGF5RGF0ZUNvcHkgPSBuZXcgRGF0ZSh0aGlzLmRlZmF1bHREYXRlWzFdLnZhbHVlT2YoKSk7XG4gICAgY29uc3QgbGFzdE1vbnRoVGltZVNwYW4gPVxuICAgICAgdG9kYXlEYXRlQ29weS52YWx1ZU9mKCkgLVxuICAgICAgbmV3IERhdGUodG9kYXlEYXRlQ29weS5zZXRNb250aCh0b2RheURhdGVDb3B5LmdldE1vbnRoKCkgLSAxKSkudmFsdWVPZigpO1xuXG4gICAgdGhpcy5wcmVkZWZpbmVkVGltZVNwYW5MaXN0ID0gW1xuICAgICAgeyB0aXRsZTogZ2V0dGV4dCgnTGFzdCBtaW51dGUnKSwgdGltZVNwYW5Jbk1zOiBUaW1lU3BhbkluTXMuTUlOVVRFIH0sXG4gICAgICB7IHRpdGxlOiBnZXR0ZXh0KCdMYXN0IGhvdXInKSwgdGltZVNwYW5Jbk1zOiBUaW1lU3BhbkluTXMuSE9VUiB9LFxuICAgICAgeyB0aXRsZTogZ2V0dGV4dCgnTGFzdCBkYXknKSwgdGltZVNwYW5Jbk1zOiBUaW1lU3BhbkluTXMuREFZIH0sXG4gICAgICB7IHRpdGxlOiBnZXR0ZXh0KCdMYXN0IHdlZWsnKSwgdGltZVNwYW5Jbk1zOiBUaW1lU3BhbkluTXMuV0VFSyB9LFxuICAgICAgeyB0aXRsZTogZ2V0dGV4dCgnTGFzdCBtb250aCcpLCB0aW1lU3BhbkluTXM6IGxhc3RNb250aFRpbWVTcGFuIH1cbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGRhdGV0aW1lIHBpY2tlciBmb3JtIHdpdGggcHJvcGVyIGZpZWxkcyBhbmQgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIGluaXRpYWxWYWx1ZSBWYWx1ZSB0byBmaWxsIGZvcm0gd2l0aC5cbiAgICovXG4gIHByaXZhdGUgaW5pdEZvcm0oaW5pdGlhbFZhbHVlOiBEYXRlVGltZUNvbnRleHQpIHtcbiAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICB0aGlzLmZpZWxkcyA9IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogJ2RhdGUtdGltZScsXG4gICAgICAgIGtleTogJ2Zyb21EYXRlJyxcbiAgICAgICAgdGVtcGxhdGVPcHRpb25zOiB7XG4gICAgICAgICAgbGFiZWw6IGdldHRleHQoJ0Zyb21gZGF0ZWAnKVxuICAgICAgICB9LFxuICAgICAgICBleHByZXNzaW9uUHJvcGVydGllczoge1xuICAgICAgICAgICd0ZW1wbGF0ZU9wdGlvbnMubWF4RGF0ZSc6IChtb2RlbDogYW55KSA9PiBtb2RlbD8udG9EYXRlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGU6ICdkYXRlLXRpbWUnLFxuICAgICAgICBrZXk6ICd0b0RhdGUnLFxuICAgICAgICB0ZW1wbGF0ZU9wdGlvbnM6IHtcbiAgICAgICAgICBsYWJlbDogZ2V0dGV4dCgnVG9gZGF0ZWAnKVxuICAgICAgICB9LFxuICAgICAgICBleHByZXNzaW9uUHJvcGVydGllczoge1xuICAgICAgICAgICd0ZW1wbGF0ZU9wdGlvbnMubWluRGF0ZSc6IChtb2RlbDogYW55KSA9PiBtb2RlbD8uZnJvbURhdGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gICAgdGhpcy5tb2RlbCA9IHtcbiAgICAgIGZyb21EYXRlOiBpbml0aWFsVmFsdWVbMF0udG9JU09TdHJpbmcoKSxcbiAgICAgIHRvRGF0ZTogaW5pdGlhbFZhbHVlWzFdLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgbmV3IFdpZGdldENoYW5nZUV2ZW50IGVpdGhlciBvbiB0aGUgbG9jYWwgY2hhbmdlIGVtaXR0ZXIgb3Igb24gdGhlIGdsb2JhbCBvbmUuXG4gICAqIEBwYXJhbSBkYXRlUmFuZ2UgVGhlIGV2ZW50IGRhdGEgdG8gc2VuZC5cbiAgICogQHBhcmFtIHByZWRlZmluZWREYXRlRnJvbSBUaW1lIHJhbmdlIHNlbGVjdGVkIGZyb20gZHJvcGRvd24uXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZShkYXRlUmFuZ2U6IERhdGVUaW1lQ29udGV4dCwgcHJlZGVmaW5lZERhdGVGcm9tPzogUHJlZGVmaW5lZFRpbWVTcGFuKSB7XG4gICAgaWYgKHRoaXMuaXNDb3VwbGVkKSB7XG4gICAgICB0aGlzLndpZGdldEV2ZW50U2VydmljZS5lbWl0KHsgdHlwZTogJ1RJTUVfQ09OVEVYVCcsIGRhdGE6IGRhdGVSYW5nZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2NhbERhdGUgPSBkYXRlUmFuZ2U7XG4gICAgICB0aGlzLmRhdGVDb250ZXh0Q2hhbmdlLmVtaXQoZGF0ZVJhbmdlKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UHJlZGVmaW5lZFRpbWVTcGFuID1cbiAgICAgIHByZWRlZmluZWREYXRlRnJvbSB8fCB0aGlzLmdldEN1cnJlbnRQcmVkZWZpbmVkVGltZVNwYW4oZGF0ZVJhbmdlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9HbG9iYWxDb250ZXh0KCkge1xuICAgIGNvbnN0IGV2ZW50JCA9IHRoaXMud2lkZ2V0RXZlbnRTZXJ2aWNlLmdldE9ic2VydmFibGU8VGltZUNvbnRleHRFdmVudD4oJ1RJTUVfQ09OVEVYVCcpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gZXZlbnQkLnN1YnNjcmliZSgoZGF0ZUNvbnRleHRDaGFuZ2U6IERhdGVUaW1lQ29udGV4dCkgPT4ge1xuICAgICAgdGhpcy5nbG9iYWxEYXRlID0gZGF0ZUNvbnRleHRDaGFuZ2U7XG4gICAgICB0aGlzLmRhdGVDb250ZXh0Q2hhbmdlLmVtaXQoZGF0ZUNvbnRleHRDaGFuZ2UpO1xuICAgICAgdGhpcy51cGRhdGVGb3JtVmFsdWVzKGRhdGVDb250ZXh0Q2hhbmdlKTtcbiAgICAgIHRoaXMuc2V0RGF0ZUNvbnRleHRRdWVyeVBhcmFtcygpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVGb3JtVmFsdWVzKHZhbHVlOiBEYXRlVGltZUNvbnRleHQpIHtcbiAgICB0aGlzLm1vZGVsID0ge1xuICAgICAgZnJvbURhdGU6IHZhbHVlWzBdLnRvSVNPU3RyaW5nKCksXG4gICAgICB0b0RhdGU6IHZhbHVlWzFdLnRvSVNPU3RyaW5nKClcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZUZyb21HbG9iYWxDb250ZXh0KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEluaXRpYWxEYXRlKCk6IERhdGVUaW1lQ29udGV4dCB7XG4gICAgY29uc3QgZGF0ZUNvbnRleHRGcm9tID1cbiAgICAgIHRoaXMuYWN0aXZhdGVkUm91dGUuc25hcHNob3QucXVlcnlQYXJhbXNbRGF0ZUNvbnRleHRRdWVyeVBhcmFtcy5EQVRFX0NPTlRFWFRfRlJPTV07XG4gICAgY29uc3QgZGF0ZUNvbnRleHRUbyA9XG4gICAgICB0aGlzLmFjdGl2YXRlZFJvdXRlLnNuYXBzaG90LnF1ZXJ5UGFyYW1zW0RhdGVDb250ZXh0UXVlcnlQYXJhbXMuREFURV9DT05URVhUX1RPXTtcblxuICAgIGlmICh0aGlzLmlzVmFsaWREYXRlUmFuZ2UoZGF0ZUNvbnRleHRGcm9tLCBkYXRlQ29udGV4dFRvKSkge1xuICAgICAgcmV0dXJuIFtuZXcgRGF0ZShkYXRlQ29udGV4dEZyb20pLCBuZXcgRGF0ZShkYXRlQ29udGV4dFRvKV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpZGdldEV2ZW50U2VydmljZS5nZXRMYXN0VmFsdWUoJ1RJTUVfQ09OVEVYVCcpIHx8IHRoaXMuZGVmYXVsdERhdGU7XG4gIH1cblxuICBwcml2YXRlIGlzVmFsaWREYXRlUmFuZ2Uoc3RyaW5naWZpZWREYXRlRnJvbTogc3RyaW5nLCBzdHJpbmdpZmllZERhdGVUbzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGF0ZUZyb20gPSBuZXcgRGF0ZShzdHJpbmdpZmllZERhdGVGcm9tKTtcbiAgICBjb25zdCBkYXRlVG8gPSBuZXcgRGF0ZShzdHJpbmdpZmllZERhdGVUbyk7XG4gICAgaWYgKFxuICAgICAgZGF0ZUZyb20gaW5zdGFuY2VvZiBEYXRlICYmXG4gICAgICAhaXNOYU4oZGF0ZUZyb20/LmdldFRpbWUoKSkgJiZcbiAgICAgIGRhdGVUbyBpbnN0YW5jZW9mIERhdGUgJiZcbiAgICAgICFpc05hTihkYXRlVG8/LmdldFRpbWUoKSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRlRnJvbSA8IGRhdGVUbztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgZGF0ZSBjb250ZXh0IGFzIHVybCBxdWVyeSBwYXJhbXMuXG4gICAqL1xuICBwcml2YXRlIHNldERhdGVDb250ZXh0UXVlcnlQYXJhbXMoKSB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IFJlY29yZDxEYXRlQ29udGV4dFF1ZXJ5UGFyYW1zLCBzdHJpbmc+ID0ge1xuICAgICAgZGF0ZUNvbnRleHRGcm9tOiB0aGlzLmdsb2JhbERhdGVbMF0udG9JU09TdHJpbmcoKSxcbiAgICAgIGRhdGVDb250ZXh0VG86IHRoaXMuZ2xvYmFsRGF0ZVsxXS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbXSwge1xuICAgICAgcmVsYXRpdmVUbzogdGhpcy5hY3RpdmF0ZWRSb3V0ZSxcbiAgICAgIHF1ZXJ5UGFyYW1zLFxuICAgICAgcXVlcnlQYXJhbXNIYW5kbGluZzogJ21lcmdlJ1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1F1ZXJ5UGFyYW1zQ2hhbmdlKCkge1xuICAgIHRoaXMuYWN0aXZhdGVkUm91dGUucXVlcnlQYXJhbXNcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgKHsgZGF0ZUNvbnRleHRGcm9tLCBkYXRlQ29udGV4dFRvIH06IHsgW2tleSBpbiBEYXRlQ29udGV4dFF1ZXJ5UGFyYW1zXTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMuaXNWYWxpZERhdGVSYW5nZShkYXRlQ29udGV4dEZyb20sIGRhdGVDb250ZXh0VG8pICYmXG4gICAgICAgICAgICAgICh0aGlzLmdsb2JhbERhdGVbMF0udG9JU09TdHJpbmcoKSAhPT0gZGF0ZUNvbnRleHRGcm9tIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRlWzFdLnRvSVNPU3RyaW5nKCkgIT09IGRhdGVDb250ZXh0VG8pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgKHsgZGF0ZUNvbnRleHRGcm9tLCBkYXRlQ29udGV4dFRvIH06IHsgW2tleSBpbiBEYXRlQ29udGV4dFF1ZXJ5UGFyYW1zXTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRlQ29udGV4dDogRGF0ZVRpbWVDb250ZXh0ID0gW25ldyBEYXRlKGRhdGVDb250ZXh0RnJvbSksIG5ldyBEYXRlKGRhdGVDb250ZXh0VG8pXTtcbiAgICAgICAgICB0aGlzLndpZGdldEV2ZW50U2VydmljZS5lbWl0KHsgdHlwZTogJ1RJTUVfQ09OVEVYVCcsIGRhdGE6IGRhdGVDb250ZXh0IH0pO1xuICAgICAgICB9XG4gICAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50UHJlZGVmaW5lZFRpbWVTcGFuKGRhdGVSYW5nZTogRGF0ZVRpbWVDb250ZXh0KSB7XG4gICAgaWYgKGRhdGVSYW5nZVsxXS50b0lTT1N0cmluZygpICE9PSB0aGlzLmRlZmF1bHREYXRlWzFdLnRvSVNPU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGltZVNwYW4gPSBkYXRlUmFuZ2VbMV0udmFsdWVPZigpIC0gZGF0ZVJhbmdlWzBdLnZhbHVlT2YoKTtcbiAgICByZXR1cm4gdGhpcy5wcmVkZWZpbmVkVGltZVNwYW5MaXN0LmZpbmQoXG4gICAgICBwcmVkZWZUaW1lU3BhbiA9PiBwcmVkZWZUaW1lU3Bhbi50aW1lU3BhbkluTXMgPT09IHRpbWVTcGFuXG4gICAgKTtcbiAgfVxufVxuIiwiPGM4eS1hY3Rpb24tYmFyLWl0ZW1cbiAgKm5nSWY9XCJpc0NvdXBsZWRcIlxuICBbZ3JvdXBJZF09XCIndGltZWNvbnRleHQnXCJcbiAgW3BsYWNlbWVudF09XCInbGVmdCdcIlxuICBpdGVtQ2xhc3M9XCJuYXZiYXItZm9ybVwiXG4+XG4gIDxuZy1jb250YWluZXJcbiAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJkYXRlVGltZVBpY2tlclwiXG4gICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgZGF0ZTogZ2xvYmFsRGF0ZSB9XCJcbiAgPjwvbmctY29udGFpbmVyPlxuPC9jOHktYWN0aW9uLWJhci1pdGVtPlxuXG48bmctY29udGFpbmVyXG4gICpuZ0lmPVwiIWlzQ291cGxlZFwiXG4gIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImRhdGVUaW1lUGlja2VyXCJcbiAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInsgZGF0ZTogbG9jYWxEYXRlIH1cIlxuPjwvbmctY29udGFpbmVyPlxuXG48bmctdGVtcGxhdGUgI2RhdGVUaW1lUGlja2VyIGxldC1kYXRlPVwiZGF0ZVwiPlxuICA8bGFiZWw+e3sgJ1RpbWUgcmFuZ2UnIHwgdHJhbnNsYXRlIH19PC9sYWJlbD5cbiAgPGRpdlxuICAgIGNsYXNzPVwiZHJvcGRvd24gbS1yLTRcIlxuICAgIGRyb3Bkb3duXG4gICAgI2Ryb3Bkb3duPVwiYnMtZHJvcGRvd25cIlxuICAgIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgIFtpbnNpZGVDbGlja109XCJ0cnVlXCJcbiAgPlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwiZHJvcGRvd24tdG9nZ2xlIGZvcm0tY29udHJvbCBsLWgtMSBkLWZsZXggYS1pLWNlbnRlclwiXG4gICAgICBkcm9wZG93blRvZ2dsZVxuICAgICAgdGl0bGU9XCJ7eyBkYXRlWzBdIHwgYzh5RGF0ZTogJ3Nob3J0JyB9fSDigJQge3sgZGF0ZVsxXSB8IGM4eURhdGU6ICdzaG9ydCcgfX1cIlxuICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgID5cbiAgICAgIDxzcGFuPnt7IGRhdGVbMF0gfCBjOHlEYXRlOiAnc2hvcnREYXRlJyB9fSDigJQge3sgZGF0ZVsxXSB8IGM4eURhdGU6ICdzaG9ydERhdGUnIH19PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJjYXJldCBtLXItOCBtLWwtNFwiPjwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxkaXYgKmRyb3Bkb3duTWVudSBjbGFzcz1cImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS0tZGF0ZS1yYW5nZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInAtMTZcIj5cbiAgICAgICAgPGZvcm1seS1mb3JtIFtmb3JtXT1cImZvcm1cIiBbZmllbGRzXT1cImZpZWxkc1wiIFttb2RlbF09XCJtb2RlbFwiPjwvZm9ybWx5LWZvcm0+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwLTE2IGQtZmxleCBnYXAtOCBzZXBhcmF0b3ItdG9wXCI+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gZmxleC1ncm93XCJcbiAgICAgICAgICAoY2xpY2spPVwicmVzZXQoKTsgZHJvcGRvd24uaXNPcGVuID0gZmFsc2VcIlxuICAgICAgICAgIHRpdGxlPVwie3sgJ1Jlc2V0JyB8IHRyYW5zbGF0ZSB9fVwiXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgdHJhbnNsYXRlXG4gICAgICAgID5cbiAgICAgICAgICBSZXNldFxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGZsZXgtZ3Jvd1wiXG4gICAgICAgICAgKGNsaWNrKT1cImFwcGx5RGF0ZXRpbWVDb250ZXh0KCk7IGRyb3Bkb3duLmlzT3BlbiA9IGZhbHNlXCJcbiAgICAgICAgICBbZGlzYWJsZWRdPVwiKGZvcm0ucHJpc3RpbmUgJiYgZm9ybS51bnRvdWNoZWQpIHx8IGZvcm0uaW52YWxpZFwiXG4gICAgICAgICAgdGl0bGU9XCJ7eyAnQXBwbHknIHwgdHJhbnNsYXRlIH19XCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICB0cmFuc2xhdGVcbiAgICAgICAgPlxuICAgICAgICAgIEFwcGx5XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuXG4gIDxkaXYgY2xhc3M9XCJjOHktc2VsZWN0LXdyYXBwZXJcIj5cbiAgICA8c2VsZWN0XG4gICAgICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIidSYW5nZScgfCB0cmFuc2xhdGVcIlxuICAgICAgW25nTW9kZWxdPVwiY3VycmVudFByZWRlZmluZWRUaW1lU3BhblwiXG4gICAgICAobmdNb2RlbENoYW5nZSk9XCJwcmVkZWZpbmVkRGF0ZUZyb21TZWxlY3RlZCgkZXZlbnQpXCJcbiAgICA+XG4gICAgICA8b3B0aW9uIHZhbHVlPVwidW5kZWZpbmVkXCIgZGlzYWJsZWQ9XCJ0cnVlXCI+e3sgJ0N1c3RvbSByYW5nZWB0aW1lYCcgfCB0cmFuc2xhdGUgfX08L29wdGlvbj5cbiAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGRhdGVGcm9tIG9mIHByZWRlZmluZWRUaW1lU3Bhbkxpc3RcIiBbbmdWYWx1ZV09XCJkYXRlRnJvbVwiPlxuICAgICAgICB7eyBkYXRlRnJvbS50aXRsZSB9fVxuICAgICAgPC9vcHRpb24+XG4gICAgPC9zZWxlY3Q+XG4gICAgPHNwYW4+PC9zcGFuPlxuICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxjOHktZGFzaGJvYXJkLWNoaWxkLWFjdGlvbj5cbiAgPGJ1dHRvbiAoY2xpY2spPVwidG9nZ2xlRGVjb3VwbGluZygpO1wiIHR5cGU9XCJidXR0b25cIj5cbiAgICA8aSBbYzh5SWNvbl09XCJpc0NvdXBsZWQgPyAnc2NoZWR1bGUxJyA6ICd0b2RheSdcIj48L2k+XG4gICAgPHNwYW4gY2xhc3M9XCJtLWwtNFwiPlxuICAgICAge3sgKGlzQ291cGxlZCA/IGRlY291cGxlVGltZUNvbnRleHRMYWJlbCA6IGNvdXBsZVRpbWVDb250ZXh0TGFiZWwpIHwgdHJhbnNsYXRlIH19XG4gICAgPC9zcGFuPlxuICA8L2J1dHRvbj5cbjwvYzh5LWRhc2hib2FyZC1jaGlsZC1hY3Rpb24+XG4iXX0=