import { importProvidersFrom, Injectable, InjectFlags, InjectionToken, Injector } from '@angular/core';
import { Router, ROUTES } from '@angular/router';
import { ViewContext } from './router.model';
import { ContextRouteService } from './context-route.service';
import { distinctUntilChanged, shareReplay } from 'rxjs/operators';
import { fromTriggerOnce, hookGeneric, getInjectedHooks, InjectionType, ExtensionPointWithoutStateForPlugins } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins';
import { flatten } from 'lodash';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "./context-route.service";
import * as i3 from "../plugins";
/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookRoute` function instead.
 */
export const HOOK_ROUTE = new InjectionToken('HOOK_ROUTE');
/**
 * You can either provide a single `Route` as parameter:
 * ```typescript
 *  hookRoute(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookRoute([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<Route>`
 * ```typescript
 *  export class MyRouteFactory implements ExtensionFactory<Route> {...}
 *  ...
 *  hookRoute(MyRouteFactory)
 * ```
 * A typed alternative to `HOOK_ROUTE`.
 * @param route The `Route`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookRoute(route, options) {
    return hookGeneric(route, HOOK_ROUTE, options);
}
/**
 * A service which defines routes for the application. You can use
 * HOOK_ROUTES or pass
 */
export class RouterService extends ExtensionPointWithoutStateForPlugins {
    constructor(rootInjector, router, contextRouteService, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        this.contextRouteService = contextRouteService;
        this.state = new Map();
        this.items$ = this.setupItemsObservable();
        // We are doing a self subscription to add the new routes
        // to the router configuration.
        this.items$.subscribe((routes) => {
            const toAddRoutes = routes.filter((route) => {
                const path = `${route.context || ''}${route.path}`;
                const isAlreadyAdded = this.state.has(path);
                if (!isAlreadyAdded) {
                    this.state.set(path, route);
                }
                return !isAlreadyAdded;
            });
            this.addRoute(toAddRoutes);
        });
        plugins.pluginDetails$.subscribe(({ moduleRef, remoteNgModule }) => {
            this.resolveRouterForChildRoutes(moduleRef, remoteNgModule);
        });
    }
    /**
     * Refresh the current context
     */
    refresh() {
        super.refresh();
        this.contextRouteService.refreshContext();
    }
    /**
     * Add a new route to the router configuration or a context.
     * @param route The route to add
     */
    addRoute(route) {
        this.addRoutes(Array.isArray(route) ? route : [route]);
    }
    /**
     * Determines if the given MO is an group or an device and returns
     * the correct href to link correctly to that MO.
     * @param groupOrDevice The MO of a group or the device.
     * @param prefix How should the link be prefixed.
     */
    getHref(groupOrDevice, prefix = '#/') {
        if (groupOrDevice.c8y_IsDeviceGroup || groupOrDevice.c8y_IsDynamicGroup) {
            return `${prefix}${ViewContext.Group.replace(':id', groupOrDevice.id)}`;
        }
        return `${prefix}${ViewContext.Device.replace(':id', groupOrDevice.id)}`;
    }
    setupItemsObservable() {
        return fromTriggerOnce(this.router, this.refresh$, [
            getInjectedHooks(HOOK_ROUTE, this.injectors, InjectionType.ROUTE),
            () => this.factories
        ]).pipe(distinctUntilChanged(), shareReplay(1));
    }
    addRoutes(routes) {
        // Empty route needs to be last as of navigation to angularjs routes
        // if ** route hit, the angularjs routes are loaded.
        const emptyRoute = this.router.config.find(r => r.path === '**');
        this.router.resetConfig([
            ...this.router.config.filter(r => r.path !== '**'),
            ...routes.map((r) => this.convertRoute(this.router.config, r)),
            emptyRoute
        ].filter(Boolean));
    }
    convertRoute(initialConfig, route) {
        if (route.context) {
            initialConfig.forEach((r) => {
                if (r.data && r.data.context === route.context) {
                    r.children = [route, ...(r.children || [])];
                }
            });
            return;
        }
        return route;
    }
    resolveRouterForChildRoutes(moduleRef, remoteNgModule) {
        // NOTE: stolen from lazy loaded routes from Angular itself.
        // https://github.com/angular/angular/blob/da58801f95c66c201e332189af25702bdd722f3f/packages/router/src/router_config_loader.ts#L103-L108
        const rawRoutes = flatten(moduleRef.injector.get(ROUTES, [], InjectFlags.Self | InjectFlags.Optional));
        if (rawRoutes.length > 0) {
            const routeWithInjector = rawRoutes.map(route => {
                route.providers = [importProvidersFrom(remoteNgModule)];
                return route;
            });
            this.addRoute(routeWithInjector);
        }
    }
}
RouterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: RouterService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.ContextRouteService }, { token: i3.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
RouterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: RouterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: RouterService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.ContextRouteService }, { type: i3.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3JvdXRlci9yb3V0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsbUJBQW1CLEVBQ25CLFVBQVUsRUFDVixXQUFXLEVBQ1gsY0FBYyxFQUNkLFFBQVEsRUFFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2pELE9BQU8sRUFBdUIsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFHOUQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ25FLE9BQU8sRUFFTCxlQUFlLEVBRWYsV0FBVyxFQUNYLGdCQUFnQixFQUNoQixhQUFhLEVBQ2Isb0NBQW9DLEVBRXJDLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7Ozs7O0FBc0JqQzs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxjQUFjLENBQWUsWUFBWSxDQUFDLENBQUM7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsTUFBTSxVQUFVLFNBQVMsQ0FBQyxLQUE2QixFQUFFLE9BQThCO0lBQ3JGLE9BQU8sV0FBVyxDQUFRLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQUVEOzs7R0FHRztBQUlILE1BQU0sT0FBTyxhQUFjLFNBQVEsb0NBQTJDO0lBRzVFLFlBQ0UsWUFBc0IsRUFDZixNQUFjLEVBQ2IsbUJBQXdDLEVBQ2hELE9BQThCO1FBRTlCLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFKdEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNiLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFMekMsVUFBSyxHQUFHLElBQUksR0FBRyxFQUFpQixDQUFDO1FBU3hDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFFMUMseURBQXlEO1FBQ3pELCtCQUErQjtRQUMvQixJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQWUsRUFBRSxFQUFFO1lBQ3hDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFZLEVBQUUsRUFBRTtnQkFDakQsTUFBTSxJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsT0FBTyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ25ELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM1QyxJQUFJLENBQUMsY0FBYyxFQUFFO29CQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQzdCO2dCQUNELE9BQU8sQ0FBQyxjQUFjLENBQUM7WUFDekIsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdCLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFO1lBQ2pFLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxTQUFTLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxPQUFPO1FBQ0wsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2hCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEtBQXNCO1FBQzdCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsT0FBTyxDQUFDLGFBQTZCLEVBQUUsTUFBTSxHQUFHLElBQUk7UUFDbEQsSUFBSSxhQUFhLENBQUMsaUJBQWlCLElBQUksYUFBYSxDQUFDLGtCQUFrQixFQUFFO1lBQ3ZFLE9BQU8sR0FBRyxNQUFNLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGFBQWEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1NBQ3pFO1FBQ0QsT0FBTyxHQUFHLE1BQU0sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsYUFBYSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDM0UsQ0FBQztJQUVTLG9CQUFvQjtRQUM1QixPQUFPLGVBQWUsQ0FBUSxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDeEQsZ0JBQWdCLENBQVEsVUFBVSxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQztZQUN4RSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsU0FBUztTQUNyQixDQUFDLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVPLFNBQVMsQ0FBQyxNQUFNO1FBQ3RCLG9FQUFvRTtRQUNwRSxvREFBb0Q7UUFDcEQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FDckI7WUFDRSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDO1lBQ2xELEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNyRSxVQUFVO1NBQ1gsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQ2xCLENBQUM7SUFDSixDQUFDO0lBRU8sWUFBWSxDQUFDLGFBQWEsRUFBRSxLQUFZO1FBQzlDLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRTtZQUNqQixhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBUSxFQUFFLEVBQUU7Z0JBQ2pDLElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sS0FBSyxLQUFLLENBQUMsT0FBTyxFQUFFO29CQUM5QyxDQUFDLENBQUMsUUFBUSxHQUFHLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzdDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDSCxPQUFPO1NBQ1I7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFTywyQkFBMkIsQ0FBQyxTQUEyQixFQUFFLGNBQW1CO1FBQ2xGLDREQUE0RDtRQUM1RCx5SUFBeUk7UUFDekksTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUN2QixTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxFQUFFLFdBQVcsQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUM1RSxDQUFDO1FBRUYsSUFBSSxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUN4QixNQUFNLGlCQUFpQixHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQzlDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUN4RCxPQUFPLEtBQUssQ0FBQztZQUNmLENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ2xDO0lBQ0gsQ0FBQzs7MEdBMUdVLGFBQWE7OEdBQWIsYUFBYSxjQUZaLE1BQU07MkZBRVAsYUFBYTtrQkFIekIsVUFBVTttQkFBQztvQkFDVixVQUFVLEVBQUUsTUFBTTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpbXBvcnRQcm92aWRlcnNGcm9tLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RGbGFncyxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEluamVjdG9yLFxuICBOZ01vZHVsZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciwgUk9VVEVTIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IFJvdXRlRmFjdG9yeSwgUm91dGUsIFZpZXdDb250ZXh0IH0gZnJvbSAnLi9yb3V0ZXIubW9kZWwnO1xuaW1wb3J0IHsgQ29udGV4dFJvdXRlU2VydmljZSB9IGZyb20gJy4vY29udGV4dC1yb3V0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IElNYW5hZ2VkT2JqZWN0IH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHNoYXJlUmVwbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgRXh0ZW5zaW9uRmFjdG9yeSxcbiAgZnJvbVRyaWdnZXJPbmNlLFxuICBHZW5lcmljSG9va1R5cGUsXG4gIGhvb2tHZW5lcmljLFxuICBnZXRJbmplY3RlZEhvb2tzLFxuICBJbmplY3Rpb25UeXBlLFxuICBFeHRlbnNpb25Qb2ludFdpdGhvdXRTdGF0ZUZvclBsdWdpbnMsXG4gIEhvb2tPcHRpb25zXG59IGZyb20gJy4uL2NvbW1vbi9leHRlbnNpb24taG9va3MnO1xuaW1wb3J0IHsgUGx1Z2luc1Jlc29sdmVTZXJ2aWNlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnbG9kYXNoJztcblxuLyoqXG4gKiBBbiBleHRlbnNpb24gSE9PSyBjYW4gdXNlIGVpdGhlciBhIHB1cmUgdmFsdWU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZVZhbHVlOiB7IC4uLmhvb2tWYWx1ZSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqXG4gKiBPciBhbiBhcnJheSB0byBkaXJlY3RseSByZWdpc3RlciBtdWx0aXBsZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IFt7IC4uLmhvb2tWYWx1ZXMgfV0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIEV4dGVuc2lvbkZhY3Rvcnkgd2hpY2ggYWxsb3dzIHRvIGRlZmluZSBhIGdldCgpIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uXG4gKiBnZXRzIGNhbGxlZCBvbiBlYWNoIG5hdmlnYXRpb24gd2l0aCB0aGUgY3VycmVudCByb3V0ZSBhbmQgY2FuIHJldHVybiB2YWx1ZXNcbiAqIGFzeW5jIChvYnNlcnZhYmxlIG9yIHByb21pc2UpLlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VGYWN0b3J5OiB7IGdldDogKHJvdXRlKSA9PiBkb1NvbWV0aGluZ0FzeW5jKHJvdXRlKSB9LCBtdWx0aTogdHJ1ZSB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVFeHRlbnNpb24gPSBSb3V0ZSB8IFJvdXRlW10gfCBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPjtcblxuLyoqXG4gKiBBIGhvb2sgdG8gdXNlIGZvciBNdWx0aSBQcm92aWRlciBleHRlbnNpb24uXG4gKiBAZGVwcmVjYXRlZCBDb25zaWRlciB1c2luZyB0aGUgYGhvb2tSb3V0ZWAgZnVuY3Rpb24gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEhPT0tfUk9VVEUgPSBuZXcgSW5qZWN0aW9uVG9rZW48Um91dGVGYWN0b3J5PignSE9PS19ST1VURScpO1xuXG4vKipcbiAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSBzaW5nbGUgYFJvdXRlYCBhcyBwYXJhbWV0ZXI6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgaG9va1JvdXRlKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tSb3V0ZShbLi4uXSlcbiAqIGBgYFxuICpcbiAqIE9yIHlvdSBwcm92aWRlIGFuIFNlcnZpY2UgdGhhdCBpbXBsZW1lbnRzIGBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPmBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBleHBvcnQgY2xhc3MgTXlSb3V0ZUZhY3RvcnkgaW1wbGVtZW50cyBFeHRlbnNpb25GYWN0b3J5PFJvdXRlPiB7Li4ufVxuICogIC4uLlxuICogIGhvb2tSb3V0ZShNeVJvdXRlRmFjdG9yeSlcbiAqIGBgYFxuICogQSB0eXBlZCBhbHRlcm5hdGl2ZSB0byBgSE9PS19ST1VURWAuXG4gKiBAcGFyYW0gcm91dGUgVGhlIGBSb3V0ZWAncyBvciBgRXh0ZW5zaW9uRmFjdG9yeWAgdG8gYmUgcHJvdmlkZWQuXG4gKiBAcmV0dXJucyBBbiBgUHJvdmlkZXJgIHRvIGJlIHByb3ZpZGVkIGluIHlvdXIgbW9kdWxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaG9va1JvdXRlKHJvdXRlOiBHZW5lcmljSG9va1R5cGU8Um91dGU+LCBvcHRpb25zPzogUGFydGlhbDxIb29rT3B0aW9ucz4pIHtcbiAgcmV0dXJuIGhvb2tHZW5lcmljPFJvdXRlPihyb3V0ZSwgSE9PS19ST1VURSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgcm91dGVzIGZvciB0aGUgYXBwbGljYXRpb24uIFlvdSBjYW4gdXNlXG4gKiBIT09LX1JPVVRFUyBvciBwYXNzXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFJvdXRlclNlcnZpY2UgZXh0ZW5kcyBFeHRlbnNpb25Qb2ludFdpdGhvdXRTdGF0ZUZvclBsdWdpbnM8Um91dGU+IHtcbiAgcmVhZG9ubHkgc3RhdGUgPSBuZXcgTWFwPHN0cmluZywgUm91dGU+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcm9vdEluamVjdG9yOiBJbmplY3RvcixcbiAgICBwdWJsaWMgcm91dGVyOiBSb3V0ZXIsXG4gICAgcHJpdmF0ZSBjb250ZXh0Um91dGVTZXJ2aWNlOiBDb250ZXh0Um91dGVTZXJ2aWNlLFxuICAgIHBsdWdpbnM6IFBsdWdpbnNSZXNvbHZlU2VydmljZVxuICApIHtcbiAgICBzdXBlcihyb290SW5qZWN0b3IsIHBsdWdpbnMpO1xuICAgIHRoaXMuaXRlbXMkID0gdGhpcy5zZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpO1xuXG4gICAgLy8gV2UgYXJlIGRvaW5nIGEgc2VsZiBzdWJzY3JpcHRpb24gdG8gYWRkIHRoZSBuZXcgcm91dGVzXG4gICAgLy8gdG8gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uLlxuICAgIHRoaXMuaXRlbXMkLnN1YnNjcmliZSgocm91dGVzOiBSb3V0ZVtdKSA9PiB7XG4gICAgICBjb25zdCB0b0FkZFJvdXRlcyA9IHJvdXRlcy5maWx0ZXIoKHJvdXRlOiBSb3V0ZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gYCR7cm91dGUuY29udGV4dCB8fCAnJ30ke3JvdXRlLnBhdGh9YDtcbiAgICAgICAgY29uc3QgaXNBbHJlYWR5QWRkZWQgPSB0aGlzLnN0YXRlLmhhcyhwYXRoKTtcbiAgICAgICAgaWYgKCFpc0FscmVhZHlBZGRlZCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUuc2V0KHBhdGgsIHJvdXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWlzQWxyZWFkeUFkZGVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZFJvdXRlKHRvQWRkUm91dGVzKTtcbiAgICB9KTtcblxuICAgIHBsdWdpbnMucGx1Z2luRGV0YWlscyQuc3Vic2NyaWJlKCh7IG1vZHVsZVJlZiwgcmVtb3RlTmdNb2R1bGUgfSkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlUm91dGVyRm9yQ2hpbGRSb3V0ZXMobW9kdWxlUmVmLCByZW1vdGVOZ01vZHVsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY3VycmVudCBjb250ZXh0XG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHN1cGVyLnJlZnJlc2goKTtcbiAgICB0aGlzLmNvbnRleHRSb3V0ZVNlcnZpY2UucmVmcmVzaENvbnRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgcm91dGUgdG8gdGhlIHJvdXRlciBjb25maWd1cmF0aW9uIG9yIGEgY29udGV4dC5cbiAgICogQHBhcmFtIHJvdXRlIFRoZSByb3V0ZSB0byBhZGRcbiAgICovXG4gIGFkZFJvdXRlKHJvdXRlOiBSb3V0ZSB8IFJvdXRlW10pIHtcbiAgICB0aGlzLmFkZFJvdXRlcyhBcnJheS5pc0FycmF5KHJvdXRlKSA/IHJvdXRlIDogW3JvdXRlXSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gTU8gaXMgYW4gZ3JvdXAgb3IgYW4gZGV2aWNlIGFuZCByZXR1cm5zXG4gICAqIHRoZSBjb3JyZWN0IGhyZWYgdG8gbGluayBjb3JyZWN0bHkgdG8gdGhhdCBNTy5cbiAgICogQHBhcmFtIGdyb3VwT3JEZXZpY2UgVGhlIE1PIG9mIGEgZ3JvdXAgb3IgdGhlIGRldmljZS5cbiAgICogQHBhcmFtIHByZWZpeCBIb3cgc2hvdWxkIHRoZSBsaW5rIGJlIHByZWZpeGVkLlxuICAgKi9cbiAgZ2V0SHJlZihncm91cE9yRGV2aWNlOiBJTWFuYWdlZE9iamVjdCwgcHJlZml4ID0gJyMvJyk6IHN0cmluZyB7XG4gICAgaWYgKGdyb3VwT3JEZXZpY2UuYzh5X0lzRGV2aWNlR3JvdXAgfHwgZ3JvdXBPckRldmljZS5jOHlfSXNEeW5hbWljR3JvdXApIHtcbiAgICAgIHJldHVybiBgJHtwcmVmaXh9JHtWaWV3Q29udGV4dC5Hcm91cC5yZXBsYWNlKCc6aWQnLCBncm91cE9yRGV2aWNlLmlkKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7Vmlld0NvbnRleHQuRGV2aWNlLnJlcGxhY2UoJzppZCcsIGdyb3VwT3JEZXZpY2UuaWQpfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgc2V0dXBJdGVtc09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxSb3V0ZVtdPiB7XG4gICAgcmV0dXJuIGZyb21UcmlnZ2VyT25jZTxSb3V0ZT4odGhpcy5yb3V0ZXIsIHRoaXMucmVmcmVzaCQsIFtcbiAgICAgIGdldEluamVjdGVkSG9va3M8Um91dGU+KEhPT0tfUk9VVEUsIHRoaXMuaW5qZWN0b3JzLCBJbmplY3Rpb25UeXBlLlJPVVRFKSxcbiAgICAgICgpID0+IHRoaXMuZmFjdG9yaWVzXG4gICAgXSkucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCBzaGFyZVJlcGxheSgxKSk7XG4gIH1cblxuICBwcml2YXRlIGFkZFJvdXRlcyhyb3V0ZXMpIHtcbiAgICAvLyBFbXB0eSByb3V0ZSBuZWVkcyB0byBiZSBsYXN0IGFzIG9mIG5hdmlnYXRpb24gdG8gYW5ndWxhcmpzIHJvdXRlc1xuICAgIC8vIGlmICoqIHJvdXRlIGhpdCwgdGhlIGFuZ3VsYXJqcyByb3V0ZXMgYXJlIGxvYWRlZC5cbiAgICBjb25zdCBlbXB0eVJvdXRlID0gdGhpcy5yb3V0ZXIuY29uZmlnLmZpbmQociA9PiByLnBhdGggPT09ICcqKicpO1xuICAgIHRoaXMucm91dGVyLnJlc2V0Q29uZmlnKFxuICAgICAgW1xuICAgICAgICAuLi50aGlzLnJvdXRlci5jb25maWcuZmlsdGVyKHIgPT4gci5wYXRoICE9PSAnKionKSxcbiAgICAgICAgLi4ucm91dGVzLm1hcCgocjogUm91dGUpID0+IHRoaXMuY29udmVydFJvdXRlKHRoaXMucm91dGVyLmNvbmZpZywgcikpLFxuICAgICAgICBlbXB0eVJvdXRlXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRSb3V0ZShpbml0aWFsQ29uZmlnLCByb3V0ZTogUm91dGUpIHtcbiAgICBpZiAocm91dGUuY29udGV4dCkge1xuICAgICAgaW5pdGlhbENvbmZpZy5mb3JFYWNoKChyOiBSb3V0ZSkgPT4ge1xuICAgICAgICBpZiAoci5kYXRhICYmIHIuZGF0YS5jb250ZXh0ID09PSByb3V0ZS5jb250ZXh0KSB7XG4gICAgICAgICAgci5jaGlsZHJlbiA9IFtyb3V0ZSwgLi4uKHIuY2hpbGRyZW4gfHwgW10pXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiByb3V0ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVJvdXRlckZvckNoaWxkUm91dGVzKG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8YW55PiwgcmVtb3RlTmdNb2R1bGU6IGFueSkge1xuICAgIC8vIE5PVEU6IHN0b2xlbiBmcm9tIGxhenkgbG9hZGVkIHJvdXRlcyBmcm9tIEFuZ3VsYXIgaXRzZWxmLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi9kYTU4ODAxZjk1YzY2YzIwMWUzMzIxODlhZjI1NzAyYmRkNzIyZjNmL3BhY2thZ2VzL3JvdXRlci9zcmMvcm91dGVyX2NvbmZpZ19sb2FkZXIudHMjTDEwMy1MMTA4XG4gICAgY29uc3QgcmF3Um91dGVzID0gZmxhdHRlbihcbiAgICAgIG1vZHVsZVJlZi5pbmplY3Rvci5nZXQoUk9VVEVTLCBbXSwgSW5qZWN0RmxhZ3MuU2VsZiB8IEluamVjdEZsYWdzLk9wdGlvbmFsKVxuICAgICk7XG5cbiAgICBpZiAocmF3Um91dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJvdXRlV2l0aEluamVjdG9yID0gcmF3Um91dGVzLm1hcChyb3V0ZSA9PiB7XG4gICAgICAgIHJvdXRlLnByb3ZpZGVycyA9IFtpbXBvcnRQcm92aWRlcnNGcm9tKHJlbW90ZU5nTW9kdWxlKV07XG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRSb3V0ZShyb3V0ZVdpdGhJbmplY3Rvcik7XG4gICAgfVxuICB9XG59XG4iXX0=