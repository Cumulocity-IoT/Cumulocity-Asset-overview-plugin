import { coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectorRef, ComponentFactoryResolver, Directive, EventEmitter, Input, Output, TemplateRef, ViewContainerRef } from '@angular/core';
import { assign, get } from 'lodash-es';
import { combineLatest, isObservable, of, pipe, Subject } from 'rxjs';
import { filter, map, takeUntil, tap } from 'rxjs/operators';
import { RealtimeService } from '../realtime/realtime.service';
import { LoadMoreComponent } from './load-more.component';
import { VirtualScrollerWrapperComponent } from './virtual-scroll/virtual-scroller-wrapper.component';
import * as i0 from "@angular/core";
/**
 * A directive to iterate over IResultList<T> data from @c8y/client.
 * Depending on the [c8yForLoadMore] a load more button is:
 *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
 *          change with maxIterations settings).
 *  - show: Shows a load more button for the user to decide
 *  - none: Doesn't perform any load more action.
 *  - hidden: Loads more data automatically but with no visible button for the user.
 *
 * Additional, any rxjs operator pipe can be applied to the [c8yForPipe] input, e.g. to
 * filter the data displayed currently as well as the data loaded by subsequent requests.
 *
 * Example:
 * ```html
 * <div *c8yFor="let device of devices; loadMore: 'auto'; let i = index; pipe: filterPipe;">
 *  {{ i + 1 }}. {{device.name}}
 * </div>
 * ```
 * The above example will list all entities that are applied to `devices`:
 * ```typescript
 * this.devices = this.inventoryService.list({ pageSize: 10, fragmentType: 'c8y_IsDevice' })
 * ```
 * It will display the first 10 items, if there is more space left on the screen, and there are more
 * than 10 devices, it will automatically load up to 10 pages more. If it still can't fit the screen
 * it will stop and switch to `show` mode.
 *
 * A pipe can be applied e.g. for filtering or grouping. This pipe is attached to every follow up
 * request done by the load more component:
 * ```typescript
 * this.filterPipe = pipe(
 *    map((data: []) => {
 *     return data.filter(
 *      (mo: any) => mo.name && mo.name.toLowerCase().indexOf(value.toLowerCase()) > -1
 *    );
 *  })
 * );
 * ```
 * The pipe must be an rxjs pipe and can take any operator.
 *
 * Example with realtime support and items count output (e.g. for handling empty state and header):
 *
 * ```html
 * <c8y-list-group>
 *   <div class="c8y-empty-state" *ngIf="count === 0">
 *     (...)
 *   </div>
 *
 *   <div class="page-sticky-header hidden-xs c8y-list__item c8y-list--timeline" *ngIf="count > 0">
 *     (...)
 *   </div>
 *
 *   <ng-template
 *     c8yFor
 *     let-operation
 *     [c8yForOf]="items$"
 *     [c8yForPipe]="filterPipe"
 *     [c8yForRealtime]="realtime"
 *     [c8yForRealtimeOptions]="realtimeOptions"
 *     (c8yForCount)="count = $event"
 *   >
 *     <c8y-li-timeline>
 *       (...)
 *     </c8y-li-timeline>
 *   </ng-template>
 * </c8y-list-group>
 * ```
 *
 * ```typescript
 * @Component({
 *   (...)
 * })
 * export class ExampleComponent {
 *   @Input() deviceId: IIdentified;
 *   items$ = this.operationService.list({
 *     deviceId: this.deviceId,
 *     fragmentType: 'c8y_MyOperation',
 *     dateFrom: new Date(0).toISOString(),
 *     dateTo: new Date(Date.now()).toISOString(),
 *     revert: true,
 *     withTotalPages: true
 *   });
 *   filterPipe = pipe(map((ops: IOperation[]) => ops.filter(op => op.c8y_MyOperation)));
 *   realtimeOptions: ForOfRealtimeOptions = {
 *     entityOrId: this.deviceId,
 *     removeOnUpdate: true,
 *     insertOnUpdate: true
 *   } as ForOfRealtimeOptions;
 *   count: number;
 *
 *   constructor(
 *     private operationService: OperationService,
 *     public realtime: OperationRealtimeService
 *   ) {}
 * }
 * ```
 */
export class ForOfDirective {
    constructor(tpl, vcr, componentFactoryResolver, cdRef) {
        this.tpl = tpl;
        this.vcr = vcr;
        this.componentFactoryResolver = componentFactoryResolver;
        this.cdRef = cdRef;
        this.cachedData = [];
        this.loadMoreMode = 'auto';
        this.dataPipe = pipe(tap());
        this.itemDataPipe = pipe(map(item => [item]), src => this.dataPipe(src), map(([item]) => item));
        this.maxIterations = 10;
        this.realtimeOptions = {};
        this.unsubscribe$ = new Subject();
        /**
         * Enable virtual scroll rendering method.
         */
        this.c8yForEnableVirtualScroll = false;
        /**
         * Sets mode of virtual scroller instance.
         * window is used for case when whole viewport is scrolled.
         * fixed can be used on inner-scroll containers.
         */
        this.c8yForVirtualScrollStrategy = 'window';
        /**
         * The number of items currently loaded in the list.
         */
        this.c8yForCount = new EventEmitter();
        this.count = 0;
    }
    get shouldUseLoadMoreButton() {
        return (this.loadMoreMode === 'auto' || this.loadMoreMode === 'show' || this.loadMoreMode === 'hidden');
    }
    get hasMoreData() {
        return this.loadMore && this.loadMore.hasMore;
    }
    get length() {
        return this.cachedData.length;
    }
    /**
     * The data setter. Must be a response from @c8y/data or an observable.
     * You can pass an observable with null to explicitly clear the list.
     */
    set c8yForOf(fetchData) {
        if (fetchData) {
            this.obs$ = (isObservable(fetchData) ? fetchData : of(fetchData)).pipe(map(result => {
                if (result === null) {
                    this.paging = null;
                    return [];
                }
                const { paging, data } = result;
                this.paging = paging;
                return data;
            }));
        }
    }
    /**
     * The mode setter:
     *  - auto: Tries to automatically load more data (default maximum 10 iterations; can be
     *          change with maxIterations settings).
     *  - show: Shows a load more button for the user to decide
     *  - none: Doesn't perform any load more action.
     *  - hidden: Loads more data automatically but with no visible button for the user.
     */
    set c8yForLoadMore(type) {
        this.loadMoreMode = type;
    }
    /**
     * The pipe setter to attach any rxjs pipe to the current and more loaded data.
     */
    set c8yForPipe(dataPipe) {
        if (dataPipe) {
            this.dataPipe = dataPipe;
        }
    }
    /**
     * A template to use if no data is found at all (e.g. if you apply a filter pipe).
     */
    set c8yForNotFound(notFoundTemplate) {
        this.notFoundTemplate = notFoundTemplate;
        if (this.loadMore) {
            this.loadMore.noMoreDataHint = notFoundTemplate;
        }
    }
    /**
     * The maximum numbers of iterations to call data from the api.
     */
    set c8yForMaxIterations(maxIterations) {
        this.maxIterations = maxIterations;
    }
    /**
     * A custom loading component.
     */
    set c8yForLoadingTemplate(loadingTemplate) {
        this.loadingTemplate = loadingTemplate;
    }
    /**
     * Load next text label.
     */
    set c8yForLoadNextLabel(loadNextLabel) {
        this.loadNextLabel = loadNextLabel;
    }
    /**
     * A RealtimeService instance.
     */
    set c8yForRealtime(source) {
        this.realtime = source;
    }
    /**
     * Realtime options.
     */
    set c8yForRealtimeOptions(realtimeOptions) {
        this.realtimeOptions = realtimeOptions;
    }
    /**
     * A comparator function for comparing list items. Used to determine
     * the position at which a new element should be added to the list.
     */
    set c8yForComparator(comparator) {
        this.comparator = comparator;
    }
    ngOnInit() {
        this.handleRealtime();
    }
    ngOnChanges(changes) {
        if (this.obs$ && (changes.c8yForPipe || changes.c8yForOf)) {
            this.unsubscribePaging();
            if (this.virtualScrollInstance) {
                this.virtualScrollInstance.filterPipe = this.dataPipe;
                window.scrollTo({ top: 0 });
            }
            // only re-rendering  on filtering if all data is already loaded
            // from the backend
            const reRender = !this.hasMoreData && !!changes.c8yForPipe && !changes.c8yForOf;
            if (reRender) {
                this.obs$ = of(this.cachedData);
            }
            this.pagingSub = this.obs$
                .pipe(tap(data => {
                if (!reRender) {
                    this.cachedData = data;
                }
            }))
                .pipe(src => this.dataPipe(src))
                .subscribe((data) => {
                this.updateCount(data.length);
                this.render(data, reRender);
            });
        }
    }
    ngOnDestroy() {
        this.unsubscribePaging();
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    handleRealtime() {
        if (this.realtime) {
            this.handleRealtimeCreate();
            this.handleRealtimeUpdate();
            this.handleRealtimeDelete();
        }
    }
    /**
     * On create notification:
     * - if item passes data pipe, then insert it.
     * @private
     */
    handleRealtimeCreate() {
        const { entityOrId } = this.realtimeOptions;
        this.realtime
            .onCreate$(entityOrId)
            .pipe(item$ => this.itemDataPipe(item$), filter(item => item), takeUntil(this.unsubscribe$))
            .subscribe(item => this.insert(item));
    }
    /**
     * On update notification:
     * - if item is displayed and passes data pipe, then update it,
     * - if item is displayed and doesn't pass data pipe, then remove it (if `removeOnUpdate` is true),
     * - if item is not displayed and passes data pipe, then insert it (if `insertOnUpdate` is true),
     * - if item is not displayed and doesn't pass data pipe, then ignore it.
     * @private
     */
    handleRealtimeUpdate() {
        const { entityOrId } = this.realtimeOptions;
        this.realtime
            .onUpdate$(entityOrId)
            .pipe(item$ => combineLatest([
            item$,
            item$.pipe(src => this.itemDataPipe(src), map(item => item !== undefined))
        ]), takeUntil(this.unsubscribe$))
            .subscribe(([item, passesDataPipe]) => {
            const { insertOnUpdate, removeOnUpdate } = this.realtimeOptions;
            const displayed = this.isDisplayed(coerceNumberProperty(item.id));
            if (displayed) {
                if (passesDataPipe) {
                    this.update(item);
                }
                else if (removeOnUpdate) {
                    this.remove(coerceNumberProperty(item.id));
                }
            }
            else if (passesDataPipe && insertOnUpdate) {
                this.insert(item);
            }
        });
    }
    /**
     * On delete notification:
     * - remove item from the list (if not there, it will be just ignored).
     * @private
     */
    handleRealtimeDelete() {
        const { entityOrId } = this.realtimeOptions;
        this.realtime
            .onDelete$(entityOrId)
            .pipe(takeUntil(this.unsubscribe$))
            .subscribe(id => this.remove(coerceNumberProperty(id)));
    }
    render(data, reRender = false) {
        if (this.c8yForEnableVirtualScroll) {
            if (!this.virtualScrollInstance) {
                this.virtualScrollInstance = this.createVirtualScrollWrapperComponent();
                if (this.shouldUseLoadMoreButton) {
                    this.loadMore = this.createLoadMoreButtonComponent(false);
                }
            }
            this.setVirtualScrollContents(data);
            return;
        }
        this.vcr.clear();
        data.forEach((item, index) => {
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData,
                loadMoreComponent: this.loadMore
            };
            this.vcr.createEmbeddedView(this.tpl, context);
        });
        if (this.shouldUseLoadMoreButton) {
            this.loadMore = this.createLoadMoreButtonComponent(reRender);
        }
    }
    append(data) {
        if (this.c8yForEnableVirtualScroll) {
            this.appendVirtualScrollContent(data);
            return;
        }
        data.forEach(item => {
            const index = this.shouldUseLoadMoreButton ? this.vcr.length - 1 : this.vcr.length;
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData,
                loadMoreComponent: this.loadMore
            };
            this.vcr.createEmbeddedView(this.tpl, context, index);
        });
    }
    loadMoreData(data) {
        if (data.length > 0) {
            this.updateCount(data.length);
            this.append(data);
        }
        this.cdRef.detectChanges();
    }
    createLoadMoreButtonComponent(reRender) {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(LoadMoreComponent);
        const componentRef = this.vcr.createComponent(componentFactory);
        const instance = componentRef.instance;
        instance.paging = this.paging;
        instance.useIntersection = this.loadMoreMode === 'auto' || this.loadMoreMode === 'hidden';
        instance.hidden = this.loadMoreMode === 'hidden';
        instance.maxIterations = this.maxIterations;
        instance.noMoreDataHint = this.notFoundTemplate;
        instance.loadingTemplate = this.loadingTemplate;
        instance.loadNextLabel = this.loadNextLabel;
        this.pagingSub = instance.onLoad
            .pipe(map((data) => this.checkForDuplicates(data)), tap((data) => {
            this.cachedData = this.cachedData.concat(data);
        }))
            .pipe(src => this.dataPipe(src))
            .subscribe(data => this.loadMoreData(data));
        if (reRender) {
            assign(instance, this.loadMore);
        }
        return instance;
    }
    createVirtualScrollWrapperComponent() {
        const componentFactory = this.componentFactoryResolver.resolveComponentFactory(VirtualScrollerWrapperComponent);
        const componentRef = this.vcr.createComponent(componentFactory);
        const instance = componentRef.instance;
        instance.items = this.cachedData;
        instance.itemHeight = this.c8yForVirtualScrollElementSize;
        instance.template = this.tpl;
        instance.strategy = this.c8yForVirtualScrollStrategy;
        instance.containerHeight = this.c8yForVirtualScrollContainerHeight;
        return instance;
    }
    insert(item) {
        let index = 0;
        if (this.comparator && this.cachedData.length) {
            let comparisionResult;
            do {
                const view = this.vcr.get(index);
                const itemB = get(view, 'context.$implicit');
                comparisionResult = item && itemB ? this.comparator(item, itemB) : 0;
                if (comparisionResult <= 0) {
                    index++;
                }
            } while (comparisionResult <= 0 && index < this.cachedData.length);
        }
        // Do not append elements after the last one currently loaded,
        // as it may belong further down there on the list and will
        // be eventually loaded with one of the next pages.
        if (index < this.cachedData.length || this.cachedData.length === 0) {
            const context = {
                $implicit: item,
                index,
                length: this.length,
                hasMore: this.hasMoreData
            };
            this.cachedData.splice(index, 0, item);
            const viewRef = this.tpl.createEmbeddedView(context);
            this.vcr.insert(viewRef, index);
            this.updateCount(1);
        }
    }
    update(updatedItem) {
        this.forMatchingEmbeddedViewRef((item) => item && updatedItem && item.id === updatedItem.id, (view) => {
            view.context.$implicit = updatedItem;
            view.markForCheck();
        });
    }
    remove(idToRemove) {
        if (this.isDisplayed(idToRemove)) {
            this.updateCount(-1);
        }
        this.forMatchingEmbeddedViewRef((item) => item && coerceNumberProperty(item.id, NaN) === idToRemove, (view) => view.destroy());
    }
    updateCount(countChange) {
        this.count += countChange;
        this.c8yForCount.emit(this.count);
    }
    isDisplayed(idToCheck) {
        let displayed = false;
        this.forMatchingEmbeddedViewRef((item) => item && coerceNumberProperty(item.id, NaN) === idToCheck, () => {
            displayed = true;
        });
        return displayed;
    }
    forMatchingEmbeddedViewRef(filterFn, callbackFn) {
        for (let i = 0; i < this.vcr.length; i++) {
            const view = this.vcr.get(i);
            const item = get(view, 'context.$implicit');
            if (filterFn(item)) {
                callbackFn(view);
            }
        }
    }
    checkForDuplicates(data) {
        return this.realtime
            ? data.filter(item => !this.cachedData.some(cached => cached.id === item.id))
            : data;
    }
    unsubscribePaging() {
        if (this.pagingSub) {
            this.pagingSub.unsubscribe();
        }
    }
    setVirtualScrollContents(items) {
        if (this.c8yForEnableVirtualScroll && this.virtualScrollInstance) {
            this.virtualScrollInstance.items = items;
            this.virtualScrollInstance.apply();
        }
    }
    appendVirtualScrollContent(items) {
        if (this.c8yForEnableVirtualScroll && this.virtualScrollInstance) {
            this.virtualScrollInstance.items = this.virtualScrollInstance.items.concat(items);
            this.virtualScrollInstance.apply();
        }
    }
}
ForOfDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: ForOfDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
ForOfDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "14.0.6", type: ForOfDirective, selector: "[c8yFor]", inputs: { c8yForOf: "c8yForOf", c8yForLoadMore: "c8yForLoadMore", c8yForPipe: "c8yForPipe", c8yForNotFound: "c8yForNotFound", c8yForMaxIterations: "c8yForMaxIterations", c8yForLoadingTemplate: "c8yForLoadingTemplate", c8yForLoadNextLabel: "c8yForLoadNextLabel", c8yForRealtime: "c8yForRealtime", c8yForRealtimeOptions: "c8yForRealtimeOptions", c8yForComparator: "c8yForComparator", c8yForEnableVirtualScroll: "c8yForEnableVirtualScroll", c8yForVirtualScrollElementSize: "c8yForVirtualScrollElementSize", c8yForVirtualScrollStrategy: "c8yForVirtualScrollStrategy", c8yForVirtualScrollContainerHeight: "c8yForVirtualScrollContainerHeight" }, outputs: { c8yForCount: "c8yForCount" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: ForOfDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[c8yFor]'
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { c8yForOf: [{
                type: Input
            }], c8yForLoadMore: [{
                type: Input
            }], c8yForPipe: [{
                type: Input
            }], c8yForNotFound: [{
                type: Input
            }], c8yForMaxIterations: [{
                type: Input
            }], c8yForLoadingTemplate: [{
                type: Input
            }], c8yForLoadNextLabel: [{
                type: Input
            }], c8yForRealtime: [{
                type: Input
            }], c8yForRealtimeOptions: [{
                type: Input
            }], c8yForComparator: [{
                type: Input
            }], c8yForEnableVirtualScroll: [{
                type: Input
            }], c8yForVirtualScrollElementSize: [{
                type: Input
            }], c8yForVirtualScrollStrategy: [{
                type: Input
            }], c8yForVirtualScrollContainerHeight: [{
                type: Input
            }], c8yForCount: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yT2YuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vZm9yT2YuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzdELE9BQU8sRUFDTCxpQkFBaUIsRUFFakIsd0JBQXdCLEVBQ3hCLFNBQVMsRUFFVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFFTixXQUFXLEVBQ1gsZ0JBQWdCLEVBRWpCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFjLEVBQUUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUNoRyxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRzFELE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHFEQUFxRCxDQUFDOztBQUV0Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0ErRkc7QUFJSCxNQUFNLE9BQU8sY0FBYztJQThLekIsWUFDVSxHQUFxQixFQUNyQixHQUFxQixFQUNyQix3QkFBa0QsRUFDbEQsS0FBd0I7UUFIeEIsUUFBRyxHQUFILEdBQUcsQ0FBa0I7UUFDckIsUUFBRyxHQUFILEdBQUcsQ0FBa0I7UUFDckIsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUEwQjtRQUNsRCxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQWpMMUIsZUFBVSxHQUFrQixFQUFFLENBQUM7UUFFL0IsaUJBQVksR0FBaUIsTUFBTSxDQUFDO1FBQ3BDLGFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUN2QixpQkFBWSxHQUFHLElBQUksQ0FDekIsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUNuQixHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQ3pCLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUN0QixDQUFDO1FBS00sa0JBQWEsR0FBRyxFQUFFLENBQUM7UUFJbkIsb0JBQWUsR0FBeUIsRUFBMEIsQ0FBQztRQUVuRSxpQkFBWSxHQUFrQixJQUFJLE9BQU8sRUFBRSxDQUFDO1FBeUhwRDs7V0FFRztRQUVLLDhCQUF5QixHQUFHLEtBQUssQ0FBQztRQVExQzs7OztXQUlHO1FBRUssZ0NBQTJCLEdBQXVCLFFBQVEsQ0FBQztRQVFuRTs7V0FFRztRQUVLLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUN6QyxVQUFLLEdBQUcsQ0FBQyxDQUFDO0lBT2YsQ0FBQztJQTVKSixJQUFZLHVCQUF1QjtRQUNqQyxPQUFPLENBQ0wsSUFBSSxDQUFDLFlBQVksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxRQUFRLENBQy9GLENBQUM7SUFDSixDQUFDO0lBRUQsSUFBWSxXQUFXO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztJQUNoRCxDQUFDO0lBRUQsSUFBWSxNQUFNO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQ0ksUUFBUSxDQUFDLFNBQTBFO1FBQ3JGLElBQUksU0FBUyxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3BFLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDWCxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7b0JBQ25CLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO29CQUNuQixPQUFPLEVBQUUsQ0FBQztpQkFDWDtnQkFDRCxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQztnQkFDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQ0gsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxJQUNJLGNBQWMsQ0FBQyxJQUFrQjtRQUNuQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLFVBQVUsQ0FBQyxRQUFRO1FBQ3JCLElBQUksUUFBUSxFQUFFO1lBQ1osSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7U0FDMUI7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLGNBQWMsQ0FBQyxnQkFBa0M7UUFDbkQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLGdCQUFnQixDQUFDO1FBQ3pDLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQztTQUNqRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0ksbUJBQW1CLENBQUMsYUFBcUI7UUFDM0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFDckMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFDSSxxQkFBcUIsQ0FBQyxlQUFpQztRQUN6RCxJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLG1CQUFtQixDQUFDLGFBQXFCO1FBQzNDLElBQUksQ0FBQyxhQUFhLEdBQUcsYUFBYSxDQUFDO0lBQ3JDLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0ksY0FBYyxDQUFDLE1BQTRCO1FBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0kscUJBQXFCLENBQUMsZUFBcUM7UUFDN0QsSUFBSSxDQUFDLGVBQWUsR0FBRyxlQUFlLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7T0FHRztJQUNILElBQ0ksZ0JBQWdCLENBQUMsVUFBb0Q7UUFDdkUsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztJQTBDRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTyxXQUFXLENBQUMsT0FBc0I7UUFDeEMsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekQsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7WUFFekIsSUFBSSxJQUFJLENBQUMscUJBQXFCLEVBQUU7Z0JBQzlCLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztnQkFDdEQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQzdCO1lBRUQsZ0VBQWdFO1lBQ2hFLG1CQUFtQjtZQUNuQixNQUFNLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO1lBRWhGLElBQUksUUFBUSxFQUFFO2dCQUNaLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNqQztZQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUk7aUJBQ3ZCLElBQUksQ0FDSCxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ1QsSUFBSSxDQUFDLFFBQVEsRUFBRTtvQkFDYixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztpQkFDeEI7WUFDSCxDQUFDLENBQUMsQ0FDSDtpQkFDQSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUMvQixTQUFTLENBQUMsQ0FBQyxJQUFRLEVBQUUsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQzlCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQzlCLENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDSCxDQUFDO0lBRU8sV0FBVztRQUNqQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDL0IsQ0FBQztJQUVPLGNBQWM7UUFDcEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBQzVCLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQzdCO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxvQkFBb0I7UUFDMUIsTUFBTSxFQUFFLFVBQVUsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDNUMsSUFBSSxDQUFDLFFBQVE7YUFDVixTQUFTLENBQUMsVUFBVSxDQUFDO2FBQ3JCLElBQUksQ0FDSCxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQ2pDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUNwQixTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUM3QjthQUNBLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNLLG9CQUFvQjtRQUMxQixNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM1QyxJQUFJLENBQUMsUUFBUTthQUNWLFNBQVMsQ0FBQyxVQUFVLENBQUM7YUFDckIsSUFBSSxDQUNILEtBQUssQ0FBQyxFQUFFLENBQ04sYUFBYSxDQUFDO1lBQ1osS0FBSztZQUNMLEtBQUssQ0FBQyxJQUFJLENBQ1IsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUM3QixHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQ2hDO1NBQ0YsQ0FBQyxFQUNKLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQzdCO2FBQ0EsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLEVBQUUsRUFBRTtZQUNwQyxNQUFNLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDaEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsRSxJQUFJLFNBQVMsRUFBRTtnQkFDYixJQUFJLGNBQWMsRUFBRTtvQkFDbEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDbkI7cUJBQU0sSUFBSSxjQUFjLEVBQUU7b0JBQ3pCLElBQUksQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzVDO2FBQ0Y7aUJBQU0sSUFBSSxjQUFjLElBQUksY0FBYyxFQUFFO2dCQUMzQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ25CO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLG9CQUFvQjtRQUMxQixNQUFNLEVBQUUsVUFBVSxFQUFFLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUM1QyxJQUFJLENBQUMsUUFBUTthQUNWLFNBQVMsQ0FBQyxVQUFVLENBQUM7YUFDckIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDbEMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztJQUVPLE1BQU0sQ0FBQyxJQUFJLEVBQUUsUUFBUSxHQUFHLEtBQUs7UUFDbkMsSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtnQkFDL0IsSUFBSSxDQUFDLHFCQUFxQixHQUFHLElBQUksQ0FBQyxtQ0FBbUMsRUFBRSxDQUFDO2dCQUN4RSxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtvQkFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsNkJBQTZCLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQzNEO2FBQ0Y7WUFFRCxJQUFJLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEMsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUVqQixJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO1lBQzNCLE1BQU0sT0FBTyxHQUFHO2dCQUNkLFNBQVMsRUFBRSxJQUFJO2dCQUNmLEtBQUs7Z0JBQ0wsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVc7Z0JBQ3pCLGlCQUFpQixFQUFFLElBQUksQ0FBQyxRQUFRO2FBQ2pDLENBQUM7WUFDRixJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDakQsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtZQUNoQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM5RDtJQUNILENBQUM7SUFFTyxNQUFNLENBQUMsSUFBSTtRQUNqQixJQUFJLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtZQUNsQyxJQUFJLENBQUMsMEJBQTBCLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdEMsT0FBTztTQUNSO1FBRUQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNsQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7WUFDbkYsTUFBTSxPQUFPLEdBQUc7Z0JBQ2QsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsS0FBSztnQkFDTCxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07Z0JBQ25CLE9BQU8sRUFBRSxJQUFJLENBQUMsV0FBVztnQkFDekIsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLFFBQVE7YUFDakMsQ0FBQztZQUNGLElBQUksQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDeEQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sWUFBWSxDQUFDLElBQUk7UUFDdkIsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ25CO1FBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRU8sNkJBQTZCLENBQUMsUUFBUTtRQUM1QyxNQUFNLGdCQUFnQixHQUNwQixJQUFJLENBQUMsd0JBQXdCLENBQUMsdUJBQXVCLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUMzRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ2hFLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxRQUE2QixDQUFDO1FBQzVELFFBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUM5QixRQUFRLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxZQUFZLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxZQUFZLEtBQUssUUFBUSxDQUFDO1FBQzFGLFFBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksS0FBSyxRQUFRLENBQUM7UUFDakQsUUFBUSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzVDLFFBQVEsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1FBQ2hELFFBQVEsQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUNoRCxRQUFRLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7UUFDNUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTTthQUM3QixJQUFJLENBQ0gsR0FBRyxDQUFDLENBQUMsSUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDaEQsR0FBRyxDQUFDLENBQUMsSUFBUSxFQUFFLEVBQUU7WUFDZixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pELENBQUMsQ0FBQyxDQUNIO2FBQ0EsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMvQixTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDOUMsSUFBSSxRQUFRLEVBQUU7WUFDWixNQUFNLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNqQztRQUNELE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFTyxtQ0FBbUM7UUFDekMsTUFBTSxnQkFBZ0IsR0FDcEIsSUFBSSxDQUFDLHdCQUF3QixDQUFDLHVCQUF1QixDQUFDLCtCQUErQixDQUFDLENBQUM7UUFDekYsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUNoRSxNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsUUFBMkMsQ0FBQztRQUMxRSxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFDakMsUUFBUSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsOEJBQThCLENBQUM7UUFDMUQsUUFBUSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1FBQzdCLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLDJCQUEyQixDQUFDO1FBQ3JELFFBQVEsQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGtDQUFrQyxDQUFDO1FBRW5FLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFTyxNQUFNLENBQUMsSUFBSTtRQUNqQixJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7UUFFZCxJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUU7WUFDN0MsSUFBSSxpQkFBeUIsQ0FBQztZQUM5QixHQUFHO2dCQUNELE1BQU0sSUFBSSxHQUF5QixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQXlCLENBQUM7Z0JBQy9FLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztnQkFDN0MsaUJBQWlCLEdBQUcsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDckUsSUFBSSxpQkFBaUIsSUFBSSxDQUFDLEVBQUU7b0JBQzFCLEtBQUssRUFBRSxDQUFDO2lCQUNUO2FBQ0YsUUFBUSxpQkFBaUIsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO1NBQ3BFO1FBRUQsOERBQThEO1FBQzlELDJEQUEyRDtRQUMzRCxtREFBbUQ7UUFDbkQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2xFLE1BQU0sT0FBTyxHQUFHO2dCQUNkLFNBQVMsRUFBRSxJQUFJO2dCQUNmLEtBQUs7Z0JBQ0wsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO2dCQUNuQixPQUFPLEVBQUUsSUFBSSxDQUFDLFdBQVc7YUFDMUIsQ0FBQztZQUVGLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDdkMsTUFBTSxPQUFPLEdBQVksSUFBSSxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUM5RCxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQjtJQUNILENBQUM7SUFFTyxNQUFNLENBQUMsV0FBVztRQUN4QixJQUFJLENBQUMsMEJBQTBCLENBQzdCLENBQUMsSUFBaUIsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLFdBQVcsSUFBSSxJQUFJLENBQUMsRUFBRSxLQUFLLFdBQVcsQ0FBQyxFQUFFLEVBQ3hFLENBQUMsSUFBMEIsRUFBRSxFQUFFO1lBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQztZQUNyQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDdEIsQ0FBQyxDQUNGLENBQUM7SUFDSixDQUFDO0lBRU8sTUFBTSxDQUFDLFVBQVU7UUFDdkIsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ2hDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN0QjtRQUNELElBQUksQ0FBQywwQkFBMEIsQ0FDN0IsQ0FBQyxJQUFpQixFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsS0FBSyxVQUFVLEVBQ2hGLENBQUMsSUFBMEIsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUMvQyxDQUFDO0lBQ0osQ0FBQztJQUVPLFdBQVcsQ0FBQyxXQUFtQjtRQUNyQyxJQUFJLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQztRQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVPLFdBQVcsQ0FBQyxTQUFTO1FBQzNCLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsMEJBQTBCLENBQzdCLENBQUMsSUFBaUIsRUFBRSxFQUFFLENBQUMsSUFBSSxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUMvRSxHQUFHLEVBQUU7WUFDSCxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ25CLENBQUMsQ0FDRixDQUFDO1FBQ0YsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVPLDBCQUEwQixDQUNoQyxRQUF3QyxFQUN4QyxVQUFnRDtRQUVoRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEMsTUFBTSxJQUFJLEdBQXlCLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBeUIsQ0FBQztZQUMzRSxNQUFNLElBQUksR0FBZ0IsR0FBRyxDQUFDLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3pELElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUNsQixVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDbEI7U0FDRjtJQUNILENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxJQUFtQjtRQUM1QyxPQUFPLElBQUksQ0FBQyxRQUFRO1lBQ2xCLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzdFLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDWCxDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNsQixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzlCO0lBQ0gsQ0FBQztJQUVPLHdCQUF3QixDQUFDLEtBQUs7UUFDcEMsSUFBSSxJQUFJLENBQUMseUJBQXlCLElBQUksSUFBSSxDQUFDLHFCQUFxQixFQUFFO1lBQ2hFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNwQztJQUNILENBQUM7SUFFTywwQkFBMEIsQ0FBQyxLQUFLO1FBQ3RDLElBQUksSUFBSSxDQUFDLHlCQUF5QixJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUNoRSxJQUFJLENBQUMscUJBQXFCLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ2xGLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNwQztJQUNILENBQUM7OzJHQXhmVSxjQUFjOytGQUFkLGNBQWM7MkZBQWQsY0FBYztrQkFIMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsVUFBVTtpQkFDckI7d01BMkNLLFFBQVE7c0JBRFgsS0FBSztnQkEwQkYsY0FBYztzQkFEakIsS0FBSztnQkFTRixVQUFVO3NCQURiLEtBQUs7Z0JBV0YsY0FBYztzQkFEakIsS0FBSztnQkFZRixtQkFBbUI7c0JBRHRCLEtBQUs7Z0JBU0YscUJBQXFCO3NCQUR4QixLQUFLO2dCQVNGLG1CQUFtQjtzQkFEdEIsS0FBSztnQkFTRixjQUFjO3NCQURqQixLQUFLO2dCQVNGLHFCQUFxQjtzQkFEeEIsS0FBSztnQkFVRixnQkFBZ0I7c0JBRG5CLEtBQUs7Z0JBU0UseUJBQXlCO3NCQURoQyxLQUFLO2dCQU9FLDhCQUE4QjtzQkFEckMsS0FBSztnQkFTRSwyQkFBMkI7c0JBRGxDLEtBQUs7Z0JBT0Usa0NBQWtDO3NCQUR6QyxLQUFLO2dCQU9FLFdBQVc7c0JBRGxCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50RmFjdG9yeSxcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBEaXJlY3RpdmUsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgVmlld1JlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElJZGVudGlmaWVkLCBJUmVzdWx0TGlzdCwgUGFnaW5nIH0gZnJvbSAnQGM4eS9jbGllbnQnO1xuaW1wb3J0IHsgYXNzaWduLCBnZXQgfSBmcm9tICdsb2Rhc2gtZXMnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgaXNPYnNlcnZhYmxlLCBPYnNlcnZhYmxlLCBvZiwgcGlwZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFrZVVudGlsLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSZWFsdGltZVNlcnZpY2UgfSBmcm9tICcuLi9yZWFsdGltZS9yZWFsdGltZS5zZXJ2aWNlJztcbmltcG9ydCB7IExvYWRNb3JlQ29tcG9uZW50IH0gZnJvbSAnLi9sb2FkLW1vcmUuY29tcG9uZW50JztcbmltcG9ydCB7IExvYWRNb3JlTW9kZSB9IGZyb20gJy4vbG9hZC1tb3JlLm1vZGVsJztcbmltcG9ydCB7IEZvck9mUmVhbHRpbWVPcHRpb25zIH0gZnJvbSAnLi9mb3JPZi5tb2RlbCc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsZXJXcmFwcGVyQ29tcG9uZW50IH0gZnJvbSAnLi92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbGVyLXdyYXBwZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0byBpdGVyYXRlIG92ZXIgSVJlc3VsdExpc3Q8VD4gZGF0YSBmcm9tIEBjOHkvY2xpZW50LlxuICogRGVwZW5kaW5nIG9uIHRoZSBbYzh5Rm9yTG9hZE1vcmVdIGEgbG9hZCBtb3JlIGJ1dHRvbiBpczpcbiAqICAtIGF1dG86IFRyaWVzIHRvIGF1dG9tYXRpY2FsbHkgbG9hZCBtb3JlIGRhdGEgKGRlZmF1bHQgbWF4aW11bSAxMCBpdGVyYXRpb25zOyBjYW4gYmVcbiAqICAgICAgICAgIGNoYW5nZSB3aXRoIG1heEl0ZXJhdGlvbnMgc2V0dGluZ3MpLlxuICogIC0gc2hvdzogU2hvd3MgYSBsb2FkIG1vcmUgYnV0dG9uIGZvciB0aGUgdXNlciB0byBkZWNpZGVcbiAqICAtIG5vbmU6IERvZXNuJ3QgcGVyZm9ybSBhbnkgbG9hZCBtb3JlIGFjdGlvbi5cbiAqICAtIGhpZGRlbjogTG9hZHMgbW9yZSBkYXRhIGF1dG9tYXRpY2FsbHkgYnV0IHdpdGggbm8gdmlzaWJsZSBidXR0b24gZm9yIHRoZSB1c2VyLlxuICpcbiAqIEFkZGl0aW9uYWwsIGFueSByeGpzIG9wZXJhdG9yIHBpcGUgY2FuIGJlIGFwcGxpZWQgdG8gdGhlIFtjOHlGb3JQaXBlXSBpbnB1dCwgZS5nLiB0b1xuICogZmlsdGVyIHRoZSBkYXRhIGRpc3BsYXllZCBjdXJyZW50bHkgYXMgd2VsbCBhcyB0aGUgZGF0YSBsb2FkZWQgYnkgc3Vic2VxdWVudCByZXF1ZXN0cy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGRpdiAqYzh5Rm9yPVwibGV0IGRldmljZSBvZiBkZXZpY2VzOyBsb2FkTW9yZTogJ2F1dG8nOyBsZXQgaSA9IGluZGV4OyBwaXBlOiBmaWx0ZXJQaXBlO1wiPlxuICogIHt7IGkgKyAxIH19LiB7e2RldmljZS5uYW1lfX1cbiAqIDwvZGl2PlxuICogYGBgXG4gKiBUaGUgYWJvdmUgZXhhbXBsZSB3aWxsIGxpc3QgYWxsIGVudGl0aWVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gYGRldmljZXNgOlxuICogYGBgdHlwZXNjcmlwdFxuICogdGhpcy5kZXZpY2VzID0gdGhpcy5pbnZlbnRvcnlTZXJ2aWNlLmxpc3QoeyBwYWdlU2l6ZTogMTAsIGZyYWdtZW50VHlwZTogJ2M4eV9Jc0RldmljZScgfSlcbiAqIGBgYFxuICogSXQgd2lsbCBkaXNwbGF5IHRoZSBmaXJzdCAxMCBpdGVtcywgaWYgdGhlcmUgaXMgbW9yZSBzcGFjZSBsZWZ0IG9uIHRoZSBzY3JlZW4sIGFuZCB0aGVyZSBhcmUgbW9yZVxuICogdGhhbiAxMCBkZXZpY2VzLCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgbG9hZCB1cCB0byAxMCBwYWdlcyBtb3JlLiBJZiBpdCBzdGlsbCBjYW4ndCBmaXQgdGhlIHNjcmVlblxuICogaXQgd2lsbCBzdG9wIGFuZCBzd2l0Y2ggdG8gYHNob3dgIG1vZGUuXG4gKlxuICogQSBwaXBlIGNhbiBiZSBhcHBsaWVkIGUuZy4gZm9yIGZpbHRlcmluZyBvciBncm91cGluZy4gVGhpcyBwaXBlIGlzIGF0dGFjaGVkIHRvIGV2ZXJ5IGZvbGxvdyB1cFxuICogcmVxdWVzdCBkb25lIGJ5IHRoZSBsb2FkIG1vcmUgY29tcG9uZW50OlxuICogYGBgdHlwZXNjcmlwdFxuICogdGhpcy5maWx0ZXJQaXBlID0gcGlwZShcbiAqICAgIG1hcCgoZGF0YTogW10pID0+IHtcbiAqICAgICByZXR1cm4gZGF0YS5maWx0ZXIoXG4gKiAgICAgIChtbzogYW55KSA9PiBtby5uYW1lICYmIG1vLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbHVlLnRvTG93ZXJDYXNlKCkpID4gLTFcbiAqICAgICk7XG4gKiAgfSlcbiAqICk7XG4gKiBgYGBcbiAqIFRoZSBwaXBlIG11c3QgYmUgYW4gcnhqcyBwaXBlIGFuZCBjYW4gdGFrZSBhbnkgb3BlcmF0b3IuXG4gKlxuICogRXhhbXBsZSB3aXRoIHJlYWx0aW1lIHN1cHBvcnQgYW5kIGl0ZW1zIGNvdW50IG91dHB1dCAoZS5nLiBmb3IgaGFuZGxpbmcgZW1wdHkgc3RhdGUgYW5kIGhlYWRlcik6XG4gKlxuICogYGBgaHRtbFxuICogPGM4eS1saXN0LWdyb3VwPlxuICogICA8ZGl2IGNsYXNzPVwiYzh5LWVtcHR5LXN0YXRlXCIgKm5nSWY9XCJjb3VudCA9PT0gMFwiPlxuICogICAgICguLi4pXG4gKiAgIDwvZGl2PlxuICpcbiAqICAgPGRpdiBjbGFzcz1cInBhZ2Utc3RpY2t5LWhlYWRlciBoaWRkZW4teHMgYzh5LWxpc3RfX2l0ZW0gYzh5LWxpc3QtLXRpbWVsaW5lXCIgKm5nSWY9XCJjb3VudCA+IDBcIj5cbiAqICAgICAoLi4uKVxuICogICA8L2Rpdj5cbiAqXG4gKiAgIDxuZy10ZW1wbGF0ZVxuICogICAgIGM4eUZvclxuICogICAgIGxldC1vcGVyYXRpb25cbiAqICAgICBbYzh5Rm9yT2ZdPVwiaXRlbXMkXCJcbiAqICAgICBbYzh5Rm9yUGlwZV09XCJmaWx0ZXJQaXBlXCJcbiAqICAgICBbYzh5Rm9yUmVhbHRpbWVdPVwicmVhbHRpbWVcIlxuICogICAgIFtjOHlGb3JSZWFsdGltZU9wdGlvbnNdPVwicmVhbHRpbWVPcHRpb25zXCJcbiAqICAgICAoYzh5Rm9yQ291bnQpPVwiY291bnQgPSAkZXZlbnRcIlxuICogICA+XG4gKiAgICAgPGM4eS1saS10aW1lbGluZT5cbiAqICAgICAgICguLi4pXG4gKiAgICAgPC9jOHktbGktdGltZWxpbmU+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2M4eS1saXN0LWdyb3VwPlxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQENvbXBvbmVudCh7XG4gKiAgICguLi4pXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEV4YW1wbGVDb21wb25lbnQge1xuICogICBASW5wdXQoKSBkZXZpY2VJZDogSUlkZW50aWZpZWQ7XG4gKiAgIGl0ZW1zJCA9IHRoaXMub3BlcmF0aW9uU2VydmljZS5saXN0KHtcbiAqICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcbiAqICAgICBmcmFnbWVudFR5cGU6ICdjOHlfTXlPcGVyYXRpb24nLFxuICogICAgIGRhdGVGcm9tOiBuZXcgRGF0ZSgwKS50b0lTT1N0cmluZygpLFxuICogICAgIGRhdGVUbzogbmV3IERhdGUoRGF0ZS5ub3coKSkudG9JU09TdHJpbmcoKSxcbiAqICAgICByZXZlcnQ6IHRydWUsXG4gKiAgICAgd2l0aFRvdGFsUGFnZXM6IHRydWVcbiAqICAgfSk7XG4gKiAgIGZpbHRlclBpcGUgPSBwaXBlKG1hcCgob3BzOiBJT3BlcmF0aW9uW10pID0+IG9wcy5maWx0ZXIob3AgPT4gb3AuYzh5X015T3BlcmF0aW9uKSkpO1xuICogICByZWFsdGltZU9wdGlvbnM6IEZvck9mUmVhbHRpbWVPcHRpb25zID0ge1xuICogICAgIGVudGl0eU9ySWQ6IHRoaXMuZGV2aWNlSWQsXG4gKiAgICAgcmVtb3ZlT25VcGRhdGU6IHRydWUsXG4gKiAgICAgaW5zZXJ0T25VcGRhdGU6IHRydWVcbiAqICAgfSBhcyBGb3JPZlJlYWx0aW1lT3B0aW9ucztcbiAqICAgY291bnQ6IG51bWJlcjtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKFxuICogICAgIHByaXZhdGUgb3BlcmF0aW9uU2VydmljZTogT3BlcmF0aW9uU2VydmljZSxcbiAqICAgICBwdWJsaWMgcmVhbHRpbWU6IE9wZXJhdGlvblJlYWx0aW1lU2VydmljZVxuICogICApIHt9XG4gKiB9XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2M4eUZvcl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvck9mRGlyZWN0aXZlIHtcbiAgcHJpdmF0ZSBjYWNoZWREYXRhOiBJSWRlbnRpZmllZFtdID0gW107XG4gIHByaXZhdGUgcGFnaW5nOiBQYWdpbmc8SUlkZW50aWZpZWQ+O1xuICBwcml2YXRlIGxvYWRNb3JlTW9kZTogTG9hZE1vcmVNb2RlID0gJ2F1dG8nO1xuICBwcml2YXRlIGRhdGFQaXBlID0gcGlwZSh0YXAoKSk7XG4gIHByaXZhdGUgaXRlbURhdGFQaXBlID0gcGlwZShcbiAgICBtYXAoaXRlbSA9PiBbaXRlbV0pLFxuICAgIHNyYyA9PiB0aGlzLmRhdGFQaXBlKHNyYyksXG4gICAgbWFwKChbaXRlbV0pID0+IGl0ZW0pXG4gICk7XG4gIHByaXZhdGUgcGFnaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgb2JzJDogT2JzZXJ2YWJsZTxJSWRlbnRpZmllZFtdPjtcbiAgcHJpdmF0ZSBsb2FkTW9yZTogTG9hZE1vcmVDb21wb25lbnQ7XG4gIHByaXZhdGUgbG9hZGluZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBwcml2YXRlIG1heEl0ZXJhdGlvbnMgPSAxMDtcbiAgcHJpdmF0ZSBub3RGb3VuZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICBwcml2YXRlIGxvYWROZXh0TGFiZWw6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFsdGltZTogUmVhbHRpbWVTZXJ2aWNlPGFueT47XG4gIHByaXZhdGUgcmVhbHRpbWVPcHRpb25zOiBGb3JPZlJlYWx0aW1lT3B0aW9ucyA9IHt9IGFzIEZvck9mUmVhbHRpbWVPcHRpb25zO1xuICBwcml2YXRlIGNvbXBhcmF0b3I6IChpdGVtQTogb2JqZWN0LCBpdGVtQjogb2JqZWN0KSA9PiBudW1iZXI7XG4gIHByaXZhdGUgdW5zdWJzY3JpYmUkOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSB2aXJ0dWFsU2Nyb2xsSW5zdGFuY2U6IFZpcnR1YWxTY3JvbGxlcldyYXBwZXJDb21wb25lbnQ7XG5cbiAgcHJpdmF0ZSBnZXQgc2hvdWxkVXNlTG9hZE1vcmVCdXR0b24oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9hZE1vcmVNb2RlID09PSAnYXV0bycgfHwgdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdzaG93JyB8fCB0aGlzLmxvYWRNb3JlTW9kZSA9PT0gJ2hpZGRlbidcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaGFzTW9yZURhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZE1vcmUgJiYgdGhpcy5sb2FkTW9yZS5oYXNNb3JlO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlZERhdGEubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhIHNldHRlci4gTXVzdCBiZSBhIHJlc3BvbnNlIGZyb20gQGM4eS9kYXRhIG9yIGFuIG9ic2VydmFibGUuXG4gICAqIFlvdSBjYW4gcGFzcyBhbiBvYnNlcnZhYmxlIHdpdGggbnVsbCB0byBleHBsaWNpdGx5IGNsZWFyIHRoZSBsaXN0LlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvck9mKGZldGNoRGF0YTogSVJlc3VsdExpc3Q8SUlkZW50aWZpZWQ+IHwgT2JzZXJ2YWJsZTxJUmVzdWx0TGlzdDxJSWRlbnRpZmllZD4+KSB7XG4gICAgaWYgKGZldGNoRGF0YSkge1xuICAgICAgdGhpcy5vYnMkID0gKGlzT2JzZXJ2YWJsZShmZXRjaERhdGEpID8gZmV0Y2hEYXRhIDogb2YoZmV0Y2hEYXRhKSkucGlwZShcbiAgICAgICAgbWFwKHJlc3VsdCA9PiB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYWdpbmcgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IHBhZ2luZywgZGF0YSB9ID0gcmVzdWx0O1xuICAgICAgICAgIHRoaXMucGFnaW5nID0gcGFnaW5nO1xuICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1vZGUgc2V0dGVyOlxuICAgKiAgLSBhdXRvOiBUcmllcyB0byBhdXRvbWF0aWNhbGx5IGxvYWQgbW9yZSBkYXRhIChkZWZhdWx0IG1heGltdW0gMTAgaXRlcmF0aW9uczsgY2FuIGJlXG4gICAqICAgICAgICAgIGNoYW5nZSB3aXRoIG1heEl0ZXJhdGlvbnMgc2V0dGluZ3MpLlxuICAgKiAgLSBzaG93OiBTaG93cyBhIGxvYWQgbW9yZSBidXR0b24gZm9yIHRoZSB1c2VyIHRvIGRlY2lkZVxuICAgKiAgLSBub25lOiBEb2Vzbid0IHBlcmZvcm0gYW55IGxvYWQgbW9yZSBhY3Rpb24uXG4gICAqICAtIGhpZGRlbjogTG9hZHMgbW9yZSBkYXRhIGF1dG9tYXRpY2FsbHkgYnV0IHdpdGggbm8gdmlzaWJsZSBidXR0b24gZm9yIHRoZSB1c2VyLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvckxvYWRNb3JlKHR5cGU6IExvYWRNb3JlTW9kZSkge1xuICAgIHRoaXMubG9hZE1vcmVNb2RlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGlwZSBzZXR0ZXIgdG8gYXR0YWNoIGFueSByeGpzIHBpcGUgdG8gdGhlIGN1cnJlbnQgYW5kIG1vcmUgbG9hZGVkIGRhdGEuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yUGlwZShkYXRhUGlwZSkge1xuICAgIGlmIChkYXRhUGlwZSkge1xuICAgICAgdGhpcy5kYXRhUGlwZSA9IGRhdGFQaXBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHRlbXBsYXRlIHRvIHVzZSBpZiBubyBkYXRhIGlzIGZvdW5kIGF0IGFsbCAoZS5nLiBpZiB5b3UgYXBwbHkgYSBmaWx0ZXIgcGlwZSkuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yTm90Rm91bmQobm90Rm91bmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgIHRoaXMubm90Rm91bmRUZW1wbGF0ZSA9IG5vdEZvdW5kVGVtcGxhdGU7XG4gICAgaWYgKHRoaXMubG9hZE1vcmUpIHtcbiAgICAgIHRoaXMubG9hZE1vcmUubm9Nb3JlRGF0YUhpbnQgPSBub3RGb3VuZFRlbXBsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXJzIG9mIGl0ZXJhdGlvbnMgdG8gY2FsbCBkYXRhIGZyb20gdGhlIGFwaS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JNYXhJdGVyYXRpb25zKG1heEl0ZXJhdGlvbnM6IG51bWJlcikge1xuICAgIHRoaXMubWF4SXRlcmF0aW9ucyA9IG1heEl0ZXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQSBjdXN0b20gbG9hZGluZyBjb21wb25lbnQuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgYzh5Rm9yTG9hZGluZ1RlbXBsYXRlKGxvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgIHRoaXMubG9hZGluZ1RlbXBsYXRlID0gbG9hZGluZ1RlbXBsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgbmV4dCB0ZXh0IGxhYmVsLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvckxvYWROZXh0TGFiZWwobG9hZE5leHRMYWJlbDogc3RyaW5nKSB7XG4gICAgdGhpcy5sb2FkTmV4dExhYmVsID0gbG9hZE5leHRMYWJlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIFJlYWx0aW1lU2VydmljZSBpbnN0YW5jZS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjOHlGb3JSZWFsdGltZShzb3VyY2U6IFJlYWx0aW1lU2VydmljZTxhbnk+KSB7XG4gICAgdGhpcy5yZWFsdGltZSA9IHNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFsdGltZSBvcHRpb25zLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvclJlYWx0aW1lT3B0aW9ucyhyZWFsdGltZU9wdGlvbnM6IEZvck9mUmVhbHRpbWVPcHRpb25zKSB7XG4gICAgdGhpcy5yZWFsdGltZU9wdGlvbnMgPSByZWFsdGltZU9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogQSBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBjb21wYXJpbmcgbGlzdCBpdGVtcy4gVXNlZCB0byBkZXRlcm1pbmVcbiAgICogdGhlIHBvc2l0aW9uIGF0IHdoaWNoIGEgbmV3IGVsZW1lbnQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGM4eUZvckNvbXBhcmF0b3IoY29tcGFyYXRvcjogKGl0ZW1BOiBvYmplY3QsIGl0ZW1COiBvYmplY3QpID0+IG51bWJlcikge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlIHZpcnR1YWwgc2Nyb2xsIHJlbmRlcmluZyBtZXRob2QuXG4gICAqL1xuICBASW5wdXQoKVxuICBwcml2YXRlIGM4eUZvckVuYWJsZVZpcnR1YWxTY3JvbGwgPSBmYWxzZTtcblxuICAvKipcbiAgICogUHJvdmlkZXMgZml4ZWQgaXRlbSBzaXplIGZvciB2aXJ0dWFsIHNjcm9sbCB3aW5kb3cgc3RyYXRlZ3kuXG4gICAqL1xuICBASW5wdXQoKVxuICBwcml2YXRlIGM4eUZvclZpcnR1YWxTY3JvbGxFbGVtZW50U2l6ZTtcblxuICAvKipcbiAgICogU2V0cyBtb2RlIG9mIHZpcnR1YWwgc2Nyb2xsZXIgaW5zdGFuY2UuXG4gICAqIHdpbmRvdyBpcyB1c2VkIGZvciBjYXNlIHdoZW4gd2hvbGUgdmlld3BvcnQgaXMgc2Nyb2xsZWQuXG4gICAqIGZpeGVkIGNhbiBiZSB1c2VkIG9uIGlubmVyLXNjcm9sbCBjb250YWluZXJzLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHJpdmF0ZSBjOHlGb3JWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3k6ICdmaXhlZCcgfCAnd2luZG93JyA9ICd3aW5kb3cnO1xuXG4gIC8qKlxuICAgKiBXaGVuIHVzZWQgZml4ZWQgc3RyYXRlZ3ksIHRoZXJlIG5lZWRzIHRvIGJlIGZpeGVkIGhlaWdodCBzZXQgb24gc2Nyb2xsaW5nIGNvbnRhaW5lci5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHByaXZhdGUgYzh5Rm9yVmlydHVhbFNjcm9sbENvbnRhaW5lckhlaWdodDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGN1cnJlbnRseSBsb2FkZWQgaW4gdGhlIGxpc3QuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHJpdmF0ZSBjOHlGb3JDb3VudCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICBwcml2YXRlIGNvdW50ID0gMDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRwbDogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmXG4gICkge31cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVJlYWx0aW1lKCk7XG4gIH1cblxuICBwcml2YXRlIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vYnMkICYmIChjaGFuZ2VzLmM4eUZvclBpcGUgfHwgY2hhbmdlcy5jOHlGb3JPZikpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmVQYWdpbmcoKTtcblxuICAgICAgaWYgKHRoaXMudmlydHVhbFNjcm9sbEluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMudmlydHVhbFNjcm9sbEluc3RhbmNlLmZpbHRlclBpcGUgPSB0aGlzLmRhdGFQaXBlO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oeyB0b3A6IDAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgcmUtcmVuZGVyaW5nICBvbiBmaWx0ZXJpbmcgaWYgYWxsIGRhdGEgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgIC8vIGZyb20gdGhlIGJhY2tlbmRcbiAgICAgIGNvbnN0IHJlUmVuZGVyID0gIXRoaXMuaGFzTW9yZURhdGEgJiYgISFjaGFuZ2VzLmM4eUZvclBpcGUgJiYgIWNoYW5nZXMuYzh5Rm9yT2Y7XG5cbiAgICAgIGlmIChyZVJlbmRlcikge1xuICAgICAgICB0aGlzLm9icyQgPSBvZih0aGlzLmNhY2hlZERhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWdpbmdTdWIgPSB0aGlzLm9icyRcbiAgICAgICAgLnBpcGUoXG4gICAgICAgICAgdGFwKGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZVJlbmRlcikge1xuICAgICAgICAgICAgICB0aGlzLmNhY2hlZERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgLnBpcGUoc3JjID0+IHRoaXMuZGF0YVBpcGUoc3JjKSlcbiAgICAgICAgLnN1YnNjcmliZSgoZGF0YTogW10pID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNvdW50KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihkYXRhLCByZVJlbmRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy51bnN1YnNjcmliZVBhZ2luZygpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUkLm5leHQoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZWFsdGltZSgpIHtcbiAgICBpZiAodGhpcy5yZWFsdGltZSkge1xuICAgICAgdGhpcy5oYW5kbGVSZWFsdGltZUNyZWF0ZSgpO1xuICAgICAgdGhpcy5oYW5kbGVSZWFsdGltZVVwZGF0ZSgpO1xuICAgICAgdGhpcy5oYW5kbGVSZWFsdGltZURlbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbiBjcmVhdGUgbm90aWZpY2F0aW9uOlxuICAgKiAtIGlmIGl0ZW0gcGFzc2VzIGRhdGEgcGlwZSwgdGhlbiBpbnNlcnQgaXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVJlYWx0aW1lQ3JlYXRlKCkge1xuICAgIGNvbnN0IHsgZW50aXR5T3JJZCB9ID0gdGhpcy5yZWFsdGltZU9wdGlvbnM7XG4gICAgdGhpcy5yZWFsdGltZVxuICAgICAgLm9uQ3JlYXRlJChlbnRpdHlPcklkKVxuICAgICAgLnBpcGUoXG4gICAgICAgIGl0ZW0kID0+IHRoaXMuaXRlbURhdGFQaXBlKGl0ZW0kKSxcbiAgICAgICAgZmlsdGVyKGl0ZW0gPT4gaXRlbSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLnVuc3Vic2NyaWJlJClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoaXRlbSA9PiB0aGlzLmluc2VydChpdGVtKSk7XG4gIH1cblxuICAvKipcbiAgICogT24gdXBkYXRlIG5vdGlmaWNhdGlvbjpcbiAgICogLSBpZiBpdGVtIGlzIGRpc3BsYXllZCBhbmQgcGFzc2VzIGRhdGEgcGlwZSwgdGhlbiB1cGRhdGUgaXQsXG4gICAqIC0gaWYgaXRlbSBpcyBkaXNwbGF5ZWQgYW5kIGRvZXNuJ3QgcGFzcyBkYXRhIHBpcGUsIHRoZW4gcmVtb3ZlIGl0IChpZiBgcmVtb3ZlT25VcGRhdGVgIGlzIHRydWUpLFxuICAgKiAtIGlmIGl0ZW0gaXMgbm90IGRpc3BsYXllZCBhbmQgcGFzc2VzIGRhdGEgcGlwZSwgdGhlbiBpbnNlcnQgaXQgKGlmIGBpbnNlcnRPblVwZGF0ZWAgaXMgdHJ1ZSksXG4gICAqIC0gaWYgaXRlbSBpcyBub3QgZGlzcGxheWVkIGFuZCBkb2Vzbid0IHBhc3MgZGF0YSBwaXBlLCB0aGVuIGlnbm9yZSBpdC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlUmVhbHRpbWVVcGRhdGUoKSB7XG4gICAgY29uc3QgeyBlbnRpdHlPcklkIH0gPSB0aGlzLnJlYWx0aW1lT3B0aW9ucztcbiAgICB0aGlzLnJlYWx0aW1lXG4gICAgICAub25VcGRhdGUkKGVudGl0eU9ySWQpXG4gICAgICAucGlwZShcbiAgICAgICAgaXRlbSQgPT5cbiAgICAgICAgICBjb21iaW5lTGF0ZXN0KFtcbiAgICAgICAgICAgIGl0ZW0kLFxuICAgICAgICAgICAgaXRlbSQucGlwZShcbiAgICAgICAgICAgICAgc3JjID0+IHRoaXMuaXRlbURhdGFQaXBlKHNyYyksXG4gICAgICAgICAgICAgIG1hcChpdGVtID0+IGl0ZW0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUkKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgoW2l0ZW0sIHBhc3Nlc0RhdGFQaXBlXSkgPT4ge1xuICAgICAgICBjb25zdCB7IGluc2VydE9uVXBkYXRlLCByZW1vdmVPblVwZGF0ZSB9ID0gdGhpcy5yZWFsdGltZU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRpc3BsYXllZCA9IHRoaXMuaXNEaXNwbGF5ZWQoY29lcmNlTnVtYmVyUHJvcGVydHkoaXRlbS5pZCkpO1xuICAgICAgICBpZiAoZGlzcGxheWVkKSB7XG4gICAgICAgICAgaWYgKHBhc3Nlc0RhdGFQaXBlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZShpdGVtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlbW92ZU9uVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShjb2VyY2VOdW1iZXJQcm9wZXJ0eShpdGVtLmlkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhc3Nlc0RhdGFQaXBlICYmIGluc2VydE9uVXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5pbnNlcnQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGRlbGV0ZSBub3RpZmljYXRpb246XG4gICAqIC0gcmVtb3ZlIGl0ZW0gZnJvbSB0aGUgbGlzdCAoaWYgbm90IHRoZXJlLCBpdCB3aWxsIGJlIGp1c3QgaWdub3JlZCkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVJlYWx0aW1lRGVsZXRlKCkge1xuICAgIGNvbnN0IHsgZW50aXR5T3JJZCB9ID0gdGhpcy5yZWFsdGltZU9wdGlvbnM7XG4gICAgdGhpcy5yZWFsdGltZVxuICAgICAgLm9uRGVsZXRlJChlbnRpdHlPcklkKVxuICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmUkKSlcbiAgICAgIC5zdWJzY3JpYmUoaWQgPT4gdGhpcy5yZW1vdmUoY29lcmNlTnVtYmVyUHJvcGVydHkoaWQpKSk7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlcihkYXRhLCByZVJlbmRlciA9IGZhbHNlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYzh5Rm9yRW5hYmxlVmlydHVhbFNjcm9sbCkge1xuICAgICAgaWYgKCF0aGlzLnZpcnR1YWxTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnZpcnR1YWxTY3JvbGxJbnN0YW5jZSA9IHRoaXMuY3JlYXRlVmlydHVhbFNjcm9sbFdyYXBwZXJDb21wb25lbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlTG9hZE1vcmVCdXR0b24pIHtcbiAgICAgICAgICB0aGlzLmxvYWRNb3JlID0gdGhpcy5jcmVhdGVMb2FkTW9yZUJ1dHRvbkNvbXBvbmVudChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRWaXJ0dWFsU2Nyb2xsQ29udGVudHMoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy52Y3IuY2xlYXIoKTtcblxuICAgIGRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICRpbXBsaWNpdDogaXRlbSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmU6IHRoaXMuaGFzTW9yZURhdGEsXG4gICAgICAgIGxvYWRNb3JlQ29tcG9uZW50OiB0aGlzLmxvYWRNb3JlXG4gICAgICB9O1xuICAgICAgdGhpcy52Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudHBsLCBjb250ZXh0KTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnNob3VsZFVzZUxvYWRNb3JlQnV0dG9uKSB7XG4gICAgICB0aGlzLmxvYWRNb3JlID0gdGhpcy5jcmVhdGVMb2FkTW9yZUJ1dHRvbkNvbXBvbmVudChyZVJlbmRlcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBlbmQoZGF0YSkge1xuICAgIGlmICh0aGlzLmM4eUZvckVuYWJsZVZpcnR1YWxTY3JvbGwpIHtcbiAgICAgIHRoaXMuYXBwZW5kVmlydHVhbFNjcm9sbENvbnRlbnQoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGF0YS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNob3VsZFVzZUxvYWRNb3JlQnV0dG9uID8gdGhpcy52Y3IubGVuZ3RoIC0gMSA6IHRoaXMudmNyLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICRpbXBsaWNpdDogaXRlbSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGgsXG4gICAgICAgIGhhc01vcmU6IHRoaXMuaGFzTW9yZURhdGEsXG4gICAgICAgIGxvYWRNb3JlQ29tcG9uZW50OiB0aGlzLmxvYWRNb3JlXG4gICAgICB9O1xuICAgICAgdGhpcy52Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudHBsLCBjb250ZXh0LCBpbmRleCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRNb3JlRGF0YShkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy51cGRhdGVDb3VudChkYXRhLmxlbmd0aCk7XG4gICAgICB0aGlzLmFwcGVuZChkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUxvYWRNb3JlQnV0dG9uQ29tcG9uZW50KHJlUmVuZGVyKSB7XG4gICAgY29uc3QgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+ID1cbiAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KExvYWRNb3JlQ29tcG9uZW50KTtcbiAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLnZjci5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnRSZWYuaW5zdGFuY2UgYXMgTG9hZE1vcmVDb21wb25lbnQ7XG4gICAgaW5zdGFuY2UucGFnaW5nID0gdGhpcy5wYWdpbmc7XG4gICAgaW5zdGFuY2UudXNlSW50ZXJzZWN0aW9uID0gdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdhdXRvJyB8fCB0aGlzLmxvYWRNb3JlTW9kZSA9PT0gJ2hpZGRlbic7XG4gICAgaW5zdGFuY2UuaGlkZGVuID0gdGhpcy5sb2FkTW9yZU1vZGUgPT09ICdoaWRkZW4nO1xuICAgIGluc3RhbmNlLm1heEl0ZXJhdGlvbnMgPSB0aGlzLm1heEl0ZXJhdGlvbnM7XG4gICAgaW5zdGFuY2Uubm9Nb3JlRGF0YUhpbnQgPSB0aGlzLm5vdEZvdW5kVGVtcGxhdGU7XG4gICAgaW5zdGFuY2UubG9hZGluZ1RlbXBsYXRlID0gdGhpcy5sb2FkaW5nVGVtcGxhdGU7XG4gICAgaW5zdGFuY2UubG9hZE5leHRMYWJlbCA9IHRoaXMubG9hZE5leHRMYWJlbDtcbiAgICB0aGlzLnBhZ2luZ1N1YiA9IGluc3RhbmNlLm9uTG9hZFxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcCgoZGF0YTogW10pID0+IHRoaXMuY2hlY2tGb3JEdXBsaWNhdGVzKGRhdGEpKSxcbiAgICAgICAgdGFwKChkYXRhOiBbXSkgPT4ge1xuICAgICAgICAgIHRoaXMuY2FjaGVkRGF0YSA9IHRoaXMuY2FjaGVkRGF0YS5jb25jYXQoZGF0YSk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICAucGlwZShzcmMgPT4gdGhpcy5kYXRhUGlwZShzcmMpKVxuICAgICAgLnN1YnNjcmliZShkYXRhID0+IHRoaXMubG9hZE1vcmVEYXRhKGRhdGEpKTtcbiAgICBpZiAocmVSZW5kZXIpIHtcbiAgICAgIGFzc2lnbihpbnN0YW5jZSwgdGhpcy5sb2FkTW9yZSk7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlVmlydHVhbFNjcm9sbFdyYXBwZXJDb21wb25lbnQoKSB7XG4gICAgY29uc3QgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+ID1cbiAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFZpcnR1YWxTY3JvbGxlcldyYXBwZXJDb21wb25lbnQpO1xuICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IHRoaXMudmNyLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5KTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IGNvbXBvbmVudFJlZi5pbnN0YW5jZSBhcyBWaXJ0dWFsU2Nyb2xsZXJXcmFwcGVyQ29tcG9uZW50O1xuICAgIGluc3RhbmNlLml0ZW1zID0gdGhpcy5jYWNoZWREYXRhO1xuICAgIGluc3RhbmNlLml0ZW1IZWlnaHQgPSB0aGlzLmM4eUZvclZpcnR1YWxTY3JvbGxFbGVtZW50U2l6ZTtcbiAgICBpbnN0YW5jZS50ZW1wbGF0ZSA9IHRoaXMudHBsO1xuICAgIGluc3RhbmNlLnN0cmF0ZWd5ID0gdGhpcy5jOHlGb3JWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3k7XG4gICAgaW5zdGFuY2UuY29udGFpbmVySGVpZ2h0ID0gdGhpcy5jOHlGb3JWaXJ0dWFsU2Nyb2xsQ29udGFpbmVySGVpZ2h0O1xuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnNlcnQoaXRlbSkge1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBpZiAodGhpcy5jb21wYXJhdG9yICYmIHRoaXMuY2FjaGVkRGF0YS5sZW5ndGgpIHtcbiAgICAgIGxldCBjb21wYXJpc2lvblJlc3VsdDogbnVtYmVyO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8YW55PiA9IHRoaXMudmNyLmdldChpbmRleCkgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT47XG4gICAgICAgIGNvbnN0IGl0ZW1CID0gZ2V0KHZpZXcsICdjb250ZXh0LiRpbXBsaWNpdCcpO1xuICAgICAgICBjb21wYXJpc2lvblJlc3VsdCA9IGl0ZW0gJiYgaXRlbUIgPyB0aGlzLmNvbXBhcmF0b3IoaXRlbSwgaXRlbUIpIDogMDtcbiAgICAgICAgaWYgKGNvbXBhcmlzaW9uUmVzdWx0IDw9IDApIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChjb21wYXJpc2lvblJlc3VsdCA8PSAwICYmIGluZGV4IDwgdGhpcy5jYWNoZWREYXRhLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGFwcGVuZCBlbGVtZW50cyBhZnRlciB0aGUgbGFzdCBvbmUgY3VycmVudGx5IGxvYWRlZCxcbiAgICAvLyBhcyBpdCBtYXkgYmVsb25nIGZ1cnRoZXIgZG93biB0aGVyZSBvbiB0aGUgbGlzdCBhbmQgd2lsbFxuICAgIC8vIGJlIGV2ZW50dWFsbHkgbG9hZGVkIHdpdGggb25lIG9mIHRoZSBuZXh0IHBhZ2VzLlxuICAgIGlmIChpbmRleCA8IHRoaXMuY2FjaGVkRGF0YS5sZW5ndGggfHwgdGhpcy5jYWNoZWREYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgJGltcGxpY2l0OiBpdGVtLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcbiAgICAgICAgaGFzTW9yZTogdGhpcy5oYXNNb3JlRGF0YVxuICAgICAgfTtcblxuICAgICAgdGhpcy5jYWNoZWREYXRhLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgICBjb25zdCB2aWV3UmVmOiBWaWV3UmVmID0gdGhpcy50cGwuY3JlYXRlRW1iZWRkZWRWaWV3KGNvbnRleHQpO1xuICAgICAgdGhpcy52Y3IuaW5zZXJ0KHZpZXdSZWYsIGluZGV4KTtcbiAgICAgIHRoaXMudXBkYXRlQ291bnQoMSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGUodXBkYXRlZEl0ZW0pIHtcbiAgICB0aGlzLmZvck1hdGNoaW5nRW1iZWRkZWRWaWV3UmVmKFxuICAgICAgKGl0ZW06IElJZGVudGlmaWVkKSA9PiBpdGVtICYmIHVwZGF0ZWRJdGVtICYmIGl0ZW0uaWQgPT09IHVwZGF0ZWRJdGVtLmlkLFxuICAgICAgKHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+KSA9PiB7XG4gICAgICAgIHZpZXcuY29udGV4dC4kaW1wbGljaXQgPSB1cGRhdGVkSXRlbTtcbiAgICAgICAgdmlldy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmUoaWRUb1JlbW92ZSkge1xuICAgIGlmICh0aGlzLmlzRGlzcGxheWVkKGlkVG9SZW1vdmUpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvdW50KC0xKTtcbiAgICB9XG4gICAgdGhpcy5mb3JNYXRjaGluZ0VtYmVkZGVkVmlld1JlZihcbiAgICAgIChpdGVtOiBJSWRlbnRpZmllZCkgPT4gaXRlbSAmJiBjb2VyY2VOdW1iZXJQcm9wZXJ0eShpdGVtLmlkLCBOYU4pID09PSBpZFRvUmVtb3ZlLFxuICAgICAgKHZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+KSA9PiB2aWV3LmRlc3Ryb3koKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUNvdW50KGNvdW50Q2hhbmdlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNvdW50ICs9IGNvdW50Q2hhbmdlO1xuICAgIHRoaXMuYzh5Rm9yQ291bnQuZW1pdCh0aGlzLmNvdW50KTtcbiAgfVxuXG4gIHByaXZhdGUgaXNEaXNwbGF5ZWQoaWRUb0NoZWNrKSB7XG4gICAgbGV0IGRpc3BsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMuZm9yTWF0Y2hpbmdFbWJlZGRlZFZpZXdSZWYoXG4gICAgICAoaXRlbTogSUlkZW50aWZpZWQpID0+IGl0ZW0gJiYgY29lcmNlTnVtYmVyUHJvcGVydHkoaXRlbS5pZCwgTmFOKSA9PT0gaWRUb0NoZWNrLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkaXNwbGF5ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGRpc3BsYXllZDtcbiAgfVxuXG4gIHByaXZhdGUgZm9yTWF0Y2hpbmdFbWJlZGRlZFZpZXdSZWYoXG4gICAgZmlsdGVyRm46IChpdGVtOiBJSWRlbnRpZmllZCkgPT4gYm9vbGVhbixcbiAgICBjYWxsYmFja0ZuOiAodmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT4pID0+IHZvaWRcbiAgKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZjci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT4gPSB0aGlzLnZjci5nZXQoaSkgYXMgRW1iZWRkZWRWaWV3UmVmPGFueT47XG4gICAgICBjb25zdCBpdGVtOiBJSWRlbnRpZmllZCA9IGdldCh2aWV3LCAnY29udGV4dC4kaW1wbGljaXQnKTtcbiAgICAgIGlmIChmaWx0ZXJGbihpdGVtKSkge1xuICAgICAgICBjYWxsYmFja0ZuKHZpZXcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JEdXBsaWNhdGVzKGRhdGE6IElJZGVudGlmaWVkW10pOiBJSWRlbnRpZmllZFtdIHtcbiAgICByZXR1cm4gdGhpcy5yZWFsdGltZVxuICAgICAgPyBkYXRhLmZpbHRlcihpdGVtID0+ICF0aGlzLmNhY2hlZERhdGEuc29tZShjYWNoZWQgPT4gY2FjaGVkLmlkID09PSBpdGVtLmlkKSlcbiAgICAgIDogZGF0YTtcbiAgfVxuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVQYWdpbmcoKSB7XG4gICAgaWYgKHRoaXMucGFnaW5nU3ViKSB7XG4gICAgICB0aGlzLnBhZ2luZ1N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0VmlydHVhbFNjcm9sbENvbnRlbnRzKGl0ZW1zKSB7XG4gICAgaWYgKHRoaXMuYzh5Rm9yRW5hYmxlVmlydHVhbFNjcm9sbCAmJiB0aGlzLnZpcnR1YWxTY3JvbGxJbnN0YW5jZSkge1xuICAgICAgdGhpcy52aXJ0dWFsU2Nyb2xsSW5zdGFuY2UuaXRlbXMgPSBpdGVtcztcbiAgICAgIHRoaXMudmlydHVhbFNjcm9sbEluc3RhbmNlLmFwcGx5KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhcHBlbmRWaXJ0dWFsU2Nyb2xsQ29udGVudChpdGVtcykge1xuICAgIGlmICh0aGlzLmM4eUZvckVuYWJsZVZpcnR1YWxTY3JvbGwgJiYgdGhpcy52aXJ0dWFsU2Nyb2xsSW5zdGFuY2UpIHtcbiAgICAgIHRoaXMudmlydHVhbFNjcm9sbEluc3RhbmNlLml0ZW1zID0gdGhpcy52aXJ0dWFsU2Nyb2xsSW5zdGFuY2UuaXRlbXMuY29uY2F0KGl0ZW1zKTtcbiAgICAgIHRoaXMudmlydHVhbFNjcm9sbEluc3RhbmNlLmFwcGx5KCk7XG4gICAgfVxuICB9XG59XG4iXX0=