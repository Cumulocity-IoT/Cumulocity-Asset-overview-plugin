import { InjectionToken, Optional, Inject, Injectable } from '@angular/core';
import { camelCase, isUndefined } from 'lodash-es';
import { ApplicationOptions } from './ApplicationOptions';
import { hookGeneric } from './extension-hooks';
import { SystemOptionsService, TenantOptionsService } from '@c8y/ngx-components/api';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/ngx-components/api";
/**
 * @deprecated Consider using the `hookOptions` function instead.
 */
export const HOOK_OPTIONS = new InjectionToken('HOOK_OPTIONS');
/**
 * You can either provide a single `ApplicationOptions` as parameter:
 * ```typescript
 *  hookOptions(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookOptions([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<ApplicationOptions>`
 * ```typescript
 *  export class MyApplicationOptionsFactory implements ExtensionFactory<ApplicationOptions> {...}
 *  ...
 *  hookOptions(MyApplicationOptionsFactory)
 * ```
 * A typed alternative to `HOOK_OPTIONS`.
 * @param options The `ApplicationOptions`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookOptions(options, hookOptions) {
    return hookGeneric(options, HOOK_OPTIONS, hookOptions);
}
/**
 * A service that allows to set or get application options
 * which configure the default behavior of the UI.
 */
export class OptionsService extends ApplicationOptions {
    constructor(options, systemOptionsService, tenantOptionService) {
        super();
        this.systemOptionsService = systemOptionsService;
        this.tenantOptionService = tenantOptionService;
        this.setupOptions(options);
    }
    /**
     * Returns an application option used to configure the UI.
     * @param optionKey The application options key.
     * @param defaultValue A value to return if non is set.
     * @param attemptParse Indicates whether the value should be parsed with JSON.parse.
     */
    get(optionKey, defaultValue, attemptParse) {
        let value = this[optionKey];
        if (typeof value === 'undefined') {
            value = this[camelCase(optionKey)];
        }
        if (attemptParse) {
            return this.parseOptionRawValue(value, defaultValue);
        }
        return typeof value !== 'undefined' ? value : defaultValue;
    }
    /**
     * Sets an application option.
     * @param key The key to set.
     * @param value The value to set.
     */
    set(key, value) {
        this[camelCase(key)] = value;
    }
    /**
     * Gets support url from tenant options.
     * If response returns '404 not found' it gets the support url from application options.
     * If the support link within application options is not provided the UI will use the system options.
     * Is the support link explicitly set to false it will be hidden.
     *
     * @returns Returns support url or false.
     */
    async getSupportUrl() {
        let url = await this.getTenantOption('configuration', 'system.support.url');
        if (isUndefined(url)) {
            url = this.supportUrl;
        }
        this.supportUrl = isUndefined(url)
            ? (await this.getSystemOption('support', 'url')) || false
            : url;
        return this.supportUrl;
    }
    /**
     * Returns if the tenant allows to show the activate-support user menu entry.
     * Note: Only if system-level support-user/enabled is false we can activate it at tenant level.
     */
    async getActivateSupportUser() {
        const option = await this.getSystemOption('support-user', 'enabled', true);
        return !option;
    }
    /**
     * Gets a value from the system service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    async getSystemOption(category, key, defaultValue) {
        return this.getOptionFromService(category, key, this.systemOptionsService, defaultValue);
    }
    /**
     * Gets a value from the tenant service and parses it.
     *
     * @param category The category for this option.
     * @param key The key for that option.
     * @param defaultValue The default if the option was not found.
     */
    async getTenantOption(category, key, defaultValue) {
        return this.getOptionFromService(category, key, this.tenantOptionService, defaultValue);
    }
    setupOptions(options) {
        if (options) {
            if (!Array.isArray(options)) {
                options = [options];
            }
            options.forEach(optionMap => {
                if (optionMap) {
                    Object.keys(optionMap).forEach(key => {
                        this[camelCase(key)] = optionMap[key];
                    });
                }
            });
        }
    }
    async getOptionFromService(category, key, service, defaultValue) {
        try {
            const { data } = await service.detail({ category, key });
            return this.parseOptionRawValue(data.value, defaultValue);
        }
        catch (ex) {
            return defaultValue;
        }
    }
    parseOptionRawValue(rawValue, defaultValue) {
        let value;
        try {
            value = JSON.parse(rawValue);
        }
        catch (e) {
            value = isUndefined(rawValue) ? defaultValue : rawValue;
        }
        return value;
    }
}
OptionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: OptionsService, deps: [{ token: HOOK_OPTIONS, optional: true }, { token: i1.SystemOptionsService }, { token: i1.TenantOptionsService }], target: i0.ɵɵFactoryTarget.Injectable });
OptionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: OptionsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: OptionsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [HOOK_OPTIONS]
                }] }, { type: i1.SystemOptionsService }, { type: i1.TenantOptionsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vb3B0aW9ucy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDbkQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDMUQsT0FBTyxFQUFxQyxXQUFXLEVBQWUsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7O0FBRXJGOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sWUFBWSxHQUFHLElBQUksY0FBYyxDQUM1QyxjQUFjLENBQ2YsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3pCLE9BQTRDLEVBQzVDLFdBQWtDO0lBRWxDLE9BQU8sV0FBVyxDQUFxQixPQUFPLEVBQUUsWUFBWSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRDs7O0dBR0c7QUFFSCxNQUFNLE9BQU8sY0FBZSxTQUFRLGtCQUFrQjtJQUVwRCxZQUNvQyxPQUFPLEVBQ2pDLG9CQUEwQyxFQUMxQyxtQkFBeUM7UUFFakQsS0FBSyxFQUFFLENBQUM7UUFIQSx5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBc0I7UUFHakQsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxHQUFHLENBQUMsU0FBK0IsRUFBRSxZQUFrQixFQUFFLFlBQXNCO1FBQzdFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM1QixJQUFJLE9BQU8sS0FBSyxLQUFLLFdBQVcsRUFBRTtZQUNoQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxZQUFZLEVBQUU7WUFDaEIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO1NBQ3REO1FBQ0QsT0FBTyxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0lBQzdELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUFVO1FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsYUFBYTtRQUNqQixJQUFJLEdBQUcsR0FBcUIsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBQzlGLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BCLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO1NBQ3ZCO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsR0FBRyxDQUFDO1lBQ2hDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLO1lBQ3pELENBQUMsQ0FBQyxHQUFHLENBQUM7UUFDUixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxzQkFBc0I7UUFDMUIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDM0UsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNqQixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsS0FBSyxDQUFDLGVBQWUsQ0FDbkIsUUFBZ0IsRUFDaEIsR0FBVyxFQUNYLFlBQWdCO1FBRWhCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFJLFFBQVEsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQzlGLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUNuQixRQUFnQixFQUNoQixHQUFXLEVBQ1gsWUFBZ0I7UUFFaEIsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUksUUFBUSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVPLFlBQVksQ0FBQyxPQUFxQjtRQUN4QyxJQUFJLE9BQU8sRUFBRTtZQUNYLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUMzQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUNyQjtZQUNELE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQzFCLElBQUksU0FBUyxFQUFFO29CQUNiLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFO3dCQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN4QyxDQUFDLENBQUMsQ0FBQztpQkFDSjtZQUNILENBQUMsQ0FBQyxDQUFDO1NBQ0o7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLG9CQUFvQixDQUNoQyxRQUFnQixFQUNoQixHQUFXLEVBQ1gsT0FBb0QsRUFDcEQsWUFBZTtRQUVmLElBQUk7WUFDRixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDekQsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztTQUMzRDtRQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ1gsT0FBTyxZQUFZLENBQUM7U0FDckI7SUFDSCxDQUFDO0lBRU8sbUJBQW1CLENBQWEsUUFBZ0IsRUFBRSxZQUFlO1FBQ3ZFLElBQUksS0FBaUIsQ0FBQztRQUN0QixJQUFJO1lBQ0YsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLEtBQUssR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO1NBQ3pEO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOzsyR0FwSVUsY0FBYyxrQkFHSCxZQUFZOytHQUh2QixjQUFjLGNBREQsTUFBTTsyRkFDbkIsY0FBYztrQkFEMUIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OzBCQUk3QixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgT3B0aW9uYWwsIEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBpc1VuZGVmaW5lZCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBBcHBsaWNhdGlvbk9wdGlvbnMgfSBmcm9tICcuL0FwcGxpY2F0aW9uT3B0aW9ucyc7XG5pbXBvcnQgeyBFeHRlbnNpb25GYWN0b3J5LCBHZW5lcmljSG9va1R5cGUsIGhvb2tHZW5lcmljLCBIb29rT3B0aW9ucyB9IGZyb20gJy4vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLCBUZW5hbnRPcHRpb25zU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvYXBpJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDb25zaWRlciB1c2luZyB0aGUgYGhvb2tPcHRpb25zYCBmdW5jdGlvbiBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgSE9PS19PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuPEV4dGVuc2lvbkZhY3Rvcnk8QXBwbGljYXRpb25PcHRpb25zPj4oXG4gICdIT09LX09QVElPTlMnXG4pO1xuXG4vKipcbiAqIFlvdSBjYW4gZWl0aGVyIHByb3ZpZGUgYSBzaW5nbGUgYEFwcGxpY2F0aW9uT3B0aW9uc2AgYXMgcGFyYW1ldGVyOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tPcHRpb25zKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tPcHRpb25zKFsuLi5dKVxuICogYGBgXG4gKlxuICogT3IgeW91IHByb3ZpZGUgYW4gU2VydmljZSB0aGF0IGltcGxlbWVudHMgYEV4dGVuc2lvbkZhY3Rvcnk8QXBwbGljYXRpb25PcHRpb25zPmBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBleHBvcnQgY2xhc3MgTXlBcHBsaWNhdGlvbk9wdGlvbnNGYWN0b3J5IGltcGxlbWVudHMgRXh0ZW5zaW9uRmFjdG9yeTxBcHBsaWNhdGlvbk9wdGlvbnM+IHsuLi59XG4gKiAgLi4uXG4gKiAgaG9va09wdGlvbnMoTXlBcHBsaWNhdGlvbk9wdGlvbnNGYWN0b3J5KVxuICogYGBgXG4gKiBBIHR5cGVkIGFsdGVybmF0aXZlIHRvIGBIT09LX09QVElPTlNgLlxuICogQHBhcmFtIG9wdGlvbnMgVGhlIGBBcHBsaWNhdGlvbk9wdGlvbnNgJ3Mgb3IgYEV4dGVuc2lvbkZhY3RvcnlgIHRvIGJlIHByb3ZpZGVkLlxuICogQHJldHVybnMgQW4gYFByb3ZpZGVyYCB0byBiZSBwcm92aWRlZCBpbiB5b3VyIG1vZHVsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhvb2tPcHRpb25zKFxuICBvcHRpb25zOiBHZW5lcmljSG9va1R5cGU8QXBwbGljYXRpb25PcHRpb25zPixcbiAgaG9va09wdGlvbnM/OiBQYXJ0aWFsPEhvb2tPcHRpb25zPlxuKSB7XG4gIHJldHVybiBob29rR2VuZXJpYzxBcHBsaWNhdGlvbk9wdGlvbnM+KG9wdGlvbnMsIEhPT0tfT1BUSU9OUywgaG9va09wdGlvbnMpO1xufVxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGFsbG93cyB0byBzZXQgb3IgZ2V0IGFwcGxpY2F0aW9uIG9wdGlvbnNcbiAqIHdoaWNoIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiB0aGUgVUkuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgT3B0aW9uc1NlcnZpY2UgZXh0ZW5kcyBBcHBsaWNhdGlvbk9wdGlvbnMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoSE9PS19PUFRJT05TKSBvcHRpb25zLFxuICAgIHByaXZhdGUgc3lzdGVtT3B0aW9uc1NlcnZpY2U6IFN5c3RlbU9wdGlvbnNTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVuYW50T3B0aW9uU2VydmljZTogVGVuYW50T3B0aW9uc1NlcnZpY2VcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwT3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFwcGxpY2F0aW9uIG9wdGlvbiB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgVUkuXG4gICAqIEBwYXJhbSBvcHRpb25LZXkgVGhlIGFwcGxpY2F0aW9uIG9wdGlvbnMga2V5LlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEEgdmFsdWUgdG8gcmV0dXJuIGlmIG5vbiBpcyBzZXQuXG4gICAqIEBwYXJhbSBhdHRlbXB0UGFyc2UgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHZhbHVlIHNob3VsZCBiZSBwYXJzZWQgd2l0aCBKU09OLnBhcnNlLlxuICAgKi9cbiAgZ2V0KG9wdGlvbktleToga2V5b2YgT3B0aW9uc1NlcnZpY2UsIGRlZmF1bHRWYWx1ZT86IGFueSwgYXR0ZW1wdFBhcnNlPzogYm9vbGVhbikge1xuICAgIGxldCB2YWx1ZSA9IHRoaXNbb3B0aW9uS2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzW2NhbWVsQ2FzZShvcHRpb25LZXkpXTtcbiAgICB9XG4gICAgaWYgKGF0dGVtcHRQYXJzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcHRpb25SYXdWYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGFwcGxpY2F0aW9uIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHNldC5cbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzW2NhbWVsQ2FzZShrZXkpXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgc3VwcG9ydCB1cmwgZnJvbSB0ZW5hbnQgb3B0aW9ucy5cbiAgICogSWYgcmVzcG9uc2UgcmV0dXJucyAnNDA0IG5vdCBmb3VuZCcgaXQgZ2V0cyB0aGUgc3VwcG9ydCB1cmwgZnJvbSBhcHBsaWNhdGlvbiBvcHRpb25zLlxuICAgKiBJZiB0aGUgc3VwcG9ydCBsaW5rIHdpdGhpbiBhcHBsaWNhdGlvbiBvcHRpb25zIGlzIG5vdCBwcm92aWRlZCB0aGUgVUkgd2lsbCB1c2UgdGhlIHN5c3RlbSBvcHRpb25zLlxuICAgKiBJcyB0aGUgc3VwcG9ydCBsaW5rIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlIGl0IHdpbGwgYmUgaGlkZGVuLlxuICAgKlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHN1cHBvcnQgdXJsIG9yIGZhbHNlLlxuICAgKi9cbiAgYXN5bmMgZ2V0U3VwcG9ydFVybCgpIHtcbiAgICBsZXQgdXJsOiBzdHJpbmcgfCBib29sZWFuID0gYXdhaXQgdGhpcy5nZXRUZW5hbnRPcHRpb24oJ2NvbmZpZ3VyYXRpb24nLCAnc3lzdGVtLnN1cHBvcnQudXJsJyk7XG4gICAgaWYgKGlzVW5kZWZpbmVkKHVybCkpIHtcbiAgICAgIHVybCA9IHRoaXMuc3VwcG9ydFVybDtcbiAgICB9XG4gICAgdGhpcy5zdXBwb3J0VXJsID0gaXNVbmRlZmluZWQodXJsKVxuICAgICAgPyAoYXdhaXQgdGhpcy5nZXRTeXN0ZW1PcHRpb24oJ3N1cHBvcnQnLCAndXJsJykpIHx8IGZhbHNlXG4gICAgICA6IHVybDtcbiAgICByZXR1cm4gdGhpcy5zdXBwb3J0VXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIHRlbmFudCBhbGxvd3MgdG8gc2hvdyB0aGUgYWN0aXZhdGUtc3VwcG9ydCB1c2VyIG1lbnUgZW50cnkuXG4gICAqIE5vdGU6IE9ubHkgaWYgc3lzdGVtLWxldmVsIHN1cHBvcnQtdXNlci9lbmFibGVkIGlzIGZhbHNlIHdlIGNhbiBhY3RpdmF0ZSBpdCBhdCB0ZW5hbnQgbGV2ZWwuXG4gICAqL1xuICBhc3luYyBnZXRBY3RpdmF0ZVN1cHBvcnRVc2VyKCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IGF3YWl0IHRoaXMuZ2V0U3lzdGVtT3B0aW9uKCdzdXBwb3J0LXVzZXInLCAnZW5hYmxlZCcsIHRydWUpO1xuICAgIHJldHVybiAhb3B0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSBzeXN0ZW0gc2VydmljZSBhbmQgcGFyc2VzIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gY2F0ZWdvcnkgVGhlIGNhdGVnb3J5IGZvciB0aGlzIG9wdGlvbi5cbiAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB0aGF0IG9wdGlvbi5cbiAgICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCBpZiB0aGUgb3B0aW9uIHdhcyBub3QgZm91bmQuXG4gICAqL1xuICBhc3luYyBnZXRTeXN0ZW1PcHRpb248VCA9IHN0cmluZz4oXG4gICAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU/OiBUXG4gICk6IFByb21pc2U8VCB8IHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmdldE9wdGlvbkZyb21TZXJ2aWNlPFQ+KGNhdGVnb3J5LCBrZXksIHRoaXMuc3lzdGVtT3B0aW9uc1NlcnZpY2UsIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHZhbHVlIGZyb20gdGhlIHRlbmFudCBzZXJ2aWNlIGFuZCBwYXJzZXMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSBjYXRlZ29yeSBUaGUgY2F0ZWdvcnkgZm9yIHRoaXMgb3B0aW9uLlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgZm9yIHRoYXQgb3B0aW9uLlxuICAgKiBAcGFyYW0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IGlmIHRoZSBvcHRpb24gd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIGFzeW5jIGdldFRlbmFudE9wdGlvbjxUID0gc3RyaW5nPihcbiAgICBjYXRlZ29yeTogc3RyaW5nLFxuICAgIGtleTogc3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZT86IFRcbiAgKTogUHJvbWlzZTxUIHwgc3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3B0aW9uRnJvbVNlcnZpY2U8VD4oY2F0ZWdvcnksIGtleSwgdGhpcy50ZW5hbnRPcHRpb25TZXJ2aWNlLCBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cE9wdGlvbnMob3B0aW9uczogYW55W10gfCBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5mb3JFYWNoKG9wdGlvbk1hcCA9PiB7XG4gICAgICAgIGlmIChvcHRpb25NYXApIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25NYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIHRoaXNbY2FtZWxDYXNlKGtleSldID0gb3B0aW9uTWFwW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0T3B0aW9uRnJvbVNlcnZpY2U8VCA9IHN0cmluZz4oXG4gICAgY2F0ZWdvcnk6IHN0cmluZyxcbiAgICBrZXk6IHN0cmluZyxcbiAgICBzZXJ2aWNlOiBTeXN0ZW1PcHRpb25zU2VydmljZSB8IFRlbmFudE9wdGlvbnNTZXJ2aWNlLFxuICAgIGRlZmF1bHRWYWx1ZTogVFxuICApOiBQcm9taXNlPFQgfCBzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzZXJ2aWNlLmRldGFpbCh7IGNhdGVnb3J5LCBrZXkgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9wdGlvblJhd1ZhbHVlKGRhdGEudmFsdWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwYXJzZU9wdGlvblJhd1ZhbHVlPFQgPSBzdHJpbmc+KHJhd1ZhbHVlOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogVCk6IFQgfCBzdHJpbmcge1xuICAgIGxldCB2YWx1ZTogVCB8IHN0cmluZztcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YWx1ZSA9IGlzVW5kZWZpbmVkKHJhd1ZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHJhd1ZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbiJdfQ==