import { Injectable } from '@angular/core';
import { InventoryBinaryService, SystemOptionsService } from '@c8y/client';
import { every, first, flatten, get, isNaN, isUndefined, keys, map, uniq, min } from 'lodash-es';
import { saveAs } from 'file-saver';
import { Observable, of, throwError } from 'rxjs';
import { catchError, switchMap, startWith, share } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client";
export var GENERIC_FILE_TYPE;
(function (GENERIC_FILE_TYPE) {
    GENERIC_FILE_TYPE["ARCHIVE"] = "archive";
    GENERIC_FILE_TYPE["AUDIO"] = "audio";
    GENERIC_FILE_TYPE["CODE"] = "code";
    GENERIC_FILE_TYPE["EXCEL"] = "excel";
    GENERIC_FILE_TYPE["IMAGE"] = "image";
    GENERIC_FILE_TYPE["PDF"] = "pdf";
    GENERIC_FILE_TYPE["POWERPOINT"] = "powerpoint";
    GENERIC_FILE_TYPE["TEXT"] = "text";
    GENERIC_FILE_TYPE["VIDEO"] = "video";
    GENERIC_FILE_TYPE["WORD"] = "word";
    GENERIC_FILE_TYPE["EPL"] = "epl";
})(GENERIC_FILE_TYPE || (GENERIC_FILE_TYPE = {}));
export class FilesService {
    constructor(systemOptionsService, inventoryBinaryService) {
        this.systemOptionsService = systemOptionsService;
        this.inventoryBinaryService = inventoryBinaryService;
        this.DEFAULT_BYTES_LIMIT = 52428800;
        this.FILENAME_MAX_LENGTH = 128;
        this.fileTypeExtensionsMap = {
            [GENERIC_FILE_TYPE.ARCHIVE]: {
                exts: ['7z', 'apk', 'cab', 'gz', 'iso', 'jar', 'rar', 'tar', 'zip']
            },
            [GENERIC_FILE_TYPE.AUDIO]: {
                exts: ['3gp', 'aiff', 'aac', 'amr', 'm4a', 'm4p', 'mp3', 'oga', 'ogg', 'raw', 'wav', 'wma']
            },
            [GENERIC_FILE_TYPE.CODE]: {
                exts: ['aspx', 'exe', 'htm', 'html', 'jad', 'js', 'json', 'jsp', 'php', 'xml']
            },
            [GENERIC_FILE_TYPE.EXCEL]: {
                exts: ['xls', 'xlsx']
            },
            [GENERIC_FILE_TYPE.IMAGE]: {
                exts: ['bmp', 'gif', 'jpeg', 'jpg', 'png', 'tiff', 'svg', 'ico', 'apng', 'webp']
            },
            [GENERIC_FILE_TYPE.PDF]: {
                exts: ['pdf']
            },
            [GENERIC_FILE_TYPE.POWERPOINT]: {
                exts: ['ppt', 'pptx']
            },
            [GENERIC_FILE_TYPE.TEXT]: {
                exts: ['txt']
            },
            [GENERIC_FILE_TYPE.VIDEO]: {
                exts: ['asf', 'avi', 'flv', 'mov', 'mp4', 'ogv', 'qt', 'rm', 'rmvb', 'wmv', '3gp']
            },
            [GENERIC_FILE_TYPE.WORD]: {
                exts: ['doc', 'docx']
            },
            [GENERIC_FILE_TYPE.EPL]: {
                exts: ['mon']
            }
        };
        this.fileSizeLimitCfg = {
            systemOption: {
                category: 'files',
                key: 'max.size'
            },
            defaultBytesLimit: this.DEFAULT_BYTES_LIMIT,
            actualBytesLimit: undefined
        };
    }
    /**
     * Checks if files have valid size.
     * @param files Files to check.
     * @returns Returns true if each file has the correct size.
     */
    async haveValidSizes(files, maxFileSizeInBytes) {
        const limit = min([maxFileSizeInBytes, await this.loadBytesSizeLimit()]);
        return every(files, (f) => {
            return this.size(f) <= limit;
        });
    }
    /**
     * Checks the system file size limit, if not available returns the default value.
     * Default limit: [DEFAULT_BYTES_LIMIT]{@link DEFAULT_BYTES_LIMIT}
     * @returns Returns promise with the limit value.
     */
    async loadBytesSizeLimit() {
        let bytesLimit = this.DEFAULT_BYTES_LIMIT;
        if (this.fileSizeLimitCfg.actualBytesLimit) {
            return this.fileSizeLimitCfg.actualBytesLimit;
        }
        const { systemOption } = this.fileSizeLimitCfg;
        try {
            const { data: { value: actualBytesLimit } } = await this.systemOptionsService.detail(systemOption);
            if (!actualBytesLimit) {
                return bytesLimit;
            }
            const parsedActualBytesLimit = parseInt(actualBytesLimit, 10);
            if (isNaN(parsedActualBytesLimit)) {
                return bytesLimit;
            }
            this.fileSizeLimitCfg.actualBytesLimit = parsedActualBytesLimit;
            bytesLimit = parsedActualBytesLimit;
        }
        catch (error) {
            // do nothing
        }
        return bytesLimit;
    }
    /**
     * Checks the size of the file
     * @param file File to check.
     * @returns Returns size of the file in bytes.
     */
    size(file) {
        const fileLength = get(file, 'length') || get(file, 'size');
        const attachments = get(file, '_attachments');
        const attachmentsObj = get(attachments, first(keys(attachments)));
        return isUndefined(fileLength) ? get(attachmentsObj, 'length') : fileLength;
    }
    /**
     * Checks whether files have allowed extensions.
     * If the accept parameter is not specified, all extensions are accepted.
     * @param files Files to check.
     * @param accept String of comma separated file extensions and generic types ([GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}), e.g. .zip,.7z,excel.
     * @returns  Returns true if each file has allowed extension.
     */
    haveValidExtensions(files, accept) {
        if (!accept) {
            return true;
        }
        const filesArray = files.item
            ? Array.from(files)
            : Array.isArray(files)
                ? files
                : [files];
        const filesExts = filesArray.map((file) => this.getFileExtension(file)?.toLowerCase());
        const allowedExts = this.extractFileExtensions(accept);
        return filesExts.every(ext => allowedExts.includes(ext));
    }
    /**
     * Checks if each file has a valid filename length.
     * @param files Files to check.
     * @returns Returns true if each file has a valid filename length.
     */
    checkMaxLength(files) {
        return every(files, (f) => {
            return this.FILENAME_MAX_LENGTH > f.name.length;
        });
    }
    /**
     * Extracts the file extension.
     * @param file File from which the extension should be extracted.
     * @returns Returns the file extension or undefined if the file has no extension.
     */
    getFileExtension(file) {
        const fileNameAndFileExt = file.name.split('.');
        if (fileNameAndFileExt.length === 1) {
            // no file ext
            return undefined;
        }
        return fileNameAndFileExt.pop();
    }
    /**
     * List of file extensions.
     * @returns Returns list of file extensions.
     */
    getFileExtensions() {
        return uniq(flatten(map(this.fileTypeExtensionsMap, ({ exts }) => exts)));
    }
    /**
     * The list of generic file types.
     * @returns Returns the list of generic file types.
     */
    getGenericFileTypes() {
        return Object.keys(this.fileTypeExtensionsMap);
    }
    /**
     * @ignore
     */
    mapGenericFileTypesToExtensions(genericFileTypes = []) {
        const fileExts = genericFileTypes.map(gT => {
            const { exts } = this.fileTypeExtensionsMap[gT];
            return exts;
        });
        return uniq(flatten(fileExts));
    }
    /**
     * Extracts a list of file extensions from a string.
     * Can accept generic file types check: [GENERIC_FILE_TYPE]{@link GENERIC_FILE_TYPE}.
     *
     * @param str String from which the file extensions are extracted (comma separated values).
     * Accepted string format:
     * * ".zip,.iso",
     * * "zip,ISO",
     * * "archive".
     * Important: generic types cannot contain a dot. All values with a dot are treated as a normal extension.
     * @returns Returns a list of the file extensions.
     */
    extractFileExtensions(str) {
        if (!str) {
            return [];
        }
        const types = str.split(',').map(t => t.toLowerCase().trim());
        const genericTypes = types.filter((t) => this.isGenericType(t));
        const defaultFileExts = types.filter((t) => !this.isGenericType(t));
        const allTypes = [
            ...this.mapGenericFileTypesToExtensions(genericTypes),
            ...defaultFileExts
        ].map(t => t.replace('.', ''));
        return uniq(allTypes);
    }
    /**
     * Converts a file to a base64 image string.
     *
     * @param file The file to convert to base 64.
     * @returns The image string in base64 format.
     */
    toBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(String(reader.result));
            reader.onerror = error => reject(error);
        });
    }
    /**
     * Allows to get a File representation of an managed object binary. Can be used
     * to convert this file toBase64 to show it to the end-user.
     * @param binary The binary managed object
     * @returns The file representation.
     */
    async getFile(binary) {
        const res = await this.inventoryBinaryService.download(binary.id);
        const arrayBuffer = await res.arrayBuffer();
        return new File([arrayBuffer], binary.name, { type: binary.contentType });
    }
    /**
     * Allows to calculate the hash sum of the provided file.
     * @param file The file to hash.
     * @returns The SHA-256 hash of the file.
     */
    async getHashSumOfFile(file) {
        const buffer = await file.arrayBuffer();
        const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(bytes => bytes.toString(16).padStart(2, '0')).join('');
        return hashHex;
    }
    /**
     * Allows to download a file (opens the browser download prompt).
     * @param binary The binary managed object.
     */
    async download(binary) {
        const file = await this.getFile(binary);
        saveAs(file);
    }
    /**
     * Loads the file to JavaScript memory.
     * Returns an observable that emits progression status object,
     * and after download is completed, blob property is populated with Blob result object.
     * Unsubscribing from the returned observable aborts the file fetch request.
     *
     * @param binary The binary managed object.
     */
    fetchFileWithProgress$(binary) {
        const progress = {
            totalBytes: +binary.length,
            bufferedBytes: 0,
            percentage: 0,
            bytesPerSecond: 0
        };
        return of(new AbortController()).pipe(switchMap(async (abortController) => ({
            abortController,
            startTimestamp: new Date().getTime(),
            response: await this.inventoryBinaryService.download(binary.id, {
                signal: abortController.signal
            })
        })), switchMap(({ response, abortController, startTimestamp }) => this.processResponse$(abortController, response, startTimestamp, progress, binary.type)), startWith(progress), share(), catchError(err => throwError(err)));
    }
    processResponse$(abortController, response, startTimestamp, progress, binaryType) {
        return new Observable(sub => {
            const reader = response.body.getReader();
            const chunks = [];
            const readStream = async () => {
                try {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            progress.blob = new Blob(chunks, { type: binaryType });
                            sub.next({ ...progress });
                            sub.complete();
                            break;
                        }
                        chunks.push(value);
                        progress.bufferedBytes += value.length;
                        const currentTimestamp = new Date().getTime();
                        const timestampDiff = currentTimestamp - startTimestamp;
                        progress.bytesPerSecond = Math.round(progress.bufferedBytes / Math.round(timestampDiff / 1000));
                        progress.percentage = Math.round((progress.bufferedBytes / progress.totalBytes) * 100);
                        sub.next({ ...progress });
                    }
                }
                catch (e) {
                    abortController.abort();
                    sub.error(e);
                }
            };
            readStream();
            return {
                unsubscribe() {
                    abortController.abort();
                    sub.complete();
                }
            };
        });
    }
    isGenericType(type) {
        return Object.values(GENERIC_FILE_TYPE).includes(type);
    }
}
FilesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: FilesService, deps: [{ token: i1.SystemOptionsService }, { token: i1.InventoryBinaryService }], target: i0.ɵɵFactoryTarget.Injectable });
FilesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: FilesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: FilesService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.SystemOptionsService }, { type: i1.InventoryBinaryService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvY29tbW9uL2ZpbGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBR0wsc0JBQXNCLEVBQ3RCLG9CQUFvQixFQUNyQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sV0FBVyxDQUFDO0FBQ2pHLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDcEMsT0FBTyxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xELE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBVXpFLE1BQU0sQ0FBTixJQUFZLGlCQVlYO0FBWkQsV0FBWSxpQkFBaUI7SUFDM0Isd0NBQW1CLENBQUE7SUFDbkIsb0NBQWUsQ0FBQTtJQUNmLGtDQUFhLENBQUE7SUFDYixvQ0FBZSxDQUFBO0lBQ2Ysb0NBQWUsQ0FBQTtJQUNmLGdDQUFXLENBQUE7SUFDWCw4Q0FBeUIsQ0FBQTtJQUN6QixrQ0FBYSxDQUFBO0lBQ2Isb0NBQWUsQ0FBQTtJQUNmLGtDQUFhLENBQUE7SUFDYixnQ0FBVyxDQUFBO0FBQ2IsQ0FBQyxFQVpXLGlCQUFpQixLQUFqQixpQkFBaUIsUUFZNUI7QUFFRCxNQUFNLE9BQU8sWUFBWTtJQWlEdkIsWUFDVSxvQkFBMEMsRUFDMUMsc0JBQThDO1FBRDlDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7UUFDMUMsMkJBQXNC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USxFQUFFLENBQUMsQ0FBQztxQkFDM0I7aUJBQ0Y7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN4QixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNkO1lBQ0gsQ0FBQyxDQUFDO1lBQ0YsVUFBVSxFQUFFLENBQUM7WUFFYixPQUFPO2dCQUNMLFdBQVc7b0JBQ1QsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUN4QixHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQ2pCLENBQUM7YUFDRixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sYUFBYSxDQUFDLElBQVk7UUFDaEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsUUFBUSxDQUFDLElBQXlCLENBQUMsQ0FBQztJQUM5RSxDQUFDOzt5R0E3VlUsWUFBWTs2R0FBWixZQUFZLGNBREMsTUFBTTsyRkFDbkIsWUFBWTtrQkFEeEIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBJRmV0Y2hSZXNwb25zZSxcbiAgSU1hbmFnZWRPYmplY3RCaW5hcnksXG4gIEludmVudG9yeUJpbmFyeVNlcnZpY2UsXG4gIFN5c3RlbU9wdGlvbnNTZXJ2aWNlXG59IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGV2ZXJ5LCBmaXJzdCwgZmxhdHRlbiwgZ2V0LCBpc05hTiwgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgdW5pcSwgbWluIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIHN3aXRjaE1hcCwgc3RhcnRXaXRoLCBzaGFyZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBJRmV0Y2hXaXRoUHJvZ3Jlc3Mge1xuICB0b3RhbEJ5dGVzOiBudW1iZXI7XG4gIGJ1ZmZlcmVkQnl0ZXM6IG51bWJlcjtcbiAgcGVyY2VudGFnZTogbnVtYmVyO1xuICBieXRlc1BlclNlY29uZDogbnVtYmVyO1xuICBibG9iPzogQmxvYjtcbn1cblxuZXhwb3J0IGVudW0gR0VORVJJQ19GSUxFX1RZUEUge1xuICBBUkNISVZFID0gJ2FyY2hpdmUnLFxuICBBVURJTyA9ICdhdWRpbycsXG4gIENPREUgPSAnY29kZScsXG4gIEVYQ0VMID0gJ2V4Y2VsJyxcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBQREYgPSAncGRmJyxcbiAgUE9XRVJQT0lOVCA9ICdwb3dlcnBvaW50JyxcbiAgVEVYVCA9ICd0ZXh0JyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBXT1JEID0gJ3dvcmQnLFxuICBFUEwgPSAnZXBsJ1xufVxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGaWxlc1NlcnZpY2Uge1xuICByZWFkb25seSBERUZBVUxUX0JZVEVTX0xJTUlUID0gNTI0Mjg4MDA7XG4gIHJlYWRvbmx5IEZJTEVOQU1FX01BWF9MRU5HVEggPSAxMjg7XG5cbiAgZmlsZVR5cGVFeHRlbnNpb25zTWFwOiB7IFtrZXk6IHN0cmluZ106IHsgZXh0czogc3RyaW5nW10gfSB9ID0ge1xuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5BUkNISVZFXToge1xuICAgICAgZXh0czogWyc3eicsICdhcGsnLCAnY2FiJywgJ2d6JywgJ2lzbycsICdqYXInLCAncmFyJywgJ3RhcicsICd6aXAnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkFVRElPXToge1xuICAgICAgZXh0czogWyczZ3AnLCAnYWlmZicsICdhYWMnLCAnYW1yJywgJ200YScsICdtNHAnLCAnbXAzJywgJ29nYScsICdvZ2cnLCAncmF3JywgJ3dhdicsICd3bWEnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkNPREVdOiB7XG4gICAgICBleHRzOiBbJ2FzcHgnLCAnZXhlJywgJ2h0bScsICdodG1sJywgJ2phZCcsICdqcycsICdqc29uJywgJ2pzcCcsICdwaHAnLCAneG1sJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5FWENFTF06IHtcbiAgICAgIGV4dHM6IFsneGxzJywgJ3hsc3gnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLklNQUdFXToge1xuICAgICAgZXh0czogWydibXAnLCAnZ2lmJywgJ2pwZWcnLCAnanBnJywgJ3BuZycsICd0aWZmJywgJ3N2ZycsICdpY28nLCAnYXBuZycsICd3ZWJwJ11cbiAgICB9LFxuICAgIFtHRU5FUklDX0ZJTEVfVFlQRS5QREZdOiB7XG4gICAgICBleHRzOiBbJ3BkZiddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuUE9XRVJQT0lOVF06IHtcbiAgICAgIGV4dHM6IFsncHB0JywgJ3BwdHgnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLlRFWFRdOiB7XG4gICAgICBleHRzOiBbJ3R4dCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuVklERU9dOiB7XG4gICAgICBleHRzOiBbJ2FzZicsICdhdmknLCAnZmx2JywgJ21vdicsICdtcDQnLCAnb2d2JywgJ3F0JywgJ3JtJywgJ3JtdmInLCAnd212JywgJzNncCddXG4gICAgfSxcbiAgICBbR0VORVJJQ19GSUxFX1RZUEUuV09SRF06IHtcbiAgICAgIGV4dHM6IFsnZG9jJywgJ2RvY3gnXVxuICAgIH0sXG4gICAgW0dFTkVSSUNfRklMRV9UWVBFLkVQTF06IHtcbiAgICAgIGV4dHM6IFsnbW9uJ11cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBmaWxlU2l6ZUxpbWl0Q2ZnID0ge1xuICAgIHN5c3RlbU9wdGlvbjoge1xuICAgICAgY2F0ZWdvcnk6ICdmaWxlcycsXG4gICAgICBrZXk6ICdtYXguc2l6ZSdcbiAgICB9LFxuICAgIGRlZmF1bHRCeXRlc0xpbWl0OiB0aGlzLkRFRkFVTFRfQllURVNfTElNSVQsXG4gICAgYWN0dWFsQnl0ZXNMaW1pdDogdW5kZWZpbmVkXG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBzeXN0ZW1PcHRpb25zU2VydmljZTogU3lzdGVtT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBpbnZlbnRvcnlCaW5hcnlTZXJ2aWNlOiBJbnZlbnRvcnlCaW5hcnlTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGZpbGVzIGhhdmUgdmFsaWQgc2l6ZS5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyB0aGUgY29ycmVjdCBzaXplLlxuICAgKi9cbiAgYXN5bmMgaGF2ZVZhbGlkU2l6ZXMoZmlsZXM6IEZpbGVMaXN0LCBtYXhGaWxlU2l6ZUluQnl0ZXM/OiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBsaW1pdCA9IG1pbihbbWF4RmlsZVNpemVJbkJ5dGVzLCBhd2FpdCB0aGlzLmxvYWRCeXRlc1NpemVMaW1pdCgpXSk7XG4gICAgcmV0dXJuIGV2ZXJ5KGZpbGVzLCAoZjogRmlsZSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZShmKSA8PSBsaW1pdDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN5c3RlbSBmaWxlIHNpemUgbGltaXQsIGlmIG5vdCBhdmFpbGFibGUgcmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICogRGVmYXVsdCBsaW1pdDogW0RFRkFVTFRfQllURVNfTElNSVRde0BsaW5rIERFRkFVTFRfQllURVNfTElNSVR9XG4gICAqIEByZXR1cm5zIFJldHVybnMgcHJvbWlzZSB3aXRoIHRoZSBsaW1pdCB2YWx1ZS5cbiAgICovXG4gIGFzeW5jIGxvYWRCeXRlc1NpemVMaW1pdCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGxldCBieXRlc0xpbWl0ID0gdGhpcy5ERUZBVUxUX0JZVEVTX0xJTUlUO1xuICAgIGlmICh0aGlzLmZpbGVTaXplTGltaXRDZmcuYWN0dWFsQnl0ZXNMaW1pdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZVNpemVMaW1pdENmZy5hY3R1YWxCeXRlc0xpbWl0O1xuICAgIH1cbiAgICBjb25zdCB7IHN5c3RlbU9wdGlvbiB9ID0gdGhpcy5maWxlU2l6ZUxpbWl0Q2ZnO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YTogeyB2YWx1ZTogYWN0dWFsQnl0ZXNMaW1pdCB9XG4gICAgICB9ID0gYXdhaXQgdGhpcy5zeXN0ZW1PcHRpb25zU2VydmljZS5kZXRhaWwoc3lzdGVtT3B0aW9uKTtcblxuICAgICAgaWYgKCFhY3R1YWxCeXRlc0xpbWl0KSB7XG4gICAgICAgIHJldHVybiBieXRlc0xpbWl0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBY3R1YWxCeXRlc0xpbWl0ID0gcGFyc2VJbnQoYWN0dWFsQnl0ZXNMaW1pdCwgMTApO1xuICAgICAgaWYgKGlzTmFOKHBhcnNlZEFjdHVhbEJ5dGVzTGltaXQpKSB7XG4gICAgICAgIHJldHVybiBieXRlc0xpbWl0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbGVTaXplTGltaXRDZmcuYWN0dWFsQnl0ZXNMaW1pdCA9IHBhcnNlZEFjdHVhbEJ5dGVzTGltaXQ7XG4gICAgICBieXRlc0xpbWl0ID0gcGFyc2VkQWN0dWFsQnl0ZXNMaW1pdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNMaW1pdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHNpemUgb2YgdGhlIGZpbGVcbiAgICogQHBhcmFtIGZpbGUgRmlsZSB0byBjaGVjay5cbiAgICogQHJldHVybnMgUmV0dXJucyBzaXplIG9mIHRoZSBmaWxlIGluIGJ5dGVzLlxuICAgKi9cbiAgc2l6ZShmaWxlOiBGaWxlIHwgSU1hbmFnZWRPYmplY3RCaW5hcnkpOiBudW1iZXIge1xuICAgIGNvbnN0IGZpbGVMZW5ndGggPSBnZXQoZmlsZSwgJ2xlbmd0aCcpIHx8IGdldChmaWxlLCAnc2l6ZScpO1xuICAgIGNvbnN0IGF0dGFjaG1lbnRzID0gZ2V0KGZpbGUsICdfYXR0YWNobWVudHMnKTtcbiAgICBjb25zdCBhdHRhY2htZW50c09iaiA9IGdldChhdHRhY2htZW50cywgZmlyc3Qoa2V5cyhhdHRhY2htZW50cykpKTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQoZmlsZUxlbmd0aCkgPyBnZXQoYXR0YWNobWVudHNPYmosICdsZW5ndGgnKSA6IGZpbGVMZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgZmlsZXMgaGF2ZSBhbGxvd2VkIGV4dGVuc2lvbnMuXG4gICAqIElmIHRoZSBhY2NlcHQgcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQsIGFsbCBleHRlbnNpb25zIGFyZSBhY2NlcHRlZC5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0gYWNjZXB0IFN0cmluZyBvZiBjb21tYSBzZXBhcmF0ZWQgZmlsZSBleHRlbnNpb25zIGFuZCBnZW5lcmljIHR5cGVzIChbR0VORVJJQ19GSUxFX1RZUEVde0BsaW5rIEdFTkVSSUNfRklMRV9UWVBFfSksIGUuZy4gLnppcCwuN3osZXhjZWwuXG4gICAqIEByZXR1cm5zICBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyBhbGxvd2VkIGV4dGVuc2lvbi5cbiAgICovXG4gIGhhdmVWYWxpZEV4dGVuc2lvbnMoZmlsZXM6IEZpbGVMaXN0IHwgRmlsZSB8IEZpbGVbXSwgYWNjZXB0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGZpbGVzQXJyYXkgPSAoZmlsZXMgYXMgRmlsZUxpc3QpLml0ZW1cbiAgICAgID8gQXJyYXkuZnJvbShmaWxlcyBhcyBGaWxlTGlzdClcbiAgICAgIDogQXJyYXkuaXNBcnJheShmaWxlcylcbiAgICAgID8gZmlsZXNcbiAgICAgIDogW2ZpbGVzXTtcblxuICAgIGNvbnN0IGZpbGVzRXh0cyA9IGZpbGVzQXJyYXkubWFwKChmaWxlOiBGaWxlKSA9PiB0aGlzLmdldEZpbGVFeHRlbnNpb24oZmlsZSk/LnRvTG93ZXJDYXNlKCkpO1xuICAgIGNvbnN0IGFsbG93ZWRFeHRzID0gdGhpcy5leHRyYWN0RmlsZUV4dGVuc2lvbnMoYWNjZXB0KTtcbiAgICByZXR1cm4gZmlsZXNFeHRzLmV2ZXJ5KGV4dCA9PiBhbGxvd2VkRXh0cy5pbmNsdWRlcyhleHQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgZWFjaCBmaWxlIGhhcyBhIHZhbGlkIGZpbGVuYW1lIGxlbmd0aC5cbiAgICogQHBhcmFtIGZpbGVzIEZpbGVzIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgZWFjaCBmaWxlIGhhcyBhIHZhbGlkIGZpbGVuYW1lIGxlbmd0aC5cbiAgICovXG4gIGNoZWNrTWF4TGVuZ3RoKGZpbGVzOiBGaWxlTGlzdCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBldmVyeShmaWxlcywgKGY6IEZpbGUpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLkZJTEVOQU1FX01BWF9MRU5HVEggPiBmLm5hbWUubGVuZ3RoO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaWxlIGV4dGVuc2lvbi5cbiAgICogQHBhcmFtIGZpbGUgRmlsZSBmcm9tIHdoaWNoIHRoZSBleHRlbnNpb24gc2hvdWxkIGJlIGV4dHJhY3RlZC5cbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZmlsZSBleHRlbnNpb24gb3IgdW5kZWZpbmVkIGlmIHRoZSBmaWxlIGhhcyBubyBleHRlbnNpb24uXG4gICAqL1xuICBnZXRGaWxlRXh0ZW5zaW9uKGZpbGU6IEZpbGUpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGZpbGVOYW1lQW5kRmlsZUV4dCA9IGZpbGUubmFtZS5zcGxpdCgnLicpO1xuICAgIGlmIChmaWxlTmFtZUFuZEZpbGVFeHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBubyBmaWxlIGV4dFxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVOYW1lQW5kRmlsZUV4dC5wb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucy5cbiAgICogQHJldHVybnMgUmV0dXJucyBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucy5cbiAgICovXG4gIGdldEZpbGVFeHRlbnNpb25zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKG1hcCh0aGlzLmZpbGVUeXBlRXh0ZW5zaW9uc01hcCwgKHsgZXh0cyB9KSA9PiBleHRzKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIGdlbmVyaWMgZmlsZSB0eXBlcy5cbiAgICogQHJldHVybnMgUmV0dXJucyB0aGUgbGlzdCBvZiBnZW5lcmljIGZpbGUgdHlwZXMuXG4gICAqL1xuICBnZXRHZW5lcmljRmlsZVR5cGVzKCk6IEdFTkVSSUNfRklMRV9UWVBFW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmZpbGVUeXBlRXh0ZW5zaW9uc01hcCkgYXMgR0VORVJJQ19GSUxFX1RZUEVbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBtYXBHZW5lcmljRmlsZVR5cGVzVG9FeHRlbnNpb25zKGdlbmVyaWNGaWxlVHlwZXM6IEdFTkVSSUNfRklMRV9UWVBFW10gPSBbXSk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBmaWxlRXh0cyA9IGdlbmVyaWNGaWxlVHlwZXMubWFwKGdUID0+IHtcbiAgICAgIGNvbnN0IHsgZXh0cyB9ID0gdGhpcy5maWxlVHlwZUV4dGVuc2lvbnNNYXBbZ1RdO1xuICAgICAgcmV0dXJuIGV4dHM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKGZpbGVFeHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgbGlzdCBvZiBmaWxlIGV4dGVuc2lvbnMgZnJvbSBhIHN0cmluZy5cbiAgICogQ2FuIGFjY2VwdCBnZW5lcmljIGZpbGUgdHlwZXMgY2hlY2s6IFtHRU5FUklDX0ZJTEVfVFlQRV17QGxpbmsgR0VORVJJQ19GSUxFX1RZUEV9LlxuICAgKlxuICAgKiBAcGFyYW0gc3RyIFN0cmluZyBmcm9tIHdoaWNoIHRoZSBmaWxlIGV4dGVuc2lvbnMgYXJlIGV4dHJhY3RlZCAoY29tbWEgc2VwYXJhdGVkIHZhbHVlcykuXG4gICAqIEFjY2VwdGVkIHN0cmluZyBmb3JtYXQ6XG4gICAqICogXCIuemlwLC5pc29cIixcbiAgICogKiBcInppcCxJU09cIixcbiAgICogKiBcImFyY2hpdmVcIi5cbiAgICogSW1wb3J0YW50OiBnZW5lcmljIHR5cGVzIGNhbm5vdCBjb250YWluIGEgZG90LiBBbGwgdmFsdWVzIHdpdGggYSBkb3QgYXJlIHRyZWF0ZWQgYXMgYSBub3JtYWwgZXh0ZW5zaW9uLlxuICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZmlsZSBleHRlbnNpb25zLlxuICAgKi9cbiAgZXh0cmFjdEZpbGVFeHRlbnNpb25zKHN0cjogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHR5cGVzID0gc3RyLnNwbGl0KCcsJykubWFwKHQgPT4gdC50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XG5cbiAgICBjb25zdCBnZW5lcmljVHlwZXMgPSB0eXBlcy5maWx0ZXIoKHQ6IHN0cmluZykgPT4gdGhpcy5pc0dlbmVyaWNUeXBlKHQpKTtcbiAgICBjb25zdCBkZWZhdWx0RmlsZUV4dHMgPSB0eXBlcy5maWx0ZXIoKHQ6IHN0cmluZykgPT4gIXRoaXMuaXNHZW5lcmljVHlwZSh0KSk7XG5cbiAgICBjb25zdCBhbGxUeXBlcyA9IFtcbiAgICAgIC4uLnRoaXMubWFwR2VuZXJpY0ZpbGVUeXBlc1RvRXh0ZW5zaW9ucyhnZW5lcmljVHlwZXMgYXMgR0VORVJJQ19GSUxFX1RZUEVbXSksXG4gICAgICAuLi5kZWZhdWx0RmlsZUV4dHNcbiAgICBdLm1hcCh0ID0+IHQucmVwbGFjZSgnLicsICcnKSk7XG5cbiAgICByZXR1cm4gdW5pcShhbGxUeXBlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBmaWxlIHRvIGEgYmFzZTY0IGltYWdlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgdG8gY29udmVydCB0byBiYXNlIDY0LlxuICAgKiBAcmV0dXJucyBUaGUgaW1hZ2Ugc3RyaW5nIGluIGJhc2U2NCBmb3JtYXQuXG4gICAqL1xuICB0b0Jhc2U2NChmaWxlOiBGaWxlKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoU3RyaW5nKHJlYWRlci5yZXN1bHQpKTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZXJyb3IgPT4gcmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gZ2V0IGEgRmlsZSByZXByZXNlbnRhdGlvbiBvZiBhbiBtYW5hZ2VkIG9iamVjdCBiaW5hcnkuIENhbiBiZSB1c2VkXG4gICAqIHRvIGNvbnZlcnQgdGhpcyBmaWxlIHRvQmFzZTY0IHRvIHNob3cgaXQgdG8gdGhlIGVuZC11c2VyLlxuICAgKiBAcGFyYW0gYmluYXJ5IFRoZSBiaW5hcnkgbWFuYWdlZCBvYmplY3RcbiAgICogQHJldHVybnMgVGhlIGZpbGUgcmVwcmVzZW50YXRpb24uXG4gICAqL1xuICBhc3luYyBnZXRGaWxlKGJpbmFyeTogSU1hbmFnZWRPYmplY3RCaW5hcnkpOiBQcm9taXNlPEZpbGU+IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmludmVudG9yeUJpbmFyeVNlcnZpY2UuZG93bmxvYWQoYmluYXJ5LmlkKTtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHJlcy5hcnJheUJ1ZmZlcigpO1xuICAgIHJldHVybiBuZXcgRmlsZShbYXJyYXlCdWZmZXJdLCBiaW5hcnkubmFtZSwgeyB0eXBlOiBiaW5hcnkuY29udGVudFR5cGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIHRvIGNhbGN1bGF0ZSB0aGUgaGFzaCBzdW0gb2YgdGhlIHByb3ZpZGVkIGZpbGUuXG4gICAqIEBwYXJhbSBmaWxlIFRoZSBmaWxlIHRvIGhhc2guXG4gICAqIEByZXR1cm5zIFRoZSBTSEEtMjU2IGhhc2ggb2YgdGhlIGZpbGUuXG4gICAqL1xuICBhc3luYyBnZXRIYXNoU3VtT2ZGaWxlKGZpbGU6IEZpbGUpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBidWZmZXIpO1xuICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKGJ5dGVzID0+IGJ5dGVzLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gaGFzaEhleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gZG93bmxvYWQgYSBmaWxlIChvcGVucyB0aGUgYnJvd3NlciBkb3dubG9hZCBwcm9tcHQpLlxuICAgKiBAcGFyYW0gYmluYXJ5IFRoZSBiaW5hcnkgbWFuYWdlZCBvYmplY3QuXG4gICAqL1xuICBhc3luYyBkb3dubG9hZChiaW5hcnk6IElNYW5hZ2VkT2JqZWN0QmluYXJ5KSB7XG4gICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuZ2V0RmlsZShiaW5hcnkpO1xuICAgIHNhdmVBcyhmaWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZmlsZSB0byBKYXZhU2NyaXB0IG1lbW9yeS5cbiAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgcHJvZ3Jlc3Npb24gc3RhdHVzIG9iamVjdCxcbiAgICogYW5kIGFmdGVyIGRvd25sb2FkIGlzIGNvbXBsZXRlZCwgYmxvYiBwcm9wZXJ0eSBpcyBwb3B1bGF0ZWQgd2l0aCBCbG9iIHJlc3VsdCBvYmplY3QuXG4gICAqIFVuc3Vic2NyaWJpbmcgZnJvbSB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSBhYm9ydHMgdGhlIGZpbGUgZmV0Y2ggcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIGJpbmFyeSBUaGUgYmluYXJ5IG1hbmFnZWQgb2JqZWN0LlxuICAgKi9cbiAgZmV0Y2hGaWxlV2l0aFByb2dyZXNzJChiaW5hcnk6IElNYW5hZ2VkT2JqZWN0QmluYXJ5KTogT2JzZXJ2YWJsZTxJRmV0Y2hXaXRoUHJvZ3Jlc3M+IHtcbiAgICBjb25zdCBwcm9ncmVzczogSUZldGNoV2l0aFByb2dyZXNzID0ge1xuICAgICAgdG90YWxCeXRlczogK2JpbmFyeS5sZW5ndGgsXG4gICAgICBidWZmZXJlZEJ5dGVzOiAwLFxuICAgICAgcGVyY2VudGFnZTogMCxcbiAgICAgIGJ5dGVzUGVyU2Vjb25kOiAwXG4gICAgfTtcblxuICAgIHJldHVybiBvZihuZXcgQWJvcnRDb250cm9sbGVyKCkpLnBpcGUoXG4gICAgICBzd2l0Y2hNYXAoYXN5bmMgYWJvcnRDb250cm9sbGVyID0+ICh7XG4gICAgICAgIGFib3J0Q29udHJvbGxlcixcbiAgICAgICAgc3RhcnRUaW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpLFxuICAgICAgICByZXNwb25zZTogYXdhaXQgdGhpcy5pbnZlbnRvcnlCaW5hcnlTZXJ2aWNlLmRvd25sb2FkKGJpbmFyeS5pZCwge1xuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KVxuICAgICAgfSkpLFxuICAgICAgc3dpdGNoTWFwKCh7IHJlc3BvbnNlLCBhYm9ydENvbnRyb2xsZXIsIHN0YXJ0VGltZXN0YW1wIH0pID0+XG4gICAgICAgIHRoaXMucHJvY2Vzc1Jlc3BvbnNlJChhYm9ydENvbnRyb2xsZXIsIHJlc3BvbnNlLCBzdGFydFRpbWVzdGFtcCwgcHJvZ3Jlc3MsIGJpbmFyeS50eXBlKVxuICAgICAgKSxcbiAgICAgIHN0YXJ0V2l0aChwcm9ncmVzcyksXG4gICAgICBzaGFyZSgpLFxuICAgICAgY2F0Y2hFcnJvcihlcnIgPT4gdGhyb3dFcnJvcihlcnIpKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NSZXNwb25zZSQoXG4gICAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICAgcmVzcG9uc2U6IElGZXRjaFJlc3BvbnNlLFxuICAgIHN0YXJ0VGltZXN0YW1wOiBudW1iZXIsXG4gICAgcHJvZ3Jlc3M6IElGZXRjaFdpdGhQcm9ncmVzcyxcbiAgICBiaW5hcnlUeXBlOiBzdHJpbmdcbiAgKTogT2JzZXJ2YWJsZTxJRmV0Y2hXaXRoUHJvZ3Jlc3M+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3ViID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcblxuICAgICAgY29uc3QgcmVhZFN0cmVhbSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcHJvZ3Jlc3MuYmxvYiA9IG5ldyBCbG9iKGNodW5rcywgeyB0eXBlOiBiaW5hcnlUeXBlIH0pO1xuICAgICAgICAgICAgICBzdWIubmV4dCh7IC4uLnByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICBzdWIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcblxuICAgICAgICAgICAgcHJvZ3Jlc3MuYnVmZmVyZWRCeXRlcyArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZXN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXBEaWZmID0gY3VycmVudFRpbWVzdGFtcCAtIHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgcHJvZ3Jlc3MuYnl0ZXNQZXJTZWNvbmQgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICBwcm9ncmVzcy5idWZmZXJlZEJ5dGVzIC8gTWF0aC5yb3VuZCh0aW1lc3RhbXBEaWZmIC8gMTAwMClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwcm9ncmVzcy5wZXJjZW50YWdlID0gTWF0aC5yb3VuZCgocHJvZ3Jlc3MuYnVmZmVyZWRCeXRlcyAvIHByb2dyZXNzLnRvdGFsQnl0ZXMpICogMTAwKTtcbiAgICAgICAgICAgIHN1Yi5uZXh0KHsgLi4ucHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgc3ViLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVhZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICBzdWIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaXNHZW5lcmljVHlwZSh0eXBlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhHRU5FUklDX0ZJTEVfVFlQRSkuaW5jbHVkZXModHlwZSBhcyBHRU5FUklDX0ZJTEVfVFlQRSk7XG4gIH1cbn1cbiJdfQ==