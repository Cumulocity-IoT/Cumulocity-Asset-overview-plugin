import { DatePipe as NgDatePipe, DATE_PIPE_DEFAULT_TIMEZONE } from '@angular/common';
import { Inject, LOCALE_ID, Optional, Pipe } from '@angular/core';
import { TranslateService } from '@ngx-translate/core';
import { gettext } from '../i18n/gettext';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-translate/core";
/**
 * The range of times supported by ECMAScript Date objects in milliseconds.
 * @see http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.1
 */
export const ES_MAX_TIME_MILLISECONDS = 8640000000000000;
/**
 * Formats a date value according to locale rules. If no other format specified it defaults to `medium`
 * used as standard date/time format.
 *
 * Extends Angular's DatePipe in a way so that date values exceeding the range supported by ECMAScript
 * are displayed as earliest/latest supported point in time printed in the desired format pre- or postfixed
 * by the word `before` or `after`, respectively.
 * In all other cases the pipe behaves as the standard [DatePipe]{@link https://angular.io/api/common/DatePipe}.
 *
 * ```html
 * <span class="highlight">{{ deadline | c8yDate }}</span> <!-- e.g. 7 May 2020, 17:45:19 (en-GB) or 07.05.2020, 17:45:19 (de) -->
 * <span>{{ lastUpdated | c8yDate: 'a h:MM:ss' }}</span> <!-- e.g. pm 5:45:19 -->
 * <span>{{ 8640000000000000 + 1 | c8yDate }}</span> <!-- e.g. after 13 Sep 275760, 03:00:00 --> ```
 */
export class DatePipe extends NgDatePipe {
    constructor(locale, translateService, defaultTimezone) {
        super(locale, defaultTimezone);
        this.translateService = translateService;
    }
    transform(value, format = 'medium', timezone, locale) {
        let valueInBounds = value;
        let valueBefore = false;
        let valueBeyond = false;
        if (typeof value === 'number' && !isNaN(value)) {
            valueInBounds = Math.min(value, ES_MAX_TIME_MILLISECONDS);
            valueInBounds = Math.max(valueInBounds, -ES_MAX_TIME_MILLISECONDS);
            valueBefore = value < -ES_MAX_TIME_MILLISECONDS;
            valueBeyond = value > ES_MAX_TIME_MILLISECONDS;
        }
        let result = super.transform(valueInBounds, format, timezone, locale);
        if (valueBefore) {
            result = this.translateService.instant(gettext(`before {{date}}`), { date: result });
        }
        else if (valueBeyond) {
            result = this.translateService.instant(gettext(`after {{date}}`), { date: result });
        }
        return result;
    }
}
DatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: DatePipe, deps: [{ token: LOCALE_ID }, { token: i1.TranslateService }, { token: DATE_PIPE_DEFAULT_TIMEZONE, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });
DatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "14.0.6", ngImport: i0, type: DatePipe, name: "c8yDate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: DatePipe, decorators: [{
            type: Pipe,
            args: [{ name: 'c8yDate' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i1.TranslateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATE_PIPE_DEFAULT_TIMEZONE]
                }, {
                    type: Optional
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29yZS9jb21tb24vZGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLElBQUksVUFBVSxFQUFFLDBCQUEwQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDckYsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7OztBQUUxQzs7O0dBR0c7QUFDSCxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUV6RDs7Ozs7Ozs7Ozs7OztHQWFHO0FBRUgsTUFBTSxPQUFPLFFBQVMsU0FBUSxVQUFVO0lBQ3RDLFlBQ3FCLE1BQWMsRUFDekIsZ0JBQWtDLEVBQ00sZUFBK0I7UUFFL0UsS0FBSyxDQUFDLE1BQU0sRUFBRSxlQUFlLENBQUMsQ0FBQztRQUh2QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBSTVDLENBQUM7SUFFRCxTQUFTLENBQUMsS0FBVSxFQUFFLE1BQU0sR0FBRyxRQUFRLEVBQUUsUUFBaUIsRUFBRSxNQUFlO1FBQ3pFLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQztRQUMxQixJQUFJLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBRXhCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzlDLGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1lBQzFELGFBQWEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDLHdCQUF3QixDQUFDLENBQUM7WUFFbkUsV0FBVyxHQUFHLEtBQUssR0FBRyxDQUFDLHdCQUF3QixDQUFDO1lBQ2hELFdBQVcsR0FBRyxLQUFLLEdBQUcsd0JBQXdCLENBQUM7U0FDaEQ7UUFDRCxJQUFJLE1BQU0sR0FBVyxLQUFLLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBRTlFLElBQUksV0FBVyxFQUFFO1lBQ2YsTUFBTSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUN0RjthQUFNLElBQUksV0FBVyxFQUFFO1lBQ3RCLE1BQU0sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDckY7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztxR0E5QlUsUUFBUSxrQkFFVCxTQUFTLDZDQUVULDBCQUEwQjttR0FKekIsUUFBUTsyRkFBUixRQUFRO2tCQURwQixJQUFJO21CQUFDLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRTs7MEJBR3BCLE1BQU07MkJBQUMsU0FBUzs7MEJBRWhCLE1BQU07MkJBQUMsMEJBQTBCOzswQkFBRyxRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0ZVBpcGUgYXMgTmdEYXRlUGlwZSwgREFURV9QSVBFX0RFRkFVTFRfVElNRVpPTkUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBMT0NBTEVfSUQsIE9wdGlvbmFsLCBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBnZXR0ZXh0IH0gZnJvbSAnLi4vaTE4bi9nZXR0ZXh0JztcblxuLyoqXG4gKiBUaGUgcmFuZ2Ugb2YgdGltZXMgc3VwcG9ydGVkIGJ5IEVDTUFTY3JpcHQgRGF0ZSBvYmplY3RzIGluIG1pbGxpc2Vjb25kcy5cbiAqIEBzZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLTE1LjkuMS4xXG4gKi9cbmV4cG9ydCBjb25zdCBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFMgPSA4NjQwMDAwMDAwMDAwMDAwO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBkYXRlIHZhbHVlIGFjY29yZGluZyB0byBsb2NhbGUgcnVsZXMuIElmIG5vIG90aGVyIGZvcm1hdCBzcGVjaWZpZWQgaXQgZGVmYXVsdHMgdG8gYG1lZGl1bWBcbiAqIHVzZWQgYXMgc3RhbmRhcmQgZGF0ZS90aW1lIGZvcm1hdC5cbiAqXG4gKiBFeHRlbmRzIEFuZ3VsYXIncyBEYXRlUGlwZSBpbiBhIHdheSBzbyB0aGF0IGRhdGUgdmFsdWVzIGV4Y2VlZGluZyB0aGUgcmFuZ2Ugc3VwcG9ydGVkIGJ5IEVDTUFTY3JpcHRcbiAqIGFyZSBkaXNwbGF5ZWQgYXMgZWFybGllc3QvbGF0ZXN0IHN1cHBvcnRlZCBwb2ludCBpbiB0aW1lIHByaW50ZWQgaW4gdGhlIGRlc2lyZWQgZm9ybWF0IHByZS0gb3IgcG9zdGZpeGVkXG4gKiBieSB0aGUgd29yZCBgYmVmb3JlYCBvciBgYWZ0ZXJgLCByZXNwZWN0aXZlbHkuXG4gKiBJbiBhbGwgb3RoZXIgY2FzZXMgdGhlIHBpcGUgYmVoYXZlcyBhcyB0aGUgc3RhbmRhcmQgW0RhdGVQaXBlXXtAbGluayBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvbW1vbi9EYXRlUGlwZX0uXG4gKlxuICogYGBgaHRtbFxuICogPHNwYW4gY2xhc3M9XCJoaWdobGlnaHRcIj57eyBkZWFkbGluZSB8IGM4eURhdGUgfX08L3NwYW4+IDwhLS0gZS5nLiA3IE1heSAyMDIwLCAxNzo0NToxOSAoZW4tR0IpIG9yIDA3LjA1LjIwMjAsIDE3OjQ1OjE5IChkZSkgLS0+XG4gKiA8c3Bhbj57eyBsYXN0VXBkYXRlZCB8IGM4eURhdGU6ICdhIGg6TU06c3MnIH19PC9zcGFuPiA8IS0tIGUuZy4gcG0gNTo0NToxOSAtLT5cbiAqIDxzcGFuPnt7IDg2NDAwMDAwMDAwMDAwMDAgKyAxIHwgYzh5RGF0ZSB9fTwvc3Bhbj4gPCEtLSBlLmcuIGFmdGVyIDEzIFNlcCAyNzU3NjAsIDAzOjAwOjAwIC0tPiBgYGBcbiAqL1xuQFBpcGUoeyBuYW1lOiAnYzh5RGF0ZScgfSlcbmV4cG9ydCBjbGFzcyBEYXRlUGlwZSBleHRlbmRzIE5nRGF0ZVBpcGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KExPQ0FMRV9JRCkgbG9jYWxlOiBzdHJpbmcsXG4gICAgcHJpdmF0ZSB0cmFuc2xhdGVTZXJ2aWNlOiBUcmFuc2xhdGVTZXJ2aWNlLFxuICAgIEBJbmplY3QoREFURV9QSVBFX0RFRkFVTFRfVElNRVpPTkUpIEBPcHRpb25hbCgpIGRlZmF1bHRUaW1lem9uZT86IHN0cmluZyB8IG51bGxcbiAgKSB7XG4gICAgc3VwZXIobG9jYWxlLCBkZWZhdWx0VGltZXpvbmUpO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBhbnksIGZvcm1hdCA9ICdtZWRpdW0nLCB0aW1lem9uZT86IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogYW55IHtcbiAgICBsZXQgdmFsdWVJbkJvdW5kcyA9IHZhbHVlO1xuICAgIGxldCB2YWx1ZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCB2YWx1ZUJleW9uZCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWluKHZhbHVlLCBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuICAgICAgdmFsdWVJbkJvdW5kcyA9IE1hdGgubWF4KHZhbHVlSW5Cb3VuZHMsIC1FU19NQVhfVElNRV9NSUxMSVNFQ09ORFMpO1xuXG4gICAgICB2YWx1ZUJlZm9yZSA9IHZhbHVlIDwgLUVTX01BWF9USU1FX01JTExJU0VDT05EUztcbiAgICAgIHZhbHVlQmV5b25kID0gdmFsdWUgPiBFU19NQVhfVElNRV9NSUxMSVNFQ09ORFM7XG4gICAgfVxuICAgIGxldCByZXN1bHQ6IHN0cmluZyA9IHN1cGVyLnRyYW5zZm9ybSh2YWx1ZUluQm91bmRzLCBmb3JtYXQsIHRpbWV6b25lLCBsb2NhbGUpO1xuXG4gICAgaWYgKHZhbHVlQmVmb3JlKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuaW5zdGFudChnZXR0ZXh0KGBiZWZvcmUge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZUJleW9uZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLmluc3RhbnQoZ2V0dGV4dChgYWZ0ZXIge3tkYXRlfX1gKSwgeyBkYXRlOiByZXN1bHQgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19