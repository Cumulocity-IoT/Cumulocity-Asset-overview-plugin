import { __decorate, __metadata } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { FetchClient, TenantLoginOptionsService, ApplicationService } from '@c8y/client';
import { keys, get } from 'lodash-es';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { distinctUntilChanged, filter, map, scan, switchMap, shareReplay, startWith, debounceTime, take } from 'rxjs/operators';
import { OptionsService } from './options.service';
import { StateService } from './state-service.abstract';
import { ApiService } from '@c8y/ngx-components/api';
import { throttle } from './throttle.decorator';
import { satisfies } from 'semver';
import * as i0 from "@angular/core";
import * as i1 from "@c8y/client";
import * as i2 from "@c8y/ngx-components/api";
import * as i3 from "./options.service";
export class AppStateService extends StateService {
    constructor(applicationService, apiService, options, fetchClient, tenantLoginOptionsService) {
        super();
        this.applicationService = applicationService;
        this.apiService = apiService;
        this.options = options;
        this.fetchClient = fetchClient;
        this.tenantLoginOptionsService = tenantLoginOptionsService;
        this.state$ = new BehaviorSubject({
            app: {
                name: this.options.name,
                contextPath: this.getCurrentContextPath() || this.options.contextPath
            },
            supportUrl: this.options.supportUrl,
            lang: this.options.get('defaultLanguage', 'en'),
            langs: this.getLangs(),
            langsDetail: this.options.languages,
            loginOptions: this.options.loginOptions,
            activateSupportUserAvailable: undefined,
            versions: {
                backend: undefined,
                ui: this.options.versions || { ngx: undefined }
            },
            hidePowered: this.options.hidePowered,
            isLoading: false,
            showRightDrawer: this.options.rightDrawer,
            loginExtraLink: this.options.get('login_extra_link'),
            newsletter: this.options.newsletter
        });
        this.currentSupportUserName = new BehaviorSubject(null);
        this.currentUser = new BehaviorSubject(null);
        this.currentTenant = new BehaviorSubject(null);
        this.currentApplication = new BehaviorSubject(null);
        this.currentApplicationConfig = this.currentApplication.pipe(filter(app => !!app), map(app => app?.config || null));
        this.apiService.calls
            .pipe(filter(({ url }) => !/notification\/realtime/.test(url)), map(({ phase }) => (phase === 'start' ? 1 : -1)), scan((count, item) => count + item, 0), map(count => count > 0), distinctUntilChanged())
            .subscribe(isLoading => (this.state.isLoading = isLoading));
        this.assignApplicationKeyToDefaultHeaders();
        this.currentAppsOfUser = this.currentAppsOfUser$();
    }
    assignApplicationKeyToDefaultHeaders() {
        if (!isDevMode()) {
            this.fetchClient.defaultHeaders = {
                ...(this.fetchClient.defaultHeaders || {}),
                'X-Cumulocity-Application-Key': this.options.key
            };
        }
    }
    /**
     * Returns the current state.
     */
    get state() {
        return this.state$.value;
    }
    getLangs() {
        const { languages } = this.options;
        return languages ? keys(languages).filter(k => languages[k]) : [];
    }
    /**
     * Returns the correct UI version. In hybrid mode for angular and ngx.
     */
    get uiVersion() {
        const version = this.state.versions.ui;
        return version.ngx || version.ng1;
    }
    /**
     * Loads the app manifest. If no access -> throw an error to verify app access.
     */
    async loadManifest() {
        try {
            const { data: application } = await this.applicationService.getManifestOfContextPath(this.state.app.contextPath);
            this.state.app.manifest = application;
            this.state.app.id = application.id;
            const { data } = await this.applicationService.detail(application.id);
            this.currentApplication.next(data);
            await this.loadDefaultOptions();
        }
        catch (ex) {
            this.currentApplication.next({});
            throw ex;
        }
    }
    /**
     * Dynamic options are stored on the API in a specific config: {} object. They can
     * be used to configure the app dynamically.
     *
     * Note: To avoids conflicts with the default Config, it is recommended
     * to use a certain namespace.
     */
    async updateCurrentApplicationConfig(config) {
        const appWithUpdatedConfig = await this.applicationService.updateApplicationConfig(this.state.app.id, config);
        this.currentApplication.next(appWithUpdatedConfig);
        return appWithUpdatedConfig.config;
    }
    /**
     * When this function called, it refreshes the values of loginOptions stored within ui state object.
     * Function is throttled to execute the refresh once in a time specified by params of @throttled decorator,
     * it should be called on leading edge of the timeout.
     */
    async refreshLoginOptions() {
        const loginOptions = (await this.tenantLoginOptionsService.listForCurrentTenant()).data;
        this.state$.next({ ...this.state, loginOptions });
    }
    /**
     * Checks current users application list and matches it against given application name.
     * Returns true if application is in the list.
     * @param name application name
     */
    async isApplicationAvailable(name) {
        const apps = await this.currentAppsOfUser.pipe(take(1)).toPromise();
        return apps.some(app => app.name === name || app.contextPath === name);
    }
    /**
     * Sets current user (including support user).
     * @param userInfo Info about current user and support user to be set.
     */
    setUser(userInfo) {
        this.currentSupportUserName.next(userInfo.supportUserName || null);
        this.currentUser.next(userInfo.user);
    }
    /**
     * Verifies if the current application is owned by the current tenant.
     * @param app The application to verify.
     * @returns true if it belongs to the current tenant.
     */
    isOwnerOfApplication(app) {
        if (!app) {
            app = this.currentApplication.value;
        }
        const currentTenant = this.currentTenant.value;
        const appOwner = get(app, 'owner.tenant.id');
        return currentTenant.name === appOwner;
    }
    getCurrentContextPath() {
        const match = window.location.pathname.match(/\/apps\/(public\/){0,1}(.+?)(\/|\?|#|$)/);
        return match && match[2];
    }
    currentAppsOfUser$() {
        const appChanges$ = this.onAppChangesCompletion$().pipe(startWith(undefined));
        const userChanges$ = this.currentUser.pipe(map(user => user?.id), distinctUntilChanged());
        return combineLatest([userChanges$, appChanges$]).pipe(filter(([userId]) => !!userId), switchMap(([userId]) => this.applicationService.listByUser(userId, {
            dropOverwrittenApps: true,
            noPaging: true
        })), map(({ data }) => data), shareReplay({ bufferSize: 1, refCount: true }));
    }
    /**
     * An Observable emitting once all POST, PUT, DELETE requests to the application API finished
     */
    onAppChangesCompletion$() {
        const methods = ['POST', 'PUT', 'DELETE'];
        return this.apiService.calls.pipe(filter(({ method, url }) => methods.includes(method) && url?.includes('application/applications')), map(({ phase }) => (phase === 'start' ? 1 : -1)), scan((count, item) => count + item, 0), map(count => count === 0), distinctUntilChanged(), debounceTime(500), filter(completed => !!completed), map(() => {
            return;
        }));
    }
    async loadDefaultOptions() {
        this.state.supportUrl = await this.options.getSupportUrl();
        this.state.activateSupportUserAvailable = await this.options.getActivateSupportUser();
        this.state.versions.backend = await this.options.getSystemOption('system', 'version');
        try {
            this.showIncompatibleVersionsError();
        }
        catch (ex) {
            // ignore this
        }
        this.emitNewState();
    }
    showIncompatibleVersionsError() {
        if (this.options.noVersionWarning) {
            return;
        }
        const uiVersion = this.state.versions.ui.ngx;
        const backendVersion = this.state.versions.backend;
        if (!satisfies(uiVersion, `<=${backendVersion} || ~${backendVersion}`)) {
            const errorContent = `You are running version ${uiVersion} of the UI and version ${backendVersion} of backend!`;
            console.log('%c ' + errorContent, 'font-weight: bold; font-size: 30px; color: red;');
        }
    }
}
AppStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: AppStateService, deps: [{ token: i1.ApplicationService }, { token: i2.ApiService }, { token: i3.OptionsService }, { token: i1.FetchClient }, { token: i1.TenantLoginOptionsService }], target: i0.ɵɵFactoryTarget.Injectable });
AppStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: AppStateService, providedIn: 'root' });
__decorate([
    throttle(600, { trailing: false }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AppStateService.prototype, "refreshLoginOptions", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: AppStateService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1.ApplicationService }, { type: i2.ApiService }, { type: i3.OptionsService }, { type: i1.FetchClient }, { type: i1.TenantLoginOptionsService }]; }, propDecorators: { refreshLoginOptions: [] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidWktc3RhdGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2NvcmUvY29tbW9uL3VpLXN0YXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFDTCxXQUFXLEVBRVgseUJBQXlCLEVBQ3pCLGtCQUFrQixFQUduQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNsRSxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLE1BQU0sRUFDTixHQUFHLEVBQ0gsSUFBSSxFQUNKLFNBQVMsRUFDVCxXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksRUFDWixJQUFJLEVBQ0wsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUVyRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDaEQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLFFBQVEsQ0FBQzs7Ozs7QUFHbkMsTUFBTSxPQUFPLGVBQWdCLFNBQVEsWUFBWTtJQXFDL0MsWUFDVSxrQkFBc0MsRUFDdkMsVUFBc0IsRUFDckIsT0FBdUIsRUFDdkIsV0FBd0IsRUFDeEIseUJBQW9EO1FBRTVELEtBQUssRUFBRSxDQUFDO1FBTkEsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN2QyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3JCLFlBQU8sR0FBUCxPQUFP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QWMsR0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUM7UUFFM0QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLEVBQUUsS0FBSyxjQUFjLFFBQVEsY0FBYyxFQUFFLENBQUMsRUFBRTtZQUN0RSxNQUFNLFlBQVksR0FBRywyQkFBMkIsU0FBUywwQkFBMEIsY0FBYyxjQUFjLENBQUM7WUFDaEgsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsWUFBWSxFQUFFLGlEQUFpRCxDQUFDLENBQUM7U0FDdEY7SUFDSCxDQUFDOzs0R0EzT1UsZUFBZTtnSEFBZixlQUFlLGNBREYsTUFBTTtBQWtJOUI7SUFEQyxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxDQUFDOzs7OzBEQUlsQzsyRkFwSVUsZUFBZTtrQkFEM0IsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7aU9Ba0kxQixtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEZldGNoQ2xpZW50LFxuICBJQXBwbGljYXRpb24sXG4gIFRlbmFudExvZ2luT3B0aW9uc1NlcnZpY2UsXG4gIEFwcGxpY2F0aW9uU2VydmljZSxcbiAgSUN1cnJlbnRUZW5hbnQsXG4gIElVc2VyXG59IGZyb20gJ0BjOHkvY2xpZW50JztcbmltcG9ydCB7IGtleXMsIGdldCB9IGZyb20gJ2xvZGFzaC1lcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGRpc3RpbmN0VW50aWxDaGFuZ2VkLFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgc2NhbixcbiAgc3dpdGNoTWFwLFxuICBzaGFyZVJlcGxheSxcbiAgc3RhcnRXaXRoLFxuICBkZWJvdW5jZVRpbWUsXG4gIHRha2Vcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgT3B0aW9uc1NlcnZpY2UgfSBmcm9tICcuL29wdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBTdGF0ZVNlcnZpY2UgfSBmcm9tICcuL3N0YXRlLXNlcnZpY2UuYWJzdHJhY3QnO1xuaW1wb3J0IHsgQXBpU2VydmljZSB9IGZyb20gJ0BjOHkvbmd4LWNvbXBvbmVudHMvYXBpJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uT3B0aW9ucyB9IGZyb20gJy4vQXBwbGljYXRpb25PcHRpb25zJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnLi90aHJvdHRsZS5kZWNvcmF0b3InO1xuaW1wb3J0IHsgc2F0aXNmaWVzIH0gZnJvbSAnc2VtdmVyJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBBcHBTdGF0ZVNlcnZpY2UgZXh0ZW5kcyBTdGF0ZVNlcnZpY2Uge1xuICBzdGF0ZSQ6IEJlaGF2aW9yU3ViamVjdDxhbnk+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnk+KHtcbiAgICBhcHA6IHtcbiAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5uYW1lLFxuICAgICAgY29udGV4dFBhdGg6IHRoaXMuZ2V0Q3VycmVudENvbnRleHRQYXRoKCkgfHwgdGhpcy5vcHRpb25zLmNvbnRleHRQYXRoXG4gICAgfSxcbiAgICBzdXBwb3J0VXJsOiB0aGlzLm9wdGlvbnMuc3VwcG9ydFVybCxcbiAgICBsYW5nOiB0aGlzLm9wdGlvbnMuZ2V0KCdkZWZhdWx0TGFuZ3VhZ2UnLCAnZW4nKSxcbiAgICBsYW5nczogdGhpcy5nZXRMYW5ncygpLFxuICAgIGxhbmdzRGV0YWlsOiB0aGlzLm9wdGlvbnMubGFuZ3VhZ2VzLFxuICAgIGxvZ2luT3B0aW9uczogdGhpcy5vcHRpb25zLmxvZ2luT3B0aW9ucyxcbiAgICBhY3RpdmF0ZVN1cHBvcnRVc2VyQXZhaWxhYmxlOiB1bmRlZmluZWQsXG4gICAgdmVyc2lvbnM6IHtcbiAgICAgIGJhY2tlbmQ6IHVuZGVmaW5lZCxcbiAgICAgIHVpOiB0aGlzLm9wdGlvbnMudmVyc2lvbnMgfHwgeyBuZ3g6IHVuZGVmaW5lZCB9XG4gICAgfSxcbiAgICBoaWRlUG93ZXJlZDogdGhpcy5vcHRpb25zLmhpZGVQb3dlcmVkLFxuICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgc2hvd1JpZ2h0RHJhd2VyOiB0aGlzLm9wdGlvbnMucmlnaHREcmF3ZXIsXG4gICAgbG9naW5FeHRyYUxpbms6IHRoaXMub3B0aW9ucy5nZXQoJ2xvZ2luX2V4dHJhX2xpbmsnKSxcbiAgICBuZXdzbGV0dGVyOiB0aGlzLm9wdGlvbnMubmV3c2xldHRlclxuICB9KTtcbiAgY3VycmVudFN1cHBvcnRVc2VyTmFtZTogQmVoYXZpb3JTdWJqZWN0PHN0cmluZyB8IG51bGw+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgY3VycmVudFVzZXI6IEJlaGF2aW9yU3ViamVjdDxJVXNlciB8IG51bGw+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChudWxsKTtcbiAgY3VycmVudFRlbmFudDogQmVoYXZpb3JTdWJqZWN0PElDdXJyZW50VGVuYW50IHwgbnVsbD4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICBjdXJyZW50QXBwbGljYXRpb246IEJlaGF2aW9yU3ViamVjdDxJQXBwbGljYXRpb24gfCBudWxsPiA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gIGN1cnJlbnRBcHBsaWNhdGlvbkNvbmZpZzogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5jdXJyZW50QXBwbGljYXRpb24ucGlwZShcbiAgICBmaWx0ZXIoYXBwID0+ICEhYXBwKSxcbiAgICBtYXAoYXBwID0+IGFwcD8uY29uZmlnIHx8IG51bGwpXG4gICk7XG4gIC8qKlxuICAgKiBBbiBPYnNlcnZhYmxlIG9mIHRoZSBhcHBsaWNhdGlvbnMgYXZhaWxhYmxlIGZvciB0aGUgY3VycmVudCB1c2VyLlxuICAgKiBUaGUgT2JzZXJ2YWJsZSBlbWl0cyBhIG5ldyBhcnJheSBvbiB1c2VyIGNoYW5nZXMgb3IgaWYgdGhlIGFwcGxpY2F0aW9uXG4gICAqIHBlcmZvcm1zIFBPU1QsIFBVVCBvciBERUxFVEUgcmVxdWVzdHMgdG8gdGhlIGFwcGxpY2F0aW9uIEFQSS5cbiAgICovXG4gIGN1cnJlbnRBcHBzT2ZVc2VyOiBPYnNlcnZhYmxlPElBcHBsaWNhdGlvbltdPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGFwcGxpY2F0aW9uU2VydmljZTogQXBwbGljYXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBhcGlTZXJ2aWNlOiBBcGlTZXJ2aWNlLFxuICAgIHByaXZhdGUgb3B0aW9uczogT3B0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBmZXRjaENsaWVudDogRmV0Y2hDbGllbnQsXG4gICAgcHJpdmF0ZSB0ZW5hbnRMb2dpbk9wdGlvbnNTZXJ2aWNlOiBUZW5hbnRMb2dpbk9wdGlvbnNTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hcGlTZXJ2aWNlLmNhbGxzXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKCh7IHVybCB9KSA9PiAhL25vdGlmaWNhdGlvblxcL3JlYWx0aW1lLy50ZXN0KHVybCkpLFxuICAgICAgICBtYXAoKHsgcGhhc2UgfSkgPT4gKHBoYXNlID09PSAnc3RhcnQnID8gMSA6IC0xKSksXG4gICAgICAgIHNjYW4oKGNvdW50LCBpdGVtKSA9PiBjb3VudCArIGl0ZW0sIDApLFxuICAgICAgICBtYXAoY291bnQgPT4gY291bnQgPiAwKSxcbiAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShpc0xvYWRpbmcgPT4gKHRoaXMuc3RhdGUuaXNMb2FkaW5nID0gaXNMb2FkaW5nKSk7XG5cbiAgICB0aGlzLmFzc2lnbkFwcGxpY2F0aW9uS2V5VG9EZWZhdWx0SGVhZGVycygpO1xuICAgIHRoaXMuY3VycmVudEFwcHNPZlVzZXIgPSB0aGlzLmN1cnJlbnRBcHBzT2ZVc2VyJCgpO1xuICB9XG5cbiAgYXNzaWduQXBwbGljYXRpb25LZXlUb0RlZmF1bHRIZWFkZXJzKCkge1xuICAgIGlmICghaXNEZXZNb2RlKCkpIHtcbiAgICAgIHRoaXMuZmV0Y2hDbGllbnQuZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgIC4uLih0aGlzLmZldGNoQ2xpZW50LmRlZmF1bHRIZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgJ1gtQ3VtdWxvY2l0eS1BcHBsaWNhdGlvbi1LZXknOiB0aGlzLm9wdGlvbnMua2V5XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlJC52YWx1ZTtcbiAgfVxuXG4gIGdldExhbmdzKCkge1xuICAgIGNvbnN0IHsgbGFuZ3VhZ2VzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIGxhbmd1YWdlcyA/IGtleXMobGFuZ3VhZ2VzKS5maWx0ZXIoayA9PiBsYW5ndWFnZXNba10pIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29ycmVjdCBVSSB2ZXJzaW9uLiBJbiBoeWJyaWQgbW9kZSBmb3IgYW5ndWxhciBhbmQgbmd4LlxuICAgKi9cbiAgZ2V0IHVpVmVyc2lvbigpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdGhpcy5zdGF0ZS52ZXJzaW9ucy51aTtcbiAgICByZXR1cm4gdmVyc2lvbi5uZ3ggfHwgdmVyc2lvbi5uZzE7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIGFwcCBtYW5pZmVzdC4gSWYgbm8gYWNjZXNzIC0+IHRocm93IGFuIGVycm9yIHRvIHZlcmlmeSBhcHAgYWNjZXNzLlxuICAgKi9cbiAgYXN5bmMgbG9hZE1hbmlmZXN0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IGFwcGxpY2F0aW9uIH0gPSBhd2FpdCB0aGlzLmFwcGxpY2F0aW9uU2VydmljZS5nZXRNYW5pZmVzdE9mQ29udGV4dFBhdGgoXG4gICAgICAgIHRoaXMuc3RhdGUuYXBwLmNvbnRleHRQYXRoXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0ZS5hcHAubWFuaWZlc3QgPSBhcHBsaWNhdGlvbjtcbiAgICAgIHRoaXMuc3RhdGUuYXBwLmlkID0gYXBwbGljYXRpb24uaWQ7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb25TZXJ2aWNlLmRldGFpbChhcHBsaWNhdGlvbi5pZCk7XG4gICAgICB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbi5uZXh0KGRhdGEpO1xuICAgICAgYXdhaXQgdGhpcy5sb2FkRGVmYXVsdE9wdGlvbnMoKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgdGhpcy5jdXJyZW50QXBwbGljYXRpb24ubmV4dCh7fSk7XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHluYW1pYyBvcHRpb25zIGFyZSBzdG9yZWQgb24gdGhlIEFQSSBpbiBhIHNwZWNpZmljIGNvbmZpZzoge30gb2JqZWN0LiBUaGV5IGNhblxuICAgKiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgYXBwIGR5bmFtaWNhbGx5LlxuICAgKlxuICAgKiBOb3RlOiBUbyBhdm9pZHMgY29uZmxpY3RzIHdpdGggdGhlIGRlZmF1bHQgQ29uZmlnLCBpdCBpcyByZWNvbW1lbmRlZFxuICAgKiB0byB1c2UgYSBjZXJ0YWluIG5hbWVzcGFjZS5cbiAgICovXG4gIGFzeW5jIHVwZGF0ZUN1cnJlbnRBcHBsaWNhdGlvbkNvbmZpZzxUID0gQXBwbGljYXRpb25PcHRpb25zPihjb25maWc6IFQpOiBQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBhcHBXaXRoVXBkYXRlZENvbmZpZyA9IGF3YWl0IHRoaXMuYXBwbGljYXRpb25TZXJ2aWNlLnVwZGF0ZUFwcGxpY2F0aW9uQ29uZmlnKFxuICAgICAgdGhpcy5zdGF0ZS5hcHAuaWQsXG4gICAgICBjb25maWdcbiAgICApO1xuICAgIHRoaXMuY3VycmVudEFwcGxpY2F0aW9uLm5leHQoYXBwV2l0aFVwZGF0ZWRDb25maWcpO1xuICAgIHJldHVybiBhcHBXaXRoVXBkYXRlZENvbmZpZy5jb25maWc7XG4gIH1cblxuICAvKipcbiAgICogV2hlbiB0aGlzIGZ1bmN0aW9uIGNhbGxlZCwgaXQgcmVmcmVzaGVzIHRoZSB2YWx1ZXMgb2YgbG9naW5PcHRpb25zIHN0b3JlZCB3aXRoaW4gdWkgc3RhdGUgb2JqZWN0LlxuICAgKiBGdW5jdGlvbiBpcyB0aHJvdHRsZWQgdG8gZXhlY3V0ZSB0aGUgcmVmcmVzaCBvbmNlIGluIGEgdGltZSBzcGVjaWZpZWQgYnkgcGFyYW1zIG9mIEB0aHJvdHRsZWQgZGVjb3JhdG9yLFxuICAgKiBpdCBzaG91bGQgYmUgY2FsbGVkIG9uIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICovXG4gIEB0aHJvdHRsZSg2MDAsIHsgdHJhaWxpbmc6IGZhbHNlIH0pXG4gIGFzeW5jIHJlZnJlc2hMb2dpbk9wdGlvbnMoKSB7XG4gICAgY29uc3QgbG9naW5PcHRpb25zID0gKGF3YWl0IHRoaXMudGVuYW50TG9naW5PcHRpb25zU2VydmljZS5saXN0Rm9yQ3VycmVudFRlbmFudCgpKS5kYXRhO1xuICAgIHRoaXMuc3RhdGUkLm5leHQoeyAuLi50aGlzLnN0YXRlLCBsb2dpbk9wdGlvbnMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGN1cnJlbnQgdXNlcnMgYXBwbGljYXRpb24gbGlzdCBhbmQgbWF0Y2hlcyBpdCBhZ2FpbnN0IGdpdmVuIGFwcGxpY2F0aW9uIG5hbWUuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhcHBsaWNhdGlvbiBpcyBpbiB0aGUgbGlzdC5cbiAgICogQHBhcmFtIG5hbWUgYXBwbGljYXRpb24gbmFtZVxuICAgKi9cbiAgYXN5bmMgaXNBcHBsaWNhdGlvbkF2YWlsYWJsZShuYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhcHBzID0gYXdhaXQgdGhpcy5jdXJyZW50QXBwc09mVXNlci5waXBlKHRha2UoMSkpLnRvUHJvbWlzZSgpO1xuICAgIHJldHVybiBhcHBzLnNvbWUoYXBwID0+IGFwcC5uYW1lID09PSBuYW1lIHx8IGFwcC5jb250ZXh0UGF0aCA9PT0gbmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBjdXJyZW50IHVzZXIgKGluY2x1ZGluZyBzdXBwb3J0IHVzZXIpLlxuICAgKiBAcGFyYW0gdXNlckluZm8gSW5mbyBhYm91dCBjdXJyZW50IHVzZXIgYW5kIHN1cHBvcnQgdXNlciB0byBiZSBzZXQuXG4gICAqL1xuICBzZXRVc2VyKHVzZXJJbmZvOiB7IHVzZXI6IElVc2VyOyBzdXBwb3J0VXNlck5hbWU6IHN0cmluZyB9KSB7XG4gICAgdGhpcy5jdXJyZW50U3VwcG9ydFVzZXJOYW1lLm5leHQodXNlckluZm8uc3VwcG9ydFVzZXJOYW1lIHx8IG51bGwpO1xuICAgIHRoaXMuY3VycmVudFVzZXIubmV4dCh1c2VySW5mby51c2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiB0aGUgY3VycmVudCBhcHBsaWNhdGlvbiBpcyBvd25lZCBieSB0aGUgY3VycmVudCB0ZW5hbnQuXG4gICAqIEBwYXJhbSBhcHAgVGhlIGFwcGxpY2F0aW9uIHRvIHZlcmlmeS5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiBpdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IHRlbmFudC5cbiAgICovXG4gIGlzT3duZXJPZkFwcGxpY2F0aW9uKGFwcD86IElBcHBsaWNhdGlvbik6IGJvb2xlYW4ge1xuICAgIGlmICghYXBwKSB7XG4gICAgICBhcHAgPSB0aGlzLmN1cnJlbnRBcHBsaWNhdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRlbmFudDogSUN1cnJlbnRUZW5hbnQgPSB0aGlzLmN1cnJlbnRUZW5hbnQudmFsdWU7XG4gICAgY29uc3QgYXBwT3duZXIgPSBnZXQoYXBwLCAnb3duZXIudGVuYW50LmlkJyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUZW5hbnQubmFtZSA9PT0gYXBwT3duZXI7XG4gIH1cblxuICBnZXRDdXJyZW50Q29udGV4dFBhdGgoKSB7XG4gICAgY29uc3QgbWF0Y2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubWF0Y2goL1xcL2FwcHNcXC8ocHVibGljXFwvKXswLDF9KC4rPykoXFwvfFxcP3wjfCQpLyk7XG4gICAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzJdO1xuICB9XG5cbiAgcHJvdGVjdGVkIGN1cnJlbnRBcHBzT2ZVc2VyJCgpOiBPYnNlcnZhYmxlPElBcHBsaWNhdGlvbltdPiB7XG4gICAgY29uc3QgYXBwQ2hhbmdlcyQgPSB0aGlzLm9uQXBwQ2hhbmdlc0NvbXBsZXRpb24kKCkucGlwZShzdGFydFdpdGgodW5kZWZpbmVkIGFzIHZvaWQpKTtcbiAgICBjb25zdCB1c2VyQ2hhbmdlcyQgPSB0aGlzLmN1cnJlbnRVc2VyLnBpcGUoXG4gICAgICBtYXAodXNlciA9PiB1c2VyPy5pZCksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgKTtcbiAgICByZXR1cm4gY29tYmluZUxhdGVzdChbdXNlckNoYW5nZXMkLCBhcHBDaGFuZ2VzJF0pLnBpcGUoXG4gICAgICBmaWx0ZXIoKFt1c2VySWRdKSA9PiAhIXVzZXJJZCksXG4gICAgICBzd2l0Y2hNYXAoKFt1c2VySWRdKSA9PlxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU2VydmljZS5saXN0QnlVc2VyKHVzZXJJZCwge1xuICAgICAgICAgIGRyb3BPdmVyd3JpdHRlbkFwcHM6IHRydWUsXG4gICAgICAgICAgbm9QYWdpbmc6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICBtYXAoKHsgZGF0YSB9KSA9PiBkYXRhKSxcbiAgICAgIHNoYXJlUmVwbGF5KHsgYnVmZmVyU2l6ZTogMSwgcmVmQ291bnQ6IHRydWUgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgZW1pdHRpbmcgb25jZSBhbGwgUE9TVCwgUFVULCBERUxFVEUgcmVxdWVzdHMgdG8gdGhlIGFwcGxpY2F0aW9uIEFQSSBmaW5pc2hlZFxuICAgKi9cbiAgcHJvdGVjdGVkIG9uQXBwQ2hhbmdlc0NvbXBsZXRpb24kKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbJ1BPU1QnLCAnUFVUJywgJ0RFTEVURSddO1xuICAgIHJldHVybiB0aGlzLmFwaVNlcnZpY2UuY2FsbHMucGlwZShcbiAgICAgIGZpbHRlcihcbiAgICAgICAgKHsgbWV0aG9kLCB1cmwgfSkgPT4gbWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpICYmIHVybD8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2FwcGxpY2F0aW9ucycpXG4gICAgICApLFxuICAgICAgbWFwKCh7IHBoYXNlIH0pID0+IChwaGFzZSA9PT0gJ3N0YXJ0JyA/IDEgOiAtMSkpLFxuICAgICAgc2NhbigoY291bnQsIGl0ZW0pID0+IGNvdW50ICsgaXRlbSwgMCksXG4gICAgICBtYXAoY291bnQgPT4gY291bnQgPT09IDApLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIGRlYm91bmNlVGltZSg1MDApLFxuICAgICAgZmlsdGVyKGNvbXBsZXRlZCA9PiAhIWNvbXBsZXRlZCksXG4gICAgICBtYXAoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWREZWZhdWx0T3B0aW9ucygpIHtcbiAgICB0aGlzLnN0YXRlLnN1cHBvcnRVcmwgPSBhd2FpdCB0aGlzLm9wdGlvbnMuZ2V0U3VwcG9ydFVybCgpO1xuICAgIHRoaXMuc3RhdGUuYWN0aXZhdGVTdXBwb3J0VXNlckF2YWlsYWJsZSA9IGF3YWl0IHRoaXMub3B0aW9ucy5nZXRBY3RpdmF0ZVN1cHBvcnRVc2VyKCk7XG4gICAgdGhpcy5zdGF0ZS52ZXJzaW9ucy5iYWNrZW5kID0gYXdhaXQgdGhpcy5vcHRpb25zLmdldFN5c3RlbU9wdGlvbignc3lzdGVtJywgJ3ZlcnNpb24nKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5zaG93SW5jb21wYXRpYmxlVmVyc2lvbnNFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAvLyBpZ25vcmUgdGhpc1xuICAgIH1cbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG93SW5jb21wYXRpYmxlVmVyc2lvbnNFcnJvcigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm5vVmVyc2lvbldhcm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdWlWZXJzaW9uOiBzdHJpbmcgPSB0aGlzLnN0YXRlLnZlcnNpb25zLnVpLm5neDtcbiAgICBjb25zdCBiYWNrZW5kVmVyc2lvbjogc3RyaW5nID0gdGhpcy5zdGF0ZS52ZXJzaW9ucy5iYWNrZW5kO1xuXG4gICAgaWYgKCFzYXRpc2ZpZXModWlWZXJzaW9uLCBgPD0ke2JhY2tlbmRWZXJzaW9ufSB8fCB+JHtiYWNrZW5kVmVyc2lvbn1gKSkge1xuICAgICAgY29uc3QgZXJyb3JDb250ZW50ID0gYFlvdSBhcmUgcnVubmluZyB2ZXJzaW9uICR7dWlWZXJzaW9ufSBvZiB0aGUgVUkgYW5kIHZlcnNpb24gJHtiYWNrZW5kVmVyc2lvbn0gb2YgYmFja2VuZCFgO1xuICAgICAgY29uc29sZS5sb2coJyVjICcgKyBlcnJvckNvbnRlbnQsICdmb250LXdlaWdodDogYm9sZDsgZm9udC1zaXplOiAzMHB4OyBjb2xvcjogcmVkOycpO1xuICAgIH1cbiAgfVxufVxuIl19