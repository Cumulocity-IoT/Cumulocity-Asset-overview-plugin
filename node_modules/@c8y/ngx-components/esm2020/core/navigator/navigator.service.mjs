import { Injectable, InjectionToken, Injector } from '@angular/core';
import { Router } from '@angular/router';
import { distinctUntilChanged, map, shareReplay } from 'rxjs/operators';
import { fromTriggerOnce, hookGeneric, getInjectedHooks, sortByPriority, stateToFactory, ExtensionPointForPlugins } from '../common/extension-hooks';
import { PluginsResolveService } from '../plugins/plugins-resolve.service';
import { NavigatorNodeRoot } from './navigator-node-root';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "../plugins/plugins-resolve.service";
/**
 * A hook to use for Multi Provider extension.
 * @deprecated Consider using the `hookNavigator` function instead.
 */
export const HOOK_NAVIGATOR_NODES = new InjectionToken('HOOK_NAVIGATOR_NODES');
/**
 * You can either provide a single `NavigatorNode` or `NavigatorNodeData` as parameter:
 * ```typescript
 *  hookNavigator(...)
 * ```
 *
 * Or an array to directly register multiple:
 * ```typescript
 *  hookNavigator([...])
 * ```
 *
 * Or you provide an Service that implements `ExtensionFactory<NavigatorNode | NavigatorNodeData>`
 * ```typescript
 *  export class MyNavigatorFactory implements ExtensionFactory<NavigatorNode | NavigatorNodeData> {...}
 *  ...
 *  hookNavigator(MyNavigatorFactory)
 * ```
 * A typed alternative to `HOOK_NAVIGATOR_NODES`.
 * @param nodes The `NavigatorNode`'s, `NavigatorNodeData`'s or `ExtensionFactory` to be provided.
 * @returns An `Provider` to be provided in your module.
 */
export function hookNavigator(nodes, options) {
    return hookGeneric(nodes, HOOK_NAVIGATOR_NODES, options);
}
/**
 * A service which defines the navigator.
 */
export class NavigatorService extends ExtensionPointForPlugins {
    constructor(rootInjector, router, plugins) {
        super(rootInjector, plugins);
        this.router = router;
        /**
         * Indicates whether the menu entry associated with the given URL should be expanded.
         */
        this.firstUrl = true;
        this.items$ = this.setupItemsObservable();
        this.hasItemsInNavigator$ = this.items$.pipe(map(({ length }) => !!length), distinctUntilChanged());
    }
    /**
     * Checks whenever a navigator entry associated with the given URL should be expanded.
     * @param {NavigatorNode} node Navigator node.
     */
    openOnFirstUrl(node) {
        if (this.firstUrl && !!node.path) {
            return (this.router.isActive(node.path, node.routerLinkExact) || node.openOnStart(this.router.url));
        }
        return false;
    }
    /**
     * Returns the current state.
     * @readonly
     * @returns The current set of actions.
     */
    get state() {
        return this.state$.value;
    }
    /**
     * Adds a new node to the navigator.
     * @param {NavigatorNode} node Navigator node to add.
     */
    add(node) {
        this.state.add(node);
        this.emitNewState();
    }
    /**
     * Removes a node from the navigator.
     * @param {NavigatorNode} node Navigator node to remove.
     */
    remove(node) {
        this.state.delete(node);
        this.emitNewState();
    }
    setupItemsObservable() {
        const rootNode = new NavigatorNodeRoot();
        return fromTriggerOnce(this.router, this.refresh$, [
            getInjectedHooks(HOOK_NAVIGATOR_NODES, this.injectors),
            () => this.factories,
            stateToFactory(this.state$)
        ]).pipe(distinctUntilChanged(), map((nodes) => {
            const noParent = nodes.filter(node => !node.parent);
            const withParent = nodes.filter(node => node.parent);
            // Based on the sortedNodes array, the nodes are sequentially created.
            // Nodes sorting is done in two steps to have the top-level nodes first.
            // This way, by the time we are adding a child node, the parent node is already present.
            const sortedNodes = sortByPriority(noParent).concat(sortByPriority(withParent));
            rootNode.empty();
            sortedNodes.forEach(node => rootNode.addRoot(node));
            return rootNode.children;
        }), shareReplay(1));
    }
}
NavigatorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: NavigatorService, deps: [{ token: i0.Injector }, { token: i1.Router }, { token: i2.PluginsResolveService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigatorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: NavigatorService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: NavigatorService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i1.Router }, { type: i2.PluginsResolveService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdG9yLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL25hdmlnYXRvci9uYXZpZ2F0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUVMLGVBQWUsRUFFZixXQUFXLEVBQ1gsZ0JBQWdCLEVBQ2hCLGNBQWMsRUFDZCxjQUFjLEVBQ2Qsd0JBQXdCLEVBRXpCLE1BQU0sMkJBQTJCLENBQUM7QUFDbkMsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFHM0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7QUFzQjFEOzs7R0FHRztBQUNILE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUNwRCxzQkFBc0IsQ0FDdkIsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CRztBQUNILE1BQU0sVUFBVSxhQUFhLENBQzNCLEtBQXlELEVBQ3pELE9BQThCO0lBRTlCLE9BQU8sV0FBVyxDQUFvQyxLQUFLLEVBQUUsb0JBQW9CLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDOUYsQ0FBQztBQUVEOztHQUVHO0FBSUgsTUFBTSxPQUFPLGdCQUFpQixTQUFRLHdCQUF1QztJQU8zRSxZQUFZLFlBQXNCLEVBQVUsTUFBYyxFQUFFLE9BQThCO1FBQ3hGLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFEYSxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBTjFEOztXQUVHO1FBQ0gsYUFBUSxH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YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBFeHRlbnNpb25GYWN0b3J5LFxuICBmcm9tVHJpZ2dlck9uY2UsXG4gIEdlbmVyaWNIb29rVHlwZSxcbiAgaG9va0dlbmVyaWMsXG4gIGdldEluamVjdGVkSG9va3MsXG4gIHNvcnRCeVByaW9yaXR5LFxuICBzdGF0ZVRvRmFjdG9yeSxcbiAgRXh0ZW5zaW9uUG9pbnRGb3JQbHVnaW5zLFxuICBIb29rT3B0aW9uc1xufSBmcm9tICcuLi9jb21tb24vZXh0ZW5zaW9uLWhvb2tzJztcbmltcG9ydCB7IFBsdWdpbnNSZXNvbHZlU2VydmljZSB9IGZyb20gJy4uL3BsdWdpbnMvcGx1Z2lucy1yZXNvbHZlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZSB9IGZyb20gJy4vbmF2aWdhdG9yLW5vZGUnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZURhdGEgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlLWRhdGEnO1xuaW1wb3J0IHsgTmF2aWdhdG9yTm9kZVJvb3QgfSBmcm9tICcuL25hdmlnYXRvci1ub2RlLXJvb3QnO1xuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBIT09LIGNhbiB1c2UgZWl0aGVyIGEgcHVyZSB2YWx1ZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICB7IHByb3ZpZGU6IEhPT0tfWCwgdXNlVmFsdWU6IHsgLi4uaG9va1ZhbHVlIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIHsgcHJvdmlkZTogSE9PS19YLCB1c2VWYWx1ZTogW3sgLi4uaG9va1ZhbHVlcyB9XSwgbXVsdGk6IHRydWUgfVxuICogYGBgXG4gKlxuICogT3IgYW4gRXh0ZW5zaW9uRmFjdG9yeSB3aGljaCBhbGxvd3MgdG8gZGVmaW5lIGEgZ2V0KCkgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb25cbiAqIGdldHMgY2FsbGVkIG9uIGVhY2ggbmF2aWdhdGlvbiB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGFuZCBjYW4gcmV0dXJuIHZhbHVlc1xuICogYXN5bmMgKG9ic2VydmFibGUgb3IgcHJvbWlzZSkuXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgeyBwcm92aWRlOiBIT09LX1gsIHVzZUZhY3Rvcnk6IHsgZ2V0OiAocm91dGUpID0+IGRvU29tZXRoaW5nQXN5bmMocm91dGUpIH0sIG11bHRpOiB0cnVlIH1cbiAqIGBgYFxuICovXG50eXBlIE5hdmlnYXRvckV4dGVuc2lvbiA9IE5hdmlnYXRvck5vZGUgfCBOYXZpZ2F0b3JOb2RlW10gfCBFeHRlbnNpb25GYWN0b3J5PE5hdmlnYXRvck5vZGU+O1xuXG4vKipcbiAqIEEgaG9vayB0byB1c2UgZm9yIE11bHRpIFByb3ZpZGVyIGV4dGVuc2lvbi5cbiAqIEBkZXByZWNhdGVkIENvbnNpZGVyIHVzaW5nIHRoZSBgaG9va05hdmlnYXRvcmAgZnVuY3Rpb24gaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGNvbnN0IEhPT0tfTkFWSUdBVE9SX05PREVTID0gbmV3IEluamVjdGlvblRva2VuPE5hdmlnYXRvckV4dGVuc2lvbltdPihcbiAgJ0hPT0tfTkFWSUdBVE9SX05PREVTJ1xuKTtcblxuLyoqXG4gKiBZb3UgY2FuIGVpdGhlciBwcm92aWRlIGEgc2luZ2xlIGBOYXZpZ2F0b3JOb2RlYCBvciBgTmF2aWdhdG9yTm9kZURhdGFgIGFzIHBhcmFtZXRlcjpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBob29rTmF2aWdhdG9yKC4uLilcbiAqIGBgYFxuICpcbiAqIE9yIGFuIGFycmF5IHRvIGRpcmVjdGx5IHJlZ2lzdGVyIG11bHRpcGxlOlxuICogYGBgdHlwZXNjcmlwdFxuICogIGhvb2tOYXZpZ2F0b3IoWy4uLl0pXG4gKiBgYGBcbiAqXG4gKiBPciB5b3UgcHJvdmlkZSBhbiBTZXJ2aWNlIHRoYXQgaW1wbGVtZW50cyBgRXh0ZW5zaW9uRmFjdG9yeTxOYXZpZ2F0b3JOb2RlIHwgTmF2aWdhdG9yTm9kZURhdGE+YFxuICogYGBgdHlwZXNjcmlwdFxuICogIGV4cG9ydCBjbGFzcyBNeU5hdmlnYXRvckZhY3RvcnkgaW1wbGVtZW50cyBFeHRlbnNpb25GYWN0b3J5PE5hdmlnYXRvck5vZGUgfCBOYXZpZ2F0b3JOb2RlRGF0YT4gey4uLn1cbiAqICAuLi5cbiAqICBob29rTmF2aWdhdG9yKE15TmF2aWdhdG9yRmFjdG9yeSlcbiAqIGBgYFxuICogQSB0eXBlZCBhbHRlcm5hdGl2ZSB0byBgSE9PS19OQVZJR0FUT1JfTk9ERVNgLlxuICogQHBhcmFtIG5vZGVzIFRoZSBgTmF2aWdhdG9yTm9kZWAncywgYE5hdmlnYXRvck5vZGVEYXRhYCdzIG9yIGBFeHRlbnNpb25GYWN0b3J5YCB0byBiZSBwcm92aWRlZC5cbiAqIEByZXR1cm5zIEFuIGBQcm92aWRlcmAgdG8gYmUgcHJvdmlkZWQgaW4geW91ciBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBob29rTmF2aWdhdG9yKFxuICBub2RlczogR2VuZXJpY0hvb2tUeXBlPE5hdmlnYXRvck5vZGUgfCBOYXZpZ2F0b3JOb2RlRGF0YT4sXG4gIG9wdGlvbnM/OiBQYXJ0aWFsPEhvb2tPcHRpb25zPlxuKSB7XG4gIHJldHVybiBob29rR2VuZXJpYzxOYXZpZ2F0b3JOb2RlIHwgTmF2aWdhdG9yTm9kZURhdGE+KG5vZGVzLCBIT09LX05BVklHQVRPUl9OT0RFUywgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHdoaWNoIGRlZmluZXMgdGhlIG5hdmlnYXRvci5cbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yU2VydmljZSBleHRlbmRzIEV4dGVuc2lvblBvaW50Rm9yUGx1Z2luczxOYXZpZ2F0b3JOb2RlPiB7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgbWVudSBlbnRyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgZXhwYW5kZWQuXG4gICAqL1xuICBmaXJzdFVybCA9IHRydWU7XG4gIGhhc0l0ZW1zSW5OYXZpZ2F0b3IkOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG4gIGNvbnN0cnVjdG9yKHJvb3RJbmplY3RvcjogSW5qZWN0b3IsIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIsIHBsdWdpbnM6IFBsdWdpbnNSZXNvbHZlU2VydmljZSkge1xuICAgIHN1cGVyKHJvb3RJbmplY3RvciwgcGx1Z2lucyk7XG4gICAgdGhpcy5pdGVtcyQgPSB0aGlzLnNldHVwSXRlbXNPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5oYXNJdGVtc0luTmF2aWdhdG9yJCA9IHRoaXMuaXRlbXMkLnBpcGUoXG4gICAgICBtYXAoKHsgbGVuZ3RoIH0pID0+ICEhbGVuZ3RoKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGVuZXZlciBhIG5hdmlnYXRvciBlbnRyeSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIFVSTCBzaG91bGQgYmUgZXhwYW5kZWQuXG4gICAqIEBwYXJhbSB7TmF2aWdhdG9yTm9kZX0gbm9kZSBOYXZpZ2F0b3Igbm9kZS5cbiAgICovXG4gIG9wZW5PbkZpcnN0VXJsKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICBpZiAodGhpcy5maXJzdFVybCAmJiAhIW5vZGUucGF0aCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5yb3V0ZXIuaXNBY3RpdmUobm9kZS5wYXRoLCBub2RlLnJvdXRlckxpbmtFeGFjdCkgfHwgbm9kZS5vcGVuT25TdGFydCh0aGlzLnJvdXRlci51cmwpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICogQHJlYWRvbmx5XG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHNldCBvZiBhY3Rpb25zLlxuICAgKi9cbiAgZ2V0IHN0YXRlKCk6IFNldDxOYXZpZ2F0b3JOb2RlPiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUkLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbm9kZSB0byB0aGUgbmF2aWdhdG9yLlxuICAgKiBAcGFyYW0ge05hdmlnYXRvck5vZGV9IG5vZGUgTmF2aWdhdG9yIG5vZGUgdG8gYWRkLlxuICAgKi9cbiAgYWRkKG5vZGU6IE5hdmlnYXRvck5vZGUpIHtcbiAgICB0aGlzLnN0YXRlLmFkZChub2RlKTtcbiAgICB0aGlzLmVtaXROZXdTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIG5hdmlnYXRvci5cbiAgICogQHBhcmFtIHtOYXZpZ2F0b3JOb2RlfSBub2RlIE5hdmlnYXRvciBub2RlIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZShub2RlOiBOYXZpZ2F0b3JOb2RlKSB7XG4gICAgdGhpcy5zdGF0ZS5kZWxldGUobm9kZSk7XG4gICAgdGhpcy5lbWl0TmV3U3RhdGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzZXR1cEl0ZW1zT2JzZXJ2YWJsZSgpOiBPYnNlcnZhYmxlPE5hdmlnYXRvck5vZGVbXT4ge1xuICAgIGNvbnN0IHJvb3ROb2RlID0gbmV3IE5hdmlnYXRvck5vZGVSb290KCk7XG4gICAgcmV0dXJuIGZyb21UcmlnZ2VyT25jZTxOYXZpZ2F0b3JFeHRlbnNpb24+KHRoaXMucm91dGVyLCB0aGlzLnJlZnJlc2gkLCBbXG4gICAgICBnZXRJbmplY3RlZEhvb2tzPE5hdmlnYXRvck5vZGU+KEhPT0tfTkFWSUdBVE9SX05PREVTLCB0aGlzLmluamVjdG9ycyksXG4gICAgICAoKSA9PiB0aGlzLmZhY3RvcmllcyxcbiAgICAgIHN0YXRlVG9GYWN0b3J5KHRoaXMuc3RhdGUkKVxuICAgIF0pLnBpcGUoXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgbWFwKChub2RlczogUGFydGlhbDxOYXZpZ2F0b3JOb2RlRGF0YVtdPikgPT4ge1xuICAgICAgICBjb25zdCBub1BhcmVudCA9IG5vZGVzLmZpbHRlcihub2RlID0+ICFub2RlLnBhcmVudCk7XG4gICAgICAgIGNvbnN0IHdpdGhQYXJlbnQgPSBub2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLnBhcmVudCk7XG5cbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHNvcnRlZE5vZGVzIGFycmF5LCB0aGUgbm9kZXMgYXJlIHNlcXVlbnRpYWxseSBjcmVhdGVkLlxuICAgICAgICAvLyBOb2RlcyBzb3J0aW5nIGlzIGRvbmUgaW4gdHdvIHN0ZXBzIHRvIGhhdmUgdGhlIHRvcC1sZXZlbCBub2RlcyBmaXJzdC5cbiAgICAgICAgLy8gVGhpcyB3YXksIGJ5IHRoZSB0aW1lIHdlIGFyZSBhZGRpbmcgYSBjaGlsZCBub2RlLCB0aGUgcGFyZW50IG5vZGUgaXMgYWxyZWFkeSBwcmVzZW50LlxuICAgICAgICBjb25zdCBzb3J0ZWROb2RlcyA9IHNvcnRCeVByaW9yaXR5KG5vUGFyZW50KS5jb25jYXQoc29ydEJ5UHJpb3JpdHkod2l0aFBhcmVudCkpO1xuICAgICAgICByb290Tm9kZS5lbXB0eSgpO1xuICAgICAgICBzb3J0ZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gcm9vdE5vZGUuYWRkUm9vdChub2RlKSk7XG4gICAgICAgIHJldHVybiByb290Tm9kZS5jaGlsZHJlbjtcbiAgICAgIH0pLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICB9XG59XG4iXX0=