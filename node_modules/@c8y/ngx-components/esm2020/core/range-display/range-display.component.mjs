import { Component, Input, HostBinding } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import * as i0 from "@angular/core";
import * as i1 from "@angular/platform-browser";
import * as i2 from "@angular/common";
import * as i3 from "../i18n/c8y-translate.pipe";
import * as i4 from "../common/date.pipe";
export class RangeDisplayComponent {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.config = {};
        this.display = 'full';
    }
    get inlineStyle() {
        this.config = this.config || {};
        if (!this.config.min) {
            this.config.min = 0;
        }
        if (!this.config.max) {
            this.config.max = 100;
        }
        if (this.config.fractionSize !== undefined) {
            this.config.current = parseFloat(this.config.current.toFixed(this.config.fractionSize));
        }
        return this.sanitizer.bypassSecurityTrustStyle(`
          --range-min: ${this.config.min};
          --range-max: ${this.config.max};
          --full-range: ${this.config.max - this.config.min};
          --measurement-target: ${((this.config.target - this.config.min) * 100) / (this.config.max - this.config.min)}%;
          --measurement-current: ${((this.config.current - this.config.min) * 100) / (this.config.max - this.config.min)}%;
          --range-y-min: ${((this.config.yellowRangeMin - this.config.min) * 100) /
            (this.config.max - this.config.min)}%;
          --range-y-max: ${((this.config.yellowRangeMax - this.config.min) / (this.config.max - this.config.min)) *
            100}%;
          --range-r-min: ${((this.config.redRangeMin - this.config.min) * 100) /
            (this.config.max - this.config.min)}%;
          --range-r-max: ${((this.config.redRangeMax - this.config.min) / (this.config.max - this.config.min)) *
            100}%;
        `);
    }
    checkTarget() {
        return (this.config.target !== undefined &&
            this.config.target !== null &&
            this.config.target >= this.config.min &&
            this.config.target <= this.config.max);
    }
    rulerCalc(index) {
        const num = this.config.min + ((this.config.max - this.config.min) / 10) * index;
        if (this.config.fractionSize !== undefined) {
            return parseFloat(num.toFixed(this.config.fractionSize));
        }
        return parseFloat(num.toFixed(2));
    }
    trackByIndex(index) {
        return index;
    }
    isRedRangeDisplayed() {
        const { redRangeMin, redRangeMax } = this.config;
        return this.isRangeDisplayed(redRangeMin, redRangeMax);
    }
    isYellowRangeDisplayed() {
        const { yellowRangeMin, yellowRangeMax } = this.config;
        return this.isRangeDisplayed(yellowRangeMin, yellowRangeMax);
    }
    isRangeDisplayed(rangeMin, rangeMax) {
        return rangeMin === 0 || rangeMax === 0 || (rangeMin && rangeMax);
    }
}
RangeDisplayComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: RangeDisplayComponent, deps: [{ token: i1.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component });
RangeDisplayComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.6", type: RangeDisplayComponent, selector: "c8y-range-display", inputs: { config: "config", display: "display" }, host: { properties: { "attr.style": "this.inlineStyle" } }, ngImport: i0, template: "<div [ngClass]=\"{ 'range-display--vertical': config.orientation === 'vertical',\n  'range-display--compact' : display ==='compact',\n  'range-display--inline' : display ==='inline' }\" \n  attr.data-label=\"{{ config.unit }}\"\n>\n  <div class=\"range-display\">\n    <div class=\"range-display__range\">\n      <div class=\"range-display__range__unit\">\n        {{ config.unit }}\n      </div>\n      <div *ngIf=\"isYellowRangeDisplayed()\" class=\"range-display__range__min\"></div>\n      <div *ngIf=\"isRedRangeDisplayed()\" class=\"range-display__range__max\"></div>\n      <div\n        *ngIf=\"checkTarget()\"\n        class=\"range-display__range__target\"\n        attr.data-label=\"{{ config.target }} {{ config.unit }}\"\n        title=\"{{ 'Target' | translate }}: {{ config.target }} {{ config.unit }}\"\n      ></div>\n      <div\n        *ngIf=\"\n          config.current != undefined &&\n          config.current >= config.min &&\n          config.current <= config.max\n        \"\n        class=\"range-display__range__current\"\n        attr.data-label=\"{{ config.current }} {{ config.unit }} &#xa; {{ config.time | c8yDate }}\"\n        title=\"{{ 'Current' | translate }}: {{ config.current }} {{ config.unit }} | {{\n          config.time | c8yDate\n        }}\"\n      ></div>\n    </div>\n    <div class=\"range-display__ruler\">\n      <div\n        *ngFor=\"let x of [].constructor(10); let index = index; trackBy: trackByIndex\"\n        attr.data-label=\"{{ rulerCalc(index) }}\"\n        class=\"range-display__tick\"\n      ></div>\n      <div attr.data-label=\"{{ config.max || 100 | number }}\" class=\"range-display__tick\"></div>\n    </div>\n  </div>\n</div>\n", dependencies: [{ kind: "directive", type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i3.C8yTranslatePipe, name: "translate" }, { kind: "pipe", type: i2.DecimalPipe, name: "number" }, { kind: "pipe", type: i4.DatePipe, name: "c8yDate" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.6", ngImport: i0, type: RangeDisplayComponent, decorators: [{
            type: Component,
            args: [{ selector: 'c8y-range-display', template: "<div [ngClass]=\"{ 'range-display--vertical': config.orientation === 'vertical',\n  'range-display--compact' : display ==='compact',\n  'range-display--inline' : display ==='inline' }\" \n  attr.data-label=\"{{ config.unit }}\"\n>\n  <div class=\"range-display\">\n    <div class=\"range-display__range\">\n      <div class=\"range-display__range__unit\">\n        {{ config.unit }}\n      </div>\n      <div *ngIf=\"isYellowRangeDisplayed()\" class=\"range-display__range__min\"></div>\n      <div *ngIf=\"isRedRangeDisplayed()\" class=\"range-display__range__max\"></div>\n      <div\n        *ngIf=\"checkTarget()\"\n        class=\"range-display__range__target\"\n        attr.data-label=\"{{ config.target }} {{ config.unit }}\"\n        title=\"{{ 'Target' | translate }}: {{ config.target }} {{ config.unit }}\"\n      ></div>\n      <div\n        *ngIf=\"\n          config.current != undefined &&\n          config.current >= config.min &&\n          config.current <= config.max\n        \"\n        class=\"range-display__range__current\"\n        attr.data-label=\"{{ config.current }} {{ config.unit }} &#xa; {{ config.time | c8yDate }}\"\n        title=\"{{ 'Current' | translate }}: {{ config.current }} {{ config.unit }} | {{\n          config.time | c8yDate\n        }}\"\n      ></div>\n    </div>\n    <div class=\"range-display__ruler\">\n      <div\n        *ngFor=\"let x of [].constructor(10); let index = index; trackBy: trackByIndex\"\n        attr.data-label=\"{{ rulerCalc(index) }}\"\n        class=\"range-display__tick\"\n      ></div>\n      <div attr.data-label=\"{{ config.max || 100 | number }}\" class=\"range-display__tick\"></div>\n    </div>\n  </div>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i1.DomSanitizer }]; }, propDecorators: { config: [{
                type: Input
            }], display: [{
                type: Input
            }], inlineStyle: [{
                type: HostBinding,
                args: ['attr.style']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UtZGlzcGxheS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9jb3JlL3JhbmdlLWRpc3BsYXkvcmFuZ2UtZGlzcGxheS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9jb3JlL3JhbmdlLWRpc3BsYXkvcmFuZ2UtZGlzcGxheS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDOzs7Ozs7QUFPekQsTUFBTSxPQUFPLHFCQUFxQjtJQThDaEMsWUFBb0IsU0FBdUI7UUFBdkIsY0FBUyxHQUFULFNBQVMsQ0FBYztRQTdDbEMsV0FBTSxHQUFpQixFQUFFLENBQUM7UUFDMUIsWUFBTyxHQUFrQyxNQUFNLENBQUM7SUE0Q1gsQ0FBQztJQTNDL0MsSUFDSSxXQUFXO1FBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQztRQUNoQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUU7WUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztTQUN2QjtRQUNELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLHdCQUF3QixDQUM1Qzt5QkFDbUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHO3lCQUNmLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRzswQkFDZCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUc7a0NBRS9DLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQ3JGO21DQUVFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQ3RGOzJCQUVFLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUN0RCxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUNwQzsyQkFFRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEYsR0FDRjsyQkFFRSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDbkQsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FDcEM7MkJBRUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ25GLEdBQ0Y7U0FDRCxDQUNKLENBQUM7SUFDSixDQUFDO0lBSUQsV0FBVztRQUNULE9BQU8sQ0FDTCxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBSyxTQUFTO1lBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUk7WUFDM0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHO1lBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUN0QyxDQUFDO0lBQ0osQ0FBQztJQUVELFNBQVMsQ0FBQyxLQUFLO1FBQ2IsTUFBTSxHQUFHLEdBQVcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDO1FBQ3pGLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLEtBQUssU0FBUyxFQUFFO1lBQzFDLE9BQU8sVUFBVSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO1NBQzFEO1FBQ0QsT0FBTyxVQUFVLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxZQUFZLENBQUMsS0FBYTtRQUN4QixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxtQkFBbUI7UUFDakIsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQ2pELE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsc0JBQXNCO1FBQ3BCLE1BQU0sRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2RCxPQUFPLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVELGdCQUFnQixDQUFDLFFBQVEsRUFBRSxRQUFRO1FBQ2pDLE9BQU8sUUFBUSxLQUFLLENBQUMsSUFBSSxRQUFRLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLFFBQVEsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7O2tIQWpGVSxxQkFBcUI7c0dBQXJCLHFCQUFxQix1S0NSbEMscXFEQXlDQTsyRkRqQ2EscUJBQXFCO2tCQUpqQyxTQUFTOytCQUNFLG1CQUFtQjttR0FJcEIsTUFBTTtzQkFBZCxLQUFLO2dCQUNHLE9BQU87c0JBQWYsS0FBSztnQkFFRixXQUFXO3NCQURkLFdBQVc7dUJBQUMsWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEhvc3RCaW5kaW5nIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IFJhbmdlRGlzcGxheSB9IGZyb20gJy4vcmFuZ2UtZGlzcGxheS5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2M4eS1yYW5nZS1kaXNwbGF5JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3JhbmdlLWRpc3BsYXkuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFJhbmdlRGlzcGxheUNvbXBvbmVudCB7XG4gIEBJbnB1dCgpIGNvbmZpZzogUmFuZ2VEaXNwbGF5ID0ge307XG4gIEBJbnB1dCgpIGRpc3BsYXk6ICdmdWxsJyB8ICdjb21wYWN0JyB8ICdpbmxpbmUnID0gJ2Z1bGwnO1xuICBASG9zdEJpbmRpbmcoJ2F0dHIuc3R5bGUnKVxuICBnZXQgaW5saW5lU3R5bGUoKSB7XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmNvbmZpZyB8fCB7fTtcbiAgICBpZiAoIXRoaXMuY29uZmlnLm1pbikge1xuICAgICAgdGhpcy5jb25maWcubWluID0gMDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5tYXgpIHtcbiAgICAgIHRoaXMuY29uZmlnLm1heCA9IDEwMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmZyYWN0aW9uU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmNvbmZpZy5jdXJyZW50ID0gcGFyc2VGbG9hdCh0aGlzLmNvbmZpZy5jdXJyZW50LnRvRml4ZWQodGhpcy5jb25maWcuZnJhY3Rpb25TaXplKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoXG4gICAgICBgXG4gICAgICAgICAgLS1yYW5nZS1taW46ICR7dGhpcy5jb25maWcubWlufTtcbiAgICAgICAgICAtLXJhbmdlLW1heDogJHt0aGlzLmNvbmZpZy5tYXh9O1xuICAgICAgICAgIC0tZnVsbC1yYW5nZTogJHt0aGlzLmNvbmZpZy5tYXggLSB0aGlzLmNvbmZpZy5taW59O1xuICAgICAgICAgIC0tbWVhc3VyZW1lbnQtdGFyZ2V0OiAke1xuICAgICAgICAgICAgKCh0aGlzLmNvbmZpZy50YXJnZXQgLSB0aGlzLmNvbmZpZy5taW4pICogMTAwKSAvICh0aGlzLmNvbmZpZy5tYXggLSB0aGlzLmNvbmZpZy5taW4pXG4gICAgICAgICAgfSU7XG4gICAgICAgICAgLS1tZWFzdXJlbWVudC1jdXJyZW50OiAke1xuICAgICAgICAgICAgKCh0aGlzLmNvbmZpZy5jdXJyZW50IC0gdGhpcy5jb25maWcubWluKSAqIDEwMCkgLyAodGhpcy5jb25maWcubWF4IC0gdGhpcy5jb25maWcubWluKVxuICAgICAgICAgIH0lO1xuICAgICAgICAgIC0tcmFuZ2UteS1taW46ICR7XG4gICAgICAgICAgICAoKHRoaXMuY29uZmlnLnllbGxvd1JhbmdlTWluIC0gdGhpcy5jb25maWcubWluKSAqIDEwMCkgL1xuICAgICAgICAgICAgKHRoaXMuY29uZmlnLm1heCAtIHRoaXMuY29uZmlnLm1pbilcbiAgICAgICAgICB9JTtcbiAgICAgICAgICAtLXJhbmdlLXktbWF4OiAke1xuICAgICAgICAgICAgKCh0aGlzLmNvbmZpZy55ZWxsb3dSYW5nZU1heCAtIHRoaXMuY29uZmlnLm1pbikgLyAodGhpcy5jb25maWcubWF4IC0gdGhpcy5jb25maWcubWluKSkgKlxuICAgICAgICAgICAgMTAwXG4gICAgICAgICAgfSU7XG4gICAgICAgICAgLS1yYW5nZS1yLW1pbjogJHtcbiAgICAgICAgICAgICgodGhpcy5jb25maWcucmVkUmFuZ2VNaW4gLSB0aGlzLmNvbmZpZy5taW4pICogMTAwKSAvXG4gICAgICAgICAgICAodGhpcy5jb25maWcubWF4IC0gdGhpcy5jb25maWcubWluKVxuICAgICAgICAgIH0lO1xuICAgICAgICAgIC0tcmFuZ2Utci1tYXg6ICR7XG4gICAgICAgICAgICAoKHRoaXMuY29uZmlnLnJlZFJhbmdlTWF4IC0gdGhpcy5jb25maWcubWluKSAvICh0aGlzLmNvbmZpZy5tYXggLSB0aGlzLmNvbmZpZy5taW4pKSAqXG4gICAgICAgICAgICAxMDBcbiAgICAgICAgICB9JTtcbiAgICAgICAgYFxuICAgICk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNhbml0aXplcjogRG9tU2FuaXRpemVyKSB7fVxuXG4gIGNoZWNrVGFyZ2V0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmNvbmZpZy50YXJnZXQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgdGhpcy5jb25maWcudGFyZ2V0ICE9PSBudWxsICYmXG4gICAgICB0aGlzLmNvbmZpZy50YXJnZXQgPj0gdGhpcy5jb25maWcubWluICYmXG4gICAgICB0aGlzLmNvbmZpZy50YXJnZXQgPD0gdGhpcy5jb25maWcubWF4XG4gICAgKTtcbiAgfVxuXG4gIHJ1bGVyQ2FsYyhpbmRleCkge1xuICAgIGNvbnN0IG51bTogbnVtYmVyID0gdGhpcy5jb25maWcubWluICsgKCh0aGlzLmNvbmZpZy5tYXggLSB0aGlzLmNvbmZpZy5taW4pIC8gMTApICogaW5kZXg7XG4gICAgaWYgKHRoaXMuY29uZmlnLmZyYWN0aW9uU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChudW0udG9GaXhlZCh0aGlzLmNvbmZpZy5mcmFjdGlvblNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtLnRvRml4ZWQoMikpO1xuICB9XG5cbiAgdHJhY2tCeUluZGV4KGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIGlzUmVkUmFuZ2VEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgeyByZWRSYW5nZU1pbiwgcmVkUmFuZ2VNYXggfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiB0aGlzLmlzUmFuZ2VEaXNwbGF5ZWQocmVkUmFuZ2VNaW4sIHJlZFJhbmdlTWF4KTtcbiAgfVxuXG4gIGlzWWVsbG93UmFuZ2VEaXNwbGF5ZWQoKSB7XG4gICAgY29uc3QgeyB5ZWxsb3dSYW5nZU1pbiwgeWVsbG93UmFuZ2VNYXggfSA9IHRoaXMuY29uZmlnO1xuICAgIHJldHVybiB0aGlzLmlzUmFuZ2VEaXNwbGF5ZWQoeWVsbG93UmFuZ2VNaW4sIHllbGxvd1JhbmdlTWF4KTtcbiAgfVxuXG4gIGlzUmFuZ2VEaXNwbGF5ZWQocmFuZ2VNaW4sIHJhbmdlTWF4KSB7XG4gICAgcmV0dXJuIHJhbmdlTWluID09PSAwIHx8IHJhbmdlTWF4ID09PSAwIHx8IChyYW5nZU1pbiAmJiByYW5nZU1heCk7XG4gIH1cbn1cbiIsIjxkaXYgW25nQ2xhc3NdPVwieyAncmFuZ2UtZGlzcGxheS0tdmVydGljYWwnOiBjb25maWcub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcsXG4gICdyYW5nZS1kaXNwbGF5LS1jb21wYWN0JyA6IGRpc3BsYXkgPT09J2NvbXBhY3QnLFxuICAncmFuZ2UtZGlzcGxheS0taW5saW5lJyA6IGRpc3BsYXkgPT09J2lubGluZScgfVwiIFxuICBhdHRyLmRhdGEtbGFiZWw9XCJ7eyBjb25maWcudW5pdCB9fVwiXG4+XG4gIDxkaXYgY2xhc3M9XCJyYW5nZS1kaXNwbGF5XCI+XG4gICAgPGRpdiBjbGFzcz1cInJhbmdlLWRpc3BsYXlfX3JhbmdlXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicmFuZ2UtZGlzcGxheV9fcmFuZ2VfX3VuaXRcIj5cbiAgICAgICAge3sgY29uZmlnLnVuaXQgfX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiAqbmdJZj1cImlzWWVsbG93UmFuZ2VEaXNwbGF5ZWQoKVwiIGNsYXNzPVwicmFuZ2UtZGlzcGxheV9fcmFuZ2VfX21pblwiPjwvZGl2PlxuICAgICAgPGRpdiAqbmdJZj1cImlzUmVkUmFuZ2VEaXNwbGF5ZWQoKVwiIGNsYXNzPVwicmFuZ2UtZGlzcGxheV9fcmFuZ2VfX21heFwiPjwvZGl2PlxuICAgICAgPGRpdlxuICAgICAgICAqbmdJZj1cImNoZWNrVGFyZ2V0KClcIlxuICAgICAgICBjbGFzcz1cInJhbmdlLWRpc3BsYXlfX3JhbmdlX190YXJnZXRcIlxuICAgICAgICBhdHRyLmRhdGEtbGFiZWw9XCJ7eyBjb25maWcudGFyZ2V0IH19IHt7IGNvbmZpZy51bml0IH19XCJcbiAgICAgICAgdGl0bGU9XCJ7eyAnVGFyZ2V0JyB8IHRyYW5zbGF0ZSB9fToge3sgY29uZmlnLnRhcmdldCB9fSB7eyBjb25maWcudW5pdCB9fVwiXG4gICAgICA+PC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgY29uZmlnLmN1cnJlbnQgIT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgY29uZmlnLmN1cnJlbnQgPj0gY29uZmlnLm1pbiAmJlxuICAgICAgICAgIGNvbmZpZy5jdXJyZW50IDw9IGNvbmZpZy5tYXhcbiAgICAgICAgXCJcbiAgICAgICAgY2xhc3M9XCJyYW5nZS1kaXNwbGF5X19yYW5nZV9fY3VycmVudFwiXG4gICAgICAgIGF0dHIuZGF0YS1sYWJlbD1cInt7IGNvbmZpZy5jdXJyZW50IH19IHt7IGNvbmZpZy51bml0IH19ICYjeGE7IHt7IGNvbmZpZy50aW1lIHwgYzh5RGF0ZSB9fVwiXG4gICAgICAgIHRpdGxlPVwie3sgJ0N1cnJlbnQnIHwgdHJhbnNsYXRlIH19OiB7eyBjb25maWcuY3VycmVudCB9fSB7eyBjb25maWcudW5pdCB9fSB8IHt7XG4gICAgICAgICAgY29uZmlnLnRpbWUgfCBjOHlEYXRlXG4gICAgICAgIH19XCJcbiAgICAgID48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicmFuZ2UtZGlzcGxheV9fcnVsZXJcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgKm5nRm9yPVwibGV0IHggb2YgW10uY29uc3RydWN0b3IoMTApOyBsZXQgaW5kZXggPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUluZGV4XCJcbiAgICAgICAgYXR0ci5kYXRhLWxhYmVsPVwie3sgcnVsZXJDYWxjKGluZGV4KSB9fVwiXG4gICAgICAgIGNsYXNzPVwicmFuZ2UtZGlzcGxheV9fdGlja1wiXG4gICAgICA+PC9kaXY+XG4gICAgICA8ZGl2IGF0dHIuZGF0YS1sYWJlbD1cInt7IGNvbmZpZy5tYXggfHwgMTAwIHwgbnVtYmVyIH19XCIgY2xhc3M9XCJyYW5nZS1kaXNwbGF5X190aWNrXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG4iXX0=