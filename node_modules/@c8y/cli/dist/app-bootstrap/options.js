var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { forEach, get, reduce, union } from 'lodash';
import chroma from 'chroma-js';
let staticOptionsCache;
let urlOptionsCache;
export function loadOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const urlOptions = loadUrlOptions(); // used for debugging or preview
        const staticOptions = loadStaticOptions();
        const dynamicOptions = yield loadDynamicOptions();
        const localDynamicOptions = yield loadLocalDynamicOptions();
        const previewOptions = loadPreviewOptions();
        // languages are to be merged and not replaced
        const languages = Object.assign(Object.assign(Object.assign(Object.assign({}, (staticOptions.languages || {})), (localDynamicOptions.languages || {})), (dynamicOptions.languages || {})), (urlOptions.languages || {}));
        const options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ versions: {
                ng1: __VERSION_NG1__,
                ngx: __VERSION_NGX__,
                package: __VERSION_PACKAGE__
            } }, staticOptions), localDynamicOptions), dynamicOptions), urlOptions), previewOptions), { remotes: getAllMFRemotes([
                staticOptions,
                localDynamicOptions,
                dynamicOptions,
                urlOptions,
                previewOptions
            ]), languages, remoteModules: [] });
        options.C8Y_INSTANCE_OPTIONS = Object.assign({}, options); // for compatability with c8yBase.getOptions in ng1-modules
        // If no shades are defined, we auto generate shades. This was implemented with the
        // re-design in 10.17. Branding editor should later define the shades. So long we
        // auto generate shades out of the primary color and based on the referenceShades.
        const shouldApplyShadeColors = hasBrandPrimary(options.brandingCssVars) && !hasAnyBrandShade(options.brandingCssVars);
        if (shouldApplyShadeColors) {
            options.brandingCssVars = getShadeColorBrandingCssVars(options.brandingCssVars);
        }
        return options;
    });
}
function getShadeColorBrandingCssVars(brandingCssVars) {
    const shades = generateShades(brandingCssVars['brand-primary']);
    let i = 1;
    for (const shade of shades) {
        brandingCssVars['c8y-brand-' + i + '0'] = shade;
        i++;
    }
    return brandingCssVars;
}
function generateShades(inputColor) {
    const referenceShades = [
        '#134158',
        '#1C5569',
        '#058192',
        '#22A6AA',
        '#3CC1B7',
        '#8ADBD5',
        '#C5EDEA',
        '#EBF9F8'
    ];
    // Calculate the luminance of the reference shades
    const referenceLuminances = referenceShades.map(color => chroma(color).luminance());
    // Generate shades of the input color with the same luminance as the reference shades
    const generatedShades = referenceLuminances.map(luminance => chroma(inputColor).luminance(luminance).hex());
    // Calculate the distance between the input color and each color in the generatedShades array
    const distances = generatedShades.map(color => chroma.deltaE(inputColor, color));
    // Find the index of the color with the smallest distance
    const index = distances.indexOf(Math.min(...distances));
    generatedShades[index] = inputColor;
    return generatedShades;
}
function hasBrandPrimary(brandingCssVars) {
    return !!(brandingCssVars === null || brandingCssVars === void 0 ? void 0 : brandingCssVars['brand-primary']);
}
function hasAnyBrandShade(brandingCssVars) {
    if (!brandingCssVars) {
        return false;
    }
    return !!Object.keys(brandingCssVars).some(value => /brand-[1-8]0/.test(value));
}
export function getAllMFRemotes(options) {
    return reduce(options, (allRemotes, mfRemote) => {
        const { remotes } = mfRemote;
        forEach(remotes, (remoteModules, remoteContextPath) => {
            const currentRemotes = get(allRemotes, remoteContextPath, []);
            allRemotes[remoteContextPath] = union(currentRemotes, remoteModules);
        });
        return allRemotes;
    }, {});
}
function loadStaticOptions() {
    if (!staticOptionsCache) {
        staticOptionsCache =
            JSON.parse(document.querySelector('#static-options').innerText) || {};
    }
    return Object.assign(Object.assign({}, staticOptionsCache), loadUrlOptions());
}
export function loginOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const hostName = location.origin;
        return yield requestRemoteOptions(hostName + '/tenant/loginOptions');
    });
}
export function loadUrlOptions() {
    if (!urlOptionsCache) {
        const query = location.search.substr(1).split('&');
        urlOptionsCache = query.reduce((options, keyValuePair) => {
            if (keyValuePair) {
                if (keyValuePair.match(/=/)) {
                    const [key, value] = keyValuePair.split(/=/);
                    try {
                        options[key] = JSON.parse(decodeURIComponent(value));
                    }
                    catch (error) {
                        console.warn(`Failed to parse option ${key}: ${error}`);
                        options[key] = value;
                    }
                }
                else {
                    options[keyValuePair] = true;
                }
            }
            return options;
        }, {});
    }
    return urlOptionsCache;
}
export function clearUrlOptionsCache() {
    urlOptionsCache = undefined;
}
function loadLocalDynamicOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        const remoteOptions = yield requestRemoteOptions(`cumulocity.json?nocache=${String(Math.random()).substr(2)}`);
        return remoteOptions;
    });
}
function loadDynamicOptions() {
    return __awaiter(this, void 0, void 0, function* () {
        let { dynamicOptionsUrl } = loadStaticOptions();
        let remoteOptions = {};
        if (dynamicOptionsUrl) {
            dynamicOptionsUrl = dynamicOptionsUrl.match(/\?/)
                ? dynamicOptionsUrl
                : `${dynamicOptionsUrl}?nocache=${String(Math.random()).substr(2)}`;
            remoteOptions = yield requestRemoteOptions(dynamicOptionsUrl);
        }
        return remoteOptions;
    });
}
function loadPreviewOptions() {
    if (window.C8Y_PREVIEW) {
        return window.C8Y_PREVIEW;
    }
    return {};
}
function requestRemoteOptions(url) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            let options = {};
            const onload = () => {
                if (request.status >= 200 && request.status < 400) {
                    try {
                        options = JSON.parse(request.responseText);
                    }
                    catch (e) {
                        // do nothing
                    }
                    Object.keys(options).forEach(key => {
                        const value = options[key];
                        if (typeof value === 'string') {
                            try {
                                const parsed = JSON.parse(value);
                                if (typeof parsed === 'object') {
                                    options[key] = parsed;
                                }
                            }
                            catch (e) {
                                // do nothing
                            }
                        }
                    });
                }
                resolve(options);
            };
            request.open('GET', url, true);
            request.setRequestHeader('UseXBasic', 'true');
            request.onload = onload;
            request.onerror = e => reject(e);
            request.send();
        });
    });
}
export function applyOptions(options) {
    const { c8yAppVarName = 'C8Y_APP' } = options;
    options = window.C8Y_APP = window[c8yAppVarName] = Object.assign({ modules: [] }, options);
    setVersion(options);
    updateTitle(options, document);
    updateFavicon(options, document);
    updateBrandingUrl(options, document);
    updateCss(options, document);
    updateTranslations(options);
    return options;
}
export function setVersion(options) {
    const { c8yVersionName = 'UI_VERSION' } = options;
    window[c8yVersionName] = options.versions.ng1 || options.versions.ngx;
}
export function updateTitle({ globalTitle }, document) {
    if (!globalTitle) {
        return;
    }
    const titleEl = document.querySelector('title');
    titleEl.innerText = `${globalTitle} - ${titleEl.innerText}`;
}
export function updateFavicon({ faviconUrl = 'favicon.ico' }, document) {
    const link = document.createElement('link');
    link.setAttribute('rel', 'icon');
    link.setAttribute('href', faviconUrl);
    document.querySelector('head').appendChild(link);
}
export function updateBrandingUrl({ brandingUrl }, document) {
    if (!brandingUrl) {
        if (__ENTRY_BRANDING__) {
            /**
             * Added ngGlobalStyle. Without it, the Angular webpack configuration only uses less-loader for project styles (c8y/style package).
             * After adding ngGlobalStyle, the rest of the loaders: postcss, css, and mini-css-extract will be applied to the project styles.
             */
            import(/* webpackChunkName: "branding" */ `${__ENTRY_BRANDING__}?ngGlobalStyle`);
        }
        else {
            throw new Error('Branding definition missing.');
        }
    }
    else {
        const link = document.createElement('link');
        link.setAttribute('rel', 'stylesheet');
        link.setAttribute('href', brandingUrl);
        document.querySelector('head').appendChild(link);
    }
}
export function updateCss({ brandingCssVars, extraCssUrls }, document) {
    if (Array.isArray(extraCssUrls)) {
        extraCssUrls.forEach(url => {
            const link = document.createElement('link');
            link.setAttribute('rel', 'stylesheet');
            link.setAttribute('href', url);
            document.querySelector('head').appendChild(link);
        });
    }
    if (brandingCssVars) {
        const vars = Object.keys(brandingCssVars).map(key => `--${key}: ${brandingCssVars[key]};`);
        const style = document.createElement('style');
        style.appendChild(document.createTextNode(`:root{\n${vars.join('\n')}\n}`));
        document.querySelector('body').appendChild(style);
    }
}
export function updateTranslations(options) {
    if (options.i18nExtra) {
        options.langsDetails = Object.assign(Object.assign({}, options.langsDetails), options.i18nExtra);
    }
}
//# sourceMappingURL=options.js.map