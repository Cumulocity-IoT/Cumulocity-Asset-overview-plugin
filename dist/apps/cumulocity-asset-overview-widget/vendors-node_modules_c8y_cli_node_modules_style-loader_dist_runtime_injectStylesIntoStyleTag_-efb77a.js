"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_c8y_cli_node_modules_style-loader_dist_runtime_injectStylesIntoStyleTag_-efb77a"],{

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \**************************************************************************************************/
/***/ (function(module) {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0BjOHkvY2xpL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz81NjEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRE9NLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRE9NW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXhCeUlkZW50aWZpZXIgPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM10sXG4gICAgICBzdXBwb3J0czogaXRlbVs0XSxcbiAgICAgIGxheWVyOiBpdGVtWzVdXG4gICAgfTtcbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuICB2YXIgdXBkYXRlciA9IGZ1bmN0aW9uIHVwZGF0ZXIobmV3T2JqKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCAmJiBuZXdPYmouc3VwcG9ydHMgPT09IG9iai5zdXBwb3J0cyAmJiBuZXdPYmoubGF5ZXIgPT09IG9iai5sYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhcGkudXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwaS5yZW1vdmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB1cGRhdGVyO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIHZhciBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICB9XG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcbiAgICAgIHZhciBfaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihfaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuICAgICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICB9O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \******************************************************************************************/
/***/ (function(module) {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0BjOHkvY2xpL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanM/OWE2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIG1lbW8gPSB7fTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBnZXRUYXJnZXQodGFyZ2V0KSB7XG4gIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICB9XG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0QnlTZWxlY3RvcihpbnNlcnQsIHN0eWxlKSB7XG4gIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQoaW5zZXJ0KTtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICB9XG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydEJ5U2VsZWN0b3I7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertBySelector.js\n");

/***/ }),

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \********************************************************************************************/
/***/ (function(module) {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzPzdhNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/insertStyleElement.js\n");

/***/ }),

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzPzhhMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\n");

/***/ }),

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \*************************************************************************************/
/***/ (function(module) {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVEb21BUEkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYzh5L2NsaS9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcz9hYzM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQob2JqLnN1cHBvcnRzLCBcIikge1wiKTtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIik7XG4gIH1cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJAbGF5ZXJcIi5jb25jYXQob2JqLmxheWVyLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQob2JqLmxheWVyKSA6IFwiXCIsIFwiIHtcIik7XG4gIH1cbiAgY3NzICs9IG9iai5jc3M7XG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLnN1cHBvcnRzKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH1cblxuICAvLyBGb3Igb2xkIElFXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7fSxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICB9O1xuICB9XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBkb21BUEk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleDomAPI.js\n");

/***/ }),

/***/ "./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*******************************************************************************************/
/***/ (function(module) {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGM4eS9jbGkvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0BjOHkvY2xpL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzZkM2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@c8y/cli/node_modules/style-loader/dist/runtime/styleTagTransform.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gW107XG5cbiAgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICB2YXIgbmVlZExheWVyID0gdHlwZW9mIGl0ZW1bNV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwiQGxheWVyXCIuY29uY2F0KGl0ZW1bNV0ubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChpdGVtWzVdKSA6IFwiXCIsIFwiIHtcIik7XG4gICAgICB9XG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgbGlzdC5pID0gZnVuY3Rpb24gaShtb2R1bGVzLCBtZWRpYSwgZGVkdXBlLCBzdXBwb3J0cywgbGF5ZXIpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIHVuZGVmaW5lZF1dO1xuICAgIH1cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2tdWzBdO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbW9kdWxlcy5sZW5ndGg7IF9rKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2tdKTtcbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN1cHBvcnRzKSB7XG4gICAgICAgIGlmICghaXRlbVs0XSkge1xuICAgICAgICAgIGl0ZW1bNF0gPSBcIlwiLmNvbmNhdChzdXBwb3J0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzRdID0gc3VwcG9ydHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBsaXN0O1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ (function(module) {

eval("\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === \"function\") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    return [content].concat([sourceMapping]).join(\"\\n\");\n  }\n  return [content].join(\"\\n\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanM/YWYxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlbSkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV07XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oXCJcXG5cIik7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/runtime/sourceMaps.js\n");

/***/ }),

/***/ "./node_modules/@ng-select/ng-select/themes/default.theme.css?ngResource":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ng-select/ng-select/themes/default.theme.css?ngResource ***!
  \*******************************************************************************/
/***/ (function(module) {

module.exports = ".ng-select.ng-select-opened>.ng-select-container{background:#fff;border-color:#b3b3b3 #ccc #d9d9d9}.ng-select.ng-select-opened>.ng-select-container:hover{box-shadow:none}.ng-select.ng-select-opened>.ng-select-container .ng-arrow{top:-2px;border-color:transparent transparent #999;border-width:0 5px 5px}.ng-select.ng-select-opened>.ng-select-container .ng-arrow:hover{border-color:transparent transparent #333}.ng-select.ng-select-opened.ng-select-top>.ng-select-container{border-top-right-radius:0;border-top-left-radius:0}.ng-select.ng-select-opened.ng-select-right>.ng-select-container{border-top-right-radius:0;border-bottom-right-radius:0}.ng-select.ng-select-opened.ng-select-bottom>.ng-select-container{border-bottom-right-radius:0;border-bottom-left-radius:0}.ng-select.ng-select-opened.ng-select-left>.ng-select-container{border-top-left-radius:0;border-bottom-left-radius:0}.ng-select.ng-select-focused:not(.ng-select-opened)>.ng-select-container{border-color:#007eff;box-shadow:inset 0 1px 1px rgba(0,0,0,0.075),0 0 0 3px rgba(0,126,255,0.1)}.ng-select.ng-select-disabled>.ng-select-container{background-color:#f9f9f9}.ng-select .ng-has-value .ng-placeholder{display:none}.ng-select .ng-select-container{color:#333;background-color:#fff;border-radius:4px;border:1px solid #ccc;min-height:36px;align-items:center}.ng-select .ng-select-container:hover{box-shadow:0 1px 0 rgba(0,0,0,0.06)}.ng-select .ng-select-container .ng-value-container{align-items:center;padding-left:10px}[dir=\"rtl\"] .ng-select .ng-select-container .ng-value-container{padding-right:10px;padding-left:0}.ng-select .ng-select-container .ng-value-container .ng-placeholder{color:#999}.ng-select.ng-select-single .ng-select-container{height:36px}.ng-select.ng-select-single .ng-select-container .ng-value-container .ng-input{top:5px;left:0;padding-left:10px;padding-right:50px}[dir=\"rtl\"] .ng-select.ng-select-single .ng-select-container .ng-value-container .ng-input{padding-right:10px;padding-left:50px}.ng-select.ng-select-multiple.ng-select-disabled>.ng-select-container .ng-value-container .ng-value{background-color:#f9f9f9;border:1px solid #e6e6e6}.ng-select.ng-select-multiple.ng-select-disabled>.ng-select-container .ng-value-container .ng-value .ng-value-label{padding:0 5px}.ng-select.ng-select-multiple .ng-select-container .ng-value-container{padding-top:5px;padding-left:7px}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container{padding-right:7px;padding-left:0}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value{font-size:.9em;margin-bottom:5px;color:#333;background-color:#ebf5ff;border-radius:2px;margin-right:5px}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value{margin-right:0;margin-left:5px}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value.ng-value-disabled{background-color:#f9f9f9}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value.ng-value-disabled .ng-value-label{padding-left:5px}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value.ng-value-disabled .ng-value-label{padding-left:0;padding-right:5px}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-label{display:inline-block;padding:1px 5px}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon{display:inline-block;padding:1px 5px}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon:hover{background-color:#d1e8ff}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon.left{border-right:1px solid #b8dbff}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon.left{border-left:1px solid #b8dbff;border-right:none}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon.right{border-left:1px solid #b8dbff}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-value .ng-value-icon.right{border-left:0;border-right:1px solid #b8dbff}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-input{padding:0 0 3px 3px}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-input{padding:0 3px 3px 0}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-input>input{color:#000}.ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{top:5px;padding-bottom:5px;padding-left:3px}[dir=\"rtl\"] .ng-select.ng-select-multiple .ng-select-container .ng-value-container .ng-placeholder{padding-right:3px;padding-left:0}.ng-select .ng-clear-wrapper{color:#999}.ng-select .ng-clear-wrapper:hover .ng-clear{color:#D0021B}.ng-select .ng-spinner-zone{padding:5px 5px 0 0}[dir=\"rtl\"] .ng-select .ng-spinner-zone{padding:5px 0 0 5px}.ng-select .ng-arrow-wrapper{width:25px;padding-right:5px}[dir=\"rtl\"] .ng-select .ng-arrow-wrapper{padding-left:5px;padding-right:0}.ng-select .ng-arrow-wrapper:hover .ng-arrow{border-top-color:#666}.ng-select .ng-arrow-wrapper .ng-arrow{border-color:#999 transparent transparent;border-style:solid;border-width:5px 5px 2.5px}.ng-dropdown-panel{background-color:#fff;border:1px solid #ccc;box-shadow:0 1px 0 rgba(0,0,0,0.06);left:0}.ng-dropdown-panel.ng-select-top{bottom:100%;border-top-right-radius:4px;border-top-left-radius:4px;border-bottom-color:#e6e6e6;margin-bottom:-1px}.ng-dropdown-panel.ng-select-top .ng-dropdown-panel-items .ng-option:first-child{border-top-right-radius:4px;border-top-left-radius:4px}.ng-dropdown-panel.ng-select-right{left:100%;top:0;border-top-right-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;border-bottom-color:#e6e6e6;margin-bottom:-1px}.ng-dropdown-panel.ng-select-right .ng-dropdown-panel-items .ng-option:first-child{border-top-right-radius:4px}.ng-dropdown-panel.ng-select-bottom{top:100%;border-bottom-right-radius:4px;border-bottom-left-radius:4px;border-top-color:#e6e6e6;margin-top:-1px}.ng-dropdown-panel.ng-select-bottom .ng-dropdown-panel-items .ng-option:last-child{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.ng-dropdown-panel.ng-select-left{left:-100%;top:0;border-top-left-radius:4px;border-bottom-right-radius:4px;border-bottom-left-radius:4px;border-bottom-color:#e6e6e6;margin-bottom:-1px}.ng-dropdown-panel.ng-select-left .ng-dropdown-panel-items .ng-option:first-child{border-top-left-radius:4px}.ng-dropdown-panel .ng-dropdown-header{border-bottom:1px solid #ccc;padding:5px 7px}.ng-dropdown-panel .ng-dropdown-footer{border-top:1px solid #ccc;padding:5px 7px}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup{user-select:none;padding:8px 10px;font-weight:500;color:rgba(0,0,0,0.54);cursor:pointer}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup.ng-option-disabled{cursor:default}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup.ng-option-marked{background-color:#f5faff}.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup.ng-option-selected,.ng-dropdown-panel .ng-dropdown-panel-items .ng-optgroup.ng-option-selected.ng-option-marked{color:rgba(0,0,0,0.54);background-color:#ebf5ff;font-weight:600}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option{background-color:#fff;color:rgba(0,0,0,0.87);padding:8px 10px}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-selected,.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-selected.ng-option-marked{color:#333;background-color:#ebf5ff}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-selected .ng-option-label,.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-selected.ng-option-marked .ng-option-label{font-weight:600}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-marked{background-color:#f5faff;color:#333}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-disabled{color:#ccc}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-child{padding-left:22px}[dir=\"rtl\"] .ng-dropdown-panel .ng-dropdown-panel-items .ng-option.ng-option-child{padding-right:22px;padding-left:0}.ng-dropdown-panel .ng-dropdown-panel-items .ng-option .ng-tag-label{font-size:80%;font-weight:400;padding-right:5px}[dir=\"rtl\"] .ng-dropdown-panel .ng-dropdown-panel-items .ng-option .ng-tag-label{padding-left:5px;padding-right:0}[dir=\"rtl\"] .ng-dropdown-panel{direction:rtl;text-align:right}\n";

/***/ }),

/***/ "./node_modules/@angular/animations/fesm2020/browser.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@angular/animations/fesm2020/browser.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationDriver\": function() { return /* binding */ AnimationDriver; },\n/* harmony export */   \"ɵAnimation\": function() { return /* binding */ Animation; },\n/* harmony export */   \"ɵAnimationEngine\": function() { return /* binding */ AnimationEngine; },\n/* harmony export */   \"ɵAnimationStyleNormalizer\": function() { return /* binding */ AnimationStyleNormalizer; },\n/* harmony export */   \"ɵNoopAnimationDriver\": function() { return /* binding */ NoopAnimationDriver; },\n/* harmony export */   \"ɵNoopAnimationStyleNormalizer\": function() { return /* binding */ NoopAnimationStyleNormalizer; },\n/* harmony export */   \"ɵWebAnimationsDriver\": function() { return /* binding */ WebAnimationsDriver; },\n/* harmony export */   \"ɵWebAnimationsPlayer\": function() { return /* binding */ WebAnimationsPlayer; },\n/* harmony export */   \"ɵWebAnimationsStyleNormalizer\": function() { return /* binding */ WebAnimationsStyleNormalizer; },\n/* harmony export */   \"ɵallowPreviousPlayerStylesMerge\": function() { return /* binding */ allowPreviousPlayerStylesMerge; },\n/* harmony export */   \"ɵcontainsElement\": function() { return /* binding */ containsElement; },\n/* harmony export */   \"ɵgetParentElement\": function() { return /* binding */ getParentElement; },\n/* harmony export */   \"ɵinvokeQuery\": function() { return /* binding */ invokeQuery; },\n/* harmony export */   \"ɵnormalizeKeyframes\": function() { return /* binding */ normalizeKeyframes; },\n/* harmony export */   \"ɵvalidateStyleProperty\": function() { return /* binding */ validateStyleProperty; }\n/* harmony export */ });\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/animations */ \"webpack/sharing/consume/default/@angular/animations/@angular/animations\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/**\n * @license Angular v15.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n\n\n\nconst LINE_START = '\\n - ';\nfunction invalidTimingValue(exp) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3000 /* RuntimeErrorCode.INVALID_TIMING_VALUE */, ngDevMode && `The provided timing value \"${exp}\" is invalid.`);\n}\nfunction negativeStepValue() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3100 /* RuntimeErrorCode.NEGATIVE_STEP_VALUE */, ngDevMode && 'Duration values below 0 are not allowed for this animation step.');\n}\nfunction negativeDelayValue() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3101 /* RuntimeErrorCode.NEGATIVE_DELAY_VALUE */, ngDevMode && 'Delay values below 0 are not allowed for this animation step.');\n}\nfunction invalidStyleParams(varName) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3001 /* RuntimeErrorCode.INVALID_STYLE_PARAMS */, ngDevMode &&\n        `Unable to resolve the local animation param ${varName} in the given list of values`);\n}\nfunction invalidParamValue(varName) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3003 /* RuntimeErrorCode.INVALID_PARAM_VALUE */, ngDevMode && `Please provide a value for the animation param ${varName}`);\n}\nfunction invalidNodeType(nodeType) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3004 /* RuntimeErrorCode.INVALID_NODE_TYPE */, ngDevMode && `Unable to resolve animation metadata node #${nodeType}`);\n}\nfunction invalidCssUnitValue(userProvidedProperty, value) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3005 /* RuntimeErrorCode.INVALID_CSS_UNIT_VALUE */, ngDevMode && `Please provide a CSS unit value for ${userProvidedProperty}:${value}`);\n}\nfunction invalidTrigger() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3006 /* RuntimeErrorCode.INVALID_TRIGGER */, ngDevMode &&\n        'animation triggers cannot be prefixed with an `@` sign (e.g. trigger(\\'@foo\\', [...]))');\n}\nfunction invalidDefinition() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3007 /* RuntimeErrorCode.INVALID_DEFINITION */, ngDevMode && 'only state() and transition() definitions can sit inside of a trigger()');\n}\nfunction invalidState(metadataName, missingSubs) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3008 /* RuntimeErrorCode.INVALID_STATE */, ngDevMode &&\n        `state(\"${metadataName}\", ...) must define default values for all the following style substitutions: ${missingSubs.join(', ')}`);\n}\nfunction invalidStyleValue(value) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3002 /* RuntimeErrorCode.INVALID_STYLE_VALUE */, ngDevMode && `The provided style string value ${value} is not allowed.`);\n}\nfunction invalidProperty(prop) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3009 /* RuntimeErrorCode.INVALID_PROPERTY */, ngDevMode &&\n        `The provided animation property \"${prop}\" is not a supported CSS property for animations`);\n}\nfunction invalidParallelAnimation(prop, firstStart, firstEnd, secondStart, secondEnd) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3010 /* RuntimeErrorCode.INVALID_PARALLEL_ANIMATION */, ngDevMode &&\n        `The CSS property \"${prop}\" that exists between the times of \"${firstStart}ms\" and \"${firstEnd}ms\" is also being animated in a parallel animation between the times of \"${secondStart}ms\" and \"${secondEnd}ms\"`);\n}\nfunction invalidKeyframes() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3011 /* RuntimeErrorCode.INVALID_KEYFRAMES */, ngDevMode && `keyframes() must be placed inside of a call to animate()`);\n}\nfunction invalidOffset() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3012 /* RuntimeErrorCode.INVALID_OFFSET */, ngDevMode && `Please ensure that all keyframe offsets are between 0 and 1`);\n}\nfunction keyframeOffsetsOutOfOrder() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3200 /* RuntimeErrorCode.KEYFRAME_OFFSETS_OUT_OF_ORDER */, ngDevMode && `Please ensure that all keyframe offsets are in order`);\n}\nfunction keyframesMissingOffsets() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3202 /* RuntimeErrorCode.KEYFRAMES_MISSING_OFFSETS */, ngDevMode && `Not all style() steps within the declared keyframes() contain offsets`);\n}\nfunction invalidStagger() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3013 /* RuntimeErrorCode.INVALID_STAGGER */, ngDevMode && `stagger() can only be used inside of query()`);\n}\nfunction invalidQuery(selector) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3014 /* RuntimeErrorCode.INVALID_QUERY */, ngDevMode &&\n        `\\`query(\"${selector}\")\\` returned zero elements. (Use \\`query(\"${selector}\", { optional: true })\\` if you wish to allow this.)`);\n}\nfunction invalidExpression(expr) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3015 /* RuntimeErrorCode.INVALID_EXPRESSION */, ngDevMode && `The provided transition expression \"${expr}\" is not supported`);\n}\nfunction invalidTransitionAlias(alias) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3016 /* RuntimeErrorCode.INVALID_TRANSITION_ALIAS */, ngDevMode && `The transition alias value \"${alias}\" is not supported`);\n}\nfunction validationFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3500 /* RuntimeErrorCode.VALIDATION_FAILED */, ngDevMode && `animation validation failed:\\n${errors.map(err => err.message).join('\\n')}`);\n}\nfunction buildingFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3501 /* RuntimeErrorCode.BUILDING_FAILED */, ngDevMode && `animation building failed:\\n${errors.map(err => err.message).join('\\n')}`);\n}\nfunction triggerBuildFailed(name, errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3404 /* RuntimeErrorCode.TRIGGER_BUILD_FAILED */, ngDevMode &&\n        `The animation trigger \"${name}\" has failed to build due to the following errors:\\n - ${errors.map(err => err.message).join('\\n - ')}`);\n}\nfunction animationFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3502 /* RuntimeErrorCode.ANIMATION_FAILED */, ngDevMode &&\n        `Unable to animate due to the following errors:${LINE_START}${errors.map(err => err.message).join(LINE_START)}`);\n}\nfunction registerFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3503 /* RuntimeErrorCode.REGISTRATION_FAILED */, ngDevMode &&\n        `Unable to build the animation due to the following errors: ${errors.map(err => err.message).join('\\n')}`);\n}\nfunction missingOrDestroyedAnimation() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3300 /* RuntimeErrorCode.MISSING_OR_DESTROYED_ANIMATION */, ngDevMode && 'The requested animation doesn\\'t exist or has already been destroyed');\n}\nfunction createAnimationFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3504 /* RuntimeErrorCode.CREATE_ANIMATION_FAILED */, ngDevMode &&\n        `Unable to create the animation due to the following errors:${errors.map(err => err.message).join('\\n')}`);\n}\nfunction missingPlayer(id) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3301 /* RuntimeErrorCode.MISSING_PLAYER */, ngDevMode && `Unable to find the timeline player referenced by ${id}`);\n}\nfunction missingTrigger(phase, name) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3302 /* RuntimeErrorCode.MISSING_TRIGGER */, ngDevMode &&\n        `Unable to listen on the animation trigger event \"${phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n}\nfunction missingEvent(name) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3303 /* RuntimeErrorCode.MISSING_EVENT */, ngDevMode &&\n        `Unable to listen on the animation trigger \"${name}\" because the provided event is undefined!`);\n}\nfunction unsupportedTriggerEvent(phase, name) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3400 /* RuntimeErrorCode.UNSUPPORTED_TRIGGER_EVENT */, ngDevMode &&\n        `The provided animation trigger event \"${phase}\" for the animation trigger \"${name}\" is not supported!`);\n}\nfunction unregisteredTrigger(name) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3401 /* RuntimeErrorCode.UNREGISTERED_TRIGGER */, ngDevMode && `The provided animation trigger \"${name}\" has not been registered!`);\n}\nfunction triggerTransitionsFailed(errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3402 /* RuntimeErrorCode.TRIGGER_TRANSITIONS_FAILED */, ngDevMode &&\n        `Unable to process animations due to the following failed trigger transitions\\n ${errors.map(err => err.message).join('\\n')}`);\n}\nfunction triggerParsingFailed(name, errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3403 /* RuntimeErrorCode.TRIGGER_PARSING_FAILED */, ngDevMode &&\n        `Animation parsing for the ${name} trigger have failed:${LINE_START}${errors.map(err => err.message).join(LINE_START)}`);\n}\nfunction transitionFailed(name, errors) {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵRuntimeError\"](3505 /* RuntimeErrorCode.TRANSITION_FAILED */, ngDevMode && `@${name} has failed due to:\\n ${errors.map(err => err.message).join('\\n- ')}`);\n}\n\n/**\n * Set of all animatable CSS properties\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties\n */\nconst ANIMATABLE_PROP_SET = new Set([\n    '-moz-outline-radius',\n    '-moz-outline-radius-bottomleft',\n    '-moz-outline-radius-bottomright',\n    '-moz-outline-radius-topleft',\n    '-moz-outline-radius-topright',\n    '-ms-grid-columns',\n    '-ms-grid-rows',\n    '-webkit-line-clamp',\n    '-webkit-text-fill-color',\n    '-webkit-text-stroke',\n    '-webkit-text-stroke-color',\n    'accent-color',\n    'all',\n    'backdrop-filter',\n    'background',\n    'background-color',\n    'background-position',\n    'background-size',\n    'block-size',\n    'border',\n    'border-block-end',\n    'border-block-end-color',\n    'border-block-end-width',\n    'border-block-start',\n    'border-block-start-color',\n    'border-block-start-width',\n    'border-bottom',\n    'border-bottom-color',\n    'border-bottom-left-radius',\n    'border-bottom-right-radius',\n    'border-bottom-width',\n    'border-color',\n    'border-end-end-radius',\n    'border-end-start-radius',\n    'border-image-outset',\n    'border-image-slice',\n    'border-image-width',\n    'border-inline-end',\n    'border-inline-end-color',\n    'border-inline-end-width',\n    'border-inline-start',\n    'border-inline-start-color',\n    'border-inline-start-width',\n    'border-left',\n    'border-left-color',\n    'border-left-width',\n    'border-radius',\n    'border-right',\n    'border-right-color',\n    'border-right-width',\n    'border-start-end-radius',\n    'border-start-start-radius',\n    'border-top',\n    'border-top-color',\n    'border-top-left-radius',\n    'border-top-right-radius',\n    'border-top-width',\n    'border-width',\n    'bottom',\n    'box-shadow',\n    'caret-color',\n    'clip',\n    'clip-path',\n    'color',\n    'column-count',\n    'column-gap',\n    'column-rule',\n    'column-rule-color',\n    'column-rule-width',\n    'column-width',\n    'columns',\n    'filter',\n    'flex',\n    'flex-basis',\n    'flex-grow',\n    'flex-shrink',\n    'font',\n    'font-size',\n    'font-size-adjust',\n    'font-stretch',\n    'font-variation-settings',\n    'font-weight',\n    'gap',\n    'grid-column-gap',\n    'grid-gap',\n    'grid-row-gap',\n    'grid-template-columns',\n    'grid-template-rows',\n    'height',\n    'inline-size',\n    'input-security',\n    'inset',\n    'inset-block',\n    'inset-block-end',\n    'inset-block-start',\n    'inset-inline',\n    'inset-inline-end',\n    'inset-inline-start',\n    'left',\n    'letter-spacing',\n    'line-clamp',\n    'line-height',\n    'margin',\n    'margin-block-end',\n    'margin-block-start',\n    'margin-bottom',\n    'margin-inline-end',\n    'margin-inline-start',\n    'margin-left',\n    'margin-right',\n    'margin-top',\n    'mask',\n    'mask-border',\n    'mask-position',\n    'mask-size',\n    'max-block-size',\n    'max-height',\n    'max-inline-size',\n    'max-lines',\n    'max-width',\n    'min-block-size',\n    'min-height',\n    'min-inline-size',\n    'min-width',\n    'object-position',\n    'offset',\n    'offset-anchor',\n    'offset-distance',\n    'offset-path',\n    'offset-position',\n    'offset-rotate',\n    'opacity',\n    'order',\n    'outline',\n    'outline-color',\n    'outline-offset',\n    'outline-width',\n    'padding',\n    'padding-block-end',\n    'padding-block-start',\n    'padding-bottom',\n    'padding-inline-end',\n    'padding-inline-start',\n    'padding-left',\n    'padding-right',\n    'padding-top',\n    'perspective',\n    'perspective-origin',\n    'right',\n    'rotate',\n    'row-gap',\n    'scale',\n    'scroll-margin',\n    'scroll-margin-block',\n    'scroll-margin-block-end',\n    'scroll-margin-block-start',\n    'scroll-margin-bottom',\n    'scroll-margin-inline',\n    'scroll-margin-inline-end',\n    'scroll-margin-inline-start',\n    'scroll-margin-left',\n    'scroll-margin-right',\n    'scroll-margin-top',\n    'scroll-padding',\n    'scroll-padding-block',\n    'scroll-padding-block-end',\n    'scroll-padding-block-start',\n    'scroll-padding-bottom',\n    'scroll-padding-inline',\n    'scroll-padding-inline-end',\n    'scroll-padding-inline-start',\n    'scroll-padding-left',\n    'scroll-padding-right',\n    'scroll-padding-top',\n    'scroll-snap-coordinate',\n    'scroll-snap-destination',\n    'scrollbar-color',\n    'shape-image-threshold',\n    'shape-margin',\n    'shape-outside',\n    'tab-size',\n    'text-decoration',\n    'text-decoration-color',\n    'text-decoration-thickness',\n    'text-emphasis',\n    'text-emphasis-color',\n    'text-indent',\n    'text-shadow',\n    'text-underline-offset',\n    'top',\n    'transform',\n    'transform-origin',\n    'translate',\n    'vertical-align',\n    'visibility',\n    'width',\n    'word-spacing',\n    'z-index',\n    'zoom',\n]);\n\nfunction isBrowser() {\n    return (typeof window !== 'undefined' && typeof window.document !== 'undefined');\n}\nfunction isNode() {\n    // Checking only for `process` isn't enough to identify whether or not we're in a Node\n    // environment, because Webpack by default will polyfill the `process`. While we can discern\n    // that Webpack polyfilled it by looking at `process.browser`, it's very Webpack-specific and\n    // might not be future-proof. Instead we look at the stringified version of `process` which\n    // is `[object process]` in Node and `[object Object]` when polyfilled.\n    return typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n}\nfunction optimizeGroupPlayer(players) {\n    switch (players.length) {\n        case 0:\n            return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__.NoopAnimationPlayer();\n        case 1:\n            return players[0];\n        default:\n            return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__[\"ɵAnimationGroupPlayer\"](players);\n    }\n}\nfunction normalizeKeyframes$1(driver, normalizer, element, keyframes, preStyles = new Map(), postStyles = new Map()) {\n    const errors = [];\n    const normalizedKeyframes = [];\n    let previousOffset = -1;\n    let previousKeyframe = null;\n    keyframes.forEach(kf => {\n        const offset = kf.get('offset');\n        const isSameOffset = offset == previousOffset;\n        const normalizedKeyframe = (isSameOffset && previousKeyframe) || new Map();\n        kf.forEach((val, prop) => {\n            let normalizedProp = prop;\n            let normalizedValue = val;\n            if (prop !== 'offset') {\n                normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n                switch (normalizedValue) {\n                    case _angular_animations__WEBPACK_IMPORTED_MODULE_0__[\"ɵPRE_STYLE\"]:\n                        normalizedValue = preStyles.get(prop);\n                        break;\n                    case _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE:\n                        normalizedValue = postStyles.get(prop);\n                        break;\n                    default:\n                        normalizedValue =\n                            normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n                        break;\n                }\n            }\n            normalizedKeyframe.set(normalizedProp, normalizedValue);\n        });\n        if (!isSameOffset) {\n            normalizedKeyframes.push(normalizedKeyframe);\n        }\n        previousKeyframe = normalizedKeyframe;\n        previousOffset = offset;\n    });\n    if (errors.length) {\n        throw animationFailed(errors);\n    }\n    return normalizedKeyframes;\n}\nfunction listenOnPlayer(player, eventName, event, callback) {\n    switch (eventName) {\n        case 'start':\n            player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player)));\n            break;\n        case 'done':\n            player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player)));\n            break;\n        case 'destroy':\n            player.onDestroy(() => callback(event && copyAnimationEvent(event, 'destroy', player)));\n            break;\n    }\n}\nfunction copyAnimationEvent(e, phaseName, player) {\n    const totalTime = player.totalTime;\n    const disabled = player.disabled ? true : false;\n    const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);\n    const data = e['_data'];\n    if (data != null) {\n        event['_data'] = data;\n    }\n    return event;\n}\nfunction makeAnimationEvent(element, triggerName, fromState, toState, phaseName = '', totalTime = 0, disabled) {\n    return { element, triggerName, fromState, toState, phaseName, totalTime, disabled: !!disabled };\n}\nfunction getOrSetDefaultValue(map, key, defaultValue) {\n    let value = map.get(key);\n    if (!value) {\n        map.set(key, value = defaultValue);\n    }\n    return value;\n}\nfunction parseTimelineCommand(command) {\n    const separatorPos = command.indexOf(':');\n    const id = command.substring(1, separatorPos);\n    const action = command.slice(separatorPos + 1);\n    return [id, action];\n}\nlet _contains = (elm1, elm2) => false;\nlet _query = (element, selector, multi) => {\n    return [];\n};\nlet _documentElement = null;\nfunction getParentElement(element) {\n    const parent = element.parentNode || element.host; // consider host to support shadow DOM\n    if (parent === _documentElement) {\n        return null;\n    }\n    return parent;\n}\n// Define utility methods for browsers and platform-server(domino) where Element\n// and utility methods exist.\nconst _isNode = isNode();\nif (_isNode || typeof Element !== 'undefined') {\n    if (!isBrowser()) {\n        _contains = (elm1, elm2) => elm1.contains(elm2);\n    }\n    else {\n        // Read the document element in an IIFE that's been marked pure to avoid a top-level property\n        // read that may prevent tree-shaking.\n        _documentElement = /* @__PURE__ */ (() => document.documentElement)();\n        _contains = (elm1, elm2) => {\n            while (elm2) {\n                if (elm2 === elm1) {\n                    return true;\n                }\n                elm2 = getParentElement(elm2);\n            }\n            return false;\n        };\n    }\n    _query = (element, selector, multi) => {\n        if (multi) {\n            return Array.from(element.querySelectorAll(selector));\n        }\n        const elem = element.querySelector(selector);\n        return elem ? [elem] : [];\n    };\n}\nfunction containsVendorPrefix(prop) {\n    // Webkit is the only real popular vendor prefix nowadays\n    // cc: http://shouldiprefix.com/\n    return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit\n}\nlet _CACHED_BODY = null;\nlet _IS_WEBKIT = false;\nfunction validateStyleProperty(prop) {\n    if (!_CACHED_BODY) {\n        _CACHED_BODY = getBodyNode() || {};\n        _IS_WEBKIT = _CACHED_BODY.style ? ('WebkitAppearance' in _CACHED_BODY.style) : false;\n    }\n    let result = true;\n    if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {\n        result = prop in _CACHED_BODY.style;\n        if (!result && _IS_WEBKIT) {\n            const camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.slice(1);\n            result = camelProp in _CACHED_BODY.style;\n        }\n    }\n    return result;\n}\nfunction validateWebAnimatableStyleProperty(prop) {\n    return ANIMATABLE_PROP_SET.has(prop);\n}\nfunction getBodyNode() {\n    if (typeof document != 'undefined') {\n        return document.body;\n    }\n    return null;\n}\nconst containsElement = _contains;\nconst invokeQuery = _query;\nfunction hypenatePropsKeys(original) {\n    const newMap = new Map();\n    original.forEach((val, prop) => {\n        const newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');\n        newMap.set(newProp, val);\n    });\n    return newMap;\n}\n\n/**\n * @publicApi\n */\nclass NoopAnimationDriver {\n    validateStyleProperty(prop) {\n        return validateStyleProperty(prop);\n    }\n    matchesElement(_element, _selector) {\n        // This method is deprecated and no longer in use so we return false.\n        return false;\n    }\n    containsElement(elm1, elm2) {\n        return containsElement(elm1, elm2);\n    }\n    getParentElement(element) {\n        return getParentElement(element);\n    }\n    query(element, selector, multi) {\n        return invokeQuery(element, selector, multi);\n    }\n    computeStyle(element, prop, defaultValue) {\n        return defaultValue || '';\n    }\n    animate(element, keyframes, duration, delay, easing, previousPlayers = [], scrubberAccessRequested) {\n        return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__.NoopAnimationPlayer(duration, delay);\n    }\n}\nNoopAnimationDriver.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: NoopAnimationDriver, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nNoopAnimationDriver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: NoopAnimationDriver });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: NoopAnimationDriver, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }] });\n/**\n * @publicApi\n */\nclass AnimationDriver {\n}\nAnimationDriver.NOOP = ( /* @__PURE__ */new NoopAnimationDriver());\n\nconst ONE_SECOND = 1000;\nconst SUBSTITUTION_EXPR_START = '{{';\nconst SUBSTITUTION_EXPR_END = '}}';\nconst ENTER_CLASSNAME = 'ng-enter';\nconst LEAVE_CLASSNAME = 'ng-leave';\nconst NG_TRIGGER_CLASSNAME = 'ng-trigger';\nconst NG_TRIGGER_SELECTOR = '.ng-trigger';\nconst NG_ANIMATING_CLASSNAME = 'ng-animating';\nconst NG_ANIMATING_SELECTOR = '.ng-animating';\nfunction resolveTimingValue(value) {\n    if (typeof value == 'number')\n        return value;\n    const matches = value.match(/^(-?[\\.\\d]+)(m?s)/);\n    if (!matches || matches.length < 2)\n        return 0;\n    return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\nfunction _convertTimeValueToMS(value, unit) {\n    switch (unit) {\n        case 's':\n            return value * ONE_SECOND;\n        default: // ms or something else\n            return value;\n    }\n}\nfunction resolveTiming(timings, errors, allowNegativeValues) {\n    return timings.hasOwnProperty('duration') ?\n        timings :\n        parseTimeExpression(timings, errors, allowNegativeValues);\n}\nfunction parseTimeExpression(exp, errors, allowNegativeValues) {\n    const regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n    let duration;\n    let delay = 0;\n    let easing = '';\n    if (typeof exp === 'string') {\n        const matches = exp.match(regex);\n        if (matches === null) {\n            errors.push(invalidTimingValue(exp));\n            return { duration: 0, delay: 0, easing: '' };\n        }\n        duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n        const delayMatch = matches[3];\n        if (delayMatch != null) {\n            delay = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);\n        }\n        const easingVal = matches[5];\n        if (easingVal) {\n            easing = easingVal;\n        }\n    }\n    else {\n        duration = exp;\n    }\n    if (!allowNegativeValues) {\n        let containsErrors = false;\n        let startIndex = errors.length;\n        if (duration < 0) {\n            errors.push(negativeStepValue());\n            containsErrors = true;\n        }\n        if (delay < 0) {\n            errors.push(negativeDelayValue());\n            containsErrors = true;\n        }\n        if (containsErrors) {\n            errors.splice(startIndex, 0, invalidTimingValue(exp));\n        }\n    }\n    return { duration, delay, easing };\n}\nfunction copyObj(obj, destination = {}) {\n    Object.keys(obj).forEach(prop => {\n        destination[prop] = obj[prop];\n    });\n    return destination;\n}\nfunction convertToMap(obj) {\n    const styleMap = new Map();\n    Object.keys(obj).forEach(prop => {\n        const val = obj[prop];\n        styleMap.set(prop, val);\n    });\n    return styleMap;\n}\nfunction normalizeKeyframes(keyframes) {\n    if (!keyframes.length) {\n        return [];\n    }\n    if (keyframes[0] instanceof Map) {\n        return keyframes;\n    }\n    return keyframes.map(kf => convertToMap(kf));\n}\nfunction normalizeStyles(styles) {\n    const normalizedStyles = new Map();\n    if (Array.isArray(styles)) {\n        styles.forEach(data => copyStyles(data, normalizedStyles));\n    }\n    else {\n        copyStyles(styles, normalizedStyles);\n    }\n    return normalizedStyles;\n}\nfunction copyStyles(styles, destination = new Map(), backfill) {\n    if (backfill) {\n        for (let [prop, val] of backfill) {\n            destination.set(prop, val);\n        }\n    }\n    for (let [prop, val] of styles) {\n        destination.set(prop, val);\n    }\n    return destination;\n}\nfunction getStyleAttributeString(element, key, value) {\n    // Return the key-value pair string to be added to the style attribute for the\n    // given CSS style key.\n    if (value) {\n        return key + ':' + value + ';';\n    }\n    else {\n        return '';\n    }\n}\nfunction writeStyleAttribute(element) {\n    // Read the style property of the element and manually reflect it to the\n    // style attribute. This is needed because Domino on platform-server doesn't\n    // understand the full set of allowed CSS properties and doesn't reflect some\n    // of them automatically.\n    let styleAttrValue = '';\n    for (let i = 0; i < element.style.length; i++) {\n        const key = element.style.item(i);\n        styleAttrValue += getStyleAttributeString(element, key, element.style.getPropertyValue(key));\n    }\n    for (const key in element.style) {\n        // Skip internal Domino properties that don't need to be reflected.\n        if (!element.style.hasOwnProperty(key) || key.startsWith('_')) {\n            continue;\n        }\n        const dashKey = camelCaseToDashCase(key);\n        styleAttrValue += getStyleAttributeString(element, dashKey, element.style[key]);\n    }\n    element.setAttribute('style', styleAttrValue);\n}\nfunction setStyles(element, styles, formerStyles) {\n    if (element['style']) {\n        styles.forEach((val, prop) => {\n            const camelProp = dashCaseToCamelCase(prop);\n            if (formerStyles && !formerStyles.has(prop)) {\n                formerStyles.set(prop, element.style[camelProp]);\n            }\n            element.style[camelProp] = val;\n        });\n        // On the server set the 'style' attribute since it's not automatically reflected.\n        if (isNode()) {\n            writeStyleAttribute(element);\n        }\n    }\n}\nfunction eraseStyles(element, styles) {\n    if (element['style']) {\n        styles.forEach((_, prop) => {\n            const camelProp = dashCaseToCamelCase(prop);\n            element.style[camelProp] = '';\n        });\n        // On the server set the 'style' attribute since it's not automatically reflected.\n        if (isNode()) {\n            writeStyleAttribute(element);\n        }\n    }\n}\nfunction normalizeAnimationEntry(steps) {\n    if (Array.isArray(steps)) {\n        if (steps.length == 1)\n            return steps[0];\n        return (0,_angular_animations__WEBPACK_IMPORTED_MODULE_0__.sequence)(steps);\n    }\n    return steps;\n}\nfunction validateStyleParams(value, options, errors) {\n    const params = options.params || {};\n    const matches = extractStyleParams(value);\n    if (matches.length) {\n        matches.forEach(varName => {\n            if (!params.hasOwnProperty(varName)) {\n                errors.push(invalidStyleParams(varName));\n            }\n        });\n    }\n}\nconst PARAM_REGEX = new RegExp(`${SUBSTITUTION_EXPR_START}\\\\s*(.+?)\\\\s*${SUBSTITUTION_EXPR_END}`, 'g');\nfunction extractStyleParams(value) {\n    let params = [];\n    if (typeof value === 'string') {\n        let match;\n        while (match = PARAM_REGEX.exec(value)) {\n            params.push(match[1]);\n        }\n        PARAM_REGEX.lastIndex = 0;\n    }\n    return params;\n}\nfunction interpolateParams(value, params, errors) {\n    const original = value.toString();\n    const str = original.replace(PARAM_REGEX, (_, varName) => {\n        let localVal = params[varName];\n        // this means that the value was never overridden by the data passed in by the user\n        if (localVal == null) {\n            errors.push(invalidParamValue(varName));\n            localVal = '';\n        }\n        return localVal.toString();\n    });\n    // we do this to assert that numeric values stay as they are\n    return str == original ? value : str;\n}\nfunction iteratorToArray(iterator) {\n    const arr = [];\n    let item = iterator.next();\n    while (!item.done) {\n        arr.push(item.value);\n        item = iterator.next();\n    }\n    return arr;\n}\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction camelCaseToDashCase(input) {\n    return input.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\nfunction allowPreviousPlayerStylesMerge(duration, delay) {\n    return duration === 0 || delay === 0;\n}\nfunction balancePreviousStylesIntoKeyframes(element, keyframes, previousStyles) {\n    if (previousStyles.size && keyframes.length) {\n        let startingKeyframe = keyframes[0];\n        let missingStyleProps = [];\n        previousStyles.forEach((val, prop) => {\n            if (!startingKeyframe.has(prop)) {\n                missingStyleProps.push(prop);\n            }\n            startingKeyframe.set(prop, val);\n        });\n        if (missingStyleProps.length) {\n            for (let i = 1; i < keyframes.length; i++) {\n                let kf = keyframes[i];\n                missingStyleProps.forEach(prop => kf.set(prop, computeStyle(element, prop)));\n            }\n        }\n    }\n    return keyframes;\n}\nfunction visitDslNode(visitor, node, context) {\n    switch (node.type) {\n        case 7 /* AnimationMetadataType.Trigger */:\n            return visitor.visitTrigger(node, context);\n        case 0 /* AnimationMetadataType.State */:\n            return visitor.visitState(node, context);\n        case 1 /* AnimationMetadataType.Transition */:\n            return visitor.visitTransition(node, context);\n        case 2 /* AnimationMetadataType.Sequence */:\n            return visitor.visitSequence(node, context);\n        case 3 /* AnimationMetadataType.Group */:\n            return visitor.visitGroup(node, context);\n        case 4 /* AnimationMetadataType.Animate */:\n            return visitor.visitAnimate(node, context);\n        case 5 /* AnimationMetadataType.Keyframes */:\n            return visitor.visitKeyframes(node, context);\n        case 6 /* AnimationMetadataType.Style */:\n            return visitor.visitStyle(node, context);\n        case 8 /* AnimationMetadataType.Reference */:\n            return visitor.visitReference(node, context);\n        case 9 /* AnimationMetadataType.AnimateChild */:\n            return visitor.visitAnimateChild(node, context);\n        case 10 /* AnimationMetadataType.AnimateRef */:\n            return visitor.visitAnimateRef(node, context);\n        case 11 /* AnimationMetadataType.Query */:\n            return visitor.visitQuery(node, context);\n        case 12 /* AnimationMetadataType.Stagger */:\n            return visitor.visitStagger(node, context);\n        default:\n            throw invalidNodeType(node.type);\n    }\n}\nfunction computeStyle(element, prop) {\n    return window.getComputedStyle(element)[prop];\n}\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\nfunction createListOfWarnings(warnings) {\n    const LINE_START = '\\n - ';\n    return `${LINE_START}${warnings.filter(Boolean).map(warning => warning).join(LINE_START)}`;\n}\nfunction warnValidation(warnings) {\n    NG_DEV_MODE && console.warn(`animation validation warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnTriggerBuild(name, warnings) {\n    NG_DEV_MODE &&\n        console.warn(`The animation trigger \"${name}\" has built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction warnRegister(warnings) {\n    NG_DEV_MODE &&\n        console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction triggerParsingWarnings(name, warnings) {\n    NG_DEV_MODE &&\n        console.warn(`Animation parsing for the ${name} trigger presents the following warnings:${createListOfWarnings(warnings)}`);\n}\nfunction pushUnrecognizedPropertiesWarning(warnings, props) {\n    if (props.length) {\n        warnings.push(`The following provided properties are not recognized: ${props.join(', ')}`);\n    }\n}\n\nconst ANY_STATE = '*';\nfunction parseTransitionExpr(transitionValue, errors) {\n    const expressions = [];\n    if (typeof transitionValue == 'string') {\n        transitionValue.split(/\\s*,\\s*/).forEach(str => parseInnerTransitionStr(str, expressions, errors));\n    }\n    else {\n        expressions.push(transitionValue);\n    }\n    return expressions;\n}\nfunction parseInnerTransitionStr(eventStr, expressions, errors) {\n    if (eventStr[0] == ':') {\n        const result = parseAnimationAlias(eventStr, errors);\n        if (typeof result == 'function') {\n            expressions.push(result);\n            return;\n        }\n        eventStr = result;\n    }\n    const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n    if (match == null || match.length < 4) {\n        errors.push(invalidExpression(eventStr));\n        return expressions;\n    }\n    const fromState = match[1];\n    const separator = match[2];\n    const toState = match[3];\n    expressions.push(makeLambdaFromStates(fromState, toState));\n    const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n    if (separator[0] == '<' && !isFullAnyStateExpr) {\n        expressions.push(makeLambdaFromStates(toState, fromState));\n    }\n}\nfunction parseAnimationAlias(alias, errors) {\n    switch (alias) {\n        case ':enter':\n            return 'void => *';\n        case ':leave':\n            return '* => void';\n        case ':increment':\n            return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);\n        case ':decrement':\n            return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);\n        default:\n            errors.push(invalidTransitionAlias(alias));\n            return '* => *';\n    }\n}\n// DO NOT REFACTOR ... keep the follow set instantiations\n// with the values intact (closure compiler for some reason\n// removes follow-up lines that add the values outside of\n// the constructor...\nconst TRUE_BOOLEAN_VALUES = new Set(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set(['false', '0']);\nfunction makeLambdaFromStates(lhs, rhs) {\n    const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n    const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n    return (fromState, toState) => {\n        let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n        let rhsMatch = rhs == ANY_STATE || rhs == toState;\n        if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n            lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n        }\n        if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n            rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n        }\n        return lhsMatch && rhsMatch;\n    };\n}\n\nconst SELF_TOKEN = ':self';\nconst SELF_TOKEN_REGEX = new RegExp(`\\s*${SELF_TOKEN}\\s*,?`, 'g');\n/*\n * [Validation]\n * The visitor code below will traverse the animation AST generated by the animation verb functions\n * (the output is a tree of objects) and attempt to perform a series of validations on the data. The\n * following corner-cases will be validated:\n *\n * 1. Overlap of animations\n * Given that a CSS property cannot be animated in more than one place at the same time, it's\n * important that this behavior is detected and validated. The way in which this occurs is that\n * each time a style property is examined, a string-map containing the property will be updated with\n * the start and end times for when the property is used within an animation step.\n *\n * If there are two or more parallel animations that are currently running (these are invoked by the\n * group()) on the same element then the validator will throw an error. Since the start/end timing\n * values are collected for each property then if the current animation step is animating the same\n * property and its timing values fall anywhere into the window of time that the property is\n * currently being animated within then this is what causes an error.\n *\n * 2. Timing values\n * The validator will validate to see if a timing value of `duration delay easing` or\n * `durationNumber` is valid or not.\n *\n * (note that upon validation the code below will replace the timing data with an object containing\n * {duration,delay,easing}.\n *\n * 3. Offset Validation\n * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().\n * Offsets within keyframes() are considered valid when:\n *\n *   - No offsets are used at all\n *   - Each style() entry contains an offset value\n *   - Each offset is between 0 and 1\n *   - Each offset is greater to or equal than the previous one\n *\n * Otherwise an error will be thrown.\n */\nfunction buildAnimationAst(driver, metadata, errors, warnings) {\n    return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);\n}\nconst ROOT_SELECTOR = '';\nclass AnimationAstBuilderVisitor {\n    constructor(_driver) {\n        this._driver = _driver;\n    }\n    build(metadata, errors, warnings) {\n        const context = new AnimationAstBuilderContext(errors);\n        this._resetContextStyleTimingState(context);\n        const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (context.unsupportedCSSPropertiesFound.size) {\n                pushUnrecognizedPropertiesWarning(warnings, [...context.unsupportedCSSPropertiesFound.keys()]);\n            }\n        }\n        return ast;\n    }\n    _resetContextStyleTimingState(context) {\n        context.currentQuerySelector = ROOT_SELECTOR;\n        context.collectedStyles = new Map();\n        context.collectedStyles.set(ROOT_SELECTOR, new Map());\n        context.currentTime = 0;\n    }\n    visitTrigger(metadata, context) {\n        let queryCount = context.queryCount = 0;\n        let depCount = context.depCount = 0;\n        const states = [];\n        const transitions = [];\n        if (metadata.name.charAt(0) == '@') {\n            context.errors.push(invalidTrigger());\n        }\n        metadata.definitions.forEach(def => {\n            this._resetContextStyleTimingState(context);\n            if (def.type == 0 /* AnimationMetadataType.State */) {\n                const stateDef = def;\n                const name = stateDef.name;\n                name.toString().split(/\\s*,\\s*/).forEach(n => {\n                    stateDef.name = n;\n                    states.push(this.visitState(stateDef, context));\n                });\n                stateDef.name = name;\n            }\n            else if (def.type == 1 /* AnimationMetadataType.Transition */) {\n                const transition = this.visitTransition(def, context);\n                queryCount += transition.queryCount;\n                depCount += transition.depCount;\n                transitions.push(transition);\n            }\n            else {\n                context.errors.push(invalidDefinition());\n            }\n        });\n        return {\n            type: 7 /* AnimationMetadataType.Trigger */,\n            name: metadata.name,\n            states,\n            transitions,\n            queryCount,\n            depCount,\n            options: null\n        };\n    }\n    visitState(metadata, context) {\n        const styleAst = this.visitStyle(metadata.styles, context);\n        const astParams = (metadata.options && metadata.options.params) || null;\n        if (styleAst.containsDynamicStyles) {\n            const missingSubs = new Set();\n            const params = astParams || {};\n            styleAst.styles.forEach(style => {\n                if (style instanceof Map) {\n                    style.forEach(value => {\n                        extractStyleParams(value).forEach(sub => {\n                            if (!params.hasOwnProperty(sub)) {\n                                missingSubs.add(sub);\n                            }\n                        });\n                    });\n                }\n            });\n            if (missingSubs.size) {\n                const missingSubsArr = iteratorToArray(missingSubs.values());\n                context.errors.push(invalidState(metadata.name, missingSubsArr));\n            }\n        }\n        return {\n            type: 0 /* AnimationMetadataType.State */,\n            name: metadata.name,\n            style: styleAst,\n            options: astParams ? { params: astParams } : null\n        };\n    }\n    visitTransition(metadata, context) {\n        context.queryCount = 0;\n        context.depCount = 0;\n        const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n        const matchers = parseTransitionExpr(metadata.expr, context.errors);\n        return {\n            type: 1 /* AnimationMetadataType.Transition */,\n            matchers,\n            animation,\n            queryCount: context.queryCount,\n            depCount: context.depCount,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitSequence(metadata, context) {\n        return {\n            type: 2 /* AnimationMetadataType.Sequence */,\n            steps: metadata.steps.map(s => visitDslNode(this, s, context)),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitGroup(metadata, context) {\n        const currentTime = context.currentTime;\n        let furthestTime = 0;\n        const steps = metadata.steps.map(step => {\n            context.currentTime = currentTime;\n            const innerAst = visitDslNode(this, step, context);\n            furthestTime = Math.max(furthestTime, context.currentTime);\n            return innerAst;\n        });\n        context.currentTime = furthestTime;\n        return {\n            type: 3 /* AnimationMetadataType.Group */,\n            steps,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitAnimate(metadata, context) {\n        const timingAst = constructTimingAst(metadata.timings, context.errors);\n        context.currentAnimateTimings = timingAst;\n        let styleAst;\n        let styleMetadata = metadata.styles ? metadata.styles : (0,_angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)({});\n        if (styleMetadata.type == 5 /* AnimationMetadataType.Keyframes */) {\n            styleAst = this.visitKeyframes(styleMetadata, context);\n        }\n        else {\n            let styleMetadata = metadata.styles;\n            let isEmpty = false;\n            if (!styleMetadata) {\n                isEmpty = true;\n                const newStyleData = {};\n                if (timingAst.easing) {\n                    newStyleData['easing'] = timingAst.easing;\n                }\n                styleMetadata = (0,_angular_animations__WEBPACK_IMPORTED_MODULE_0__.style)(newStyleData);\n            }\n            context.currentTime += timingAst.duration + timingAst.delay;\n            const _styleAst = this.visitStyle(styleMetadata, context);\n            _styleAst.isEmptyStep = isEmpty;\n            styleAst = _styleAst;\n        }\n        context.currentAnimateTimings = null;\n        return {\n            type: 4 /* AnimationMetadataType.Animate */,\n            timings: timingAst,\n            style: styleAst,\n            options: null\n        };\n    }\n    visitStyle(metadata, context) {\n        const ast = this._makeStyleAst(metadata, context);\n        this._validateStyleAst(ast, context);\n        return ast;\n    }\n    _makeStyleAst(metadata, context) {\n        const styles = [];\n        const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];\n        for (let styleTuple of metadataStyles) {\n            if (typeof styleTuple === 'string') {\n                if (styleTuple === _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE) {\n                    styles.push(styleTuple);\n                }\n                else {\n                    context.errors.push(invalidStyleValue(styleTuple));\n                }\n            }\n            else {\n                styles.push(convertToMap(styleTuple));\n            }\n        }\n        let containsDynamicStyles = false;\n        let collectedEasing = null;\n        styles.forEach(styleData => {\n            if (styleData instanceof Map) {\n                if (styleData.has('easing')) {\n                    collectedEasing = styleData.get('easing');\n                    styleData.delete('easing');\n                }\n                if (!containsDynamicStyles) {\n                    for (let value of styleData.values()) {\n                        if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {\n                            containsDynamicStyles = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        return {\n            type: 6 /* AnimationMetadataType.Style */,\n            styles,\n            easing: collectedEasing,\n            offset: metadata.offset,\n            containsDynamicStyles,\n            options: null\n        };\n    }\n    _validateStyleAst(ast, context) {\n        const timings = context.currentAnimateTimings;\n        let endTime = context.currentTime;\n        let startTime = context.currentTime;\n        if (timings && startTime > 0) {\n            startTime -= timings.duration + timings.delay;\n        }\n        ast.styles.forEach(tuple => {\n            if (typeof tuple === 'string')\n                return;\n            tuple.forEach((value, prop) => {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    if (!this._driver.validateStyleProperty(prop)) {\n                        tuple.delete(prop);\n                        context.unsupportedCSSPropertiesFound.add(prop);\n                        return;\n                    }\n                }\n                // This is guaranteed to have a defined Map at this querySelector location making it\n                // safe to add the assertion here. It is set as a default empty map in prior methods.\n                const collectedStyles = context.collectedStyles.get(context.currentQuerySelector);\n                const collectedEntry = collectedStyles.get(prop);\n                let updateCollectedStyle = true;\n                if (collectedEntry) {\n                    if (startTime != endTime && startTime >= collectedEntry.startTime &&\n                        endTime <= collectedEntry.endTime) {\n                        context.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));\n                        updateCollectedStyle = false;\n                    }\n                    // we always choose the smaller start time value since we\n                    // want to have a record of the entire animation window where\n                    // the style property is being animated in between\n                    startTime = collectedEntry.startTime;\n                }\n                if (updateCollectedStyle) {\n                    collectedStyles.set(prop, { startTime, endTime });\n                }\n                if (context.options) {\n                    validateStyleParams(value, context.options, context.errors);\n                }\n            });\n        });\n    }\n    visitKeyframes(metadata, context) {\n        const ast = { type: 5 /* AnimationMetadataType.Keyframes */, styles: [], options: null };\n        if (!context.currentAnimateTimings) {\n            context.errors.push(invalidKeyframes());\n            return ast;\n        }\n        const MAX_KEYFRAME_OFFSET = 1;\n        let totalKeyframesWithOffsets = 0;\n        const offsets = [];\n        let offsetsOutOfOrder = false;\n        let keyframesOutOfRange = false;\n        let previousOffset = 0;\n        const keyframes = metadata.steps.map(styles => {\n            const style = this._makeStyleAst(styles, context);\n            let offsetVal = style.offset != null ? style.offset : consumeOffset(style.styles);\n            let offset = 0;\n            if (offsetVal != null) {\n                totalKeyframesWithOffsets++;\n                offset = style.offset = offsetVal;\n            }\n            keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;\n            offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;\n            previousOffset = offset;\n            offsets.push(offset);\n            return style;\n        });\n        if (keyframesOutOfRange) {\n            context.errors.push(invalidOffset());\n        }\n        if (offsetsOutOfOrder) {\n            context.errors.push(keyframeOffsetsOutOfOrder());\n        }\n        const length = metadata.steps.length;\n        let generatedOffset = 0;\n        if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {\n            context.errors.push(keyframesMissingOffsets());\n        }\n        else if (totalKeyframesWithOffsets == 0) {\n            generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);\n        }\n        const limit = length - 1;\n        const currentTime = context.currentTime;\n        const currentAnimateTimings = context.currentAnimateTimings;\n        const animateDuration = currentAnimateTimings.duration;\n        keyframes.forEach((kf, i) => {\n            const offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];\n            const durationUpToThisFrame = offset * animateDuration;\n            context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;\n            currentAnimateTimings.duration = durationUpToThisFrame;\n            this._validateStyleAst(kf, context);\n            kf.offset = offset;\n            ast.styles.push(kf);\n        });\n        return ast;\n    }\n    visitReference(metadata, context) {\n        return {\n            type: 8 /* AnimationMetadataType.Reference */,\n            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitAnimateChild(metadata, context) {\n        context.depCount++;\n        return {\n            type: 9 /* AnimationMetadataType.AnimateChild */,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitAnimateRef(metadata, context) {\n        return {\n            type: 10 /* AnimationMetadataType.AnimateRef */,\n            animation: this.visitReference(metadata.animation, context),\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitQuery(metadata, context) {\n        const parentSelector = context.currentQuerySelector;\n        const options = (metadata.options || {});\n        context.queryCount++;\n        context.currentQuery = metadata;\n        const [selector, includeSelf] = normalizeSelector(metadata.selector);\n        context.currentQuerySelector =\n            parentSelector.length ? (parentSelector + ' ' + selector) : selector;\n        getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, new Map());\n        const animation = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);\n        context.currentQuery = null;\n        context.currentQuerySelector = parentSelector;\n        return {\n            type: 11 /* AnimationMetadataType.Query */,\n            selector,\n            limit: options.limit || 0,\n            optional: !!options.optional,\n            includeSelf,\n            animation,\n            originalSelector: metadata.selector,\n            options: normalizeAnimationOptions(metadata.options)\n        };\n    }\n    visitStagger(metadata, context) {\n        if (!context.currentQuery) {\n            context.errors.push(invalidStagger());\n        }\n        const timings = metadata.timings === 'full' ?\n            { duration: 0, delay: 0, easing: 'full' } :\n            resolveTiming(metadata.timings, context.errors, true);\n        return {\n            type: 12 /* AnimationMetadataType.Stagger */,\n            animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),\n            timings,\n            options: null\n        };\n    }\n}\nfunction normalizeSelector(selector) {\n    const hasAmpersand = selector.split(/\\s*,\\s*/).find(token => token == SELF_TOKEN) ? true : false;\n    if (hasAmpersand) {\n        selector = selector.replace(SELF_TOKEN_REGEX, '');\n    }\n    // Note: the :enter and :leave aren't normalized here since those\n    // selectors are filled in at runtime during timeline building\n    selector = selector.replace(/@\\*/g, NG_TRIGGER_SELECTOR)\n        .replace(/@\\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.slice(1))\n        .replace(/:animating/g, NG_ANIMATING_SELECTOR);\n    return [selector, hasAmpersand];\n}\nfunction normalizeParams(obj) {\n    return obj ? copyObj(obj) : null;\n}\nclass AnimationAstBuilderContext {\n    constructor(errors) {\n        this.errors = errors;\n        this.queryCount = 0;\n        this.depCount = 0;\n        this.currentTransition = null;\n        this.currentQuery = null;\n        this.currentQuerySelector = null;\n        this.currentAnimateTimings = null;\n        this.currentTime = 0;\n        this.collectedStyles = new Map();\n        this.options = null;\n        this.unsupportedCSSPropertiesFound = new Set();\n    }\n}\nfunction consumeOffset(styles) {\n    if (typeof styles == 'string')\n        return null;\n    let offset = null;\n    if (Array.isArray(styles)) {\n        styles.forEach(styleTuple => {\n            if (styleTuple instanceof Map && styleTuple.has('offset')) {\n                const obj = styleTuple;\n                offset = parseFloat(obj.get('offset'));\n                obj.delete('offset');\n            }\n        });\n    }\n    else if (styles instanceof Map && styles.has('offset')) {\n        const obj = styles;\n        offset = parseFloat(obj.get('offset'));\n        obj.delete('offset');\n    }\n    return offset;\n}\nfunction constructTimingAst(value, errors) {\n    if (value.hasOwnProperty('duration')) {\n        return value;\n    }\n    if (typeof value == 'number') {\n        const duration = resolveTiming(value, errors).duration;\n        return makeTimingAst(duration, 0, '');\n    }\n    const strValue = value;\n    const isDynamic = strValue.split(/\\s+/).some(v => v.charAt(0) == '{' && v.charAt(1) == '{');\n    if (isDynamic) {\n        const ast = makeTimingAst(0, 0, '');\n        ast.dynamic = true;\n        ast.strValue = strValue;\n        return ast;\n    }\n    const timings = resolveTiming(strValue, errors);\n    return makeTimingAst(timings.duration, timings.delay, timings.easing);\n}\nfunction normalizeAnimationOptions(options) {\n    if (options) {\n        options = copyObj(options);\n        if (options['params']) {\n            options['params'] = normalizeParams(options['params']);\n        }\n    }\n    else {\n        options = {};\n    }\n    return options;\n}\nfunction makeTimingAst(duration, delay, easing) {\n    return { duration, delay, easing };\n}\n\nfunction createTimelineInstruction(element, keyframes, preStyleProps, postStyleProps, duration, delay, easing = null, subTimeline = false) {\n    return {\n        type: 1 /* AnimationTransitionInstructionType.TimelineAnimation */,\n        element,\n        keyframes,\n        preStyleProps,\n        postStyleProps,\n        duration,\n        delay,\n        totalTime: duration + delay,\n        easing,\n        subTimeline\n    };\n}\n\nclass ElementInstructionMap {\n    constructor() {\n        this._map = new Map();\n    }\n    get(element) {\n        return this._map.get(element) || [];\n    }\n    append(element, instructions) {\n        let existingInstructions = this._map.get(element);\n        if (!existingInstructions) {\n            this._map.set(element, existingInstructions = []);\n        }\n        existingInstructions.push(...instructions);\n    }\n    has(element) {\n        return this._map.has(element);\n    }\n    clear() {\n        this._map.clear();\n    }\n}\n\nconst ONE_FRAME_IN_MILLISECONDS = 1;\nconst ENTER_TOKEN = ':enter';\nconst ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\nconst LEAVE_TOKEN = ':leave';\nconst LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n/*\n * The code within this file aims to generate web-animations-compatible keyframes from Angular's\n * animation DSL code.\n *\n * The code below will be converted from:\n *\n * ```\n * sequence([\n *   style({ opacity: 0 }),\n *   animate(1000, style({ opacity: 0 }))\n * ])\n * ```\n *\n * To:\n * ```\n * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]\n * duration = 1000\n * delay = 0\n * easing = ''\n * ```\n *\n * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a\n * combination of AST traversal and merge-sort-like algorithms are used.\n *\n * [AST Traversal]\n * Each of the animation verbs, when executed, will return an string-map object representing what\n * type of action it is (style, animate, group, etc...) and the data associated with it. This means\n * that when functional composition mix of these functions is evaluated (like in the example above)\n * then it will end up producing a tree of objects representing the animation itself.\n *\n * When this animation object tree is processed by the visitor code below it will visit each of the\n * verb statements within the visitor. And during each visit it will build the context of the\n * animation keyframes by interacting with the `TimelineBuilder`.\n *\n * [TimelineBuilder]\n * This class is responsible for tracking the styles and building a series of keyframe objects for a\n * timeline between a start and end time. The builder starts off with an initial timeline and each\n * time the AST comes across a `group()`, `keyframes()` or a combination of the two within a\n * `sequence()` then it will generate a sub timeline for each step as well as a new one after\n * they are complete.\n *\n * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub\n * timeline was created (based on one of the cases above) then the parent timeline will attempt to\n * merge the styles used within the sub timelines into itself (only with group() this will happen).\n * This happens with a merge operation (much like how the merge works in mergeSort) and it will only\n * copy the most recently used styles from the sub timelines into the parent timeline. This ensures\n * that if the styles are used later on in another phase of the animation then they will be the most\n * up-to-date values.\n *\n * [How Missing Styles Are Updated]\n * Each timeline has a `backFill` property which is responsible for filling in new styles into\n * already processed keyframes if a new style shows up later within the animation sequence.\n *\n * ```\n * sequence([\n *   style({ width: 0 }),\n *   animate(1000, style({ width: 100 })),\n *   animate(1000, style({ width: 200 })),\n *   animate(1000, style({ width: 300 }))\n *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere\n * else\n * ])\n * ```\n *\n * What is happening here is that the `height` value is added later in the sequence, but is missing\n * from all previous animation steps. Therefore when a keyframe is created it would also be missing\n * from all previous keyframes up until where it is first used. For the timeline keyframe generation\n * to properly fill in the style it will place the previous value (the value from the parent\n * timeline) or a default value of `*` into the backFill map. The `copyStyles` method in util.ts\n * handles propagating that backfill map to the styles object.\n *\n * When a sub-timeline is created it will have its own backFill property. This is done so that\n * styles present within the sub-timeline do not accidentally seep into the previous/future timeline\n * keyframes\n *\n * [Validation]\n * The code in this file is not responsible for validation. That functionality happens with within\n * the `AnimationValidatorVisitor` code.\n */\nfunction buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = new Map(), finalStyles = new Map(), options, subInstructions, errors = []) {\n    return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);\n}\nclass AnimationTimelineBuilderVisitor {\n    buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {\n        subInstructions = subInstructions || new ElementInstructionMap();\n        const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n        context.options = options;\n        const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n        context.currentTimeline.delayNextStep(delay);\n        context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n        visitDslNode(this, ast, context);\n        // this checks to see if an actual animation happened\n        const timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n        // note: we just want to apply the final styles for the rootElement, so we do not\n        //       just apply the styles to the last timeline but the last timeline which\n        //       element is the root one (basically `*`-styles are replaced with the actual\n        //       state style values only for the root element)\n        if (timelines.length && finalStyles.size) {\n            let lastRootTimeline;\n            for (let i = timelines.length - 1; i >= 0; i--) {\n                const timeline = timelines[i];\n                if (timeline.element === rootElement) {\n                    lastRootTimeline = timeline;\n                    break;\n                }\n            }\n            if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {\n                lastRootTimeline.setStyles([finalStyles], null, context.errors, options);\n            }\n        }\n        return timelines.length ?\n            timelines.map(timeline => timeline.buildKeyframes()) :\n            [createTimelineInstruction(rootElement, [], [], [], 0, delay, '', false)];\n    }\n    visitTrigger(ast, context) {\n        // these values are not visited in this AST\n    }\n    visitState(ast, context) {\n        // these values are not visited in this AST\n    }\n    visitTransition(ast, context) {\n        // these values are not visited in this AST\n    }\n    visitAnimateChild(ast, context) {\n        const elementInstructions = context.subInstructions.get(context.element);\n        if (elementInstructions) {\n            const innerContext = context.createSubContext(ast.options);\n            const startTime = context.currentTimeline.currentTime;\n            const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);\n            if (startTime != endTime) {\n                // we do this on the upper context because we created a sub context for\n                // the sub child animations\n                context.transformIntoNewTimeline(endTime);\n            }\n        }\n        context.previousNode = ast;\n    }\n    visitAnimateRef(ast, context) {\n        const innerContext = context.createSubContext(ast.options);\n        innerContext.transformIntoNewTimeline();\n        this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);\n        this.visitReference(ast.animation, innerContext);\n        context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n        context.previousNode = ast;\n    }\n    _applyAnimationRefDelays(animationsRefsOptions, context, innerContext) {\n        for (const animationRefOptions of animationsRefsOptions) {\n            const animationDelay = animationRefOptions?.delay;\n            if (animationDelay) {\n                const animationDelayValue = typeof animationDelay === 'number' ?\n                    animationDelay :\n                    resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context.errors));\n                innerContext.delayNextStep(animationDelayValue);\n            }\n        }\n    }\n    _visitSubInstructions(instructions, context, options) {\n        const startTime = context.currentTimeline.currentTime;\n        let furthestTime = startTime;\n        // this is a special-case for when a user wants to skip a sub\n        // animation from being fired entirely.\n        const duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n        const delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n        if (duration !== 0) {\n            instructions.forEach(instruction => {\n                const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay);\n                furthestTime =\n                    Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n            });\n        }\n        return furthestTime;\n    }\n    visitReference(ast, context) {\n        context.updateOptions(ast.options, true);\n        visitDslNode(this, ast.animation, context);\n        context.previousNode = ast;\n    }\n    visitSequence(ast, context) {\n        const subContextCount = context.subContextCount;\n        let ctx = context;\n        const options = ast.options;\n        if (options && (options.params || options.delay)) {\n            ctx = context.createSubContext(options);\n            ctx.transformIntoNewTimeline();\n            if (options.delay != null) {\n                if (ctx.previousNode.type == 6 /* AnimationMetadataType.Style */) {\n                    ctx.currentTimeline.snapshotCurrentStyles();\n                    ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n                }\n                const delay = resolveTimingValue(options.delay);\n                ctx.delayNextStep(delay);\n            }\n        }\n        if (ast.steps.length) {\n            ast.steps.forEach(s => visitDslNode(this, s, ctx));\n            // this is here just in case the inner steps only contain or end with a style() call\n            ctx.currentTimeline.applyStylesToKeyframe();\n            // this means that some animation function within the sequence\n            // ended up creating a sub timeline (which means the current\n            // timeline cannot overlap with the contents of the sequence)\n            if (ctx.subContextCount > subContextCount) {\n                ctx.transformIntoNewTimeline();\n            }\n        }\n        context.previousNode = ast;\n    }\n    visitGroup(ast, context) {\n        const innerTimelines = [];\n        let furthestTime = context.currentTimeline.currentTime;\n        const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n        ast.steps.forEach(s => {\n            const innerContext = context.createSubContext(ast.options);\n            if (delay) {\n                innerContext.delayNextStep(delay);\n            }\n            visitDslNode(this, s, innerContext);\n            furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n            innerTimelines.push(innerContext.currentTimeline);\n        });\n        // this operation is run after the AST loop because otherwise\n        // if the parent timeline's collected styles were updated then\n        // it would pass in invalid data into the new-to-be forked items\n        innerTimelines.forEach(timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n        context.transformIntoNewTimeline(furthestTime);\n        context.previousNode = ast;\n    }\n    _visitTiming(ast, context) {\n        if (ast.dynamic) {\n            const strValue = ast.strValue;\n            const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n            return resolveTiming(timingValue, context.errors);\n        }\n        else {\n            return { duration: ast.duration, delay: ast.delay, easing: ast.easing };\n        }\n    }\n    visitAnimate(ast, context) {\n        const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n        const timeline = context.currentTimeline;\n        if (timings.delay) {\n            context.incrementTime(timings.delay);\n            timeline.snapshotCurrentStyles();\n        }\n        const style = ast.style;\n        if (style.type == 5 /* AnimationMetadataType.Keyframes */) {\n            this.visitKeyframes(style, context);\n        }\n        else {\n            context.incrementTime(timings.duration);\n            this.visitStyle(style, context);\n            timeline.applyStylesToKeyframe();\n        }\n        context.currentAnimateTimings = null;\n        context.previousNode = ast;\n    }\n    visitStyle(ast, context) {\n        const timeline = context.currentTimeline;\n        const timings = context.currentAnimateTimings;\n        // this is a special case for when a style() call\n        // directly follows  an animate() call (but not inside of an animate() call)\n        if (!timings && timeline.hasCurrentStyleProperties()) {\n            timeline.forwardFrame();\n        }\n        const easing = (timings && timings.easing) || ast.easing;\n        if (ast.isEmptyStep) {\n            timeline.applyEmptyStep(easing);\n        }\n        else {\n            timeline.setStyles(ast.styles, easing, context.errors, context.options);\n        }\n        context.previousNode = ast;\n    }\n    visitKeyframes(ast, context) {\n        const currentAnimateTimings = context.currentAnimateTimings;\n        const startTime = (context.currentTimeline).duration;\n        const duration = currentAnimateTimings.duration;\n        const innerContext = context.createSubContext();\n        const innerTimeline = innerContext.currentTimeline;\n        innerTimeline.easing = currentAnimateTimings.easing;\n        ast.styles.forEach(step => {\n            const offset = step.offset || 0;\n            innerTimeline.forwardTime(offset * duration);\n            innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n            innerTimeline.applyStylesToKeyframe();\n        });\n        // this will ensure that the parent timeline gets all the styles from\n        // the child even if the new timeline below is not used\n        context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n        // we do this because the window between this timeline and the sub timeline\n        // should ensure that the styles within are exactly the same as they were before\n        context.transformIntoNewTimeline(startTime + duration);\n        context.previousNode = ast;\n    }\n    visitQuery(ast, context) {\n        // in the event that the first step before this is a style step we need\n        // to ensure the styles are applied before the children are animated\n        const startTime = context.currentTimeline.currentTime;\n        const options = (ast.options || {});\n        const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n        if (delay &&\n            (context.previousNode.type === 6 /* AnimationMetadataType.Style */ ||\n                (startTime == 0 && context.currentTimeline.hasCurrentStyleProperties()))) {\n            context.currentTimeline.snapshotCurrentStyles();\n            context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n        let furthestTime = startTime;\n        const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);\n        context.currentQueryTotal = elms.length;\n        let sameElementTimeline = null;\n        elms.forEach((element, i) => {\n            context.currentQueryIndex = i;\n            const innerContext = context.createSubContext(ast.options, element);\n            if (delay) {\n                innerContext.delayNextStep(delay);\n            }\n            if (element === context.element) {\n                sameElementTimeline = innerContext.currentTimeline;\n            }\n            visitDslNode(this, ast.animation, innerContext);\n            // this is here just incase the inner steps only contain or end\n            // with a style() call (which is here to signal that this is a preparatory\n            // call to style an element before it is animated again)\n            innerContext.currentTimeline.applyStylesToKeyframe();\n            const endTime = innerContext.currentTimeline.currentTime;\n            furthestTime = Math.max(furthestTime, endTime);\n        });\n        context.currentQueryIndex = 0;\n        context.currentQueryTotal = 0;\n        context.transformIntoNewTimeline(furthestTime);\n        if (sameElementTimeline) {\n            context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n            context.currentTimeline.snapshotCurrentStyles();\n        }\n        context.previousNode = ast;\n    }\n    visitStagger(ast, context) {\n        const parentContext = context.parentContext;\n        const tl = context.currentTimeline;\n        const timings = ast.timings;\n        const duration = Math.abs(timings.duration);\n        const maxTime = duration * (context.currentQueryTotal - 1);\n        let delay = duration * context.currentQueryIndex;\n        let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n        switch (staggerTransformer) {\n            case 'reverse':\n                delay = maxTime - delay;\n                break;\n            case 'full':\n                delay = parentContext.currentStaggerTime;\n                break;\n        }\n        const timeline = context.currentTimeline;\n        if (delay) {\n            timeline.delayNextStep(delay);\n        }\n        const startingTime = timeline.currentTime;\n        visitDslNode(this, ast.animation, context);\n        context.previousNode = ast;\n        // time = duration + delay\n        // the reason why this computation is so complex is because\n        // the inner timeline may either have a delay value or a stretched\n        // keyframe depending on if a subtimeline is not used or is used.\n        parentContext.currentStaggerTime =\n            (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\n    }\n}\nconst DEFAULT_NOOP_PREVIOUS_NODE = {};\nclass AnimationTimelineContext {\n    constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {\n        this._driver = _driver;\n        this.element = element;\n        this.subInstructions = subInstructions;\n        this._enterClassName = _enterClassName;\n        this._leaveClassName = _leaveClassName;\n        this.errors = errors;\n        this.timelines = timelines;\n        this.parentContext = null;\n        this.currentAnimateTimings = null;\n        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        this.subContextCount = 0;\n        this.options = {};\n        this.currentQueryIndex = 0;\n        this.currentQueryTotal = 0;\n        this.currentStaggerTime = 0;\n        this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\n        timelines.push(this.currentTimeline);\n    }\n    get params() {\n        return this.options.params;\n    }\n    updateOptions(options, skipIfExists) {\n        if (!options)\n            return;\n        const newOptions = options;\n        let optionsToUpdate = this.options;\n        // NOTE: this will get patched up when other animation methods support duration overrides\n        if (newOptions.duration != null) {\n            optionsToUpdate.duration = resolveTimingValue(newOptions.duration);\n        }\n        if (newOptions.delay != null) {\n            optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\n        }\n        const newParams = newOptions.params;\n        if (newParams) {\n            let paramsToUpdate = optionsToUpdate.params;\n            if (!paramsToUpdate) {\n                paramsToUpdate = this.options.params = {};\n            }\n            Object.keys(newParams).forEach(name => {\n                if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {\n                    paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);\n                }\n            });\n        }\n    }\n    _copyOptions() {\n        const options = {};\n        if (this.options) {\n            const oldParams = this.options.params;\n            if (oldParams) {\n                const params = options['params'] = {};\n                Object.keys(oldParams).forEach(name => {\n                    params[name] = oldParams[name];\n                });\n            }\n        }\n        return options;\n    }\n    createSubContext(options = null, element, newTime) {\n        const target = element || this.element;\n        const context = new AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\n        context.previousNode = this.previousNode;\n        context.currentAnimateTimings = this.currentAnimateTimings;\n        context.options = this._copyOptions();\n        context.updateOptions(options);\n        context.currentQueryIndex = this.currentQueryIndex;\n        context.currentQueryTotal = this.currentQueryTotal;\n        context.parentContext = this;\n        this.subContextCount++;\n        return context;\n    }\n    transformIntoNewTimeline(newTime) {\n        this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n        this.timelines.push(this.currentTimeline);\n        return this.currentTimeline;\n    }\n    appendInstructionToTimeline(instruction, duration, delay) {\n        const updatedTimings = {\n            duration: duration != null ? duration : instruction.duration,\n            delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\n            easing: ''\n        };\n        const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n        this.timelines.push(builder);\n        return updatedTimings;\n    }\n    incrementTime(time) {\n        this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n    }\n    delayNextStep(delay) {\n        // negative delays are not yet supported\n        if (delay > 0) {\n            this.currentTimeline.delayNextStep(delay);\n        }\n    }\n    invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {\n        let results = [];\n        if (includeSelf) {\n            results.push(this.element);\n        }\n        if (selector.length > 0) { // only if :self is used then the selector can be empty\n            selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n            selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n            const multi = limit != 1;\n            let elements = this._driver.query(this.element, selector, multi);\n            if (limit !== 0) {\n                elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) :\n                    elements.slice(0, limit);\n            }\n            results.push(...elements);\n        }\n        if (!optional && results.length == 0) {\n            errors.push(invalidQuery(originalSelector));\n        }\n        return results;\n    }\n}\nclass TimelineBuilder {\n    constructor(_driver, element, startTime, _elementTimelineStylesLookup) {\n        this._driver = _driver;\n        this.element = element;\n        this.startTime = startTime;\n        this._elementTimelineStylesLookup = _elementTimelineStylesLookup;\n        this.duration = 0;\n        this.easing = null;\n        this._previousKeyframe = new Map();\n        this._currentKeyframe = new Map();\n        this._keyframes = new Map();\n        this._styleSummary = new Map();\n        this._localTimelineStyles = new Map();\n        this._pendingStyles = new Map();\n        this._backFill = new Map();\n        this._currentEmptyStepKeyframe = null;\n        if (!this._elementTimelineStylesLookup) {\n            this._elementTimelineStylesLookup = new Map();\n        }\n        this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);\n        if (!this._globalTimelineStyles) {\n            this._globalTimelineStyles = this._localTimelineStyles;\n            this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n        }\n        this._loadKeyframe();\n    }\n    containsAnimation() {\n        switch (this._keyframes.size) {\n            case 0:\n                return false;\n            case 1:\n                return this.hasCurrentStyleProperties();\n            default:\n                return true;\n        }\n    }\n    hasCurrentStyleProperties() {\n        return this._currentKeyframe.size > 0;\n    }\n    get currentTime() {\n        return this.startTime + this.duration;\n    }\n    delayNextStep(delay) {\n        // in the event that a style() step is placed right before a stagger()\n        // and that style() step is the very first style() value in the animation\n        // then we need to make a copy of the keyframe [0, copy, 1] so that the delay\n        // properly applies the style() values to work with the stagger...\n        const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;\n        if (this.duration || hasPreStyleStep) {\n            this.forwardTime(this.currentTime + delay);\n            if (hasPreStyleStep) {\n                this.snapshotCurrentStyles();\n            }\n        }\n        else {\n            this.startTime += delay;\n        }\n    }\n    fork(element, currentTime) {\n        this.applyStylesToKeyframe();\n        return new TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n    }\n    _loadKeyframe() {\n        if (this._currentKeyframe) {\n            this._previousKeyframe = this._currentKeyframe;\n        }\n        this._currentKeyframe = this._keyframes.get(this.duration);\n        if (!this._currentKeyframe) {\n            this._currentKeyframe = new Map();\n            this._keyframes.set(this.duration, this._currentKeyframe);\n        }\n    }\n    forwardFrame() {\n        this.duration += ONE_FRAME_IN_MILLISECONDS;\n        this._loadKeyframe();\n    }\n    forwardTime(time) {\n        this.applyStylesToKeyframe();\n        this.duration = time;\n        this._loadKeyframe();\n    }\n    _updateStyle(prop, value) {\n        this._localTimelineStyles.set(prop, value);\n        this._globalTimelineStyles.set(prop, value);\n        this._styleSummary.set(prop, { time: this.currentTime, value });\n    }\n    allowOnlyTimelineStyles() {\n        return this._currentEmptyStepKeyframe !== this._currentKeyframe;\n    }\n    applyEmptyStep(easing) {\n        if (easing) {\n            this._previousKeyframe.set('easing', easing);\n        }\n        // special case for animate(duration):\n        // all missing styles are filled with a `*` value then\n        // if any destination styles are filled in later on the same\n        // keyframe then they will override the overridden styles\n        // We use `_globalTimelineStyles` here because there may be\n        // styles in previous keyframes that are not present in this timeline\n        for (let [prop, value] of this._globalTimelineStyles) {\n            this._backFill.set(prop, value || _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE);\n            this._currentKeyframe.set(prop, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE);\n        }\n        this._currentEmptyStepKeyframe = this._currentKeyframe;\n    }\n    setStyles(input, easing, errors, options) {\n        if (easing) {\n            this._previousKeyframe.set('easing', easing);\n        }\n        const params = (options && options.params) || {};\n        const styles = flattenStyles(input, this._globalTimelineStyles);\n        for (let [prop, value] of styles) {\n            const val = interpolateParams(value, params, errors);\n            this._pendingStyles.set(prop, val);\n            if (!this._localTimelineStyles.has(prop)) {\n                this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE);\n            }\n            this._updateStyle(prop, val);\n        }\n    }\n    applyStylesToKeyframe() {\n        if (this._pendingStyles.size == 0)\n            return;\n        this._pendingStyles.forEach((val, prop) => {\n            this._currentKeyframe.set(prop, val);\n        });\n        this._pendingStyles.clear();\n        this._localTimelineStyles.forEach((val, prop) => {\n            if (!this._currentKeyframe.has(prop)) {\n                this._currentKeyframe.set(prop, val);\n            }\n        });\n    }\n    snapshotCurrentStyles() {\n        for (let [prop, val] of this._localTimelineStyles) {\n            this._pendingStyles.set(prop, val);\n            this._updateStyle(prop, val);\n        }\n    }\n    getFinalKeyframe() {\n        return this._keyframes.get(this.duration);\n    }\n    get properties() {\n        const properties = [];\n        for (let prop in this._currentKeyframe) {\n            properties.push(prop);\n        }\n        return properties;\n    }\n    mergeTimelineCollectedStyles(timeline) {\n        timeline._styleSummary.forEach((details1, prop) => {\n            const details0 = this._styleSummary.get(prop);\n            if (!details0 || details1.time > details0.time) {\n                this._updateStyle(prop, details1.value);\n            }\n        });\n    }\n    buildKeyframes() {\n        this.applyStylesToKeyframe();\n        const preStyleProps = new Set();\n        const postStyleProps = new Set();\n        const isEmpty = this._keyframes.size === 1 && this.duration === 0;\n        let finalKeyframes = [];\n        this._keyframes.forEach((keyframe, time) => {\n            const finalKeyframe = copyStyles(keyframe, new Map(), this._backFill);\n            finalKeyframe.forEach((value, prop) => {\n                if (value === _angular_animations__WEBPACK_IMPORTED_MODULE_0__[\"ɵPRE_STYLE\"]) {\n                    preStyleProps.add(prop);\n                }\n                else if (value === _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE) {\n                    postStyleProps.add(prop);\n                }\n            });\n            if (!isEmpty) {\n                finalKeyframe.set('offset', time / this.duration);\n            }\n            finalKeyframes.push(finalKeyframe);\n        });\n        const preProps = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\n        const postProps = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\n        // special case for a 0-second animation (which is designed just to place styles onscreen)\n        if (isEmpty) {\n            const kf0 = finalKeyframes[0];\n            const kf1 = new Map(kf0);\n            kf0.set('offset', 0);\n            kf1.set('offset', 1);\n            finalKeyframes = [kf0, kf1];\n        }\n        return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);\n    }\n}\nclass SubTimelineBuilder extends TimelineBuilder {\n    constructor(driver, element, keyframes, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {\n        super(driver, element, timings.delay);\n        this.keyframes = keyframes;\n        this.preStyleProps = preStyleProps;\n        this.postStyleProps = postStyleProps;\n        this._stretchStartingKeyframe = _stretchStartingKeyframe;\n        this.timings = { duration: timings.duration, delay: timings.delay, easing: timings.easing };\n    }\n    containsAnimation() {\n        return this.keyframes.length > 1;\n    }\n    buildKeyframes() {\n        let keyframes = this.keyframes;\n        let { delay, duration, easing } = this.timings;\n        if (this._stretchStartingKeyframe && delay) {\n            const newKeyframes = [];\n            const totalTime = duration + delay;\n            const startingGap = delay / totalTime;\n            // the original starting keyframe now starts once the delay is done\n            const newFirstKeyframe = copyStyles(keyframes[0]);\n            newFirstKeyframe.set('offset', 0);\n            newKeyframes.push(newFirstKeyframe);\n            const oldFirstKeyframe = copyStyles(keyframes[0]);\n            oldFirstKeyframe.set('offset', roundOffset(startingGap));\n            newKeyframes.push(oldFirstKeyframe);\n            /*\n              When the keyframe is stretched then it means that the delay before the animation\n              starts is gone. Instead the first keyframe is placed at the start of the animation\n              and it is then copied to where it starts when the original delay is over. This basically\n              means nothing animates during that delay, but the styles are still rendered. For this\n              to work the original offset values that exist in the original keyframes must be \"warped\"\n              so that they can take the new keyframe + delay into account.\n      \n              delay=1000, duration=1000, keyframes = 0 .5 1\n      \n              turns into\n      \n              delay=0, duration=2000, keyframes = 0 .33 .66 1\n             */\n            // offsets between 1 ... n -1 are all warped by the keyframe stretch\n            const limit = keyframes.length - 1;\n            for (let i = 1; i <= limit; i++) {\n                let kf = copyStyles(keyframes[i]);\n                const oldOffset = kf.get('offset');\n                const timeAtKeyframe = delay + oldOffset * duration;\n                kf.set('offset', roundOffset(timeAtKeyframe / totalTime));\n                newKeyframes.push(kf);\n            }\n            // the new starting keyframe should be added at the start\n            duration = totalTime;\n            delay = 0;\n            easing = '';\n            keyframes = newKeyframes;\n        }\n        return createTimelineInstruction(this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing, true);\n    }\n}\nfunction roundOffset(offset, decimalPoints = 3) {\n    const mult = Math.pow(10, decimalPoints - 1);\n    return Math.round(offset * mult) / mult;\n}\nfunction flattenStyles(input, allStyles) {\n    const styles = new Map();\n    let allProperties;\n    input.forEach(token => {\n        if (token === '*') {\n            allProperties = allProperties || allStyles.keys();\n            for (let prop of allProperties) {\n                styles.set(prop, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE);\n            }\n        }\n        else {\n            copyStyles(token, styles);\n        }\n    });\n    return styles;\n}\n\nclass Animation {\n    constructor(_driver, input) {\n        this._driver = _driver;\n        const errors = [];\n        const warnings = [];\n        const ast = buildAnimationAst(_driver, input, errors, warnings);\n        if (errors.length) {\n            throw validationFailed(errors);\n        }\n        if (warnings.length) {\n            warnValidation(warnings);\n        }\n        this._animationAst = ast;\n    }\n    buildTimelines(element, startingStyles, destinationStyles, options, subInstructions) {\n        const start = Array.isArray(startingStyles) ? normalizeStyles(startingStyles) :\n            startingStyles;\n        const dest = Array.isArray(destinationStyles) ? normalizeStyles(destinationStyles) :\n            destinationStyles;\n        const errors = [];\n        subInstructions = subInstructions || new ElementInstructionMap();\n        const result = buildAnimationTimelines(this._driver, element, this._animationAst, ENTER_CLASSNAME, LEAVE_CLASSNAME, start, dest, options, subInstructions, errors);\n        if (errors.length) {\n            throw buildingFailed(errors);\n        }\n        return result;\n    }\n}\n\n/**\n * @publicApi\n */\nclass AnimationStyleNormalizer {\n}\n/**\n * @publicApi\n */\nclass NoopAnimationStyleNormalizer {\n    normalizePropertyName(propertyName, errors) {\n        return propertyName;\n    }\n    normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n        return value;\n    }\n}\n\nconst DIMENSIONAL_PROP_SET = new Set([\n    'width',\n    'height',\n    'minWidth',\n    'minHeight',\n    'maxWidth',\n    'maxHeight',\n    'left',\n    'top',\n    'bottom',\n    'right',\n    'fontSize',\n    'outlineWidth',\n    'outlineOffset',\n    'paddingTop',\n    'paddingLeft',\n    'paddingBottom',\n    'paddingRight',\n    'marginTop',\n    'marginLeft',\n    'marginBottom',\n    'marginRight',\n    'borderRadius',\n    'borderWidth',\n    'borderTopWidth',\n    'borderLeftWidth',\n    'borderRightWidth',\n    'borderBottomWidth',\n    'textIndent',\n    'perspective'\n]);\nclass WebAnimationsStyleNormalizer extends AnimationStyleNormalizer {\n    normalizePropertyName(propertyName, errors) {\n        return dashCaseToCamelCase(propertyName);\n    }\n    normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {\n        let unit = '';\n        const strVal = value.toString().trim();\n        if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value !== 0 && value !== '0') {\n            if (typeof value === 'number') {\n                unit = 'px';\n            }\n            else {\n                const valAndSuffixMatch = value.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errors.push(invalidCssUnitValue(userProvidedProperty, value));\n                }\n            }\n        }\n        return strVal + unit;\n    }\n}\n\nfunction createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {\n    return {\n        type: 0 /* AnimationTransitionInstructionType.TransitionAnimation */,\n        element,\n        triggerName,\n        isRemovalTransition,\n        fromState,\n        fromStyles,\n        toState,\n        toStyles,\n        timelines,\n        queriedElements,\n        preStyleProps,\n        postStyleProps,\n        totalTime,\n        errors\n    };\n}\n\nconst EMPTY_OBJECT = {};\nclass AnimationTransitionFactory {\n    constructor(_triggerName, ast, _stateStyles) {\n        this._triggerName = _triggerName;\n        this.ast = ast;\n        this._stateStyles = _stateStyles;\n    }\n    match(currentState, nextState, element, params) {\n        return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);\n    }\n    buildStyles(stateName, params, errors) {\n        let styler = this._stateStyles.get('*');\n        if (stateName !== undefined) {\n            styler = this._stateStyles.get(stateName?.toString()) || styler;\n        }\n        return styler ? styler.buildStyles(params, errors) : new Map();\n    }\n    build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {\n        const errors = [];\n        const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;\n        const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;\n        const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);\n        const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;\n        const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);\n        const queriedElements = new Set();\n        const preStyleMap = new Map();\n        const postStyleMap = new Map();\n        const isRemoval = nextState === 'void';\n        const animationOptions = {\n            params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),\n            delay: this.ast.options?.delay,\n        };\n        const timelines = skipAstBuild ?\n            [] :\n            buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);\n        let totalTime = 0;\n        timelines.forEach(tl => {\n            totalTime = Math.max(tl.duration + tl.delay, totalTime);\n        });\n        if (errors.length) {\n            return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);\n        }\n        timelines.forEach(tl => {\n            const elm = tl.element;\n            const preProps = getOrSetDefaultValue(preStyleMap, elm, new Set());\n            tl.preStyleProps.forEach(prop => preProps.add(prop));\n            const postProps = getOrSetDefaultValue(postStyleMap, elm, new Set());\n            tl.postStyleProps.forEach(prop => postProps.add(prop));\n            if (elm !== element) {\n                queriedElements.add(elm);\n            }\n        });\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            checkNonAnimatableInTimelines(timelines, this._triggerName, driver);\n        }\n        const queriedElementsList = iteratorToArray(queriedElements.values());\n        return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, queriedElementsList, preStyleMap, postStyleMap, totalTime);\n    }\n}\n/**\n * Checks inside a set of timelines if they try to animate a css property which is not considered\n * animatable, in that case it prints a warning on the console.\n * Besides that the function doesn't have any other effect.\n *\n * Note: this check is done here after the timelines are built instead of doing on a lower level so\n * that we can make sure that the warning appears only once per instruction (we can aggregate here\n * all the issues instead of finding them separately).\n *\n * @param timelines The built timelines for the current instruction.\n * @param triggerName The name of the trigger for the current instruction.\n * @param driver Animation driver used to perform the check.\n *\n */\nfunction checkNonAnimatableInTimelines(timelines, triggerName, driver) {\n    if (!driver.validateAnimatableStyleProperty) {\n        return;\n    }\n    const allowedNonAnimatableProps = new Set([\n        // 'easing' is a utility/synthetic prop we use to represent\n        // easing functions, it represents a property of the animation\n        // which is not animatable but different values can be used\n        // in different steps\n        'easing'\n    ]);\n    const invalidNonAnimatableProps = new Set();\n    timelines.forEach(({ keyframes }) => {\n        const nonAnimatablePropsInitialValues = new Map();\n        keyframes.forEach(keyframe => {\n            const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));\n            for (const [prop, value] of entriesToCheck) {\n                if (!driver.validateAnimatableStyleProperty(prop)) {\n                    if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {\n                        const propInitialValue = nonAnimatablePropsInitialValues.get(prop);\n                        if (propInitialValue !== value) {\n                            invalidNonAnimatableProps.add(prop);\n                        }\n                    }\n                    else {\n                        nonAnimatablePropsInitialValues.set(prop, value);\n                    }\n                }\n            }\n        });\n    });\n    if (invalidNonAnimatableProps.size > 0) {\n        console.warn(`Warning: The animation trigger \"${triggerName}\" is attempting to animate the following` +\n            ' not animatable properties: ' + Array.from(invalidNonAnimatableProps).join(', ') + '\\n' +\n            '(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)');\n    }\n}\nfunction oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {\n    return matchFns.some(fn => fn(currentState, nextState, element, params));\n}\nfunction applyParamDefaults(userParams, defaults) {\n    const result = copyObj(defaults);\n    for (const key in userParams) {\n        if (userParams.hasOwnProperty(key) && userParams[key] != null) {\n            result[key] = userParams[key];\n        }\n    }\n    return result;\n}\nclass AnimationStateStyles {\n    constructor(styles, defaultParams, normalizer) {\n        this.styles = styles;\n        this.defaultParams = defaultParams;\n        this.normalizer = normalizer;\n    }\n    buildStyles(params, errors) {\n        const finalStyles = new Map();\n        const combinedParams = copyObj(this.defaultParams);\n        Object.keys(params).forEach(key => {\n            const value = params[key];\n            if (value !== null) {\n                combinedParams[key] = value;\n            }\n        });\n        this.styles.styles.forEach(value => {\n            if (typeof value !== 'string') {\n                value.forEach((val, prop) => {\n                    if (val) {\n                        val = interpolateParams(val, combinedParams, errors);\n                    }\n                    const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);\n                    val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);\n                    finalStyles.set(prop, val);\n                });\n            }\n        });\n        return finalStyles;\n    }\n}\n\nfunction buildTrigger(name, ast, normalizer) {\n    return new AnimationTrigger(name, ast, normalizer);\n}\nclass AnimationTrigger {\n    constructor(name, ast, _normalizer) {\n        this.name = name;\n        this.ast = ast;\n        this._normalizer = _normalizer;\n        this.transitionFactories = [];\n        this.states = new Map();\n        ast.states.forEach(ast => {\n            const defaultParams = (ast.options && ast.options.params) || {};\n            this.states.set(ast.name, new AnimationStateStyles(ast.style, defaultParams, _normalizer));\n        });\n        balanceProperties(this.states, 'true', '1');\n        balanceProperties(this.states, 'false', '0');\n        ast.transitions.forEach(ast => {\n            this.transitionFactories.push(new AnimationTransitionFactory(name, ast, this.states));\n        });\n        this.fallbackTransition = createFallbackTransition(name, this.states, this._normalizer);\n    }\n    get containsQueries() {\n        return this.ast.queryCount > 0;\n    }\n    matchTransition(currentState, nextState, element, params) {\n        const entry = this.transitionFactories.find(f => f.match(currentState, nextState, element, params));\n        return entry || null;\n    }\n    matchStyles(currentState, params, errors) {\n        return this.fallbackTransition.buildStyles(currentState, params, errors);\n    }\n}\nfunction createFallbackTransition(triggerName, states, normalizer) {\n    const matchers = [(fromState, toState) => true];\n    const animation = { type: 2 /* AnimationMetadataType.Sequence */, steps: [], options: null };\n    const transition = {\n        type: 1 /* AnimationMetadataType.Transition */,\n        animation,\n        matchers,\n        options: null,\n        queryCount: 0,\n        depCount: 0\n    };\n    return new AnimationTransitionFactory(triggerName, transition, states);\n}\nfunction balanceProperties(stateMap, key1, key2) {\n    if (stateMap.has(key1)) {\n        if (!stateMap.has(key2)) {\n            stateMap.set(key2, stateMap.get(key1));\n        }\n    }\n    else if (stateMap.has(key2)) {\n        stateMap.set(key1, stateMap.get(key2));\n    }\n}\n\nconst EMPTY_INSTRUCTION_MAP = new ElementInstructionMap();\nclass TimelineAnimationEngine {\n    constructor(bodyNode, _driver, _normalizer) {\n        this.bodyNode = bodyNode;\n        this._driver = _driver;\n        this._normalizer = _normalizer;\n        this._animations = new Map();\n        this._playersById = new Map();\n        this.players = [];\n    }\n    register(id, metadata) {\n        const errors = [];\n        const warnings = [];\n        const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n        if (errors.length) {\n            throw registerFailed(errors);\n        }\n        else {\n            if (warnings.length) {\n                warnRegister(warnings);\n            }\n            this._animations.set(id, ast);\n        }\n    }\n    _buildPlayer(i, preStyles, postStyles) {\n        const element = i.element;\n        const keyframes = normalizeKeyframes$1(this._driver, this._normalizer, element, i.keyframes, preStyles, postStyles);\n        return this._driver.animate(element, keyframes, i.duration, i.delay, i.easing, [], true);\n    }\n    create(id, element, options = {}) {\n        const errors = [];\n        const ast = this._animations.get(id);\n        let instructions;\n        const autoStylesMap = new Map();\n        if (ast) {\n            instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, new Map(), new Map(), options, EMPTY_INSTRUCTION_MAP, errors);\n            instructions.forEach(inst => {\n                const styles = getOrSetDefaultValue(autoStylesMap, inst.element, new Map());\n                inst.postStyleProps.forEach(prop => styles.set(prop, null));\n            });\n        }\n        else {\n            errors.push(missingOrDestroyedAnimation());\n            instructions = [];\n        }\n        if (errors.length) {\n            throw createAnimationFailed(errors);\n        }\n        autoStylesMap.forEach((styles, element) => {\n            styles.forEach((_, prop) => {\n                styles.set(prop, this._driver.computeStyle(element, prop, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE));\n            });\n        });\n        const players = instructions.map(i => {\n            const styles = autoStylesMap.get(i.element);\n            return this._buildPlayer(i, new Map(), styles);\n        });\n        const player = optimizeGroupPlayer(players);\n        this._playersById.set(id, player);\n        player.onDestroy(() => this.destroy(id));\n        this.players.push(player);\n        return player;\n    }\n    destroy(id) {\n        const player = this._getPlayer(id);\n        player.destroy();\n        this._playersById.delete(id);\n        const index = this.players.indexOf(player);\n        if (index >= 0) {\n            this.players.splice(index, 1);\n        }\n    }\n    _getPlayer(id) {\n        const player = this._playersById.get(id);\n        if (!player) {\n            throw missingPlayer(id);\n        }\n        return player;\n    }\n    listen(id, element, eventName, callback) {\n        // triggerName, fromState, toState are all ignored for timeline animations\n        const baseEvent = makeAnimationEvent(element, '', '', '');\n        listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);\n        return () => { };\n    }\n    command(id, element, command, args) {\n        if (command == 'register') {\n            this.register(id, args[0]);\n            return;\n        }\n        if (command == 'create') {\n            const options = (args[0] || {});\n            this.create(id, element, options);\n            return;\n        }\n        const player = this._getPlayer(id);\n        switch (command) {\n            case 'play':\n                player.play();\n                break;\n            case 'pause':\n                player.pause();\n                break;\n            case 'reset':\n                player.reset();\n                break;\n            case 'restart':\n                player.restart();\n                break;\n            case 'finish':\n                player.finish();\n                break;\n            case 'init':\n                player.init();\n                break;\n            case 'setPosition':\n                player.setPosition(parseFloat(args[0]));\n                break;\n            case 'destroy':\n                this.destroy(id);\n                break;\n        }\n    }\n}\n\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\nconst EMPTY_PLAYER_ARRAY = [];\nconst NULL_REMOVAL_STATE = {\n    namespaceId: '',\n    setForRemoval: false,\n    setForMove: false,\n    hasAnimation: false,\n    removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE = {\n    namespaceId: '',\n    setForMove: false,\n    setForRemoval: false,\n    hasAnimation: false,\n    removedBeforeQueried: true\n};\nconst REMOVAL_FLAG = '__ng_removed';\nclass StateValue {\n    get params() {\n        return this.options.params;\n    }\n    constructor(input, namespaceId = '') {\n        this.namespaceId = namespaceId;\n        const isObj = input && input.hasOwnProperty('value');\n        const value = isObj ? input['value'] : input;\n        this.value = normalizeTriggerValue(value);\n        if (isObj) {\n            const options = copyObj(input);\n            delete options['value'];\n            this.options = options;\n        }\n        else {\n            this.options = {};\n        }\n        if (!this.options.params) {\n            this.options.params = {};\n        }\n    }\n    absorbOptions(options) {\n        const newParams = options.params;\n        if (newParams) {\n            const oldParams = this.options.params;\n            Object.keys(newParams).forEach(prop => {\n                if (oldParams[prop] == null) {\n                    oldParams[prop] = newParams[prop];\n                }\n            });\n        }\n    }\n}\nconst VOID_VALUE = 'void';\nconst DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\nclass AnimationTransitionNamespace {\n    constructor(id, hostElement, _engine) {\n        this.id = id;\n        this.hostElement = hostElement;\n        this._engine = _engine;\n        this.players = [];\n        this._triggers = new Map();\n        this._queue = [];\n        this._elementListeners = new Map();\n        this._hostClassName = 'ng-tns-' + id;\n        addClass(hostElement, this._hostClassName);\n    }\n    listen(element, name, phase, callback) {\n        if (!this._triggers.has(name)) {\n            throw missingTrigger(phase, name);\n        }\n        if (phase == null || phase.length == 0) {\n            throw missingEvent(name);\n        }\n        if (!isTriggerEventValid(phase)) {\n            throw unsupportedTriggerEvent(phase, name);\n        }\n        const listeners = getOrSetDefaultValue(this._elementListeners, element, []);\n        const data = { name, phase, callback };\n        listeners.push(data);\n        const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, new Map());\n        if (!triggersWithStates.has(name)) {\n            addClass(element, NG_TRIGGER_CLASSNAME);\n            addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n            triggersWithStates.set(name, DEFAULT_STATE_VALUE);\n        }\n        return () => {\n            // the event listener is removed AFTER the flush has occurred such\n            // that leave animations callbacks can fire (otherwise if the node\n            // is removed in between then the listeners would be deregistered)\n            this._engine.afterFlush(() => {\n                const index = listeners.indexOf(data);\n                if (index >= 0) {\n                    listeners.splice(index, 1);\n                }\n                if (!this._triggers.has(name)) {\n                    triggersWithStates.delete(name);\n                }\n            });\n        };\n    }\n    register(name, ast) {\n        if (this._triggers.has(name)) {\n            // throw\n            return false;\n        }\n        else {\n            this._triggers.set(name, ast);\n            return true;\n        }\n    }\n    _getTrigger(name) {\n        const trigger = this._triggers.get(name);\n        if (!trigger) {\n            throw unregisteredTrigger(name);\n        }\n        return trigger;\n    }\n    trigger(element, triggerName, value, defaultToFallback = true) {\n        const trigger = this._getTrigger(triggerName);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n        let triggersWithStates = this._engine.statesByElement.get(element);\n        if (!triggersWithStates) {\n            addClass(element, NG_TRIGGER_CLASSNAME);\n            addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n            this._engine.statesByElement.set(element, triggersWithStates = new Map());\n        }\n        let fromState = triggersWithStates.get(triggerName);\n        const toState = new StateValue(value, this.id);\n        const isObj = value && value.hasOwnProperty('value');\n        if (!isObj && fromState) {\n            toState.absorbOptions(fromState.options);\n        }\n        triggersWithStates.set(triggerName, toState);\n        if (!fromState) {\n            fromState = DEFAULT_STATE_VALUE;\n        }\n        const isRemoval = toState.value === VOID_VALUE;\n        // normally this isn't reached by here, however, if an object expression\n        // is passed in then it may be a new object each time. Comparing the value\n        // is important since that will stay the same despite there being a new object.\n        // The removal arc here is special cased because the same element is triggered\n        // twice in the event that it contains animations on the outer/inner portions\n        // of the host container\n        if (!isRemoval && fromState.value === toState.value) {\n            // this means that despite the value not changing, some inner params\n            // have changed which means that the animation final styles need to be applied\n            if (!objEquals(fromState.params, toState.params)) {\n                const errors = [];\n                const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n                const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n                if (errors.length) {\n                    this._engine.reportError(errors);\n                }\n                else {\n                    this._engine.afterFlush(() => {\n                        eraseStyles(element, fromStyles);\n                        setStyles(element, toStyles);\n                    });\n                }\n            }\n            return;\n        }\n        const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);\n        playersOnElement.forEach(player => {\n            // only remove the player if it is queued on the EXACT same trigger/namespace\n            // we only also deal with queued players here because if the animation has\n            // started then we want to keep the player alive until the flush happens\n            // (which is where the previousPlayers are passed into the new player)\n            if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n                player.destroy();\n            }\n        });\n        let transition = trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n        let isFallbackTransition = false;\n        if (!transition) {\n            if (!defaultToFallback)\n                return;\n            transition = trigger.fallbackTransition;\n            isFallbackTransition = true;\n        }\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({ element, triggerName, transition, fromState, toState, player, isFallbackTransition });\n        if (!isFallbackTransition) {\n            addClass(element, QUEUED_CLASSNAME);\n            player.onStart(() => {\n                removeClass(element, QUEUED_CLASSNAME);\n            });\n        }\n        player.onDone(() => {\n            let index = this.players.indexOf(player);\n            if (index >= 0) {\n                this.players.splice(index, 1);\n            }\n            const players = this._engine.playersByElement.get(element);\n            if (players) {\n                let index = players.indexOf(player);\n                if (index >= 0) {\n                    players.splice(index, 1);\n                }\n            }\n        });\n        this.players.push(player);\n        playersOnElement.push(player);\n        return player;\n    }\n    deregister(name) {\n        this._triggers.delete(name);\n        this._engine.statesByElement.forEach(stateMap => stateMap.delete(name));\n        this._elementListeners.forEach((listeners, element) => {\n            this._elementListeners.set(element, listeners.filter(entry => {\n                return entry.name != name;\n            }));\n        });\n    }\n    clearElementCache(element) {\n        this._engine.statesByElement.delete(element);\n        this._elementListeners.delete(element);\n        const elementPlayers = this._engine.playersByElement.get(element);\n        if (elementPlayers) {\n            elementPlayers.forEach(player => player.destroy());\n            this._engine.playersByElement.delete(element);\n        }\n    }\n    _signalRemovalForInnerTriggers(rootElement, context) {\n        const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);\n        // emulate a leave animation for all inner nodes within this node.\n        // If there are no animations found for any of the nodes then clear the cache\n        // for the element.\n        elements.forEach(elm => {\n            // this means that an inner remove() operation has already kicked off\n            // the animation on this element...\n            if (elm[REMOVAL_FLAG])\n                return;\n            const namespaces = this._engine.fetchNamespacesByElement(elm);\n            if (namespaces.size) {\n                namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n            }\n            else {\n                this.clearElementCache(elm);\n            }\n        });\n        // If the child elements were removed along with the parent, their animations might not\n        // have completed. Clear all the elements from the cache so we don't end up with a memory leak.\n        this._engine.afterFlushAnimationsDone(() => elements.forEach(elm => this.clearElementCache(elm)));\n    }\n    triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {\n        const triggerStates = this._engine.statesByElement.get(element);\n        const previousTriggersValues = new Map();\n        if (triggerStates) {\n            const players = [];\n            triggerStates.forEach((state, triggerName) => {\n                previousTriggersValues.set(triggerName, state.value);\n                // this check is here in the event that an element is removed\n                // twice (both on the host level and the component level)\n                if (this._triggers.has(triggerName)) {\n                    const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n                    if (player) {\n                        players.push(player);\n                    }\n                }\n            });\n            if (players.length) {\n                this._engine.markElementAsRemoved(this.id, element, true, context, previousTriggersValues);\n                if (destroyAfterComplete) {\n                    optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    prepareLeaveAnimationListeners(element) {\n        const listeners = this._elementListeners.get(element);\n        const elementStates = this._engine.statesByElement.get(element);\n        // if this statement fails then it means that the element was picked up\n        // by an earlier flush (or there are no listeners at all to track the leave).\n        if (listeners && elementStates) {\n            const visitedTriggers = new Set();\n            listeners.forEach(listener => {\n                const triggerName = listener.name;\n                if (visitedTriggers.has(triggerName))\n                    return;\n                visitedTriggers.add(triggerName);\n                const trigger = this._triggers.get(triggerName);\n                const transition = trigger.fallbackTransition;\n                const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;\n                const toState = new StateValue(VOID_VALUE);\n                const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n                this._engine.totalQueuedPlayers++;\n                this._queue.push({\n                    element,\n                    triggerName,\n                    transition,\n                    fromState,\n                    toState,\n                    player,\n                    isFallbackTransition: true\n                });\n            });\n        }\n    }\n    removeNode(element, context) {\n        const engine = this._engine;\n        if (element.childElementCount) {\n            this._signalRemovalForInnerTriggers(element, context);\n        }\n        // this means that a * => VOID animation was detected and kicked off\n        if (this.triggerLeaveAnimation(element, context, true))\n            return;\n        // find the player that is animating and make sure that the\n        // removal is delayed until that player has completed\n        let containsPotentialParentTransition = false;\n        if (engine.totalAnimations) {\n            const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n            // when this `if statement` does not continue forward it means that\n            // a previous animation query has selected the current element and\n            // is animating it. In this situation want to continue forwards and\n            // allow the element to be queued up for animation later.\n            if (currentPlayers && currentPlayers.length) {\n                containsPotentialParentTransition = true;\n            }\n            else {\n                let parent = element;\n                while (parent = parent.parentNode) {\n                    const triggers = engine.statesByElement.get(parent);\n                    if (triggers) {\n                        containsPotentialParentTransition = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // at this stage we know that the element will either get removed\n        // during flush or will be picked up by a parent query. Either way\n        // we need to fire the listeners for this element when it DOES get\n        // removed (once the query parent animation is done or after flush)\n        this.prepareLeaveAnimationListeners(element);\n        // whether or not a parent has an animation we need to delay the deferral of the leave\n        // operation until we have more information (which we do after flush() has been called)\n        if (containsPotentialParentTransition) {\n            engine.markElementAsRemoved(this.id, element, false, context);\n        }\n        else {\n            const removalFlag = element[REMOVAL_FLAG];\n            if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {\n                // we do this after the flush has occurred such\n                // that the callbacks can be fired\n                engine.afterFlush(() => this.clearElementCache(element));\n                engine.destroyInnerAnimations(element);\n                engine._onRemovalComplete(element, context);\n            }\n        }\n    }\n    insertNode(element, parent) {\n        addClass(element, this._hostClassName);\n    }\n    drainQueuedTransitions(microtaskId) {\n        const instructions = [];\n        this._queue.forEach(entry => {\n            const player = entry.player;\n            if (player.destroyed)\n                return;\n            const element = entry.element;\n            const listeners = this._elementListeners.get(element);\n            if (listeners) {\n                listeners.forEach((listener) => {\n                    if (listener.name == entry.triggerName) {\n                        const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);\n                        baseEvent['_data'] = microtaskId;\n                        listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n                    }\n                });\n            }\n            if (player.markedForDestroy) {\n                this._engine.afterFlush(() => {\n                    // now we can destroy the element properly since the event listeners have\n                    // been bound to the player\n                    player.destroy();\n                });\n            }\n            else {\n                instructions.push(entry);\n            }\n        });\n        this._queue = [];\n        return instructions.sort((a, b) => {\n            // if depCount == 0 them move to front\n            // otherwise if a contains b then move back\n            const d0 = a.transition.ast.depCount;\n            const d1 = b.transition.ast.depCount;\n            if (d0 == 0 || d1 == 0) {\n                return d0 - d1;\n            }\n            return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n        });\n    }\n    destroy(context) {\n        this.players.forEach(p => p.destroy());\n        this._signalRemovalForInnerTriggers(this.hostElement, context);\n    }\n    elementContainsData(element) {\n        let containsData = false;\n        if (this._elementListeners.has(element))\n            containsData = true;\n        containsData =\n            (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n        return containsData;\n    }\n}\nclass TransitionAnimationEngine {\n    /** @internal */\n    _onRemovalComplete(element, context) {\n        this.onRemovalComplete(element, context);\n    }\n    constructor(bodyNode, driver, _normalizer) {\n        this.bodyNode = bodyNode;\n        this.driver = driver;\n        this._normalizer = _normalizer;\n        this.players = [];\n        this.newHostElements = new Map();\n        this.playersByElement = new Map();\n        this.playersByQueriedElement = new Map();\n        this.statesByElement = new Map();\n        this.disabledNodes = new Set();\n        this.totalAnimations = 0;\n        this.totalQueuedPlayers = 0;\n        this._namespaceLookup = {};\n        this._namespaceList = [];\n        this._flushFns = [];\n        this._whenQuietFns = [];\n        this.namespacesByHostElement = new Map();\n        this.collectedEnterElements = [];\n        this.collectedLeaveElements = [];\n        // this method is designed to be overridden by the code that uses this engine\n        this.onRemovalComplete = (element, context) => { };\n    }\n    get queuedPlayers() {\n        const players = [];\n        this._namespaceList.forEach(ns => {\n            ns.players.forEach(player => {\n                if (player.queued) {\n                    players.push(player);\n                }\n            });\n        });\n        return players;\n    }\n    createNamespace(namespaceId, hostElement) {\n        const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n        if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {\n            this._balanceNamespaceList(ns, hostElement);\n        }\n        else {\n            // defer this later until flush during when the host element has\n            // been inserted so that we know exactly where to place it in\n            // the namespace list\n            this.newHostElements.set(hostElement, ns);\n            // given that this host element is a part of the animation code, it\n            // may or may not be inserted by a parent node that is of an\n            // animation renderer type. If this happens then we can still have\n            // access to this item when we query for :enter nodes. If the parent\n            // is a renderer then the set data-structure will normalize the entry\n            this.collectEnterElement(hostElement);\n        }\n        return this._namespaceLookup[namespaceId] = ns;\n    }\n    _balanceNamespaceList(ns, hostElement) {\n        const namespaceList = this._namespaceList;\n        const namespacesByHostElement = this.namespacesByHostElement;\n        const limit = namespaceList.length - 1;\n        if (limit >= 0) {\n            let found = false;\n            // Find the closest ancestor with an existing namespace so we can then insert `ns` after it,\n            // establishing a top-down ordering of namespaces in `this._namespaceList`.\n            let ancestor = this.driver.getParentElement(hostElement);\n            while (ancestor) {\n                const ancestorNs = namespacesByHostElement.get(ancestor);\n                if (ancestorNs) {\n                    // An animation namespace has been registered for this ancestor, so we insert `ns`\n                    // right after it to establish top-down ordering of animation namespaces.\n                    const index = namespaceList.indexOf(ancestorNs);\n                    namespaceList.splice(index + 1, 0, ns);\n                    found = true;\n                    break;\n                }\n                ancestor = this.driver.getParentElement(ancestor);\n            }\n            if (!found) {\n                // No namespace exists that is an ancestor of `ns`, so `ns` is inserted at the front to\n                // ensure that any existing descendants are ordered after `ns`, retaining the desired\n                // top-down ordering.\n                namespaceList.unshift(ns);\n            }\n        }\n        else {\n            namespaceList.push(ns);\n        }\n        namespacesByHostElement.set(hostElement, ns);\n        return ns;\n    }\n    register(namespaceId, hostElement) {\n        let ns = this._namespaceLookup[namespaceId];\n        if (!ns) {\n            ns = this.createNamespace(namespaceId, hostElement);\n        }\n        return ns;\n    }\n    registerTrigger(namespaceId, name, trigger) {\n        let ns = this._namespaceLookup[namespaceId];\n        if (ns && ns.register(name, trigger)) {\n            this.totalAnimations++;\n        }\n    }\n    destroy(namespaceId, context) {\n        if (!namespaceId)\n            return;\n        const ns = this._fetchNamespace(namespaceId);\n        this.afterFlush(() => {\n            this.namespacesByHostElement.delete(ns.hostElement);\n            delete this._namespaceLookup[namespaceId];\n            const index = this._namespaceList.indexOf(ns);\n            if (index >= 0) {\n                this._namespaceList.splice(index, 1);\n            }\n        });\n        this.afterFlushAnimationsDone(() => ns.destroy(context));\n    }\n    _fetchNamespace(id) {\n        return this._namespaceLookup[id];\n    }\n    fetchNamespacesByElement(element) {\n        // normally there should only be one namespace per element, however\n        // if @triggers are placed on both the component element and then\n        // its host element (within the component code) then there will be\n        // two namespaces returned. We use a set here to simply deduplicate\n        // the namespaces in case (for the reason described above) there are multiple triggers\n        const namespaces = new Set();\n        const elementStates = this.statesByElement.get(element);\n        if (elementStates) {\n            for (let stateValue of elementStates.values()) {\n                if (stateValue.namespaceId) {\n                    const ns = this._fetchNamespace(stateValue.namespaceId);\n                    if (ns) {\n                        namespaces.add(ns);\n                    }\n                }\n            }\n        }\n        return namespaces;\n    }\n    trigger(namespaceId, element, name, value) {\n        if (isElementNode(element)) {\n            const ns = this._fetchNamespace(namespaceId);\n            if (ns) {\n                ns.trigger(element, name, value);\n                return true;\n            }\n        }\n        return false;\n    }\n    insertNode(namespaceId, element, parent, insertBefore) {\n        if (!isElementNode(element))\n            return;\n        // special case for when an element is removed and reinserted (move operation)\n        // when this occurs we do not want to use the element for deletion later\n        const details = element[REMOVAL_FLAG];\n        if (details && details.setForRemoval) {\n            details.setForRemoval = false;\n            details.setForMove = true;\n            const index = this.collectedLeaveElements.indexOf(element);\n            if (index >= 0) {\n                this.collectedLeaveElements.splice(index, 1);\n            }\n        }\n        // in the event that the namespaceId is blank then the caller\n        // code does not contain any animation code in it, but it is\n        // just being called so that the node is marked as being inserted\n        if (namespaceId) {\n            const ns = this._fetchNamespace(namespaceId);\n            // This if-statement is a workaround for router issue #21947.\n            // The router sometimes hits a race condition where while a route\n            // is being instantiated a new navigation arrives, triggering leave\n            // animation of DOM that has not been fully initialized, until this\n            // is resolved, we need to handle the scenario when DOM is not in a\n            // consistent state during the animation.\n            if (ns) {\n                ns.insertNode(element, parent);\n            }\n        }\n        // only *directives and host elements are inserted before\n        if (insertBefore) {\n            this.collectEnterElement(element);\n        }\n    }\n    collectEnterElement(element) {\n        this.collectedEnterElements.push(element);\n    }\n    markElementAsDisabled(element, value) {\n        if (value) {\n            if (!this.disabledNodes.has(element)) {\n                this.disabledNodes.add(element);\n                addClass(element, DISABLED_CLASSNAME);\n            }\n        }\n        else if (this.disabledNodes.has(element)) {\n            this.disabledNodes.delete(element);\n            removeClass(element, DISABLED_CLASSNAME);\n        }\n    }\n    removeNode(namespaceId, element, isHostElement, context) {\n        if (isElementNode(element)) {\n            const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n            if (ns) {\n                ns.removeNode(element, context);\n            }\n            else {\n                this.markElementAsRemoved(namespaceId, element, false, context);\n            }\n            if (isHostElement) {\n                const hostNS = this.namespacesByHostElement.get(element);\n                if (hostNS && hostNS.id !== namespaceId) {\n                    hostNS.removeNode(element, context);\n                }\n            }\n        }\n        else {\n            this._onRemovalComplete(element, context);\n        }\n    }\n    markElementAsRemoved(namespaceId, element, hasAnimation, context, previousTriggersValues) {\n        this.collectedLeaveElements.push(element);\n        element[REMOVAL_FLAG] = {\n            namespaceId,\n            setForRemoval: context,\n            hasAnimation,\n            removedBeforeQueried: false,\n            previousTriggersValues\n        };\n    }\n    listen(namespaceId, element, name, phase, callback) {\n        if (isElementNode(element)) {\n            return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n        }\n        return () => { };\n    }\n    _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {\n        return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n    }\n    destroyInnerAnimations(containerElement) {\n        let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n        elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n        if (this.playersByQueriedElement.size == 0)\n            return;\n        elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n        elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n    }\n    destroyActiveAnimationsForElement(element) {\n        const players = this.playersByElement.get(element);\n        if (players) {\n            players.forEach(player => {\n                // special case for when an element is set for destruction, but hasn't started.\n                // in this situation we want to delay the destruction until the flush occurs\n                // so that any event listeners attached to the player are triggered.\n                if (player.queued) {\n                    player.markedForDestroy = true;\n                }\n                else {\n                    player.destroy();\n                }\n            });\n        }\n    }\n    finishActiveQueriedAnimationOnElement(element) {\n        const players = this.playersByQueriedElement.get(element);\n        if (players) {\n            players.forEach(player => player.finish());\n        }\n    }\n    whenRenderingDone() {\n        return new Promise(resolve => {\n            if (this.players.length) {\n                return optimizeGroupPlayer(this.players).onDone(() => resolve());\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    processLeaveNode(element) {\n        const details = element[REMOVAL_FLAG];\n        if (details && details.setForRemoval) {\n            // this will prevent it from removing it twice\n            element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n            if (details.namespaceId) {\n                this.destroyInnerAnimations(element);\n                const ns = this._fetchNamespace(details.namespaceId);\n                if (ns) {\n                    ns.clearElementCache(element);\n                }\n            }\n            this._onRemovalComplete(element, details.setForRemoval);\n        }\n        if (element.classList?.contains(DISABLED_CLASSNAME)) {\n            this.markElementAsDisabled(element, false);\n        }\n        this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n            this.markElementAsDisabled(node, false);\n        });\n    }\n    flush(microtaskId = -1) {\n        let players = [];\n        if (this.newHostElements.size) {\n            this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n            this.newHostElements.clear();\n        }\n        if (this.totalAnimations && this.collectedEnterElements.length) {\n            for (let i = 0; i < this.collectedEnterElements.length; i++) {\n                const elm = this.collectedEnterElements[i];\n                addClass(elm, STAR_CLASSNAME);\n            }\n        }\n        if (this._namespaceList.length &&\n            (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n            const cleanupFns = [];\n            try {\n                players = this._flushAnimations(cleanupFns, microtaskId);\n            }\n            finally {\n                for (let i = 0; i < cleanupFns.length; i++) {\n                    cleanupFns[i]();\n                }\n            }\n        }\n        else {\n            for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n                const element = this.collectedLeaveElements[i];\n                this.processLeaveNode(element);\n            }\n        }\n        this.totalQueuedPlayers = 0;\n        this.collectedEnterElements.length = 0;\n        this.collectedLeaveElements.length = 0;\n        this._flushFns.forEach(fn => fn());\n        this._flushFns = [];\n        if (this._whenQuietFns.length) {\n            // we move these over to a variable so that\n            // if any new callbacks are registered in another\n            // flush they do not populate the existing set\n            const quietFns = this._whenQuietFns;\n            this._whenQuietFns = [];\n            if (players.length) {\n                optimizeGroupPlayer(players).onDone(() => {\n                    quietFns.forEach(fn => fn());\n                });\n            }\n            else {\n                quietFns.forEach(fn => fn());\n            }\n        }\n    }\n    reportError(errors) {\n        throw triggerTransitionsFailed(errors);\n    }\n    _flushAnimations(cleanupFns, microtaskId) {\n        const subTimelines = new ElementInstructionMap();\n        const skippedPlayers = [];\n        const skippedPlayersMap = new Map();\n        const queuedInstructions = [];\n        const queriedElements = new Map();\n        const allPreStyleElements = new Map();\n        const allPostStyleElements = new Map();\n        const disabledElementsSet = new Set();\n        this.disabledNodes.forEach(node => {\n            disabledElementsSet.add(node);\n            const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n            for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n                disabledElementsSet.add(nodesThatAreDisabled[i]);\n            }\n        });\n        const bodyNode = this.bodyNode;\n        const allTriggerElements = Array.from(this.statesByElement.keys());\n        const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n        // this must occur before the instructions are built below such that\n        // the :enter queries match the elements (since the timeline queries\n        // are fired during instruction building).\n        const enterNodeMapIds = new Map();\n        let i = 0;\n        enterNodeMap.forEach((nodes, root) => {\n            const className = ENTER_CLASSNAME + i++;\n            enterNodeMapIds.set(root, className);\n            nodes.forEach(node => addClass(node, className));\n        });\n        const allLeaveNodes = [];\n        const mergedLeaveNodes = new Set();\n        const leaveNodesWithoutAnimations = new Set();\n        for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n            const element = this.collectedLeaveElements[i];\n            const details = element[REMOVAL_FLAG];\n            if (details && details.setForRemoval) {\n                allLeaveNodes.push(element);\n                mergedLeaveNodes.add(element);\n                if (details.hasAnimation) {\n                    this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n                }\n                else {\n                    leaveNodesWithoutAnimations.add(element);\n                }\n            }\n        }\n        const leaveNodeMapIds = new Map();\n        const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n        leaveNodeMap.forEach((nodes, root) => {\n            const className = LEAVE_CLASSNAME + i++;\n            leaveNodeMapIds.set(root, className);\n            nodes.forEach(node => addClass(node, className));\n        });\n        cleanupFns.push(() => {\n            enterNodeMap.forEach((nodes, root) => {\n                const className = enterNodeMapIds.get(root);\n                nodes.forEach(node => removeClass(node, className));\n            });\n            leaveNodeMap.forEach((nodes, root) => {\n                const className = leaveNodeMapIds.get(root);\n                nodes.forEach(node => removeClass(node, className));\n            });\n            allLeaveNodes.forEach(element => {\n                this.processLeaveNode(element);\n            });\n        });\n        const allPlayers = [];\n        const erroneousTransitions = [];\n        for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n            const ns = this._namespaceList[i];\n            ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n                const player = entry.player;\n                const element = entry.element;\n                allPlayers.push(player);\n                if (this.collectedEnterElements.length) {\n                    const details = element[REMOVAL_FLAG];\n                    // animations for move operations (elements being removed and reinserted,\n                    // e.g. when the order of an *ngFor list changes) are currently not supported\n                    if (details && details.setForMove) {\n                        if (details.previousTriggersValues &&\n                            details.previousTriggersValues.has(entry.triggerName)) {\n                            const previousValue = details.previousTriggersValues.get(entry.triggerName);\n                            // we need to restore the previous trigger value since the element has\n                            // only been moved and hasn't actually left the DOM\n                            const triggersWithStates = this.statesByElement.get(entry.element);\n                            if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {\n                                const state = triggersWithStates.get(entry.triggerName);\n                                state.value = previousValue;\n                                triggersWithStates.set(entry.triggerName, state);\n                            }\n                        }\n                        player.destroy();\n                        return;\n                    }\n                }\n                const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n                const leaveClassName = leaveNodeMapIds.get(element);\n                const enterClassName = enterNodeMapIds.get(element);\n                const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);\n                if (instruction.errors && instruction.errors.length) {\n                    erroneousTransitions.push(instruction);\n                    return;\n                }\n                // even though the element may not be in the DOM, it may still\n                // be added at a later point (due to the mechanics of content\n                // projection and/or dynamic component insertion) therefore it's\n                // important to still style the element.\n                if (nodeIsOrphaned) {\n                    player.onStart(() => eraseStyles(element, instruction.fromStyles));\n                    player.onDestroy(() => setStyles(element, instruction.toStyles));\n                    skippedPlayers.push(player);\n                    return;\n                }\n                // if an unmatched transition is queued and ready to go\n                // then it SHOULD NOT render an animation and cancel the\n                // previously running animations.\n                if (entry.isFallbackTransition) {\n                    player.onStart(() => eraseStyles(element, instruction.fromStyles));\n                    player.onDestroy(() => setStyles(element, instruction.toStyles));\n                    skippedPlayers.push(player);\n                    return;\n                }\n                // this means that if a parent animation uses this animation as a sub-trigger\n                // then it will instruct the timeline builder not to add a player delay, but\n                // instead stretch the first keyframe gap until the animation starts. This is\n                // important in order to prevent extra initialization styles from being\n                // required by the user for the animation.\n                const timelines = [];\n                instruction.timelines.forEach(tl => {\n                    tl.stretchStartingKeyframe = true;\n                    if (!this.disabledNodes.has(tl.element)) {\n                        timelines.push(tl);\n                    }\n                });\n                instruction.timelines = timelines;\n                subTimelines.append(element, instruction.timelines);\n                const tuple = { instruction, player, element };\n                queuedInstructions.push(tuple);\n                instruction.queriedElements.forEach(element => getOrSetDefaultValue(queriedElements, element, []).push(player));\n                instruction.preStyleProps.forEach((stringMap, element) => {\n                    if (stringMap.size) {\n                        let setVal = allPreStyleElements.get(element);\n                        if (!setVal) {\n                            allPreStyleElements.set(element, setVal = new Set());\n                        }\n                        stringMap.forEach((_, prop) => setVal.add(prop));\n                    }\n                });\n                instruction.postStyleProps.forEach((stringMap, element) => {\n                    let setVal = allPostStyleElements.get(element);\n                    if (!setVal) {\n                        allPostStyleElements.set(element, setVal = new Set());\n                    }\n                    stringMap.forEach((_, prop) => setVal.add(prop));\n                });\n            });\n        }\n        if (erroneousTransitions.length) {\n            const errors = [];\n            erroneousTransitions.forEach(instruction => {\n                errors.push(transitionFailed(instruction.triggerName, instruction.errors));\n            });\n            allPlayers.forEach(player => player.destroy());\n            this.reportError(errors);\n        }\n        const allPreviousPlayersMap = new Map();\n        // this map tells us which element in the DOM tree is contained by\n        // which animation. Further down this map will get populated once\n        // the players are built and in doing so we can use it to efficiently\n        // figure out if a sub player is skipped due to a parent player having priority.\n        const animationElementMap = new Map();\n        queuedInstructions.forEach(entry => {\n            const element = entry.element;\n            if (subTimelines.has(element)) {\n                animationElementMap.set(element, element);\n                this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n            }\n        });\n        skippedPlayers.forEach(player => {\n            const element = player.element;\n            const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n            previousPlayers.forEach(prevPlayer => {\n                getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);\n                prevPlayer.destroy();\n            });\n        });\n        // this is a special case for nodes that will be removed either by\n        // having their own leave animations or by being queried in a container\n        // that will be removed once a parent animation is complete. The idea\n        // here is that * styles must be identical to ! styles because of\n        // backwards compatibility (* is also filled in by default in many places).\n        // Otherwise * styles will return an empty value or \"auto\" since the element\n        // passed to getComputedStyle will not be visible (since * === destination)\n        const replaceNodes = allLeaveNodes.filter(node => {\n            return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n        });\n        // POST STAGE: fill the * styles\n        const postStylesMap = new Map();\n        const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_0__.AUTO_STYLE);\n        allLeaveQueriedNodes.forEach(node => {\n            if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n                replaceNodes.push(node);\n            }\n        });\n        // PRE STAGE: fill the ! styles\n        const preStylesMap = new Map();\n        enterNodeMap.forEach((nodes, root) => {\n            cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, _angular_animations__WEBPACK_IMPORTED_MODULE_0__[\"ɵPRE_STYLE\"]);\n        });\n        replaceNodes.forEach(node => {\n            const post = postStylesMap.get(node);\n            const pre = preStylesMap.get(node);\n            postStylesMap.set(node, new Map([...Array.from(post?.entries() ?? []), ...Array.from(pre?.entries() ?? [])]));\n        });\n        const rootPlayers = [];\n        const subPlayers = [];\n        const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n        queuedInstructions.forEach(entry => {\n            const { element, player, instruction } = entry;\n            // this means that it was never consumed by a parent animation which\n            // means that it is independent and therefore should be set for animation\n            if (subTimelines.has(element)) {\n                if (disabledElementsSet.has(element)) {\n                    player.onDestroy(() => setStyles(element, instruction.toStyles));\n                    player.disabled = true;\n                    player.overrideTotalTime(instruction.totalTime);\n                    skippedPlayers.push(player);\n                    return;\n                }\n                // this will flow up the DOM and query the map to figure out\n                // if a parent animation has priority over it. In the situation\n                // that a parent is detected then it will cancel the loop. If\n                // nothing is detected, or it takes a few hops to find a parent,\n                // then it will fill in the missing nodes and signal them as having\n                // a detected parent (or a NO_PARENT value via a special constant).\n                let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n                if (animationElementMap.size > 1) {\n                    let elm = element;\n                    const parentsToAdd = [];\n                    while (elm = elm.parentNode) {\n                        const detectedParent = animationElementMap.get(elm);\n                        if (detectedParent) {\n                            parentWithAnimation = detectedParent;\n                            break;\n                        }\n                        parentsToAdd.push(elm);\n                    }\n                    parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n                }\n                const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);\n                player.setRealPlayer(innerPlayer);\n                if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n                    rootPlayers.push(player);\n                }\n                else {\n                    const parentPlayers = this.playersByElement.get(parentWithAnimation);\n                    if (parentPlayers && parentPlayers.length) {\n                        player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n                    }\n                    skippedPlayers.push(player);\n                }\n            }\n            else {\n                eraseStyles(element, instruction.fromStyles);\n                player.onDestroy(() => setStyles(element, instruction.toStyles));\n                // there still might be a ancestor player animating this\n                // element therefore we will still add it as a sub player\n                // even if its animation may be disabled\n                subPlayers.push(player);\n                if (disabledElementsSet.has(element)) {\n                    skippedPlayers.push(player);\n                }\n            }\n        });\n        // find all of the sub players' corresponding inner animation players\n        subPlayers.forEach(player => {\n            // even if no players are found for a sub animation it\n            // will still complete itself after the next tick since it's Noop\n            const playersForElement = skippedPlayersMap.get(player.element);\n            if (playersForElement && playersForElement.length) {\n                const innerPlayer = optimizeGroupPlayer(playersForElement);\n                player.setRealPlayer(innerPlayer);\n            }\n        });\n        // the reason why we don't actually play the animation is\n        // because all that a skipped player is designed to do is to\n        // fire the start/done transition callback events\n        skippedPlayers.forEach(player => {\n            if (player.parentPlayer) {\n                player.syncPlayerEvents(player.parentPlayer);\n            }\n            else {\n                player.destroy();\n            }\n        });\n        // run through all of the queued removals and see if they\n        // were picked up by a query. If not then perform the removal\n        // operation right away unless a parent animation is ongoing.\n        for (let i = 0; i < allLeaveNodes.length; i++) {\n            const element = allLeaveNodes[i];\n            const details = element[REMOVAL_FLAG];\n            removeClass(element, LEAVE_CLASSNAME);\n            // this means the element has a removal animation that is being\n            // taken care of and therefore the inner elements will hang around\n            // until that animation is over (or the parent queried animation)\n            if (details && details.hasAnimation)\n                continue;\n            let players = [];\n            // if this element is queried or if it contains queried children\n            // then we want for the element not to be removed from the page\n            // until the queried animations have finished\n            if (queriedElements.size) {\n                let queriedPlayerResults = queriedElements.get(element);\n                if (queriedPlayerResults && queriedPlayerResults.length) {\n                    players.push(...queriedPlayerResults);\n                }\n                let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n                for (let j = 0; j < queriedInnerElements.length; j++) {\n                    let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n                    if (queriedPlayers && queriedPlayers.length) {\n                        players.push(...queriedPlayers);\n                    }\n                }\n            }\n            const activePlayers = players.filter(p => !p.destroyed);\n            if (activePlayers.length) {\n                removeNodesAfterAnimationDone(this, element, activePlayers);\n            }\n            else {\n                this.processLeaveNode(element);\n            }\n        }\n        // this is required so the cleanup method doesn't remove them\n        allLeaveNodes.length = 0;\n        rootPlayers.forEach(player => {\n            this.players.push(player);\n            player.onDone(() => {\n                player.destroy();\n                const index = this.players.indexOf(player);\n                this.players.splice(index, 1);\n            });\n            player.play();\n        });\n        return rootPlayers;\n    }\n    elementContainsData(namespaceId, element) {\n        let containsData = false;\n        const details = element[REMOVAL_FLAG];\n        if (details && details.setForRemoval)\n            containsData = true;\n        if (this.playersByElement.has(element))\n            containsData = true;\n        if (this.playersByQueriedElement.has(element))\n            containsData = true;\n        if (this.statesByElement.has(element))\n            containsData = true;\n        return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n    }\n    afterFlush(callback) {\n        this._flushFns.push(callback);\n    }\n    afterFlushAnimationsDone(callback) {\n        this._whenQuietFns.push(callback);\n    }\n    _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {\n        let players = [];\n        if (isQueriedElement) {\n            const queriedElementPlayers = this.playersByQueriedElement.get(element);\n            if (queriedElementPlayers) {\n                players = queriedElementPlayers;\n            }\n        }\n        else {\n            const elementPlayers = this.playersByElement.get(element);\n            if (elementPlayers) {\n                const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n                elementPlayers.forEach(player => {\n                    if (player.queued)\n                        return;\n                    if (!isRemovalAnimation && player.triggerName != triggerName)\n                        return;\n                    players.push(player);\n                });\n            }\n        }\n        if (namespaceId || triggerName) {\n            players = players.filter(player => {\n                if (namespaceId && namespaceId != player.namespaceId)\n                    return false;\n                if (triggerName && triggerName != player.triggerName)\n                    return false;\n                return true;\n            });\n        }\n        return players;\n    }\n    _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {\n        const triggerName = instruction.triggerName;\n        const rootElement = instruction.element;\n        // when a removal animation occurs, ALL previous players are collected\n        // and destroyed (even if they are outside of the current namespace)\n        const targetNameSpaceId = instruction.isRemovalTransition ? undefined : namespaceId;\n        const targetTriggerName = instruction.isRemovalTransition ? undefined : triggerName;\n        for (const timelineInstruction of instruction.timelines) {\n            const element = timelineInstruction.element;\n            const isQueriedElement = element !== rootElement;\n            const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);\n            const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n            previousPlayers.forEach(player => {\n                const realPlayer = player.getRealPlayer();\n                if (realPlayer.beforeDestroy) {\n                    realPlayer.beforeDestroy();\n                }\n                player.destroy();\n                players.push(player);\n            });\n        }\n        // this needs to be done so that the PRE/POST styles can be\n        // computed properly without interfering with the previous animation\n        eraseStyles(rootElement, instruction.fromStyles);\n    }\n    _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {\n        const triggerName = instruction.triggerName;\n        const rootElement = instruction.element;\n        // we first run this so that the previous animation player\n        // data can be passed into the successive animation players\n        const allQueriedPlayers = [];\n        const allConsumedElements = new Set();\n        const allSubElements = new Set();\n        const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n            const element = timelineInstruction.element;\n            allConsumedElements.add(element);\n            // FIXME (matsko): make sure to-be-removed animations are removed properly\n            const details = element[REMOVAL_FLAG];\n            if (details && details.removedBeforeQueried)\n                return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__.NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n            const isQueriedElement = element !== rootElement;\n            const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\n                .map(p => p.getRealPlayer()))\n                .filter(p => {\n                // the `element` is not apart of the AnimationPlayer definition, but\n                // Mock/WebAnimations\n                // use the element within their implementation. This will be added in Angular5 to\n                // AnimationPlayer\n                const pp = p;\n                return pp.element ? pp.element === element : false;\n            });\n            const preStyles = preStylesMap.get(element);\n            const postStyles = postStylesMap.get(element);\n            const keyframes = normalizeKeyframes$1(this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles, postStyles);\n            const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n            // this means that this particular player belongs to a sub trigger. It is\n            // important that we match this player up with the corresponding (@trigger.listener)\n            if (timelineInstruction.subTimeline && skippedPlayersMap) {\n                allSubElements.add(element);\n            }\n            if (isQueriedElement) {\n                const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n                wrappedPlayer.setRealPlayer(player);\n                allQueriedPlayers.push(wrappedPlayer);\n            }\n            return player;\n        });\n        allQueriedPlayers.forEach(player => {\n            getOrSetDefaultValue(this.playersByQueriedElement, player.element, []).push(player);\n            player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n        });\n        allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n        const player = optimizeGroupPlayer(allNewPlayers);\n        player.onDestroy(() => {\n            allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n            setStyles(rootElement, instruction.toStyles);\n        });\n        // this basically makes all of the callbacks for sub element animations\n        // be dependent on the upper players for when they finish\n        allSubElements.forEach(element => {\n            getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);\n        });\n        return player;\n    }\n    _buildPlayer(instruction, keyframes, previousPlayers) {\n        if (keyframes.length > 0) {\n            return this.driver.animate(instruction.element, keyframes, instruction.duration, instruction.delay, instruction.easing, previousPlayers);\n        }\n        // special case for when an empty transition|definition is provided\n        // ... there is no point in rendering an empty animation\n        return new _angular_animations__WEBPACK_IMPORTED_MODULE_0__.NoopAnimationPlayer(instruction.duration, instruction.delay);\n    }\n}\nclass TransitionAnimationPlayer {\n    constructor(namespaceId, triggerName, element) {\n        this.namespaceId = namespaceId;\n        this.triggerName = triggerName;\n        this.element = element;\n        this._player = new _angular_animations__WEBPACK_IMPORTED_MODULE_0__.NoopAnimationPlayer();\n        this._containsRealPlayer = false;\n        this._queuedCallbacks = new Map();\n        this.destroyed = false;\n        this.parentPlayer = null;\n        this.markedForDestroy = false;\n        this.disabled = false;\n        this.queued = true;\n        this.totalTime = 0;\n    }\n    setRealPlayer(player) {\n        if (this._containsRealPlayer)\n            return;\n        this._player = player;\n        this._queuedCallbacks.forEach((callbacks, phase) => {\n            callbacks.forEach(callback => listenOnPlayer(player, phase, undefined, callback));\n        });\n        this._queuedCallbacks.clear();\n        this._containsRealPlayer = true;\n        this.overrideTotalTime(player.totalTime);\n        this.queued = false;\n    }\n    getRealPlayer() {\n        return this._player;\n    }\n    overrideTotalTime(totalTime) {\n        this.totalTime = totalTime;\n    }\n    syncPlayerEvents(player) {\n        const p = this._player;\n        if (p.triggerCallback) {\n            player.onStart(() => p.triggerCallback('start'));\n        }\n        player.onDone(() => this.finish());\n        player.onDestroy(() => this.destroy());\n    }\n    _queueEvent(name, callback) {\n        getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);\n    }\n    onDone(fn) {\n        if (this.queued) {\n            this._queueEvent('done', fn);\n        }\n        this._player.onDone(fn);\n    }\n    onStart(fn) {\n        if (this.queued) {\n            this._queueEvent('start', fn);\n        }\n        this._player.onStart(fn);\n    }\n    onDestroy(fn) {\n        if (this.queued) {\n            this._queueEvent('destroy', fn);\n        }\n        this._player.onDestroy(fn);\n    }\n    init() {\n        this._player.init();\n    }\n    hasStarted() {\n        return this.queued ? false : this._player.hasStarted();\n    }\n    play() {\n        !this.queued && this._player.play();\n    }\n    pause() {\n        !this.queued && this._player.pause();\n    }\n    restart() {\n        !this.queued && this._player.restart();\n    }\n    finish() {\n        this._player.finish();\n    }\n    destroy() {\n        this.destroyed = true;\n        this._player.destroy();\n    }\n    reset() {\n        !this.queued && this._player.reset();\n    }\n    setPosition(p) {\n        if (!this.queued) {\n            this._player.setPosition(p);\n        }\n    }\n    getPosition() {\n        return this.queued ? 0 : this._player.getPosition();\n    }\n    /** @internal */\n    triggerCallback(phaseName) {\n        const p = this._player;\n        if (p.triggerCallback) {\n            p.triggerCallback(phaseName);\n        }\n    }\n}\nfunction deleteOrUnsetInMap(map, key, value) {\n    let currentValues = map.get(key);\n    if (currentValues) {\n        if (currentValues.length) {\n            const index = currentValues.indexOf(value);\n            currentValues.splice(index, 1);\n        }\n        if (currentValues.length == 0) {\n            map.delete(key);\n        }\n    }\n    return currentValues;\n}\nfunction normalizeTriggerValue(value) {\n    // we use `!= null` here because it's the most simple\n    // way to test against a \"falsy\" value without mixing\n    // in empty strings or a zero value. DO NOT OPTIMIZE.\n    return value != null ? value : null;\n}\nfunction isElementNode(node) {\n    return node && node['nodeType'] === 1;\n}\nfunction isTriggerEventValid(eventName) {\n    return eventName == 'start' || eventName == 'done';\n}\nfunction cloakElement(element, value) {\n    const oldValue = element.style.display;\n    element.style.display = value != null ? value : 'none';\n    return oldValue;\n}\nfunction cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {\n    const cloakVals = [];\n    elements.forEach(element => cloakVals.push(cloakElement(element)));\n    const failedElements = [];\n    elementPropsMap.forEach((props, element) => {\n        const styles = new Map();\n        props.forEach(prop => {\n            const value = driver.computeStyle(element, prop, defaultStyle);\n            styles.set(prop, value);\n            // there is no easy way to detect this because a sub element could be removed\n            // by a parent animation element being detached.\n            if (!value || value.length == 0) {\n                element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n                failedElements.push(element);\n            }\n        });\n        valuesMap.set(element, styles);\n    });\n    // we use a index variable here since Set.forEach(a, i) does not return\n    // an index value for the closure (but instead just the value)\n    let i = 0;\n    elements.forEach(element => cloakElement(element, cloakVals[i++]));\n    return failedElements;\n}\n/*\nSince the Angular renderer code will return a collection of inserted\nnodes in all areas of a DOM tree, it's up to this algorithm to figure\nout which nodes are roots for each animation @trigger.\n\nBy placing each inserted node into a Set and traversing upwards, it\nis possible to find the @trigger elements and well any direct *star\ninsertion nodes, if a @trigger root is found then the enter element\nis placed into the Map[@trigger] spot.\n */\nfunction buildRootMap(roots, nodes) {\n    const rootMap = new Map();\n    roots.forEach(root => rootMap.set(root, []));\n    if (nodes.length == 0)\n        return rootMap;\n    const NULL_NODE = 1;\n    const nodeSet = new Set(nodes);\n    const localRootMap = new Map();\n    function getRoot(node) {\n        if (!node)\n            return NULL_NODE;\n        let root = localRootMap.get(node);\n        if (root)\n            return root;\n        const parent = node.parentNode;\n        if (rootMap.has(parent)) { // ngIf inside @trigger\n            root = parent;\n        }\n        else if (nodeSet.has(parent)) { // ngIf inside ngIf\n            root = NULL_NODE;\n        }\n        else { // recurse upwards\n            root = getRoot(parent);\n        }\n        localRootMap.set(node, root);\n        return root;\n    }\n    nodes.forEach(node => {\n        const root = getRoot(node);\n        if (root !== NULL_NODE) {\n            rootMap.get(root).push(node);\n        }\n    });\n    return rootMap;\n}\nfunction addClass(element, className) {\n    element.classList?.add(className);\n}\nfunction removeClass(element, className) {\n    element.classList?.remove(className);\n}\nfunction removeNodesAfterAnimationDone(engine, element, players) {\n    optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\nfunction flattenGroupPlayers(players) {\n    const finalPlayers = [];\n    _flattenGroupPlayersRecur(players, finalPlayers);\n    return finalPlayers;\n}\nfunction _flattenGroupPlayersRecur(players, finalPlayers) {\n    for (let i = 0; i < players.length; i++) {\n        const player = players[i];\n        if (player instanceof _angular_animations__WEBPACK_IMPORTED_MODULE_0__[\"ɵAnimationGroupPlayer\"]) {\n            _flattenGroupPlayersRecur(player.players, finalPlayers);\n        }\n        else {\n            finalPlayers.push(player);\n        }\n    }\n}\nfunction objEquals(a, b) {\n    const k1 = Object.keys(a);\n    const k2 = Object.keys(b);\n    if (k1.length != k2.length)\n        return false;\n    for (let i = 0; i < k1.length; i++) {\n        const prop = k1[i];\n        if (!b.hasOwnProperty(prop) || a[prop] !== b[prop])\n            return false;\n    }\n    return true;\n}\nfunction replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {\n    const postEntry = allPostStyleElements.get(element);\n    if (!postEntry)\n        return false;\n    let preEntry = allPreStyleElements.get(element);\n    if (preEntry) {\n        postEntry.forEach(data => preEntry.add(data));\n    }\n    else {\n        allPreStyleElements.set(element, postEntry);\n    }\n    allPostStyleElements.delete(element);\n    return true;\n}\n\nclass AnimationEngine {\n    constructor(bodyNode, _driver, _normalizer) {\n        this.bodyNode = bodyNode;\n        this._driver = _driver;\n        this._normalizer = _normalizer;\n        this._triggerCache = {};\n        // this method is designed to be overridden by the code that uses this engine\n        this.onRemovalComplete = (element, context) => { };\n        this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, _normalizer);\n        this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, _normalizer);\n        this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);\n    }\n    registerTrigger(componentId, namespaceId, hostElement, name, metadata) {\n        const cacheKey = componentId + '-' + name;\n        let trigger = this._triggerCache[cacheKey];\n        if (!trigger) {\n            const errors = [];\n            const warnings = [];\n            const ast = buildAnimationAst(this._driver, metadata, errors, warnings);\n            if (errors.length) {\n                throw triggerBuildFailed(name, errors);\n            }\n            if (warnings.length) {\n                warnTriggerBuild(name, warnings);\n            }\n            trigger = buildTrigger(name, ast, this._normalizer);\n            this._triggerCache[cacheKey] = trigger;\n        }\n        this._transitionEngine.registerTrigger(namespaceId, name, trigger);\n    }\n    register(namespaceId, hostElement) {\n        this._transitionEngine.register(namespaceId, hostElement);\n    }\n    destroy(namespaceId, context) {\n        this._transitionEngine.destroy(namespaceId, context);\n    }\n    onInsert(namespaceId, element, parent, insertBefore) {\n        this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);\n    }\n    onRemove(namespaceId, element, context, isHostElement) {\n        this._transitionEngine.removeNode(namespaceId, element, isHostElement || false, context);\n    }\n    disableAnimations(element, disable) {\n        this._transitionEngine.markElementAsDisabled(element, disable);\n    }\n    process(namespaceId, element, property, value) {\n        if (property.charAt(0) == '@') {\n            const [id, action] = parseTimelineCommand(property);\n            const args = value;\n            this._timelineEngine.command(id, element, action, args);\n        }\n        else {\n            this._transitionEngine.trigger(namespaceId, element, property, value);\n        }\n    }\n    listen(namespaceId, element, eventName, eventPhase, callback) {\n        // @@listen\n        if (eventName.charAt(0) == '@') {\n            const [id, action] = parseTimelineCommand(eventName);\n            return this._timelineEngine.listen(id, element, action, callback);\n        }\n        return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);\n    }\n    flush(microtaskId = -1) {\n        this._transitionEngine.flush(microtaskId);\n    }\n    get players() {\n        return this._transitionEngine.players\n            .concat(this._timelineEngine.players);\n    }\n    whenRenderingDone() {\n        return this._transitionEngine.whenRenderingDone();\n    }\n}\n\n/**\n * Returns an instance of `SpecialCasedStyles` if and when any special (non animateable) styles are\n * detected.\n *\n * In CSS there exist properties that cannot be animated within a keyframe animation\n * (whether it be via CSS keyframes or web-animations) and the animation implementation\n * will ignore them. This function is designed to detect those special cased styles and\n * return a container that will be executed at the start and end of the animation.\n *\n * @returns an instance of `SpecialCasedStyles` if any special styles are detected otherwise `null`\n */\nfunction packageNonAnimatableStyles(element, styles) {\n    let startStyles = null;\n    let endStyles = null;\n    if (Array.isArray(styles) && styles.length) {\n        startStyles = filterNonAnimatableStyles(styles[0]);\n        if (styles.length > 1) {\n            endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);\n        }\n    }\n    else if (styles instanceof Map) {\n        startStyles = filterNonAnimatableStyles(styles);\n    }\n    return (startStyles || endStyles) ? new SpecialCasedStyles(element, startStyles, endStyles) :\n        null;\n}\n/**\n * Designed to be executed during a keyframe-based animation to apply any special-cased styles.\n *\n * When started (when the `start()` method is run) then the provided `startStyles`\n * will be applied. When finished (when the `finish()` method is called) the\n * `endStyles` will be applied as well any any starting styles. Finally when\n * `destroy()` is called then all styles will be removed.\n */\nclass SpecialCasedStyles {\n    constructor(_element, _startStyles, _endStyles) {\n        this._element = _element;\n        this._startStyles = _startStyles;\n        this._endStyles = _endStyles;\n        this._state = 0 /* SpecialCasedStylesState.Pending */;\n        let initialStyles = SpecialCasedStyles.initialStylesByElement.get(_element);\n        if (!initialStyles) {\n            SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = new Map());\n        }\n        this._initialStyles = initialStyles;\n    }\n    start() {\n        if (this._state < 1 /* SpecialCasedStylesState.Started */) {\n            if (this._startStyles) {\n                setStyles(this._element, this._startStyles, this._initialStyles);\n            }\n            this._state = 1 /* SpecialCasedStylesState.Started */;\n        }\n    }\n    finish() {\n        this.start();\n        if (this._state < 2 /* SpecialCasedStylesState.Finished */) {\n            setStyles(this._element, this._initialStyles);\n            if (this._endStyles) {\n                setStyles(this._element, this._endStyles);\n                this._endStyles = null;\n            }\n            this._state = 1 /* SpecialCasedStylesState.Started */;\n        }\n    }\n    destroy() {\n        this.finish();\n        if (this._state < 3 /* SpecialCasedStylesState.Destroyed */) {\n            SpecialCasedStyles.initialStylesByElement.delete(this._element);\n            if (this._startStyles) {\n                eraseStyles(this._element, this._startStyles);\n                this._endStyles = null;\n            }\n            if (this._endStyles) {\n                eraseStyles(this._element, this._endStyles);\n                this._endStyles = null;\n            }\n            setStyles(this._element, this._initialStyles);\n            this._state = 3 /* SpecialCasedStylesState.Destroyed */;\n        }\n    }\n}\nSpecialCasedStyles.initialStylesByElement = ( /* @__PURE__ */new WeakMap());\nfunction filterNonAnimatableStyles(styles) {\n    let result = null;\n    styles.forEach((val, prop) => {\n        if (isNonAnimatableStyle(prop)) {\n            result = result || new Map();\n            result.set(prop, val);\n        }\n    });\n    return result;\n}\nfunction isNonAnimatableStyle(prop) {\n    return prop === 'display' || prop === 'position';\n}\n\nclass WebAnimationsPlayer {\n    constructor(element, keyframes, options, _specialStyles) {\n        this.element = element;\n        this.keyframes = keyframes;\n        this.options = options;\n        this._specialStyles = _specialStyles;\n        this._onDoneFns = [];\n        this._onStartFns = [];\n        this._onDestroyFns = [];\n        this._initialized = false;\n        this._finished = false;\n        this._started = false;\n        this._destroyed = false;\n        // the following original fns are persistent copies of the _onStartFns and _onDoneFns\n        // and are used to reset the fns to their original values upon reset()\n        // (since the _onStartFns and _onDoneFns get deleted after they are called)\n        this._originalOnDoneFns = [];\n        this._originalOnStartFns = [];\n        this.time = 0;\n        this.parentPlayer = null;\n        this.currentSnapshot = new Map();\n        this._duration = options['duration'];\n        this._delay = options['delay'] || 0;\n        this.time = this._duration + this._delay;\n    }\n    _onFinish() {\n        if (!this._finished) {\n            this._finished = true;\n            this._onDoneFns.forEach(fn => fn());\n            this._onDoneFns = [];\n        }\n    }\n    init() {\n        this._buildPlayer();\n        this._preparePlayerBeforeStart();\n    }\n    _buildPlayer() {\n        if (this._initialized)\n            return;\n        this._initialized = true;\n        const keyframes = this.keyframes;\n        // @ts-expect-error overwriting a readonly property\n        this.domPlayer = this._triggerWebAnimation(this.element, keyframes, this.options);\n        this._finalKeyframe = keyframes.length ? keyframes[keyframes.length - 1] : new Map();\n        this.domPlayer.addEventListener('finish', () => this._onFinish());\n    }\n    _preparePlayerBeforeStart() {\n        // this is required so that the player doesn't start to animate right away\n        if (this._delay) {\n            this._resetDomPlayerState();\n        }\n        else {\n            this.domPlayer.pause();\n        }\n    }\n    _convertKeyframesToObject(keyframes) {\n        const kfs = [];\n        keyframes.forEach(frame => {\n            kfs.push(Object.fromEntries(frame));\n        });\n        return kfs;\n    }\n    /** @internal */\n    _triggerWebAnimation(element, keyframes, options) {\n        // jscompiler doesn't seem to know animate is a native property because it's not fully\n        // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]\n        return element['animate'](this._convertKeyframesToObject(keyframes), options);\n    }\n    onStart(fn) {\n        this._originalOnStartFns.push(fn);\n        this._onStartFns.push(fn);\n    }\n    onDone(fn) {\n        this._originalOnDoneFns.push(fn);\n        this._onDoneFns.push(fn);\n    }\n    onDestroy(fn) {\n        this._onDestroyFns.push(fn);\n    }\n    play() {\n        this._buildPlayer();\n        if (!this.hasStarted()) {\n            this._onStartFns.forEach(fn => fn());\n            this._onStartFns = [];\n            this._started = true;\n            if (this._specialStyles) {\n                this._specialStyles.start();\n            }\n        }\n        this.domPlayer.play();\n    }\n    pause() {\n        this.init();\n        this.domPlayer.pause();\n    }\n    finish() {\n        this.init();\n        if (this._specialStyles) {\n            this._specialStyles.finish();\n        }\n        this._onFinish();\n        this.domPlayer.finish();\n    }\n    reset() {\n        this._resetDomPlayerState();\n        this._destroyed = false;\n        this._finished = false;\n        this._started = false;\n        this._onStartFns = this._originalOnStartFns;\n        this._onDoneFns = this._originalOnDoneFns;\n    }\n    _resetDomPlayerState() {\n        if (this.domPlayer) {\n            this.domPlayer.cancel();\n        }\n    }\n    restart() {\n        this.reset();\n        this.play();\n    }\n    hasStarted() {\n        return this._started;\n    }\n    destroy() {\n        if (!this._destroyed) {\n            this._destroyed = true;\n            this._resetDomPlayerState();\n            this._onFinish();\n            if (this._specialStyles) {\n                this._specialStyles.destroy();\n            }\n            this._onDestroyFns.forEach(fn => fn());\n            this._onDestroyFns = [];\n        }\n    }\n    setPosition(p) {\n        if (this.domPlayer === undefined) {\n            this.init();\n        }\n        this.domPlayer.currentTime = p * this.time;\n    }\n    getPosition() {\n        return this.domPlayer.currentTime / this.time;\n    }\n    get totalTime() {\n        return this._delay + this._duration;\n    }\n    beforeDestroy() {\n        const styles = new Map();\n        if (this.hasStarted()) {\n            // note: this code is invoked only when the `play` function was called prior to this\n            // (thus `hasStarted` returns true), this implies that the code that initializes\n            // `_finalKeyframe` has also been executed and the non-null assertion can be safely used here\n            const finalKeyframe = this._finalKeyframe;\n            finalKeyframe.forEach((val, prop) => {\n                if (prop !== 'offset') {\n                    styles.set(prop, this._finished ? val : computeStyle(this.element, prop));\n                }\n            });\n        }\n        this.currentSnapshot = styles;\n    }\n    /** @internal */\n    triggerCallback(phaseName) {\n        const methods = phaseName === 'start' ? this._onStartFns : this._onDoneFns;\n        methods.forEach(fn => fn());\n        methods.length = 0;\n    }\n}\n\nclass WebAnimationsDriver {\n    validateStyleProperty(prop) {\n        // Perform actual validation in dev mode only, in prod mode this check is a noop.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            return validateStyleProperty(prop);\n        }\n        return true;\n    }\n    validateAnimatableStyleProperty(prop) {\n        // Perform actual validation in dev mode only, in prod mode this check is a noop.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const cssProp = camelCaseToDashCase(prop);\n            return validateWebAnimatableStyleProperty(cssProp);\n        }\n        return true;\n    }\n    matchesElement(_element, _selector) {\n        // This method is deprecated and no longer in use so we return false.\n        return false;\n    }\n    containsElement(elm1, elm2) {\n        return containsElement(elm1, elm2);\n    }\n    getParentElement(element) {\n        return getParentElement(element);\n    }\n    query(element, selector, multi) {\n        return invokeQuery(element, selector, multi);\n    }\n    computeStyle(element, prop, defaultValue) {\n        return window.getComputedStyle(element)[prop];\n    }\n    animate(element, keyframes, duration, delay, easing, previousPlayers = []) {\n        const fill = delay == 0 ? 'both' : 'forwards';\n        const playerOptions = { duration, delay, fill };\n        // we check for this to avoid having a null|undefined value be present\n        // for the easing (which results in an error for certain browsers #9752)\n        if (easing) {\n            playerOptions['easing'] = easing;\n        }\n        const previousStyles = new Map();\n        const previousWebAnimationPlayers = previousPlayers.filter(player => player instanceof WebAnimationsPlayer);\n        if (allowPreviousPlayerStylesMerge(duration, delay)) {\n            previousWebAnimationPlayers.forEach(player => {\n                player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));\n            });\n        }\n        let _keyframes = normalizeKeyframes(keyframes).map(styles => copyStyles(styles));\n        _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);\n        const specialStyles = packageNonAnimatableStyles(element, _keyframes);\n        return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);\n    }\n}\n\n/**\n * @module\n * @description\n * Entry point for all animation APIs of the animation browser package.\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=browser.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9mZXNtMjAyMC9icm93c2VyLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvYW5pbWF0aW9ucy9mZXNtMjAyMC9icm93c2VyLm1qcz82M2IzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2MTUuMi43XG4gKiAoYykgMjAxMC0yMDIyIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IMm1QW5pbWF0aW9uR3JvdXBQbGF5ZXIsIE5vb3BBbmltYXRpb25QbGF5ZXIsIEFVVE9fU1RZTEUsIMm1UFJFX1NUWUxFLCBzZXF1ZW5jZSwgc3R5bGUgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgybVSdW50aW1lRXJyb3IsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuY29uc3QgTElORV9TVEFSVCA9ICdcXG4gLSAnO1xuZnVuY3Rpb24gaW52YWxpZFRpbWluZ1ZhbHVlKGV4cCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzAwMCAvKiBSdW50aW1lRXJyb3JDb2RlLklOVkFMSURfVElNSU5HX1ZBTFVFICovLCBuZ0Rldk1vZGUgJiYgYFRoZSBwcm92aWRlZCB0aW1pbmcgdmFsdWUgXCIke2V4cH1cIiBpcyBpbnZhbGlkLmApO1xufVxuZnVuY3Rpb24gbmVnYXRpdmVTdGVwVmFsdWUoKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMTAwIC8qIFJ1bnRpbWVFcnJvckNvZGUuTkVHQVRJVkVfU1RFUF9WQUxVRSAqLywgbmdEZXZNb2RlICYmICdEdXJhdGlvbiB2YWx1ZXMgYmVsb3cgMCBhcmUgbm90IGFsbG93ZWQgZm9yIHRoaXMgYW5pbWF0aW9uIHN0ZXAuJyk7XG59XG5mdW5jdGlvbiBuZWdhdGl2ZURlbGF5VmFsdWUoKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMTAxIC8qIFJ1bnRpbWVFcnJvckNvZGUuTkVHQVRJVkVfREVMQVlfVkFMVUUgKi8sIG5nRGV2TW9kZSAmJiAnRGVsYXkgdmFsdWVzIGJlbG93IDAgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGlzIGFuaW1hdGlvbiBzdGVwLicpO1xufVxuZnVuY3Rpb24gaW52YWxpZFN0eWxlUGFyYW1zKHZhck5hbWUpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMDEgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX1NUWUxFX1BBUkFNUyAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBVbmFibGUgdG8gcmVzb2x2ZSB0aGUgbG9jYWwgYW5pbWF0aW9uIHBhcmFtICR7dmFyTmFtZX0gaW4gdGhlIGdpdmVuIGxpc3Qgb2YgdmFsdWVzYCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkUGFyYW1WYWx1ZSh2YXJOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMDAzIC8qIFJ1bnRpbWVFcnJvckNvZGUuSU5WQUxJRF9QQVJBTV9WQUxVRSAqLywgbmdEZXZNb2RlICYmIGBQbGVhc2UgcHJvdmlkZSBhIHZhbHVlIGZvciB0aGUgYW5pbWF0aW9uIHBhcmFtICR7dmFyTmFtZX1gKTtcbn1cbmZ1bmN0aW9uIGludmFsaWROb2RlVHlwZShub2RlVHlwZSkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzAwNCAvKiBSdW50aW1lRXJyb3JDb2RlLklOVkFMSURfTk9ERV9UWVBFICovLCBuZ0Rldk1vZGUgJiYgYFVuYWJsZSB0byByZXNvbHZlIGFuaW1hdGlvbiBtZXRhZGF0YSBub2RlICMke25vZGVUeXBlfWApO1xufVxuZnVuY3Rpb24gaW52YWxpZENzc1VuaXRWYWx1ZSh1c2VyUHJvdmlkZWRQcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMDUgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX0NTU19VTklUX1ZBTFVFICovLCBuZ0Rldk1vZGUgJiYgYFBsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yICR7dXNlclByb3ZpZGVkUHJvcGVydHl9OiR7dmFsdWV9YCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkVHJpZ2dlcigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMDYgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX1RSSUdHRVIgKi8sIG5nRGV2TW9kZSAmJlxuICAgICAgICAnYW5pbWF0aW9uIHRyaWdnZXJzIGNhbm5vdCBiZSBwcmVmaXhlZCB3aXRoIGFuIGBAYCBzaWduIChlLmcuIHRyaWdnZXIoXFwnQGZvb1xcJywgWy4uLl0pKScpO1xufVxuZnVuY3Rpb24gaW52YWxpZERlZmluaXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMDA3IC8qIFJ1bnRpbWVFcnJvckNvZGUuSU5WQUxJRF9ERUZJTklUSU9OICovLCBuZ0Rldk1vZGUgJiYgJ29ubHkgc3RhdGUoKSBhbmQgdHJhbnNpdGlvbigpIGRlZmluaXRpb25zIGNhbiBzaXQgaW5zaWRlIG9mIGEgdHJpZ2dlcigpJyk7XG59XG5mdW5jdGlvbiBpbnZhbGlkU3RhdGUobWV0YWRhdGFOYW1lLCBtaXNzaW5nU3Vicykge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzAwOCAvKiBSdW50aW1lRXJyb3JDb2RlLklOVkFMSURfU1RBVEUgKi8sIG5nRGV2TW9kZSAmJlxuICAgICAgICBgc3RhdGUoXCIke21ldGFkYXRhTmFtZX1cIiwgLi4uKSBtdXN0IGRlZmluZSBkZWZhdWx0IHZhbHVlcyBmb3IgYWxsIHRoZSBmb2xsb3dpbmcgc3R5bGUgc3Vic3RpdHV0aW9uczogJHttaXNzaW5nU3Vicy5qb2luKCcsICcpfWApO1xufVxuZnVuY3Rpb24gaW52YWxpZFN0eWxlVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMDIgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX1NUWUxFX1ZBTFVFICovLCBuZ0Rldk1vZGUgJiYgYFRoZSBwcm92aWRlZCBzdHlsZSBzdHJpbmcgdmFsdWUgJHt2YWx1ZX0gaXMgbm90IGFsbG93ZWQuYCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkUHJvcGVydHkocHJvcCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzAwOSAvKiBSdW50aW1lRXJyb3JDb2RlLklOVkFMSURfUFJPUEVSVFkgKi8sIG5nRGV2TW9kZSAmJlxuICAgICAgICBgVGhlIHByb3ZpZGVkIGFuaW1hdGlvbiBwcm9wZXJ0eSBcIiR7cHJvcH1cIiBpcyBub3QgYSBzdXBwb3J0ZWQgQ1NTIHByb3BlcnR5IGZvciBhbmltYXRpb25zYCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkUGFyYWxsZWxBbmltYXRpb24ocHJvcCwgZmlyc3RTdGFydCwgZmlyc3RFbmQsIHNlY29uZFN0YXJ0LCBzZWNvbmRFbmQpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMTAgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX1BBUkFMTEVMX0FOSU1BVElPTiAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBUaGUgQ1NTIHByb3BlcnR5IFwiJHtwcm9wfVwiIHRoYXQgZXhpc3RzIGJldHdlZW4gdGhlIHRpbWVzIG9mIFwiJHtmaXJzdFN0YXJ0fW1zXCIgYW5kIFwiJHtmaXJzdEVuZH1tc1wiIGlzIGFsc28gYmVpbmcgYW5pbWF0ZWQgaW4gYSBwYXJhbGxlbCBhbmltYXRpb24gYmV0d2VlbiB0aGUgdGltZXMgb2YgXCIke3NlY29uZFN0YXJ0fW1zXCIgYW5kIFwiJHtzZWNvbmRFbmR9bXNcImApO1xufVxuZnVuY3Rpb24gaW52YWxpZEtleWZyYW1lcygpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMTEgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX0tFWUZSQU1FUyAqLywgbmdEZXZNb2RlICYmIGBrZXlmcmFtZXMoKSBtdXN0IGJlIHBsYWNlZCBpbnNpZGUgb2YgYSBjYWxsIHRvIGFuaW1hdGUoKWApO1xufVxuZnVuY3Rpb24gaW52YWxpZE9mZnNldCgpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMTIgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX09GRlNFVCAqLywgbmdEZXZNb2RlICYmIGBQbGVhc2UgZW5zdXJlIHRoYXQgYWxsIGtleWZyYW1lIG9mZnNldHMgYXJlIGJldHdlZW4gMCBhbmQgMWApO1xufVxuZnVuY3Rpb24ga2V5ZnJhbWVPZmZzZXRzT3V0T2ZPcmRlcigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMyMDAgLyogUnVudGltZUVycm9yQ29kZS5LRVlGUkFNRV9PRkZTRVRTX09VVF9PRl9PUkRFUiAqLywgbmdEZXZNb2RlICYmIGBQbGVhc2UgZW5zdXJlIHRoYXQgYWxsIGtleWZyYW1lIG9mZnNldHMgYXJlIGluIG9yZGVyYCk7XG59XG5mdW5jdGlvbiBrZXlmcmFtZXNNaXNzaW5nT2Zmc2V0cygpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMyMDIgLyogUnVudGltZUVycm9yQ29kZS5LRVlGUkFNRVNfTUlTU0lOR19PRkZTRVRTICovLCBuZ0Rldk1vZGUgJiYgYE5vdCBhbGwgc3R5bGUoKSBzdGVwcyB3aXRoaW4gdGhlIGRlY2xhcmVkIGtleWZyYW1lcygpIGNvbnRhaW4gb2Zmc2V0c2ApO1xufVxuZnVuY3Rpb24gaW52YWxpZFN0YWdnZXIoKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMDEzIC8qIFJ1bnRpbWVFcnJvckNvZGUuSU5WQUxJRF9TVEFHR0VSICovLCBuZ0Rldk1vZGUgJiYgYHN0YWdnZXIoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBxdWVyeSgpYCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkUXVlcnkoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMwMTQgLyogUnVudGltZUVycm9yQ29kZS5JTlZBTElEX1FVRVJZICovLCBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYFxcYHF1ZXJ5KFwiJHtzZWxlY3Rvcn1cIilcXGAgcmV0dXJuZWQgemVybyBlbGVtZW50cy4gKFVzZSBcXGBxdWVyeShcIiR7c2VsZWN0b3J9XCIsIHsgb3B0aW9uYWw6IHRydWUgfSlcXGAgaWYgeW91IHdpc2ggdG8gYWxsb3cgdGhpcy4pYCk7XG59XG5mdW5jdGlvbiBpbnZhbGlkRXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMDE1IC8qIFJ1bnRpbWVFcnJvckNvZGUuSU5WQUxJRF9FWFBSRVNTSU9OICovLCBuZ0Rldk1vZGUgJiYgYFRoZSBwcm92aWRlZCB0cmFuc2l0aW9uIGV4cHJlc3Npb24gXCIke2V4cHJ9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25BbGlhcyhhbGlhcykge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzAxNiAvKiBSdW50aW1lRXJyb3JDb2RlLklOVkFMSURfVFJBTlNJVElPTl9BTElBUyAqLywgbmdEZXZNb2RlICYmIGBUaGUgdHJhbnNpdGlvbiBhbGlhcyB2YWx1ZSBcIiR7YWxpYXN9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGlvbkZhaWxlZChlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDM1MDAgLyogUnVudGltZUVycm9yQ29kZS5WQUxJREFUSU9OX0ZBSUxFRCAqLywgbmdEZXZNb2RlICYmIGBhbmltYXRpb24gdmFsaWRhdGlvbiBmYWlsZWQ6XFxuJHtlcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuJyl9YCk7XG59XG5mdW5jdGlvbiBidWlsZGluZ0ZhaWxlZChlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDM1MDEgLyogUnVudGltZUVycm9yQ29kZS5CVUlMRElOR19GQUlMRUQgKi8sIG5nRGV2TW9kZSAmJiBgYW5pbWF0aW9uIGJ1aWxkaW5nIGZhaWxlZDpcXG4ke2Vycm9ycy5tYXAoZXJyID0+IGVyci5tZXNzYWdlKS5qb2luKCdcXG4nKX1gKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJCdWlsZEZhaWxlZChuYW1lLCBlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDM0MDQgLyogUnVudGltZUVycm9yQ29kZS5UUklHR0VSX0JVSUxEX0ZBSUxFRCAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBUaGUgYW5pbWF0aW9uIHRyaWdnZXIgXCIke25hbWV9XCIgaGFzIGZhaWxlZCB0byBidWlsZCBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6XFxuIC0gJHtlcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuIC0gJyl9YCk7XG59XG5mdW5jdGlvbiBhbmltYXRpb25GYWlsZWQoZXJyb3JzKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzNTAyIC8qIFJ1bnRpbWVFcnJvckNvZGUuQU5JTUFUSU9OX0ZBSUxFRCAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBVbmFibGUgdG8gYW5pbWF0ZSBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6JHtMSU5FX1NUQVJUfSR7ZXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oTElORV9TVEFSVCl9YCk7XG59XG5mdW5jdGlvbiByZWdpc3RlckZhaWxlZChlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDM1MDMgLyogUnVudGltZUVycm9yQ29kZS5SRUdJU1RSQVRJT05fRkFJTEVEICovLCBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYFVuYWJsZSB0byBidWlsZCB0aGUgYW5pbWF0aW9uIGR1ZSB0byB0aGUgZm9sbG93aW5nIGVycm9yczogJHtlcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuJyl9YCk7XG59XG5mdW5jdGlvbiBtaXNzaW5nT3JEZXN0cm95ZWRBbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMzAwIC8qIFJ1bnRpbWVFcnJvckNvZGUuTUlTU0lOR19PUl9ERVNUUk9ZRURfQU5JTUFUSU9OICovLCBuZ0Rldk1vZGUgJiYgJ1RoZSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGRvZXNuXFwndCBleGlzdCBvciBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCcpO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uRmFpbGVkKGVycm9ycykge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzUwNCAvKiBSdW50aW1lRXJyb3JDb2RlLkNSRUFURV9BTklNQVRJT05fRkFJTEVEICovLCBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYFVuYWJsZSB0byBjcmVhdGUgdGhlIGFuaW1hdGlvbiBkdWUgdG8gdGhlIGZvbGxvd2luZyBlcnJvcnM6JHtlcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuJyl9YCk7XG59XG5mdW5jdGlvbiBtaXNzaW5nUGxheWVyKGlkKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzMzAxIC8qIFJ1bnRpbWVFcnJvckNvZGUuTUlTU0lOR19QTEFZRVIgKi8sIG5nRGV2TW9kZSAmJiBgVW5hYmxlIHRvIGZpbmQgdGhlIHRpbWVsaW5lIHBsYXllciByZWZlcmVuY2VkIGJ5ICR7aWR9YCk7XG59XG5mdW5jdGlvbiBtaXNzaW5nVHJpZ2dlcihwaGFzZSwgbmFtZSkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzMwMiAvKiBSdW50aW1lRXJyb3JDb2RlLk1JU1NJTkdfVFJJR0dFUiAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBVbmFibGUgdG8gbGlzdGVuIG9uIHRoZSBhbmltYXRpb24gdHJpZ2dlciBldmVudCBcIiR7cGhhc2V9XCIgYmVjYXVzZSB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXCIke25hbWV9XCIgZG9lc25cXCd0IGV4aXN0IWApO1xufVxuZnVuY3Rpb24gbWlzc2luZ0V2ZW50KG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDMzMDMgLyogUnVudGltZUVycm9yQ29kZS5NSVNTSU5HX0VWRU5UICovLCBuZ0Rldk1vZGUgJiZcbiAgICAgICAgYFVuYWJsZSB0byBsaXN0ZW4gb24gdGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFwiJHtuYW1lfVwiIGJlY2F1c2UgdGhlIHByb3ZpZGVkIGV2ZW50IGlzIHVuZGVmaW5lZCFgKTtcbn1cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkVHJpZ2dlckV2ZW50KHBoYXNlLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzNDAwIC8qIFJ1bnRpbWVFcnJvckNvZGUuVU5TVVBQT1JURURfVFJJR0dFUl9FVkVOVCAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBUaGUgcHJvdmlkZWQgYW5pbWF0aW9uIHRyaWdnZXIgZXZlbnQgXCIke3BoYXNlfVwiIGZvciB0aGUgYW5pbWF0aW9uIHRyaWdnZXIgXCIke25hbWV9XCIgaXMgbm90IHN1cHBvcnRlZCFgKTtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJlZFRyaWdnZXIobmFtZSkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMzQwMSAvKiBSdW50aW1lRXJyb3JDb2RlLlVOUkVHSVNURVJFRF9UUklHR0VSICovLCBuZ0Rldk1vZGUgJiYgYFRoZSBwcm92aWRlZCBhbmltYXRpb24gdHJpZ2dlciBcIiR7bmFtZX1cIiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCFgKTtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJUcmFuc2l0aW9uc0ZhaWxlZChlcnJvcnMpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDM0MDIgLyogUnVudGltZUVycm9yQ29kZS5UUklHR0VSX1RSQU5TSVRJT05TX0ZBSUxFRCAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBVbmFibGUgdG8gcHJvY2VzcyBhbmltYXRpb25zIGR1ZSB0byB0aGUgZm9sbG93aW5nIGZhaWxlZCB0cmlnZ2VyIHRyYW5zaXRpb25zXFxuICR7ZXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oJ1xcbicpfWApO1xufVxuZnVuY3Rpb24gdHJpZ2dlclBhcnNpbmdGYWlsZWQobmFtZSwgZXJyb3JzKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzNDAzIC8qIFJ1bnRpbWVFcnJvckNvZGUuVFJJR0dFUl9QQVJTSU5HX0ZBSUxFRCAqLywgbmdEZXZNb2RlICYmXG4gICAgICAgIGBBbmltYXRpb24gcGFyc2luZyBmb3IgdGhlICR7bmFtZX0gdHJpZ2dlciBoYXZlIGZhaWxlZDoke0xJTkVfU1RBUlR9JHtlcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbihMSU5FX1NUQVJUKX1gKTtcbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25GYWlsZWQobmFtZSwgZXJyb3JzKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigzNTA1IC8qIFJ1bnRpbWVFcnJvckNvZGUuVFJBTlNJVElPTl9GQUlMRUQgKi8sIG5nRGV2TW9kZSAmJiBgQCR7bmFtZX0gaGFzIGZhaWxlZCBkdWUgdG86XFxuICR7ZXJyb3JzLm1hcChlcnIgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oJ1xcbi0gJyl9YCk7XG59XG5cbi8qKlxuICogU2V0IG9mIGFsbCBhbmltYXRhYmxlIENTUyBwcm9wZXJ0aWVzXG4gKlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX2FuaW1hdGVkX3Byb3BlcnRpZXNcbiAqL1xuY29uc3QgQU5JTUFUQUJMRV9QUk9QX1NFVCA9IG5ldyBTZXQoW1xuICAgICctbW96LW91dGxpbmUtcmFkaXVzJyxcbiAgICAnLW1vei1vdXRsaW5lLXJhZGl1cy1ib3R0b21sZWZ0JyxcbiAgICAnLW1vei1vdXRsaW5lLXJhZGl1cy1ib3R0b21yaWdodCcsXG4gICAgJy1tb3otb3V0bGluZS1yYWRpdXMtdG9wbGVmdCcsXG4gICAgJy1tb3otb3V0bGluZS1yYWRpdXMtdG9wcmlnaHQnLFxuICAgICctbXMtZ3JpZC1jb2x1bW5zJyxcbiAgICAnLW1zLWdyaWQtcm93cycsXG4gICAgJy13ZWJraXQtbGluZS1jbGFtcCcsXG4gICAgJy13ZWJraXQtdGV4dC1maWxsLWNvbG9yJyxcbiAgICAnLXdlYmtpdC10ZXh0LXN0cm9rZScsXG4gICAgJy13ZWJraXQtdGV4dC1zdHJva2UtY29sb3InLFxuICAgICdhY2NlbnQtY29sb3InLFxuICAgICdhbGwnLFxuICAgICdiYWNrZHJvcC1maWx0ZXInLFxuICAgICdiYWNrZ3JvdW5kJyxcbiAgICAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24nLFxuICAgICdiYWNrZ3JvdW5kLXNpemUnLFxuICAgICdibG9jay1zaXplJyxcbiAgICAnYm9yZGVyJyxcbiAgICAnYm9yZGVyLWJsb2NrLWVuZCcsXG4gICAgJ2JvcmRlci1ibG9jay1lbmQtY29sb3InLFxuICAgICdib3JkZXItYmxvY2stZW5kLXdpZHRoJyxcbiAgICAnYm9yZGVyLWJsb2NrLXN0YXJ0JyxcbiAgICAnYm9yZGVyLWJsb2NrLXN0YXJ0LWNvbG9yJyxcbiAgICAnYm9yZGVyLWJsb2NrLXN0YXJ0LXdpZHRoJyxcbiAgICAnYm9yZGVyLWJvdHRvbScsXG4gICAgJ2JvcmRlci1ib3R0b20tY29sb3InLFxuICAgICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJyxcbiAgICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnLFxuICAgICdib3JkZXItYm90dG9tLXdpZHRoJyxcbiAgICAnYm9yZGVyLWNvbG9yJyxcbiAgICAnYm9yZGVyLWVuZC1lbmQtcmFkaXVzJyxcbiAgICAnYm9yZGVyLWVuZC1zdGFydC1yYWRpdXMnLFxuICAgICdib3JkZXItaW1hZ2Utb3V0c2V0JyxcbiAgICAnYm9yZGVyLWltYWdlLXNsaWNlJyxcbiAgICAnYm9yZGVyLWltYWdlLXdpZHRoJyxcbiAgICAnYm9yZGVyLWlubGluZS1lbmQnLFxuICAgICdib3JkZXItaW5saW5lLWVuZC1jb2xvcicsXG4gICAgJ2JvcmRlci1pbmxpbmUtZW5kLXdpZHRoJyxcbiAgICAnYm9yZGVyLWlubGluZS1zdGFydCcsXG4gICAgJ2JvcmRlci1pbmxpbmUtc3RhcnQtY29sb3InLFxuICAgICdib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoJyxcbiAgICAnYm9yZGVyLWxlZnQnLFxuICAgICdib3JkZXItbGVmdC1jb2xvcicsXG4gICAgJ2JvcmRlci1sZWZ0LXdpZHRoJyxcbiAgICAnYm9yZGVyLXJhZGl1cycsXG4gICAgJ2JvcmRlci1yaWdodCcsXG4gICAgJ2JvcmRlci1yaWdodC1jb2xvcicsXG4gICAgJ2JvcmRlci1yaWdodC13aWR0aCcsXG4gICAgJ2JvcmRlci1zdGFydC1lbmQtcmFkaXVzJyxcbiAgICAnYm9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1cycsXG4gICAgJ2JvcmRlci10b3AnLFxuICAgICdib3JkZXItdG9wLWNvbG9yJyxcbiAgICAnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycsXG4gICAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJyxcbiAgICAnYm9yZGVyLXRvcC13aWR0aCcsXG4gICAgJ2JvcmRlci13aWR0aCcsXG4gICAgJ2JvdHRvbScsXG4gICAgJ2JveC1zaGFkb3cnLFxuICAgICdjYXJldC1jb2xvcicsXG4gICAgJ2NsaXAnLFxuICAgICdjbGlwLXBhdGgnLFxuICAgICdjb2xvcicsXG4gICAgJ2NvbHVtbi1jb3VudCcsXG4gICAgJ2NvbHVtbi1nYXAnLFxuICAgICdjb2x1bW4tcnVsZScsXG4gICAgJ2NvbHVtbi1ydWxlLWNvbG9yJyxcbiAgICAnY29sdW1uLXJ1bGUtd2lkdGgnLFxuICAgICdjb2x1bW4td2lkdGgnLFxuICAgICdjb2x1bW5zJyxcbiAgICAnZmlsdGVyJyxcbiAgICAnZmxleCcsXG4gICAgJ2ZsZXgtYmFzaXMnLFxuICAgICdmbGV4LWdyb3cnLFxuICAgICdmbGV4LXNocmluaycsXG4gICAgJ2ZvbnQnLFxuICAgICdmb250LXNpemUnLFxuICAgICdmb250LXNpemUtYWRqdXN0JyxcbiAgICAnZm9udC1zdHJldGNoJyxcbiAgICAnZm9udC12YXJpYXRpb24tc2V0dGluZ3MnLFxuICAgICdmb250LXdlaWdodCcsXG4gICAgJ2dhcCcsXG4gICAgJ2dyaWQtY29sdW1uLWdhcCcsXG4gICAgJ2dyaWQtZ2FwJyxcbiAgICAnZ3JpZC1yb3ctZ2FwJyxcbiAgICAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJyxcbiAgICAnZ3JpZC10ZW1wbGF0ZS1yb3dzJyxcbiAgICAnaGVpZ2h0JyxcbiAgICAnaW5saW5lLXNpemUnLFxuICAgICdpbnB1dC1zZWN1cml0eScsXG4gICAgJ2luc2V0JyxcbiAgICAnaW5zZXQtYmxvY2snLFxuICAgICdpbnNldC1ibG9jay1lbmQnLFxuICAgICdpbnNldC1ibG9jay1zdGFydCcsXG4gICAgJ2luc2V0LWlubGluZScsXG4gICAgJ2luc2V0LWlubGluZS1lbmQnLFxuICAgICdpbnNldC1pbmxpbmUtc3RhcnQnLFxuICAgICdsZWZ0JyxcbiAgICAnbGV0dGVyLXNwYWNpbmcnLFxuICAgICdsaW5lLWNsYW1wJyxcbiAgICAnbGluZS1oZWlnaHQnLFxuICAgICdtYXJnaW4nLFxuICAgICdtYXJnaW4tYmxvY2stZW5kJyxcbiAgICAnbWFyZ2luLWJsb2NrLXN0YXJ0JyxcbiAgICAnbWFyZ2luLWJvdHRvbScsXG4gICAgJ21hcmdpbi1pbmxpbmUtZW5kJyxcbiAgICAnbWFyZ2luLWlubGluZS1zdGFydCcsXG4gICAgJ21hcmdpbi1sZWZ0JyxcbiAgICAnbWFyZ2luLXJpZ2h0JyxcbiAgICAnbWFyZ2luLXRvcCcsXG4gICAgJ21hc2snLFxuICAgICdtYXNrLWJvcmRlcicsXG4gICAgJ21hc2stcG9zaXRpb24nLFxuICAgICdtYXNrLXNpemUnLFxuICAgICdtYXgtYmxvY2stc2l6ZScsXG4gICAgJ21heC1oZWlnaHQnLFxuICAgICdtYXgtaW5saW5lLXNpemUnLFxuICAgICdtYXgtbGluZXMnLFxuICAgICdtYXgtd2lkdGgnLFxuICAgICdtaW4tYmxvY2stc2l6ZScsXG4gICAgJ21pbi1oZWlnaHQnLFxuICAgICdtaW4taW5saW5lLXNpemUnLFxuICAgICdtaW4td2lkdGgnLFxuICAgICdvYmplY3QtcG9zaXRpb24nLFxuICAgICdvZmZzZXQnLFxuICAgICdvZmZzZXQtYW5jaG9yJyxcbiAgICAnb2Zmc2V0LWRpc3RhbmNlJyxcbiAgICAnb2Zmc2V0LXBhdGgnLFxuICAgICdvZmZzZXQtcG9zaXRpb24nLFxuICAgICdvZmZzZXQtcm90YXRlJyxcbiAgICAnb3BhY2l0eScsXG4gICAgJ29yZGVyJyxcbiAgICAnb3V0bGluZScsXG4gICAgJ291dGxpbmUtY29sb3InLFxuICAgICdvdXRsaW5lLW9mZnNldCcsXG4gICAgJ291dGxpbmUtd2lkdGgnLFxuICAgICdwYWRkaW5nJyxcbiAgICAncGFkZGluZy1ibG9jay1lbmQnLFxuICAgICdwYWRkaW5nLWJsb2NrLXN0YXJ0JyxcbiAgICAncGFkZGluZy1ib3R0b20nLFxuICAgICdwYWRkaW5nLWlubGluZS1lbmQnLFxuICAgICdwYWRkaW5nLWlubGluZS1zdGFydCcsXG4gICAgJ3BhZGRpbmctbGVmdCcsXG4gICAgJ3BhZGRpbmctcmlnaHQnLFxuICAgICdwYWRkaW5nLXRvcCcsXG4gICAgJ3BlcnNwZWN0aXZlJyxcbiAgICAncGVyc3BlY3RpdmUtb3JpZ2luJyxcbiAgICAncmlnaHQnLFxuICAgICdyb3RhdGUnLFxuICAgICdyb3ctZ2FwJyxcbiAgICAnc2NhbGUnLFxuICAgICdzY3JvbGwtbWFyZ2luJyxcbiAgICAnc2Nyb2xsLW1hcmdpbi1ibG9jaycsXG4gICAgJ3Njcm9sbC1tYXJnaW4tYmxvY2stZW5kJyxcbiAgICAnc2Nyb2xsLW1hcmdpbi1ibG9jay1zdGFydCcsXG4gICAgJ3Njcm9sbC1tYXJnaW4tYm90dG9tJyxcbiAgICAnc2Nyb2xsLW1hcmdpbi1pbmxpbmUnLFxuICAgICdzY3JvbGwtbWFyZ2luLWlubGluZS1lbmQnLFxuICAgICdzY3JvbGwtbWFyZ2luLWlubGluZS1zdGFydCcsXG4gICAgJ3Njcm9sbC1tYXJnaW4tbGVmdCcsXG4gICAgJ3Njcm9sbC1tYXJnaW4tcmlnaHQnLFxuICAgICdzY3JvbGwtbWFyZ2luLXRvcCcsXG4gICAgJ3Njcm9sbC1wYWRkaW5nJyxcbiAgICAnc2Nyb2xsLXBhZGRpbmctYmxvY2snLFxuICAgICdzY3JvbGwtcGFkZGluZy1ibG9jay1lbmQnLFxuICAgICdzY3JvbGwtcGFkZGluZy1ibG9jay1zdGFydCcsXG4gICAgJ3Njcm9sbC1wYWRkaW5nLWJvdHRvbScsXG4gICAgJ3Njcm9sbC1wYWRkaW5nLWlubGluZScsXG4gICAgJ3Njcm9sbC1wYWRkaW5nLWlubGluZS1lbmQnLFxuICAgICdzY3JvbGwtcGFkZGluZy1pbmxpbmUtc3RhcnQnLFxuICAgICdzY3JvbGwtcGFkZGluZy1sZWZ0JyxcbiAgICAnc2Nyb2xsLXBhZGRpbmctcmlnaHQnLFxuICAgICdzY3JvbGwtcGFkZGluZy10b3AnLFxuICAgICdzY3JvbGwtc25hcC1jb29yZGluYXRlJyxcbiAgICAnc2Nyb2xsLXNuYXAtZGVzdGluYXRpb24nLFxuICAgICdzY3JvbGxiYXItY29sb3InLFxuICAgICdzaGFwZS1pbWFnZS10aHJlc2hvbGQnLFxuICAgICdzaGFwZS1tYXJnaW4nLFxuICAgICdzaGFwZS1vdXRzaWRlJyxcbiAgICAndGFiLXNpemUnLFxuICAgICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICd0ZXh0LWRlY29yYXRpb24tY29sb3InLFxuICAgICd0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzJyxcbiAgICAndGV4dC1lbXBoYXNpcycsXG4gICAgJ3RleHQtZW1waGFzaXMtY29sb3InLFxuICAgICd0ZXh0LWluZGVudCcsXG4gICAgJ3RleHQtc2hhZG93JyxcbiAgICAndGV4dC11bmRlcmxpbmUtb2Zmc2V0JyxcbiAgICAndG9wJyxcbiAgICAndHJhbnNmb3JtJyxcbiAgICAndHJhbnNmb3JtLW9yaWdpbicsXG4gICAgJ3RyYW5zbGF0ZScsXG4gICAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgICAndmlzaWJpbGl0eScsXG4gICAgJ3dpZHRoJyxcbiAgICAnd29yZC1zcGFjaW5nJyxcbiAgICAnei1pbmRleCcsXG4gICAgJ3pvb20nLFxuXSk7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICAvLyBDaGVja2luZyBvbmx5IGZvciBgcHJvY2Vzc2AgaXNuJ3QgZW5vdWdoIHRvIGlkZW50aWZ5IHdoZXRoZXIgb3Igbm90IHdlJ3JlIGluIGEgTm9kZVxuICAgIC8vIGVudmlyb25tZW50LCBiZWNhdXNlIFdlYnBhY2sgYnkgZGVmYXVsdCB3aWxsIHBvbHlmaWxsIHRoZSBgcHJvY2Vzc2AuIFdoaWxlIHdlIGNhbiBkaXNjZXJuXG4gICAgLy8gdGhhdCBXZWJwYWNrIHBvbHlmaWxsZWQgaXQgYnkgbG9va2luZyBhdCBgcHJvY2Vzcy5icm93c2VyYCwgaXQncyB2ZXJ5IFdlYnBhY2stc3BlY2lmaWMgYW5kXG4gICAgLy8gbWlnaHQgbm90IGJlIGZ1dHVyZS1wcm9vZi4gSW5zdGVhZCB3ZSBsb29rIGF0IHRoZSBzdHJpbmdpZmllZCB2ZXJzaW9uIG9mIGBwcm9jZXNzYCB3aGljaFxuICAgIC8vIGlzIGBbb2JqZWN0IHByb2Nlc3NdYCBpbiBOb2RlIGFuZCBgW29iamVjdCBPYmplY3RdYCB3aGVuIHBvbHlmaWxsZWQuXG4gICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB7fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXSc7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpIHtcbiAgICBzd2l0Y2ggKHBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9vcEFuaW1hdGlvblBsYXllcigpO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyc1swXTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgybVBbmltYXRpb25Hcm91cFBsYXllcihwbGF5ZXJzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVLZXlmcmFtZXMkMShkcml2ZXIsIG5vcm1hbGl6ZXIsIGVsZW1lbnQsIGtleWZyYW1lcywgcHJlU3R5bGVzID0gbmV3IE1hcCgpLCBwb3N0U3R5bGVzID0gbmV3IE1hcCgpKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3Qgbm9ybWFsaXplZEtleWZyYW1lcyA9IFtdO1xuICAgIGxldCBwcmV2aW91c09mZnNldCA9IC0xO1xuICAgIGxldCBwcmV2aW91c0tleWZyYW1lID0gbnVsbDtcbiAgICBrZXlmcmFtZXMuZm9yRWFjaChrZiA9PiB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGtmLmdldCgnb2Zmc2V0Jyk7XG4gICAgICAgIGNvbnN0IGlzU2FtZU9mZnNldCA9IG9mZnNldCA9PSBwcmV2aW91c09mZnNldDtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEtleWZyYW1lID0gKGlzU2FtZU9mZnNldCAmJiBwcmV2aW91c0tleWZyYW1lKSB8fCBuZXcgTWFwKCk7XG4gICAgICAgIGtmLmZvckVhY2goKHZhbCwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWRQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIGxldCBub3JtYWxpemVkVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZXIubm9ybWFsaXplUHJvcGVydHlOYW1lKG5vcm1hbGl6ZWRQcm9wLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobm9ybWFsaXplZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgybVQUkVfU1RZTEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPSBwcmVTdHlsZXMuZ2V0KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgQVVUT19TVFlMRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZSA9IHBvc3RTdHlsZXMuZ2V0KHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkVmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZXIubm9ybWFsaXplU3R5bGVWYWx1ZShwcm9wLCBub3JtYWxpemVkUHJvcCwgbm9ybWFsaXplZFZhbHVlLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9ybWFsaXplZEtleWZyYW1lLnNldChub3JtYWxpemVkUHJvcCwgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNTYW1lT2Zmc2V0KSB7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5ZnJhbWVzLnB1c2gobm9ybWFsaXplZEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0tleWZyYW1lID0gbm9ybWFsaXplZEtleWZyYW1lO1xuICAgICAgICBwcmV2aW91c09mZnNldCA9IG9mZnNldDtcbiAgICB9KTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBhbmltYXRpb25GYWlsZWQoZXJyb3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRLZXlmcmFtZXM7XG59XG5mdW5jdGlvbiBsaXN0ZW5PblBsYXllcihwbGF5ZXIsIGV2ZW50TmFtZSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoKCkgPT4gY2FsbGJhY2soZXZlbnQgJiYgY29weUFuaW1hdGlvbkV2ZW50KGV2ZW50LCAnc3RhcnQnLCBwbGF5ZXIpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IGNhbGxiYWNrKGV2ZW50ICYmIGNvcHlBbmltYXRpb25FdmVudChldmVudCwgJ2RvbmUnLCBwbGF5ZXIpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVzdHJveSc6XG4gICAgICAgICAgICBwbGF5ZXIub25EZXN0cm95KCgpID0+IGNhbGxiYWNrKGV2ZW50ICYmIGNvcHlBbmltYXRpb25FdmVudChldmVudCwgJ2Rlc3Ryb3knLCBwbGF5ZXIpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBjb3B5QW5pbWF0aW9uRXZlbnQoZSwgcGhhc2VOYW1lLCBwbGF5ZXIpIHtcbiAgICBjb25zdCB0b3RhbFRpbWUgPSBwbGF5ZXIudG90YWxUaW1lO1xuICAgIGNvbnN0IGRpc2FibGVkID0gcGxheWVyLmRpc2FibGVkID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNvbnN0IGV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGUuZWxlbWVudCwgZS50cmlnZ2VyTmFtZSwgZS5mcm9tU3RhdGUsIGUudG9TdGF0ZSwgcGhhc2VOYW1lIHx8IGUucGhhc2VOYW1lLCB0b3RhbFRpbWUgPT0gdW5kZWZpbmVkID8gZS50b3RhbFRpbWUgOiB0b3RhbFRpbWUsIGRpc2FibGVkKTtcbiAgICBjb25zdCBkYXRhID0gZVsnX2RhdGEnXTtcbiAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGV2ZW50WydfZGF0YSddID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUsIHBoYXNlTmFtZSA9ICcnLCB0b3RhbFRpbWUgPSAwLCBkaXNhYmxlZCkge1xuICAgIHJldHVybiB7IGVsZW1lbnQsIHRyaWdnZXJOYW1lLCBmcm9tU3RhdGUsIHRvU3RhdGUsIHBoYXNlTmFtZSwgdG90YWxUaW1lLCBkaXNhYmxlZDogISFkaXNhYmxlZCB9O1xufVxuZnVuY3Rpb24gZ2V0T3JTZXREZWZhdWx0VmFsdWUobWFwLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCB2YWx1ZSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGltZWxpbmVDb21tYW5kKGNvbW1hbmQpIHtcbiAgICBjb25zdCBzZXBhcmF0b3JQb3MgPSBjb21tYW5kLmluZGV4T2YoJzonKTtcbiAgICBjb25zdCBpZCA9IGNvbW1hbmQuc3Vic3RyaW5nKDEsIHNlcGFyYXRvclBvcyk7XG4gICAgY29uc3QgYWN0aW9uID0gY29tbWFuZC5zbGljZShzZXBhcmF0b3JQb3MgKyAxKTtcbiAgICByZXR1cm4gW2lkLCBhY3Rpb25dO1xufVxubGV0IF9jb250YWlucyA9IChlbG0xLCBlbG0yKSA9PiBmYWxzZTtcbmxldCBfcXVlcnkgPSAoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSA9PiB7XG4gICAgcmV0dXJuIFtdO1xufTtcbmxldCBfZG9jdW1lbnRFbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldFBhcmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7IC8vIGNvbnNpZGVyIGhvc3QgdG8gc3VwcG9ydCBzaGFkb3cgRE9NXG4gICAgaWYgKHBhcmVudCA9PT0gX2RvY3VtZW50RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudDtcbn1cbi8vIERlZmluZSB1dGlsaXR5IG1ldGhvZHMgZm9yIGJyb3dzZXJzIGFuZCBwbGF0Zm9ybS1zZXJ2ZXIoZG9taW5vKSB3aGVyZSBFbGVtZW50XG4vLyBhbmQgdXRpbGl0eSBtZXRob2RzIGV4aXN0LlxuY29uc3QgX2lzTm9kZSA9IGlzTm9kZSgpO1xuaWYgKF9pc05vZGUgfHwgdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICBfY29udGFpbnMgPSAoZWxtMSwgZWxtMikgPT4gZWxtMS5jb250YWlucyhlbG0yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlYWQgdGhlIGRvY3VtZW50IGVsZW1lbnQgaW4gYW4gSUlGRSB0aGF0J3MgYmVlbiBtYXJrZWQgcHVyZSB0byBhdm9pZCBhIHRvcC1sZXZlbCBwcm9wZXJ0eVxuICAgICAgICAvLyByZWFkIHRoYXQgbWF5IHByZXZlbnQgdHJlZS1zaGFraW5nLlxuICAgICAgICBfZG9jdW1lbnRFbGVtZW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKCk7XG4gICAgICAgIF9jb250YWlucyA9IChlbG0xLCBlbG0yKSA9PiB7XG4gICAgICAgICAgICB3aGlsZSAoZWxtMikge1xuICAgICAgICAgICAgICAgIGlmIChlbG0yID09PSBlbG0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbG0yID0gZ2V0UGFyZW50RWxlbWVudChlbG0yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3F1ZXJ5ID0gKGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkgPT4ge1xuICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbSA/IFtlbGVtXSA6IFtdO1xuICAgIH07XG59XG5mdW5jdGlvbiBjb250YWluc1ZlbmRvclByZWZpeChwcm9wKSB7XG4gICAgLy8gV2Via2l0IGlzIHRoZSBvbmx5IHJlYWwgcG9wdWxhciB2ZW5kb3IgcHJlZml4IG5vd2FkYXlzXG4gICAgLy8gY2M6IGh0dHA6Ly9zaG91bGRpcHJlZml4LmNvbS9cbiAgICByZXR1cm4gcHJvcC5zdWJzdHJpbmcoMSwgNikgPT0gJ2Via2l0JzsgLy8gd2Via2l0IG9yIFdlYmtpdFxufVxubGV0IF9DQUNIRURfQk9EWSA9IG51bGw7XG5sZXQgX0lTX1dFQktJVCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApIHtcbiAgICBpZiAoIV9DQUNIRURfQk9EWSkge1xuICAgICAgICBfQ0FDSEVEX0JPRFkgPSBnZXRCb2R5Tm9kZSgpIHx8IHt9O1xuICAgICAgICBfSVNfV0VCS0lUID0gX0NBQ0hFRF9CT0RZLnN0eWxlID8gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBfQ0FDSEVEX0JPRFkuc3R5bGUpIDogZmFsc2U7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGlmIChfQ0FDSEVEX0JPRFkuc3R5bGUgJiYgIWNvbnRhaW5zVmVuZG9yUHJlZml4KHByb3ApKSB7XG4gICAgICAgIHJlc3VsdCA9IHByb3AgaW4gX0NBQ0hFRF9CT0RZLnN0eWxlO1xuICAgICAgICBpZiAoIXJlc3VsdCAmJiBfSVNfV0VCS0lUKSB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbFByb3AgPSAnV2Via2l0JyArIHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FtZWxQcm9wIGluIF9DQUNIRURfQk9EWS5zdHlsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXZWJBbmltYXRhYmxlU3R5bGVQcm9wZXJ0eShwcm9wKSB7XG4gICAgcmV0dXJuIEFOSU1BVEFCTEVfUFJPUF9TRVQuaGFzKHByb3ApO1xufVxuZnVuY3Rpb24gZ2V0Qm9keU5vZGUoKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBjb250YWluc0VsZW1lbnQgPSBfY29udGFpbnM7XG5jb25zdCBpbnZva2VRdWVyeSA9IF9xdWVyeTtcbmZ1bmN0aW9uIGh5cGVuYXRlUHJvcHNLZXlzKG9yaWdpbmFsKSB7XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcCgpO1xuICAgIG9yaWdpbmFsLmZvckVhY2goKHZhbCwgcHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQcm9wID0gcHJvcC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKTtcbiAgICAgICAgbmV3TWFwLnNldChuZXdQcm9wLCB2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdNYXA7XG59XG5cbi8qKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOb29wQW5pbWF0aW9uRHJpdmVyIHtcbiAgICB2YWxpZGF0ZVN0eWxlUHJvcGVydHkocHJvcCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApO1xuICAgIH1cbiAgICBtYXRjaGVzRWxlbWVudChfZWxlbWVudCwgX3NlbGVjdG9yKSB7XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBpbiB1c2Ugc28gd2UgcmV0dXJuIGZhbHNlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnRhaW5zRWxlbWVudChlbG0xLCBlbG0yKSB7XG4gICAgICAgIHJldHVybiBjb250YWluc0VsZW1lbnQoZWxtMSwgZWxtMik7XG4gICAgfVxuICAgIGdldFBhcmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgcXVlcnkoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VRdWVyeShlbGVtZW50LCBzZWxlY3RvciwgbXVsdGkpO1xuICAgIH1cbiAgICBjb21wdXRlU3R5bGUoZWxlbWVudCwgcHJvcCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgfHwgJyc7XG4gICAgfVxuICAgIGFuaW1hdGUoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzID0gW10sIHNjcnViYmVyQWNjZXNzUmVxdWVzdGVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9vcEFuaW1hdGlvblBsYXllcihkdXJhdGlvbiwgZGVsYXkpO1xuICAgIH1cbn1cbk5vb3BBbmltYXRpb25Ecml2ZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9vcEFuaW1hdGlvbkRyaXZlciwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbk5vb3BBbmltYXRpb25Ecml2ZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vb3BBbmltYXRpb25Ecml2ZXIgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9vcEFuaW1hdGlvbkRyaXZlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgQW5pbWF0aW9uRHJpdmVyIHtcbn1cbkFuaW1hdGlvbkRyaXZlci5OT09QID0gKCAvKiBAX19QVVJFX18gKi9uZXcgTm9vcEFuaW1hdGlvbkRyaXZlcigpKTtcblxuY29uc3QgT05FX1NFQ09ORCA9IDEwMDA7XG5jb25zdCBTVUJTVElUVVRJT05fRVhQUl9TVEFSVCA9ICd7eyc7XG5jb25zdCBTVUJTVElUVVRJT05fRVhQUl9FTkQgPSAnfX0nO1xuY29uc3QgRU5URVJfQ0xBU1NOQU1FID0gJ25nLWVudGVyJztcbmNvbnN0IExFQVZFX0NMQVNTTkFNRSA9ICduZy1sZWF2ZSc7XG5jb25zdCBOR19UUklHR0VSX0NMQVNTTkFNRSA9ICduZy10cmlnZ2VyJztcbmNvbnN0IE5HX1RSSUdHRVJfU0VMRUNUT1IgPSAnLm5nLXRyaWdnZXInO1xuY29uc3QgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSA9ICduZy1hbmltYXRpbmcnO1xuY29uc3QgTkdfQU5JTUFUSU5HX1NFTEVDVE9SID0gJy5uZy1hbmltYXRpbmcnO1xuZnVuY3Rpb24gcmVzb2x2ZVRpbWluZ1ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvXigtP1tcXC5cXGRdKykobT9zKS8pO1xuICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmxlbmd0aCA8IDIpXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XG59XG5mdW5jdGlvbiBfY29udmVydFRpbWVWYWx1ZVRvTVModmFsdWUsIHVuaXQpIHtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKiBPTkVfU0VDT05EO1xuICAgICAgICBkZWZhdWx0OiAvLyBtcyBvciBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVUaW1pbmcodGltaW5ncywgZXJyb3JzLCBhbGxvd05lZ2F0aXZlVmFsdWVzKSB7XG4gICAgcmV0dXJuIHRpbWluZ3MuaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykgP1xuICAgICAgICB0aW1pbmdzIDpcbiAgICAgICAgcGFyc2VUaW1lRXhwcmVzc2lvbih0aW1pbmdzLCBlcnJvcnMsIGFsbG93TmVnYXRpdmVWYWx1ZXMpO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lRXhwcmVzc2lvbihleHAsIGVycm9ycywgYWxsb3dOZWdhdGl2ZVZhbHVlcykge1xuICAgIGNvbnN0IHJlZ2V4ID0gL14oLT9bXFwuXFxkXSspKG0/cykoPzpcXHMrKC0/W1xcLlxcZF0rKShtP3MpKT8oPzpcXHMrKFstYS16XSsoPzpcXCguKz9cXCkpPykpPyQvaTtcbiAgICBsZXQgZHVyYXRpb247XG4gICAgbGV0IGRlbGF5ID0gMDtcbiAgICBsZXQgZWFzaW5nID0gJyc7XG4gICAgaWYgKHR5cGVvZiBleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBleHAubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goaW52YWxpZFRpbWluZ1ZhbHVlKGV4cCkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZHVyYXRpb246IDAsIGRlbGF5OiAwLCBlYXNpbmc6ICcnIH07XG4gICAgICAgIH1cbiAgICAgICAgZHVyYXRpb24gPSBfY29udmVydFRpbWVWYWx1ZVRvTVMocGFyc2VGbG9hdChtYXRjaGVzWzFdKSwgbWF0Y2hlc1syXSk7XG4gICAgICAgIGNvbnN0IGRlbGF5TWF0Y2ggPSBtYXRjaGVzWzNdO1xuICAgICAgICBpZiAoZGVsYXlNYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWxheSA9IF9jb252ZXJ0VGltZVZhbHVlVG9NUyhwYXJzZUZsb2F0KGRlbGF5TWF0Y2gpLCBtYXRjaGVzWzRdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXNpbmdWYWwgPSBtYXRjaGVzWzVdO1xuICAgICAgICBpZiAoZWFzaW5nVmFsKSB7XG4gICAgICAgICAgICBlYXNpbmcgPSBlYXNpbmdWYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGR1cmF0aW9uID0gZXhwO1xuICAgIH1cbiAgICBpZiAoIWFsbG93TmVnYXRpdmVWYWx1ZXMpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5zRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gZXJyb3JzLmxlbmd0aDtcbiAgICAgICAgaWYgKGR1cmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmVnYXRpdmVTdGVwVmFsdWUoKSk7XG4gICAgICAgICAgICBjb250YWluc0Vycm9ycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbGF5IDwgMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmVnYXRpdmVEZWxheVZhbHVlKCkpO1xuICAgICAgICAgICAgY29udGFpbnNFcnJvcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluc0Vycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnNwbGljZShzdGFydEluZGV4LCAwLCBpbnZhbGlkVGltaW5nVmFsdWUoZXhwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcgfTtcbn1cbmZ1bmN0aW9uIGNvcHlPYmoob2JqLCBkZXN0aW5hdGlvbiA9IHt9KSB7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBkZXN0aW5hdGlvbltwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9NYXAob2JqKSB7XG4gICAgY29uc3Qgc3R5bGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICAgIHN0eWxlTWFwLnNldChwcm9wLCB2YWwpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdHlsZU1hcDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgICBpZiAoIWtleWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoa2V5ZnJhbWVzWzBdIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlmcmFtZXMubWFwKGtmID0+IGNvbnZlcnRUb01hcChrZikpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVzKHN0eWxlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdHlsZXMgPSBuZXcgTWFwKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaChkYXRhID0+IGNvcHlTdHlsZXMoZGF0YSwgbm9ybWFsaXplZFN0eWxlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29weVN0eWxlcyhzdHlsZXMsIG5vcm1hbGl6ZWRTdHlsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZFN0eWxlcztcbn1cbmZ1bmN0aW9uIGNvcHlTdHlsZXMoc3R5bGVzLCBkZXN0aW5hdGlvbiA9IG5ldyBNYXAoKSwgYmFja2ZpbGwpIHtcbiAgICBpZiAoYmFja2ZpbGwpIHtcbiAgICAgICAgZm9yIChsZXQgW3Byb3AsIHZhbF0gb2YgYmFja2ZpbGwpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLnNldChwcm9wLCB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IFtwcm9wLCB2YWxdIG9mIHN0eWxlcykge1xuICAgICAgICBkZXN0aW5hdGlvbi5zZXQocHJvcCwgdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGVBdHRyaWJ1dGVTdHJpbmcoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIC8vIFJldHVybiB0aGUga2V5LXZhbHVlIHBhaXIgc3RyaW5nIHRvIGJlIGFkZGVkIHRvIHRoZSBzdHlsZSBhdHRyaWJ1dGUgZm9yIHRoZVxuICAgIC8vIGdpdmVuIENTUyBzdHlsZSBrZXkuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZXkgKyAnOicgKyB2YWx1ZSArICc7JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5mdW5jdGlvbiB3cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpIHtcbiAgICAvLyBSZWFkIHRoZSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgZWxlbWVudCBhbmQgbWFudWFsbHkgcmVmbGVjdCBpdCB0byB0aGVcbiAgICAvLyBzdHlsZSBhdHRyaWJ1dGUuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgRG9taW5vIG9uIHBsYXRmb3JtLXNlcnZlciBkb2Vzbid0XG4gICAgLy8gdW5kZXJzdGFuZCB0aGUgZnVsbCBzZXQgb2YgYWxsb3dlZCBDU1MgcHJvcGVydGllcyBhbmQgZG9lc24ndCByZWZsZWN0IHNvbWVcbiAgICAvLyBvZiB0aGVtIGF1dG9tYXRpY2FsbHkuXG4gICAgbGV0IHN0eWxlQXR0clZhbHVlID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGVsZW1lbnQuc3R5bGUuaXRlbShpKTtcbiAgICAgICAgc3R5bGVBdHRyVmFsdWUgKz0gZ2V0U3R5bGVBdHRyaWJ1dGVTdHJpbmcoZWxlbWVudCwga2V5LCBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoa2V5KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgLy8gU2tpcCBpbnRlcm5hbCBEb21pbm8gcHJvcGVydGllcyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgcmVmbGVjdGVkLlxuICAgICAgICBpZiAoIWVsZW1lbnQuc3R5bGUuaGFzT3duUHJvcGVydHkoa2V5KSB8fCBrZXkuc3RhcnRzV2l0aCgnXycpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXNoS2V5ID0gY2FtZWxDYXNlVG9EYXNoQ2FzZShrZXkpO1xuICAgICAgICBzdHlsZUF0dHJWYWx1ZSArPSBnZXRTdHlsZUF0dHJpYnV0ZVN0cmluZyhlbGVtZW50LCBkYXNoS2V5LCBlbGVtZW50LnN0eWxlW2tleV0pO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBzdHlsZUF0dHJWYWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzLCBmb3JtZXJTdHlsZXMpIHtcbiAgICBpZiAoZWxlbWVudFsnc3R5bGUnXSkge1xuICAgICAgICBzdHlsZXMuZm9yRWFjaCgodmFsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW1lbFByb3AgPSBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3ApO1xuICAgICAgICAgICAgaWYgKGZvcm1lclN0eWxlcyAmJiAhZm9ybWVyU3R5bGVzLmhhcyhwcm9wKSkge1xuICAgICAgICAgICAgICAgIGZvcm1lclN0eWxlcy5zZXQocHJvcCwgZWxlbWVudC5zdHlsZVtjYW1lbFByb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbY2FtZWxQcm9wXSA9IHZhbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9uIHRoZSBzZXJ2ZXIgc2V0IHRoZSAnc3R5bGUnIGF0dHJpYnV0ZSBzaW5jZSBpdCdzIG5vdCBhdXRvbWF0aWNhbGx5IHJlZmxlY3RlZC5cbiAgICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgICAgICB3cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZXJhc2VTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gICAgaWYgKGVsZW1lbnRbJ3N0eWxlJ10pIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goKF8sIHByb3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVsUHJvcCA9IGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW2NhbWVsUHJvcF0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9uIHRoZSBzZXJ2ZXIgc2V0IHRoZSAnc3R5bGUnIGF0dHJpYnV0ZSBzaW5jZSBpdCdzIG5vdCBhdXRvbWF0aWNhbGx5IHJlZmxlY3RlZC5cbiAgICAgICAgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgICAgICB3cml0ZVN0eWxlQXR0cmlidXRlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplQW5pbWF0aW9uRW50cnkoc3RlcHMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGVwcykpIHtcbiAgICAgICAgaWYgKHN0ZXBzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHN0ZXBzWzBdO1xuICAgICAgICByZXR1cm4gc2VxdWVuY2Uoc3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RlcHM7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlUGFyYW1zKHZhbHVlLCBvcHRpb25zLCBlcnJvcnMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICBjb25zdCBtYXRjaGVzID0gZXh0cmFjdFN0eWxlUGFyYW1zKHZhbHVlKTtcbiAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKHZhck5hbWUgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuaGFzT3duUHJvcGVydHkodmFyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChpbnZhbGlkU3R5bGVQYXJhbXModmFyTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBQQVJBTV9SRUdFWCA9IG5ldyBSZWdFeHAoYCR7U1VCU1RJVFVUSU9OX0VYUFJfU1RBUlR9XFxcXHMqKC4rPylcXFxccyoke1NVQlNUSVRVVElPTl9FWFBSX0VORH1gLCAnZycpO1xuZnVuY3Rpb24gZXh0cmFjdFN0eWxlUGFyYW1zKHZhbHVlKSB7XG4gICAgbGV0IHBhcmFtcyA9IFtdO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgd2hpbGUgKG1hdGNoID0gUEFSQU1fUkVHRVguZXhlYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBQQVJBTV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVQYXJhbXModmFsdWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHN0ciA9IG9yaWdpbmFsLnJlcGxhY2UoUEFSQU1fUkVHRVgsIChfLCB2YXJOYW1lKSA9PiB7XG4gICAgICAgIGxldCBsb2NhbFZhbCA9IHBhcmFtc1t2YXJOYW1lXTtcbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSB2YWx1ZSB3YXMgbmV2ZXIgb3ZlcnJpZGRlbiBieSB0aGUgZGF0YSBwYXNzZWQgaW4gYnkgdGhlIHVzZXJcbiAgICAgICAgaWYgKGxvY2FsVmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGludmFsaWRQYXJhbVZhbHVlKHZhck5hbWUpKTtcbiAgICAgICAgICAgIGxvY2FsVmFsID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsVmFsLnRvU3RyaW5nKCk7XG4gICAgfSk7XG4gICAgLy8gd2UgZG8gdGhpcyB0byBhc3NlcnQgdGhhdCBudW1lcmljIHZhbHVlcyBzdGF5IGFzIHRoZXkgYXJlXG4gICAgcmV0dXJuIHN0ciA9PSBvcmlnaW5hbCA/IHZhbHVlIDogc3RyO1xufVxuZnVuY3Rpb24gaXRlcmF0b3JUb0FycmF5KGl0ZXJhdG9yKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgbGV0IGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgd2hpbGUgKCFpdGVtLmRvbmUpIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBEQVNIX0NBU0VfUkVHRVhQID0gLy0rKFthLXowLTldKS9nO1xuZnVuY3Rpb24gZGFzaENhc2VUb0NhbWVsQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKERBU0hfQ0FTRV9SRUdFWFAsICguLi5tKSA9PiBtWzFdLnRvVXBwZXJDYXNlKCkpO1xufVxuZnVuY3Rpb24gY2FtZWxDYXNlVG9EYXNoQ2FzZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gYWxsb3dQcmV2aW91c1BsYXllclN0eWxlc01lcmdlKGR1cmF0aW9uLCBkZWxheSkge1xuICAgIHJldHVybiBkdXJhdGlvbiA9PT0gMCB8fCBkZWxheSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VQcmV2aW91c1N0eWxlc0ludG9LZXlmcmFtZXMoZWxlbWVudCwga2V5ZnJhbWVzLCBwcmV2aW91c1N0eWxlcykge1xuICAgIGlmIChwcmV2aW91c1N0eWxlcy5zaXplICYmIGtleWZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHN0YXJ0aW5nS2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgICAgIGxldCBtaXNzaW5nU3R5bGVQcm9wcyA9IFtdO1xuICAgICAgICBwcmV2aW91c1N0eWxlcy5mb3JFYWNoKCh2YWwsIHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmICghc3RhcnRpbmdLZXlmcmFtZS5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nU3R5bGVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRpbmdLZXlmcmFtZS5zZXQocHJvcCwgdmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nU3R5bGVQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtmID0ga2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgIG1pc3NpbmdTdHlsZVByb3BzLmZvckVhY2gocHJvcCA9PiBrZi5zZXQocHJvcCwgY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3ApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleWZyYW1lcztcbn1cbmZ1bmN0aW9uIHZpc2l0RHNsTm9kZSh2aXNpdG9yLCBub2RlLCBjb250ZXh0KSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSA3IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5UcmlnZ2VyICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmlnZ2VyKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDAgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlN0YXRlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTdGF0ZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5UcmFuc2l0aW9uICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUcmFuc2l0aW9uKG5vZGUsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIDIgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlNlcXVlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRTZXF1ZW5jZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAzIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5Hcm91cCAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0R3JvdXAobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgNCAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuQW5pbWF0ZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QW5pbWF0ZShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA1IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5LZXlmcmFtZXMgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWZyYW1lcyhub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSA2IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5TdHlsZSAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3R5bGUobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgOCAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuUmVmZXJlbmNlICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2Uobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgOSAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuQW5pbWF0ZUNoaWxkICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBbmltYXRlQ2hpbGQobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTAgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLkFuaW1hdGVSZWYgKi86XG4gICAgICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEFuaW1hdGVSZWYobm9kZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgMTEgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlF1ZXJ5ICovOlxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRRdWVyeShub2RlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAxMiAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuU3RhZ2dlciAqLzpcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U3RhZ2dlcihub2RlLCBjb250ZXh0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IGludmFsaWROb2RlVHlwZShub2RlLnR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3Byb3BdO1xufVxuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8ICEhbmdEZXZNb2RlO1xuZnVuY3Rpb24gY3JlYXRlTGlzdE9mV2FybmluZ3Mod2FybmluZ3MpIHtcbiAgICBjb25zdCBMSU5FX1NUQVJUID0gJ1xcbiAtICc7XG4gICAgcmV0dXJuIGAke0xJTkVfU1RBUlR9JHt3YXJuaW5ncy5maWx0ZXIoQm9vbGVhbikubWFwKHdhcm5pbmcgPT4gd2FybmluZykuam9pbihMSU5FX1NUQVJUKX1gO1xufVxuZnVuY3Rpb24gd2FyblZhbGlkYXRpb24od2FybmluZ3MpIHtcbiAgICBOR19ERVZfTU9ERSAmJiBjb25zb2xlLndhcm4oYGFuaW1hdGlvbiB2YWxpZGF0aW9uIHdhcm5pbmdzOiR7Y3JlYXRlTGlzdE9mV2FybmluZ3Mod2FybmluZ3MpfWApO1xufVxuZnVuY3Rpb24gd2FyblRyaWdnZXJCdWlsZChuYW1lLCB3YXJuaW5ncykge1xuICAgIE5HX0RFVl9NT0RFICYmXG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlIGFuaW1hdGlvbiB0cmlnZ2VyIFwiJHtuYW1lfVwiIGhhcyBidWlsdCB3aXRoIHRoZSBmb2xsb3dpbmcgd2FybmluZ3M6JHtjcmVhdGVMaXN0T2ZXYXJuaW5ncyh3YXJuaW5ncyl9YCk7XG59XG5mdW5jdGlvbiB3YXJuUmVnaXN0ZXIod2FybmluZ3MpIHtcbiAgICBOR19ERVZfTU9ERSAmJlxuICAgICAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvbiBidWlsdCB3aXRoIHRoZSBmb2xsb3dpbmcgd2FybmluZ3M6JHtjcmVhdGVMaXN0T2ZXYXJuaW5ncyh3YXJuaW5ncyl9YCk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyUGFyc2luZ1dhcm5pbmdzKG5hbWUsIHdhcm5pbmdzKSB7XG4gICAgTkdfREVWX01PREUgJiZcbiAgICAgICAgY29uc29sZS53YXJuKGBBbmltYXRpb24gcGFyc2luZyBmb3IgdGhlICR7bmFtZX0gdHJpZ2dlciBwcmVzZW50cyB0aGUgZm9sbG93aW5nIHdhcm5pbmdzOiR7Y3JlYXRlTGlzdE9mV2FybmluZ3Mod2FybmluZ3MpfWApO1xufVxuZnVuY3Rpb24gcHVzaFVucmVjb2duaXplZFByb3BlcnRpZXNXYXJuaW5nKHdhcm5pbmdzLCBwcm9wcykge1xuICAgIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChgVGhlIGZvbGxvd2luZyBwcm92aWRlZCBwcm9wZXJ0aWVzIGFyZSBub3QgcmVjb2duaXplZDogJHtwcm9wcy5qb2luKCcsICcpfWApO1xuICAgIH1cbn1cblxuY29uc3QgQU5ZX1NUQVRFID0gJyonO1xuZnVuY3Rpb24gcGFyc2VUcmFuc2l0aW9uRXhwcih0cmFuc2l0aW9uVmFsdWUsIGVycm9ycykge1xuICAgIGNvbnN0IGV4cHJlc3Npb25zID0gW107XG4gICAgaWYgKHR5cGVvZiB0cmFuc2l0aW9uVmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNpdGlvblZhbHVlLnNwbGl0KC9cXHMqLFxccyovKS5mb3JFYWNoKHN0ciA9PiBwYXJzZUlubmVyVHJhbnNpdGlvblN0cihzdHIsIGV4cHJlc3Npb25zLCBlcnJvcnMpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2godHJhbnNpdGlvblZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zO1xufVxuZnVuY3Rpb24gcGFyc2VJbm5lclRyYW5zaXRpb25TdHIoZXZlbnRTdHIsIGV4cHJlc3Npb25zLCBlcnJvcnMpIHtcbiAgICBpZiAoZXZlbnRTdHJbMF0gPT0gJzonKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlQW5pbWF0aW9uQWxpYXMoZXZlbnRTdHIsIGVycm9ycyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudFN0ciA9IHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBldmVudFN0ci5tYXRjaCgvXihcXCp8Wy1cXHddKylcXHMqKDw/Wz0tXT4pXFxzKihcXCp8Wy1cXHddKykkLyk7XG4gICAgaWYgKG1hdGNoID09IG51bGwgfHwgbWF0Y2gubGVuZ3RoIDwgNCkge1xuICAgICAgICBlcnJvcnMucHVzaChpbnZhbGlkRXhwcmVzc2lvbihldmVudFN0cikpO1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IG1hdGNoWzFdO1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IG1hdGNoWzJdO1xuICAgIGNvbnN0IHRvU3RhdGUgPSBtYXRjaFszXTtcbiAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKGZyb21TdGF0ZSwgdG9TdGF0ZSkpO1xuICAgIGNvbnN0IGlzRnVsbEFueVN0YXRlRXhwciA9IGZyb21TdGF0ZSA9PSBBTllfU1RBVEUgJiYgdG9TdGF0ZSA9PSBBTllfU1RBVEU7XG4gICAgaWYgKHNlcGFyYXRvclswXSA9PSAnPCcgJiYgIWlzRnVsbEFueVN0YXRlRXhwcikge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKG1ha2VMYW1iZGFGcm9tU3RhdGVzKHRvU3RhdGUsIGZyb21TdGF0ZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9uQWxpYXMoYWxpYXMsIGVycm9ycykge1xuICAgIHN3aXRjaCAoYWxpYXMpIHtcbiAgICAgICAgY2FzZSAnOmVudGVyJzpcbiAgICAgICAgICAgIHJldHVybiAndm9pZCA9PiAqJztcbiAgICAgICAgY2FzZSAnOmxlYXZlJzpcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiB2b2lkJztcbiAgICAgICAgY2FzZSAnOmluY3JlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gKGZyb21TdGF0ZSwgdG9TdGF0ZSkgPT4gcGFyc2VGbG9hdCh0b1N0YXRlKSA+IHBhcnNlRmxvYXQoZnJvbVN0YXRlKTtcbiAgICAgICAgY2FzZSAnOmRlY3JlbWVudCc6XG4gICAgICAgICAgICByZXR1cm4gKGZyb21TdGF0ZSwgdG9TdGF0ZSkgPT4gcGFyc2VGbG9hdCh0b1N0YXRlKSA8IHBhcnNlRmxvYXQoZnJvbVN0YXRlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGludmFsaWRUcmFuc2l0aW9uQWxpYXMoYWxpYXMpKTtcbiAgICAgICAgICAgIHJldHVybiAnKiA9PiAqJztcbiAgICB9XG59XG4vLyBETyBOT1QgUkVGQUNUT1IgLi4uIGtlZXAgdGhlIGZvbGxvdyBzZXQgaW5zdGFudGlhdGlvbnNcbi8vIHdpdGggdGhlIHZhbHVlcyBpbnRhY3QgKGNsb3N1cmUgY29tcGlsZXIgZm9yIHNvbWUgcmVhc29uXG4vLyByZW1vdmVzIGZvbGxvdy11cCBsaW5lcyB0aGF0IGFkZCB0aGUgdmFsdWVzIG91dHNpZGUgb2Zcbi8vIHRoZSBjb25zdHJ1Y3Rvci4uLlxuY29uc3QgVFJVRV9CT09MRUFOX1ZBTFVFUyA9IG5ldyBTZXQoWyd0cnVlJywgJzEnXSk7XG5jb25zdCBGQUxTRV9CT09MRUFOX1ZBTFVFUyA9IG5ldyBTZXQoWydmYWxzZScsICcwJ10pO1xuZnVuY3Rpb24gbWFrZUxhbWJkYUZyb21TdGF0ZXMobGhzLCByaHMpIHtcbiAgICBjb25zdCBMSFNfTUFUQ0hfQk9PTEVBTiA9IFRSVUVfQk9PTEVBTl9WQUxVRVMuaGFzKGxocykgfHwgRkFMU0VfQk9PTEVBTl9WQUxVRVMuaGFzKGxocyk7XG4gICAgY29uc3QgUkhTX01BVENIX0JPT0xFQU4gPSBUUlVFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpIHx8IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpO1xuICAgIHJldHVybiAoZnJvbVN0YXRlLCB0b1N0YXRlKSA9PiB7XG4gICAgICAgIGxldCBsaHNNYXRjaCA9IGxocyA9PSBBTllfU1RBVEUgfHwgbGhzID09IGZyb21TdGF0ZTtcbiAgICAgICAgbGV0IHJoc01hdGNoID0gcmhzID09IEFOWV9TVEFURSB8fCByaHMgPT0gdG9TdGF0ZTtcbiAgICAgICAgaWYgKCFsaHNNYXRjaCAmJiBMSFNfTUFUQ0hfQk9PTEVBTiAmJiB0eXBlb2YgZnJvbVN0YXRlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGxoc01hdGNoID0gZnJvbVN0YXRlID8gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMobGhzKSA6IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhsaHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmhzTWF0Y2ggJiYgUkhTX01BVENIX0JPT0xFQU4gJiYgdHlwZW9mIHRvU3RhdGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgcmhzTWF0Y2ggPSB0b1N0YXRlID8gVFJVRV9CT09MRUFOX1ZBTFVFUy5oYXMocmhzKSA6IEZBTFNFX0JPT0xFQU5fVkFMVUVTLmhhcyhyaHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaHNNYXRjaCAmJiByaHNNYXRjaDtcbiAgICB9O1xufVxuXG5jb25zdCBTRUxGX1RPS0VOID0gJzpzZWxmJztcbmNvbnN0IFNFTEZfVE9LRU5fUkVHRVggPSBuZXcgUmVnRXhwKGBcXHMqJHtTRUxGX1RPS0VOfVxccyosP2AsICdnJyk7XG4vKlxuICogW1ZhbGlkYXRpb25dXG4gKiBUaGUgdmlzaXRvciBjb2RlIGJlbG93IHdpbGwgdHJhdmVyc2UgdGhlIGFuaW1hdGlvbiBBU1QgZ2VuZXJhdGVkIGJ5IHRoZSBhbmltYXRpb24gdmVyYiBmdW5jdGlvbnNcbiAqICh0aGUgb3V0cHV0IGlzIGEgdHJlZSBvZiBvYmplY3RzKSBhbmQgYXR0ZW1wdCB0byBwZXJmb3JtIGEgc2VyaWVzIG9mIHZhbGlkYXRpb25zIG9uIHRoZSBkYXRhLiBUaGVcbiAqIGZvbGxvd2luZyBjb3JuZXItY2FzZXMgd2lsbCBiZSB2YWxpZGF0ZWQ6XG4gKlxuICogMS4gT3ZlcmxhcCBvZiBhbmltYXRpb25zXG4gKiBHaXZlbiB0aGF0IGEgQ1NTIHByb3BlcnR5IGNhbm5vdCBiZSBhbmltYXRlZCBpbiBtb3JlIHRoYW4gb25lIHBsYWNlIGF0IHRoZSBzYW1lIHRpbWUsIGl0J3NcbiAqIGltcG9ydGFudCB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgZGV0ZWN0ZWQgYW5kIHZhbGlkYXRlZC4gVGhlIHdheSBpbiB3aGljaCB0aGlzIG9jY3VycyBpcyB0aGF0XG4gKiBlYWNoIHRpbWUgYSBzdHlsZSBwcm9wZXJ0eSBpcyBleGFtaW5lZCwgYSBzdHJpbmctbWFwIGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5IHdpbGwgYmUgdXBkYXRlZCB3aXRoXG4gKiB0aGUgc3RhcnQgYW5kIGVuZCB0aW1lcyBmb3Igd2hlbiB0aGUgcHJvcGVydHkgaXMgdXNlZCB3aXRoaW4gYW4gYW5pbWF0aW9uIHN0ZXAuXG4gKlxuICogSWYgdGhlcmUgYXJlIHR3byBvciBtb3JlIHBhcmFsbGVsIGFuaW1hdGlvbnMgdGhhdCBhcmUgY3VycmVudGx5IHJ1bm5pbmcgKHRoZXNlIGFyZSBpbnZva2VkIGJ5IHRoZVxuICogZ3JvdXAoKSkgb24gdGhlIHNhbWUgZWxlbWVudCB0aGVuIHRoZSB2YWxpZGF0b3Igd2lsbCB0aHJvdyBhbiBlcnJvci4gU2luY2UgdGhlIHN0YXJ0L2VuZCB0aW1pbmdcbiAqIHZhbHVlcyBhcmUgY29sbGVjdGVkIGZvciBlYWNoIHByb3BlcnR5IHRoZW4gaWYgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHN0ZXAgaXMgYW5pbWF0aW5nIHRoZSBzYW1lXG4gKiBwcm9wZXJ0eSBhbmQgaXRzIHRpbWluZyB2YWx1ZXMgZmFsbCBhbnl3aGVyZSBpbnRvIHRoZSB3aW5kb3cgb2YgdGltZSB0aGF0IHRoZSBwcm9wZXJ0eSBpc1xuICogY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkIHdpdGhpbiB0aGVuIHRoaXMgaXMgd2hhdCBjYXVzZXMgYW4gZXJyb3IuXG4gKlxuICogMi4gVGltaW5nIHZhbHVlc1xuICogVGhlIHZhbGlkYXRvciB3aWxsIHZhbGlkYXRlIHRvIHNlZSBpZiBhIHRpbWluZyB2YWx1ZSBvZiBgZHVyYXRpb24gZGVsYXkgZWFzaW5nYCBvclxuICogYGR1cmF0aW9uTnVtYmVyYCBpcyB2YWxpZCBvciBub3QuXG4gKlxuICogKG5vdGUgdGhhdCB1cG9uIHZhbGlkYXRpb24gdGhlIGNvZGUgYmVsb3cgd2lsbCByZXBsYWNlIHRoZSB0aW1pbmcgZGF0YSB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiB7ZHVyYXRpb24sZGVsYXksZWFzaW5nfS5cbiAqXG4gKiAzLiBPZmZzZXQgVmFsaWRhdGlvblxuICogRWFjaCBvZiB0aGUgc3R5bGUoKSBjYWxscyBhcmUgYWxsb3dlZCB0byBoYXZlIGFuIG9mZnNldCB2YWx1ZSB3aGVuIHBsYWNlZCBpbnNpZGUgb2Yga2V5ZnJhbWVzKCkuXG4gKiBPZmZzZXRzIHdpdGhpbiBrZXlmcmFtZXMoKSBhcmUgY29uc2lkZXJlZCB2YWxpZCB3aGVuOlxuICpcbiAqICAgLSBObyBvZmZzZXRzIGFyZSB1c2VkIGF0IGFsbFxuICogICAtIEVhY2ggc3R5bGUoKSBlbnRyeSBjb250YWlucyBhbiBvZmZzZXQgdmFsdWVcbiAqICAgLSBFYWNoIG9mZnNldCBpcyBiZXR3ZWVuIDAgYW5kIDFcbiAqICAgLSBFYWNoIG9mZnNldCBpcyBncmVhdGVyIHRvIG9yIGVxdWFsIHRoYW4gdGhlIHByZXZpb3VzIG9uZVxuICpcbiAqIE90aGVyd2lzZSBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gYnVpbGRBbmltYXRpb25Bc3QoZHJpdmVyLCBtZXRhZGF0YSwgZXJyb3JzLCB3YXJuaW5ncykge1xuICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQXN0QnVpbGRlclZpc2l0b3IoZHJpdmVyKS5idWlsZChtZXRhZGF0YSwgZXJyb3JzLCB3YXJuaW5ncyk7XG59XG5jb25zdCBST09UX1NFTEVDVE9SID0gJyc7XG5jbGFzcyBBbmltYXRpb25Bc3RCdWlsZGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2RyaXZlcikge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgIH1cbiAgICBidWlsZChtZXRhZGF0YSwgZXJyb3JzLCB3YXJuaW5ncykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEFuaW1hdGlvbkFzdEJ1aWxkZXJDb250ZXh0KGVycm9ycyk7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q29udGV4dFN0eWxlVGltaW5nU3RhdGUoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGFzdCA9IHZpc2l0RHNsTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YSksIGNvbnRleHQpO1xuICAgICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgICAgICBpZiAoY29udGV4dC51bnN1cHBvcnRlZENTU1Byb3BlcnRpZXNGb3VuZC5zaXplKSB7XG4gICAgICAgICAgICAgICAgcHVzaFVucmVjb2duaXplZFByb3BlcnRpZXNXYXJuaW5nKHdhcm5pbmdzLCBbLi4uY29udGV4dC51bnN1cHBvcnRlZENTU1Byb3BlcnRpZXNGb3VuZC5rZXlzKCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICBfcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPSBST09UX1NFTEVDVE9SO1xuICAgICAgICBjb250ZXh0LmNvbGxlY3RlZFN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29udGV4dC5jb2xsZWN0ZWRTdHlsZXMuc2V0KFJPT1RfU0VMRUNUT1IsIG5ldyBNYXAoKSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cbiAgICB2aXNpdFRyaWdnZXIobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHF1ZXJ5Q291bnQgPSBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICBsZXQgZGVwQ291bnQgPSBjb250ZXh0LmRlcENvdW50ID0gMDtcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gW107XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25zID0gW107XG4gICAgICAgIGlmIChtZXRhZGF0YS5uYW1lLmNoYXJBdCgwKSA9PSAnQCcpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goaW52YWxpZFRyaWdnZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0YWRhdGEuZGVmaW5pdGlvbnMuZm9yRWFjaChkZWYgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRDb250ZXh0U3R5bGVUaW1pbmdTdGF0ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChkZWYudHlwZSA9PSAwIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5TdGF0ZSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlRGVmID0gZGVmO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzdGF0ZURlZi5uYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUudG9TdHJpbmcoKS5zcGxpdCgvXFxzKixcXHMqLykuZm9yRWFjaChuID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVEZWYubmFtZSA9IG47XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcy5wdXNoKHRoaXMudmlzaXRTdGF0ZShzdGF0ZURlZiwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXRlRGVmLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGVmLnR5cGUgPT0gMSAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuVHJhbnNpdGlvbiAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0aGlzLnZpc2l0VHJhbnNpdGlvbihkZWYsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5Q291bnQgKz0gdHJhbnNpdGlvbi5xdWVyeUNvdW50O1xuICAgICAgICAgICAgICAgIGRlcENvdW50ICs9IHRyYW5zaXRpb24uZGVwQ291bnQ7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goaW52YWxpZERlZmluaXRpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogNyAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuVHJpZ2dlciAqLyxcbiAgICAgICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgICBzdGF0ZXMsXG4gICAgICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgICAgIHF1ZXJ5Q291bnQsXG4gICAgICAgICAgICBkZXBDb3VudCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZShtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBzdHlsZUFzdCA9IHRoaXMudmlzaXRTdHlsZShtZXRhZGF0YS5zdHlsZXMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBhc3RQYXJhbXMgPSAobWV0YWRhdGEub3B0aW9ucyAmJiBtZXRhZGF0YS5vcHRpb25zLnBhcmFtcykgfHwgbnVsbDtcbiAgICAgICAgaWYgKHN0eWxlQXN0LmNvbnRhaW5zRHluYW1pY1N0eWxlcykge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1N1YnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBhc3RQYXJhbXMgfHwge307XG4gICAgICAgICAgICBzdHlsZUFzdC5zdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFN0eWxlUGFyYW1zKHZhbHVlKS5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMuaGFzT3duUHJvcGVydHkoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nU3Vicy5hZGQoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWlzc2luZ1N1YnMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdTdWJzQXJyID0gaXRlcmF0b3JUb0FycmF5KG1pc3NpbmdTdWJzLnZhbHVlcygpKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGludmFsaWRTdGF0ZShtZXRhZGF0YS5uYW1lLCBtaXNzaW5nU3Vic0FycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAwIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5TdGF0ZSAqLyxcbiAgICAgICAgICAgIG5hbWU6IG1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgICBzdHlsZTogc3R5bGVBc3QsXG4gICAgICAgICAgICBvcHRpb25zOiBhc3RQYXJhbXMgPyB7IHBhcmFtczogYXN0UGFyYW1zIH0gOiBudWxsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VHJhbnNpdGlvbihtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICBjb250ZXh0LmRlcENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gdmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBtYXRjaGVycyA9IHBhcnNlVHJhbnNpdGlvbkV4cHIobWV0YWRhdGEuZXhwciwgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMSAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuVHJhbnNpdGlvbiAqLyxcbiAgICAgICAgICAgIG1hdGNoZXJzLFxuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgcXVlcnlDb3VudDogY29udGV4dC5xdWVyeUNvdW50LFxuICAgICAgICAgICAgZGVwQ291bnQ6IGNvbnRleHQuZGVwQ291bnQsXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0U2VxdWVuY2UobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDIgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlNlcXVlbmNlICovLFxuICAgICAgICAgICAgc3RlcHM6IG1ldGFkYXRhLnN0ZXBzLm1hcChzID0+IHZpc2l0RHNsTm9kZSh0aGlzLCBzLCBjb250ZXh0KSksXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0R3JvdXAobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICBsZXQgZnVydGhlc3RUaW1lID0gMDtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoc3RlcCA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgICAgICBjb25zdCBpbm5lckFzdCA9IHZpc2l0RHNsTm9kZSh0aGlzLCBzdGVwLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9IE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgY29udGV4dC5jdXJyZW50VGltZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5uZXJBc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lID0gZnVydGhlc3RUaW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMyAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuR3JvdXAgKi8sXG4gICAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRBbmltYXRlKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRpbWluZ0FzdCA9IGNvbnN0cnVjdFRpbWluZ0FzdChtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycyk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gdGltaW5nQXN0O1xuICAgICAgICBsZXQgc3R5bGVBc3Q7XG4gICAgICAgIGxldCBzdHlsZU1ldGFkYXRhID0gbWV0YWRhdGEuc3R5bGVzID8gbWV0YWRhdGEuc3R5bGVzIDogc3R5bGUoe30pO1xuICAgICAgICBpZiAoc3R5bGVNZXRhZGF0YS50eXBlID09IDUgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLktleWZyYW1lcyAqLykge1xuICAgICAgICAgICAgc3R5bGVBc3QgPSB0aGlzLnZpc2l0S2V5ZnJhbWVzKHN0eWxlTWV0YWRhdGEsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHN0eWxlTWV0YWRhdGEgPSBtZXRhZGF0YS5zdHlsZXM7XG4gICAgICAgICAgICBsZXQgaXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzdHlsZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgaXNFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3R5bGVEYXRhID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRpbWluZ0FzdC5lYXNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3R5bGVEYXRhWydlYXNpbmcnXSA9IHRpbWluZ0FzdC5lYXNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlTWV0YWRhdGEgPSBzdHlsZShuZXdTdHlsZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50VGltZSArPSB0aW1pbmdBc3QuZHVyYXRpb24gKyB0aW1pbmdBc3QuZGVsYXk7XG4gICAgICAgICAgICBjb25zdCBfc3R5bGVBc3QgPSB0aGlzLnZpc2l0U3R5bGUoc3R5bGVNZXRhZGF0YSwgY29udGV4dCk7XG4gICAgICAgICAgICBfc3R5bGVBc3QuaXNFbXB0eVN0ZXAgPSBpc0VtcHR5O1xuICAgICAgICAgICAgc3R5bGVBc3QgPSBfc3R5bGVBc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogNCAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuQW5pbWF0ZSAqLyxcbiAgICAgICAgICAgIHRpbWluZ3M6IHRpbWluZ0FzdCxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZUFzdCxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRTdHlsZShtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9tYWtlU3R5bGVBc3QobWV0YWRhdGEsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVN0eWxlQXN0KGFzdCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIF9tYWtlU3R5bGVBc3QobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhU3R5bGVzID0gQXJyYXkuaXNBcnJheShtZXRhZGF0YS5zdHlsZXMpID8gbWV0YWRhdGEuc3R5bGVzIDogW21ldGFkYXRhLnN0eWxlc107XG4gICAgICAgIGZvciAobGV0IHN0eWxlVHVwbGUgb2YgbWV0YWRhdGFTdHlsZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3R5bGVUdXBsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVUdXBsZSA9PT0gQVVUT19TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZVR1cGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goaW52YWxpZFN0eWxlVmFsdWUoc3R5bGVUdXBsZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKGNvbnZlcnRUb01hcChzdHlsZVR1cGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5zRHluYW1pY1N0eWxlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgY29sbGVjdGVkRWFzaW5nID0gbnVsbDtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goc3R5bGVEYXRhID0+IHtcbiAgICAgICAgICAgIGlmIChzdHlsZURhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVEYXRhLmhhcygnZWFzaW5nJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkRWFzaW5nID0gc3R5bGVEYXRhLmdldCgnZWFzaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRGF0YS5kZWxldGUoJ2Vhc2luZycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5zRHluYW1pY1N0eWxlcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBzdHlsZURhdGEudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpLmluZGV4T2YoU1VCU1RJVFVUSU9OX0VYUFJfU1RBUlQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc0R5bmFtaWNTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDYgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlN0eWxlICovLFxuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgZWFzaW5nOiBjb2xsZWN0ZWRFYXNpbmcsXG4gICAgICAgICAgICBvZmZzZXQ6IG1ldGFkYXRhLm9mZnNldCxcbiAgICAgICAgICAgIGNvbnRhaW5zRHluYW1pY1N0eWxlcyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3ZhbGlkYXRlU3R5bGVBc3QoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgbGV0IGVuZFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICBsZXQgc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZTtcbiAgICAgICAgaWYgKHRpbWluZ3MgJiYgc3RhcnRUaW1lID4gMCkge1xuICAgICAgICAgICAgc3RhcnRUaW1lIC09IHRpbWluZ3MuZHVyYXRpb24gKyB0aW1pbmdzLmRlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGFzdC5zdHlsZXMuZm9yRWFjaCh0dXBsZSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHR1cGxlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0dXBsZS5mb3JFYWNoKCh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kcml2ZXIudmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dXBsZS5kZWxldGUocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnVuc3VwcG9ydGVkQ1NTUHJvcGVydGllc0ZvdW5kLmFkZChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhIGRlZmluZWQgTWFwIGF0IHRoaXMgcXVlcnlTZWxlY3RvciBsb2NhdGlvbiBtYWtpbmcgaXRcbiAgICAgICAgICAgICAgICAvLyBzYWZlIHRvIGFkZCB0aGUgYXNzZXJ0aW9uIGhlcmUuIEl0IGlzIHNldCBhcyBhIGRlZmF1bHQgZW1wdHkgbWFwIGluIHByaW9yIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGVkU3R5bGVzID0gY29udGV4dC5jb2xsZWN0ZWRTdHlsZXMuZ2V0KGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RlZEVudHJ5ID0gY29sbGVjdGVkU3R5bGVzLmdldChwcm9wKTtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlQ29sbGVjdGVkU3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0ZWRFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUgJiYgc3RhcnRUaW1lID49IGNvbGxlY3RlZEVudHJ5LnN0YXJ0VGltZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGltZSA8PSBjb2xsZWN0ZWRFbnRyeS5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGludmFsaWRQYXJhbGxlbEFuaW1hdGlvbihwcm9wLCBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWUsIGNvbGxlY3RlZEVudHJ5LmVuZFRpbWUsIHN0YXJ0VGltZSwgZW5kVGltZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ29sbGVjdGVkU3R5bGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhbHdheXMgY2hvb3NlIHRoZSBzbWFsbGVyIHN0YXJ0IHRpbWUgdmFsdWUgc2luY2Ugd2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FudCB0byBoYXZlIGEgcmVjb3JkIG9mIHRoZSBlbnRpcmUgYW5pbWF0aW9uIHdpbmRvdyB3aGVyZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3R5bGUgcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgaW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICBzdGFydFRpbWUgPSBjb2xsZWN0ZWRFbnRyeS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVDb2xsZWN0ZWRTdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRTdHlsZXMuc2V0KHByb3AsIHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlU3R5bGVQYXJhbXModmFsdWUsIGNvbnRleHQub3B0aW9ucywgY29udGV4dC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRLZXlmcmFtZXMobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYXN0ID0geyB0eXBlOiA1IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5LZXlmcmFtZXMgKi8sIHN0eWxlczogW10sIG9wdGlvbnM6IG51bGwgfTtcbiAgICAgICAgaWYgKCFjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncykge1xuICAgICAgICAgICAgY29udGV4dC5lcnJvcnMucHVzaChpbnZhbGlkS2V5ZnJhbWVzKCkpO1xuICAgICAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBNQVhfS0VZRlJBTUVfT0ZGU0VUID0gMTtcbiAgICAgICAgbGV0IHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPSAwO1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gW107XG4gICAgICAgIGxldCBvZmZzZXRzT3V0T2ZPcmRlciA9IGZhbHNlO1xuICAgICAgICBsZXQga2V5ZnJhbWVzT3V0T2ZSYW5nZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcHJldmlvdXNPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBrZXlmcmFtZXMgPSBtZXRhZGF0YS5zdGVwcy5tYXAoc3R5bGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5fbWFrZVN0eWxlQXN0KHN0eWxlcywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0VmFsID0gc3R5bGUub2Zmc2V0ICE9IG51bGwgPyBzdHlsZS5vZmZzZXQgOiBjb25zdW1lT2Zmc2V0KHN0eWxlLnN0eWxlcyk7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGlmIChvZmZzZXRWYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMrKztcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBzdHlsZS5vZmZzZXQgPSBvZmZzZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlmcmFtZXNPdXRPZlJhbmdlID0ga2V5ZnJhbWVzT3V0T2ZSYW5nZSB8fCBvZmZzZXQgPCAwIHx8IG9mZnNldCA+IDE7XG4gICAgICAgICAgICBvZmZzZXRzT3V0T2ZPcmRlciA9IG9mZnNldHNPdXRPZk9yZGVyIHx8IG9mZnNldCA8IHByZXZpb3VzT2Zmc2V0O1xuICAgICAgICAgICAgcHJldmlvdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChrZXlmcmFtZXNPdXRPZlJhbmdlKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGludmFsaWRPZmZzZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldHNPdXRPZk9yZGVyKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGtleWZyYW1lT2Zmc2V0c091dE9mT3JkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbWV0YWRhdGEuc3RlcHMubGVuZ3RoO1xuICAgICAgICBsZXQgZ2VuZXJhdGVkT2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPiAwICYmIHRvdGFsS2V5ZnJhbWVzV2l0aE9mZnNldHMgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXJyb3JzLnB1c2goa2V5ZnJhbWVzTWlzc2luZ09mZnNldHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG90YWxLZXlmcmFtZXNXaXRoT2Zmc2V0cyA9PSAwKSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWRPZmZzZXQgPSBNQVhfS0VZRlJBTUVfT0ZGU0VUIC8gKGxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgICAgICBjb25zdCBjdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgY29uc3QgYW5pbWF0ZUR1cmF0aW9uID0gY3VycmVudEFuaW1hdGVUaW1pbmdzLmR1cmF0aW9uO1xuICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaCgoa2YsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGdlbmVyYXRlZE9mZnNldCA+IDAgPyAoaSA9PSBsaW1pdCA/IDEgOiAoZ2VuZXJhdGVkT2Zmc2V0ICogaSkpIDogb2Zmc2V0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uVXBUb1RoaXNGcmFtZSA9IG9mZnNldCAqIGFuaW1hdGVEdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWUgPSBjdXJyZW50VGltZSArIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kZWxheSArIGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIGN1cnJlbnRBbmltYXRlVGltaW5ncy5kdXJhdGlvbiA9IGR1cmF0aW9uVXBUb1RoaXNGcmFtZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlU3R5bGVBc3Qoa2YsIGNvbnRleHQpO1xuICAgICAgICAgICAga2Yub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgYXN0LnN0eWxlcy5wdXNoKGtmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UmVmZXJlbmNlKG1ldGFkYXRhLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiA4IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5SZWZlcmVuY2UgKi8sXG4gICAgICAgICAgICBhbmltYXRpb246IHZpc2l0RHNsTm9kZSh0aGlzLCBub3JtYWxpemVBbmltYXRpb25FbnRyeShtZXRhZGF0YS5hbmltYXRpb24pLCBjb250ZXh0KSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZUFuaW1hdGlvbk9wdGlvbnMobWV0YWRhdGEub3B0aW9ucylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRBbmltYXRlQ2hpbGQobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5kZXBDb3VudCsrO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogOSAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuQW5pbWF0ZUNoaWxkICovLFxuICAgICAgICAgICAgb3B0aW9uczogbm9ybWFsaXplQW5pbWF0aW9uT3B0aW9ucyhtZXRhZGF0YS5vcHRpb25zKVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdEFuaW1hdGVSZWYobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IDEwIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5BbmltYXRlUmVmICovLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLnZpc2l0UmVmZXJlbmNlKG1ldGFkYXRhLmFuaW1hdGlvbiwgY29udGV4dCksXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0UXVlcnkobWV0YWRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50U2VsZWN0b3IgPSBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gKG1ldGFkYXRhLm9wdGlvbnMgfHwge30pO1xuICAgICAgICBjb250ZXh0LnF1ZXJ5Q291bnQrKztcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnkgPSBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgW3NlbGVjdG9yLCBpbmNsdWRlU2VsZl0gPSBub3JtYWxpemVTZWxlY3RvcihtZXRhZGF0YS5zZWxlY3Rvcik7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5U2VsZWN0b3IgPVxuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IubGVuZ3RoID8gKHBhcmVudFNlbGVjdG9yICsgJyAnICsgc2VsZWN0b3IpIDogc2VsZWN0b3I7XG4gICAgICAgIGdldE9yU2V0RGVmYXVsdFZhbHVlKGNvbnRleHQuY29sbGVjdGVkU3R5bGVzLCBjb250ZXh0LmN1cnJlbnRRdWVyeVNlbGVjdG9yLCBuZXcgTWFwKCkpO1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB2aXNpdERzbE5vZGUodGhpcywgbm9ybWFsaXplQW5pbWF0aW9uRW50cnkobWV0YWRhdGEuYW5pbWF0aW9uKSwgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlTZWxlY3RvciA9IHBhcmVudFNlbGVjdG9yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogMTEgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlF1ZXJ5ICovLFxuICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCB8fCAwLFxuICAgICAgICAgICAgb3B0aW9uYWw6ICEhb3B0aW9ucy5vcHRpb25hbCxcbiAgICAgICAgICAgIGluY2x1ZGVTZWxmLFxuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgb3JpZ2luYWxTZWxlY3RvcjogbWV0YWRhdGEuc2VsZWN0b3IsXG4gICAgICAgICAgICBvcHRpb25zOiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG1ldGFkYXRhLm9wdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0U3RhZ2dlcihtZXRhZGF0YSwgY29udGV4dCkge1xuICAgICAgICBpZiAoIWNvbnRleHQuY3VycmVudFF1ZXJ5KSB7XG4gICAgICAgICAgICBjb250ZXh0LmVycm9ycy5wdXNoKGludmFsaWRTdGFnZ2VyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWluZ3MgPSBtZXRhZGF0YS50aW1pbmdzID09PSAnZnVsbCcgP1xuICAgICAgICAgICAgeyBkdXJhdGlvbjogMCwgZGVsYXk6IDAsIGVhc2luZzogJ2Z1bGwnIH0gOlxuICAgICAgICAgICAgcmVzb2x2ZVRpbWluZyhtZXRhZGF0YS50aW1pbmdzLCBjb250ZXh0LmVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAxMiAvKiBBbmltYXRpb25NZXRhZGF0YVR5cGUuU3RhZ2dlciAqLyxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogdmlzaXREc2xOb2RlKHRoaXMsIG5vcm1hbGl6ZUFuaW1hdGlvbkVudHJ5KG1ldGFkYXRhLmFuaW1hdGlvbiksIGNvbnRleHQpLFxuICAgICAgICAgICAgdGltaW5ncyxcbiAgICAgICAgICAgIG9wdGlvbnM6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGhhc0FtcGVyc2FuZCA9IHNlbGVjdG9yLnNwbGl0KC9cXHMqLFxccyovKS5maW5kKHRva2VuID0+IHRva2VuID09IFNFTEZfVE9LRU4pID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGlmIChoYXNBbXBlcnNhbmQpIHtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKFNFTEZfVE9LRU5fUkVHRVgsICcnKTtcbiAgICB9XG4gICAgLy8gTm90ZTogdGhlIDplbnRlciBhbmQgOmxlYXZlIGFyZW4ndCBub3JtYWxpemVkIGhlcmUgc2luY2UgdGhvc2VcbiAgICAvLyBzZWxlY3RvcnMgYXJlIGZpbGxlZCBpbiBhdCBydW50aW1lIGR1cmluZyB0aW1lbGluZSBidWlsZGluZ1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvQFxcKi9nLCBOR19UUklHR0VSX1NFTEVDVE9SKVxuICAgICAgICAucmVwbGFjZSgvQFxcdysvZywgbWF0Y2ggPT4gTkdfVFJJR0dFUl9TRUxFQ1RPUiArICctJyArIG1hdGNoLnNsaWNlKDEpKVxuICAgICAgICAucmVwbGFjZSgvOmFuaW1hdGluZy9nLCBOR19BTklNQVRJTkdfU0VMRUNUT1IpO1xuICAgIHJldHVybiBbc2VsZWN0b3IsIGhhc0FtcGVyc2FuZF07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbXMob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA/IGNvcHlPYmoob2JqKSA6IG51bGw7XG59XG5jbGFzcyBBbmltYXRpb25Bc3RCdWlsZGVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnF1ZXJ5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmRlcENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNpdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkU3R5bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLnVuc3VwcG9ydGVkQ1NTUHJvcGVydGllc0ZvdW5kID0gbmV3IFNldCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnN1bWVPZmZzZXQoc3R5bGVzKSB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvZmZzZXQgPSBudWxsO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcbiAgICAgICAgc3R5bGVzLmZvckVhY2goc3R5bGVUdXBsZSA9PiB7XG4gICAgICAgICAgICBpZiAoc3R5bGVUdXBsZSBpbnN0YW5jZW9mIE1hcCAmJiBzdHlsZVR1cGxlLmhhcygnb2Zmc2V0JykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSBzdHlsZVR1cGxlO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2JqLmdldCgnb2Zmc2V0JykpO1xuICAgICAgICAgICAgICAgIG9iai5kZWxldGUoJ29mZnNldCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3R5bGVzIGluc3RhbmNlb2YgTWFwICYmIHN0eWxlcy5oYXMoJ29mZnNldCcpKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHN0eWxlcztcbiAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvYmouZ2V0KCdvZmZzZXQnKSk7XG4gICAgICAgIG9iai5kZWxldGUoJ29mZnNldCcpO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuZnVuY3Rpb24gY29uc3RydWN0VGltaW5nQXN0KHZhbHVlLCBlcnJvcnMpIHtcbiAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoJ2R1cmF0aW9uJykpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gcmVzb2x2ZVRpbWluZyh2YWx1ZSwgZXJyb3JzKS5kdXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIG1ha2VUaW1pbmdBc3QoZHVyYXRpb24sIDAsICcnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyVmFsdWUgPSB2YWx1ZTtcbiAgICBjb25zdCBpc0R5bmFtaWMgPSBzdHJWYWx1ZS5zcGxpdCgvXFxzKy8pLnNvbWUodiA9PiB2LmNoYXJBdCgwKSA9PSAneycgJiYgdi5jaGFyQXQoMSkgPT0gJ3snKTtcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IG1ha2VUaW1pbmdBc3QoMCwgMCwgJycpO1xuICAgICAgICBhc3QuZHluYW1pYyA9IHRydWU7XG4gICAgICAgIGFzdC5zdHJWYWx1ZSA9IHN0clZhbHVlO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICBjb25zdCB0aW1pbmdzID0gcmVzb2x2ZVRpbWluZyhzdHJWYWx1ZSwgZXJyb3JzKTtcbiAgICByZXR1cm4gbWFrZVRpbWluZ0FzdCh0aW1pbmdzLmR1cmF0aW9uLCB0aW1pbmdzLmRlbGF5LCB0aW1pbmdzLmVhc2luZyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ3BhcmFtcyddKSB7XG4gICAgICAgICAgICBvcHRpb25zWydwYXJhbXMnXSA9IG5vcm1hbGl6ZVBhcmFtcyhvcHRpb25zWydwYXJhbXMnXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBtYWtlVGltaW5nQXN0KGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHsgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbihlbGVtZW50LCBrZXlmcmFtZXMsIHByZVN0eWxlUHJvcHMsIHBvc3RTdHlsZVByb3BzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZyA9IG51bGwsIHN1YlRpbWVsaW5lID0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAxIC8qIEFuaW1hdGlvblRyYW5zaXRpb25JbnN0cnVjdGlvblR5cGUuVGltZWxpbmVBbmltYXRpb24gKi8sXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgcHJlU3R5bGVQcm9wcyxcbiAgICAgICAgcG9zdFN0eWxlUHJvcHMsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBkZWxheSxcbiAgICAgICAgdG90YWxUaW1lOiBkdXJhdGlvbiArIGRlbGF5LFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIHN1YlRpbWVsaW5lXG4gICAgfTtcbn1cblxuY2xhc3MgRWxlbWVudEluc3RydWN0aW9uTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChlbGVtZW50KSB8fCBbXTtcbiAgICB9XG4gICAgYXBwZW5kKGVsZW1lbnQsIGluc3RydWN0aW9ucykge1xuICAgICAgICBsZXQgZXhpc3RpbmdJbnN0cnVjdGlvbnMgPSB0aGlzLl9tYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWV4aXN0aW5nSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGVsZW1lbnQsIGV4aXN0aW5nSW5zdHJ1Y3Rpb25zID0gW10pO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nSW5zdHJ1Y3Rpb25zLnB1c2goLi4uaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgaGFzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoZWxlbWVudCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICB9XG59XG5cbmNvbnN0IE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFMgPSAxO1xuY29uc3QgRU5URVJfVE9LRU4gPSAnOmVudGVyJztcbmNvbnN0IEVOVEVSX1RPS0VOX1JFR0VYID0gbmV3IFJlZ0V4cChFTlRFUl9UT0tFTiwgJ2cnKTtcbmNvbnN0IExFQVZFX1RPS0VOID0gJzpsZWF2ZSc7XG5jb25zdCBMRUFWRV9UT0tFTl9SRUdFWCA9IG5ldyBSZWdFeHAoTEVBVkVfVE9LRU4sICdnJyk7XG4vKlxuICogVGhlIGNvZGUgd2l0aGluIHRoaXMgZmlsZSBhaW1zIHRvIGdlbmVyYXRlIHdlYi1hbmltYXRpb25zLWNvbXBhdGlibGUga2V5ZnJhbWVzIGZyb20gQW5ndWxhcidzXG4gKiBhbmltYXRpb24gRFNMIGNvZGUuXG4gKlxuICogVGhlIGNvZGUgYmVsb3cgd2lsbCBiZSBjb252ZXJ0ZWQgZnJvbTpcbiAqXG4gKiBgYGBcbiAqIHNlcXVlbmNlKFtcbiAqICAgc3R5bGUoeyBvcGFjaXR5OiAwIH0pLFxuICogICBhbmltYXRlKDEwMDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSlcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBUbzpcbiAqIGBgYFxuICoga2V5ZnJhbWVzID0gW3sgb3BhY2l0eTogMCwgb2Zmc2V0OiAwIH0sIHsgb3BhY2l0eTogMSwgb2Zmc2V0OiAxIH1dXG4gKiBkdXJhdGlvbiA9IDEwMDBcbiAqIGRlbGF5ID0gMFxuICogZWFzaW5nID0gJydcbiAqIGBgYFxuICpcbiAqIEZvciB0aGlzIG9wZXJhdGlvbiB0byBjb3ZlciB0aGUgY29tYmluYXRpb24gb2YgYW5pbWF0aW9uIHZlcmJzIChzdHlsZSwgYW5pbWF0ZSwgZ3JvdXAsIGV0Yy4uLikgYVxuICogY29tYmluYXRpb24gb2YgQVNUIHRyYXZlcnNhbCBhbmQgbWVyZ2Utc29ydC1saWtlIGFsZ29yaXRobXMgYXJlIHVzZWQuXG4gKlxuICogW0FTVCBUcmF2ZXJzYWxdXG4gKiBFYWNoIG9mIHRoZSBhbmltYXRpb24gdmVyYnMsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgcmV0dXJuIGFuIHN0cmluZy1tYXAgb2JqZWN0IHJlcHJlc2VudGluZyB3aGF0XG4gKiB0eXBlIG9mIGFjdGlvbiBpdCBpcyAoc3R5bGUsIGFuaW1hdGUsIGdyb3VwLCBldGMuLi4pIGFuZCB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQuIFRoaXMgbWVhbnNcbiAqIHRoYXQgd2hlbiBmdW5jdGlvbmFsIGNvbXBvc2l0aW9uIG1peCBvZiB0aGVzZSBmdW5jdGlvbnMgaXMgZXZhbHVhdGVkIChsaWtlIGluIHRoZSBleGFtcGxlIGFib3ZlKVxuICogdGhlbiBpdCB3aWxsIGVuZCB1cCBwcm9kdWNpbmcgYSB0cmVlIG9mIG9iamVjdHMgcmVwcmVzZW50aW5nIHRoZSBhbmltYXRpb24gaXRzZWxmLlxuICpcbiAqIFdoZW4gdGhpcyBhbmltYXRpb24gb2JqZWN0IHRyZWUgaXMgcHJvY2Vzc2VkIGJ5IHRoZSB2aXNpdG9yIGNvZGUgYmVsb3cgaXQgd2lsbCB2aXNpdCBlYWNoIG9mIHRoZVxuICogdmVyYiBzdGF0ZW1lbnRzIHdpdGhpbiB0aGUgdmlzaXRvci4gQW5kIGR1cmluZyBlYWNoIHZpc2l0IGl0IHdpbGwgYnVpbGQgdGhlIGNvbnRleHQgb2YgdGhlXG4gKiBhbmltYXRpb24ga2V5ZnJhbWVzIGJ5IGludGVyYWN0aW5nIHdpdGggdGhlIGBUaW1lbGluZUJ1aWxkZXJgLlxuICpcbiAqIFtUaW1lbGluZUJ1aWxkZXJdXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFja2luZyB0aGUgc3R5bGVzIGFuZCBidWlsZGluZyBhIHNlcmllcyBvZiBrZXlmcmFtZSBvYmplY3RzIGZvciBhXG4gKiB0aW1lbGluZSBiZXR3ZWVuIGEgc3RhcnQgYW5kIGVuZCB0aW1lLiBUaGUgYnVpbGRlciBzdGFydHMgb2ZmIHdpdGggYW4gaW5pdGlhbCB0aW1lbGluZSBhbmQgZWFjaFxuICogdGltZSB0aGUgQVNUIGNvbWVzIGFjcm9zcyBhIGBncm91cCgpYCwgYGtleWZyYW1lcygpYCBvciBhIGNvbWJpbmF0aW9uIG9mIHRoZSB0d28gd2l0aGluIGFcbiAqIGBzZXF1ZW5jZSgpYCB0aGVuIGl0IHdpbGwgZ2VuZXJhdGUgYSBzdWIgdGltZWxpbmUgZm9yIGVhY2ggc3RlcCBhcyB3ZWxsIGFzIGEgbmV3IG9uZSBhZnRlclxuICogdGhleSBhcmUgY29tcGxldGUuXG4gKlxuICogQXMgdGhlIEFTVCBpcyB0cmF2ZXJzZWQsIHRoZSB0aW1pbmcgc3RhdGUgb24gZWFjaCBvZiB0aGUgdGltZWxpbmVzIHdpbGwgYmUgaW5jcmVtZW50ZWQuIElmIGEgc3ViXG4gKiB0aW1lbGluZSB3YXMgY3JlYXRlZCAoYmFzZWQgb24gb25lIG9mIHRoZSBjYXNlcyBhYm92ZSkgdGhlbiB0aGUgcGFyZW50IHRpbWVsaW5lIHdpbGwgYXR0ZW1wdCB0b1xuICogbWVyZ2UgdGhlIHN0eWxlcyB1c2VkIHdpdGhpbiB0aGUgc3ViIHRpbWVsaW5lcyBpbnRvIGl0c2VsZiAob25seSB3aXRoIGdyb3VwKCkgdGhpcyB3aWxsIGhhcHBlbikuXG4gKiBUaGlzIGhhcHBlbnMgd2l0aCBhIG1lcmdlIG9wZXJhdGlvbiAobXVjaCBsaWtlIGhvdyB0aGUgbWVyZ2Ugd29ya3MgaW4gbWVyZ2VTb3J0KSBhbmQgaXQgd2lsbCBvbmx5XG4gKiBjb3B5IHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgc3R5bGVzIGZyb20gdGhlIHN1YiB0aW1lbGluZXMgaW50byB0aGUgcGFyZW50IHRpbWVsaW5lLiBUaGlzIGVuc3VyZXNcbiAqIHRoYXQgaWYgdGhlIHN0eWxlcyBhcmUgdXNlZCBsYXRlciBvbiBpbiBhbm90aGVyIHBoYXNlIG9mIHRoZSBhbmltYXRpb24gdGhlbiB0aGV5IHdpbGwgYmUgdGhlIG1vc3RcbiAqIHVwLXRvLWRhdGUgdmFsdWVzLlxuICpcbiAqIFtIb3cgTWlzc2luZyBTdHlsZXMgQXJlIFVwZGF0ZWRdXG4gKiBFYWNoIHRpbWVsaW5lIGhhcyBhIGBiYWNrRmlsbGAgcHJvcGVydHkgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgaW4gbmV3IHN0eWxlcyBpbnRvXG4gKiBhbHJlYWR5IHByb2Nlc3NlZCBrZXlmcmFtZXMgaWYgYSBuZXcgc3R5bGUgc2hvd3MgdXAgbGF0ZXIgd2l0aGluIHRoZSBhbmltYXRpb24gc2VxdWVuY2UuXG4gKlxuICogYGBgXG4gKiBzZXF1ZW5jZShbXG4gKiAgIHN0eWxlKHsgd2lkdGg6IDAgfSksXG4gKiAgIGFuaW1hdGUoMTAwMCwgc3R5bGUoeyB3aWR0aDogMTAwIH0pKSxcbiAqICAgYW5pbWF0ZSgxMDAwLCBzdHlsZSh7IHdpZHRoOiAyMDAgfSkpLFxuICogICBhbmltYXRlKDEwMDAsIHN0eWxlKHsgd2lkdGg6IDMwMCB9KSlcbiAqICAgYW5pbWF0ZSgxMDAwLCBzdHlsZSh7IHdpZHRoOiA0MDAsIGhlaWdodDogNDAwIH0pKSAvLyBub3RpY2UgaG93IGBoZWlnaHRgIGRvZXNuJ3QgZXhpc3QgYW55d2hlcmVcbiAqIGVsc2VcbiAqIF0pXG4gKiBgYGBcbiAqXG4gKiBXaGF0IGlzIGhhcHBlbmluZyBoZXJlIGlzIHRoYXQgdGhlIGBoZWlnaHRgIHZhbHVlIGlzIGFkZGVkIGxhdGVyIGluIHRoZSBzZXF1ZW5jZSwgYnV0IGlzIG1pc3NpbmdcbiAqIGZyb20gYWxsIHByZXZpb3VzIGFuaW1hdGlvbiBzdGVwcy4gVGhlcmVmb3JlIHdoZW4gYSBrZXlmcmFtZSBpcyBjcmVhdGVkIGl0IHdvdWxkIGFsc28gYmUgbWlzc2luZ1xuICogZnJvbSBhbGwgcHJldmlvdXMga2V5ZnJhbWVzIHVwIHVudGlsIHdoZXJlIGl0IGlzIGZpcnN0IHVzZWQuIEZvciB0aGUgdGltZWxpbmUga2V5ZnJhbWUgZ2VuZXJhdGlvblxuICogdG8gcHJvcGVybHkgZmlsbCBpbiB0aGUgc3R5bGUgaXQgd2lsbCBwbGFjZSB0aGUgcHJldmlvdXMgdmFsdWUgKHRoZSB2YWx1ZSBmcm9tIHRoZSBwYXJlbnRcbiAqIHRpbWVsaW5lKSBvciBhIGRlZmF1bHQgdmFsdWUgb2YgYCpgIGludG8gdGhlIGJhY2tGaWxsIG1hcC4gVGhlIGBjb3B5U3R5bGVzYCBtZXRob2QgaW4gdXRpbC50c1xuICogaGFuZGxlcyBwcm9wYWdhdGluZyB0aGF0IGJhY2tmaWxsIG1hcCB0byB0aGUgc3R5bGVzIG9iamVjdC5cbiAqXG4gKiBXaGVuIGEgc3ViLXRpbWVsaW5lIGlzIGNyZWF0ZWQgaXQgd2lsbCBoYXZlIGl0cyBvd24gYmFja0ZpbGwgcHJvcGVydHkuIFRoaXMgaXMgZG9uZSBzbyB0aGF0XG4gKiBzdHlsZXMgcHJlc2VudCB3aXRoaW4gdGhlIHN1Yi10aW1lbGluZSBkbyBub3QgYWNjaWRlbnRhbGx5IHNlZXAgaW50byB0aGUgcHJldmlvdXMvZnV0dXJlIHRpbWVsaW5lXG4gKiBrZXlmcmFtZXNcbiAqXG4gKiBbVmFsaWRhdGlvbl1cbiAqIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBub3QgcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpb24uIFRoYXQgZnVuY3Rpb25hbGl0eSBoYXBwZW5zIHdpdGggd2l0aGluXG4gKiB0aGUgYEFuaW1hdGlvblZhbGlkYXRvclZpc2l0b3JgIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQW5pbWF0aW9uVGltZWxpbmVzKGRyaXZlciwgcm9vdEVsZW1lbnQsIGFzdCwgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBzdGFydGluZ1N0eWxlcyA9IG5ldyBNYXAoKSwgZmluYWxTdHlsZXMgPSBuZXcgTWFwKCksIG9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGlvblRpbWVsaW5lQnVpbGRlclZpc2l0b3IoKS5idWlsZEtleWZyYW1lcyhkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyk7XG59XG5jbGFzcyBBbmltYXRpb25UaW1lbGluZUJ1aWxkZXJWaXNpdG9yIHtcbiAgICBidWlsZEtleWZyYW1lcyhkcml2ZXIsIHJvb3RFbGVtZW50LCBhc3QsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgc3RhcnRpbmdTdHlsZXMsIGZpbmFsU3R5bGVzLCBvcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIGVycm9ycyA9IFtdKSB7XG4gICAgICAgIHN1Ykluc3RydWN0aW9ucyA9IHN1Ykluc3RydWN0aW9ucyB8fCBuZXcgRWxlbWVudEluc3RydWN0aW9uTWFwKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBuZXcgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0KGRyaXZlciwgcm9vdEVsZW1lbnQsIHN1Ykluc3RydWN0aW9ucywgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBlcnJvcnMsIFtdKTtcbiAgICAgICAgY29udGV4dC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGVsYXkgPSBvcHRpb25zLmRlbGF5ID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZGVsYXkpIDogMDtcbiAgICAgICAgY29udGV4dC5jdXJyZW50VGltZWxpbmUuZGVsYXlOZXh0U3RlcChkZWxheSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLnNldFN0eWxlcyhbc3RhcnRpbmdTdHlsZXNdLCBudWxsLCBjb250ZXh0LmVycm9ycywgb3B0aW9ucyk7XG4gICAgICAgIHZpc2l0RHNsTm9kZSh0aGlzLCBhc3QsIGNvbnRleHQpO1xuICAgICAgICAvLyB0aGlzIGNoZWNrcyB0byBzZWUgaWYgYW4gYWN0dWFsIGFuaW1hdGlvbiBoYXBwZW5lZFxuICAgICAgICBjb25zdCB0aW1lbGluZXMgPSBjb250ZXh0LnRpbWVsaW5lcy5maWx0ZXIodGltZWxpbmUgPT4gdGltZWxpbmUuY29udGFpbnNBbmltYXRpb24oKSk7XG4gICAgICAgIC8vIG5vdGU6IHdlIGp1c3Qgd2FudCB0byBhcHBseSB0aGUgZmluYWwgc3R5bGVzIGZvciB0aGUgcm9vdEVsZW1lbnQsIHNvIHdlIGRvIG5vdFxuICAgICAgICAvLyAgICAgICBqdXN0IGFwcGx5IHRoZSBzdHlsZXMgdG8gdGhlIGxhc3QgdGltZWxpbmUgYnV0IHRoZSBsYXN0IHRpbWVsaW5lIHdoaWNoXG4gICAgICAgIC8vICAgICAgIGVsZW1lbnQgaXMgdGhlIHJvb3Qgb25lIChiYXNpY2FsbHkgYCpgLXN0eWxlcyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgYWN0dWFsXG4gICAgICAgIC8vICAgICAgIHN0YXRlIHN0eWxlIHZhbHVlcyBvbmx5IGZvciB0aGUgcm9vdCBlbGVtZW50KVxuICAgICAgICBpZiAodGltZWxpbmVzLmxlbmd0aCAmJiBmaW5hbFN0eWxlcy5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbGFzdFJvb3RUaW1lbGluZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aW1lbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRpbWVsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodGltZWxpbmUuZWxlbWVudCA9PT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFJvb3RUaW1lbGluZSA9IHRpbWVsaW5lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdFJvb3RUaW1lbGluZSAmJiAhbGFzdFJvb3RUaW1lbGluZS5hbGxvd09ubHlUaW1lbGluZVN0eWxlcygpKSB7XG4gICAgICAgICAgICAgICAgbGFzdFJvb3RUaW1lbGluZS5zZXRTdHlsZXMoW2ZpbmFsU3R5bGVzXSwgbnVsbCwgY29udGV4dC5lcnJvcnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aW1lbGluZXMubGVuZ3RoID9cbiAgICAgICAgICAgIHRpbWVsaW5lcy5tYXAodGltZWxpbmUgPT4gdGltZWxpbmUuYnVpbGRLZXlmcmFtZXMoKSkgOlxuICAgICAgICAgICAgW2NyZWF0ZVRpbWVsaW5lSW5zdHJ1Y3Rpb24ocm9vdEVsZW1lbnQsIFtdLCBbXSwgW10sIDAsIGRlbGF5LCAnJywgZmFsc2UpXTtcbiAgICB9XG4gICAgdmlzaXRUcmlnZ2VyKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXG4gICAgfVxuICAgIHZpc2l0U3RhdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBhcmUgbm90IHZpc2l0ZWQgaW4gdGhpcyBBU1RcbiAgICB9XG4gICAgdmlzaXRUcmFuc2l0aW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyB0aGVzZSB2YWx1ZXMgYXJlIG5vdCB2aXNpdGVkIGluIHRoaXMgQVNUXG4gICAgfVxuICAgIHZpc2l0QW5pbWF0ZUNoaWxkKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBlbGVtZW50SW5zdHJ1Y3Rpb25zID0gY29udGV4dC5zdWJJbnN0cnVjdGlvbnMuZ2V0KGNvbnRleHQuZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50SW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBpbm5lckNvbnRleHQgPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQoYXN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWU7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5fdmlzaXRTdWJJbnN0cnVjdGlvbnMoZWxlbWVudEluc3RydWN0aW9ucywgaW5uZXJDb250ZXh0LCBpbm5lckNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBkbyB0aGlzIG9uIHRoZSB1cHBlciBjb250ZXh0IGJlY2F1c2Ugd2UgY3JlYXRlZCBhIHN1YiBjb250ZXh0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdWIgY2hpbGQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGVuZFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH1cbiAgICB2aXNpdEFuaW1hdGVSZWYoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dChhc3Qub3B0aW9ucyk7XG4gICAgICAgIGlubmVyQ29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlBbmltYXRpb25SZWZEZWxheXMoW2FzdC5vcHRpb25zLCBhc3QuYW5pbWF0aW9uLm9wdGlvbnNdLCBjb250ZXh0LCBpbm5lckNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0UmVmZXJlbmNlKGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGlubmVyQ29udGV4dC5jdXJyZW50VGltZWxpbmUuY3VycmVudFRpbWUpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9XG4gICAgX2FwcGx5QW5pbWF0aW9uUmVmRGVsYXlzKGFuaW1hdGlvbnNSZWZzT3B0aW9ucywgY29udGV4dCwgaW5uZXJDb250ZXh0KSB7XG4gICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uUmVmT3B0aW9ucyBvZiBhbmltYXRpb25zUmVmc09wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5ID0gYW5pbWF0aW9uUmVmT3B0aW9ucz8uZGVsYXk7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGVsYXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25EZWxheVZhbHVlID0gdHlwZW9mIGFuaW1hdGlvbkRlbGF5ID09PSAnbnVtYmVyJyA/XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkRlbGF5IDpcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVRpbWluZ1ZhbHVlKGludGVycG9sYXRlUGFyYW1zKGFuaW1hdGlvbkRlbGF5LCBhbmltYXRpb25SZWZPcHRpb25zPy5wYXJhbXMgPz8ge30sIGNvbnRleHQuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0LmRlbGF5TmV4dFN0ZXAoYW5pbWF0aW9uRGVsYXlWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Zpc2l0U3ViSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucywgY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgbGV0IGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwtY2FzZSBmb3Igd2hlbiBhIHVzZXIgd2FudHMgdG8gc2tpcCBhIHN1YlxuICAgICAgICAvLyBhbmltYXRpb24gZnJvbSBiZWluZyBmaXJlZCBlbnRpcmVseS5cbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uICE9IG51bGwgPyByZXNvbHZlVGltaW5nVmFsdWUob3B0aW9ucy5kdXJhdGlvbikgOiBudWxsO1xuICAgICAgICBjb25zdCBkZWxheSA9IG9wdGlvbnMuZGVsYXkgIT0gbnVsbCA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IG51bGw7XG4gICAgICAgIGlmIChkdXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RydWN0aW9uVGltaW5ncyA9IGNvbnRleHQuYXBwZW5kSW5zdHJ1Y3Rpb25Ub1RpbWVsaW5lKGluc3RydWN0aW9uLCBkdXJhdGlvbiwgZGVsYXkpO1xuICAgICAgICAgICAgICAgIGZ1cnRoZXN0VGltZSA9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGZ1cnRoZXN0VGltZSwgaW5zdHJ1Y3Rpb25UaW1pbmdzLmR1cmF0aW9uICsgaW5zdHJ1Y3Rpb25UaW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdXJ0aGVzdFRpbWU7XG4gICAgfVxuICAgIHZpc2l0UmVmZXJlbmNlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0LnVwZGF0ZU9wdGlvbnMoYXN0Lm9wdGlvbnMsIHRydWUpO1xuICAgICAgICB2aXNpdERzbE5vZGUodGhpcywgYXN0LmFuaW1hdGlvbiwgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH1cbiAgICB2aXNpdFNlcXVlbmNlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBzdWJDb250ZXh0Q291bnQgPSBjb250ZXh0LnN1YkNvbnRleHRDb3VudDtcbiAgICAgICAgbGV0IGN0eCA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhc3Qub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMucGFyYW1zIHx8IG9wdGlvbnMuZGVsYXkpKSB7XG4gICAgICAgICAgICBjdHggPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQob3B0aW9ucyk7XG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5wcmV2aW91c05vZGUudHlwZSA9PSA2IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5TdHlsZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBjdHguY3VycmVudFRpbWVsaW5lLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xuICAgICAgICAgICAgICAgICAgICBjdHgucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gcmVzb2x2ZVRpbWluZ1ZhbHVlKG9wdGlvbnMuZGVsYXkpO1xuICAgICAgICAgICAgICAgIGN0eC5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0LnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXN0LnN0ZXBzLmZvckVhY2gocyA9PiB2aXNpdERzbE5vZGUodGhpcywgcywgY3R4KSk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGhlcmUganVzdCBpbiBjYXNlIHRoZSBpbm5lciBzdGVwcyBvbmx5IGNvbnRhaW4gb3IgZW5kIHdpdGggYSBzdHlsZSgpIGNhbGxcbiAgICAgICAgICAgIGN0eC5jdXJyZW50VGltZWxpbmUuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgc29tZSBhbmltYXRpb24gZnVuY3Rpb24gd2l0aGluIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gZW5kZWQgdXAgY3JlYXRpbmcgYSBzdWIgdGltZWxpbmUgKHdoaWNoIG1lYW5zIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyB0aW1lbGluZSBjYW5ub3Qgb3ZlcmxhcCB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgc2VxdWVuY2UpXG4gICAgICAgICAgICBpZiAoY3R4LnN1YkNvbnRleHRDb3VudCA+IHN1YkNvbnRleHRDb3VudCkge1xuICAgICAgICAgICAgICAgIGN0eC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9XG4gICAgdmlzaXRHcm91cChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaW5uZXJUaW1lbGluZXMgPSBbXTtcbiAgICAgICAgbGV0IGZ1cnRoZXN0VGltZSA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICBjb25zdCBkZWxheSA9IGFzdC5vcHRpb25zICYmIGFzdC5vcHRpb25zLmRlbGF5ID8gcmVzb2x2ZVRpbWluZ1ZhbHVlKGFzdC5vcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGFzdC5zdGVwcy5mb3JFYWNoKHMgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5uZXJDb250ZXh0ID0gY29udGV4dC5jcmVhdGVTdWJDb250ZXh0KGFzdC5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgICAgICAgIGlubmVyQ29udGV4dC5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpc2l0RHNsTm9kZSh0aGlzLCBzLCBpbm5lckNvbnRleHQpO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGlubmVyVGltZWxpbmVzLnB1c2goaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBydW4gYWZ0ZXIgdGhlIEFTVCBsb29wIGJlY2F1c2Ugb3RoZXJ3aXNlXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgdGltZWxpbmUncyBjb2xsZWN0ZWQgc3R5bGVzIHdlcmUgdXBkYXRlZCB0aGVuXG4gICAgICAgIC8vIGl0IHdvdWxkIHBhc3MgaW4gaW52YWxpZCBkYXRhIGludG8gdGhlIG5ldy10by1iZSBmb3JrZWQgaXRlbXNcbiAgICAgICAgaW5uZXJUaW1lbGluZXMuZm9yRWFjaCh0aW1lbGluZSA9PiBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5tZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHRpbWVsaW5lKSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKGZ1cnRoZXN0VGltZSk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH1cbiAgICBfdmlzaXRUaW1pbmcoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QuZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSBhc3Quc3RyVmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0aW1pbmdWYWx1ZSA9IGNvbnRleHQucGFyYW1zID8gaW50ZXJwb2xhdGVQYXJhbXMoc3RyVmFsdWUsIGNvbnRleHQucGFyYW1zLCBjb250ZXh0LmVycm9ycykgOiBzdHJWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlVGltaW5nKHRpbWluZ1ZhbHVlLCBjb250ZXh0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogYXN0LmR1cmF0aW9uLCBkZWxheTogYXN0LmRlbGF5LCBlYXNpbmc6IGFzdC5lYXNpbmcgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEFuaW1hdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncyA9IHRoaXMuX3Zpc2l0VGltaW5nKGFzdC50aW1pbmdzLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaWYgKHRpbWluZ3MuZGVsYXkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5jcmVtZW50VGltZSh0aW1pbmdzLmRlbGF5KTtcbiAgICAgICAgICAgIHRpbWVsaW5lLnNuYXBzaG90Q3VycmVudFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlID0gYXN0LnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUudHlwZSA9PSA1IC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5LZXlmcmFtZXMgKi8pIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRLZXlmcmFtZXMoc3R5bGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5pbmNyZW1lbnRUaW1lKHRpbWluZ3MuZHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy52aXNpdFN0eWxlKHN0eWxlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHRpbWVsaW5lLmFwcGx5U3R5bGVzVG9LZXlmcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gbnVsbDtcbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfVxuICAgIHZpc2l0U3R5bGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVsaW5lID0gY29udGV4dC5jdXJyZW50VGltZWxpbmU7XG4gICAgICAgIGNvbnN0IHRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgLy8gdGhpcyBpcyBhIHNwZWNpYWwgY2FzZSBmb3Igd2hlbiBhIHN0eWxlKCkgY2FsbFxuICAgICAgICAvLyBkaXJlY3RseSBmb2xsb3dzICBhbiBhbmltYXRlKCkgY2FsbCAoYnV0IG5vdCBpbnNpZGUgb2YgYW4gYW5pbWF0ZSgpIGNhbGwpXG4gICAgICAgIGlmICghdGltaW5ncyAmJiB0aW1lbGluZS5oYXNDdXJyZW50U3R5bGVQcm9wZXJ0aWVzKCkpIHtcbiAgICAgICAgICAgIHRpbWVsaW5lLmZvcndhcmRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVhc2luZyA9ICh0aW1pbmdzICYmIHRpbWluZ3MuZWFzaW5nKSB8fCBhc3QuZWFzaW5nO1xuICAgICAgICBpZiAoYXN0LmlzRW1wdHlTdGVwKSB7XG4gICAgICAgICAgICB0aW1lbGluZS5hcHBseUVtcHR5U3RlcChlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGltZWxpbmUuc2V0U3R5bGVzKGFzdC5zdHlsZXMsIGVhc2luZywgY29udGV4dC5lcnJvcnMsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5wcmV2aW91c05vZGUgPSBhc3Q7XG4gICAgfVxuICAgIHZpc2l0S2V5ZnJhbWVzKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBjb250ZXh0LmN1cnJlbnRBbmltYXRlVGltaW5ncztcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gKGNvbnRleHQuY3VycmVudFRpbWVsaW5lKS5kdXJhdGlvbjtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZHVyYXRpb247XG4gICAgICAgIGNvbnN0IGlubmVyQ29udGV4dCA9IGNvbnRleHQuY3JlYXRlU3ViQ29udGV4dCgpO1xuICAgICAgICBjb25zdCBpbm5lclRpbWVsaW5lID0gaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaW5uZXJUaW1lbGluZS5lYXNpbmcgPSBjdXJyZW50QW5pbWF0ZVRpbWluZ3MuZWFzaW5nO1xuICAgICAgICBhc3Quc3R5bGVzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGVwLm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgaW5uZXJUaW1lbGluZS5mb3J3YXJkVGltZShvZmZzZXQgKiBkdXJhdGlvbik7XG4gICAgICAgICAgICBpbm5lclRpbWVsaW5lLnNldFN0eWxlcyhzdGVwLnN0eWxlcywgc3RlcC5lYXNpbmcsIGNvbnRleHQuZXJyb3JzLCBjb250ZXh0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgaW5uZXJUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBlbnN1cmUgdGhhdCB0aGUgcGFyZW50IHRpbWVsaW5lIGdldHMgYWxsIHRoZSBzdHlsZXMgZnJvbVxuICAgICAgICAvLyB0aGUgY2hpbGQgZXZlbiBpZiB0aGUgbmV3IHRpbWVsaW5lIGJlbG93IGlzIG5vdCB1c2VkXG4gICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXMoaW5uZXJUaW1lbGluZSk7XG4gICAgICAgIC8vIHdlIGRvIHRoaXMgYmVjYXVzZSB0aGUgd2luZG93IGJldHdlZW4gdGhpcyB0aW1lbGluZSBhbmQgdGhlIHN1YiB0aW1lbGluZVxuICAgICAgICAvLyBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIHN0eWxlcyB3aXRoaW4gYXJlIGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhleSB3ZXJlIGJlZm9yZVxuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybUludG9OZXdUaW1lbGluZShzdGFydFRpbWUgKyBkdXJhdGlvbik7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gYXN0O1xuICAgIH1cbiAgICB2aXNpdFF1ZXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICAvLyBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgZmlyc3Qgc3RlcCBiZWZvcmUgdGhpcyBpcyBhIHN0eWxlIHN0ZXAgd2UgbmVlZFxuICAgICAgICAvLyB0byBlbnN1cmUgdGhlIHN0eWxlcyBhcmUgYXBwbGllZCBiZWZvcmUgdGhlIGNoaWxkcmVuIGFyZSBhbmltYXRlZFxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IChhc3Qub3B0aW9ucyB8fCB7fSk7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gb3B0aW9ucy5kZWxheSA/IHJlc29sdmVUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSA6IDA7XG4gICAgICAgIGlmIChkZWxheSAmJlxuICAgICAgICAgICAgKGNvbnRleHQucHJldmlvdXNOb2RlLnR5cGUgPT09IDYgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlN0eWxlICovIHx8XG4gICAgICAgICAgICAgICAgKHN0YXJ0VGltZSA9PSAwICYmIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLmhhc0N1cnJlbnRTdHlsZVByb3BlcnRpZXMoKSkpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gREVGQVVMVF9OT09QX1BSRVZJT1VTX05PREU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1cnRoZXN0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgZWxtcyA9IGNvbnRleHQuaW52b2tlUXVlcnkoYXN0LnNlbGVjdG9yLCBhc3Qub3JpZ2luYWxTZWxlY3RvciwgYXN0LmxpbWl0LCBhc3QuaW5jbHVkZVNlbGYsIG9wdGlvbnMub3B0aW9uYWwgPyB0cnVlIDogZmFsc2UsIGNvbnRleHQuZXJyb3JzKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlUb3RhbCA9IGVsbXMubGVuZ3RoO1xuICAgICAgICBsZXQgc2FtZUVsZW1lbnRUaW1lbGluZSA9IG51bGw7XG4gICAgICAgIGVsbXMuZm9yRWFjaCgoZWxlbWVudCwgaSkgPT4ge1xuICAgICAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlJbmRleCA9IGk7XG4gICAgICAgICAgICBjb25zdCBpbm5lckNvbnRleHQgPSBjb250ZXh0LmNyZWF0ZVN1YkNvbnRleHQoYXN0Lm9wdGlvbnMsIGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICAgICAgaW5uZXJDb250ZXh0LmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IGNvbnRleHQuZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNhbWVFbGVtZW50VGltZWxpbmUgPSBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXREc2xOb2RlKHRoaXMsIGFzdC5hbmltYXRpb24sIGlubmVyQ29udGV4dCk7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGhlcmUganVzdCBpbmNhc2UgdGhlIGlubmVyIHN0ZXBzIG9ubHkgY29udGFpbiBvciBlbmRcbiAgICAgICAgICAgIC8vIHdpdGggYSBzdHlsZSgpIGNhbGwgKHdoaWNoIGlzIGhlcmUgdG8gc2lnbmFsIHRoYXQgdGhpcyBpcyBhIHByZXBhcmF0b3J5XG4gICAgICAgICAgICAvLyBjYWxsIHRvIHN0eWxlIGFuIGVsZW1lbnQgYmVmb3JlIGl0IGlzIGFuaW1hdGVkIGFnYWluKVxuICAgICAgICAgICAgaW5uZXJDb250ZXh0LmN1cnJlbnRUaW1lbGluZS5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBpbm5lckNvbnRleHQuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lO1xuICAgICAgICAgICAgZnVydGhlc3RUaW1lID0gTWF0aC5tYXgoZnVydGhlc3RUaW1lLCBlbmRUaW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5SW5kZXggPSAwO1xuICAgICAgICBjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsID0gMDtcbiAgICAgICAgY29udGV4dC50cmFuc2Zvcm1JbnRvTmV3VGltZWxpbmUoZnVydGhlc3RUaW1lKTtcbiAgICAgICAgaWYgKHNhbWVFbGVtZW50VGltZWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudFRpbWVsaW5lLm1lcmdlVGltZWxpbmVDb2xsZWN0ZWRTdHlsZXMoc2FtZUVsZW1lbnRUaW1lbGluZSk7XG4gICAgICAgICAgICBjb250ZXh0LmN1cnJlbnRUaW1lbGluZS5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICB9XG4gICAgdmlzaXRTdGFnZ2VyKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBwYXJlbnRDb250ZXh0ID0gY29udGV4dC5wYXJlbnRDb250ZXh0O1xuICAgICAgICBjb25zdCB0bCA9IGNvbnRleHQuY3VycmVudFRpbWVsaW5lO1xuICAgICAgICBjb25zdCB0aW1pbmdzID0gYXN0LnRpbWluZ3M7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gTWF0aC5hYnModGltaW5ncy5kdXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG1heFRpbWUgPSBkdXJhdGlvbiAqIChjb250ZXh0LmN1cnJlbnRRdWVyeVRvdGFsIC0gMSk7XG4gICAgICAgIGxldCBkZWxheSA9IGR1cmF0aW9uICogY29udGV4dC5jdXJyZW50UXVlcnlJbmRleDtcbiAgICAgICAgbGV0IHN0YWdnZXJUcmFuc2Zvcm1lciA9IHRpbWluZ3MuZHVyYXRpb24gPCAwID8gJ3JldmVyc2UnIDogdGltaW5ncy5lYXNpbmc7XG4gICAgICAgIHN3aXRjaCAoc3RhZ2dlclRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICBjYXNlICdyZXZlcnNlJzpcbiAgICAgICAgICAgICAgICBkZWxheSA9IG1heFRpbWUgLSBkZWxheTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Z1bGwnOlxuICAgICAgICAgICAgICAgIGRlbGF5ID0gcGFyZW50Q29udGV4dC5jdXJyZW50U3RhZ2dlclRpbWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBjb250ZXh0LmN1cnJlbnRUaW1lbGluZTtcbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgICB0aW1lbGluZS5kZWxheU5leHRTdGVwKGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydGluZ1RpbWUgPSB0aW1lbGluZS5jdXJyZW50VGltZTtcbiAgICAgICAgdmlzaXREc2xOb2RlKHRoaXMsIGFzdC5hbmltYXRpb24sIGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnByZXZpb3VzTm9kZSA9IGFzdDtcbiAgICAgICAgLy8gdGltZSA9IGR1cmF0aW9uICsgZGVsYXlcbiAgICAgICAgLy8gdGhlIHJlYXNvbiB3aHkgdGhpcyBjb21wdXRhdGlvbiBpcyBzbyBjb21wbGV4IGlzIGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIGlubmVyIHRpbWVsaW5lIG1heSBlaXRoZXIgaGF2ZSBhIGRlbGF5IHZhbHVlIG9yIGEgc3RyZXRjaGVkXG4gICAgICAgIC8vIGtleWZyYW1lIGRlcGVuZGluZyBvbiBpZiBhIHN1YnRpbWVsaW5lIGlzIG5vdCB1c2VkIG9yIGlzIHVzZWQuXG4gICAgICAgIHBhcmVudENvbnRleHQuY3VycmVudFN0YWdnZXJUaW1lID1cbiAgICAgICAgICAgICh0bC5jdXJyZW50VGltZSAtIHN0YXJ0aW5nVGltZSkgKyAodGwuc3RhcnRUaW1lIC0gcGFyZW50Q29udGV4dC5jdXJyZW50VGltZWxpbmUuc3RhcnRUaW1lKTtcbiAgICB9XG59XG5jb25zdCBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERSA9IHt9O1xuY2xhc3MgQW5pbWF0aW9uVGltZWxpbmVDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihfZHJpdmVyLCBlbGVtZW50LCBzdWJJbnN0cnVjdGlvbnMsIF9lbnRlckNsYXNzTmFtZSwgX2xlYXZlQ2xhc3NOYW1lLCBlcnJvcnMsIHRpbWVsaW5lcywgaW5pdGlhbFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zO1xuICAgICAgICB0aGlzLl9lbnRlckNsYXNzTmFtZSA9IF9lbnRlckNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5fbGVhdmVDbGFzc05hbWUgPSBfbGVhdmVDbGFzc05hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnRpbWVsaW5lcyA9IHRpbWVsaW5lcztcbiAgICAgICAgdGhpcy5wYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzTm9kZSA9IERFRkFVTFRfTk9PUF9QUkVWSU9VU19OT0RFO1xuICAgICAgICB0aGlzLnN1YkNvbnRleHRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWVyeUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UXVlcnlUb3RhbCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YWdnZXJUaW1lID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUgPSBpbml0aWFsVGltZWxpbmUgfHwgbmV3IFRpbWVsaW5lQnVpbGRlcih0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIDApO1xuICAgICAgICB0aW1lbGluZXMucHVzaCh0aGlzLmN1cnJlbnRUaW1lbGluZSk7XG4gICAgfVxuICAgIGdldCBwYXJhbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgIH1cbiAgICB1cGRhdGVPcHRpb25zKG9wdGlvbnMsIHNraXBJZkV4aXN0cykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBsZXQgb3B0aW9uc1RvVXBkYXRlID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgZ2V0IHBhdGNoZWQgdXAgd2hlbiBvdGhlciBhbmltYXRpb24gbWV0aG9kcyBzdXBwb3J0IGR1cmF0aW9uIG92ZXJyaWRlc1xuICAgICAgICBpZiAobmV3T3B0aW9ucy5kdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zVG9VcGRhdGUuZHVyYXRpb24gPSByZXNvbHZlVGltaW5nVmFsdWUobmV3T3B0aW9ucy5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld09wdGlvbnMuZGVsYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uc1RvVXBkYXRlLmRlbGF5ID0gcmVzb2x2ZVRpbWluZ1ZhbHVlKG5ld09wdGlvbnMuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IG5ld09wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XG4gICAgICAgICAgICBsZXQgcGFyYW1zVG9VcGRhdGUgPSBvcHRpb25zVG9VcGRhdGUucGFyYW1zO1xuICAgICAgICAgICAgaWYgKCFwYXJhbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1RvVXBkYXRlID0gdGhpcy5vcHRpb25zLnBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2tpcElmRXhpc3RzIHx8ICFwYXJhbXNUb1VwZGF0ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNUb1VwZGF0ZVtuYW1lXSA9IGludGVycG9sYXRlUGFyYW1zKG5ld1BhcmFtc1tuYW1lXSwgcGFyYW1zVG9VcGRhdGUsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29weU9wdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb2xkUGFyYW1zID0gdGhpcy5vcHRpb25zLnBhcmFtcztcbiAgICAgICAgICAgIGlmIChvbGRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zWydwYXJhbXMnXSA9IHt9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKG9sZFBhcmFtcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW25hbWVdID0gb2xkUGFyYW1zW25hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjcmVhdGVTdWJDb250ZXh0KG9wdGlvbnMgPSBudWxsLCBlbGVtZW50LCBuZXdUaW1lKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gbmV3IEFuaW1hdGlvblRpbWVsaW5lQ29udGV4dCh0aGlzLl9kcml2ZXIsIHRhcmdldCwgdGhpcy5zdWJJbnN0cnVjdGlvbnMsIHRoaXMuX2VudGVyQ2xhc3NOYW1lLCB0aGlzLl9sZWF2ZUNsYXNzTmFtZSwgdGhpcy5lcnJvcnMsIHRoaXMudGltZWxpbmVzLCB0aGlzLmN1cnJlbnRUaW1lbGluZS5mb3JrKHRhcmdldCwgbmV3VGltZSB8fCAwKSk7XG4gICAgICAgIGNvbnRleHQucHJldmlvdXNOb2RlID0gdGhpcy5wcmV2aW91c05vZGU7XG4gICAgICAgIGNvbnRleHQuY3VycmVudEFuaW1hdGVUaW1pbmdzID0gdGhpcy5jdXJyZW50QW5pbWF0ZVRpbWluZ3M7XG4gICAgICAgIGNvbnRleHQub3B0aW9ucyA9IHRoaXMuX2NvcHlPcHRpb25zKCk7XG4gICAgICAgIGNvbnRleHQudXBkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29udGV4dC5jdXJyZW50UXVlcnlJbmRleCA9IHRoaXMuY3VycmVudFF1ZXJ5SW5kZXg7XG4gICAgICAgIGNvbnRleHQuY3VycmVudFF1ZXJ5VG90YWwgPSB0aGlzLmN1cnJlbnRRdWVyeVRvdGFsO1xuICAgICAgICBjb250ZXh0LnBhcmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YkNvbnRleHRDb3VudCsrO1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgdHJhbnNmb3JtSW50b05ld1RpbWVsaW5lKG5ld1RpbWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c05vZGUgPSBERUZBVUxUX05PT1BfUFJFVklPVVNfTk9ERTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUgPSB0aGlzLmN1cnJlbnRUaW1lbGluZS5mb3JrKHRoaXMuZWxlbWVudCwgbmV3VGltZSk7XG4gICAgICAgIHRoaXMudGltZWxpbmVzLnB1c2godGhpcy5jdXJyZW50VGltZWxpbmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGltZWxpbmU7XG4gICAgfVxuICAgIGFwcGVuZEluc3RydWN0aW9uVG9UaW1lbGluZShpbnN0cnVjdGlvbiwgZHVyYXRpb24sIGRlbGF5KSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRUaW1pbmdzID0ge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uICE9IG51bGwgPyBkdXJhdGlvbiA6IGluc3RydWN0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuY3VycmVudFRpbWVsaW5lLmN1cnJlbnRUaW1lICsgKGRlbGF5ICE9IG51bGwgPyBkZWxheSA6IDApICsgaW5zdHJ1Y3Rpb24uZGVsYXksXG4gICAgICAgICAgICBlYXNpbmc6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgU3ViVGltZWxpbmVCdWlsZGVyKHRoaXMuX2RyaXZlciwgaW5zdHJ1Y3Rpb24uZWxlbWVudCwgaW5zdHJ1Y3Rpb24ua2V5ZnJhbWVzLCBpbnN0cnVjdGlvbi5wcmVTdHlsZVByb3BzLCBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcywgdXBkYXRlZFRpbWluZ3MsIGluc3RydWN0aW9uLnN0cmV0Y2hTdGFydGluZ0tleWZyYW1lKTtcbiAgICAgICAgdGhpcy50aW1lbGluZXMucHVzaChidWlsZGVyKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRUaW1pbmdzO1xuICAgIH1cbiAgICBpbmNyZW1lbnRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZWxpbmUuZm9yd2FyZFRpbWUodGhpcy5jdXJyZW50VGltZWxpbmUuZHVyYXRpb24gKyB0aW1lKTtcbiAgICB9XG4gICAgZGVsYXlOZXh0U3RlcChkZWxheSkge1xuICAgICAgICAvLyBuZWdhdGl2ZSBkZWxheXMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWVsaW5lLmRlbGF5TmV4dFN0ZXAoZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZVF1ZXJ5KHNlbGVjdG9yLCBvcmlnaW5hbFNlbGVjdG9yLCBsaW1pdCwgaW5jbHVkZVNlbGYsIG9wdGlvbmFsLCBlcnJvcnMpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IubGVuZ3RoID4gMCkgeyAvLyBvbmx5IGlmIDpzZWxmIGlzIHVzZWQgdGhlbiB0aGUgc2VsZWN0b3IgY2FuIGJlIGVtcHR5XG4gICAgICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoRU5URVJfVE9LRU5fUkVHRVgsICcuJyArIHRoaXMuX2VudGVyQ2xhc3NOYW1lKTtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShMRUFWRV9UT0tFTl9SRUdFWCwgJy4nICsgdGhpcy5fbGVhdmVDbGFzc05hbWUpO1xuICAgICAgICAgICAgY29uc3QgbXVsdGkgPSBsaW1pdCAhPSAxO1xuICAgICAgICAgICAgbGV0IGVsZW1lbnRzID0gdGhpcy5fZHJpdmVyLnF1ZXJ5KHRoaXMuZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gbGltaXQgPCAwID8gZWxlbWVudHMuc2xpY2UoZWxlbWVudHMubGVuZ3RoICsgbGltaXQsIGVsZW1lbnRzLmxlbmd0aCkgOlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5zbGljZSgwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goLi4uZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9uYWwgJiYgcmVzdWx0cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goaW52YWxpZFF1ZXJ5KG9yaWdpbmFsU2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG59XG5jbGFzcyBUaW1lbGluZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKF9kcml2ZXIsIGVsZW1lbnQsIHN0YXJ0VGltZSwgX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cCkge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwID0gX2VsZW1lbnRUaW1lbGluZVN0eWxlc0xvb2t1cDtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuZWFzaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudEtleWZyYW1lID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9rZXlmcmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3N0eWxlU3VtbWFyeSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbG9jYWxUaW1lbGluZVN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYmFja0ZpbGwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFRpbWVsaW5lU3R5bGVzTG9va3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMgPSB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxUaW1lbGluZVN0eWxlcyA9IHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXM7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXAuc2V0KGVsZW1lbnQsIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH1cbiAgICBjb250YWluc0FuaW1hdGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLl9rZXlmcmFtZXMuc2l6ZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDdXJyZW50U3R5bGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0N1cnJlbnRTdHlsZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50S2V5ZnJhbWUuc2l6ZSA+IDA7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRUaW1lICsgdGhpcy5kdXJhdGlvbjtcbiAgICB9XG4gICAgZGVsYXlOZXh0U3RlcChkZWxheSkge1xuICAgICAgICAvLyBpbiB0aGUgZXZlbnQgdGhhdCBhIHN0eWxlKCkgc3RlcCBpcyBwbGFjZWQgcmlnaHQgYmVmb3JlIGEgc3RhZ2dlcigpXG4gICAgICAgIC8vIGFuZCB0aGF0IHN0eWxlKCkgc3RlcCBpcyB0aGUgdmVyeSBmaXJzdCBzdHlsZSgpIHZhbHVlIGluIHRoZSBhbmltYXRpb25cbiAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIG1ha2UgYSBjb3B5IG9mIHRoZSBrZXlmcmFtZSBbMCwgY29weSwgMV0gc28gdGhhdCB0aGUgZGVsYXlcbiAgICAgICAgLy8gcHJvcGVybHkgYXBwbGllcyB0aGUgc3R5bGUoKSB2YWx1ZXMgdG8gd29yayB3aXRoIHRoZSBzdGFnZ2VyLi4uXG4gICAgICAgIGNvbnN0IGhhc1ByZVN0eWxlU3RlcCA9IHRoaXMuX2tleWZyYW1lcy5zaXplID09PSAxICYmIHRoaXMuX3BlbmRpbmdTdHlsZXMuc2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gfHwgaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRUaW1lKHRoaXMuY3VycmVudFRpbWUgKyBkZWxheSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlU3R5bGVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwc2hvdEN1cnJlbnRTdHlsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lICs9IGRlbGF5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmsoZWxlbWVudCwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lbGluZUJ1aWxkZXIodGhpcy5fZHJpdmVyLCBlbGVtZW50LCBjdXJyZW50VGltZSB8fCB0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLl9lbGVtZW50VGltZWxpbmVTdHlsZXNMb29rdXApO1xuICAgIH1cbiAgICBfbG9hZEtleWZyYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0tleWZyYW1lID0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSA9IHRoaXMuX2tleWZyYW1lcy5nZXQodGhpcy5kdXJhdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5fY3VycmVudEtleWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9rZXlmcmFtZXMuc2V0KHRoaXMuZHVyYXRpb24sIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yd2FyZEZyYW1lKCkge1xuICAgICAgICB0aGlzLmR1cmF0aW9uICs9IE9ORV9GUkFNRV9JTl9NSUxMSVNFQ09ORFM7XG4gICAgICAgIHRoaXMuX2xvYWRLZXlmcmFtZSgpO1xuICAgIH1cbiAgICBmb3J3YXJkVGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZXNUb0tleWZyYW1lKCk7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aW1lO1xuICAgICAgICB0aGlzLl9sb2FkS2V5ZnJhbWUoKTtcbiAgICB9XG4gICAgX3VwZGF0ZVN0eWxlKHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMuc2V0KHByb3AsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMuc2V0KHByb3AsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fc3R5bGVTdW1tYXJ5LnNldChwcm9wLCB7IHRpbWU6IHRoaXMuY3VycmVudFRpbWUsIHZhbHVlIH0pO1xuICAgIH1cbiAgICBhbGxvd09ubHlUaW1lbGluZVN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFbXB0eVN0ZXBLZXlmcmFtZSAhPT0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xuICAgIH1cbiAgICBhcHBseUVtcHR5U3RlcChlYXNpbmcpIHtcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNLZXlmcmFtZS5zZXQoJ2Vhc2luZycsIGVhc2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBhbmltYXRlKGR1cmF0aW9uKTpcbiAgICAgICAgLy8gYWxsIG1pc3Npbmcgc3R5bGVzIGFyZSBmaWxsZWQgd2l0aCBhIGAqYCB2YWx1ZSB0aGVuXG4gICAgICAgIC8vIGlmIGFueSBkZXN0aW5hdGlvbiBzdHlsZXMgYXJlIGZpbGxlZCBpbiBsYXRlciBvbiB0aGUgc2FtZVxuICAgICAgICAvLyBrZXlmcmFtZSB0aGVuIHRoZXkgd2lsbCBvdmVycmlkZSB0aGUgb3ZlcnJpZGRlbiBzdHlsZXNcbiAgICAgICAgLy8gV2UgdXNlIGBfZ2xvYmFsVGltZWxpbmVTdHlsZXNgIGhlcmUgYmVjYXVzZSB0aGVyZSBtYXkgYmVcbiAgICAgICAgLy8gc3R5bGVzIGluIHByZXZpb3VzIGtleWZyYW1lcyB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiB0aGlzIHRpbWVsaW5lXG4gICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWx1ZV0gb2YgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tGaWxsLnNldChwcm9wLCB2YWx1ZSB8fCBBVVRPX1NUWUxFKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRLZXlmcmFtZS5zZXQocHJvcCwgQVVUT19TVFlMRSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudEVtcHR5U3RlcEtleWZyYW1lID0gdGhpcy5fY3VycmVudEtleWZyYW1lO1xuICAgIH1cbiAgICBzZXRTdHlsZXMoaW5wdXQsIGVhc2luZywgZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChlYXNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzS2V5ZnJhbWUuc2V0KCdlYXNpbmcnLCBlYXNpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IChvcHRpb25zICYmIG9wdGlvbnMucGFyYW1zKSB8fCB7fTtcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZmxhdHRlblN0eWxlcyhpbnB1dCwgdGhpcy5fZ2xvYmFsVGltZWxpbmVTdHlsZXMpO1xuICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHN0eWxlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gaW50ZXJwb2xhdGVQYXJhbXModmFsdWUsIHBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdHlsZXMuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja0ZpbGwuc2V0KHByb3AsIHRoaXMuX2dsb2JhbFRpbWVsaW5lU3R5bGVzLmdldChwcm9wKSA/PyBBVVRPX1NUWUxFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0eWxlKHByb3AsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlTdHlsZXNUb0tleWZyYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1N0eWxlcy5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3BlbmRpbmdTdHlsZXMuZm9yRWFjaCgodmFsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nU3R5bGVzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMuZm9yRWFjaCgodmFsLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRLZXlmcmFtZS5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50S2V5ZnJhbWUuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzbmFwc2hvdEN1cnJlbnRTdHlsZXMoKSB7XG4gICAgICAgIGZvciAobGV0IFtwcm9wLCB2YWxdIG9mIHRoaXMuX2xvY2FsVGltZWxpbmVTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdHlsZXMuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZShwcm9wLCB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEZpbmFsS2V5ZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlmcmFtZXMuZ2V0KHRoaXMuZHVyYXRpb24pO1xuICAgIH1cbiAgICBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMuX2N1cnJlbnRLZXlmcmFtZSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBtZXJnZVRpbWVsaW5lQ29sbGVjdGVkU3R5bGVzKHRpbWVsaW5lKSB7XG4gICAgICAgIHRpbWVsaW5lLl9zdHlsZVN1bW1hcnkuZm9yRWFjaCgoZGV0YWlsczEsIHByb3ApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMwID0gdGhpcy5fc3R5bGVTdW1tYXJ5LmdldChwcm9wKTtcbiAgICAgICAgICAgIGlmICghZGV0YWlsczAgfHwgZGV0YWlsczEudGltZSA+IGRldGFpbHMwLnRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdHlsZShwcm9wLCBkZXRhaWxzMS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZEtleWZyYW1lcygpIHtcbiAgICAgICAgdGhpcy5hcHBseVN0eWxlc1RvS2V5ZnJhbWUoKTtcbiAgICAgICAgY29uc3QgcHJlU3R5bGVQcm9wcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgcG9zdFN0eWxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLl9rZXlmcmFtZXMuc2l6ZSA9PT0gMSAmJiB0aGlzLmR1cmF0aW9uID09PSAwO1xuICAgICAgICBsZXQgZmluYWxLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fa2V5ZnJhbWVzLmZvckVhY2goKGtleWZyYW1lLCB0aW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEtleWZyYW1lID0gY29weVN0eWxlcyhrZXlmcmFtZSwgbmV3IE1hcCgpLCB0aGlzLl9iYWNrRmlsbCk7XG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lLmZvckVhY2goKHZhbHVlLCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSDJtVBSRV9TVFlMRSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVTdHlsZVByb3BzLmFkZChwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IEFVVE9fU1RZTEUpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdFN0eWxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlmcmFtZS5zZXQoJ29mZnNldCcsIHRpbWUgLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzLnB1c2goZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmVQcm9wcyA9IHByZVN0eWxlUHJvcHMuc2l6ZSA/IGl0ZXJhdG9yVG9BcnJheShwcmVTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICBjb25zdCBwb3N0UHJvcHMgPSBwb3N0U3R5bGVQcm9wcy5zaXplID8gaXRlcmF0b3JUb0FycmF5KHBvc3RTdHlsZVByb3BzLnZhbHVlcygpKSA6IFtdO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIGEgMC1zZWNvbmQgYW5pbWF0aW9uICh3aGljaCBpcyBkZXNpZ25lZCBqdXN0IHRvIHBsYWNlIHN0eWxlcyBvbnNjcmVlbilcbiAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtmMCA9IGZpbmFsS2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgY29uc3Qga2YxID0gbmV3IE1hcChrZjApO1xuICAgICAgICAgICAga2YwLnNldCgnb2Zmc2V0JywgMCk7XG4gICAgICAgICAgICBrZjEuc2V0KCdvZmZzZXQnLCAxKTtcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWVzID0gW2tmMCwga2YxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlVGltZWxpbmVJbnN0cnVjdGlvbih0aGlzLmVsZW1lbnQsIGZpbmFsS2V5ZnJhbWVzLCBwcmVQcm9wcywgcG9zdFByb3BzLCB0aGlzLmR1cmF0aW9uLCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5lYXNpbmcsIGZhbHNlKTtcbiAgICB9XG59XG5jbGFzcyBTdWJUaW1lbGluZUJ1aWxkZXIgZXh0ZW5kcyBUaW1lbGluZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGRyaXZlciwgZWxlbWVudCwga2V5ZnJhbWVzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgdGltaW5ncywgX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoZHJpdmVyLCBlbGVtZW50LCB0aW1pbmdzLmRlbGF5KTtcbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG4gICAgICAgIHRoaXMucHJlU3R5bGVQcm9wcyA9IHByZVN0eWxlUHJvcHM7XG4gICAgICAgIHRoaXMucG9zdFN0eWxlUHJvcHMgPSBwb3N0U3R5bGVQcm9wcztcbiAgICAgICAgdGhpcy5fc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWUgPSBfc3RyZXRjaFN0YXJ0aW5nS2V5ZnJhbWU7XG4gICAgICAgIHRoaXMudGltaW5ncyA9IHsgZHVyYXRpb246IHRpbWluZ3MuZHVyYXRpb24sIGRlbGF5OiB0aW1pbmdzLmRlbGF5LCBlYXNpbmc6IHRpbWluZ3MuZWFzaW5nIH07XG4gICAgfVxuICAgIGNvbnRhaW5zQW5pbWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlmcmFtZXMubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgYnVpbGRLZXlmcmFtZXMoKSB7XG4gICAgICAgIGxldCBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgICAgbGV0IHsgZGVsYXksIGR1cmF0aW9uLCBlYXNpbmcgfSA9IHRoaXMudGltaW5ncztcbiAgICAgICAgaWYgKHRoaXMuX3N0cmV0Y2hTdGFydGluZ0tleWZyYW1lICYmIGRlbGF5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGR1cmF0aW9uICsgZGVsYXk7XG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ0dhcCA9IGRlbGF5IC8gdG90YWxUaW1lO1xuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN0YXJ0aW5nIGtleWZyYW1lIG5vdyBzdGFydHMgb25jZSB0aGUgZGVsYXkgaXMgZG9uZVxuICAgICAgICAgICAgY29uc3QgbmV3Rmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdKTtcbiAgICAgICAgICAgIG5ld0ZpcnN0S2V5ZnJhbWUuc2V0KCdvZmZzZXQnLCAwKTtcbiAgICAgICAgICAgIG5ld0tleWZyYW1lcy5wdXNoKG5ld0ZpcnN0S2V5ZnJhbWUpO1xuICAgICAgICAgICAgY29uc3Qgb2xkRmlyc3RLZXlmcmFtZSA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzWzBdKTtcbiAgICAgICAgICAgIG9sZEZpcnN0S2V5ZnJhbWUuc2V0KCdvZmZzZXQnLCByb3VuZE9mZnNldChzdGFydGluZ0dhcCkpO1xuICAgICAgICAgICAgbmV3S2V5ZnJhbWVzLnB1c2gob2xkRmlyc3RLZXlmcmFtZSk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBXaGVuIHRoZSBrZXlmcmFtZSBpcyBzdHJldGNoZWQgdGhlbiBpdCBtZWFucyB0aGF0IHRoZSBkZWxheSBiZWZvcmUgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICBzdGFydHMgaXMgZ29uZS4gSW5zdGVhZCB0aGUgZmlyc3Qga2V5ZnJhbWUgaXMgcGxhY2VkIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIGFuZCBpdCBpcyB0aGVuIGNvcGllZCB0byB3aGVyZSBpdCBzdGFydHMgd2hlbiB0aGUgb3JpZ2luYWwgZGVsYXkgaXMgb3Zlci4gVGhpcyBiYXNpY2FsbHlcbiAgICAgICAgICAgICAgbWVhbnMgbm90aGluZyBhbmltYXRlcyBkdXJpbmcgdGhhdCBkZWxheSwgYnV0IHRoZSBzdHlsZXMgYXJlIHN0aWxsIHJlbmRlcmVkLiBGb3IgdGhpc1xuICAgICAgICAgICAgICB0byB3b3JrIHRoZSBvcmlnaW5hbCBvZmZzZXQgdmFsdWVzIHRoYXQgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGtleWZyYW1lcyBtdXN0IGJlIFwid2FycGVkXCJcbiAgICAgICAgICAgICAgc28gdGhhdCB0aGV5IGNhbiB0YWtlIHRoZSBuZXcga2V5ZnJhbWUgKyBkZWxheSBpbnRvIGFjY291bnQuXG4gICAgICBcbiAgICAgICAgICAgICAgZGVsYXk9MTAwMCwgZHVyYXRpb249MTAwMCwga2V5ZnJhbWVzID0gMCAuNSAxXG4gICAgICBcbiAgICAgICAgICAgICAgdHVybnMgaW50b1xuICAgICAgXG4gICAgICAgICAgICAgIGRlbGF5PTAsIGR1cmF0aW9uPTIwMDAsIGtleWZyYW1lcyA9IDAgLjMzIC42NiAxXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIG9mZnNldHMgYmV0d2VlbiAxIC4uLiBuIC0xIGFyZSBhbGwgd2FycGVkIGJ5IHRoZSBrZXlmcmFtZSBzdHJldGNoXG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGltaXQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBrZiA9IGNvcHlTdHlsZXMoa2V5ZnJhbWVzW2ldKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRPZmZzZXQgPSBrZi5nZXQoJ29mZnNldCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVBdEtleWZyYW1lID0gZGVsYXkgKyBvbGRPZmZzZXQgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBrZi5zZXQoJ29mZnNldCcsIHJvdW5kT2Zmc2V0KHRpbWVBdEtleWZyYW1lIC8gdG90YWxUaW1lKSk7XG4gICAgICAgICAgICAgICAgbmV3S2V5ZnJhbWVzLnB1c2goa2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGFydGluZyBrZXlmcmFtZSBzaG91bGQgYmUgYWRkZWQgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRvdGFsVGltZTtcbiAgICAgICAgICAgIGRlbGF5ID0gMDtcbiAgICAgICAgICAgIGVhc2luZyA9ICcnO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0gbmV3S2V5ZnJhbWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVUaW1lbGluZUluc3RydWN0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLnByZVN0eWxlUHJvcHMsIHRoaXMucG9zdFN0eWxlUHJvcHMsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCB0cnVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiByb3VuZE9mZnNldChvZmZzZXQsIGRlY2ltYWxQb2ludHMgPSAzKSB7XG4gICAgY29uc3QgbXVsdCA9IE1hdGgucG93KDEwLCBkZWNpbWFsUG9pbnRzIC0gMSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0ICogbXVsdCkgLyBtdWx0O1xufVxuZnVuY3Rpb24gZmxhdHRlblN0eWxlcyhpbnB1dCwgYWxsU3R5bGVzKSB7XG4gICAgY29uc3Qgc3R5bGVzID0gbmV3IE1hcCgpO1xuICAgIGxldCBhbGxQcm9wZXJ0aWVzO1xuICAgIGlucHV0LmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICBpZiAodG9rZW4gPT09ICcqJykge1xuICAgICAgICAgICAgYWxsUHJvcGVydGllcyA9IGFsbFByb3BlcnRpZXMgfHwgYWxsU3R5bGVzLmtleXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3Agb2YgYWxsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5zZXQocHJvcCwgQVVUT19TVFlMRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb3B5U3R5bGVzKHRva2VuLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0eWxlcztcbn1cblxuY2xhc3MgQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihfZHJpdmVyLCBpbnB1dCkge1xuICAgICAgICB0aGlzLl9kcml2ZXIgPSBfZHJpdmVyO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICAgICAgY29uc3QgYXN0ID0gYnVpbGRBbmltYXRpb25Bc3QoX2RyaXZlciwgaW5wdXQsIGVycm9ycywgd2FybmluZ3MpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgdmFsaWRhdGlvbkZhaWxlZChlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdhcm5WYWxpZGF0aW9uKHdhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbmltYXRpb25Bc3QgPSBhc3Q7XG4gICAgfVxuICAgIGJ1aWxkVGltZWxpbmVzKGVsZW1lbnQsIHN0YXJ0aW5nU3R5bGVzLCBkZXN0aW5hdGlvblN0eWxlcywgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gQXJyYXkuaXNBcnJheShzdGFydGluZ1N0eWxlcykgPyBub3JtYWxpemVTdHlsZXMoc3RhcnRpbmdTdHlsZXMpIDpcbiAgICAgICAgICAgIHN0YXJ0aW5nU3R5bGVzO1xuICAgICAgICBjb25zdCBkZXN0ID0gQXJyYXkuaXNBcnJheShkZXN0aW5hdGlvblN0eWxlcykgPyBub3JtYWxpemVTdHlsZXMoZGVzdGluYXRpb25TdHlsZXMpIDpcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uU3R5bGVzO1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgc3ViSW5zdHJ1Y3Rpb25zID0gc3ViSW5zdHJ1Y3Rpb25zIHx8IG5ldyBFbGVtZW50SW5zdHJ1Y3Rpb25NYXAoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYnVpbGRBbmltYXRpb25UaW1lbGluZXModGhpcy5fZHJpdmVyLCBlbGVtZW50LCB0aGlzLl9hbmltYXRpb25Bc3QsIEVOVEVSX0NMQVNTTkFNRSwgTEVBVkVfQ0xBU1NOQU1FLCBzdGFydCwgZGVzdCwgb3B0aW9ucywgc3ViSW5zdHJ1Y3Rpb25zLCBlcnJvcnMpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgYnVpbGRpbmdGYWlsZWQoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciB7XG59XG4vKipcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciB7XG4gICAgbm9ybWFsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eU5hbWU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVN0eWxlVmFsdWUodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5jb25zdCBESU1FTlNJT05BTF9QUk9QX1NFVCA9IG5ldyBTZXQoW1xuICAgICd3aWR0aCcsXG4gICAgJ2hlaWdodCcsXG4gICAgJ21pbldpZHRoJyxcbiAgICAnbWluSGVpZ2h0JyxcbiAgICAnbWF4V2lkdGgnLFxuICAgICdtYXhIZWlnaHQnLFxuICAgICdsZWZ0JyxcbiAgICAndG9wJyxcbiAgICAnYm90dG9tJyxcbiAgICAncmlnaHQnLFxuICAgICdmb250U2l6ZScsXG4gICAgJ291dGxpbmVXaWR0aCcsXG4gICAgJ291dGxpbmVPZmZzZXQnLFxuICAgICdwYWRkaW5nVG9wJyxcbiAgICAncGFkZGluZ0xlZnQnLFxuICAgICdwYWRkaW5nQm90dG9tJyxcbiAgICAncGFkZGluZ1JpZ2h0JyxcbiAgICAnbWFyZ2luVG9wJyxcbiAgICAnbWFyZ2luTGVmdCcsXG4gICAgJ21hcmdpbkJvdHRvbScsXG4gICAgJ21hcmdpblJpZ2h0JyxcbiAgICAnYm9yZGVyUmFkaXVzJyxcbiAgICAnYm9yZGVyV2lkdGgnLFxuICAgICdib3JkZXJUb3BXaWR0aCcsXG4gICAgJ2JvcmRlckxlZnRXaWR0aCcsXG4gICAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAgICdib3JkZXJCb3R0b21XaWR0aCcsXG4gICAgJ3RleHRJbmRlbnQnLFxuICAgICdwZXJzcGVjdGl2ZSdcbl0pO1xuY2xhc3MgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciBleHRlbmRzIEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciB7XG4gICAgbm9ybWFsaXplUHJvcGVydHlOYW1lKHByb3BlcnR5TmFtZSwgZXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBkYXNoQ2FzZVRvQ2FtZWxDYXNlKHByb3BlcnR5TmFtZSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVN0eWxlVmFsdWUodXNlclByb3ZpZGVkUHJvcGVydHksIG5vcm1hbGl6ZWRQcm9wZXJ0eSwgdmFsdWUsIGVycm9ycykge1xuICAgICAgICBsZXQgdW5pdCA9ICcnO1xuICAgICAgICBjb25zdCBzdHJWYWwgPSB2YWx1ZS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgaWYgKERJTUVOU0lPTkFMX1BST1BfU0VULmhhcyhub3JtYWxpemVkUHJvcGVydHkpICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSAnMCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxBbmRTdWZmaXhNYXRjaCA9IHZhbHVlLm1hdGNoKC9eWystXT9bXFxkXFwuXSsoW2Etel0qKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsQW5kU3VmZml4TWF0Y2ggJiYgdmFsQW5kU3VmZml4TWF0Y2hbMV0ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goaW52YWxpZENzc1VuaXRWYWx1ZSh1c2VyUHJvdmlkZWRQcm9wZXJ0eSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0clZhbCArIHVuaXQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdHJpZ2dlck5hbWUsIGZyb21TdGF0ZSwgdG9TdGF0ZSwgaXNSZW1vdmFsVHJhbnNpdGlvbiwgZnJvbVN0eWxlcywgdG9TdHlsZXMsIHRpbWVsaW5lcywgcXVlcmllZEVsZW1lbnRzLCBwcmVTdHlsZVByb3BzLCBwb3N0U3R5bGVQcm9wcywgdG90YWxUaW1lLCBlcnJvcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwIC8qIEFuaW1hdGlvblRyYW5zaXRpb25JbnN0cnVjdGlvblR5cGUuVHJhbnNpdGlvbkFuaW1hdGlvbiAqLyxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgdHJpZ2dlck5hbWUsXG4gICAgICAgIGlzUmVtb3ZhbFRyYW5zaXRpb24sXG4gICAgICAgIGZyb21TdGF0ZSxcbiAgICAgICAgZnJvbVN0eWxlcyxcbiAgICAgICAgdG9TdGF0ZSxcbiAgICAgICAgdG9TdHlsZXMsXG4gICAgICAgIHRpbWVsaW5lcyxcbiAgICAgICAgcXVlcmllZEVsZW1lbnRzLFxuICAgICAgICBwcmVTdHlsZVByb3BzLFxuICAgICAgICBwb3N0U3R5bGVQcm9wcyxcbiAgICAgICAgdG90YWxUaW1lLFxuICAgICAgICBlcnJvcnNcbiAgICB9O1xufVxuXG5jb25zdCBFTVBUWV9PQkpFQ1QgPSB7fTtcbmNsYXNzIEFuaW1hdGlvblRyYW5zaXRpb25GYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihfdHJpZ2dlck5hbWUsIGFzdCwgX3N0YXRlU3R5bGVzKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJOYW1lID0gX3RyaWdnZXJOYW1lO1xuICAgICAgICB0aGlzLmFzdCA9IGFzdDtcbiAgICAgICAgdGhpcy5fc3RhdGVTdHlsZXMgPSBfc3RhdGVTdHlsZXM7XG4gICAgfVxuICAgIG1hdGNoKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBlbGVtZW50LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG9uZU9yTW9yZVRyYW5zaXRpb25zTWF0Y2godGhpcy5hc3QubWF0Y2hlcnMsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBlbGVtZW50LCBwYXJhbXMpO1xuICAgIH1cbiAgICBidWlsZFN0eWxlcyhzdGF0ZU5hbWUsIHBhcmFtcywgZXJyb3JzKSB7XG4gICAgICAgIGxldCBzdHlsZXIgPSB0aGlzLl9zdGF0ZVN0eWxlcy5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXRlTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHlsZXIgPSB0aGlzLl9zdGF0ZVN0eWxlcy5nZXQoc3RhdGVOYW1lPy50b1N0cmluZygpKSB8fCBzdHlsZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0eWxlciA/IHN0eWxlci5idWlsZFN0eWxlcyhwYXJhbXMsIGVycm9ycykgOiBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGJ1aWxkKGRyaXZlciwgZWxlbWVudCwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgY3VycmVudE9wdGlvbnMsIG5leHRPcHRpb25zLCBzdWJJbnN0cnVjdGlvbnMsIHNraXBBc3RCdWlsZCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbkFuaW1hdGlvblBhcmFtcyA9IHRoaXMuYXN0Lm9wdGlvbnMgJiYgdGhpcy5hc3Qub3B0aW9ucy5wYXJhbXMgfHwgRU1QVFlfT0JKRUNUO1xuICAgICAgICBjb25zdCBjdXJyZW50QW5pbWF0aW9uUGFyYW1zID0gY3VycmVudE9wdGlvbnMgJiYgY3VycmVudE9wdGlvbnMucGFyYW1zIHx8IEVNUFRZX09CSkVDVDtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlU3R5bGVzID0gdGhpcy5idWlsZFN0eWxlcyhjdXJyZW50U3RhdGUsIGN1cnJlbnRBbmltYXRpb25QYXJhbXMsIGVycm9ycyk7XG4gICAgICAgIGNvbnN0IG5leHRBbmltYXRpb25QYXJhbXMgPSBuZXh0T3B0aW9ucyAmJiBuZXh0T3B0aW9ucy5wYXJhbXMgfHwgRU1QVFlfT0JKRUNUO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGVTdHlsZXMgPSB0aGlzLmJ1aWxkU3R5bGVzKG5leHRTdGF0ZSwgbmV4dEFuaW1hdGlvblBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgY29uc3QgcXVlcmllZEVsZW1lbnRzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBwcmVTdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgcG9zdFN0eWxlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBpc1JlbW92YWwgPSBuZXh0U3RhdGUgPT09ICd2b2lkJztcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcmFtczogYXBwbHlQYXJhbURlZmF1bHRzKG5leHRBbmltYXRpb25QYXJhbXMsIHRyYW5zaXRpb25BbmltYXRpb25QYXJhbXMpLFxuICAgICAgICAgICAgZGVsYXk6IHRoaXMuYXN0Lm9wdGlvbnM/LmRlbGF5LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0aW1lbGluZXMgPSBza2lwQXN0QnVpbGQgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgYnVpbGRBbmltYXRpb25UaW1lbGluZXMoZHJpdmVyLCBlbGVtZW50LCB0aGlzLmFzdC5hbmltYXRpb24sIGVudGVyQ2xhc3NOYW1lLCBsZWF2ZUNsYXNzTmFtZSwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIGFuaW1hdGlvbk9wdGlvbnMsIHN1Ykluc3RydWN0aW9ucywgZXJyb3JzKTtcbiAgICAgICAgbGV0IHRvdGFsVGltZSA9IDA7XG4gICAgICAgIHRpbWVsaW5lcy5mb3JFYWNoKHRsID0+IHtcbiAgICAgICAgICAgIHRvdGFsVGltZSA9IE1hdGgubWF4KHRsLmR1cmF0aW9uICsgdGwuZGVsYXksIHRvdGFsVGltZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zaXRpb25JbnN0cnVjdGlvbihlbGVtZW50LCB0aGlzLl90cmlnZ2VyTmFtZSwgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGlzUmVtb3ZhbCwgY3VycmVudFN0YXRlU3R5bGVzLCBuZXh0U3RhdGVTdHlsZXMsIFtdLCBbXSwgcHJlU3R5bGVNYXAsIHBvc3RTdHlsZU1hcCwgdG90YWxUaW1lLCBlcnJvcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVsaW5lcy5mb3JFYWNoKHRsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IHRsLmVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBwcmVQcm9wcyA9IGdldE9yU2V0RGVmYXVsdFZhbHVlKHByZVN0eWxlTWFwLCBlbG0sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICB0bC5wcmVTdHlsZVByb3BzLmZvckVhY2gocHJvcCA9PiBwcmVQcm9wcy5hZGQocHJvcCkpO1xuICAgICAgICAgICAgY29uc3QgcG9zdFByb3BzID0gZ2V0T3JTZXREZWZhdWx0VmFsdWUocG9zdFN0eWxlTWFwLCBlbG0sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICB0bC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKHByb3AgPT4gcG9zdFByb3BzLmFkZChwcm9wKSk7XG4gICAgICAgICAgICBpZiAoZWxtICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcXVlcmllZEVsZW1lbnRzLmFkZChlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgY2hlY2tOb25BbmltYXRhYmxlSW5UaW1lbGluZXModGltZWxpbmVzLCB0aGlzLl90cmlnZ2VyTmFtZSwgZHJpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVkRWxlbWVudHNMaXN0ID0gaXRlcmF0b3JUb0FycmF5KHF1ZXJpZWRFbGVtZW50cy52YWx1ZXMoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudCwgdGhpcy5fdHJpZ2dlck5hbWUsIGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBpc1JlbW92YWwsIGN1cnJlbnRTdGF0ZVN0eWxlcywgbmV4dFN0YXRlU3R5bGVzLCB0aW1lbGluZXMsIHF1ZXJpZWRFbGVtZW50c0xpc3QsIHByZVN0eWxlTWFwLCBwb3N0U3R5bGVNYXAsIHRvdGFsVGltZSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaW5zaWRlIGEgc2V0IG9mIHRpbWVsaW5lcyBpZiB0aGV5IHRyeSB0byBhbmltYXRlIGEgY3NzIHByb3BlcnR5IHdoaWNoIGlzIG5vdCBjb25zaWRlcmVkXG4gKiBhbmltYXRhYmxlLCBpbiB0aGF0IGNhc2UgaXQgcHJpbnRzIGEgd2FybmluZyBvbiB0aGUgY29uc29sZS5cbiAqIEJlc2lkZXMgdGhhdCB0aGUgZnVuY3Rpb24gZG9lc24ndCBoYXZlIGFueSBvdGhlciBlZmZlY3QuXG4gKlxuICogTm90ZTogdGhpcyBjaGVjayBpcyBkb25lIGhlcmUgYWZ0ZXIgdGhlIHRpbWVsaW5lcyBhcmUgYnVpbHQgaW5zdGVhZCBvZiBkb2luZyBvbiBhIGxvd2VyIGxldmVsIHNvXG4gKiB0aGF0IHdlIGNhbiBtYWtlIHN1cmUgdGhhdCB0aGUgd2FybmluZyBhcHBlYXJzIG9ubHkgb25jZSBwZXIgaW5zdHJ1Y3Rpb24gKHdlIGNhbiBhZ2dyZWdhdGUgaGVyZVxuICogYWxsIHRoZSBpc3N1ZXMgaW5zdGVhZCBvZiBmaW5kaW5nIHRoZW0gc2VwYXJhdGVseSkuXG4gKlxuICogQHBhcmFtIHRpbWVsaW5lcyBUaGUgYnVpbHQgdGltZWxpbmVzIGZvciB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAqIEBwYXJhbSB0cmlnZ2VyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdHJpZ2dlciBmb3IgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24uXG4gKiBAcGFyYW0gZHJpdmVyIEFuaW1hdGlvbiBkcml2ZXIgdXNlZCB0byBwZXJmb3JtIHRoZSBjaGVjay5cbiAqXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTm9uQW5pbWF0YWJsZUluVGltZWxpbmVzKHRpbWVsaW5lcywgdHJpZ2dlck5hbWUsIGRyaXZlcikge1xuICAgIGlmICghZHJpdmVyLnZhbGlkYXRlQW5pbWF0YWJsZVN0eWxlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd2VkTm9uQW5pbWF0YWJsZVByb3BzID0gbmV3IFNldChbXG4gICAgICAgIC8vICdlYXNpbmcnIGlzIGEgdXRpbGl0eS9zeW50aGV0aWMgcHJvcCB3ZSB1c2UgdG8gcmVwcmVzZW50XG4gICAgICAgIC8vIGVhc2luZyBmdW5jdGlvbnMsIGl0IHJlcHJlc2VudHMgYSBwcm9wZXJ0eSBvZiB0aGUgYW5pbWF0aW9uXG4gICAgICAgIC8vIHdoaWNoIGlzIG5vdCBhbmltYXRhYmxlIGJ1dCBkaWZmZXJlbnQgdmFsdWVzIGNhbiBiZSB1c2VkXG4gICAgICAgIC8vIGluIGRpZmZlcmVudCBzdGVwc1xuICAgICAgICAnZWFzaW5nJ1xuICAgIF0pO1xuICAgIGNvbnN0IGludmFsaWROb25BbmltYXRhYmxlUHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgdGltZWxpbmVzLmZvckVhY2goKHsga2V5ZnJhbWVzIH0pID0+IHtcbiAgICAgICAgY29uc3Qgbm9uQW5pbWF0YWJsZVByb3BzSW5pdGlhbFZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goa2V5ZnJhbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW50cmllc1RvQ2hlY2sgPSBBcnJheS5mcm9tKGtleWZyYW1lLmVudHJpZXMoKSkuZmlsdGVyKChbcHJvcF0pID0+ICFhbGxvd2VkTm9uQW5pbWF0YWJsZVByb3BzLmhhcyhwcm9wKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm9wLCB2YWx1ZV0gb2YgZW50cmllc1RvQ2hlY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRyaXZlci52YWxpZGF0ZUFuaW1hdGFibGVTdHlsZVByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub25BbmltYXRhYmxlUHJvcHNJbml0aWFsVmFsdWVzLmhhcyhwcm9wKSAmJiAhaW52YWxpZE5vbkFuaW1hdGFibGVQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BJbml0aWFsVmFsdWUgPSBub25BbmltYXRhYmxlUHJvcHNJbml0aWFsVmFsdWVzLmdldChwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wSW5pdGlhbFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWROb25BbmltYXRhYmxlUHJvcHMuYWRkKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9uQW5pbWF0YWJsZVByb3BzSW5pdGlhbFZhbHVlcy5zZXQocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoaW52YWxpZE5vbkFuaW1hdGFibGVQcm9wcy5zaXplID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IFRoZSBhbmltYXRpb24gdHJpZ2dlciBcIiR7dHJpZ2dlck5hbWV9XCIgaXMgYXR0ZW1wdGluZyB0byBhbmltYXRlIHRoZSBmb2xsb3dpbmdgICtcbiAgICAgICAgICAgICcgbm90IGFuaW1hdGFibGUgcHJvcGVydGllczogJyArIEFycmF5LmZyb20oaW52YWxpZE5vbkFuaW1hdGFibGVQcm9wcykuam9pbignLCAnKSArICdcXG4nICtcbiAgICAgICAgICAgICcodG8gY2hlY2sgdGhlIGxpc3Qgb2YgYWxsIGFuaW1hdGFibGUgcHJvcGVydGllcyB2aXNpdCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX2FuaW1hdGVkX3Byb3BlcnRpZXMpJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gb25lT3JNb3JlVHJhbnNpdGlvbnNNYXRjaChtYXRjaEZucywgY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGVsZW1lbnQsIHBhcmFtcykge1xuICAgIHJldHVybiBtYXRjaEZucy5zb21lKGZuID0+IGZuKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBlbGVtZW50LCBwYXJhbXMpKTtcbn1cbmZ1bmN0aW9uIGFwcGx5UGFyYW1EZWZhdWx0cyh1c2VyUGFyYW1zLCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGNvcHlPYmooZGVmYXVsdHMpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHVzZXJQYXJhbXMpIHtcbiAgICAgICAgaWYgKHVzZXJQYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB1c2VyUGFyYW1zW2tleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB1c2VyUGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEFuaW1hdGlvblN0YXRlU3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZXMsIGRlZmF1bHRQYXJhbXMsIG5vcm1hbGl6ZXIpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuZGVmYXVsdFBhcmFtcyA9IGRlZmF1bHRQYXJhbXM7XG4gICAgICAgIHRoaXMubm9ybWFsaXplciA9IG5vcm1hbGl6ZXI7XG4gICAgfVxuICAgIGJ1aWxkU3R5bGVzKHBhcmFtcywgZXJyb3JzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsU3R5bGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjb21iaW5lZFBhcmFtcyA9IGNvcHlPYmoodGhpcy5kZWZhdWx0UGFyYW1zKTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29tYmluZWRQYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHlsZXMuc3R5bGVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2YWwsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gaW50ZXJwb2xhdGVQYXJhbXModmFsLCBjb21iaW5lZFBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemVkUHJvcCA9IHRoaXMubm9ybWFsaXplci5ub3JtYWxpemVQcm9wZXJ0eU5hbWUocHJvcCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdGhpcy5ub3JtYWxpemVyLm5vcm1hbGl6ZVN0eWxlVmFsdWUocHJvcCwgbm9ybWFsaXplZFByb3AsIHZhbCwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTdHlsZXMuc2V0KHByb3AsIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmluYWxTdHlsZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFRyaWdnZXIobmFtZSwgYXN0LCBub3JtYWxpemVyKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UcmlnZ2VyKG5hbWUsIGFzdCwgbm9ybWFsaXplcik7XG59XG5jbGFzcyBBbmltYXRpb25UcmlnZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhc3QsIF9ub3JtYWxpemVyKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXN0ID0gYXN0O1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVyID0gX25vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkZhY3RvcmllcyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgYXN0LnN0YXRlcy5mb3JFYWNoKGFzdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UGFyYW1zID0gKGFzdC5vcHRpb25zICYmIGFzdC5vcHRpb25zLnBhcmFtcykgfHwge307XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5zZXQoYXN0Lm5hbWUsIG5ldyBBbmltYXRpb25TdGF0ZVN0eWxlcyhhc3Quc3R5bGUsIGRlZmF1bHRQYXJhbXMsIF9ub3JtYWxpemVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBiYWxhbmNlUHJvcGVydGllcyh0aGlzLnN0YXRlcywgJ3RydWUnLCAnMScpO1xuICAgICAgICBiYWxhbmNlUHJvcGVydGllcyh0aGlzLnN0YXRlcywgJ2ZhbHNlJywgJzAnKTtcbiAgICAgICAgYXN0LnRyYW5zaXRpb25zLmZvckVhY2goYXN0ID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbkZhY3Rvcmllcy5wdXNoKG5ldyBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeShuYW1lLCBhc3QsIHRoaXMuc3RhdGVzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZhbGxiYWNrVHJhbnNpdGlvbiA9IGNyZWF0ZUZhbGxiYWNrVHJhbnNpdGlvbihuYW1lLCB0aGlzLnN0YXRlcywgdGhpcy5fbm9ybWFsaXplcik7XG4gICAgfVxuICAgIGdldCBjb250YWluc1F1ZXJpZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzdC5xdWVyeUNvdW50ID4gMDtcbiAgICB9XG4gICAgbWF0Y2hUcmFuc2l0aW9uKGN1cnJlbnRTdGF0ZSwgbmV4dFN0YXRlLCBlbGVtZW50LCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLnRyYW5zaXRpb25GYWN0b3JpZXMuZmluZChmID0+IGYubWF0Y2goY3VycmVudFN0YXRlLCBuZXh0U3RhdGUsIGVsZW1lbnQsIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gZW50cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgbWF0Y2hTdHlsZXMoY3VycmVudFN0YXRlLCBwYXJhbXMsIGVycm9ycykge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWxsYmFja1RyYW5zaXRpb24uYnVpbGRTdHlsZXMoY3VycmVudFN0YXRlLCBwYXJhbXMsIGVycm9ycyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRmFsbGJhY2tUcmFuc2l0aW9uKHRyaWdnZXJOYW1lLCBzdGF0ZXMsIG5vcm1hbGl6ZXIpIHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFsoZnJvbVN0YXRlLCB0b1N0YXRlKSA9PiB0cnVlXTtcbiAgICBjb25zdCBhbmltYXRpb24gPSB7IHR5cGU6IDIgLyogQW5pbWF0aW9uTWV0YWRhdGFUeXBlLlNlcXVlbmNlICovLCBzdGVwczogW10sIG9wdGlvbnM6IG51bGwgfTtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0ge1xuICAgICAgICB0eXBlOiAxIC8qIEFuaW1hdGlvbk1ldGFkYXRhVHlwZS5UcmFuc2l0aW9uICovLFxuICAgICAgICBhbmltYXRpb24sXG4gICAgICAgIG1hdGNoZXJzLFxuICAgICAgICBvcHRpb25zOiBudWxsLFxuICAgICAgICBxdWVyeUNvdW50OiAwLFxuICAgICAgICBkZXBDb3VudDogMFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25UcmFuc2l0aW9uRmFjdG9yeSh0cmlnZ2VyTmFtZSwgdHJhbnNpdGlvbiwgc3RhdGVzKTtcbn1cbmZ1bmN0aW9uIGJhbGFuY2VQcm9wZXJ0aWVzKHN0YXRlTWFwLCBrZXkxLCBrZXkyKSB7XG4gICAgaWYgKHN0YXRlTWFwLmhhcyhrZXkxKSkge1xuICAgICAgICBpZiAoIXN0YXRlTWFwLmhhcyhrZXkyKSkge1xuICAgICAgICAgICAgc3RhdGVNYXAuc2V0KGtleTIsIHN0YXRlTWFwLmdldChrZXkxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVNYXAuaGFzKGtleTIpKSB7XG4gICAgICAgIHN0YXRlTWFwLnNldChrZXkxLCBzdGF0ZU1hcC5nZXQoa2V5MikpO1xuICAgIH1cbn1cblxuY29uc3QgRU1QVFlfSU5TVFJVQ1RJT05fTUFQID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuY2xhc3MgVGltZWxpbmVBbmltYXRpb25FbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKGJvZHlOb2RlLCBfZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmJvZHlOb2RlID0gYm9keU5vZGU7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcGxheWVyc0J5SWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xuICAgIH1cbiAgICByZWdpc3RlcihpZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgICAgIGNvbnN0IGFzdCA9IGJ1aWxkQW5pbWF0aW9uQXN0KHRoaXMuX2RyaXZlciwgbWV0YWRhdGEsIGVycm9ycywgd2FybmluZ3MpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgcmVnaXN0ZXJGYWlsZWQoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3YXJuaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3YXJuUmVnaXN0ZXIod2FybmluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9ucy5zZXQoaWQsIGFzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkUGxheWVyKGksIHByZVN0eWxlcywgcG9zdFN0eWxlcykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaS5lbGVtZW50O1xuICAgICAgICBjb25zdCBrZXlmcmFtZXMgPSBub3JtYWxpemVLZXlmcmFtZXMkMSh0aGlzLl9kcml2ZXIsIHRoaXMuX25vcm1hbGl6ZXIsIGVsZW1lbnQsIGkua2V5ZnJhbWVzLCBwcmVTdHlsZXMsIHBvc3RTdHlsZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyLmFuaW1hdGUoZWxlbWVudCwga2V5ZnJhbWVzLCBpLmR1cmF0aW9uLCBpLmRlbGF5LCBpLmVhc2luZywgW10sIHRydWUpO1xuICAgIH1cbiAgICBjcmVhdGUoaWQsIGVsZW1lbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fYW5pbWF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBsZXQgaW5zdHJ1Y3Rpb25zO1xuICAgICAgICBjb25zdCBhdXRvU3R5bGVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoYXN0KSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBidWlsZEFuaW1hdGlvblRpbWVsaW5lcyh0aGlzLl9kcml2ZXIsIGVsZW1lbnQsIGFzdCwgRU5URVJfQ0xBU1NOQU1FLCBMRUFWRV9DTEFTU05BTUUsIG5ldyBNYXAoKSwgbmV3IE1hcCgpLCBvcHRpb25zLCBFTVBUWV9JTlNUUlVDVElPTl9NQVAsIGVycm9ycyk7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRPclNldERlZmF1bHRWYWx1ZShhdXRvU3R5bGVzTWFwLCBpbnN0LmVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgICAgICAgICAgICAgaW5zdC5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKHByb3AgPT4gc3R5bGVzLnNldChwcm9wLCBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKG1pc3NpbmdPckRlc3Ryb3llZEFuaW1hdGlvbigpKTtcbiAgICAgICAgICAgIGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVBbmltYXRpb25GYWlsZWQoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBhdXRvU3R5bGVzTWFwLmZvckVhY2goKHN0eWxlcywgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgc3R5bGVzLmZvckVhY2goKF8sIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBzdHlsZXMuc2V0KHByb3AsIHRoaXMuX2RyaXZlci5jb21wdXRlU3R5bGUoZWxlbWVudCwgcHJvcCwgQVVUT19TVFlMRSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwbGF5ZXJzID0gaW5zdHJ1Y3Rpb25zLm1hcChpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IGF1dG9TdHlsZXNNYXAuZ2V0KGkuZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRQbGF5ZXIoaSwgbmV3IE1hcCgpLCBzdHlsZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGxheWVyID0gb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKTtcbiAgICAgICAgdGhpcy5fcGxheWVyc0J5SWQuc2V0KGlkLCBwbGF5ZXIpO1xuICAgICAgICBwbGF5ZXIub25EZXN0cm95KCgpID0+IHRoaXMuZGVzdHJveShpZCkpO1xuICAgICAgICB0aGlzLnBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH1cbiAgICBkZXN0cm95KGlkKSB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuX2dldFBsYXllcihpZCk7XG4gICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3BsYXllcnNCeUlkLmRlbGV0ZShpZCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRQbGF5ZXIoaWQpIHtcbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5fcGxheWVyc0J5SWQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFwbGF5ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG1pc3NpbmdQbGF5ZXIoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgfVxuICAgIGxpc3RlbihpZCwgZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICAvLyB0cmlnZ2VyTmFtZSwgZnJvbVN0YXRlLCB0b1N0YXRlIGFyZSBhbGwgaWdub3JlZCBmb3IgdGltZWxpbmUgYW5pbWF0aW9uc1xuICAgICAgICBjb25zdCBiYXNlRXZlbnQgPSBtYWtlQW5pbWF0aW9uRXZlbnQoZWxlbWVudCwgJycsICcnLCAnJyk7XG4gICAgICAgIGxpc3Rlbk9uUGxheWVyKHRoaXMuX2dldFBsYXllcihpZCksIGV2ZW50TmFtZSwgYmFzZUV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgfVxuICAgIGNvbW1hbmQoaWQsIGVsZW1lbnQsIGNvbW1hbmQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKGNvbW1hbmQgPT0gJ3JlZ2lzdGVyJykge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcihpZCwgYXJnc1swXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQgPT0gJ2NyZWF0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJnc1swXSB8fCB7fSk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZShpZCwgZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGxheWVyID0gdGhpcy5fZ2V0UGxheWVyKGlkKTtcbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlICdwbGF5JzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGxheSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGF1c2UnOlxuICAgICAgICAgICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICAgICAgICAgIHBsYXllci5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVzdGFydCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZpbmlzaCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgICAgICAgcGxheWVyLmluaXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NldFBvc2l0aW9uJzpcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UG9zaXRpb24ocGFyc2VGbG9hdChhcmdzWzBdKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBRVUVVRURfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUtcXVldWVkJztcbmNvbnN0IFFVRVVFRF9TRUxFQ1RPUiA9ICcubmctYW5pbWF0ZS1xdWV1ZWQnO1xuY29uc3QgRElTQUJMRURfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUtZGlzYWJsZWQnO1xuY29uc3QgRElTQUJMRURfU0VMRUNUT1IgPSAnLm5nLWFuaW1hdGUtZGlzYWJsZWQnO1xuY29uc3QgU1RBUl9DTEFTU05BTUUgPSAnbmctc3Rhci1pbnNlcnRlZCc7XG5jb25zdCBTVEFSX1NFTEVDVE9SID0gJy5uZy1zdGFyLWluc2VydGVkJztcbmNvbnN0IEVNUFRZX1BMQVlFUl9BUlJBWSA9IFtdO1xuY29uc3QgTlVMTF9SRU1PVkFMX1NUQVRFID0ge1xuICAgIG5hbWVzcGFjZUlkOiAnJyxcbiAgICBzZXRGb3JSZW1vdmFsOiBmYWxzZSxcbiAgICBzZXRGb3JNb3ZlOiBmYWxzZSxcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxuICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiBmYWxzZVxufTtcbmNvbnN0IE5VTExfUkVNT1ZFRF9RVUVSSUVEX1NUQVRFID0ge1xuICAgIG5hbWVzcGFjZUlkOiAnJyxcbiAgICBzZXRGb3JNb3ZlOiBmYWxzZSxcbiAgICBzZXRGb3JSZW1vdmFsOiBmYWxzZSxcbiAgICBoYXNBbmltYXRpb246IGZhbHNlLFxuICAgIHJlbW92ZWRCZWZvcmVRdWVyaWVkOiB0cnVlXG59O1xuY29uc3QgUkVNT1ZBTF9GTEFHID0gJ19fbmdfcmVtb3ZlZCc7XG5jbGFzcyBTdGF0ZVZhbHVlIHtcbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBhcmFtcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQsIG5hbWVzcGFjZUlkID0gJycpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICBjb25zdCBpc09iaiA9IGlucHV0ICYmIGlucHV0Lmhhc093blByb3BlcnR5KCd2YWx1ZScpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGlzT2JqID8gaW5wdXRbJ3ZhbHVlJ10gOiBpbnB1dDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5vcm1hbGl6ZVRyaWdnZXJWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvcHlPYmooaW5wdXQpO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNbJ3ZhbHVlJ107XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGFyYW1zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWJzb3JiT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAobmV3UGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRQYXJhbXMgPSB0aGlzLm9wdGlvbnMucGFyYW1zO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3UGFyYW1zKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJhbXNbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRQYXJhbXNbcHJvcF0gPSBuZXdQYXJhbXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBWT0lEX1ZBTFVFID0gJ3ZvaWQnO1xuY29uc3QgREVGQVVMVF9TVEFURV9WQUxVRSA9IG5ldyBTdGF0ZVZhbHVlKFZPSURfVkFMVUUpO1xuY2xhc3MgQW5pbWF0aW9uVHJhbnNpdGlvbk5hbWVzcGFjZSB7XG4gICAgY29uc3RydWN0b3IoaWQsIGhvc3RFbGVtZW50LCBfZW5naW5lKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLl9lbmdpbmUgPSBfZW5naW5lO1xuICAgICAgICB0aGlzLnBsYXllcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2hvc3RDbGFzc05hbWUgPSAnbmctdG5zLScgKyBpZDtcbiAgICAgICAgYWRkQ2xhc3MoaG9zdEVsZW1lbnQsIHRoaXMuX2hvc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICBsaXN0ZW4oZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJpZ2dlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBtaXNzaW5nVHJpZ2dlcihwaGFzZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBoYXNlID09IG51bGwgfHwgcGhhc2UubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRocm93IG1pc3NpbmdFdmVudChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVHJpZ2dlckV2ZW50VmFsaWQocGhhc2UpKSB7XG4gICAgICAgICAgICB0aHJvdyB1bnN1cHBvcnRlZFRyaWdnZXJFdmVudChwaGFzZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gZ2V0T3JTZXREZWZhdWx0VmFsdWUodGhpcy5fZWxlbWVudExpc3RlbmVycywgZWxlbWVudCwgW10pO1xuICAgICAgICBjb25zdCBkYXRhID0geyBuYW1lLCBwaGFzZSwgY2FsbGJhY2sgfTtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2goZGF0YSk7XG4gICAgICAgIGNvbnN0IHRyaWdnZXJzV2l0aFN0YXRlcyA9IGdldE9yU2V0RGVmYXVsdFZhbHVlKHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQsIGVsZW1lbnQsIG5ldyBNYXAoKSk7XG4gICAgICAgIGlmICghdHJpZ2dlcnNXaXRoU3RhdGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUpO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgTkdfVFJJR0dFUl9DTEFTU05BTUUgKyAnLScgKyBuYW1lKTtcbiAgICAgICAgICAgIHRyaWdnZXJzV2l0aFN0YXRlcy5zZXQobmFtZSwgREVGQVVMVF9TVEFURV9WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lciBpcyByZW1vdmVkIEFGVEVSIHRoZSBmbHVzaCBoYXMgb2NjdXJyZWQgc3VjaFxuICAgICAgICAgICAgLy8gdGhhdCBsZWF2ZSBhbmltYXRpb25zIGNhbGxiYWNrcyBjYW4gZmlyZSAob3RoZXJ3aXNlIGlmIHRoZSBub2RlXG4gICAgICAgICAgICAvLyBpcyByZW1vdmVkIGluIGJldHdlZW4gdGhlbiB0aGUgbGlzdGVuZXJzIHdvdWxkIGJlIGRlcmVnaXN0ZXJlZClcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5hZnRlckZsdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RyaWdnZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2Vyc1dpdGhTdGF0ZXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZWdpc3RlcihuYW1lLCBhc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgLy8gdGhyb3dcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJzLnNldChuYW1lLCBhc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldFRyaWdnZXIobmFtZSkge1xuICAgICAgICBjb25zdCB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlcnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRocm93IHVucmVnaXN0ZXJlZFRyaWdnZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaWdnZXI7XG4gICAgfVxuICAgIHRyaWdnZXIoZWxlbWVudCwgdHJpZ2dlck5hbWUsIHZhbHVlLCBkZWZhdWx0VG9GYWxsYmFjayA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHRoaXMuX2dldFRyaWdnZXIodHJpZ2dlck5hbWUpO1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcih0aGlzLmlkLCB0cmlnZ2VyTmFtZSwgZWxlbWVudCk7XG4gICAgICAgIGxldCB0cmlnZ2Vyc1dpdGhTdGF0ZXMgPSB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCF0cmlnZ2Vyc1dpdGhTdGF0ZXMpIHtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIE5HX1RSSUdHRVJfQ0xBU1NOQU1FICsgJy0nICsgdHJpZ2dlck5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5zZXQoZWxlbWVudCwgdHJpZ2dlcnNXaXRoU3RhdGVzID0gbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnJvbVN0YXRlID0gdHJpZ2dlcnNXaXRoU3RhdGVzLmdldCh0cmlnZ2VyTmFtZSk7XG4gICAgICAgIGNvbnN0IHRvU3RhdGUgPSBuZXcgU3RhdGVWYWx1ZSh2YWx1ZSwgdGhpcy5pZCk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gdmFsdWUgJiYgdmFsdWUuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJyk7XG4gICAgICAgIGlmICghaXNPYmogJiYgZnJvbVN0YXRlKSB7XG4gICAgICAgICAgICB0b1N0YXRlLmFic29yYk9wdGlvbnMoZnJvbVN0YXRlLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJzV2l0aFN0YXRlcy5zZXQodHJpZ2dlck5hbWUsIHRvU3RhdGUpO1xuICAgICAgICBpZiAoIWZyb21TdGF0ZSkge1xuICAgICAgICAgICAgZnJvbVN0YXRlID0gREVGQVVMVF9TVEFURV9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1JlbW92YWwgPSB0b1N0YXRlLnZhbHVlID09PSBWT0lEX1ZBTFVFO1xuICAgICAgICAvLyBub3JtYWxseSB0aGlzIGlzbid0IHJlYWNoZWQgYnkgaGVyZSwgaG93ZXZlciwgaWYgYW4gb2JqZWN0IGV4cHJlc3Npb25cbiAgICAgICAgLy8gaXMgcGFzc2VkIGluIHRoZW4gaXQgbWF5IGJlIGEgbmV3IG9iamVjdCBlYWNoIHRpbWUuIENvbXBhcmluZyB0aGUgdmFsdWVcbiAgICAgICAgLy8gaXMgaW1wb3J0YW50IHNpbmNlIHRoYXQgd2lsbCBzdGF5IHRoZSBzYW1lIGRlc3BpdGUgdGhlcmUgYmVpbmcgYSBuZXcgb2JqZWN0LlxuICAgICAgICAvLyBUaGUgcmVtb3ZhbCBhcmMgaGVyZSBpcyBzcGVjaWFsIGNhc2VkIGJlY2F1c2UgdGhlIHNhbWUgZWxlbWVudCBpcyB0cmlnZ2VyZWRcbiAgICAgICAgLy8gdHdpY2UgaW4gdGhlIGV2ZW50IHRoYXQgaXQgY29udGFpbnMgYW5pbWF0aW9ucyBvbiB0aGUgb3V0ZXIvaW5uZXIgcG9ydGlvbnNcbiAgICAgICAgLy8gb2YgdGhlIGhvc3QgY29udGFpbmVyXG4gICAgICAgIGlmICghaXNSZW1vdmFsICYmIGZyb21TdGF0ZS52YWx1ZSA9PT0gdG9TdGF0ZS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGRlc3BpdGUgdGhlIHZhbHVlIG5vdCBjaGFuZ2luZywgc29tZSBpbm5lciBwYXJhbXNcbiAgICAgICAgICAgIC8vIGhhdmUgY2hhbmdlZCB3aGljaCBtZWFucyB0aGF0IHRoZSBhbmltYXRpb24gZmluYWwgc3R5bGVzIG5lZWQgdG8gYmUgYXBwbGllZFxuICAgICAgICAgICAgaWYgKCFvYmpFcXVhbHMoZnJvbVN0YXRlLnBhcmFtcywgdG9TdGF0ZS5wYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbVN0eWxlcyA9IHRyaWdnZXIubWF0Y2hTdHlsZXMoZnJvbVN0YXRlLnZhbHVlLCBmcm9tU3RhdGUucGFyYW1zLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvU3R5bGVzID0gdHJpZ2dlci5tYXRjaFN0eWxlcyh0b1N0YXRlLnZhbHVlLCB0b1N0YXRlLnBhcmFtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUucmVwb3J0RXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5hZnRlckZsdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGZyb21TdHlsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U3R5bGVzKGVsZW1lbnQsIHRvU3R5bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBsYXllcnNPbkVsZW1lbnQgPSBnZXRPclNldERlZmF1bHRWYWx1ZSh0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudCwgZWxlbWVudCwgW10pO1xuICAgICAgICBwbGF5ZXJzT25FbGVtZW50LmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBwbGF5ZXIgaWYgaXQgaXMgcXVldWVkIG9uIHRoZSBFWEFDVCBzYW1lIHRyaWdnZXIvbmFtZXNwYWNlXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IGFsc28gZGVhbCB3aXRoIHF1ZXVlZCBwbGF5ZXJzIGhlcmUgYmVjYXVzZSBpZiB0aGUgYW5pbWF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gc3RhcnRlZCB0aGVuIHdlIHdhbnQgdG8ga2VlcCB0aGUgcGxheWVyIGFsaXZlIHVudGlsIHRoZSBmbHVzaCBoYXBwZW5zXG4gICAgICAgICAgICAvLyAod2hpY2ggaXMgd2hlcmUgdGhlIHByZXZpb3VzUGxheWVycyBhcmUgcGFzc2VkIGludG8gdGhlIG5ldyBwbGF5ZXIpXG4gICAgICAgICAgICBpZiAocGxheWVyLm5hbWVzcGFjZUlkID09IHRoaXMuaWQgJiYgcGxheWVyLnRyaWdnZXJOYW1lID09IHRyaWdnZXJOYW1lICYmIHBsYXllci5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHRyYW5zaXRpb24gPSB0cmlnZ2VyLm1hdGNoVHJhbnNpdGlvbihmcm9tU3RhdGUudmFsdWUsIHRvU3RhdGUudmFsdWUsIGVsZW1lbnQsIHRvU3RhdGUucGFyYW1zKTtcbiAgICAgICAgbGV0IGlzRmFsbGJhY2tUcmFuc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0VG9GYWxsYmFjaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICBpc0ZhbGxiYWNrVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5naW5lLnRvdGFsUXVldWVkUGxheWVycysrO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHsgZWxlbWVudCwgdHJpZ2dlck5hbWUsIHRyYW5zaXRpb24sIGZyb21TdGF0ZSwgdG9TdGF0ZSwgcGxheWVyLCBpc0ZhbGxiYWNrVHJhbnNpdGlvbiB9KTtcbiAgICAgICAgaWYgKCFpc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgUVVFVUVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICBwbGF5ZXIub25TdGFydCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgUVVFVUVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMucGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IHRoaXMuX2VuZ2luZS5wbGF5ZXJzQnlFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gcGxheWVycy5pbmRleE9mKHBsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgIHBsYXllcnNPbkVsZW1lbnQucHVzaChwbGF5ZXIpO1xuICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgIH1cbiAgICBkZXJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdGVzQnlFbGVtZW50LmZvckVhY2goc3RhdGVNYXAgPT4gc3RhdGVNYXAuZGVsZXRlKG5hbWUpKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudExpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcnMsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVycy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeS5uYW1lICE9IG5hbWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhckVsZW1lbnRDYWNoZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBsYXllcnMgPSB0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgZWxlbWVudFBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4gcGxheWVyLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUucGxheWVyc0J5RWxlbWVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NpZ25hbFJlbW92YWxGb3JJbm5lclRyaWdnZXJzKHJvb3RFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fZW5naW5lLmRyaXZlci5xdWVyeShyb290RWxlbWVudCwgTkdfVFJJR0dFUl9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgIC8vIGVtdWxhdGUgYSBsZWF2ZSBhbmltYXRpb24gZm9yIGFsbCBpbm5lciBub2RlcyB3aXRoaW4gdGhpcyBub2RlLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyBmb3VuZCBmb3IgYW55IG9mIHRoZSBub2RlcyB0aGVuIGNsZWFyIHRoZSBjYWNoZVxuICAgICAgICAvLyBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxtID0+IHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBhbiBpbm5lciByZW1vdmUoKSBvcGVyYXRpb24gaGFzIGFscmVhZHkga2lja2VkIG9mZlxuICAgICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBvbiB0aGlzIGVsZW1lbnQuLi5cbiAgICAgICAgICAgIGlmIChlbG1bUkVNT1ZBTF9GTEFHXSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gdGhpcy5fZW5naW5lLmZldGNoTmFtZXNwYWNlc0J5RWxlbWVudChlbG0pO1xuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZXMuZm9yRWFjaChucyA9PiBucy50cmlnZ2VyTGVhdmVBbmltYXRpb24oZWxtLCBjb250ZXh0LCBmYWxzZSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckVsZW1lbnRDYWNoZShlbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgdGhlIGNoaWxkIGVsZW1lbnRzIHdlcmUgcmVtb3ZlZCBhbG9uZyB3aXRoIHRoZSBwYXJlbnQsIHRoZWlyIGFuaW1hdGlvbnMgbWlnaHQgbm90XG4gICAgICAgIC8vIGhhdmUgY29tcGxldGVkLiBDbGVhciBhbGwgdGhlIGVsZW1lbnRzIGZyb20gdGhlIGNhY2hlIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoIGEgbWVtb3J5IGxlYWsuXG4gICAgICAgIHRoaXMuX2VuZ2luZS5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUoKCkgPT4gZWxlbWVudHMuZm9yRWFjaChlbG0gPT4gdGhpcy5jbGVhckVsZW1lbnRDYWNoZShlbG0pKSk7XG4gICAgfVxuICAgIHRyaWdnZXJMZWF2ZUFuaW1hdGlvbihlbGVtZW50LCBjb250ZXh0LCBkZXN0cm95QWZ0ZXJDb21wbGV0ZSwgZGVmYXVsdFRvRmFsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHJpZ2dlclN0YXRlcyA9IHRoaXMuX2VuZ2luZS5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBwcmV2aW91c1RyaWdnZXJzVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAodHJpZ2dlclN0YXRlcykge1xuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IFtdO1xuICAgICAgICAgICAgdHJpZ2dlclN0YXRlcy5mb3JFYWNoKChzdGF0ZSwgdHJpZ2dlck5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1RyaWdnZXJzVmFsdWVzLnNldCh0cmlnZ2VyTmFtZSwgc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hlY2sgaXMgaGVyZSBpbiB0aGUgZXZlbnQgdGhhdCBhbiBlbGVtZW50IGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyB0d2ljZSAoYm90aCBvbiB0aGUgaG9zdCBsZXZlbCBhbmQgdGhlIGNvbXBvbmVudCBsZXZlbClcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcnMuaGFzKHRyaWdnZXJOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLnRyaWdnZXIoZWxlbWVudCwgdHJpZ2dlck5hbWUsIFZPSURfVkFMVUUsIGRlZmF1bHRUb0ZhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5tYXJrRWxlbWVudEFzUmVtb3ZlZCh0aGlzLmlkLCBlbGVtZW50LCB0cnVlLCBjb250ZXh0LCBwcmV2aW91c1RyaWdnZXJzVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdHJveUFmdGVyQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKS5vbkRvbmUoKCkgPT4gdGhpcy5fZW5naW5lLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHByZXBhcmVMZWF2ZUFuaW1hdGlvbkxpc3RlbmVycyhlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50U3RhdGVzID0gdGhpcy5fZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIC8vIGlmIHRoaXMgc3RhdGVtZW50IGZhaWxzIHRoZW4gaXQgbWVhbnMgdGhhdCB0aGUgZWxlbWVudCB3YXMgcGlja2VkIHVwXG4gICAgICAgIC8vIGJ5IGFuIGVhcmxpZXIgZmx1c2ggKG9yIHRoZXJlIGFyZSBubyBsaXN0ZW5lcnMgYXQgYWxsIHRvIHRyYWNrIHRoZSBsZWF2ZSkuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMgJiYgZWxlbWVudFN0YXRlcykge1xuICAgICAgICAgICAgY29uc3QgdmlzaXRlZFRyaWdnZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJOYW1lID0gbGlzdGVuZXIubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZFRyaWdnZXJzLmhhcyh0cmlnZ2VyTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2aXNpdGVkVHJpZ2dlcnMuYWRkKHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlcnMuZ2V0KHRyaWdnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gdHJpZ2dlci5mYWxsYmFja1RyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbVN0YXRlID0gZWxlbWVudFN0YXRlcy5nZXQodHJpZ2dlck5hbWUpIHx8IERFRkFVTFRfU1RBVEVfVkFMVUU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9TdGF0ZSA9IG5ldyBTdGF0ZVZhbHVlKFZPSURfVkFMVUUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IG5ldyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyKHRoaXMuaWQsIHRyaWdnZXJOYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUudG90YWxRdWV1ZWRQbGF5ZXJzKys7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmcm9tU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHRvU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFja1RyYW5zaXRpb246IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZU5vZGUoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9lbmdpbmU7XG4gICAgICAgIGlmIChlbGVtZW50LmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxSZW1vdmFsRm9ySW5uZXJUcmlnZ2VycyhlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgYSAqID0+IFZPSUQgYW5pbWF0aW9uIHdhcyBkZXRlY3RlZCBhbmQga2lja2VkIG9mZlxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyTGVhdmVBbmltYXRpb24oZWxlbWVudCwgY29udGV4dCwgdHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIGZpbmQgdGhlIHBsYXllciB0aGF0IGlzIGFuaW1hdGluZyBhbmQgbWFrZSBzdXJlIHRoYXQgdGhlXG4gICAgICAgIC8vIHJlbW92YWwgaXMgZGVsYXllZCB1bnRpbCB0aGF0IHBsYXllciBoYXMgY29tcGxldGVkXG4gICAgICAgIGxldCBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKGVuZ2luZS50b3RhbEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQbGF5ZXJzID0gZW5naW5lLnBsYXllcnMubGVuZ3RoID8gZW5naW5lLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KSA6IFtdO1xuICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGBpZiBzdGF0ZW1lbnRgIGRvZXMgbm90IGNvbnRpbnVlIGZvcndhcmQgaXQgbWVhbnMgdGhhdFxuICAgICAgICAgICAgLy8gYSBwcmV2aW91cyBhbmltYXRpb24gcXVlcnkgaGFzIHNlbGVjdGVkIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAgICAgICAvLyBpcyBhbmltYXRpbmcgaXQuIEluIHRoaXMgc2l0dWF0aW9uIHdhbnQgdG8gY29udGludWUgZm9yd2FyZHMgYW5kXG4gICAgICAgICAgICAvLyBhbGxvdyB0aGUgZWxlbWVudCB0byBiZSBxdWV1ZWQgdXAgZm9yIGFuaW1hdGlvbiBsYXRlci5cbiAgICAgICAgICAgIGlmIChjdXJyZW50UGxheWVycyAmJiBjdXJyZW50UGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJzID0gZW5naW5lLnN0YXRlc0J5RWxlbWVudC5nZXQocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluc1BvdGVudGlhbFBhcmVudFRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXQgdGhpcyBzdGFnZSB3ZSBrbm93IHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBlaXRoZXIgZ2V0IHJlbW92ZWRcbiAgICAgICAgLy8gZHVyaW5nIGZsdXNoIG9yIHdpbGwgYmUgcGlja2VkIHVwIGJ5IGEgcGFyZW50IHF1ZXJ5LiBFaXRoZXIgd2F5XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZmlyZSB0aGUgbGlzdGVuZXJzIGZvciB0aGlzIGVsZW1lbnQgd2hlbiBpdCBET0VTIGdldFxuICAgICAgICAvLyByZW1vdmVkIChvbmNlIHRoZSBxdWVyeSBwYXJlbnQgYW5pbWF0aW9uIGlzIGRvbmUgb3IgYWZ0ZXIgZmx1c2gpXG4gICAgICAgIHRoaXMucHJlcGFyZUxlYXZlQW5pbWF0aW9uTGlzdGVuZXJzKGVsZW1lbnQpO1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBhIHBhcmVudCBoYXMgYW4gYW5pbWF0aW9uIHdlIG5lZWQgdG8gZGVsYXkgdGhlIGRlZmVycmFsIG9mIHRoZSBsZWF2ZVxuICAgICAgICAvLyBvcGVyYXRpb24gdW50aWwgd2UgaGF2ZSBtb3JlIGluZm9ybWF0aW9uICh3aGljaCB3ZSBkbyBhZnRlciBmbHVzaCgpIGhhcyBiZWVuIGNhbGxlZClcbiAgICAgICAgaWYgKGNvbnRhaW5zUG90ZW50aWFsUGFyZW50VHJhbnNpdGlvbikge1xuICAgICAgICAgICAgZW5naW5lLm1hcmtFbGVtZW50QXNSZW1vdmVkKHRoaXMuaWQsIGVsZW1lbnQsIGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92YWxGbGFnID0gZWxlbWVudFtSRU1PVkFMX0ZMQUddO1xuICAgICAgICAgICAgaWYgKCFyZW1vdmFsRmxhZyB8fCByZW1vdmFsRmxhZyA9PT0gTlVMTF9SRU1PVkFMX1NUQVRFKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG8gdGhpcyBhZnRlciB0aGUgZmx1c2ggaGFzIG9jY3VycmVkIHN1Y2hcbiAgICAgICAgICAgICAgICAvLyB0aGF0IHRoZSBjYWxsYmFja3MgY2FuIGJlIGZpcmVkXG4gICAgICAgICAgICAgICAgZW5naW5lLmFmdGVyRmx1c2goKCkgPT4gdGhpcy5jbGVhckVsZW1lbnRDYWNoZShlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgZW5naW5lLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZW5naW5lLl9vblJlbW92YWxDb21wbGV0ZShlbGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnROb2RlKGVsZW1lbnQsIHBhcmVudCkge1xuICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCB0aGlzLl9ob3N0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyhtaWNyb3Rhc2tJZCkge1xuICAgICAgICBjb25zdCBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fcXVldWUuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSBlbnRyeS5wbGF5ZXI7XG4gICAgICAgICAgICBpZiAocGxheWVyLmRlc3Ryb3llZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZW50cnkuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2VsZW1lbnRMaXN0ZW5lcnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZSA9PSBlbnRyeS50cmlnZ2VyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZUV2ZW50ID0gbWFrZUFuaW1hdGlvbkV2ZW50KGVsZW1lbnQsIGVudHJ5LnRyaWdnZXJOYW1lLCBlbnRyeS5mcm9tU3RhdGUudmFsdWUsIGVudHJ5LnRvU3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUV2ZW50WydfZGF0YSddID0gbWljcm90YXNrSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5PblBsYXllcihlbnRyeS5wbGF5ZXIsIGxpc3RlbmVyLnBoYXNlLCBiYXNlRXZlbnQsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYXllci5tYXJrZWRGb3JEZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLmFmdGVyRmx1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3cgd2UgY2FuIGRlc3Ryb3kgdGhlIGVsZW1lbnQgcHJvcGVybHkgc2luY2UgdGhlIGV2ZW50IGxpc3RlbmVycyBoYXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZW4gYm91bmQgdG8gdGhlIHBsYXllclxuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBkZXBDb3VudCA9PSAwIHRoZW0gbW92ZSB0byBmcm9udFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGEgY29udGFpbnMgYiB0aGVuIG1vdmUgYmFja1xuICAgICAgICAgICAgY29uc3QgZDAgPSBhLnRyYW5zaXRpb24uYXN0LmRlcENvdW50O1xuICAgICAgICAgICAgY29uc3QgZDEgPSBiLnRyYW5zaXRpb24uYXN0LmRlcENvdW50O1xuICAgICAgICAgICAgaWYgKGQwID09IDAgfHwgZDEgPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkMCAtIGQxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZ2luZS5kcml2ZXIuY29udGFpbnNFbGVtZW50KGEuZWxlbWVudCwgYi5lbGVtZW50KSA/IDEgOiAtMTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koY29udGV4dCkge1xuICAgICAgICB0aGlzLnBsYXllcnMuZm9yRWFjaChwID0+IHAuZGVzdHJveSgpKTtcbiAgICAgICAgdGhpcy5fc2lnbmFsUmVtb3ZhbEZvcklubmVyVHJpZ2dlcnModGhpcy5ob3N0RWxlbWVudCwgY29udGV4dCk7XG4gICAgfVxuICAgIGVsZW1lbnRDb250YWluc0RhdGEoZWxlbWVudCkge1xuICAgICAgICBsZXQgY29udGFpbnNEYXRhID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50TGlzdGVuZXJzLmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIGNvbnRhaW5zRGF0YSA9XG4gICAgICAgICAgICAodGhpcy5fcXVldWUuZmluZChlbnRyeSA9PiBlbnRyeS5lbGVtZW50ID09PSBlbGVtZW50KSA/IHRydWUgOiBmYWxzZSkgfHwgY29udGFpbnNEYXRhO1xuICAgICAgICByZXR1cm4gY29udGFpbnNEYXRhO1xuICAgIH1cbn1cbmNsYXNzIFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihib2R5Tm9kZSwgZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmJvZHlOb2RlID0gYm9keU5vZGU7XG4gICAgICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVyID0gX25vcm1hbGl6ZXI7XG4gICAgICAgIHRoaXMucGxheWVycyA9IFtdO1xuICAgICAgICB0aGlzLm5ld0hvc3RFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5wbGF5ZXJzQnlFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXRlc0J5RWxlbWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnRvdGFsQW5pbWF0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMudG90YWxRdWV1ZWRQbGF5ZXJzID0gMDtcbiAgICAgICAgdGhpcy5fbmFtZXNwYWNlTG9va3VwID0ge307XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QgPSBbXTtcbiAgICAgICAgdGhpcy5fZmx1c2hGbnMgPSBbXTtcbiAgICAgICAgdGhpcy5fd2hlblF1aWV0Rm5zID0gW107XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMgPSBbXTtcbiAgICAgICAgLy8gdGhpcyBtZXRob2QgaXMgZGVzaWduZWQgdG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY29kZSB0aGF0IHVzZXMgdGhpcyBlbmdpbmVcbiAgICAgICAgdGhpcy5vblJlbW92YWxDb21wbGV0ZSA9IChlbGVtZW50LCBjb250ZXh0KSA9PiB7IH07XG4gICAgfVxuICAgIGdldCBxdWV1ZWRQbGF5ZXJzKCkge1xuICAgICAgICBjb25zdCBwbGF5ZXJzID0gW107XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZUxpc3QuZm9yRWFjaChucyA9PiB7XG4gICAgICAgICAgICBucy5wbGF5ZXJzLmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGxheWVyLnF1ZXVlZCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGF5ZXJzO1xuICAgIH1cbiAgICBjcmVhdGVOYW1lc3BhY2UobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5zID0gbmV3IEFuaW1hdGlvblRyYW5zaXRpb25OYW1lc3BhY2UobmFtZXNwYWNlSWQsIGhvc3RFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuYm9keU5vZGUgJiYgdGhpcy5kcml2ZXIuY29udGFpbnNFbGVtZW50KHRoaXMuYm9keU5vZGUsIGhvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5fYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGhvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmVyIHRoaXMgbGF0ZXIgdW50aWwgZmx1c2ggZHVyaW5nIHdoZW4gdGhlIGhvc3QgZWxlbWVudCBoYXNcbiAgICAgICAgICAgIC8vIGJlZW4gaW5zZXJ0ZWQgc28gdGhhdCB3ZSBrbm93IGV4YWN0bHkgd2hlcmUgdG8gcGxhY2UgaXQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBuYW1lc3BhY2UgbGlzdFxuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuc2V0KGhvc3RFbGVtZW50LCBucyk7XG4gICAgICAgICAgICAvLyBnaXZlbiB0aGF0IHRoaXMgaG9zdCBlbGVtZW50IGlzIGEgcGFydCBvZiB0aGUgYW5pbWF0aW9uIGNvZGUsIGl0XG4gICAgICAgICAgICAvLyBtYXkgb3IgbWF5IG5vdCBiZSBpbnNlcnRlZCBieSBhIHBhcmVudCBub2RlIHRoYXQgaXMgb2YgYW5cbiAgICAgICAgICAgIC8vIGFuaW1hdGlvbiByZW5kZXJlciB0eXBlLiBJZiB0aGlzIGhhcHBlbnMgdGhlbiB3ZSBjYW4gc3RpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gYWNjZXNzIHRvIHRoaXMgaXRlbSB3aGVuIHdlIHF1ZXJ5IGZvciA6ZW50ZXIgbm9kZXMuIElmIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGlzIGEgcmVuZGVyZXIgdGhlbiB0aGUgc2V0IGRhdGEtc3RydWN0dXJlIHdpbGwgbm9ybWFsaXplIHRoZSBlbnRyeVxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0RW50ZXJFbGVtZW50KGhvc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXSA9IG5zO1xuICAgIH1cbiAgICBfYmFsYW5jZU5hbWVzcGFjZUxpc3QobnMsIGhvc3RFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZUxpc3QgPSB0aGlzLl9uYW1lc3BhY2VMaXN0O1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VzQnlIb3N0RWxlbWVudCA9IHRoaXMubmFtZXNwYWNlc0J5SG9zdEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gbmFtZXNwYWNlTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGltaXQgPj0gMCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHdpdGggYW4gZXhpc3RpbmcgbmFtZXNwYWNlIHNvIHdlIGNhbiB0aGVuIGluc2VydCBgbnNgIGFmdGVyIGl0LFxuICAgICAgICAgICAgLy8gZXN0YWJsaXNoaW5nIGEgdG9wLWRvd24gb3JkZXJpbmcgb2YgbmFtZXNwYWNlcyBpbiBgdGhpcy5fbmFtZXNwYWNlTGlzdGAuXG4gICAgICAgICAgICBsZXQgYW5jZXN0b3IgPSB0aGlzLmRyaXZlci5nZXRQYXJlbnRFbGVtZW50KGhvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yTnMgPSBuYW1lc3BhY2VzQnlIb3N0RWxlbWVudC5nZXQoYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChhbmNlc3Rvck5zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIGFuaW1hdGlvbiBuYW1lc3BhY2UgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBhbmNlc3Rvciwgc28gd2UgaW5zZXJ0IGBuc2BcbiAgICAgICAgICAgICAgICAgICAgLy8gcmlnaHQgYWZ0ZXIgaXQgdG8gZXN0YWJsaXNoIHRvcC1kb3duIG9yZGVyaW5nIG9mIGFuaW1hdGlvbiBuYW1lc3BhY2VzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzcGFjZUxpc3QuaW5kZXhPZihhbmNlc3Rvck5zKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlTGlzdC5zcGxpY2UoaW5kZXggKyAxLCAwLCBucyk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gdGhpcy5kcml2ZXIuZ2V0UGFyZW50RWxlbWVudChhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmFtZXNwYWNlIGV4aXN0cyB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIGBuc2AsIHNvIGBuc2AgaXMgaW5zZXJ0ZWQgYXQgdGhlIGZyb250IHRvXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYW55IGV4aXN0aW5nIGRlc2NlbmRhbnRzIGFyZSBvcmRlcmVkIGFmdGVyIGBuc2AsIHJldGFpbmluZyB0aGUgZGVzaXJlZFxuICAgICAgICAgICAgICAgIC8vIHRvcC1kb3duIG9yZGVyaW5nLlxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZUxpc3QudW5zaGlmdChucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lc3BhY2VMaXN0LnB1c2gobnMpO1xuICAgICAgICB9XG4gICAgICAgIG5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LnNldChob3N0RWxlbWVudCwgbnMpO1xuICAgICAgICByZXR1cm4gbnM7XG4gICAgfVxuICAgIHJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xuICAgICAgICBsZXQgbnMgPSB0aGlzLl9uYW1lc3BhY2VMb29rdXBbbmFtZXNwYWNlSWRdO1xuICAgICAgICBpZiAoIW5zKSB7XG4gICAgICAgICAgICBucyA9IHRoaXMuY3JlYXRlTmFtZXNwYWNlKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5zO1xuICAgIH1cbiAgICByZWdpc3RlclRyaWdnZXIobmFtZXNwYWNlSWQsIG5hbWUsIHRyaWdnZXIpIHtcbiAgICAgICAgbGV0IG5zID0gdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgaWYgKG5zICYmIG5zLnJlZ2lzdGVyKG5hbWUsIHRyaWdnZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnRvdGFsQW5pbWF0aW9ucysrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3kobmFtZXNwYWNlSWQsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2VJZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJGbHVzaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmRlbGV0ZShucy5ob3N0RWxlbWVudCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbmFtZXNwYWNlTG9va3VwW25hbWVzcGFjZUlkXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbmFtZXNwYWNlTGlzdC5pbmRleE9mKG5zKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZXNwYWNlTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZnRlckZsdXNoQW5pbWF0aW9uc0RvbmUoKCkgPT4gbnMuZGVzdHJveShjb250ZXh0KSk7XG4gICAgfVxuICAgIF9mZXRjaE5hbWVzcGFjZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZXNwYWNlTG9va3VwW2lkXTtcbiAgICB9XG4gICAgZmV0Y2hOYW1lc3BhY2VzQnlFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gbm9ybWFsbHkgdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIG5hbWVzcGFjZSBwZXIgZWxlbWVudCwgaG93ZXZlclxuICAgICAgICAvLyBpZiBAdHJpZ2dlcnMgYXJlIHBsYWNlZCBvbiBib3RoIHRoZSBjb21wb25lbnQgZWxlbWVudCBhbmQgdGhlblxuICAgICAgICAvLyBpdHMgaG9zdCBlbGVtZW50ICh3aXRoaW4gdGhlIGNvbXBvbmVudCBjb2RlKSB0aGVuIHRoZXJlIHdpbGwgYmVcbiAgICAgICAgLy8gdHdvIG5hbWVzcGFjZXMgcmV0dXJuZWQuIFdlIHVzZSBhIHNldCBoZXJlIHRvIHNpbXBseSBkZWR1cGxpY2F0ZVxuICAgICAgICAvLyB0aGUgbmFtZXNwYWNlcyBpbiBjYXNlIChmb3IgdGhlIHJlYXNvbiBkZXNjcmliZWQgYWJvdmUpIHRoZXJlIGFyZSBtdWx0aXBsZSB0cmlnZ2Vyc1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VzID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50U3RhdGVzID0gdGhpcy5zdGF0ZXNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudFN0YXRlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGVWYWx1ZSBvZiBlbGVtZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlVmFsdWUubmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShzdGF0ZVZhbHVlLm5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2VzLmFkZChucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZXM7XG4gICAgfVxuICAgIHRyaWdnZXIobmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgIGlmIChucykge1xuICAgICAgICAgICAgICAgIG5zLnRyaWdnZXIoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaW5zZXJ0Tm9kZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnROb2RlKGVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyByZW1vdmVkIGFuZCByZWluc2VydGVkIChtb3ZlIG9wZXJhdGlvbilcbiAgICAgICAgLy8gd2hlbiB0aGlzIG9jY3VycyB3ZSBkbyBub3Qgd2FudCB0byB1c2UgdGhlIGVsZW1lbnQgZm9yIGRlbGV0aW9uIGxhdGVyXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgZGV0YWlscy5zZXRGb3JSZW1vdmFsID0gZmFsc2U7XG4gICAgICAgICAgICBkZXRhaWxzLnNldEZvck1vdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIG5hbWVzcGFjZUlkIGlzIGJsYW5rIHRoZW4gdGhlIGNhbGxlclxuICAgICAgICAvLyBjb2RlIGRvZXMgbm90IGNvbnRhaW4gYW55IGFuaW1hdGlvbiBjb2RlIGluIGl0LCBidXQgaXQgaXNcbiAgICAgICAgLy8ganVzdCBiZWluZyBjYWxsZWQgc28gdGhhdCB0aGUgbm9kZSBpcyBtYXJrZWQgYXMgYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBucyA9IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaWYtc3RhdGVtZW50IGlzIGEgd29ya2Fyb3VuZCBmb3Igcm91dGVyIGlzc3VlICMyMTk0Ny5cbiAgICAgICAgICAgIC8vIFRoZSByb3V0ZXIgc29tZXRpbWVzIGhpdHMgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSB3aGlsZSBhIHJvdXRlXG4gICAgICAgICAgICAvLyBpcyBiZWluZyBpbnN0YW50aWF0ZWQgYSBuZXcgbmF2aWdhdGlvbiBhcnJpdmVzLCB0cmlnZ2VyaW5nIGxlYXZlXG4gICAgICAgICAgICAvLyBhbmltYXRpb24gb2YgRE9NIHRoYXQgaGFzIG5vdCBiZWVuIGZ1bGx5IGluaXRpYWxpemVkLCB1bnRpbCB0aGlzXG4gICAgICAgICAgICAvLyBpcyByZXNvbHZlZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhlIHNjZW5hcmlvIHdoZW4gRE9NIGlzIG5vdCBpbiBhXG4gICAgICAgICAgICAvLyBjb25zaXN0ZW50IHN0YXRlIGR1cmluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgbnMuaW5zZXJ0Tm9kZShlbGVtZW50LCBwYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgKmRpcmVjdGl2ZXMgYW5kIGhvc3QgZWxlbWVudHMgYXJlIGluc2VydGVkIGJlZm9yZVxuICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RFbnRlckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGVjdEVudGVyRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBtYXJrRWxlbWVudEFzRGlzYWJsZWQoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWROb2Rlcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVkTm9kZXMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIERJU0FCTEVEX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNhYmxlZE5vZGVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZE5vZGVzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIERJU0FCTEVEX0NMQVNTTkFNRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTm9kZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgaXNIb3N0RWxlbWVudCwgY29udGV4dCkge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSBuYW1lc3BhY2VJZCA/IHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICBucy5yZW1vdmVOb2RlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRWxlbWVudEFzUmVtb3ZlZChuYW1lc3BhY2VJZCwgZWxlbWVudCwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3N0TlMgPSB0aGlzLm5hbWVzcGFjZXNCeUhvc3RFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdE5TICYmIGhvc3ROUy5pZCAhPT0gbmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdE5TLnJlbW92ZU5vZGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFya0VsZW1lbnRBc1JlbW92ZWQobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGhhc0FuaW1hdGlvbiwgY29udGV4dCwgcHJldmlvdXNUcmlnZ2Vyc1ZhbHVlcykge1xuICAgICAgICB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0ge1xuICAgICAgICAgICAgbmFtZXNwYWNlSWQsXG4gICAgICAgICAgICBzZXRGb3JSZW1vdmFsOiBjb250ZXh0LFxuICAgICAgICAgICAgaGFzQW5pbWF0aW9uLFxuICAgICAgICAgICAgcmVtb3ZlZEJlZm9yZVF1ZXJpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJldmlvdXNUcmlnZ2Vyc1ZhbHVlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBsaXN0ZW4obmFtZXNwYWNlSWQsIGVsZW1lbnQsIG5hbWUsIHBoYXNlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoaXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoTmFtZXNwYWNlKG5hbWVzcGFjZUlkKS5saXN0ZW4oZWxlbWVudCwgbmFtZSwgcGhhc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgIH1cbiAgICBfYnVpbGRJbnN0cnVjdGlvbihlbnRyeSwgc3ViVGltZWxpbmVzLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIHNraXBCdWlsZEFzdCkge1xuICAgICAgICByZXR1cm4gZW50cnkudHJhbnNpdGlvbi5idWlsZCh0aGlzLmRyaXZlciwgZW50cnkuZWxlbWVudCwgZW50cnkuZnJvbVN0YXRlLnZhbHVlLCBlbnRyeS50b1N0YXRlLnZhbHVlLCBlbnRlckNsYXNzTmFtZSwgbGVhdmVDbGFzc05hbWUsIGVudHJ5LmZyb21TdGF0ZS5vcHRpb25zLCBlbnRyeS50b1N0YXRlLm9wdGlvbnMsIHN1YlRpbWVsaW5lcywgc2tpcEJ1aWxkQXN0KTtcbiAgICB9XG4gICAgZGVzdHJveUlubmVyQW5pbWF0aW9ucyhjb250YWluZXJFbGVtZW50KSB7XG4gICAgICAgIGxldCBlbGVtZW50cyA9IHRoaXMuZHJpdmVyLnF1ZXJ5KGNvbnRhaW5lckVsZW1lbnQsIE5HX1RSSUdHRVJfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gdGhpcy5kZXN0cm95QWN0aXZlQW5pbWF0aW9uc0ZvckVsZW1lbnQoZWxlbWVudCkpO1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5kcml2ZXIucXVlcnkoY29udGFpbmVyRWxlbWVudCwgTkdfQU5JTUFUSU5HX1NFTEVDVE9SLCB0cnVlKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHRoaXMuZmluaXNoQWN0aXZlUXVlcmllZEFuaW1hdGlvbk9uRWxlbWVudChlbGVtZW50KSk7XG4gICAgfVxuICAgIGRlc3Ryb3lBY3RpdmVBbmltYXRpb25zRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHBsYXllcnMgPSB0aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAocGxheWVycykge1xuICAgICAgICAgICAgcGxheWVycy5mb3JFYWNoKHBsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgc2V0IGZvciBkZXN0cnVjdGlvbiwgYnV0IGhhc24ndCBzdGFydGVkLlxuICAgICAgICAgICAgICAgIC8vIGluIHRoaXMgc2l0dWF0aW9uIHdlIHdhbnQgdG8gZGVsYXkgdGhlIGRlc3RydWN0aW9uIHVudGlsIHRoZSBmbHVzaCBvY2N1cnNcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IGFueSBldmVudCBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIHBsYXllciBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5tYXJrZWRGb3JEZXN0cm95ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoQWN0aXZlUXVlcmllZEFuaW1hdGlvbk9uRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHBsYXllcnMgPSB0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKHBsYXllcnMpIHtcbiAgICAgICAgICAgIHBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4gcGxheWVyLmZpbmlzaCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGVuUmVuZGVyaW5nRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW1pemVHcm91cFBsYXllcih0aGlzLnBsYXllcnMpLm9uRG9uZSgoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHByZXZlbnQgaXQgZnJvbSByZW1vdmluZyBpdCB0d2ljZVxuICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkFMX1NUQVRFO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMubmFtZXNwYWNlSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lJbm5lckFuaW1hdGlvbnMoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9mZXRjaE5hbWVzcGFjZShkZXRhaWxzLm5hbWVzcGFjZUlkKTtcbiAgICAgICAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbnMuY2xlYXJFbGVtZW50Q2FjaGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb25SZW1vdmFsQ29tcGxldGUoZWxlbWVudCwgZGV0YWlscy5zZXRGb3JSZW1vdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3Q/LmNvbnRhaW5zKERJU0FCTEVEX0NMQVNTTkFNRSkpIHtcbiAgICAgICAgICAgIHRoaXMubWFya0VsZW1lbnRBc0Rpc2FibGVkKGVsZW1lbnQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBESVNBQkxFRF9TRUxFQ1RPUiwgdHJ1ZSkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFya0VsZW1lbnRBc0Rpc2FibGVkKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoKG1pY3JvdGFza0lkID0gLTEpIHtcbiAgICAgICAgbGV0IHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubmV3SG9zdEVsZW1lbnRzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubmV3SG9zdEVsZW1lbnRzLmZvckVhY2goKG5zLCBlbGVtZW50KSA9PiB0aGlzLl9iYWxhbmNlTmFtZXNwYWNlTGlzdChucywgZWxlbWVudCkpO1xuICAgICAgICAgICAgdGhpcy5uZXdIb3N0RWxlbWVudHMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b3RhbEFuaW1hdGlvbnMgJiYgdGhpcy5jb2xsZWN0ZWRFbnRlckVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbG0gPSB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZWxtLCBTVEFSX0NMQVNTTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX25hbWVzcGFjZUxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICAodGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgfHwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFudXBGbnMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGxheWVycyA9IHRoaXMuX2ZsdXNoQW5pbWF0aW9ucyhjbGVhbnVwRm5zLCBtaWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFudXBGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cEZuc1tpXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY29sbGVjdGVkTGVhdmVFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbFF1ZXVlZFBsYXllcnMgPSAwO1xuICAgICAgICB0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRMZWF2ZUVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgICAgIHRoaXMuX2ZsdXNoRm5zID0gW107XG4gICAgICAgIGlmICh0aGlzLl93aGVuUXVpZXRGbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB3ZSBtb3ZlIHRoZXNlIG92ZXIgdG8gYSB2YXJpYWJsZSBzbyB0aGF0XG4gICAgICAgICAgICAvLyBpZiBhbnkgbmV3IGNhbGxiYWNrcyBhcmUgcmVnaXN0ZXJlZCBpbiBhbm90aGVyXG4gICAgICAgICAgICAvLyBmbHVzaCB0aGV5IGRvIG5vdCBwb3B1bGF0ZSB0aGUgZXhpc3Rpbmcgc2V0XG4gICAgICAgICAgICBjb25zdCBxdWlldEZucyA9IHRoaXMuX3doZW5RdWlldEZucztcbiAgICAgICAgICAgIHRoaXMuX3doZW5RdWlldEZucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVHcm91cFBsYXllcihwbGF5ZXJzKS5vbkRvbmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBxdWlldEZucy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVpZXRGbnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXBvcnRFcnJvcihlcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgdHJpZ2dlclRyYW5zaXRpb25zRmFpbGVkKGVycm9ycyk7XG4gICAgfVxuICAgIF9mbHVzaEFuaW1hdGlvbnMoY2xlYW51cEZucywgbWljcm90YXNrSWQpIHtcbiAgICAgICAgY29uc3Qgc3ViVGltZWxpbmVzID0gbmV3IEVsZW1lbnRJbnN0cnVjdGlvbk1hcCgpO1xuICAgICAgICBjb25zdCBza2lwcGVkUGxheWVycyA9IFtdO1xuICAgICAgICBjb25zdCBza2lwcGVkUGxheWVyc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgcXVldWVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJpZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYWxsUHJlU3R5bGVFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYWxsUG9zdFN0eWxlRWxlbWVudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkRWxlbWVudHNTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgZGlzYWJsZWRFbGVtZW50c1NldC5hZGQobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBub2Rlc1RoYXRBcmVEaXNhYmxlZCA9IHRoaXMuZHJpdmVyLnF1ZXJ5KG5vZGUsIFFVRVVFRF9TRUxFQ1RPUiwgdHJ1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVGhhdEFyZURpc2FibGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRFbGVtZW50c1NldC5hZGQobm9kZXNUaGF0QXJlRGlzYWJsZWRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm9keU5vZGUgPSB0aGlzLmJvZHlOb2RlO1xuICAgICAgICBjb25zdCBhbGxUcmlnZ2VyRWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuc3RhdGVzQnlFbGVtZW50LmtleXMoKSk7XG4gICAgICAgIGNvbnN0IGVudGVyTm9kZU1hcCA9IGJ1aWxkUm9vdE1hcChhbGxUcmlnZ2VyRWxlbWVudHMsIHRoaXMuY29sbGVjdGVkRW50ZXJFbGVtZW50cyk7XG4gICAgICAgIC8vIHRoaXMgbXVzdCBvY2N1ciBiZWZvcmUgdGhlIGluc3RydWN0aW9ucyBhcmUgYnVpbHQgYmVsb3cgc3VjaCB0aGF0XG4gICAgICAgIC8vIHRoZSA6ZW50ZXIgcXVlcmllcyBtYXRjaCB0aGUgZWxlbWVudHMgKHNpbmNlIHRoZSB0aW1lbGluZSBxdWVyaWVzXG4gICAgICAgIC8vIGFyZSBmaXJlZCBkdXJpbmcgaW5zdHJ1Y3Rpb24gYnVpbGRpbmcpLlxuICAgICAgICBjb25zdCBlbnRlck5vZGVNYXBJZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZW50ZXJOb2RlTWFwLmZvckVhY2goKG5vZGVzLCByb290KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBFTlRFUl9DTEFTU05BTUUgKyBpKys7XG4gICAgICAgICAgICBlbnRlck5vZGVNYXBJZHMuc2V0KHJvb3QsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbGxMZWF2ZU5vZGVzID0gW107XG4gICAgICAgIGNvbnN0IG1lcmdlZExlYXZlTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmNvbGxlY3RlZExlYXZlRWxlbWVudHNbaV07XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZWxlbWVudFtSRU1PVkFMX0ZMQUddO1xuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JSZW1vdmFsKSB7XG4gICAgICAgICAgICAgICAgYWxsTGVhdmVOb2Rlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIG1lcmdlZExlYXZlTm9kZXMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkZXRhaWxzLmhhc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBTVEFSX1NFTEVDVE9SLCB0cnVlKS5mb3JFYWNoKGVsbSA9PiBtZXJnZWRMZWF2ZU5vZGVzLmFkZChlbG0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlYXZlTm9kZU1hcElkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbGVhdmVOb2RlTWFwID0gYnVpbGRSb290TWFwKGFsbFRyaWdnZXJFbGVtZW50cywgQXJyYXkuZnJvbShtZXJnZWRMZWF2ZU5vZGVzKSk7XG4gICAgICAgIGxlYXZlTm9kZU1hcC5mb3JFYWNoKChub2Rlcywgcm9vdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gTEVBVkVfQ0xBU1NOQU1FICsgaSsrO1xuICAgICAgICAgICAgbGVhdmVOb2RlTWFwSWRzLnNldChyb290LCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IGFkZENsYXNzKG5vZGUsIGNsYXNzTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xlYW51cEZucy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGVudGVyTm9kZU1hcC5mb3JFYWNoKChub2Rlcywgcm9vdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGVudGVyTm9kZU1hcElkcy5nZXQocm9vdCk7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZWF2ZU5vZGVNYXAuZm9yRWFjaCgobm9kZXMsIHJvb3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBsZWF2ZU5vZGVNYXBJZHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc05hbWUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWxsTGVhdmVOb2Rlcy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWxsUGxheWVycyA9IFtdO1xuICAgICAgICBjb25zdCBlcnJvbmVvdXNUcmFuc2l0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbmFtZXNwYWNlTGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbnMgPSB0aGlzLl9uYW1lc3BhY2VMaXN0W2ldO1xuICAgICAgICAgICAgbnMuZHJhaW5RdWV1ZWRUcmFuc2l0aW9ucyhtaWNyb3Rhc2tJZCkuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheWVyID0gZW50cnkucGxheWVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xuICAgICAgICAgICAgICAgIGFsbFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbGxlY3RlZEVudGVyRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbnMgZm9yIG1vdmUgb3BlcmF0aW9ucyAoZWxlbWVudHMgYmVpbmcgcmVtb3ZlZCBhbmQgcmVpbnNlcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiB3aGVuIHRoZSBvcmRlciBvZiBhbiAqbmdGb3IgbGlzdCBjaGFuZ2VzKSBhcmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5zZXRGb3JNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlscy5wcmV2aW91c1RyaWdnZXJzVmFsdWVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscy5wcmV2aW91c1RyaWdnZXJzVmFsdWVzLmhhcyhlbnRyeS50cmlnZ2VyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gZGV0YWlscy5wcmV2aW91c1RyaWdnZXJzVmFsdWVzLmdldChlbnRyeS50cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwcmV2aW91cyB0cmlnZ2VyIHZhbHVlIHNpbmNlIHRoZSBlbGVtZW50IGhhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYmVlbiBtb3ZlZCBhbmQgaGFzbid0IGFjdHVhbGx5IGxlZnQgdGhlIERPTVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaWdnZXJzV2l0aFN0YXRlcyA9IHRoaXMuc3RhdGVzQnlFbGVtZW50LmdldChlbnRyeS5lbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpZ2dlcnNXaXRoU3RhdGVzICYmIHRyaWdnZXJzV2l0aFN0YXRlcy5oYXMoZW50cnkudHJpZ2dlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdHJpZ2dlcnNXaXRoU3RhdGVzLmdldChlbnRyeS50cmlnZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcnNXaXRoU3RhdGVzLnNldChlbnRyeS50cmlnZ2VyTmFtZSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUlzT3JwaGFuZWQgPSAhYm9keU5vZGUgfHwgIXRoaXMuZHJpdmVyLmNvbnRhaW5zRWxlbWVudChib2R5Tm9kZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVhdmVDbGFzc05hbWUgPSBsZWF2ZU5vZGVNYXBJZHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudGVyQ2xhc3NOYW1lID0gZW50ZXJOb2RlTWFwSWRzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHRoaXMuX2J1aWxkSW5zdHJ1Y3Rpb24oZW50cnksIHN1YlRpbWVsaW5lcywgZW50ZXJDbGFzc05hbWUsIGxlYXZlQ2xhc3NOYW1lLCBub2RlSXNPcnBoYW5lZCk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmVycm9ycyAmJiBpbnN0cnVjdGlvbi5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9uZW91c1RyYW5zaXRpb25zLnB1c2goaW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBlbGVtZW50IG1heSBub3QgYmUgaW4gdGhlIERPTSwgaXQgbWF5IHN0aWxsXG4gICAgICAgICAgICAgICAgLy8gYmUgYWRkZWQgYXQgYSBsYXRlciBwb2ludCAoZHVlIHRvIHRoZSBtZWNoYW5pY3Mgb2YgY29udGVudFxuICAgICAgICAgICAgICAgIC8vIHByb2plY3Rpb24gYW5kL29yIGR5bmFtaWMgY29tcG9uZW50IGluc2VydGlvbikgdGhlcmVmb3JlIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQgdG8gc3RpbGwgc3R5bGUgdGhlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJc09ycGhhbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vblN0YXJ0KCgpID0+IGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLm9uRGVzdHJveSgoKSA9PiBzZXRTdHlsZXMoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udG9TdHlsZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIGFuIHVubWF0Y2hlZCB0cmFuc2l0aW9uIGlzIHF1ZXVlZCBhbmQgcmVhZHkgdG8gZ29cbiAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IFNIT1VMRCBOT1QgcmVuZGVyIGFuIGFuaW1hdGlvbiBhbmQgY2FuY2VsIHRoZVxuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzbHkgcnVubmluZyBhbmltYXRpb25zLlxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5pc0ZhbGxiYWNrVHJhbnNpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXIub25TdGFydCgoKSA9PiBlcmFzZVN0eWxlcyhlbGVtZW50LCBpbnN0cnVjdGlvbi5mcm9tU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koKCkgPT4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgaWYgYSBwYXJlbnQgYW5pbWF0aW9uIHVzZXMgdGhpcyBhbmltYXRpb24gYXMgYSBzdWItdHJpZ2dlclxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaXQgd2lsbCBpbnN0cnVjdCB0aGUgdGltZWxpbmUgYnVpbGRlciBub3QgdG8gYWRkIGEgcGxheWVyIGRlbGF5LCBidXRcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkIHN0cmV0Y2ggdGhlIGZpcnN0IGtleWZyYW1lIGdhcCB1bnRpbCB0aGUgYW5pbWF0aW9uIHN0YXJ0cy4gVGhpcyBpc1xuICAgICAgICAgICAgICAgIC8vIGltcG9ydGFudCBpbiBvcmRlciB0byBwcmV2ZW50IGV4dHJhIGluaXRpYWxpemF0aW9uIHN0eWxlcyBmcm9tIGJlaW5nXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYnkgdGhlIHVzZXIgZm9yIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZWxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzLmZvckVhY2godGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0bC5zdHJldGNoU3RhcnRpbmdLZXlmcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNhYmxlZE5vZGVzLmhhcyh0bC5lbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVzLnB1c2godGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24udGltZWxpbmVzID0gdGltZWxpbmVzO1xuICAgICAgICAgICAgICAgIHN1YlRpbWVsaW5lcy5hcHBlbmQoZWxlbWVudCwgaW5zdHJ1Y3Rpb24udGltZWxpbmVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZSA9IHsgaW5zdHJ1Y3Rpb24sIHBsYXllciwgZWxlbWVudCB9O1xuICAgICAgICAgICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5wdXNoKHR1cGxlKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5xdWVyaWVkRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IGdldE9yU2V0RGVmYXVsdFZhbHVlKHF1ZXJpZWRFbGVtZW50cywgZWxlbWVudCwgW10pLnB1c2gocGxheWVyKSk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb24ucHJlU3R5bGVQcm9wcy5mb3JFYWNoKChzdHJpbmdNYXAsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ01hcC5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2V0VmFsID0gYWxsUHJlU3R5bGVFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNldFZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByZVN0eWxlRWxlbWVudHMuc2V0KGVsZW1lbnQsIHNldFZhbCA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdNYXAuZm9yRWFjaCgoXywgcHJvcCkgPT4gc2V0VmFsLmFkZChwcm9wKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbi5wb3N0U3R5bGVQcm9wcy5mb3JFYWNoKChzdHJpbmdNYXAsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNldFZhbCA9IGFsbFBvc3RTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXRWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFBvc3RTdHlsZUVsZW1lbnRzLnNldChlbGVtZW50LCBzZXRWYWwgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ01hcC5mb3JFYWNoKChfLCBwcm9wKSA9PiBzZXRWYWwuYWRkKHByb3ApKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvbmVvdXNUcmFuc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgZXJyb25lb3VzVHJhbnNpdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2godHJhbnNpdGlvbkZhaWxlZChpbnN0cnVjdGlvbi50cmlnZ2VyTmFtZSwgaW5zdHJ1Y3Rpb24uZXJyb3JzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFsbFBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4gcGxheWVyLmRlc3Ryb3koKSk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsUHJldmlvdXNQbGF5ZXJzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0aGlzIG1hcCB0ZWxscyB1cyB3aGljaCBlbGVtZW50IGluIHRoZSBET00gdHJlZSBpcyBjb250YWluZWQgYnlcbiAgICAgICAgLy8gd2hpY2ggYW5pbWF0aW9uLiBGdXJ0aGVyIGRvd24gdGhpcyBtYXAgd2lsbCBnZXQgcG9wdWxhdGVkIG9uY2VcbiAgICAgICAgLy8gdGhlIHBsYXllcnMgYXJlIGJ1aWx0IGFuZCBpbiBkb2luZyBzbyB3ZSBjYW4gdXNlIGl0IHRvIGVmZmljaWVudGx5XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgYSBzdWIgcGxheWVyIGlzIHNraXBwZWQgZHVlIHRvIGEgcGFyZW50IHBsYXllciBoYXZpbmcgcHJpb3JpdHkuXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHF1ZXVlZEluc3RydWN0aW9ucy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyeS5lbGVtZW50O1xuICAgICAgICAgICAgaWYgKHN1YlRpbWVsaW5lcy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25FbGVtZW50TWFwLnNldChlbGVtZW50LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWZvcmVBbmltYXRpb25CdWlsZChlbnRyeS5wbGF5ZXIubmFtZXNwYWNlSWQsIGVudHJ5Lmluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2tpcHBlZFBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHBsYXllci5lbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQbGF5ZXJzID0gdGhpcy5fZ2V0UHJldmlvdXNQbGF5ZXJzKGVsZW1lbnQsIGZhbHNlLCBwbGF5ZXIubmFtZXNwYWNlSWQsIHBsYXllci50cmlnZ2VyTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChwcmV2UGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBnZXRPclNldERlZmF1bHRWYWx1ZShhbGxQcmV2aW91c1BsYXllcnNNYXAsIGVsZW1lbnQsIFtdKS5wdXNoKHByZXZQbGF5ZXIpO1xuICAgICAgICAgICAgICAgIHByZXZQbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBub2RlcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBlaXRoZXIgYnlcbiAgICAgICAgLy8gaGF2aW5nIHRoZWlyIG93biBsZWF2ZSBhbmltYXRpb25zIG9yIGJ5IGJlaW5nIHF1ZXJpZWQgaW4gYSBjb250YWluZXJcbiAgICAgICAgLy8gdGhhdCB3aWxsIGJlIHJlbW92ZWQgb25jZSBhIHBhcmVudCBhbmltYXRpb24gaXMgY29tcGxldGUuIFRoZSBpZGVhXG4gICAgICAgIC8vIGhlcmUgaXMgdGhhdCAqIHN0eWxlcyBtdXN0IGJlIGlkZW50aWNhbCB0byAhIHN0eWxlcyBiZWNhdXNlIG9mXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICgqIGlzIGFsc28gZmlsbGVkIGluIGJ5IGRlZmF1bHQgaW4gbWFueSBwbGFjZXMpLlxuICAgICAgICAvLyBPdGhlcndpc2UgKiBzdHlsZXMgd2lsbCByZXR1cm4gYW4gZW1wdHkgdmFsdWUgb3IgXCJhdXRvXCIgc2luY2UgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gcGFzc2VkIHRvIGdldENvbXB1dGVkU3R5bGUgd2lsbCBub3QgYmUgdmlzaWJsZSAoc2luY2UgKiA9PT0gZGVzdGluYXRpb24pXG4gICAgICAgIGNvbnN0IHJlcGxhY2VOb2RlcyA9IGFsbExlYXZlTm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUobm9kZSwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUE9TVCBTVEFHRTogZmlsbCB0aGUgKiBzdHlsZXNcbiAgICAgICAgY29uc3QgcG9zdFN0eWxlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgYWxsTGVhdmVRdWVyaWVkTm9kZXMgPSBjbG9ha0FuZENvbXB1dGVTdHlsZXMocG9zdFN0eWxlc01hcCwgdGhpcy5kcml2ZXIsIGxlYXZlTm9kZXNXaXRob3V0QW5pbWF0aW9ucywgYWxsUG9zdFN0eWxlRWxlbWVudHMsIEFVVE9fU1RZTEUpO1xuICAgICAgICBhbGxMZWF2ZVF1ZXJpZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUobm9kZSwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBQUkUgU1RBR0U6IGZpbGwgdGhlICEgc3R5bGVzXG4gICAgICAgIGNvbnN0IHByZVN0eWxlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZW50ZXJOb2RlTWFwLmZvckVhY2goKG5vZGVzLCByb290KSA9PiB7XG4gICAgICAgICAgICBjbG9ha0FuZENvbXB1dGVTdHlsZXMocHJlU3R5bGVzTWFwLCB0aGlzLmRyaXZlciwgbmV3IFNldChub2RlcyksIGFsbFByZVN0eWxlRWxlbWVudHMsIMm1UFJFX1NUWUxFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxhY2VOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zdCA9IHBvc3RTdHlsZXNNYXAuZ2V0KG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgcHJlID0gcHJlU3R5bGVzTWFwLmdldChub2RlKTtcbiAgICAgICAgICAgIHBvc3RTdHlsZXNNYXAuc2V0KG5vZGUsIG5ldyBNYXAoWy4uLkFycmF5LmZyb20ocG9zdD8uZW50cmllcygpID8/IFtdKSwgLi4uQXJyYXkuZnJvbShwcmU/LmVudHJpZXMoKSA/PyBbXSldKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByb290UGxheWVycyA9IFtdO1xuICAgICAgICBjb25zdCBzdWJQbGF5ZXJzID0gW107XG4gICAgICAgIGNvbnN0IE5PX1BBUkVOVF9BTklNQVRJT05fRUxFTUVOVF9ERVRFQ1RFRCA9IHt9O1xuICAgICAgICBxdWV1ZWRJbnN0cnVjdGlvbnMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHBsYXllciwgaW5zdHJ1Y3Rpb24gfSA9IGVudHJ5O1xuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGl0IHdhcyBuZXZlciBjb25zdW1lZCBieSBhIHBhcmVudCBhbmltYXRpb24gd2hpY2hcbiAgICAgICAgICAgIC8vIG1lYW5zIHRoYXQgaXQgaXMgaW5kZXBlbmRlbnQgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgc2V0IGZvciBhbmltYXRpb25cbiAgICAgICAgICAgIGlmIChzdWJUaW1lbGluZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koKCkgPT4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBsYXllci5vdmVycmlkZVRvdGFsVGltZShpbnN0cnVjdGlvbi50b3RhbFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGZsb3cgdXAgdGhlIERPTSBhbmQgcXVlcnkgdGhlIG1hcCB0byBmaWd1cmUgb3V0XG4gICAgICAgICAgICAgICAgLy8gaWYgYSBwYXJlbnQgYW5pbWF0aW9uIGhhcyBwcmlvcml0eSBvdmVyIGl0LiBJbiB0aGUgc2l0dWF0aW9uXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhIHBhcmVudCBpcyBkZXRlY3RlZCB0aGVuIGl0IHdpbGwgY2FuY2VsIHRoZSBsb29wLiBJZlxuICAgICAgICAgICAgICAgIC8vIG5vdGhpbmcgaXMgZGV0ZWN0ZWQsIG9yIGl0IHRha2VzIGEgZmV3IGhvcHMgdG8gZmluZCBhIHBhcmVudCxcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGl0IHdpbGwgZmlsbCBpbiB0aGUgbWlzc2luZyBub2RlcyBhbmQgc2lnbmFsIHRoZW0gYXMgaGF2aW5nXG4gICAgICAgICAgICAgICAgLy8gYSBkZXRlY3RlZCBwYXJlbnQgKG9yIGEgTk9fUEFSRU5UIHZhbHVlIHZpYSBhIHNwZWNpYWwgY29uc3RhbnQpLlxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRXaXRoQW5pbWF0aW9uID0gTk9fUEFSRU5UX0FOSU1BVElPTl9FTEVNRU5UX0RFVEVDVEVEO1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25FbGVtZW50TWFwLnNpemUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbG0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRzVG9BZGQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGVsbSA9IGVsbS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RlZFBhcmVudCA9IGFuaW1hdGlvbkVsZW1lbnRNYXAuZ2V0KGVsbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRXaXRoQW5pbWF0aW9uID0gZGV0ZWN0ZWRQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzVG9BZGQucHVzaChlbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHNUb0FkZC5mb3JFYWNoKHBhcmVudCA9PiBhbmltYXRpb25FbGVtZW50TWFwLnNldChwYXJlbnQsIHBhcmVudFdpdGhBbmltYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJQbGF5ZXIgPSB0aGlzLl9idWlsZEFuaW1hdGlvbihwbGF5ZXIubmFtZXNwYWNlSWQsIGluc3RydWN0aW9uLCBhbGxQcmV2aW91c1BsYXllcnNNYXAsIHNraXBwZWRQbGF5ZXJzTWFwLCBwcmVTdHlsZXNNYXAsIHBvc3RTdHlsZXNNYXApO1xuICAgICAgICAgICAgICAgIHBsYXllci5zZXRSZWFsUGxheWVyKGlubmVyUGxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50V2l0aEFuaW1hdGlvbiA9PT0gTk9fUEFSRU5UX0FOSU1BVElPTl9FTEVNRU5UX0RFVEVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3RQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBsYXllcnMgPSB0aGlzLnBsYXllcnNCeUVsZW1lbnQuZ2V0KHBhcmVudFdpdGhBbmltYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50UGxheWVycyAmJiBwYXJlbnRQbGF5ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhcmVudFBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIocGFyZW50UGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFBsYXllcnMucHVzaChwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVyYXNlU3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLmZyb21TdHlsZXMpO1xuICAgICAgICAgICAgICAgIHBsYXllci5vbkRlc3Ryb3koKCkgPT4gc2V0U3R5bGVzKGVsZW1lbnQsIGluc3RydWN0aW9uLnRvU3R5bGVzKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgc3RpbGwgbWlnaHQgYmUgYSBhbmNlc3RvciBwbGF5ZXIgYW5pbWF0aW5nIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRoZXJlZm9yZSB3ZSB3aWxsIHN0aWxsIGFkZCBpdCBhcyBhIHN1YiBwbGF5ZXJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0cyBhbmltYXRpb24gbWF5IGJlIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgc3ViUGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWRQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBmaW5kIGFsbCBvZiB0aGUgc3ViIHBsYXllcnMnIGNvcnJlc3BvbmRpbmcgaW5uZXIgYW5pbWF0aW9uIHBsYXllcnNcbiAgICAgICAgc3ViUGxheWVycy5mb3JFYWNoKHBsYXllciA9PiB7XG4gICAgICAgICAgICAvLyBldmVuIGlmIG5vIHBsYXllcnMgYXJlIGZvdW5kIGZvciBhIHN1YiBhbmltYXRpb24gaXRcbiAgICAgICAgICAgIC8vIHdpbGwgc3RpbGwgY29tcGxldGUgaXRzZWxmIGFmdGVyIHRoZSBuZXh0IHRpY2sgc2luY2UgaXQncyBOb29wXG4gICAgICAgICAgICBjb25zdCBwbGF5ZXJzRm9yRWxlbWVudCA9IHNraXBwZWRQbGF5ZXJzTWFwLmdldChwbGF5ZXIuZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAocGxheWVyc0ZvckVsZW1lbnQgJiYgcGxheWVyc0ZvckVsZW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJQbGF5ZXIgPSBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnNGb3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2V0UmVhbFBsYXllcihpbm5lclBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGUgcmVhc29uIHdoeSB3ZSBkb24ndCBhY3R1YWxseSBwbGF5IHRoZSBhbmltYXRpb24gaXNcbiAgICAgICAgLy8gYmVjYXVzZSBhbGwgdGhhdCBhIHNraXBwZWQgcGxheWVyIGlzIGRlc2lnbmVkIHRvIGRvIGlzIHRvXG4gICAgICAgIC8vIGZpcmUgdGhlIHN0YXJ0L2RvbmUgdHJhbnNpdGlvbiBjYWxsYmFjayBldmVudHNcbiAgICAgICAgc2tpcHBlZFBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4ge1xuICAgICAgICAgICAgaWYgKHBsYXllci5wYXJlbnRQbGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuc3luY1BsYXllckV2ZW50cyhwbGF5ZXIucGFyZW50UGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBydW4gdGhyb3VnaCBhbGwgb2YgdGhlIHF1ZXVlZCByZW1vdmFscyBhbmQgc2VlIGlmIHRoZXlcbiAgICAgICAgLy8gd2VyZSBwaWNrZWQgdXAgYnkgYSBxdWVyeS4gSWYgbm90IHRoZW4gcGVyZm9ybSB0aGUgcmVtb3ZhbFxuICAgICAgICAvLyBvcGVyYXRpb24gcmlnaHQgYXdheSB1bmxlc3MgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsTGVhdmVOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGFsbExlYXZlTm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxzID0gZWxlbWVudFtSRU1PVkFMX0ZMQUddO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTEVBVkVfQ0xBU1NOQU1FKTtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhlIGVsZW1lbnQgaGFzIGEgcmVtb3ZhbCBhbmltYXRpb24gdGhhdCBpcyBiZWluZ1xuICAgICAgICAgICAgLy8gdGFrZW4gY2FyZSBvZiBhbmQgdGhlcmVmb3JlIHRoZSBpbm5lciBlbGVtZW50cyB3aWxsIGhhbmcgYXJvdW5kXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGF0IGFuaW1hdGlvbiBpcyBvdmVyIChvciB0aGUgcGFyZW50IHF1ZXJpZWQgYW5pbWF0aW9uKVxuICAgICAgICAgICAgaWYgKGRldGFpbHMgJiYgZGV0YWlscy5oYXNBbmltYXRpb24pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgcGxheWVycyA9IFtdO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBlbGVtZW50IGlzIHF1ZXJpZWQgb3IgaWYgaXQgY29udGFpbnMgcXVlcmllZCBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhlbiB3ZSB3YW50IGZvciB0aGUgZWxlbWVudCBub3QgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyB1bnRpbCB0aGUgcXVlcmllZCBhbmltYXRpb25zIGhhdmUgZmluaXNoZWRcbiAgICAgICAgICAgIGlmIChxdWVyaWVkRWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBxdWVyaWVkUGxheWVyUmVzdWx0cyA9IHF1ZXJpZWRFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXJpZWRQbGF5ZXJSZXN1bHRzICYmIHF1ZXJpZWRQbGF5ZXJSZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwbGF5ZXJzLnB1c2goLi4ucXVlcmllZFBsYXllclJlc3VsdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcXVlcmllZElubmVyRWxlbWVudHMgPSB0aGlzLmRyaXZlci5xdWVyeShlbGVtZW50LCBOR19BTklNQVRJTkdfU0VMRUNUT1IsIHRydWUpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcmllZElubmVyRWxlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHF1ZXJpZWRQbGF5ZXJzID0gcXVlcmllZEVsZW1lbnRzLmdldChxdWVyaWVkSW5uZXJFbGVtZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyaWVkUGxheWVycyAmJiBxdWVyaWVkUGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXllcnMucHVzaCguLi5xdWVyaWVkUGxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVQbGF5ZXJzID0gcGxheWVycy5maWx0ZXIocCA9PiAhcC5kZXN0cm95ZWQpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZXNBZnRlckFuaW1hdGlvbkRvbmUodGhpcywgZWxlbWVudCwgYWN0aXZlUGxheWVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NMZWF2ZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBpcyByZXF1aXJlZCBzbyB0aGUgY2xlYW51cCBtZXRob2QgZG9lc24ndCByZW1vdmUgdGhlbVxuICAgICAgICBhbGxMZWF2ZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHJvb3RQbGF5ZXJzLmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgICAgIHRoaXMucGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb290UGxheWVycztcbiAgICB9XG4gICAgZWxlbWVudENvbnRhaW5zRGF0YShuYW1lc3BhY2VJZCwgZWxlbWVudCkge1xuICAgICAgICBsZXQgY29udGFpbnNEYXRhID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgIGlmIChkZXRhaWxzICYmIGRldGFpbHMuc2V0Rm9yUmVtb3ZhbClcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnBsYXllcnNCeUVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgY29udGFpbnNEYXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVzQnlFbGVtZW50LmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgIGNvbnRhaW5zRGF0YSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9mZXRjaE5hbWVzcGFjZShuYW1lc3BhY2VJZCkuZWxlbWVudENvbnRhaW5zRGF0YShlbGVtZW50KSB8fCBjb250YWluc0RhdGE7XG4gICAgfVxuICAgIGFmdGVyRmx1c2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fZmx1c2hGbnMucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGFmdGVyRmx1c2hBbmltYXRpb25zRG9uZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl93aGVuUXVpZXRGbnMucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIF9nZXRQcmV2aW91c1BsYXllcnMoZWxlbWVudCwgaXNRdWVyaWVkRWxlbWVudCwgbmFtZXNwYWNlSWQsIHRyaWdnZXJOYW1lLCB0b1N0YXRlVmFsdWUpIHtcbiAgICAgICAgbGV0IHBsYXllcnMgPSBbXTtcbiAgICAgICAgaWYgKGlzUXVlcmllZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJpZWRFbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5UXVlcmllZEVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHF1ZXJpZWRFbGVtZW50UGxheWVycykge1xuICAgICAgICAgICAgICAgIHBsYXllcnMgPSBxdWVyaWVkRWxlbWVudFBsYXllcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50UGxheWVycyA9IHRoaXMucGxheWVyc0J5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudFBsYXllcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbW92YWxBbmltYXRpb24gPSAhdG9TdGF0ZVZhbHVlIHx8IHRvU3RhdGVWYWx1ZSA9PSBWT0lEX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsZW1lbnRQbGF5ZXJzLmZvckVhY2gocGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsYXllci5xdWV1ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW1vdmFsQW5pbWF0aW9uICYmIHBsYXllci50cmlnZ2VyTmFtZSAhPSB0cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZUlkIHx8IHRyaWdnZXJOYW1lKSB7XG4gICAgICAgICAgICBwbGF5ZXJzID0gcGxheWVycy5maWx0ZXIocGxheWVyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNwYWNlSWQgJiYgbmFtZXNwYWNlSWQgIT0gcGxheWVyLm5hbWVzcGFjZUlkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRyaWdnZXJOYW1lICYmIHRyaWdnZXJOYW1lICE9IHBsYXllci50cmlnZ2VyTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsYXllcnM7XG4gICAgfVxuICAgIF9iZWZvcmVBbmltYXRpb25CdWlsZChuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCkge1xuICAgICAgICBjb25zdCB0cmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLnRyaWdnZXJOYW1lO1xuICAgICAgICBjb25zdCByb290RWxlbWVudCA9IGluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgIC8vIHdoZW4gYSByZW1vdmFsIGFuaW1hdGlvbiBvY2N1cnMsIEFMTCBwcmV2aW91cyBwbGF5ZXJzIGFyZSBjb2xsZWN0ZWRcbiAgICAgICAgLy8gYW5kIGRlc3Ryb3llZCAoZXZlbiBpZiB0aGV5IGFyZSBvdXRzaWRlIG9mIHRoZSBjdXJyZW50IG5hbWVzcGFjZSlcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZVNwYWNlSWQgPSBpbnN0cnVjdGlvbi5pc1JlbW92YWxUcmFuc2l0aW9uID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlSWQ7XG4gICAgICAgIGNvbnN0IHRhcmdldFRyaWdnZXJOYW1lID0gaW5zdHJ1Y3Rpb24uaXNSZW1vdmFsVHJhbnNpdGlvbiA/IHVuZGVmaW5lZCA6IHRyaWdnZXJOYW1lO1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVsaW5lSW5zdHJ1Y3Rpb24gb2YgaW5zdHJ1Y3Rpb24udGltZWxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGltZWxpbmVJbnN0cnVjdGlvbi5lbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgaXNRdWVyaWVkRWxlbWVudCA9IGVsZW1lbnQgIT09IHJvb3RFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcGxheWVycyA9IGdldE9yU2V0RGVmYXVsdFZhbHVlKGFsbFByZXZpb3VzUGxheWVyc01hcCwgZWxlbWVudCwgW10pO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQbGF5ZXJzID0gdGhpcy5fZ2V0UHJldmlvdXNQbGF5ZXJzKGVsZW1lbnQsIGlzUXVlcmllZEVsZW1lbnQsIHRhcmdldE5hbWVTcGFjZUlkLCB0YXJnZXRUcmlnZ2VyTmFtZSwgaW5zdHJ1Y3Rpb24udG9TdGF0ZSk7XG4gICAgICAgICAgICBwcmV2aW91c1BsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWxQbGF5ZXIgPSBwbGF5ZXIuZ2V0UmVhbFBsYXllcigpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFsUGxheWVyLmJlZm9yZURlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFBsYXllci5iZWZvcmVEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXllci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcGxheWVycy5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIGRvbmUgc28gdGhhdCB0aGUgUFJFL1BPU1Qgc3R5bGVzIGNhbiBiZVxuICAgICAgICAvLyBjb21wdXRlZCBwcm9wZXJseSB3aXRob3V0IGludGVyZmVyaW5nIHdpdGggdGhlIHByZXZpb3VzIGFuaW1hdGlvblxuICAgICAgICBlcmFzZVN0eWxlcyhyb290RWxlbWVudCwgaW5zdHJ1Y3Rpb24uZnJvbVN0eWxlcyk7XG4gICAgfVxuICAgIF9idWlsZEFuaW1hdGlvbihuYW1lc3BhY2VJZCwgaW5zdHJ1Y3Rpb24sIGFsbFByZXZpb3VzUGxheWVyc01hcCwgc2tpcHBlZFBsYXllcnNNYXAsIHByZVN0eWxlc01hcCwgcG9zdFN0eWxlc01hcCkge1xuICAgICAgICBjb25zdCB0cmlnZ2VyTmFtZSA9IGluc3RydWN0aW9uLnRyaWdnZXJOYW1lO1xuICAgICAgICBjb25zdCByb290RWxlbWVudCA9IGluc3RydWN0aW9uLmVsZW1lbnQ7XG4gICAgICAgIC8vIHdlIGZpcnN0IHJ1biB0aGlzIHNvIHRoYXQgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBwbGF5ZXJcbiAgICAgICAgLy8gZGF0YSBjYW4gYmUgcGFzc2VkIGludG8gdGhlIHN1Y2Nlc3NpdmUgYW5pbWF0aW9uIHBsYXllcnNcbiAgICAgICAgY29uc3QgYWxsUXVlcmllZFBsYXllcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsQ29uc3VtZWRFbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgYWxsU3ViRWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGFsbE5ld1BsYXllcnMgPSBpbnN0cnVjdGlvbi50aW1lbGluZXMubWFwKHRpbWVsaW5lSW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRpbWVsaW5lSW5zdHJ1Y3Rpb24uZWxlbWVudDtcbiAgICAgICAgICAgIGFsbENvbnN1bWVkRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gRklYTUUgKG1hdHNrbyk6IG1ha2Ugc3VyZSB0by1iZS1yZW1vdmVkIGFuaW1hdGlvbnMgYXJlIHJlbW92ZWQgcHJvcGVybHlcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbHMgPSBlbGVtZW50W1JFTU9WQUxfRkxBR107XG4gICAgICAgICAgICBpZiAoZGV0YWlscyAmJiBkZXRhaWxzLnJlbW92ZWRCZWZvcmVRdWVyaWVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTm9vcEFuaW1hdGlvblBsYXllcih0aW1lbGluZUluc3RydWN0aW9uLmR1cmF0aW9uLCB0aW1lbGluZUluc3RydWN0aW9uLmRlbGF5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzUXVlcmllZEVsZW1lbnQgPSBlbGVtZW50ICE9PSByb290RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWVycyA9IGZsYXR0ZW5Hcm91cFBsYXllcnMoKGFsbFByZXZpb3VzUGxheWVyc01hcC5nZXQoZWxlbWVudCkgfHwgRU1QVFlfUExBWUVSX0FSUkFZKVxuICAgICAgICAgICAgICAgIC5tYXAocCA9PiBwLmdldFJlYWxQbGF5ZXIoKSkpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihwID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgYGVsZW1lbnRgIGlzIG5vdCBhcGFydCBvZiB0aGUgQW5pbWF0aW9uUGxheWVyIGRlZmluaXRpb24sIGJ1dFxuICAgICAgICAgICAgICAgIC8vIE1vY2svV2ViQW5pbWF0aW9uc1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZWxlbWVudCB3aXRoaW4gdGhlaXIgaW1wbGVtZW50YXRpb24uIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiBBbmd1bGFyNSB0b1xuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGlvblBsYXllclxuICAgICAgICAgICAgICAgIGNvbnN0IHBwID0gcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHAuZWxlbWVudCA/IHBwLmVsZW1lbnQgPT09IGVsZW1lbnQgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcHJlU3R5bGVzID0gcHJlU3R5bGVzTWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3RTdHlsZXMgPSBwb3N0U3R5bGVzTWFwLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IG5vcm1hbGl6ZUtleWZyYW1lcyQxKHRoaXMuZHJpdmVyLCB0aGlzLl9ub3JtYWxpemVyLCBlbGVtZW50LCB0aW1lbGluZUluc3RydWN0aW9uLmtleWZyYW1lcywgcHJlU3R5bGVzLCBwb3N0U3R5bGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHBsYXllciA9IHRoaXMuX2J1aWxkUGxheWVyKHRpbWVsaW5lSW5zdHJ1Y3Rpb24sIGtleWZyYW1lcywgcHJldmlvdXNQbGF5ZXJzKTtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGlzIHBhcnRpY3VsYXIgcGxheWVyIGJlbG9uZ3MgdG8gYSBzdWIgdHJpZ2dlci4gSXQgaXNcbiAgICAgICAgICAgIC8vIGltcG9ydGFudCB0aGF0IHdlIG1hdGNoIHRoaXMgcGxheWVyIHVwIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgKEB0cmlnZ2VyLmxpc3RlbmVyKVxuICAgICAgICAgICAgaWYgKHRpbWVsaW5lSW5zdHJ1Y3Rpb24uc3ViVGltZWxpbmUgJiYgc2tpcHBlZFBsYXllcnNNYXApIHtcbiAgICAgICAgICAgICAgICBhbGxTdWJFbGVtZW50cy5hZGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyaWVkRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRQbGF5ZXIgPSBuZXcgVHJhbnNpdGlvbkFuaW1hdGlvblBsYXllcihuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRQbGF5ZXIuc2V0UmVhbFBsYXllcihwbGF5ZXIpO1xuICAgICAgICAgICAgICAgIGFsbFF1ZXJpZWRQbGF5ZXJzLnB1c2god3JhcHBlZFBsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGxheWVyO1xuICAgICAgICB9KTtcbiAgICAgICAgYWxsUXVlcmllZFBsYXllcnMuZm9yRWFjaChwbGF5ZXIgPT4ge1xuICAgICAgICAgICAgZ2V0T3JTZXREZWZhdWx0VmFsdWUodGhpcy5wbGF5ZXJzQnlRdWVyaWVkRWxlbWVudCwgcGxheWVyLmVsZW1lbnQsIFtdKS5wdXNoKHBsYXllcik7XG4gICAgICAgICAgICBwbGF5ZXIub25Eb25lKCgpID0+IGRlbGV0ZU9yVW5zZXRJbk1hcCh0aGlzLnBsYXllcnNCeVF1ZXJpZWRFbGVtZW50LCBwbGF5ZXIuZWxlbWVudCwgcGxheWVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhbGxDb25zdW1lZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBhZGRDbGFzcyhlbGVtZW50LCBOR19BTklNQVRJTkdfQ0xBU1NOQU1FKSk7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IG9wdGltaXplR3JvdXBQbGF5ZXIoYWxsTmV3UGxheWVycyk7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICAgICAgYWxsQ29uc3VtZWRFbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgTkdfQU5JTUFUSU5HX0NMQVNTTkFNRSkpO1xuICAgICAgICAgICAgc2V0U3R5bGVzKHJvb3RFbGVtZW50LCBpbnN0cnVjdGlvbi50b1N0eWxlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBtYWtlcyBhbGwgb2YgdGhlIGNhbGxiYWNrcyBmb3Igc3ViIGVsZW1lbnQgYW5pbWF0aW9uc1xuICAgICAgICAvLyBiZSBkZXBlbmRlbnQgb24gdGhlIHVwcGVyIHBsYXllcnMgZm9yIHdoZW4gdGhleSBmaW5pc2hcbiAgICAgICAgYWxsU3ViRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGdldE9yU2V0RGVmYXVsdFZhbHVlKHNraXBwZWRQbGF5ZXJzTWFwLCBlbGVtZW50LCBbXSkucHVzaChwbGF5ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYXllcjtcbiAgICB9XG4gICAgX2J1aWxkUGxheWVyKGluc3RydWN0aW9uLCBrZXlmcmFtZXMsIHByZXZpb3VzUGxheWVycykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyaXZlci5hbmltYXRlKGluc3RydWN0aW9uLmVsZW1lbnQsIGtleWZyYW1lcywgaW5zdHJ1Y3Rpb24uZHVyYXRpb24sIGluc3RydWN0aW9uLmRlbGF5LCBpbnN0cnVjdGlvbi5lYXNpbmcsIHByZXZpb3VzUGxheWVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciB3aGVuIGFuIGVtcHR5IHRyYW5zaXRpb258ZGVmaW5pdGlvbiBpcyBwcm92aWRlZFxuICAgICAgICAvLyAuLi4gdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVuZGVyaW5nIGFuIGVtcHR5IGFuaW1hdGlvblxuICAgICAgICByZXR1cm4gbmV3IE5vb3BBbmltYXRpb25QbGF5ZXIoaW5zdHJ1Y3Rpb24uZHVyYXRpb24sIGluc3RydWN0aW9uLmRlbGF5KTtcbiAgICB9XG59XG5jbGFzcyBUcmFuc2l0aW9uQW5pbWF0aW9uUGxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lc3BhY2VJZCwgdHJpZ2dlck5hbWUsIGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLnRyaWdnZXJOYW1lID0gdHJpZ2dlck5hbWU7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3BsYXllciA9IG5ldyBOb29wQW5pbWF0aW9uUGxheWVyKCk7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5zUmVhbFBsYXllciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9xdWV1ZWRDYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGFyZW50UGxheWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JEZXN0cm95ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5xdWV1ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRvdGFsVGltZSA9IDA7XG4gICAgfVxuICAgIHNldFJlYWxQbGF5ZXIocGxheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3BsYXllciA9IHBsYXllcjtcbiAgICAgICAgdGhpcy5fcXVldWVkQ2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrcywgcGhhc2UpID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGxpc3Rlbk9uUGxheWVyKHBsYXllciwgcGhhc2UsIHVuZGVmaW5lZCwgY2FsbGJhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENhbGxiYWNrcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9jb250YWluc1JlYWxQbGF5ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLm92ZXJyaWRlVG90YWxUaW1lKHBsYXllci50b3RhbFRpbWUpO1xuICAgICAgICB0aGlzLnF1ZXVlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXRSZWFsUGxheWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGxheWVyO1xuICAgIH1cbiAgICBvdmVycmlkZVRvdGFsVGltZSh0b3RhbFRpbWUpIHtcbiAgICAgICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgfVxuICAgIHN5bmNQbGF5ZXJFdmVudHMocGxheWVyKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9wbGF5ZXI7XG4gICAgICAgIGlmIChwLnRyaWdnZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgcGxheWVyLm9uU3RhcnQoKCkgPT4gcC50cmlnZ2VyQ2FsbGJhY2soJ3N0YXJ0JykpO1xuICAgICAgICB9XG4gICAgICAgIHBsYXllci5vbkRvbmUoKCkgPT4gdGhpcy5maW5pc2goKSk7XG4gICAgICAgIHBsYXllci5vbkRlc3Ryb3koKCkgPT4gdGhpcy5kZXN0cm95KCkpO1xuICAgIH1cbiAgICBfcXVldWVFdmVudChuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBnZXRPclNldERlZmF1bHRWYWx1ZSh0aGlzLl9xdWV1ZWRDYWxsYmFja3MsIG5hbWUsIFtdKS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25Eb25lKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZG9uZScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25Eb25lKGZuKTtcbiAgICB9XG4gICAgb25TdGFydChmbikge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlRXZlbnQoJ3N0YXJ0JywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BsYXllci5vblN0YXJ0KGZuKTtcbiAgICB9XG4gICAgb25EZXN0cm95KGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcXVldWVFdmVudCgnZGVzdHJveScsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wbGF5ZXIub25EZXN0cm95KGZuKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fcGxheWVyLmluaXQoKTtcbiAgICB9XG4gICAgaGFzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVldWVkID8gZmFsc2UgOiB0aGlzLl9wbGF5ZXIuaGFzU3RhcnRlZCgpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnBsYXkoKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgICF0aGlzLnF1ZXVlZCAmJiB0aGlzLl9wbGF5ZXIucGF1c2UoKTtcbiAgICB9XG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgIXRoaXMucXVldWVkICYmIHRoaXMuX3BsYXllci5yZXN0YXJ0KCk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5fcGxheWVyLmZpbmlzaCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICAhdGhpcy5xdWV1ZWQgJiYgdGhpcy5fcGxheWVyLnJlc2V0KCk7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHApIHtcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnNldFBvc2l0aW9uKHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZWQgPyAwIDogdGhpcy5fcGxheWVyLmdldFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0cmlnZ2VyQ2FsbGJhY2socGhhc2VOYW1lKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9wbGF5ZXI7XG4gICAgICAgIGlmIChwLnRyaWdnZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgcC50cmlnZ2VyQ2FsbGJhY2socGhhc2VOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlbGV0ZU9yVW5zZXRJbk1hcChtYXAsIGtleSwgdmFsdWUpIHtcbiAgICBsZXQgY3VycmVudFZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoY3VycmVudFZhbHVlcykge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudFZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFZhbHVlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmFsdWVzO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVHJpZ2dlclZhbHVlKHZhbHVlKSB7XG4gICAgLy8gd2UgdXNlIGAhPSBudWxsYCBoZXJlIGJlY2F1c2UgaXQncyB0aGUgbW9zdCBzaW1wbGVcbiAgICAvLyB3YXkgdG8gdGVzdCBhZ2FpbnN0IGEgXCJmYWxzeVwiIHZhbHVlIHdpdGhvdXQgbWl4aW5nXG4gICAgLy8gaW4gZW1wdHkgc3RyaW5ncyBvciBhIHplcm8gdmFsdWUuIERPIE5PVCBPUFRJTUlaRS5cbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGVbJ25vZGVUeXBlJ10gPT09IDE7XG59XG5mdW5jdGlvbiBpc1RyaWdnZXJFdmVudFZhbGlkKGV2ZW50TmFtZSkge1xuICAgIHJldHVybiBldmVudE5hbWUgPT0gJ3N0YXJ0JyB8fCBldmVudE5hbWUgPT0gJ2RvbmUnO1xufVxuZnVuY3Rpb24gY2xvYWtFbGVtZW50KGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogJ25vbmUnO1xuICAgIHJldHVybiBvbGRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGNsb2FrQW5kQ29tcHV0ZVN0eWxlcyh2YWx1ZXNNYXAsIGRyaXZlciwgZWxlbWVudHMsIGVsZW1lbnRQcm9wc01hcCwgZGVmYXVsdFN0eWxlKSB7XG4gICAgY29uc3QgY2xvYWtWYWxzID0gW107XG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IGNsb2FrVmFscy5wdXNoKGNsb2FrRWxlbWVudChlbGVtZW50KSkpO1xuICAgIGNvbnN0IGZhaWxlZEVsZW1lbnRzID0gW107XG4gICAgZWxlbWVudFByb3BzTWFwLmZvckVhY2goKHByb3BzLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZHJpdmVyLmNvbXB1dGVTdHlsZShlbGVtZW50LCBwcm9wLCBkZWZhdWx0U3R5bGUpO1xuICAgICAgICAgICAgc3R5bGVzLnNldChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBlYXN5IHdheSB0byBkZXRlY3QgdGhpcyBiZWNhdXNlIGEgc3ViIGVsZW1lbnQgY291bGQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgLy8gYnkgYSBwYXJlbnQgYW5pbWF0aW9uIGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQuXG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFtSRU1PVkFMX0ZMQUddID0gTlVMTF9SRU1PVkVEX1FVRVJJRURfU1RBVEU7XG4gICAgICAgICAgICAgICAgZmFpbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlc01hcC5zZXQoZWxlbWVudCwgc3R5bGVzKTtcbiAgICB9KTtcbiAgICAvLyB3ZSB1c2UgYSBpbmRleCB2YXJpYWJsZSBoZXJlIHNpbmNlIFNldC5mb3JFYWNoKGEsIGkpIGRvZXMgbm90IHJldHVyblxuICAgIC8vIGFuIGluZGV4IHZhbHVlIGZvciB0aGUgY2xvc3VyZSAoYnV0IGluc3RlYWQganVzdCB0aGUgdmFsdWUpXG4gICAgbGV0IGkgPSAwO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiBjbG9ha0VsZW1lbnQoZWxlbWVudCwgY2xvYWtWYWxzW2krK10pKTtcbiAgICByZXR1cm4gZmFpbGVkRWxlbWVudHM7XG59XG4vKlxuU2luY2UgdGhlIEFuZ3VsYXIgcmVuZGVyZXIgY29kZSB3aWxsIHJldHVybiBhIGNvbGxlY3Rpb24gb2YgaW5zZXJ0ZWRcbm5vZGVzIGluIGFsbCBhcmVhcyBvZiBhIERPTSB0cmVlLCBpdCdzIHVwIHRvIHRoaXMgYWxnb3JpdGhtIHRvIGZpZ3VyZVxub3V0IHdoaWNoIG5vZGVzIGFyZSByb290cyBmb3IgZWFjaCBhbmltYXRpb24gQHRyaWdnZXIuXG5cbkJ5IHBsYWNpbmcgZWFjaCBpbnNlcnRlZCBub2RlIGludG8gYSBTZXQgYW5kIHRyYXZlcnNpbmcgdXB3YXJkcywgaXRcbmlzIHBvc3NpYmxlIHRvIGZpbmQgdGhlIEB0cmlnZ2VyIGVsZW1lbnRzIGFuZCB3ZWxsIGFueSBkaXJlY3QgKnN0YXJcbmluc2VydGlvbiBub2RlcywgaWYgYSBAdHJpZ2dlciByb290IGlzIGZvdW5kIHRoZW4gdGhlIGVudGVyIGVsZW1lbnRcbmlzIHBsYWNlZCBpbnRvIHRoZSBNYXBbQHRyaWdnZXJdIHNwb3QuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUm9vdE1hcChyb290cywgbm9kZXMpIHtcbiAgICBjb25zdCByb290TWFwID0gbmV3IE1hcCgpO1xuICAgIHJvb3RzLmZvckVhY2gocm9vdCA9PiByb290TWFwLnNldChyb290LCBbXSkpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJvb3RNYXA7XG4gICAgY29uc3QgTlVMTF9OT0RFID0gMTtcbiAgICBjb25zdCBub2RlU2V0ID0gbmV3IFNldChub2Rlcyk7XG4gICAgY29uc3QgbG9jYWxSb290TWFwID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gTlVMTF9OT0RFO1xuICAgICAgICBsZXQgcm9vdCA9IGxvY2FsUm9vdE1hcC5nZXQobm9kZSk7XG4gICAgICAgIGlmIChyb290KVxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHJvb3RNYXAuaGFzKHBhcmVudCkpIHsgLy8gbmdJZiBpbnNpZGUgQHRyaWdnZXJcbiAgICAgICAgICAgIHJvb3QgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZVNldC5oYXMocGFyZW50KSkgeyAvLyBuZ0lmIGluc2lkZSBuZ0lmXG4gICAgICAgICAgICByb290ID0gTlVMTF9OT0RFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyByZWN1cnNlIHVwd2FyZHNcbiAgICAgICAgICAgIHJvb3QgPSBnZXRSb290KHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxSb290TWFwLnNldChub2RlLCByb290KTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBnZXRSb290KG5vZGUpO1xuICAgICAgICBpZiAocm9vdCAhPT0gTlVMTF9OT0RFKSB7XG4gICAgICAgICAgICByb290TWFwLmdldChyb290KS5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvb3RNYXA7XG59XG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdD8uYWRkKGNsYXNzTmFtZSk7XG59XG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdD8ucmVtb3ZlKGNsYXNzTmFtZSk7XG59XG5mdW5jdGlvbiByZW1vdmVOb2Rlc0FmdGVyQW5pbWF0aW9uRG9uZShlbmdpbmUsIGVsZW1lbnQsIHBsYXllcnMpIHtcbiAgICBvcHRpbWl6ZUdyb3VwUGxheWVyKHBsYXllcnMpLm9uRG9uZSgoKSA9PiBlbmdpbmUucHJvY2Vzc0xlYXZlTm9kZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBmbGF0dGVuR3JvdXBQbGF5ZXJzKHBsYXllcnMpIHtcbiAgICBjb25zdCBmaW5hbFBsYXllcnMgPSBbXTtcbiAgICBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllcnMsIGZpbmFsUGxheWVycyk7XG4gICAgcmV0dXJuIGZpbmFsUGxheWVycztcbn1cbmZ1bmN0aW9uIF9mbGF0dGVuR3JvdXBQbGF5ZXJzUmVjdXIocGxheWVycywgZmluYWxQbGF5ZXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBsYXllciA9IHBsYXllcnNbaV07XG4gICAgICAgIGlmIChwbGF5ZXIgaW5zdGFuY2VvZiDJtUFuaW1hdGlvbkdyb3VwUGxheWVyKSB7XG4gICAgICAgICAgICBfZmxhdHRlbkdyb3VwUGxheWVyc1JlY3VyKHBsYXllci5wbGF5ZXJzLCBmaW5hbFBsYXllcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWxQbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG9iakVxdWFscyhhLCBiKSB7XG4gICAgY29uc3QgazEgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBjb25zdCBrMiA9IE9iamVjdC5rZXlzKGIpO1xuICAgIGlmIChrMS5sZW5ndGggIT0gazIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9wID0gazFbaV07XG4gICAgICAgIGlmICghYi5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBhW3Byb3BdICE9PSBiW3Byb3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VQb3N0U3R5bGVzQXNQcmUoZWxlbWVudCwgYWxsUHJlU3R5bGVFbGVtZW50cywgYWxsUG9zdFN0eWxlRWxlbWVudHMpIHtcbiAgICBjb25zdCBwb3N0RW50cnkgPSBhbGxQb3N0U3R5bGVFbGVtZW50cy5nZXQoZWxlbWVudCk7XG4gICAgaWYgKCFwb3N0RW50cnkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcHJlRW50cnkgPSBhbGxQcmVTdHlsZUVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICBpZiAocHJlRW50cnkpIHtcbiAgICAgICAgcG9zdEVudHJ5LmZvckVhY2goZGF0YSA9PiBwcmVFbnRyeS5hZGQoZGF0YSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWxsUHJlU3R5bGVFbGVtZW50cy5zZXQoZWxlbWVudCwgcG9zdEVudHJ5KTtcbiAgICB9XG4gICAgYWxsUG9zdFN0eWxlRWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5jbGFzcyBBbmltYXRpb25FbmdpbmUge1xuICAgIGNvbnN0cnVjdG9yKGJvZHlOb2RlLCBfZHJpdmVyLCBfbm9ybWFsaXplcikge1xuICAgICAgICB0aGlzLmJvZHlOb2RlID0gYm9keU5vZGU7XG4gICAgICAgIHRoaXMuX2RyaXZlciA9IF9kcml2ZXI7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBfbm9ybWFsaXplcjtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNhY2hlID0ge307XG4gICAgICAgIC8vIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNvZGUgdGhhdCB1c2VzIHRoaXMgZW5naW5lXG4gICAgICAgIHRoaXMub25SZW1vdmFsQ29tcGxldGUgPSAoZWxlbWVudCwgY29udGV4dCkgPT4geyB9O1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lID0gbmV3IFRyYW5zaXRpb25BbmltYXRpb25FbmdpbmUoYm9keU5vZGUsIF9kcml2ZXIsIF9ub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVFbmdpbmUgPSBuZXcgVGltZWxpbmVBbmltYXRpb25FbmdpbmUoYm9keU5vZGUsIF9kcml2ZXIsIF9ub3JtYWxpemVyKTtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5vblJlbW92YWxDb21wbGV0ZSA9IChlbGVtZW50LCBjb250ZXh0KSA9PiB0aGlzLm9uUmVtb3ZhbENvbXBsZXRlKGVsZW1lbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZWdpc3RlclRyaWdnZXIoY29tcG9uZW50SWQsIG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCwgbmFtZSwgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBjb21wb25lbnRJZCArICctJyArIG5hbWU7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gdGhpcy5fdHJpZ2dlckNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgICAgICAgICBjb25zdCBhc3QgPSBidWlsZEFuaW1hdGlvbkFzdCh0aGlzLl9kcml2ZXIsIG1ldGFkYXRhLCBlcnJvcnMsIHdhcm5pbmdzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdHJpZ2dlckJ1aWxkRmFpbGVkKG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FybmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgd2FyblRyaWdnZXJCdWlsZChuYW1lLCB3YXJuaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyID0gYnVpbGRUcmlnZ2VyKG5hbWUsIGFzdCwgdGhpcy5fbm9ybWFsaXplcik7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQ2FjaGVbY2FjaGVLZXldID0gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyVHJpZ2dlcihuYW1lc3BhY2VJZCwgbmFtZSwgdHJpZ2dlcik7XG4gICAgfVxuICAgIHJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgfVxuICAgIGRlc3Ryb3kobmFtZXNwYWNlSWQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5kZXN0cm95KG5hbWVzcGFjZUlkLCBjb250ZXh0KTtcbiAgICB9XG4gICAgb25JbnNlcnQobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHBhcmVudCwgaW5zZXJ0QmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUuaW5zZXJ0Tm9kZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgcGFyZW50LCBpbnNlcnRCZWZvcmUpO1xuICAgIH1cbiAgICBvblJlbW92ZShuYW1lc3BhY2VJZCwgZWxlbWVudCwgY29udGV4dCwgaXNIb3N0RWxlbWVudCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnJlbW92ZU5vZGUobmFtZXNwYWNlSWQsIGVsZW1lbnQsIGlzSG9zdEVsZW1lbnQgfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICBkaXNhYmxlQW5pbWF0aW9ucyhlbGVtZW50LCBkaXNhYmxlKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUubWFya0VsZW1lbnRBc0Rpc2FibGVkKGVsZW1lbnQsIGRpc2FibGUpO1xuICAgIH1cbiAgICBwcm9jZXNzKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmNoYXJBdCgwKSA9PSAnQCcpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpZCwgYWN0aW9uXSA9IHBhcnNlVGltZWxpbmVDb21tYW5kKHByb3BlcnR5KTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lRW5naW5lLmNvbW1hbmQoaWQsIGVsZW1lbnQsIGFjdGlvbiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uRW5naW5lLnRyaWdnZXIobmFtZXNwYWNlSWQsIGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdGVuKG5hbWVzcGFjZUlkLCBlbGVtZW50LCBldmVudE5hbWUsIGV2ZW50UGhhc2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEBAbGlzdGVuXG4gICAgICAgIGlmIChldmVudE5hbWUuY2hhckF0KDApID09ICdAJykge1xuICAgICAgICAgICAgY29uc3QgW2lkLCBhY3Rpb25dID0gcGFyc2VUaW1lbGluZUNvbW1hbmQoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lbGluZUVuZ2luZS5saXN0ZW4oaWQsIGVsZW1lbnQsIGFjdGlvbiwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uRW5naW5lLmxpc3RlbihuYW1lc3BhY2VJZCwgZWxlbWVudCwgZXZlbnROYW1lLCBldmVudFBoYXNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGZsdXNoKG1pY3JvdGFza0lkID0gLTEpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5mbHVzaChtaWNyb3Rhc2tJZCk7XG4gICAgfVxuICAgIGdldCBwbGF5ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvbkVuZ2luZS5wbGF5ZXJzXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMuX3RpbWVsaW5lRW5naW5lLnBsYXllcnMpO1xuICAgIH1cbiAgICB3aGVuUmVuZGVyaW5nRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zaXRpb25FbmdpbmUud2hlblJlbmRlcmluZ0RvbmUoKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiBgU3BlY2lhbENhc2VkU3R5bGVzYCBpZiBhbmQgd2hlbiBhbnkgc3BlY2lhbCAobm9uIGFuaW1hdGVhYmxlKSBzdHlsZXMgYXJlXG4gKiBkZXRlY3RlZC5cbiAqXG4gKiBJbiBDU1MgdGhlcmUgZXhpc3QgcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBhbmltYXRlZCB3aXRoaW4gYSBrZXlmcmFtZSBhbmltYXRpb25cbiAqICh3aGV0aGVyIGl0IGJlIHZpYSBDU1Mga2V5ZnJhbWVzIG9yIHdlYi1hbmltYXRpb25zKSBhbmQgdGhlIGFuaW1hdGlvbiBpbXBsZW1lbnRhdGlvblxuICogd2lsbCBpZ25vcmUgdGhlbS4gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBkZXRlY3QgdGhvc2Ugc3BlY2lhbCBjYXNlZCBzdHlsZXMgYW5kXG4gKiByZXR1cm4gYSBjb250YWluZXIgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gKlxuICogQHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYFNwZWNpYWxDYXNlZFN0eWxlc2AgaWYgYW55IHNwZWNpYWwgc3R5bGVzIGFyZSBkZXRlY3RlZCBvdGhlcndpc2UgYG51bGxgXG4gKi9cbmZ1bmN0aW9uIHBhY2thZ2VOb25BbmltYXRhYmxlU3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICAgIGxldCBzdGFydFN0eWxlcyA9IG51bGw7XG4gICAgbGV0IGVuZFN0eWxlcyA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGVzKSAmJiBzdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0U3R5bGVzID0gZmlsdGVyTm9uQW5pbWF0YWJsZVN0eWxlcyhzdHlsZXNbMF0pO1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGVuZFN0eWxlcyA9IGZpbHRlck5vbkFuaW1hdGFibGVTdHlsZXMoc3R5bGVzW3N0eWxlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc3R5bGVzIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHN0YXJ0U3R5bGVzID0gZmlsdGVyTm9uQW5pbWF0YWJsZVN0eWxlcyhzdHlsZXMpO1xuICAgIH1cbiAgICByZXR1cm4gKHN0YXJ0U3R5bGVzIHx8IGVuZFN0eWxlcykgPyBuZXcgU3BlY2lhbENhc2VkU3R5bGVzKGVsZW1lbnQsIHN0YXJ0U3R5bGVzLCBlbmRTdHlsZXMpIDpcbiAgICAgICAgbnVsbDtcbn1cbi8qKlxuICogRGVzaWduZWQgdG8gYmUgZXhlY3V0ZWQgZHVyaW5nIGEga2V5ZnJhbWUtYmFzZWQgYW5pbWF0aW9uIHRvIGFwcGx5IGFueSBzcGVjaWFsLWNhc2VkIHN0eWxlcy5cbiAqXG4gKiBXaGVuIHN0YXJ0ZWQgKHdoZW4gdGhlIGBzdGFydCgpYCBtZXRob2QgaXMgcnVuKSB0aGVuIHRoZSBwcm92aWRlZCBgc3RhcnRTdHlsZXNgXG4gKiB3aWxsIGJlIGFwcGxpZWQuIFdoZW4gZmluaXNoZWQgKHdoZW4gdGhlIGBmaW5pc2goKWAgbWV0aG9kIGlzIGNhbGxlZCkgdGhlXG4gKiBgZW5kU3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgYXMgd2VsbCBhbnkgYW55IHN0YXJ0aW5nIHN0eWxlcy4gRmluYWxseSB3aGVuXG4gKiBgZGVzdHJveSgpYCBpcyBjYWxsZWQgdGhlbiBhbGwgc3R5bGVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAqL1xuY2xhc3MgU3BlY2lhbENhc2VkU3R5bGVzIHtcbiAgICBjb25zdHJ1Y3RvcihfZWxlbWVudCwgX3N0YXJ0U3R5bGVzLCBfZW5kU3R5bGVzKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fc3RhcnRTdHlsZXMgPSBfc3RhcnRTdHlsZXM7XG4gICAgICAgIHRoaXMuX2VuZFN0eWxlcyA9IF9lbmRTdHlsZXM7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMCAvKiBTcGVjaWFsQ2FzZWRTdHlsZXNTdGF0ZS5QZW5kaW5nICovO1xuICAgICAgICBsZXQgaW5pdGlhbFN0eWxlcyA9IFNwZWNpYWxDYXNlZFN0eWxlcy5pbml0aWFsU3R5bGVzQnlFbGVtZW50LmdldChfZWxlbWVudCk7XG4gICAgICAgIGlmICghaW5pdGlhbFN0eWxlcykge1xuICAgICAgICAgICAgU3BlY2lhbENhc2VkU3R5bGVzLmluaXRpYWxTdHlsZXNCeUVsZW1lbnQuc2V0KF9lbGVtZW50LCBpbml0aWFsU3R5bGVzID0gbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbml0aWFsU3R5bGVzID0gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA8IDEgLyogU3BlY2lhbENhc2VkU3R5bGVzU3RhdGUuU3RhcnRlZCAqLykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0U3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgc2V0U3R5bGVzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3N0YXJ0U3R5bGVzLCB0aGlzLl9pbml0aWFsU3R5bGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBTcGVjaWFsQ2FzZWRTdHlsZXNTdGF0ZS5TdGFydGVkICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPCAyIC8qIFNwZWNpYWxDYXNlZFN0eWxlc1N0YXRlLkZpbmlzaGVkICovKSB7XG4gICAgICAgICAgICBzZXRTdHlsZXModGhpcy5fZWxlbWVudCwgdGhpcy5faW5pdGlhbFN0eWxlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW5kU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgc2V0U3R5bGVzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2VuZFN0eWxlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gMSAvKiBTcGVjaWFsQ2FzZWRTdHlsZXNTdGF0ZS5TdGFydGVkICovO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA8IDMgLyogU3BlY2lhbENhc2VkU3R5bGVzU3RhdGUuRGVzdHJveWVkICovKSB7XG4gICAgICAgICAgICBTcGVjaWFsQ2FzZWRTdHlsZXMuaW5pdGlhbFN0eWxlc0J5RWxlbWVudC5kZWxldGUodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBlcmFzZVN0eWxlcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9zdGFydFN0eWxlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kU3R5bGVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmRTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICBlcmFzZVN0eWxlcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9lbmRTdHlsZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFN0eWxlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRTdHlsZXModGhpcy5fZWxlbWVudCwgdGhpcy5faW5pdGlhbFN0eWxlcyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IDMgLyogU3BlY2lhbENhc2VkU3R5bGVzU3RhdGUuRGVzdHJveWVkICovO1xuICAgICAgICB9XG4gICAgfVxufVxuU3BlY2lhbENhc2VkU3R5bGVzLmluaXRpYWxTdHlsZXNCeUVsZW1lbnQgPSAoIC8qIEBfX1BVUkVfXyAqL25ldyBXZWFrTWFwKCkpO1xuZnVuY3Rpb24gZmlsdGVyTm9uQW5pbWF0YWJsZVN0eWxlcyhzdHlsZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBzdHlsZXMuZm9yRWFjaCgodmFsLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmIChpc05vbkFuaW1hdGFibGVTdHlsZShwcm9wKSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQocHJvcCwgdmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc05vbkFuaW1hdGFibGVTdHlsZShwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AgPT09ICdkaXNwbGF5JyB8fCBwcm9wID09PSAncG9zaXRpb24nO1xufVxuXG5jbGFzcyBXZWJBbmltYXRpb25zUGxheWVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBrZXlmcmFtZXMsIG9wdGlvbnMsIF9zcGVjaWFsU3R5bGVzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zcGVjaWFsU3R5bGVzID0gX3NwZWNpYWxTdHlsZXM7XG4gICAgICAgIHRoaXMuX29uRG9uZUZucyA9IFtdO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gW107XG4gICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIG9yaWdpbmFsIGZucyBhcmUgcGVyc2lzdGVudCBjb3BpZXMgb2YgdGhlIF9vblN0YXJ0Rm5zIGFuZCBfb25Eb25lRm5zXG4gICAgICAgIC8vIGFuZCBhcmUgdXNlZCB0byByZXNldCB0aGUgZm5zIHRvIHRoZWlyIG9yaWdpbmFsIHZhbHVlcyB1cG9uIHJlc2V0KClcbiAgICAgICAgLy8gKHNpbmNlIHRoZSBfb25TdGFydEZucyBhbmQgX29uRG9uZUZucyBnZXQgZGVsZXRlZCBhZnRlciB0aGV5IGFyZSBjYWxsZWQpXG4gICAgICAgIHRoaXMuX29yaWdpbmFsT25Eb25lRm5zID0gW107XG4gICAgICAgIHRoaXMuX29yaWdpbmFsT25TdGFydEZucyA9IFtdO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudFBsYXllciA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNuYXBzaG90ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IG9wdGlvbnNbJ2R1cmF0aW9uJ107XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gb3B0aW9uc1snZGVsYXknXSB8fCAwO1xuICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLl9kdXJhdGlvbiArIHRoaXMuX2RlbGF5O1xuICAgIH1cbiAgICBfb25GaW5pc2goKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZUZucy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgICAgICAgICAgdGhpcy5fb25Eb25lRm5zID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fYnVpbGRQbGF5ZXIoKTtcbiAgICAgICAgdGhpcy5fcHJlcGFyZVBsYXllckJlZm9yZVN0YXJ0KCk7XG4gICAgfVxuICAgIF9idWlsZFBsYXllcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG92ZXJ3cml0aW5nIGEgcmVhZG9ubHkgcHJvcGVydHlcbiAgICAgICAgdGhpcy5kb21QbGF5ZXIgPSB0aGlzLl90cmlnZ2VyV2ViQW5pbWF0aW9uKHRoaXMuZWxlbWVudCwga2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9maW5hbEtleWZyYW1lID0ga2V5ZnJhbWVzLmxlbmd0aCA/IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0gOiBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZpbmlzaCcsICgpID0+IHRoaXMuX29uRmluaXNoKCkpO1xuICAgIH1cbiAgICBfcHJlcGFyZVBsYXllckJlZm9yZVN0YXJ0KCkge1xuICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIHNvIHRoYXQgdGhlIHBsYXllciBkb2Vzbid0IHN0YXJ0IHRvIGFuaW1hdGUgcmlnaHQgYXdheVxuICAgICAgICBpZiAodGhpcy5fZGVsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0RG9tUGxheWVyU3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZG9tUGxheWVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnZlcnRLZXlmcmFtZXNUb09iamVjdChrZXlmcmFtZXMpIHtcbiAgICAgICAgY29uc3Qga2ZzID0gW107XG4gICAgICAgIGtleWZyYW1lcy5mb3JFYWNoKGZyYW1lID0+IHtcbiAgICAgICAgICAgIGtmcy5wdXNoKE9iamVjdC5mcm9tRW50cmllcyhmcmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGtmcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyV2ViQW5pbWF0aW9uKGVsZW1lbnQsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICAvLyBqc2NvbXBpbGVyIGRvZXNuJ3Qgc2VlbSB0byBrbm93IGFuaW1hdGUgaXMgYSBuYXRpdmUgcHJvcGVydHkgYmVjYXVzZSBpdCdzIG5vdCBmdWxseVxuICAgICAgICAvLyBzdXBwb3J0ZWQgeWV0IGFjcm9zcyBjb21tb24gYnJvd3NlcnMgKHdlIHBvbHlmaWxsIGl0IGZvciBFZGdlL1NhZmFyaSkgW0NMICMxNDM2MzA5MjldXG4gICAgICAgIHJldHVybiBlbGVtZW50WydhbmltYXRlJ10odGhpcy5fY29udmVydEtleWZyYW1lc1RvT2JqZWN0KGtleWZyYW1lcyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvblN0YXJ0KGZuKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsT25TdGFydEZucy5wdXNoKGZuKTtcbiAgICAgICAgdGhpcy5fb25TdGFydEZucy5wdXNoKGZuKTtcbiAgICB9XG4gICAgb25Eb25lKGZuKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsT25Eb25lRm5zLnB1c2goZm4pO1xuICAgICAgICB0aGlzLl9vbkRvbmVGbnMucHVzaChmbik7XG4gICAgfVxuICAgIG9uRGVzdHJveShmbikge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMucHVzaChmbik7XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkUGxheWVyKCk7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgICAgICAgIHRoaXMuX29uU3RhcnRGbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NwZWNpYWxTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVjaWFsU3R5bGVzLnN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb21QbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLnBhdXNlKCk7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIGlmICh0aGlzLl9zcGVjaWFsU3R5bGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9zcGVjaWFsU3R5bGVzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uRmluaXNoKCk7XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmZpbmlzaCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vblN0YXJ0Rm5zID0gdGhpcy5fb3JpZ2luYWxPblN0YXJ0Rm5zO1xuICAgICAgICB0aGlzLl9vbkRvbmVGbnMgPSB0aGlzLl9vcmlnaW5hbE9uRG9uZUZucztcbiAgICB9XG4gICAgX3Jlc2V0RG9tUGxheWVyU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbVBsYXllcikge1xuICAgICAgICAgICAgdGhpcy5kb21QbGF5ZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG4gICAgaGFzU3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0ZWQ7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXREb21QbGF5ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zcGVjaWFsU3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BlY2lhbFN0eWxlcy5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vbkRlc3Ryb3lGbnMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVzdHJveUZucyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHApIHtcbiAgICAgICAgaWYgKHRoaXMuZG9tUGxheWVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9tUGxheWVyLmN1cnJlbnRUaW1lID0gcCAqIHRoaXMudGltZTtcbiAgICB9XG4gICAgZ2V0UG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbVBsYXllci5jdXJyZW50VGltZSAvIHRoaXMudGltZTtcbiAgICB9XG4gICAgZ2V0IHRvdGFsVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5ICsgdGhpcy5fZHVyYXRpb247XG4gICAgfVxuICAgIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAvLyBub3RlOiB0aGlzIGNvZGUgaXMgaW52b2tlZCBvbmx5IHdoZW4gdGhlIGBwbGF5YCBmdW5jdGlvbiB3YXMgY2FsbGVkIHByaW9yIHRvIHRoaXNcbiAgICAgICAgICAgIC8vICh0aHVzIGBoYXNTdGFydGVkYCByZXR1cm5zIHRydWUpLCB0aGlzIGltcGxpZXMgdGhhdCB0aGUgY29kZSB0aGF0IGluaXRpYWxpemVzXG4gICAgICAgICAgICAvLyBgX2ZpbmFsS2V5ZnJhbWVgIGhhcyBhbHNvIGJlZW4gZXhlY3V0ZWQgYW5kIHRoZSBub24tbnVsbCBhc3NlcnRpb24gY2FuIGJlIHNhZmVseSB1c2VkIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSB0aGlzLl9maW5hbEtleWZyYW1lO1xuICAgICAgICAgICAgZmluYWxLZXlmcmFtZS5mb3JFYWNoKCh2YWwsIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnNldChwcm9wLCB0aGlzLl9maW5pc2hlZCA/IHZhbCA6IGNvbXB1dGVTdHlsZSh0aGlzLmVsZW1lbnQsIHByb3ApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTbmFwc2hvdCA9IHN0eWxlcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRyaWdnZXJDYWxsYmFjayhwaGFzZU5hbWUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IHBoYXNlTmFtZSA9PT0gJ3N0YXJ0JyA/IHRoaXMuX29uU3RhcnRGbnMgOiB0aGlzLl9vbkRvbmVGbnM7XG4gICAgICAgIG1ldGhvZHMuZm9yRWFjaChmbiA9PiBmbigpKTtcbiAgICAgICAgbWV0aG9kcy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuY2xhc3MgV2ViQW5pbWF0aW9uc0RyaXZlciB7XG4gICAgdmFsaWRhdGVTdHlsZVByb3BlcnR5KHByb3ApIHtcbiAgICAgICAgLy8gUGVyZm9ybSBhY3R1YWwgdmFsaWRhdGlvbiBpbiBkZXYgbW9kZSBvbmx5LCBpbiBwcm9kIG1vZGUgdGhpcyBjaGVjayBpcyBhIG5vb3AuXG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVN0eWxlUHJvcGVydHkocHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhbGlkYXRlQW5pbWF0YWJsZVN0eWxlUHJvcGVydHkocHJvcCkge1xuICAgICAgICAvLyBQZXJmb3JtIGFjdHVhbCB2YWxpZGF0aW9uIGluIGRldiBtb2RlIG9ubHksIGluIHByb2QgbW9kZSB0aGlzIGNoZWNrIGlzIGEgbm9vcC5cbiAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgY29uc3QgY3NzUHJvcCA9IGNhbWVsQ2FzZVRvRGFzaENhc2UocHJvcCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVXZWJBbmltYXRhYmxlU3R5bGVQcm9wZXJ0eShjc3NQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbWF0Y2hlc0VsZW1lbnQoX2VsZW1lbnQsIF9zZWxlY3Rvcikge1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgaW4gdXNlIHNvIHdlIHJldHVybiBmYWxzZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb250YWluc0VsZW1lbnQoZWxtMSwgZWxtMikge1xuICAgICAgICByZXR1cm4gY29udGFpbnNFbGVtZW50KGVsbTEsIGVsbTIpO1xuICAgIH1cbiAgICBnZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxuICAgIHF1ZXJ5KGVsZW1lbnQsIHNlbGVjdG9yLCBtdWx0aSkge1xuICAgICAgICByZXR1cm4gaW52b2tlUXVlcnkoZWxlbWVudCwgc2VsZWN0b3IsIG11bHRpKTtcbiAgICB9XG4gICAgY29tcHV0ZVN0eWxlKGVsZW1lbnQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbcHJvcF07XG4gICAgfVxuICAgIGFuaW1hdGUoZWxlbWVudCwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgcHJldmlvdXNQbGF5ZXJzID0gW10pIHtcbiAgICAgICAgY29uc3QgZmlsbCA9IGRlbGF5ID09IDAgPyAnYm90aCcgOiAnZm9yd2FyZHMnO1xuICAgICAgICBjb25zdCBwbGF5ZXJPcHRpb25zID0geyBkdXJhdGlvbiwgZGVsYXksIGZpbGwgfTtcbiAgICAgICAgLy8gd2UgY2hlY2sgZm9yIHRoaXMgdG8gYXZvaWQgaGF2aW5nIGEgbnVsbHx1bmRlZmluZWQgdmFsdWUgYmUgcHJlc2VudFxuICAgICAgICAvLyBmb3IgdGhlIGVhc2luZyAod2hpY2ggcmVzdWx0cyBpbiBhbiBlcnJvciBmb3IgY2VydGFpbiBicm93c2VycyAjOTc1MilcbiAgICAgICAgaWYgKGVhc2luZykge1xuICAgICAgICAgICAgcGxheWVyT3B0aW9uc1snZWFzaW5nJ10gPSBlYXNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNTdHlsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzV2ViQW5pbWF0aW9uUGxheWVycyA9IHByZXZpb3VzUGxheWVycy5maWx0ZXIocGxheWVyID0+IHBsYXllciBpbnN0YW5jZW9mIFdlYkFuaW1hdGlvbnNQbGF5ZXIpO1xuICAgICAgICBpZiAoYWxsb3dQcmV2aW91c1BsYXllclN0eWxlc01lcmdlKGR1cmF0aW9uLCBkZWxheSkpIHtcbiAgICAgICAgICAgIHByZXZpb3VzV2ViQW5pbWF0aW9uUGxheWVycy5mb3JFYWNoKHBsYXllciA9PiB7XG4gICAgICAgICAgICAgICAgcGxheWVyLmN1cnJlbnRTbmFwc2hvdC5mb3JFYWNoKCh2YWwsIHByb3ApID0+IHByZXZpb3VzU3R5bGVzLnNldChwcm9wLCB2YWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBfa2V5ZnJhbWVzID0gbm9ybWFsaXplS2V5ZnJhbWVzKGtleWZyYW1lcykubWFwKHN0eWxlcyA9PiBjb3B5U3R5bGVzKHN0eWxlcykpO1xuICAgICAgICBfa2V5ZnJhbWVzID0gYmFsYW5jZVByZXZpb3VzU3R5bGVzSW50b0tleWZyYW1lcyhlbGVtZW50LCBfa2V5ZnJhbWVzLCBwcmV2aW91c1N0eWxlcyk7XG4gICAgICAgIGNvbnN0IHNwZWNpYWxTdHlsZXMgPSBwYWNrYWdlTm9uQW5pbWF0YWJsZVN0eWxlcyhlbGVtZW50LCBfa2V5ZnJhbWVzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBbmltYXRpb25zUGxheWVyKGVsZW1lbnQsIF9rZXlmcmFtZXMsIHBsYXllck9wdGlvbnMsIHNwZWNpYWxTdHlsZXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgYW5pbWF0aW9uIEFQSXMgb2YgdGhlIGFuaW1hdGlvbiBicm93c2VyIHBhY2thZ2UuXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhpcyBwYWNrYWdlLlxuICovXG5cbi8vIFRoaXMgZmlsZSBpcyBub3QgdXNlZCB0byBidWlsZCB0aGlzIG1vZHVsZS4gSXQgaXMgb25seSB1c2VkIGR1cmluZyBlZGl0aW5nXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQW5pbWF0aW9uRHJpdmVyLCBBbmltYXRpb24gYXMgybVBbmltYXRpb24sIEFuaW1hdGlvbkVuZ2luZSBhcyDJtUFuaW1hdGlvbkVuZ2luZSwgQW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyIGFzIMm1QW5pbWF0aW9uU3R5bGVOb3JtYWxpemVyLCBOb29wQW5pbWF0aW9uRHJpdmVyIGFzIMm1Tm9vcEFuaW1hdGlvbkRyaXZlciwgTm9vcEFuaW1hdGlvblN0eWxlTm9ybWFsaXplciBhcyDJtU5vb3BBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIFdlYkFuaW1hdGlvbnNEcml2ZXIgYXMgybVXZWJBbmltYXRpb25zRHJpdmVyLCBXZWJBbmltYXRpb25zUGxheWVyIGFzIMm1V2ViQW5pbWF0aW9uc1BsYXllciwgV2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciBhcyDJtVdlYkFuaW1hdGlvbnNTdHlsZU5vcm1hbGl6ZXIsIGFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZSBhcyDJtWFsbG93UHJldmlvdXNQbGF5ZXJTdHlsZXNNZXJnZSwgY29udGFpbnNFbGVtZW50IGFzIMm1Y29udGFpbnNFbGVtZW50LCBnZXRQYXJlbnRFbGVtZW50IGFzIMm1Z2V0UGFyZW50RWxlbWVudCwgaW52b2tlUXVlcnkgYXMgybVpbnZva2VRdWVyeSwgbm9ybWFsaXplS2V5ZnJhbWVzIGFzIMm1bm9ybWFsaXplS2V5ZnJhbWVzLCB2YWxpZGF0ZVN0eWxlUHJvcGVydHkgYXMgybV2YWxpZGF0ZVN0eWxlUHJvcGVydHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXIubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@angular/animations/fesm2020/browser.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/material/fesm2020/core.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@angular/material/fesm2020/core.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationCurves\": function() { return /* binding */ AnimationCurves; },\n/* harmony export */   \"AnimationDurations\": function() { return /* binding */ AnimationDurations; },\n/* harmony export */   \"DateAdapter\": function() { return /* binding */ DateAdapter; },\n/* harmony export */   \"ErrorStateMatcher\": function() { return /* binding */ ErrorStateMatcher; },\n/* harmony export */   \"MATERIAL_SANITY_CHECKS\": function() { return /* binding */ MATERIAL_SANITY_CHECKS; },\n/* harmony export */   \"MAT_DATE_FORMATS\": function() { return /* binding */ MAT_DATE_FORMATS; },\n/* harmony export */   \"MAT_DATE_LOCALE\": function() { return /* binding */ MAT_DATE_LOCALE; },\n/* harmony export */   \"MAT_DATE_LOCALE_FACTORY\": function() { return /* binding */ MAT_DATE_LOCALE_FACTORY; },\n/* harmony export */   \"MAT_NATIVE_DATE_FORMATS\": function() { return /* binding */ MAT_NATIVE_DATE_FORMATS; },\n/* harmony export */   \"MAT_OPTGROUP\": function() { return /* binding */ MAT_OPTGROUP; },\n/* harmony export */   \"MAT_OPTION_PARENT_COMPONENT\": function() { return /* binding */ MAT_OPTION_PARENT_COMPONENT; },\n/* harmony export */   \"MAT_RIPPLE_GLOBAL_OPTIONS\": function() { return /* binding */ MAT_RIPPLE_GLOBAL_OPTIONS; },\n/* harmony export */   \"MatCommonModule\": function() { return /* binding */ MatCommonModule; },\n/* harmony export */   \"MatLine\": function() { return /* binding */ MatLine; },\n/* harmony export */   \"MatLineModule\": function() { return /* binding */ MatLineModule; },\n/* harmony export */   \"MatNativeDateModule\": function() { return /* binding */ MatNativeDateModule; },\n/* harmony export */   \"MatOptgroup\": function() { return /* binding */ MatOptgroup; },\n/* harmony export */   \"MatOption\": function() { return /* binding */ MatOption; },\n/* harmony export */   \"MatOptionModule\": function() { return /* binding */ MatOptionModule; },\n/* harmony export */   \"MatOptionSelectionChange\": function() { return /* binding */ MatOptionSelectionChange; },\n/* harmony export */   \"MatPseudoCheckbox\": function() { return /* binding */ MatPseudoCheckbox; },\n/* harmony export */   \"MatPseudoCheckboxModule\": function() { return /* binding */ MatPseudoCheckboxModule; },\n/* harmony export */   \"MatRipple\": function() { return /* binding */ MatRipple; },\n/* harmony export */   \"MatRippleModule\": function() { return /* binding */ MatRippleModule; },\n/* harmony export */   \"NativeDateAdapter\": function() { return /* binding */ NativeDateAdapter; },\n/* harmony export */   \"NativeDateModule\": function() { return /* binding */ NativeDateModule; },\n/* harmony export */   \"RippleRef\": function() { return /* binding */ RippleRef; },\n/* harmony export */   \"RippleRenderer\": function() { return /* binding */ RippleRenderer; },\n/* harmony export */   \"ShowOnDirtyErrorStateMatcher\": function() { return /* binding */ ShowOnDirtyErrorStateMatcher; },\n/* harmony export */   \"VERSION\": function() { return /* binding */ VERSION; },\n/* harmony export */   \"_MatOptgroupBase\": function() { return /* binding */ _MatOptgroupBase; },\n/* harmony export */   \"_MatOptionBase\": function() { return /* binding */ _MatOptionBase; },\n/* harmony export */   \"_countGroupLabelsBeforeOption\": function() { return /* binding */ _countGroupLabelsBeforeOption; },\n/* harmony export */   \"_getOptionScrollPosition\": function() { return /* binding */ _getOptionScrollPosition; },\n/* harmony export */   \"defaultRippleAnimationConfig\": function() { return /* binding */ defaultRippleAnimationConfig; },\n/* harmony export */   \"mixinColor\": function() { return /* binding */ mixinColor; },\n/* harmony export */   \"mixinDisableRipple\": function() { return /* binding */ mixinDisableRipple; },\n/* harmony export */   \"mixinDisabled\": function() { return /* binding */ mixinDisabled; },\n/* harmony export */   \"mixinErrorState\": function() { return /* binding */ mixinErrorState; },\n/* harmony export */   \"mixinInitialized\": function() { return /* binding */ mixinInitialized; },\n/* harmony export */   \"mixinTabIndex\": function() { return /* binding */ mixinTabIndex; },\n/* harmony export */   \"setLines\": function() { return /* binding */ setLines; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/platform-browser/animations */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/a11y */ \"./node_modules/@angular/cdk/fesm2020/a11y.mjs\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/bidi */ \"./node_modules/@angular/cdk/fesm2020/bidi.mjs\");\n/* harmony import */ var _angular_cdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/cdk */ \"webpack/sharing/consume/default/@angular/cdk/@angular/cdk\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/fesm2020/platform.mjs\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @angular/cdk/keycodes */ \"./node_modules/@angular/cdk/fesm2020/keycodes.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Current version of Angular Material. */\nconst VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Version('15.2.7');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @docs-private */\nclass AnimationCurves {\n}\nAnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';\nAnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';\nAnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';\nAnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';\n/** @docs-private */\nclass AnimationDurations {\n}\nAnimationDurations.COMPLEX = '375ms';\nAnimationDurations.ENTERING = '225ms';\nAnimationDurations.EXITING = '195ms';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @docs-private */\nfunction MATERIAL_SANITY_CHECKS_FACTORY() {\n    return true;\n}\n/** Injection token that configures whether the Material sanity checks are enabled. */\nconst MATERIAL_SANITY_CHECKS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('mat-sanity-checks', {\n    providedIn: 'root',\n    factory: MATERIAL_SANITY_CHECKS_FACTORY,\n});\n/**\n * Module that captures anything that should be loaded and/or run for *all* Angular Material\n * components. This includes Bidi, etc.\n *\n * This module should be imported to each top-level component module (e.g., MatTabsModule).\n */\nclass MatCommonModule {\n    constructor(highContrastModeDetector, _sanityChecks, _document) {\n        this._sanityChecks = _sanityChecks;\n        this._document = _document;\n        /** Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype). */\n        this._hasDoneGlobalChecks = false;\n        // While A11yModule also does this, we repeat it here to avoid importing A11yModule\n        // in MatCommonModule.\n        highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n        if (!this._hasDoneGlobalChecks) {\n            this._hasDoneGlobalChecks = true;\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // Inject in here so the reference to `Platform` can be removed in production mode.\n                const platform = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform, { optional: true });\n                if (this._checkIsEnabled('doctype')) {\n                    _checkDoctypeIsDefined(this._document);\n                }\n                if (this._checkIsEnabled('theme')) {\n                    _checkThemeIsPresent(this._document, !!platform?.isBrowser);\n                }\n                if (this._checkIsEnabled('version')) {\n                    _checkCdkVersionMatch();\n                }\n            }\n        }\n    }\n    /** Gets whether a specific sanity check is enabled. */\n    _checkIsEnabled(name) {\n        if ((0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__._isTestEnvironment)()) {\n            return false;\n        }\n        if (typeof this._sanityChecks === 'boolean') {\n            return this._sanityChecks;\n        }\n        return !!this._sanityChecks[name];\n    }\n}\nMatCommonModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCommonModule, deps: [{ token: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__.HighContrastModeDetector }, { token: MATERIAL_SANITY_CHECKS, optional: true }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatCommonModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCommonModule, imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule], exports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule] });\nMatCommonModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCommonModule, imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCommonModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule],\n                    exports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_7__.BidiModule],\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__.HighContrastModeDetector }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MATERIAL_SANITY_CHECKS]\n                }] }, { type: Document, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.DOCUMENT]\n                }] }]; } });\n/** Checks that the page has a doctype. */\nfunction _checkDoctypeIsDefined(doc) {\n    if (!doc.doctype) {\n        console.warn('Current document does not have a doctype. This may cause ' +\n            'some Angular Material components not to behave as expected.');\n    }\n}\n/** Checks that a theme has been included. */\nfunction _checkThemeIsPresent(doc, isBrowser) {\n    // We need to assert that the `body` is defined, because these checks run very early\n    // and the `body` won't be defined if the consumer put their scripts in the `head`.\n    if (!doc.body || !isBrowser) {\n        return;\n    }\n    const testElement = doc.createElement('div');\n    testElement.classList.add('mat-theme-loaded-marker');\n    doc.body.appendChild(testElement);\n    const computedStyle = getComputedStyle(testElement);\n    // In some situations the computed style of the test element can be null. For example in\n    // Firefox, the computed style is null if an application is running inside of a hidden iframe.\n    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    if (computedStyle && computedStyle.display !== 'none') {\n        console.warn('Could not find Angular Material core theme. Most Material ' +\n            'components may not work as expected. For more info refer ' +\n            'to the theming guide: https://material.angular.io/guide/theming');\n    }\n    testElement.remove();\n}\n/** Checks whether the Material version matches the CDK version. */\nfunction _checkCdkVersionMatch() {\n    if (VERSION.full !== _angular_cdk__WEBPACK_IMPORTED_MODULE_1__.VERSION.full) {\n        console.warn('The Angular Material version (' +\n            VERSION.full +\n            ') does not match ' +\n            'the Angular CDK version (' +\n            _angular_cdk__WEBPACK_IMPORTED_MODULE_1__.VERSION.full +\n            ').\\n' +\n            'Please ensure the versions of these two packages exactly match.');\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mixinDisabled(base) {\n    return class extends base {\n        get disabled() {\n            return this._disabled;\n        }\n        set disabled(value) {\n            this._disabled = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceBooleanProperty)(value);\n        }\n        constructor(...args) {\n            super(...args);\n            this._disabled = false;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mixinColor(base, defaultColor) {\n    return class extends base {\n        get color() {\n            return this._color;\n        }\n        set color(value) {\n            const colorPalette = value || this.defaultColor;\n            if (colorPalette !== this._color) {\n                if (this._color) {\n                    this._elementRef.nativeElement.classList.remove(`mat-${this._color}`);\n                }\n                if (colorPalette) {\n                    this._elementRef.nativeElement.classList.add(`mat-${colorPalette}`);\n                }\n                this._color = colorPalette;\n            }\n        }\n        constructor(...args) {\n            super(...args);\n            this.defaultColor = defaultColor;\n            // Set the default color that can be specified from the mixin.\n            this.color = defaultColor;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mixinDisableRipple(base) {\n    return class extends base {\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() {\n            return this._disableRipple;\n        }\n        set disableRipple(value) {\n            this._disableRipple = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceBooleanProperty)(value);\n        }\n        constructor(...args) {\n            super(...args);\n            this._disableRipple = false;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mixinTabIndex(base, defaultTabIndex = 0) {\n    return class extends base {\n        get tabIndex() {\n            return this.disabled ? -1 : this._tabIndex;\n        }\n        set tabIndex(value) {\n            // If the specified tabIndex value is null or undefined, fall back to the default value.\n            this._tabIndex = value != null ? (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceNumberProperty)(value) : this.defaultTabIndex;\n        }\n        constructor(...args) {\n            super(...args);\n            this._tabIndex = defaultTabIndex;\n            this.defaultTabIndex = defaultTabIndex;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction mixinErrorState(base) {\n    return class extends base {\n        /** Updates the error state based on the provided error state matcher. */\n        updateErrorState() {\n            const oldState = this.errorState;\n            const parent = this._parentFormGroup || this._parentForm;\n            const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;\n            const control = this.ngControl ? this.ngControl.control : null;\n            const newState = matcher.isErrorState(control, parent);\n            if (newState !== oldState) {\n                this.errorState = newState;\n                this.stateChanges.next();\n            }\n        }\n        constructor(...args) {\n            super(...args);\n            /** Whether the component is in an error state. */\n            this.errorState = false;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with an initialized property that will emits when ngOnInit ends. */\nfunction mixinInitialized(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            /** Whether this directive has been marked as initialized. */\n            this._isInitialized = false;\n            /**\n             * List of subscribers that subscribed before the directive was initialized. Should be notified\n             * during _markInitialized. Set to null after pending subscribers are notified, and should\n             * not expect to be populated after.\n             */\n            this._pendingSubscribers = [];\n            /**\n             * Observable stream that emits when the directive initializes. If already initialized, the\n             * subscriber is stored to be notified once _markInitialized is called.\n             */\n            this.initialized = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Observable(subscriber => {\n                // If initialized, immediately notify the subscriber. Otherwise store the subscriber to notify\n                // when _markInitialized is called.\n                if (this._isInitialized) {\n                    this._notifySubscriber(subscriber);\n                }\n                else {\n                    this._pendingSubscribers.push(subscriber);\n                }\n            });\n        }\n        /**\n         * Marks the state as initialized and notifies pending subscribers. Should be called at the end\n         * of ngOnInit.\n         * @docs-private\n         */\n        _markInitialized() {\n            if (this._isInitialized && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('This directive has already been marked as initialized and ' +\n                    'should not be called twice.');\n            }\n            this._isInitialized = true;\n            this._pendingSubscribers.forEach(this._notifySubscriber);\n            this._pendingSubscribers = null;\n        }\n        /** Emits and completes the subscriber stream (should only emit once). */\n        _notifySubscriber(subscriber) {\n            subscriber.next();\n            subscriber.complete();\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** InjectionToken for datepicker that can be used to override default locale code. */\nconst MAT_DATE_LOCALE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('MAT_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MAT_DATE_LOCALE_FACTORY,\n});\n/** @docs-private */\nfunction MAT_DATE_LOCALE_FACTORY() {\n    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.LOCALE_ID);\n}\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\nclass DateAdapter {\n    constructor() {\n        this._localeChanges = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();\n        /** A stream that emits when the locale changes. */\n        this.localeChanges = this._localeChanges;\n    }\n    /**\n     * Given a potential date object, returns that same date object if it is\n     * a valid date, or `null` if it's not a valid date.\n     * @param obj The object to check.\n     * @returns A date or `null`.\n     */\n    getValidDateOrNull(obj) {\n        return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;\n    }\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value) {\n        if (value == null || (this.isDateInstance(value) && this.isValid(value))) {\n            return value;\n        }\n        return this.invalid();\n    }\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first, second) {\n        return (this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second));\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first, second) {\n        if (first && second) {\n            let firstValid = this.isValid(first);\n            let secondValid = this.isValid(second);\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n            return firstValid == secondValid;\n        }\n        return first == second;\n    }\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date, min, max) {\n        if (min && this.compareDate(date, min) < 0) {\n            return min;\n        }\n        if (max && this.compareDate(date, max) > 0) {\n            return max;\n        }\n        return date;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_DATE_FORMATS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('mat-date-formats');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings an with out of bounds month, date, etc.\n */\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/** Creates an array and fills it with values. */\nfunction range(length, valueFunction) {\n    const valuesArray = Array(length);\n    for (let i = 0; i < length; i++) {\n        valuesArray[i] = valueFunction(i);\n    }\n    return valuesArray;\n}\n/** Adapts the native JS Date for use with cdk-based components that work with dates. */\nclass NativeDateAdapter extends DateAdapter {\n    constructor(matDateLocale, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 14.0.0\n     */\n    _platform) {\n        super();\n        /**\n         * @deprecated No longer being used. To be removed.\n         * @breaking-change 14.0.0\n         */\n        this.useUtcForDisplay = false;\n        super.setLocale(matDateLocale);\n    }\n    getYear(date) {\n        return date.getFullYear();\n    }\n    getMonth(date) {\n        return date.getMonth();\n    }\n    getDate(date) {\n        return date.getDate();\n    }\n    getDayOfWeek(date) {\n        return date.getDay();\n    }\n    getMonthNames(style) {\n        const dtf = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });\n        return range(12, i => this._format(dtf, new Date(2017, i, 1)));\n    }\n    getDateNames() {\n        const dtf = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });\n        return range(31, i => this._format(dtf, new Date(2017, 0, i + 1)));\n    }\n    getDayOfWeekNames(style) {\n        const dtf = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });\n        return range(7, i => this._format(dtf, new Date(2017, 0, i + 1)));\n    }\n    getYearName(date) {\n        const dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });\n        return this._format(dtf, date);\n    }\n    getFirstDayOfWeek() {\n        // We can't tell using native JS Date what the first day of the week is, we default to Sunday.\n        return 0;\n    }\n    getNumDaysInMonth(date) {\n        return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n    }\n    clone(date) {\n        return new Date(date.getTime());\n    }\n    createDate(year, month, date) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            // Check for invalid month and date (except upper bound on date which we have to check after\n            // creating the Date).\n            if (month < 0 || month > 11) {\n                throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n            }\n            if (date < 1) {\n                throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n            }\n        }\n        let result = this._createDateWithOverflow(year, month, date);\n        // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n        if (result.getMonth() != month && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n        }\n        return result;\n    }\n    today() {\n        return new Date();\n    }\n    parse(value, parseFormat) {\n        // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n        // parameters.\n        if (typeof value == 'number') {\n            return new Date(value);\n        }\n        return value ? new Date(Date.parse(value)) : null;\n    }\n    format(date, displayFormat) {\n        if (!this.isValid(date)) {\n            throw Error('NativeDateAdapter: Cannot format invalid date.');\n        }\n        const dtf = new Intl.DateTimeFormat(this.locale, { ...displayFormat, timeZone: 'utc' });\n        return this._format(dtf, date);\n    }\n    addCalendarYears(date, years) {\n        return this.addCalendarMonths(date, years * 12);\n    }\n    addCalendarMonths(date, months) {\n        let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\n        // It's possible to wind up in the wrong month if the original month has more days than the new\n        // month. In this case we want to go to the last day of the desired month.\n        // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n        // guarantee this.\n        if (this.getMonth(newDate) != (((this.getMonth(date) + months) % 12) + 12) % 12) {\n            newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n        }\n        return newDate;\n    }\n    addCalendarDays(date, days) {\n        return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\n    }\n    toIso8601(date) {\n        return [\n            date.getUTCFullYear(),\n            this._2digit(date.getUTCMonth() + 1),\n            this._2digit(date.getUTCDate()),\n        ].join('-');\n    }\n    /**\n     * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n     * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n     * invalid date for all other values.\n     */\n    deserialize(value) {\n        if (typeof value === 'string') {\n            if (!value) {\n                return null;\n            }\n            // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n            // string is the right format first.\n            if (ISO_8601_REGEX.test(value)) {\n                let date = new Date(value);\n                if (this.isValid(date)) {\n                    return date;\n                }\n            }\n        }\n        return super.deserialize(value);\n    }\n    isDateInstance(obj) {\n        return obj instanceof Date;\n    }\n    isValid(date) {\n        return !isNaN(date.getTime());\n    }\n    invalid() {\n        return new Date(NaN);\n    }\n    /** Creates a date but allows the month and date to overflow. */\n    _createDateWithOverflow(year, month, date) {\n        // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n        // To work around this we use `setFullYear` and `setHours` instead.\n        const d = new Date();\n        d.setFullYear(year, month, date);\n        d.setHours(0, 0, 0, 0);\n        return d;\n    }\n    /**\n     * Pads a number to make it two digits.\n     * @param n The number to pad.\n     * @returns The padded number.\n     */\n    _2digit(n) {\n        return ('00' + n).slice(-2);\n    }\n    /**\n     * When converting Date object to string, javascript built-in functions may return wrong\n     * results because it applies its internal DST rules. The DST rules around the world change\n     * very frequently, and the current valid rule is not always valid in previous years though.\n     * We work around this problem building a new Date object which has its internal UTC\n     * representation with the local date and time.\n     * @param dtf Intl.DateTimeFormat object, containing the desired string format. It must have\n     *    timeZone set to 'utc' to work fine.\n     * @param date Date from which we want to get the string representation according to dtf\n     * @returns A Date object with its UTC representation based on the passed in date info\n     */\n    _format(dtf, date) {\n        // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n        // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n        const d = new Date();\n        d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n        d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n        return dtf.format(d);\n    }\n}\nNativeDateAdapter.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateAdapter, deps: [{ token: MAT_DATE_LOCALE, optional: true }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nNativeDateAdapter.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateAdapter });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateAdapter, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MAT_DATE_LOCALE]\n                }] }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_NATIVE_DATE_FORMATS = {\n    parse: {\n        dateInput: null,\n    },\n    display: {\n        dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },\n        monthYearLabel: { year: 'numeric', month: 'short' },\n        dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n        monthYearA11yLabel: { year: 'numeric', month: 'long' },\n    },\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass NativeDateModule {\n}\nNativeDateModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nNativeDateModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateModule });\nNativeDateModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateModule, providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NativeDateModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    providers: [{ provide: DateAdapter, useClass: NativeDateAdapter }],\n                }]\n        }] });\nclass MatNativeDateModule {\n}\nMatNativeDateModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNativeDateModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatNativeDateModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNativeDateModule, imports: [NativeDateModule] });\nMatNativeDateModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNativeDateModule, providers: [{ provide: MAT_DATE_FORMATS, useValue: MAT_NATIVE_DATE_FORMATS }], imports: [NativeDateModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNativeDateModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [NativeDateModule],\n                    providers: [{ provide: MAT_DATE_FORMATS, useValue: MAT_NATIVE_DATE_FORMATS }],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Error state matcher that matches when a control is invalid and dirty. */\nclass ShowOnDirtyErrorStateMatcher {\n    isErrorState(control, form) {\n        return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n    }\n}\nShowOnDirtyErrorStateMatcher.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ShowOnDirtyErrorStateMatcher, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nShowOnDirtyErrorStateMatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ShowOnDirtyErrorStateMatcher });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ShowOnDirtyErrorStateMatcher, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }] });\n/** Provider that defines how form controls behave with regards to displaying error messages. */\nclass ErrorStateMatcher {\n    isErrorState(control, form) {\n        return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n    }\n}\nErrorStateMatcher.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ErrorStateMatcher, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nErrorStateMatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ErrorStateMatcher, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ErrorStateMatcher, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Shared directive to count lines inside a text area, such as a list item.\n * Line elements can be extracted with a @ContentChildren(MatLine) query, then\n * counted by checking the query list's length.\n */\nclass MatLine {\n}\nMatLine.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLine, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatLine.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatLine, selector: \"[mat-line], [matLine]\", host: { classAttribute: \"mat-line\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLine, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[mat-line], [matLine]',\n                    host: { 'class': 'mat-line' },\n                }]\n        }] });\n/**\n * Helper that takes a query list of lines and sets the correct class on the host.\n * @docs-private\n */\nfunction setLines(lines, element, prefix = 'mat') {\n    // Note: doesn't need to unsubscribe, because `changes`\n    // gets completed by Angular when the view is destroyed.\n    lines.changes.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.startWith)(lines)).subscribe(({ length }) => {\n        setClass(element, `${prefix}-2-line`, false);\n        setClass(element, `${prefix}-3-line`, false);\n        setClass(element, `${prefix}-multi-line`, false);\n        if (length === 2 || length === 3) {\n            setClass(element, `${prefix}-${length}-line`, true);\n        }\n        else if (length > 3) {\n            setClass(element, `${prefix}-multi-line`, true);\n        }\n    });\n}\n/** Adds or removes a class from an element. */\nfunction setClass(element, className, isAdd) {\n    element.nativeElement.classList.toggle(className, isAdd);\n}\nclass MatLineModule {\n}\nMatLineModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLineModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatLineModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLineModule, declarations: [MatLine], imports: [MatCommonModule], exports: [MatLine, MatCommonModule] });\nMatLineModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLineModule, imports: [MatCommonModule, MatCommonModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatLineModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [MatCommonModule],\n                    exports: [MatLine, MatCommonModule],\n                    declarations: [MatLine],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to a previously launched ripple element.\n */\nclass RippleRef {\n    constructor(_renderer, \n    /** Reference to the ripple HTML element. */\n    element, \n    /** Ripple configuration used for the ripple. */\n    config, \n    /* Whether animations are forcibly disabled for ripples through CSS. */\n    _animationForciblyDisabledThroughCss = false) {\n        this._renderer = _renderer;\n        this.element = element;\n        this.config = config;\n        this._animationForciblyDisabledThroughCss = _animationForciblyDisabledThroughCss;\n        /** Current state of the ripple. */\n        this.state = 3 /* RippleState.HIDDEN */;\n    }\n    /** Fades out the ripple element. */\n    fadeOut() {\n        this._renderer.fadeOutRipple(this);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions$1 = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.normalizePassiveListenerOptions)({\n    passive: true,\n    capture: true,\n});\n/** Manages events through delegation so that as few event handlers as possible are bound. */\nclass RippleEventManager {\n    constructor() {\n        this._events = new Map();\n        /** Event handler that is bound and which dispatches the events to the different targets. */\n        this._delegateEventHandler = (event) => {\n            const target = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__._getEventTarget)(event);\n            if (target) {\n                this._events.get(event.type)?.forEach((handlers, element) => {\n                    if (element === target || element.contains(target)) {\n                        handlers.forEach(handler => handler.handleEvent(event));\n                    }\n                });\n            }\n        };\n    }\n    /** Adds an event handler. */\n    addHandler(ngZone, name, element, handler) {\n        const handlersForEvent = this._events.get(name);\n        if (handlersForEvent) {\n            const handlersForElement = handlersForEvent.get(element);\n            if (handlersForElement) {\n                handlersForElement.add(handler);\n            }\n            else {\n                handlersForEvent.set(element, new Set([handler]));\n            }\n        }\n        else {\n            this._events.set(name, new Map([[element, new Set([handler])]]));\n            ngZone.runOutsideAngular(() => {\n                document.addEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);\n            });\n        }\n    }\n    /** Removes an event handler. */\n    removeHandler(name, element, handler) {\n        const handlersForEvent = this._events.get(name);\n        if (!handlersForEvent) {\n            return;\n        }\n        const handlersForElement = handlersForEvent.get(element);\n        if (!handlersForElement) {\n            return;\n        }\n        handlersForElement.delete(handler);\n        if (handlersForElement.size === 0) {\n            handlersForEvent.delete(element);\n        }\n        if (handlersForEvent.size === 0) {\n            this._events.delete(name);\n            document.removeEventListener(name, this._delegateEventHandler, passiveCapturingEventOptions$1);\n        }\n    }\n}\n\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nconst defaultRippleAnimationConfig = {\n    enterDuration: 225,\n    exitDuration: 150,\n};\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n/** Options used to bind a passive capturing event. */\nconst passiveCapturingEventOptions = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.normalizePassiveListenerOptions)({\n    passive: true,\n    capture: true,\n});\n/** Events that signal that the pointer is down. */\nconst pointerDownEvents = ['mousedown', 'touchstart'];\n/** Events that signal that the pointer is up. */\nconst pointerUpEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nclass RippleRenderer {\n    constructor(_target, _ngZone, elementOrElementRef, _platform) {\n        this._target = _target;\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /** Whether the pointer is currently down or not. */\n        this._isPointerDown = false;\n        /**\n         * Map of currently active ripple references.\n         * The ripple reference is mapped to its element event listeners.\n         * The reason why `| null` is used is that event listeners are added only\n         * when the condition is truthy (see the `_startFadeOutTransition` method).\n         */\n        this._activeRipples = new Map();\n        /** Whether pointer-up event listeners have been registered. */\n        this._pointerUpEventsRegistered = false;\n        // Only do anything if we're on the browser.\n        if (_platform.isBrowser) {\n            this._containerElement = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceElement)(elementOrElementRef);\n        }\n    }\n    /**\n     * Fades in a ripple at the given coordinates.\n     * @param x Coordinate within the element, along the X axis at which to start the ripple.\n     * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n     * @param config Extra ripple options.\n     */\n    fadeInRipple(x, y, config = {}) {\n        const containerRect = (this._containerRect =\n            this._containerRect || this._containerElement.getBoundingClientRect());\n        const animationConfig = { ...defaultRippleAnimationConfig, ...config.animation };\n        if (config.centered) {\n            x = containerRect.left + containerRect.width / 2;\n            y = containerRect.top + containerRect.height / 2;\n        }\n        const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n        const offsetX = x - containerRect.left;\n        const offsetY = y - containerRect.top;\n        const enterDuration = animationConfig.enterDuration;\n        const ripple = document.createElement('div');\n        ripple.classList.add('mat-ripple-element');\n        ripple.style.left = `${offsetX - radius}px`;\n        ripple.style.top = `${offsetY - radius}px`;\n        ripple.style.height = `${radius * 2}px`;\n        ripple.style.width = `${radius * 2}px`;\n        // If a custom color has been specified, set it as inline style. If no color is\n        // set, the default color will be applied through the ripple theme styles.\n        if (config.color != null) {\n            ripple.style.backgroundColor = config.color;\n        }\n        ripple.style.transitionDuration = `${enterDuration}ms`;\n        this._containerElement.appendChild(ripple);\n        // By default the browser does not recalculate the styles of dynamically created\n        // ripple elements. This is critical to ensure that the `scale` animates properly.\n        // We enforce a style recalculation by calling `getComputedStyle` and *accessing* a property.\n        // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n        const computedStyles = window.getComputedStyle(ripple);\n        const userTransitionProperty = computedStyles.transitionProperty;\n        const userTransitionDuration = computedStyles.transitionDuration;\n        // Note: We detect whether animation is forcibly disabled through CSS (e.g. through\n        // `transition: none` or `display: none`). This is technically unexpected since animations are\n        // controlled through the animation config, but this exists for backwards compatibility. This\n        // logic does not need to be super accurate since it covers some edge cases which can be easily\n        // avoided by users.\n        const animationForciblyDisabledThroughCss = userTransitionProperty === 'none' ||\n            // Note: The canonical unit for serialized CSS `<time>` properties is seconds. Additionally\n            // some browsers expand the duration for every property (in our case `opacity` and `transform`).\n            userTransitionDuration === '0s' ||\n            userTransitionDuration === '0s, 0s' ||\n            // If the container is 0x0, it's likely `display: none`.\n            (containerRect.width === 0 && containerRect.height === 0);\n        // Exposed reference to the ripple that will be returned.\n        const rippleRef = new RippleRef(this, ripple, config, animationForciblyDisabledThroughCss);\n        // Start the enter animation by setting the transform/scale to 100%. The animation will\n        // execute as part of this statement because we forced a style recalculation before.\n        // Note: We use a 3d transform here in order to avoid an issue in Safari where\n        // the ripples aren't clipped when inside the shadow DOM (see #24028).\n        ripple.style.transform = 'scale3d(1, 1, 1)';\n        rippleRef.state = 0 /* RippleState.FADING_IN */;\n        if (!config.persistent) {\n            this._mostRecentTransientRipple = rippleRef;\n        }\n        let eventListeners = null;\n        // Do not register the `transition` event listener if fade-in and fade-out duration\n        // are set to zero. The events won't fire anyway and we can save resources here.\n        if (!animationForciblyDisabledThroughCss && (enterDuration || animationConfig.exitDuration)) {\n            this._ngZone.runOutsideAngular(() => {\n                const onTransitionEnd = () => this._finishRippleTransition(rippleRef);\n                const onTransitionCancel = () => this._destroyRipple(rippleRef);\n                ripple.addEventListener('transitionend', onTransitionEnd);\n                // If the transition is cancelled (e.g. due to DOM removal), we destroy the ripple\n                // directly as otherwise we would keep it part of the ripple container forever.\n                // https://www.w3.org/TR/css-transitions-1/#:~:text=no%20longer%20in%20the%20document.\n                ripple.addEventListener('transitioncancel', onTransitionCancel);\n                eventListeners = { onTransitionEnd, onTransitionCancel };\n            });\n        }\n        // Add the ripple reference to the list of all active ripples.\n        this._activeRipples.set(rippleRef, eventListeners);\n        // In case there is no fade-in transition duration, we need to manually call the transition\n        // end listener because `transitionend` doesn't fire if there is no transition.\n        if (animationForciblyDisabledThroughCss || !enterDuration) {\n            this._finishRippleTransition(rippleRef);\n        }\n        return rippleRef;\n    }\n    /** Fades out a ripple reference. */\n    fadeOutRipple(rippleRef) {\n        // For ripples already fading out or hidden, this should be a noop.\n        if (rippleRef.state === 2 /* RippleState.FADING_OUT */ || rippleRef.state === 3 /* RippleState.HIDDEN */) {\n            return;\n        }\n        const rippleEl = rippleRef.element;\n        const animationConfig = { ...defaultRippleAnimationConfig, ...rippleRef.config.animation };\n        // This starts the fade-out transition and will fire the transition end listener that\n        // removes the ripple element from the DOM.\n        rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n        rippleEl.style.opacity = '0';\n        rippleRef.state = 2 /* RippleState.FADING_OUT */;\n        // In case there is no fade-out transition duration, we need to manually call the\n        // transition end listener because `transitionend` doesn't fire if there is no transition.\n        if (rippleRef._animationForciblyDisabledThroughCss || !animationConfig.exitDuration) {\n            this._finishRippleTransition(rippleRef);\n        }\n    }\n    /** Fades out all currently active ripples. */\n    fadeOutAll() {\n        this._getActiveRipples().forEach(ripple => ripple.fadeOut());\n    }\n    /** Fades out all currently active non-persistent ripples. */\n    fadeOutAllNonPersistent() {\n        this._getActiveRipples().forEach(ripple => {\n            if (!ripple.config.persistent) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    /** Sets up the trigger event listeners */\n    setupTriggerEvents(elementOrElementRef) {\n        const element = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceElement)(elementOrElementRef);\n        if (!this._platform.isBrowser || !element || element === this._triggerElement) {\n            return;\n        }\n        // Remove all previously registered event listeners from the trigger element.\n        this._removeTriggerEvents();\n        this._triggerElement = element;\n        // Use event delegation for the trigger events since they're\n        // set up during creation and are performance-sensitive.\n        pointerDownEvents.forEach(type => {\n            RippleRenderer._eventManager.addHandler(this._ngZone, type, element, this);\n        });\n    }\n    /**\n     * Handles all registered events.\n     * @docs-private\n     */\n    handleEvent(event) {\n        if (event.type === 'mousedown') {\n            this._onMousedown(event);\n        }\n        else if (event.type === 'touchstart') {\n            this._onTouchStart(event);\n        }\n        else {\n            this._onPointerUp();\n        }\n        // If pointer-up events haven't been registered yet, do so now.\n        // We do this on-demand in order to reduce the total number of event listeners\n        // registered by the ripples, which speeds up the rendering time for large UIs.\n        if (!this._pointerUpEventsRegistered) {\n            // The events for hiding the ripple are bound directly on the trigger, because:\n            // 1. Some of them occur frequently (e.g. `mouseleave`) and any advantage we get from\n            // delegation will be diminished by having to look through all the data structures often.\n            // 2. They aren't as performance-sensitive, because they're bound only after the user\n            // has interacted with an element.\n            this._ngZone.runOutsideAngular(() => {\n                pointerUpEvents.forEach(type => {\n                    this._triggerElement.addEventListener(type, this, passiveCapturingEventOptions);\n                });\n            });\n            this._pointerUpEventsRegistered = true;\n        }\n    }\n    /** Method that will be called if the fade-in or fade-in transition completed. */\n    _finishRippleTransition(rippleRef) {\n        if (rippleRef.state === 0 /* RippleState.FADING_IN */) {\n            this._startFadeOutTransition(rippleRef);\n        }\n        else if (rippleRef.state === 2 /* RippleState.FADING_OUT */) {\n            this._destroyRipple(rippleRef);\n        }\n    }\n    /**\n     * Starts the fade-out transition of the given ripple if it's not persistent and the pointer\n     * is not held down anymore.\n     */\n    _startFadeOutTransition(rippleRef) {\n        const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n        const { persistent } = rippleRef.config;\n        rippleRef.state = 1 /* RippleState.VISIBLE */;\n        // When the timer runs out while the user has kept their pointer down, we want to\n        // keep only the persistent ripples and the latest transient ripple. We do this,\n        // because we don't want stacked transient ripples to appear after their enter\n        // animation has finished.\n        if (!persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n            rippleRef.fadeOut();\n        }\n    }\n    /** Destroys the given ripple by removing it from the DOM and updating its state. */\n    _destroyRipple(rippleRef) {\n        const eventListeners = this._activeRipples.get(rippleRef) ?? null;\n        this._activeRipples.delete(rippleRef);\n        // Clear out the cached bounding rect if we have no more ripples.\n        if (!this._activeRipples.size) {\n            this._containerRect = null;\n        }\n        // If the current ref is the most recent transient ripple, unset it\n        // avoid memory leaks.\n        if (rippleRef === this._mostRecentTransientRipple) {\n            this._mostRecentTransientRipple = null;\n        }\n        rippleRef.state = 3 /* RippleState.HIDDEN */;\n        if (eventListeners !== null) {\n            rippleRef.element.removeEventListener('transitionend', eventListeners.onTransitionEnd);\n            rippleRef.element.removeEventListener('transitioncancel', eventListeners.onTransitionCancel);\n        }\n        rippleRef.element.remove();\n    }\n    /** Function being called whenever the trigger is being pressed using mouse. */\n    _onMousedown(event) {\n        // Screen readers will fire fake mouse events for space/enter. Skip launching a\n        // ripple in this case for consistency with the non-screen-reader experience.\n        const isFakeMousedown = (0,_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__.isFakeMousedownFromScreenReader)(event);\n        const isSyntheticEvent = this._lastTouchStartEvent &&\n            Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n        if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n            this._isPointerDown = true;\n            this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using touch. */\n    _onTouchStart(event) {\n        if (!this._target.rippleDisabled && !(0,_angular_cdk_a11y__WEBPACK_IMPORTED_MODULE_6__.isFakeTouchstartFromScreenReader)(event)) {\n            // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n            // events will launch a second ripple if we don't ignore mouse events for a specific\n            // time after a touchstart event.\n            this._lastTouchStartEvent = Date.now();\n            this._isPointerDown = true;\n            // Use `changedTouches` so we skip any touches where the user put\n            // their finger down, but used another finger to tap the element again.\n            const touches = event.changedTouches;\n            for (let i = 0; i < touches.length; i++) {\n                this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n            }\n        }\n    }\n    /** Function being called whenever the trigger is being released. */\n    _onPointerUp() {\n        if (!this._isPointerDown) {\n            return;\n        }\n        this._isPointerDown = false;\n        // Fade-out all ripples that are visible and not persistent.\n        this._getActiveRipples().forEach(ripple => {\n            // By default, only ripples that are completely visible will fade out on pointer release.\n            // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n            const isVisible = ripple.state === 1 /* RippleState.VISIBLE */ ||\n                (ripple.config.terminateOnPointerUp && ripple.state === 0 /* RippleState.FADING_IN */);\n            if (!ripple.config.persistent && isVisible) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    _getActiveRipples() {\n        return Array.from(this._activeRipples.keys());\n    }\n    /** Removes previously registered event listeners from the trigger element. */\n    _removeTriggerEvents() {\n        const trigger = this._triggerElement;\n        if (trigger) {\n            pointerDownEvents.forEach(type => RippleRenderer._eventManager.removeHandler(type, trigger, this));\n            if (this._pointerUpEventsRegistered) {\n                pointerUpEvents.forEach(type => trigger.removeEventListener(type, this, passiveCapturingEventOptions));\n            }\n        }\n    }\n}\nRippleRenderer._eventManager = new RippleEventManager();\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x, y, rect) {\n    const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n    const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n    return Math.sqrt(distX * distX + distY * distY);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to specify the global ripple options. */\nconst MAT_RIPPLE_GLOBAL_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('mat-ripple-global-options');\nclass MatRipple {\n    /**\n     * Whether click events will not trigger the ripple. Ripples can be still launched manually\n     * by using the `launch()` method.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        if (value) {\n            this.fadeOutAllNonPersistent();\n        }\n        this._disabled = value;\n        this._setupTriggerEventsIfEnabled();\n    }\n    /**\n     * The element that triggers the ripple when click events are received.\n     * Defaults to the directive's host element.\n     */\n    get trigger() {\n        return this._trigger || this._elementRef.nativeElement;\n    }\n    set trigger(trigger) {\n        this._trigger = trigger;\n        this._setupTriggerEventsIfEnabled();\n    }\n    constructor(_elementRef, ngZone, platform, globalOptions, _animationMode) {\n        this._elementRef = _elementRef;\n        this._animationMode = _animationMode;\n        /**\n         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n         * will be the distance from the center of the ripple to the furthest corner of the host element's\n         * bounding rectangle.\n         */\n        this.radius = 0;\n        this._disabled = false;\n        /** Whether ripple directive is initialized and the input bindings are set. */\n        this._isInitialized = false;\n        this._globalOptions = globalOptions || {};\n        this._rippleRenderer = new RippleRenderer(this, ngZone, _elementRef, platform);\n    }\n    ngOnInit() {\n        this._isInitialized = true;\n        this._setupTriggerEventsIfEnabled();\n    }\n    ngOnDestroy() {\n        this._rippleRenderer._removeTriggerEvents();\n    }\n    /** Fades out all currently showing ripple elements. */\n    fadeOutAll() {\n        this._rippleRenderer.fadeOutAll();\n    }\n    /** Fades out all currently showing non-persistent ripple elements. */\n    fadeOutAllNonPersistent() {\n        this._rippleRenderer.fadeOutAllNonPersistent();\n    }\n    /**\n     * Ripple configuration from the directive's input values.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleConfig() {\n        return {\n            centered: this.centered,\n            radius: this.radius,\n            color: this.color,\n            animation: {\n                ...this._globalOptions.animation,\n                ...(this._animationMode === 'NoopAnimations' ? { enterDuration: 0, exitDuration: 0 } : {}),\n                ...this.animation,\n            },\n            terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,\n        };\n    }\n    /**\n     * Whether ripples on pointer-down are disabled or not.\n     * @docs-private Implemented as part of RippleTarget\n     */\n    get rippleDisabled() {\n        return this.disabled || !!this._globalOptions.disabled;\n    }\n    /** Sets up the trigger event listeners if ripples are enabled. */\n    _setupTriggerEventsIfEnabled() {\n        if (!this.disabled && this._isInitialized) {\n            this._rippleRenderer.setupTriggerEvents(this.trigger);\n        }\n    }\n    /** Launches a manual ripple at the specified coordinated or just by the ripple config. */\n    launch(configOrX, y = 0, config) {\n        if (typeof configOrX === 'number') {\n            return this._rippleRenderer.fadeInRipple(configOrX, y, { ...this.rippleConfig, ...config });\n        }\n        else {\n            return this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...configOrX });\n        }\n    }\n}\nMatRipple.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRipple, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { token: MAT_RIPPLE_GLOBAL_OPTIONS, optional: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatRipple.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: { color: [\"matRippleColor\", \"color\"], unbounded: [\"matRippleUnbounded\", \"unbounded\"], centered: [\"matRippleCentered\", \"centered\"], radius: [\"matRippleRadius\", \"radius\"], animation: [\"matRippleAnimation\", \"animation\"], disabled: [\"matRippleDisabled\", \"disabled\"], trigger: [\"matRippleTrigger\", \"trigger\"] }, host: { properties: { \"class.mat-ripple-unbounded\": \"unbounded\" }, classAttribute: \"mat-ripple\" }, exportAs: [\"matRipple\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRipple, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[mat-ripple], [matRipple]',\n                    exportAs: 'matRipple',\n                    host: {\n                        'class': 'mat-ripple',\n                        '[class.mat-ripple-unbounded]': 'unbounded',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MAT_RIPPLE_GLOBAL_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE]\n                }] }]; }, propDecorators: { color: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleColor']\n            }], unbounded: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleUnbounded']\n            }], centered: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleCentered']\n            }], radius: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleRadius']\n            }], animation: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleAnimation']\n            }], disabled: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleDisabled']\n            }], trigger: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matRippleTrigger']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatRippleModule {\n}\nMatRippleModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRippleModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatRippleModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRippleModule, declarations: [MatRipple], imports: [MatCommonModule], exports: [MatRipple, MatCommonModule] });\nMatRippleModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRippleModule, imports: [MatCommonModule, MatCommonModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRippleModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [MatCommonModule],\n                    exports: [MatRipple, MatCommonModule],\n                    declarations: [MatRipple],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Component that shows a simplified checkbox without including any kind of \"real\" checkbox.\n * Meant to be used when the checkbox is purely decorative and a large number of them will be\n * included, such as for the options in a multi-select. Uses no SVGs or complex animations.\n * Note that theming is meant to be handled by the parent element, e.g.\n * `mat-primary .mat-pseudo-checkbox`.\n *\n * Note that this component will be completely invisible to screen-reader users. This is *not*\n * interchangeable with `<mat-checkbox>` and should *not* be used if the user would directly\n * interact with the checkbox. The pseudo-checkbox should only be used as an implementation detail\n * of more complex components that appropriately handle selected / checked state.\n * @docs-private\n */\nclass MatPseudoCheckbox {\n    constructor(_animationMode) {\n        this._animationMode = _animationMode;\n        /** Display state of the checkbox. */\n        this.state = 'unchecked';\n        /** Whether the checkbox is disabled. */\n        this.disabled = false;\n        /**\n         * Appearance of the pseudo checkbox. Default appearance of 'full' renders a checkmark/mixedmark\n         * indicator inside a square box. 'minimal' appearance only renders the checkmark/mixedmark.\n         */\n        this.appearance = 'full';\n    }\n}\nMatPseudoCheckbox.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckbox, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatPseudoCheckbox.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatPseudoCheckbox, selector: \"mat-pseudo-checkbox\", inputs: { state: \"state\", disabled: \"disabled\", appearance: \"appearance\" }, host: { properties: { \"class.mat-pseudo-checkbox-indeterminate\": \"state === \\\"indeterminate\\\"\", \"class.mat-pseudo-checkbox-checked\": \"state === \\\"checked\\\"\", \"class.mat-pseudo-checkbox-disabled\": \"disabled\", \"class.mat-pseudo-checkbox-minimal\": \"appearance === \\\"minimal\\\"\", \"class.mat-pseudo-checkbox-full\": \"appearance === \\\"full\\\"\", \"class._mat-animation-noopable\": \"_animationMode === \\\"NoopAnimations\\\"\" }, classAttribute: \"mat-pseudo-checkbox\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: '', isInline: true, styles: [\".mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\\"\\\";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}\"], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckbox, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, selector: 'mat-pseudo-checkbox', template: '', host: {\n                        'class': 'mat-pseudo-checkbox',\n                        '[class.mat-pseudo-checkbox-indeterminate]': 'state === \"indeterminate\"',\n                        '[class.mat-pseudo-checkbox-checked]': 'state === \"checked\"',\n                        '[class.mat-pseudo-checkbox-disabled]': 'disabled',\n                        '[class.mat-pseudo-checkbox-minimal]': 'appearance === \"minimal\"',\n                        '[class.mat-pseudo-checkbox-full]': 'appearance === \"full\"',\n                        '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                    }, styles: [\".mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\\"\\\";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}\"] }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE]\n                }] }]; }, propDecorators: { state: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], disabled: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], appearance: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatPseudoCheckboxModule {\n}\nMatPseudoCheckboxModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckboxModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatPseudoCheckboxModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckboxModule, declarations: [MatPseudoCheckbox], imports: [MatCommonModule], exports: [MatPseudoCheckbox] });\nMatPseudoCheckboxModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckboxModule, imports: [MatCommonModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatPseudoCheckboxModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [MatCommonModule],\n                    exports: [MatPseudoCheckbox],\n                    declarations: [MatPseudoCheckbox],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to provide the parent component to options.\n */\nconst MAT_OPTION_PARENT_COMPONENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('MAT_OPTION_PARENT_COMPONENT');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n// Boilerplate for applying mixins to MatOptgroup.\n/** @docs-private */\nconst _MatOptgroupMixinBase = mixinDisabled(class {\n});\n// Counter for unique group ids.\nlet _uniqueOptgroupIdCounter = 0;\nclass _MatOptgroupBase extends _MatOptgroupMixinBase {\n    constructor(parent) {\n        super();\n        /** Unique id for the underlying label. */\n        this._labelId = `mat-optgroup-label-${_uniqueOptgroupIdCounter++}`;\n        this._inert = parent?.inertGroups ?? false;\n    }\n}\n_MatOptgroupBase.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: _MatOptgroupBase, deps: [{ token: MAT_OPTION_PARENT_COMPONENT, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\n_MatOptgroupBase.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: _MatOptgroupBase, inputs: { label: \"label\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: _MatOptgroupBase, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MAT_OPTION_PARENT_COMPONENT]\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; }, propDecorators: { label: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nconst MAT_OPTGROUP = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('MatOptgroup');\n/**\n * Component that is used to group instances of `mat-option`.\n */\nclass MatOptgroup extends _MatOptgroupBase {\n}\nMatOptgroup.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptgroup, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatOptgroup.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatOptgroup, selector: \"mat-optgroup\", inputs: { disabled: \"disabled\" }, host: { properties: { \"attr.role\": \"_inert ? null : \\\"group\\\"\", \"attr.aria-disabled\": \"_inert ? null : disabled.toString()\", \"attr.aria-labelledby\": \"_inert ? null : _labelId\" }, classAttribute: \"mat-mdc-optgroup\" }, providers: [{ provide: MAT_OPTGROUP, useExisting: MatOptgroup }], exportAs: [\"matOptgroup\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<span\\n  class=\\\"mat-mdc-optgroup-label\\\"\\n  aria-hidden=\\\"true\\\"\\n  [class.mdc-list-item--disabled]=\\\"disabled\\\"\\n  [id]=\\\"_labelId\\\">\\n  <span class=\\\"mdc-list-item__primary-text\\\">{{ label }} <ng-content></ng-content></span>\\n</span>\\n\\n<ng-content select=\\\"mat-option, ng-container\\\"></ng-content>\\n\", styles: [\".mat-mdc-optgroup-label{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;min-height:48px}.mat-mdc-optgroup-label:focus{outline:none}[dir=rtl] .mat-mdc-optgroup-label,.mat-mdc-optgroup-label[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-optgroup-label.mdc-list-item--disabled{opacity:.38}.mat-mdc-optgroup-label .mdc-list-item__primary-text{white-space:normal}\"], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptgroup, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ selector: 'mat-optgroup', exportAs: 'matOptgroup', encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, inputs: ['disabled'], host: {\n                        'class': 'mat-mdc-optgroup',\n                        '[attr.role]': '_inert ? null : \"group\"',\n                        '[attr.aria-disabled]': '_inert ? null : disabled.toString()',\n                        '[attr.aria-labelledby]': '_inert ? null : _labelId',\n                    }, providers: [{ provide: MAT_OPTGROUP, useExisting: MatOptgroup }], template: \"<span\\n  class=\\\"mat-mdc-optgroup-label\\\"\\n  aria-hidden=\\\"true\\\"\\n  [class.mdc-list-item--disabled]=\\\"disabled\\\"\\n  [id]=\\\"_labelId\\\">\\n  <span class=\\\"mdc-list-item__primary-text\\\">{{ label }} <ng-content></ng-content></span>\\n</span>\\n\\n<ng-content select=\\\"mat-option, ng-container\\\"></ng-content>\\n\", styles: [\".mat-mdc-optgroup-label{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;min-height:48px}.mat-mdc-optgroup-label:focus{outline:none}[dir=rtl] .mat-mdc-optgroup-label,.mat-mdc-optgroup-label[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-optgroup-label.mdc-list-item--disabled{opacity:.38}.mat-mdc-optgroup-label .mdc-list-item__primary-text{white-space:normal}\"] }]\n        }] });\n\n/**\n * Option IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueIdCounter = 0;\n/** Event object emitted by MatOption when selected or deselected. */\nclass MatOptionSelectionChange {\n    constructor(\n    /** Reference to the option that emitted the event. */\n    source, \n    /** Whether the change in the option's value was a result of a user action. */\n    isUserInput = false) {\n        this.source = source;\n        this.isUserInput = isUserInput;\n    }\n}\nclass _MatOptionBase {\n    /** Whether the wrapping component is in multiple selection mode. */\n    get multiple() {\n        return this._parent && this._parent.multiple;\n    }\n    /** Whether or not the option is currently selected. */\n    get selected() {\n        return this._selected;\n    }\n    /** Whether the option is disabled. */\n    get disabled() {\n        return (this.group && this.group.disabled) || this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_8__.coerceBooleanProperty)(value);\n    }\n    /** Whether ripples for the option are disabled. */\n    get disableRipple() {\n        return !!(this._parent && this._parent.disableRipple);\n    }\n    /** Whether to display checkmark for single-selection. */\n    get hideSingleSelectionIndicator() {\n        return !!(this._parent && this._parent.hideSingleSelectionIndicator);\n    }\n    constructor(_element, _changeDetectorRef, _parent, group) {\n        this._element = _element;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._parent = _parent;\n        this.group = group;\n        this._selected = false;\n        this._active = false;\n        this._disabled = false;\n        this._mostRecentViewValue = '';\n        /** The unique ID of the option. */\n        this.id = `mat-option-${_uniqueIdCounter++}`;\n        /** Event emitted when the option is selected or deselected. */\n        // tslint:disable-next-line:no-output-on-prefix\n        this.onSelectionChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        /** Emits when the state of the option changes and any parents have to be notified. */\n        this._stateChanges = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();\n    }\n    /**\n     * Whether or not the option is currently active and ready to be selected.\n     * An active option displays styles as if it is focused, but the\n     * focus is actually retained somewhere else. This comes in handy\n     * for components like autocomplete where focus must remain on the input.\n     */\n    get active() {\n        return this._active;\n    }\n    /**\n     * The displayed value of the option. It is necessary to show the selected option in the\n     * select's trigger.\n     */\n    get viewValue() {\n        // TODO(kara): Add input property alternative for node envs.\n        return (this._text?.nativeElement.textContent || '').trim();\n    }\n    /** Selects the option. */\n    select() {\n        if (!this._selected) {\n            this._selected = true;\n            this._changeDetectorRef.markForCheck();\n            this._emitSelectionChangeEvent();\n        }\n    }\n    /** Deselects the option. */\n    deselect() {\n        if (this._selected) {\n            this._selected = false;\n            this._changeDetectorRef.markForCheck();\n            this._emitSelectionChangeEvent();\n        }\n    }\n    /** Sets focus onto this option. */\n    focus(_origin, options) {\n        // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n        // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n        const element = this._getHostElement();\n        if (typeof element.focus === 'function') {\n            element.focus(options);\n        }\n    }\n    /**\n     * This method sets display styles on the option to make it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setActiveStyles() {\n        if (!this._active) {\n            this._active = true;\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /**\n     * This method removes display styles on the option that made it appear\n     * active. This is used by the ActiveDescendantKeyManager so key\n     * events will display the proper options as active on arrow key events.\n     */\n    setInactiveStyles() {\n        if (this._active) {\n            this._active = false;\n            this._changeDetectorRef.markForCheck();\n        }\n    }\n    /** Gets the label to be used when determining whether the option should be focused. */\n    getLabel() {\n        return this.viewValue;\n    }\n    /** Ensures the option is selected when activated from the keyboard. */\n    _handleKeydown(event) {\n        if ((event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__.ENTER || event.keyCode === _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__.SPACE) && !(0,_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_9__.hasModifierKey)(event)) {\n            this._selectViaInteraction();\n            // Prevent the page from scrolling down and form submits.\n            event.preventDefault();\n        }\n    }\n    /**\n     * `Selects the option while indicating the selection came from the user. Used to\n     * determine if the select's view -> model callback should be invoked.`\n     */\n    _selectViaInteraction() {\n        if (!this.disabled) {\n            this._selected = this.multiple ? !this._selected : true;\n            this._changeDetectorRef.markForCheck();\n            this._emitSelectionChangeEvent(true);\n        }\n    }\n    /** Returns the correct tabindex for the option depending on disabled state. */\n    _getTabIndex() {\n        return this.disabled ? '-1' : '0';\n    }\n    /** Gets the host DOM element. */\n    _getHostElement() {\n        return this._element.nativeElement;\n    }\n    ngAfterViewChecked() {\n        // Since parent components could be using the option's label to display the selected values\n        // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n        // relatively cheap, however we still limit them only to selected options in order to avoid\n        // hitting the DOM too often.\n        if (this._selected) {\n            const viewValue = this.viewValue;\n            if (viewValue !== this._mostRecentViewValue) {\n                if (this._mostRecentViewValue) {\n                    this._stateChanges.next();\n                }\n                this._mostRecentViewValue = viewValue;\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._stateChanges.complete();\n    }\n    /** Emits the selection change event. */\n    _emitSelectionChangeEvent(isUserInput = false) {\n        this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));\n    }\n}\n_MatOptionBase.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: _MatOptionBase, deps: \"invalid\", target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\n_MatOptionBase.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: _MatOptionBase, inputs: { value: \"value\", id: \"id\", disabled: \"disabled\" }, outputs: { onSelectionChange: \"onSelectionChange\" }, viewQueries: [{ propertyName: \"_text\", first: true, predicate: [\"text\"], descendants: true, static: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: _MatOptionBase, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }, { type: undefined }, { type: _MatOptgroupBase }]; }, propDecorators: { value: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], id: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], disabled: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], onSelectionChange: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output\n            }], _text: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,\n                args: ['text', { static: true }]\n            }] } });\n/**\n * Single option inside of a `<mat-select>` element.\n */\nclass MatOption extends _MatOptionBase {\n    constructor(element, changeDetectorRef, parent, group) {\n        super(element, changeDetectorRef, parent, group);\n    }\n}\nMatOption.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOption, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }, { token: MAT_OPTION_PARENT_COMPONENT, optional: true }, { token: MAT_OPTGROUP, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatOption.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatOption, selector: \"mat-option\", host: { attributes: { \"role\": \"option\" }, listeners: { \"click\": \"_selectViaInteraction()\", \"keydown\": \"_handleKeydown($event)\" }, properties: { \"attr.tabindex\": \"_getTabIndex()\", \"class.mdc-list-item--selected\": \"selected\", \"class.mat-mdc-option-multiple\": \"multiple\", \"class.mat-mdc-option-active\": \"active\", \"class.mdc-list-item--disabled\": \"disabled\", \"id\": \"id\", \"attr.aria-selected\": \"selected\", \"attr.aria-disabled\": \"disabled.toString()\" }, classAttribute: \"mat-mdc-option mdc-list-item\" }, exportAs: [\"matOption\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<mat-pseudo-checkbox *ngIf=\\\"multiple\\\" class=\\\"mat-mdc-option-pseudo-checkbox\\\"\\n    [state]=\\\"selected ? 'checked' : 'unchecked'\\\" [disabled]=\\\"disabled\\\"></mat-pseudo-checkbox>\\n\\n<ng-content select=\\\"mat-icon\\\"></ng-content>\\n\\n<span class=\\\"mdc-list-item__primary-text\\\" #text><ng-content></ng-content></span>\\n\\n<!-- Render checkmark at the end for single-selection. -->\\n<mat-pseudo-checkbox *ngIf=\\\"!multiple && selected && !hideSingleSelectionIndicator\\\"\\n    class=\\\"mat-mdc-option-pseudo-checkbox\\\" state=\\\"checked\\\" [disabled]=\\\"disabled\\\"\\n    appearance=\\\"minimal\\\"></mat-pseudo-checkbox>\\n\\n<!-- See a11y notes inside optgroup.ts for context behind this element. -->\\n<span class=\\\"cdk-visually-hidden\\\" *ngIf=\\\"group && group._inert\\\">({{ group.label }})</span>\\n\\n<div class=\\\"mat-mdc-option-ripple mat-mdc-focus-indicator\\\" mat-ripple\\n     [matRippleTrigger]=\\\"_getHostElement()\\\"\\n     [matRippleDisabled]=\\\"disabled || disableRipple\\\">\\n</div>\\n\", styles: [\".mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{opacity:.38;cursor:default}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:\\\"\\\";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:\\\"\\\"}\"], dependencies: [{ kind: \"directive\", type: MatRipple, selector: \"[mat-ripple], [matRipple]\", inputs: [\"matRippleColor\", \"matRippleUnbounded\", \"matRippleCentered\", \"matRippleRadius\", \"matRippleAnimation\", \"matRippleDisabled\", \"matRippleTrigger\"], exportAs: [\"matRipple\"] }, { kind: \"directive\", type: _angular_common__WEBPACK_IMPORTED_MODULE_2__.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { kind: \"component\", type: MatPseudoCheckbox, selector: \"mat-pseudo-checkbox\", inputs: [\"state\", \"disabled\", \"appearance\"] }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOption, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ selector: 'mat-option', exportAs: 'matOption', host: {\n                        'role': 'option',\n                        '[attr.tabindex]': '_getTabIndex()',\n                        '[class.mdc-list-item--selected]': 'selected',\n                        '[class.mat-mdc-option-multiple]': 'multiple',\n                        '[class.mat-mdc-option-active]': 'active',\n                        '[class.mdc-list-item--disabled]': 'disabled',\n                        '[id]': 'id',\n                        // Set aria-selected to false for non-selected items and true for selected items. Conform to\n                        // [WAI ARIA Listbox authoring practices guide](\n                        //  https://www.w3.org/WAI/ARIA/apg/patterns/listbox/), \"If any options are selected, each\n                        // selected option has either aria-selected or aria-checked  set to true. All options that are\n                        // selectable but not selected have either aria-selected or aria-checked set to false.\" Align\n                        // aria-selected implementation of Chips and List components.\n                        //\n                        // Set `aria-selected=\"false\"` on not-selected listbox options to fix VoiceOver announcing\n                        // every option as \"selected\" (#21491).\n                        '[attr.aria-selected]': 'selected',\n                        '[attr.aria-disabled]': 'disabled.toString()',\n                        '(click)': '_selectViaInteraction()',\n                        '(keydown)': '_handleKeydown($event)',\n                        'class': 'mat-mdc-option mdc-list-item',\n                    }, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, template: \"<mat-pseudo-checkbox *ngIf=\\\"multiple\\\" class=\\\"mat-mdc-option-pseudo-checkbox\\\"\\n    [state]=\\\"selected ? 'checked' : 'unchecked'\\\" [disabled]=\\\"disabled\\\"></mat-pseudo-checkbox>\\n\\n<ng-content select=\\\"mat-icon\\\"></ng-content>\\n\\n<span class=\\\"mdc-list-item__primary-text\\\" #text><ng-content></ng-content></span>\\n\\n<!-- Render checkmark at the end for single-selection. -->\\n<mat-pseudo-checkbox *ngIf=\\\"!multiple && selected && !hideSingleSelectionIndicator\\\"\\n    class=\\\"mat-mdc-option-pseudo-checkbox\\\" state=\\\"checked\\\" [disabled]=\\\"disabled\\\"\\n    appearance=\\\"minimal\\\"></mat-pseudo-checkbox>\\n\\n<!-- See a11y notes inside optgroup.ts for context behind this element. -->\\n<span class=\\\"cdk-visually-hidden\\\" *ngIf=\\\"group && group._inert\\\">({{ group.label }})</span>\\n\\n<div class=\\\"mat-mdc-option-ripple mat-mdc-focus-indicator\\\" mat-ripple\\n     [matRippleTrigger]=\\\"_getHostElement()\\\"\\n     [matRippleDisabled]=\\\"disabled || disableRipple\\\">\\n</div>\\n\", styles: [\".mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{opacity:.38;cursor:default}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:\\\"\\\";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:\\\"\\\"}\"] }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MAT_OPTION_PARENT_COMPONENT]\n                }] }, { type: MatOptgroup, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [MAT_OPTGROUP]\n                }] }]; } });\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nfunction _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {\n    if (optionGroups.length) {\n        let optionsArray = options.toArray();\n        let groups = optionGroups.toArray();\n        let groupCounter = 0;\n        for (let i = 0; i < optionIndex + 1; i++) {\n            if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n                groupCounter++;\n            }\n        }\n        return groupCounter;\n    }\n    return 0;\n}\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nfunction _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {\n    if (optionOffset < currentScrollPosition) {\n        return optionOffset;\n    }\n    if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n        return Math.max(0, optionOffset - panelHeight + optionHeight);\n    }\n    return currentScrollPosition;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass MatOptionModule {\n}\nMatOptionModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptionModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatOptionModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptionModule, declarations: [MatOption, MatOptgroup], imports: [MatRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, MatCommonModule, MatPseudoCheckboxModule], exports: [MatOption, MatOptgroup] });\nMatOptionModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptionModule, imports: [MatRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, MatCommonModule, MatPseudoCheckboxModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatOptionModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [MatRippleModule, _angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, MatCommonModule, MatPseudoCheckboxModule],\n                    exports: [MatOption, MatOptgroup],\n                    declarations: [MatOption, MatOptgroup],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=core.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZmVzbTIwMjAvY29yZS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9mZXNtMjAyMC9jb3JlLm1qcz81ZmJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmVyc2lvbiwgSW5qZWN0aW9uVG9rZW4sIGluamVjdCwgTmdNb2R1bGUsIE9wdGlvbmFsLCBJbmplY3QsIExPQ0FMRV9JRCwgSW5qZWN0YWJsZSwgRGlyZWN0aXZlLCBJbnB1dCwgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIEV2ZW50RW1pdHRlciwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIGkxIGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIsIGlzRmFrZVRvdWNoc3RhcnRGcm9tU2NyZWVuUmVhZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQmlkaU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IFZFUlNJT04gYXMgVkVSU0lPTiQxIH0gZnJvbSAnQGFuZ3VsYXIvY2RrJztcbmltcG9ydCAqIGFzIGkzIGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBET0NVTUVOVCwgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCAqIGFzIGkxJDEgZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IFBsYXRmb3JtLCBfaXNUZXN0RW52aXJvbm1lbnQsIG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMsIF9nZXRFdmVudFRhcmdldCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5LCBjb2VyY2VFbGVtZW50IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFOSU1BVElPTl9NT0RVTEVfVFlQRSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBFTlRFUiwgU1BBQ0UsIGhhc01vZGlmaWVyS2V5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogQ3VycmVudCB2ZXJzaW9uIG9mIEFuZ3VsYXIgTWF0ZXJpYWwuICovXG5jb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzE1LjIuNycpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBAZG9jcy1wcml2YXRlICovXG5jbGFzcyBBbmltYXRpb25DdXJ2ZXMge1xufVxuQW5pbWF0aW9uQ3VydmVzLlNUQU5EQVJEX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuREVDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjAsMC4wLDAuMiwxKSc7XG5BbmltYXRpb25DdXJ2ZXMuQUNDRUxFUkFUSU9OX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDEsMSknO1xuQW5pbWF0aW9uQ3VydmVzLlNIQVJQX0NVUlZFID0gJ2N1YmljLWJlemllcigwLjQsMC4wLDAuNiwxKSc7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuY2xhc3MgQW5pbWF0aW9uRHVyYXRpb25zIHtcbn1cbkFuaW1hdGlvbkR1cmF0aW9ucy5DT01QTEVYID0gJzM3NW1zJztcbkFuaW1hdGlvbkR1cmF0aW9ucy5FTlRFUklORyA9ICcyMjVtcyc7XG5BbmltYXRpb25EdXJhdGlvbnMuRVhJVElORyA9ICcxOTVtcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmZ1bmN0aW9uIE1BVEVSSUFMX1NBTklUWV9DSEVDS1NfRkFDVE9SWSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjb25maWd1cmVzIHdoZXRoZXIgdGhlIE1hdGVyaWFsIHNhbml0eSBjaGVja3MgYXJlIGVuYWJsZWQuICovXG5jb25zdCBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTID0gbmV3IEluamVjdGlvblRva2VuKCdtYXQtc2FuaXR5LWNoZWNrcycsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogTUFURVJJQUxfU0FOSVRZX0NIRUNLU19GQUNUT1JZLFxufSk7XG4vKipcbiAqIE1vZHVsZSB0aGF0IGNhcHR1cmVzIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIGxvYWRlZCBhbmQvb3IgcnVuIGZvciAqYWxsKiBBbmd1bGFyIE1hdGVyaWFsXG4gKiBjb21wb25lbnRzLiBUaGlzIGluY2x1ZGVzIEJpZGksIGV0Yy5cbiAqXG4gKiBUaGlzIG1vZHVsZSBzaG91bGQgYmUgaW1wb3J0ZWQgdG8gZWFjaCB0b3AtbGV2ZWwgY29tcG9uZW50IG1vZHVsZSAoZS5nLiwgTWF0VGFic01vZHVsZSkuXG4gKi9cbmNsYXNzIE1hdENvbW1vbk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoaGlnaENvbnRyYXN0TW9kZURldGVjdG9yLCBfc2FuaXR5Q2hlY2tzLCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2FuaXR5Q2hlY2tzID0gX3Nhbml0eUNoZWNrcztcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHdlJ3ZlIGRvbmUgdGhlIGdsb2JhbCBzYW5pdHkgY2hlY2tzIChlLmcuIGEgdGhlbWUgaXMgbG9hZGVkLCB0aGVyZSBpcyBhIGRvY3R5cGUpLiAqL1xuICAgICAgICB0aGlzLl9oYXNEb25lR2xvYmFsQ2hlY2tzID0gZmFsc2U7XG4gICAgICAgIC8vIFdoaWxlIEExMXlNb2R1bGUgYWxzbyBkb2VzIHRoaXMsIHdlIHJlcGVhdCBpdCBoZXJlIHRvIGF2b2lkIGltcG9ydGluZyBBMTF5TW9kdWxlXG4gICAgICAgIC8vIGluIE1hdENvbW1vbk1vZHVsZS5cbiAgICAgICAgaGlnaENvbnRyYXN0TW9kZURldGVjdG9yLl9hcHBseUJvZHlIaWdoQ29udHJhc3RNb2RlQ3NzQ2xhc3NlcygpO1xuICAgICAgICBpZiAoIXRoaXMuX2hhc0RvbmVHbG9iYWxDaGVja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RvbmVHbG9iYWxDaGVja3MgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgIC8vIEluamVjdCBpbiBoZXJlIHNvIHRoZSByZWZlcmVuY2UgdG8gYFBsYXRmb3JtYCBjYW4gYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAgICAgICAgICAgY29uc3QgcGxhdGZvcm0gPSBpbmplY3QoUGxhdGZvcm0sIHsgb3B0aW9uYWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrSXNFbmFibGVkKCdkb2N0eXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NoZWNrRG9jdHlwZUlzRGVmaW5lZCh0aGlzLl9kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGVja0lzRW5hYmxlZCgndGhlbWUnKSkge1xuICAgICAgICAgICAgICAgICAgICBfY2hlY2tUaGVtZUlzUHJlc2VudCh0aGlzLl9kb2N1bWVudCwgISFwbGF0Zm9ybT8uaXNCcm93c2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrSXNFbmFibGVkKCd2ZXJzaW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NoZWNrQ2RrVmVyc2lvbk1hdGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBHZXRzIHdoZXRoZXIgYSBzcGVjaWZpYyBzYW5pdHkgY2hlY2sgaXMgZW5hYmxlZC4gKi9cbiAgICBfY2hlY2tJc0VuYWJsZWQobmFtZSkge1xuICAgICAgICBpZiAoX2lzVGVzdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3Nhbml0eUNoZWNrcyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2FuaXR5Q2hlY2tzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3Nhbml0eUNoZWNrc1tuYW1lXTtcbiAgICB9XG59XG5NYXRDb21tb25Nb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRDb21tb25Nb2R1bGUsIGRlcHM6IFt7IHRva2VuOiBpMS5IaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IgfSwgeyB0b2tlbjogTUFURVJJQUxfU0FOSVRZX0NIRUNLUywgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogRE9DVU1FTlQgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5NYXRDb21tb25Nb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Q29tbW9uTW9kdWxlLCBpbXBvcnRzOiBbQmlkaU1vZHVsZV0sIGV4cG9ydHM6IFtCaWRpTW9kdWxlXSB9KTtcbk1hdENvbW1vbk1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRDb21tb25Nb2R1bGUsIGltcG9ydHM6IFtCaWRpTW9kdWxlLCBCaWRpTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdENvbW1vbk1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0JpZGlNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbQmlkaU1vZHVsZV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMS5IaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogRG9jdW1lbnQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuLyoqIENoZWNrcyB0aGF0IHRoZSBwYWdlIGhhcyBhIGRvY3R5cGUuICovXG5mdW5jdGlvbiBfY2hlY2tEb2N0eXBlSXNEZWZpbmVkKGRvYykge1xuICAgIGlmICghZG9jLmRvY3R5cGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDdXJyZW50IGRvY3VtZW50IGRvZXMgbm90IGhhdmUgYSBkb2N0eXBlLiBUaGlzIG1heSBjYXVzZSAnICtcbiAgICAgICAgICAgICdzb21lIEFuZ3VsYXIgTWF0ZXJpYWwgY29tcG9uZW50cyBub3QgdG8gYmVoYXZlIGFzIGV4cGVjdGVkLicpO1xuICAgIH1cbn1cbi8qKiBDaGVja3MgdGhhdCBhIHRoZW1lIGhhcyBiZWVuIGluY2x1ZGVkLiAqL1xuZnVuY3Rpb24gX2NoZWNrVGhlbWVJc1ByZXNlbnQoZG9jLCBpc0Jyb3dzZXIpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGFzc2VydCB0aGF0IHRoZSBgYm9keWAgaXMgZGVmaW5lZCwgYmVjYXVzZSB0aGVzZSBjaGVja3MgcnVuIHZlcnkgZWFybHlcbiAgICAvLyBhbmQgdGhlIGBib2R5YCB3b24ndCBiZSBkZWZpbmVkIGlmIHRoZSBjb25zdW1lciBwdXQgdGhlaXIgc2NyaXB0cyBpbiB0aGUgYGhlYWRgLlxuICAgIGlmICghZG9jLmJvZHkgfHwgIWlzQnJvd3Nlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRlc3RFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRlc3RFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21hdC10aGVtZS1sb2FkZWQtbWFya2VyJyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGVzdEVsZW1lbnQpO1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRlc3RFbGVtZW50KTtcbiAgICAvLyBJbiBzb21lIHNpdHVhdGlvbnMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIHRoZSB0ZXN0IGVsZW1lbnQgY2FuIGJlIG51bGwuIEZvciBleGFtcGxlIGluXG4gICAgLy8gRmlyZWZveCwgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG51bGwgaWYgYW4gYXBwbGljYXRpb24gaXMgcnVubmluZyBpbnNpZGUgb2YgYSBoaWRkZW4gaWZyYW1lLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgaWYgKGNvbXB1dGVkU3R5bGUgJiYgY29tcHV0ZWRTdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBBbmd1bGFyIE1hdGVyaWFsIGNvcmUgdGhlbWUuIE1vc3QgTWF0ZXJpYWwgJyArXG4gICAgICAgICAgICAnY29tcG9uZW50cyBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuIEZvciBtb3JlIGluZm8gcmVmZXIgJyArXG4gICAgICAgICAgICAndG8gdGhlIHRoZW1pbmcgZ3VpZGU6IGh0dHBzOi8vbWF0ZXJpYWwuYW5ndWxhci5pby9ndWlkZS90aGVtaW5nJyk7XG4gICAgfVxuICAgIHRlc3RFbGVtZW50LnJlbW92ZSgpO1xufVxuLyoqIENoZWNrcyB3aGV0aGVyIHRoZSBNYXRlcmlhbCB2ZXJzaW9uIG1hdGNoZXMgdGhlIENESyB2ZXJzaW9uLiAqL1xuZnVuY3Rpb24gX2NoZWNrQ2RrVmVyc2lvbk1hdGNoKCkge1xuICAgIGlmIChWRVJTSU9OLmZ1bGwgIT09IFZFUlNJT04kMS5mdWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIEFuZ3VsYXIgTWF0ZXJpYWwgdmVyc2lvbiAoJyArXG4gICAgICAgICAgICBWRVJTSU9OLmZ1bGwgK1xuICAgICAgICAgICAgJykgZG9lcyBub3QgbWF0Y2ggJyArXG4gICAgICAgICAgICAndGhlIEFuZ3VsYXIgQ0RLIHZlcnNpb24gKCcgK1xuICAgICAgICAgICAgVkVSU0lPTiQxLmZ1bGwgK1xuICAgICAgICAgICAgJykuXFxuJyArXG4gICAgICAgICAgICAnUGxlYXNlIGVuc3VyZSB0aGUgdmVyc2lvbnMgb2YgdGhlc2UgdHdvIHBhY2thZ2VzIGV4YWN0bHkgbWF0Y2guJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1peGluRGlzYWJsZWQoYmFzZSkge1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGJhc2Uge1xuICAgICAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBtaXhpbkNvbG9yKGJhc2UsIGRlZmF1bHRDb2xvcikge1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGJhc2Uge1xuICAgICAgICBnZXQgY29sb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGNvbG9yKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xvclBhbGV0dGUgPSB2YWx1ZSB8fCB0aGlzLmRlZmF1bHRDb2xvcjtcbiAgICAgICAgICAgIGlmIChjb2xvclBhbGV0dGUgIT09IHRoaXMuX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGBtYXQtJHt0aGlzLl9jb2xvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yUGFsZXR0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbWF0LSR7Y29sb3JQYWxldHRlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvciA9IGNvbG9yUGFsZXR0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBkZWZhdWx0IGNvbG9yIHRoYXQgY2FuIGJlIHNwZWNpZmllZCBmcm9tIHRoZSBtaXhpbi5cbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBkZWZhdWx0Q29sb3I7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1peGluRGlzYWJsZVJpcHBsZShiYXNlKSB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgYmFzZSB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IGlzIGRpc2FibGVkIG9yIG5vdC4gKi9cbiAgICAgICAgZ2V0IGRpc2FibGVSaXBwbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZVJpcHBsZTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgZGlzYWJsZVJpcHBsZSh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVJpcHBsZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1peGluVGFiSW5kZXgoYmFzZSwgZGVmYXVsdFRhYkluZGV4ID0gMCkge1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGJhc2Uge1xuICAgICAgICBnZXQgdGFiSW5kZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/IC0xIDogdGhpcy5fdGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IHRhYkluZGV4KHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3BlY2lmaWVkIHRhYkluZGV4IHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLl90YWJJbmRleCA9IHZhbHVlICE9IG51bGwgPyBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSkgOiB0aGlzLmRlZmF1bHRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX3RhYkluZGV4ID0gZGVmYXVsdFRhYkluZGV4O1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0VGFiSW5kZXggPSBkZWZhdWx0VGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG1peGluRXJyb3JTdGF0ZShiYXNlKSB7XG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgYmFzZSB7XG4gICAgICAgIC8qKiBVcGRhdGVzIHRoZSBlcnJvciBzdGF0ZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZXJyb3Igc3RhdGUgbWF0Y2hlci4gKi9cbiAgICAgICAgdXBkYXRlRXJyb3JTdGF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0YXRlID0gdGhpcy5lcnJvclN0YXRlO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50Rm9ybUdyb3VwIHx8IHRoaXMuX3BhcmVudEZvcm07XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVyID0gdGhpcy5lcnJvclN0YXRlTWF0Y2hlciB8fCB0aGlzLl9kZWZhdWx0RXJyb3JTdGF0ZU1hdGNoZXI7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5uZ0NvbnRyb2wgPyB0aGlzLm5nQ29udHJvbC5jb250cm9sIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbWF0Y2hlci5pc0Vycm9yU3RhdGUoY29udHJvbCwgcGFyZW50KTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgICAgICAvKiogV2hldGhlciB0aGUgY29tcG9uZW50IGlzIGluIGFuIGVycm9yIHN0YXRlLiAqL1xuICAgICAgICAgICAgdGhpcy5lcnJvclN0YXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBNaXhpbiB0byBhdWdtZW50IGEgZGlyZWN0aXZlIHdpdGggYW4gaW5pdGlhbGl6ZWQgcHJvcGVydHkgdGhhdCB3aWxsIGVtaXRzIHdoZW4gbmdPbkluaXQgZW5kcy4gKi9cbmZ1bmN0aW9uIG1peGluSW5pdGlhbGl6ZWQoYmFzZSkge1xuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGJhc2Uge1xuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIC8qKiBXaGV0aGVyIHRoaXMgZGlyZWN0aXZlIGhhcyBiZWVuIG1hcmtlZCBhcyBpbml0aWFsaXplZC4gKi9cbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGlzdCBvZiBzdWJzY3JpYmVycyB0aGF0IHN1YnNjcmliZWQgYmVmb3JlIHRoZSBkaXJlY3RpdmUgd2FzIGluaXRpYWxpemVkLiBTaG91bGQgYmUgbm90aWZpZWRcbiAgICAgICAgICAgICAqIGR1cmluZyBfbWFya0luaXRpYWxpemVkLiBTZXQgdG8gbnVsbCBhZnRlciBwZW5kaW5nIHN1YnNjcmliZXJzIGFyZSBub3RpZmllZCwgYW5kIHNob3VsZFxuICAgICAgICAgICAgICogbm90IGV4cGVjdCB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdWJzY3JpYmVycyA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPYnNlcnZhYmxlIHN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gdGhlIGRpcmVjdGl2ZSBpbml0aWFsaXplcy4gSWYgYWxyZWFkeSBpbml0aWFsaXplZCwgdGhlXG4gICAgICAgICAgICAgKiBzdWJzY3JpYmVyIGlzIHN0b3JlZCB0byBiZSBub3RpZmllZCBvbmNlIF9tYXJrSW5pdGlhbGl6ZWQgaXMgY2FsbGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlciA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW5pdGlhbGl6ZWQsIGltbWVkaWF0ZWx5IG5vdGlmeSB0aGUgc3Vic2NyaWJlci4gT3RoZXJ3aXNlIHN0b3JlIHRoZSBzdWJzY3JpYmVyIHRvIG5vdGlmeVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gX21hcmtJbml0aWFsaXplZCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5U3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgc3RhdGUgYXMgaW5pdGlhbGl6ZWQgYW5kIG5vdGlmaWVzIHBlbmRpbmcgc3Vic2NyaWJlcnMuIFNob3VsZCBiZSBjYWxsZWQgYXQgdGhlIGVuZFxuICAgICAgICAgKiBvZiBuZ09uSW5pdC5cbiAgICAgICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX21hcmtJbml0aWFsaXplZCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1RoaXMgZGlyZWN0aXZlIGhhcyBhbHJlYWR5IGJlZW4gbWFya2VkIGFzIGluaXRpYWxpemVkIGFuZCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCBub3QgYmUgY2FsbGVkIHR3aWNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nU3Vic2NyaWJlcnMuZm9yRWFjaCh0aGlzLl9ub3RpZnlTdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdWJzY3JpYmVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEVtaXRzIGFuZCBjb21wbGV0ZXMgdGhlIHN1YnNjcmliZXIgc3RyZWFtIChzaG91bGQgb25seSBlbWl0IG9uY2UpLiAqL1xuICAgICAgICBfbm90aWZ5U3Vic2NyaWJlcihzdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBJbmplY3Rpb25Ub2tlbiBmb3IgZGF0ZXBpY2tlciB0aGF0IGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIGRlZmF1bHQgbG9jYWxlIGNvZGUuICovXG5jb25zdCBNQVRfREFURV9MT0NBTEUgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ01BVF9EQVRFX0xPQ0FMRScsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogTUFUX0RBVEVfTE9DQUxFX0ZBQ1RPUlksXG59KTtcbi8qKiBAZG9jcy1wcml2YXRlICovXG5mdW5jdGlvbiBNQVRfREFURV9MT0NBTEVfRkFDVE9SWSgpIHtcbiAgICByZXR1cm4gaW5qZWN0KExPQ0FMRV9JRCk7XG59XG4vKiogQWRhcHRzIHR5cGUgYERgIHRvIGJlIHVzYWJsZSBhcyBhIGRhdGUgYnkgY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuICovXG5jbGFzcyBEYXRlQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZUNoYW5nZXMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKiogQSBzdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5sb2NhbGVDaGFuZ2VzID0gdGhpcy5fbG9jYWxlQ2hhbmdlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBwb3RlbnRpYWwgZGF0ZSBvYmplY3QsIHJldHVybnMgdGhhdCBzYW1lIGRhdGUgb2JqZWN0IGlmIGl0IGlzXG4gICAgICogYSB2YWxpZCBkYXRlLCBvciBgbnVsbGAgaWYgaXQncyBub3QgYSB2YWxpZCBkYXRlLlxuICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBBIGRhdGUgb3IgYG51bGxgLlxuICAgICAqL1xuICAgIGdldFZhbGlkRGF0ZU9yTnVsbChvYmopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEYXRlSW5zdGFuY2Uob2JqKSAmJiB0aGlzLmlzVmFsaWQob2JqKSA/IG9iaiA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGRlc2VyaWFsaXplIGEgdmFsdWUgdG8gYSB2YWxpZCBkYXRlIG9iamVjdC4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJzaW5nIGluIHRoYXRcbiAgICAgKiBkZXNlcmlhbGl6ZSBzaG91bGQgb25seSBhY2NlcHQgbm9uLWFtYmlndW91cywgbG9jYWxlLWluZGVwZW5kZW50IGZvcm1hdHMgKGUuZy4gYSBJU08gODYwMVxuICAgICAqIHN0cmluZykuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGFsbG93IGFueSBkZXNlcmlhbGl6YXRpb24sIGl0IHNpbXBseSBjaGVja3MgdGhhdFxuICAgICAqIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbHJlYWR5IGEgdmFsaWQgZGF0ZSBvYmplY3Qgb3IgbnVsbC4gVGhlIGA8bWF0LWRhdGVwaWNrZXI+YCB3aWxsIGNhbGwgdGhpc1xuICAgICAqIG1ldGhvZCBvbiBhbGwgb2YgaXRzIGBASW5wdXQoKWAgcHJvcGVydGllcyB0aGF0IGFjY2VwdCBkYXRlcy4gSXQgaXMgdGhlcmVmb3JlIHBvc3NpYmxlIHRvXG4gICAgICogc3VwcG9ydCBwYXNzaW5nIHZhbHVlcyBmcm9tIHlvdXIgYmFja2VuZCBkaXJlY3RseSB0byB0aGVzZSBwcm9wZXJ0aWVzIGJ5IG92ZXJyaWRpbmcgdGhpcyBtZXRob2RcbiAgICAgKiB0byBhbHNvIGRlc2VyaWFsaXplIHRoZSBmb3JtYXQgdXNlZCBieSB5b3VyIGJhY2tlbmQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byBhIGRhdGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgZGF0ZSBvYmplY3QsIGVpdGhlciBhIHZhbGlkIGRhdGUsIG51bGwgaWYgdGhlIHZhbHVlIGNhbiBiZVxuICAgICAqICAgICBkZXNlcmlhbGl6ZWQgaW50byBhIG51bGwgZGF0ZSAoZS5nLiB0aGUgZW1wdHkgc3RyaW5nKSwgb3IgYW4gaW52YWxpZCBkYXRlLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8ICh0aGlzLmlzRGF0ZUluc3RhbmNlKHZhbHVlKSAmJiB0aGlzLmlzVmFsaWQodmFsdWUpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludmFsaWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbG9jYWxlIHVzZWQgZm9yIGFsbCBkYXRlcy5cbiAgICAgKiBAcGFyYW0gbG9jYWxlIFRoZSBuZXcgbG9jYWxlLlxuICAgICAqL1xuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgICAgIHRoaXMuX2xvY2FsZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0d28gZGF0ZXMuXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBkYXRlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyAwIGlmIHRoZSBkYXRlcyBhcmUgZXF1YWwsIGEgbnVtYmVyIGxlc3MgdGhhbiAwIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGVhcmxpZXIsXG4gICAgICogICAgIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGxhdGVyLlxuICAgICAqL1xuICAgIGNvbXBhcmVEYXRlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldFllYXIoZmlyc3QpIC0gdGhpcy5nZXRZZWFyKHNlY29uZCkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9udGgoZmlyc3QpIC0gdGhpcy5nZXRNb250aChzZWNvbmQpIHx8XG4gICAgICAgICAgICB0aGlzLmdldERhdGUoZmlyc3QpIC0gdGhpcy5nZXREYXRlKHNlY29uZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdHdvIGRhdGVzIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IGRhdGUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHNlY29uZCBUaGUgc2Vjb25kIGRhdGUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHdvIGRhdGVzIGFyZSBlcXVhbC5cbiAgICAgKiAgICAgTnVsbCBkYXRlcyBhcmUgY29uc2lkZXJlZCBlcXVhbCB0byBvdGhlciBudWxsIGRhdGVzLlxuICAgICAqL1xuICAgIHNhbWVEYXRlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgaWYgKGZpcnN0ICYmIHNlY29uZCkge1xuICAgICAgICAgICAgbGV0IGZpcnN0VmFsaWQgPSB0aGlzLmlzVmFsaWQoZmlyc3QpO1xuICAgICAgICAgICAgbGV0IHNlY29uZFZhbGlkID0gdGhpcy5pc1ZhbGlkKHNlY29uZCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RWYWxpZCAmJiBzZWNvbmRWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5jb21wYXJlRGF0ZShmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXJzdFZhbGlkID09IHNlY29uZFZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaXJzdCA9PSBzZWNvbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsYW1wIHRoZSBnaXZlbiBkYXRlIGJldHdlZW4gbWluIGFuZCBtYXggZGF0ZXMuXG4gICAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSB2YWx1ZSB0byBhbGxvdy4gSWYgbnVsbCBvciBvbWl0dGVkIG5vIG1pbiBpcyBlbmZvcmNlZC5cbiAgICAgKiBAcGFyYW0gbWF4IFRoZSBtYXhpbXVtIHZhbHVlIHRvIGFsbG93LiBJZiBudWxsIG9yIG9taXR0ZWQgbm8gbWF4IGlzIGVuZm9yY2VkLlxuICAgICAqIEByZXR1cm5zIGBtaW5gIGlmIGBkYXRlYCBpcyBsZXNzIHRoYW4gYG1pbmAsIGBtYXhgIGlmIGRhdGUgaXMgZ3JlYXRlciB0aGFuIGBtYXhgLFxuICAgICAqICAgICBvdGhlcndpc2UgYGRhdGVgLlxuICAgICAqL1xuICAgIGNsYW1wRGF0ZShkYXRlLCBtaW4sIG1heCkge1xuICAgICAgICBpZiAobWluICYmIHRoaXMuY29tcGFyZURhdGUoZGF0ZSwgbWluKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heCAmJiB0aGlzLmNvbXBhcmVEYXRlKGRhdGUsIG1heCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBNQVRfREFURV9GT1JNQVRTID0gbmV3IEluamVjdGlvblRva2VuKCdtYXQtZGF0ZS1mb3JtYXRzJyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBNYXRjaGVzIHN0cmluZ3MgdGhhdCBoYXZlIHRoZSBmb3JtIG9mIGEgdmFsaWQgUkZDIDMzMzkgc3RyaW5nXG4gKiAoaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkpLiBOb3RlIHRoYXQgdGhlIHN0cmluZyBtYXkgbm90IGFjdHVhbGx5IGJlIGEgdmFsaWQgZGF0ZVxuICogYmVjYXVzZSB0aGUgcmVnZXggd2lsbCBtYXRjaCBzdHJpbmdzIGFuIHdpdGggb3V0IG9mIGJvdW5kcyBtb250aCwgZGF0ZSwgZXRjLlxuICovXG5jb25zdCBJU09fODYwMV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn0oPzpUXFxkezJ9OlxcZHsyfTpcXGR7Mn0oPzpcXC5cXGQrKT8oPzpafCg/Oig/OlxcK3wtKVxcZHsyfTpcXGR7Mn0pKT8pPyQvO1xuLyoqIENyZWF0ZXMgYW4gYXJyYXkgYW5kIGZpbGxzIGl0IHdpdGggdmFsdWVzLiAqL1xuZnVuY3Rpb24gcmFuZ2UobGVuZ3RoLCB2YWx1ZUZ1bmN0aW9uKSB7XG4gICAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWVzQXJyYXlbaV0gPSB2YWx1ZUZ1bmN0aW9uKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzQXJyYXk7XG59XG4vKiogQWRhcHRzIHRoZSBuYXRpdmUgSlMgRGF0ZSBmb3IgdXNlIHdpdGggY2RrLWJhc2VkIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuICovXG5jbGFzcyBOYXRpdmVEYXRlQWRhcHRlciBleHRlbmRzIERhdGVBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXREYXRlTG9jYWxlLCBcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgYmVpbmcgdXNlZC4gVG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMFxuICAgICAqL1xuICAgIF9wbGF0Zm9ybSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIGJlaW5nIHVzZWQuIFRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAqIEBicmVha2luZy1jaGFuZ2UgMTQuMC4wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZVV0Y0ZvckRpc3BsYXkgPSBmYWxzZTtcbiAgICAgICAgc3VwZXIuc2V0TG9jYWxlKG1hdERhdGVMb2NhbGUpO1xuICAgIH1cbiAgICBnZXRZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0TW9udGgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICAgIH1cbiAgICBnZXREYXRlKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xuICAgIH1cbiAgICBnZXREYXlPZldlZWsoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXREYXkoKTtcbiAgICB9XG4gICAgZ2V0TW9udGhOYW1lcyhzdHlsZSkge1xuICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyBtb250aDogc3R5bGUsIHRpbWVab25lOiAndXRjJyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDEyLCBpID0+IHRoaXMuX2Zvcm1hdChkdGYsIG5ldyBEYXRlKDIwMTcsIGksIDEpKSk7XG4gICAgfVxuICAgIGdldERhdGVOYW1lcygpIHtcbiAgICAgICAgY29uc3QgZHRmID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodGhpcy5sb2NhbGUsIHsgZGF5OiAnbnVtZXJpYycsIHRpbWVab25lOiAndXRjJyB9KTtcbiAgICAgICAgcmV0dXJuIHJhbmdlKDMxLCBpID0+IHRoaXMuX2Zvcm1hdChkdGYsIG5ldyBEYXRlKDIwMTcsIDAsIGkgKyAxKSkpO1xuICAgIH1cbiAgICBnZXREYXlPZldlZWtOYW1lcyhzdHlsZSkge1xuICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyB3ZWVrZGF5OiBzdHlsZSwgdGltZVpvbmU6ICd1dGMnIH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2UoNywgaSA9PiB0aGlzLl9mb3JtYXQoZHRmLCBuZXcgRGF0ZSgyMDE3LCAwLCBpICsgMSkpKTtcbiAgICB9XG4gICAgZ2V0WWVhck5hbWUoZGF0ZSkge1xuICAgICAgICBjb25zdCBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmxvY2FsZSwgeyB5ZWFyOiAnbnVtZXJpYycsIHRpbWVab25lOiAndXRjJyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdChkdGYsIGRhdGUpO1xuICAgIH1cbiAgICBnZXRGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdGVsbCB1c2luZyBuYXRpdmUgSlMgRGF0ZSB3aGF0IHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMsIHdlIGRlZmF1bHQgdG8gU3VuZGF5LlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZ2V0TnVtRGF5c0luTW9udGgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpICsgMSwgMCkpO1xuICAgIH1cbiAgICBjbG9uZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGNyZWF0ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgbW9udGggYW5kIGRhdGUgKGV4Y2VwdCB1cHBlciBib3VuZCBvbiBkYXRlIHdoaWNoIHdlIGhhdmUgdG8gY2hlY2sgYWZ0ZXJcbiAgICAgICAgICAgIC8vIGNyZWF0aW5nIHRoZSBEYXRlKS5cbiAgICAgICAgICAgIGlmIChtb250aCA8IDAgfHwgbW9udGggPiAxMSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIG1vbnRoIGluZGV4IFwiJHttb250aH1cIi4gTW9udGggaW5kZXggaGFzIHRvIGJlIGJldHdlZW4gMCBhbmQgMTEuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCBkYXRlIFwiJHtkYXRlfVwiLiBEYXRlIGhhcyB0byBiZSBncmVhdGVyIHRoYW4gMC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fY3JlYXRlRGF0ZVdpdGhPdmVyZmxvdyh5ZWFyLCBtb250aCwgZGF0ZSk7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGRhdGUgd2Fzbid0IGFib3ZlIHRoZSB1cHBlciBib3VuZCBmb3IgdGhlIG1vbnRoLCBjYXVzaW5nIHRoZSBtb250aCB0byBvdmVyZmxvd1xuICAgICAgICBpZiAocmVzdWx0LmdldE1vbnRoKCkgIT0gbW9udGggJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGRhdGUgXCIke2RhdGV9XCIgZm9yIG1vbnRoIHdpdGggaW5kZXggXCIke21vbnRofVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgcGFyc2UodmFsdWUsIHBhcnNlRm9ybWF0KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gd2F5IHVzaW5nIHRoZSBuYXRpdmUgSlMgRGF0ZSB0byBzZXQgdGhlIHBhcnNlIGZvcm1hdCBvciBsb2NhbGUsIHNvIHdlIGlnbm9yZSB0aGVzZVxuICAgICAgICAvLyBwYXJhbWV0ZXJzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKERhdGUucGFyc2UodmFsdWUpKSA6IG51bGw7XG4gICAgfVxuICAgIGZvcm1hdChkYXRlLCBkaXNwbGF5Rm9ybWF0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGRhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTmF0aXZlRGF0ZUFkYXB0ZXI6IENhbm5vdCBmb3JtYXQgaW52YWxpZCBkYXRlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGR0ZiA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7IC4uLmRpc3BsYXlGb3JtYXQsIHRpbWVab25lOiAndXRjJyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdChkdGYsIGRhdGUpO1xuICAgIH1cbiAgICBhZGRDYWxlbmRhclllYXJzKGRhdGUsIHllYXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZENhbGVuZGFyTW9udGhzKGRhdGUsIHllYXJzICogMTIpO1xuICAgIH1cbiAgICBhZGRDYWxlbmRhck1vbnRocyhkYXRlLCBtb250aHMpIHtcbiAgICAgICAgbGV0IG5ld0RhdGUgPSB0aGlzLl9jcmVhdGVEYXRlV2l0aE92ZXJmbG93KHRoaXMuZ2V0WWVhcihkYXRlKSwgdGhpcy5nZXRNb250aChkYXRlKSArIG1vbnRocywgdGhpcy5nZXREYXRlKGRhdGUpKTtcbiAgICAgICAgLy8gSXQncyBwb3NzaWJsZSB0byB3aW5kIHVwIGluIHRoZSB3cm9uZyBtb250aCBpZiB0aGUgb3JpZ2luYWwgbW9udGggaGFzIG1vcmUgZGF5cyB0aGFuIHRoZSBuZXdcbiAgICAgICAgLy8gbW9udGguIEluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIGdvIHRvIHRoZSBsYXN0IGRheSBvZiB0aGUgZGVzaXJlZCBtb250aC5cbiAgICAgICAgLy8gTm90ZTogdGhlIGFkZGl0aW9uYWwgKyAxMiAlIDEyIGVuc3VyZXMgd2UgZW5kIHVwIHdpdGggYSBwb3NpdGl2ZSBudW1iZXIsIHNpbmNlIEpTICUgZG9lc24ndFxuICAgICAgICAvLyBndWFyYW50ZWUgdGhpcy5cbiAgICAgICAgaWYgKHRoaXMuZ2V0TW9udGgobmV3RGF0ZSkgIT0gKCgodGhpcy5nZXRNb250aChkYXRlKSArIG1vbnRocykgJSAxMikgKyAxMikgJSAxMikge1xuICAgICAgICAgICAgbmV3RGF0ZSA9IHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKG5ld0RhdGUpLCB0aGlzLmdldE1vbnRoKG5ld0RhdGUpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0ZTtcbiAgICB9XG4gICAgYWRkQ2FsZW5kYXJEYXlzKGRhdGUsIGRheXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3codGhpcy5nZXRZZWFyKGRhdGUpLCB0aGlzLmdldE1vbnRoKGRhdGUpLCB0aGlzLmdldERhdGUoZGF0ZSkgKyBkYXlzKTtcbiAgICB9XG4gICAgdG9Jc284NjAxKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKSxcbiAgICAgICAgICAgIHRoaXMuXzJkaWdpdChkYXRlLmdldFVUQ0RhdGUoKSksXG4gICAgICAgIF0uam9pbignLScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZSBpZiBnaXZlbiBhIHZhbGlkIERhdGUgb3IgbnVsbC4gRGVzZXJpYWxpemVzIHZhbGlkIElTTyA4NjAxIHN0cmluZ3NcbiAgICAgKiAoaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzMzMzkudHh0KSBpbnRvIHZhbGlkIERhdGVzIGFuZCBlbXB0eSBzdHJpbmcgaW50byBudWxsLiBSZXR1cm5zIGFuXG4gICAgICogaW52YWxpZCBkYXRlIGZvciBhbGwgb3RoZXIgdmFsdWVzLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgYERhdGVgIGNvbnN0cnVjdG9yIGFjY2VwdHMgZm9ybWF0cyBvdGhlciB0aGFuIElTTyA4NjAxLCBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgICAgIC8vIHN0cmluZyBpcyB0aGUgcmlnaHQgZm9ybWF0IGZpcnN0LlxuICAgICAgICAgICAgaWYgKElTT184NjAxX1JFR0VYLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZChkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlc2VyaWFsaXplKHZhbHVlKTtcbiAgICB9XG4gICAgaXNEYXRlSW5zdGFuY2Uob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEYXRlO1xuICAgIH1cbiAgICBpc1ZhbGlkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGludmFsaWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIGRhdGUgYnV0IGFsbG93cyB0aGUgbW9udGggYW5kIGRhdGUgdG8gb3ZlcmZsb3cuICovXG4gICAgX2NyZWF0ZURhdGVXaXRoT3ZlcmZsb3coeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgLy8gUGFzc2luZyB0aGUgeWVhciB0byB0aGUgY29uc3RydWN0b3IgY2F1c2VzIHllYXIgbnVtYmVycyA8MTAwIHRvIGJlIGNvbnZlcnRlZCB0byAxOXh4LlxuICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIHVzZSBgc2V0RnVsbFllYXJgIGFuZCBgc2V0SG91cnNgIGluc3RlYWQuXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBkLnNldEZ1bGxZZWFyKHllYXIsIG1vbnRoLCBkYXRlKTtcbiAgICAgICAgZC5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhZHMgYSBudW1iZXIgdG8gbWFrZSBpdCB0d28gZGlnaXRzLlxuICAgICAqIEBwYXJhbSBuIFRoZSBudW1iZXIgdG8gcGFkLlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWRkZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIF8yZGlnaXQobikge1xuICAgICAgICByZXR1cm4gKCcwMCcgKyBuKS5zbGljZSgtMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gY29udmVydGluZyBEYXRlIG9iamVjdCB0byBzdHJpbmcsIGphdmFzY3JpcHQgYnVpbHQtaW4gZnVuY3Rpb25zIG1heSByZXR1cm4gd3JvbmdcbiAgICAgKiByZXN1bHRzIGJlY2F1c2UgaXQgYXBwbGllcyBpdHMgaW50ZXJuYWwgRFNUIHJ1bGVzLiBUaGUgRFNUIHJ1bGVzIGFyb3VuZCB0aGUgd29ybGQgY2hhbmdlXG4gICAgICogdmVyeSBmcmVxdWVudGx5LCBhbmQgdGhlIGN1cnJlbnQgdmFsaWQgcnVsZSBpcyBub3QgYWx3YXlzIHZhbGlkIGluIHByZXZpb3VzIHllYXJzIHRob3VnaC5cbiAgICAgKiBXZSB3b3JrIGFyb3VuZCB0aGlzIHByb2JsZW0gYnVpbGRpbmcgYSBuZXcgRGF0ZSBvYmplY3Qgd2hpY2ggaGFzIGl0cyBpbnRlcm5hbCBVVENcbiAgICAgKiByZXByZXNlbnRhdGlvbiB3aXRoIHRoZSBsb2NhbCBkYXRlIGFuZCB0aW1lLlxuICAgICAqIEBwYXJhbSBkdGYgSW50bC5EYXRlVGltZUZvcm1hdCBvYmplY3QsIGNvbnRhaW5pbmcgdGhlIGRlc2lyZWQgc3RyaW5nIGZvcm1hdC4gSXQgbXVzdCBoYXZlXG4gICAgICogICAgdGltZVpvbmUgc2V0IHRvICd1dGMnIHRvIHdvcmsgZmluZS5cbiAgICAgKiBAcGFyYW0gZGF0ZSBEYXRlIGZyb20gd2hpY2ggd2Ugd2FudCB0byBnZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBhY2NvcmRpbmcgdG8gZHRmXG4gICAgICogQHJldHVybnMgQSBEYXRlIG9iamVjdCB3aXRoIGl0cyBVVEMgcmVwcmVzZW50YXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBpbiBkYXRlIGluZm9cbiAgICAgKi9cbiAgICBfZm9ybWF0KGR0ZiwgZGF0ZSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSB5ZWFyIHRvIHRoZSBjb25zdHJ1Y3RvciBjYXVzZXMgeWVhciBudW1iZXJzIDwxMDAgdG8gYmUgY29udmVydGVkIHRvIDE5eHguXG4gICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgdXNlIGBzZXRVVENGdWxsWWVhcmAgYW5kIGBzZXRVVENIb3Vyc2AgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGQuc2V0VVRDRnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgZC5zZXRVVENIb3VycyhkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG4gICAgICAgIHJldHVybiBkdGYuZm9ybWF0KGQpO1xuICAgIH1cbn1cbk5hdGl2ZURhdGVBZGFwdGVyLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmF0aXZlRGF0ZUFkYXB0ZXIsIGRlcHM6IFt7IHRva2VuOiBNQVRfREFURV9MT0NBTEUsIG9wdGlvbmFsOiB0cnVlIH0sIHsgdG9rZW46IGkxJDEuUGxhdGZvcm0gfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbk5hdGl2ZURhdGVBZGFwdGVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5hdGl2ZURhdGVBZGFwdGVyIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmF0aXZlRGF0ZUFkYXB0ZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTUFUX0RBVEVfTE9DQUxFXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogaTEkMS5QbGF0Zm9ybSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBNQVRfTkFUSVZFX0RBVEVfRk9STUFUUyA9IHtcbiAgICBwYXJzZToge1xuICAgICAgICBkYXRlSW5wdXQ6IG51bGwsXG4gICAgfSxcbiAgICBkaXNwbGF5OiB7XG4gICAgICAgIGRhdGVJbnB1dDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbnVtZXJpYycsIGRheTogJ251bWVyaWMnIH0sXG4gICAgICAgIG1vbnRoWWVhckxhYmVsOiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcgfSxcbiAgICAgICAgZGF0ZUExMXlMYWJlbDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0sXG4gICAgICAgIG1vbnRoWWVhckExMXlMYWJlbDogeyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycgfSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBOYXRpdmVEYXRlTW9kdWxlIHtcbn1cbk5hdGl2ZURhdGVNb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOYXRpdmVEYXRlTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbk5hdGl2ZURhdGVNb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmF0aXZlRGF0ZU1vZHVsZSB9KTtcbk5hdGl2ZURhdGVNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmF0aXZlRGF0ZU1vZHVsZSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE5hdGl2ZURhdGVBZGFwdGVyIH1dIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmF0aXZlRGF0ZU1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE5hdGl2ZURhdGVBZGFwdGVyIH1dLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuY2xhc3MgTWF0TmF0aXZlRGF0ZU1vZHVsZSB7XG59XG5NYXROYXRpdmVEYXRlTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0TmF0aXZlRGF0ZU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5NYXROYXRpdmVEYXRlTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE5hdGl2ZURhdGVNb2R1bGUsIGltcG9ydHM6IFtOYXRpdmVEYXRlTW9kdWxlXSB9KTtcbk1hdE5hdGl2ZURhdGVNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0TmF0aXZlRGF0ZU1vZHVsZSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTUFUX05BVElWRV9EQVRFX0ZPUk1BVFMgfV0sIGltcG9ydHM6IFtOYXRpdmVEYXRlTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE5hdGl2ZURhdGVNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtOYXRpdmVEYXRlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTUFUX05BVElWRV9EQVRFX0ZPUk1BVFMgfV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEVycm9yIHN0YXRlIG1hdGNoZXIgdGhhdCBtYXRjaGVzIHdoZW4gYSBjb250cm9sIGlzIGludmFsaWQgYW5kIGRpcnR5LiAqL1xuY2xhc3MgU2hvd09uRGlydHlFcnJvclN0YXRlTWF0Y2hlciB7XG4gICAgaXNFcnJvclN0YXRlKGNvbnRyb2wsIGZvcm0pIHtcbiAgICAgICAgcmV0dXJuICEhKGNvbnRyb2wgJiYgY29udHJvbC5pbnZhbGlkICYmIChjb250cm9sLmRpcnR5IHx8IChmb3JtICYmIGZvcm0uc3VibWl0dGVkKSkpO1xuICAgIH1cbn1cblNob3dPbkRpcnR5RXJyb3JTdGF0ZU1hdGNoZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBTaG93T25EaXJ0eUVycm9yU3RhdGVNYXRjaGVyLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuU2hvd09uRGlydHlFcnJvclN0YXRlTWF0Y2hlci7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBTaG93T25EaXJ0eUVycm9yU3RhdGVNYXRjaGVyIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2hvd09uRGlydHlFcnJvclN0YXRlTWF0Y2hlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0gfSk7XG4vKiogUHJvdmlkZXIgdGhhdCBkZWZpbmVzIGhvdyBmb3JtIGNvbnRyb2xzIGJlaGF2ZSB3aXRoIHJlZ2FyZHMgdG8gZGlzcGxheWluZyBlcnJvciBtZXNzYWdlcy4gKi9cbmNsYXNzIEVycm9yU3RhdGVNYXRjaGVyIHtcbiAgICBpc0Vycm9yU3RhdGUoY29udHJvbCwgZm9ybSkge1xuICAgICAgICByZXR1cm4gISEoY29udHJvbCAmJiBjb250cm9sLmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCAoZm9ybSAmJiBmb3JtLnN1Ym1pdHRlZCkpKTtcbiAgICB9XG59XG5FcnJvclN0YXRlTWF0Y2hlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEVycm9yU3RhdGVNYXRjaGVyLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRXJyb3JTdGF0ZU1hdGNoZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRXJyb3JTdGF0ZU1hdGNoZXIsIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEVycm9yU3RhdGVNYXRjaGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFNoYXJlZCBkaXJlY3RpdmUgdG8gY291bnQgbGluZXMgaW5zaWRlIGEgdGV4dCBhcmVhLCBzdWNoIGFzIGEgbGlzdCBpdGVtLlxuICogTGluZSBlbGVtZW50cyBjYW4gYmUgZXh0cmFjdGVkIHdpdGggYSBAQ29udGVudENoaWxkcmVuKE1hdExpbmUpIHF1ZXJ5LCB0aGVuXG4gKiBjb3VudGVkIGJ5IGNoZWNraW5nIHRoZSBxdWVyeSBsaXN0J3MgbGVuZ3RoLlxuICovXG5jbGFzcyBNYXRMaW5lIHtcbn1cbk1hdExpbmUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRMaW5lLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRMaW5lLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0TGluZSwgc2VsZWN0b3I6IFwiW21hdC1saW5lXSwgW21hdExpbmVdXCIsIGhvc3Q6IHsgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LWxpbmVcIiB9LCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRMaW5lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0LWxpbmVdLCBbbWF0TGluZV0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYXQtbGluZScgfSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogSGVscGVyIHRoYXQgdGFrZXMgYSBxdWVyeSBsaXN0IG9mIGxpbmVzIGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzIG9uIHRoZSBob3N0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRMaW5lcyhsaW5lcywgZWxlbWVudCwgcHJlZml4ID0gJ21hdCcpIHtcbiAgICAvLyBOb3RlOiBkb2Vzbid0IG5lZWQgdG8gdW5zdWJzY3JpYmUsIGJlY2F1c2UgYGNoYW5nZXNgXG4gICAgLy8gZ2V0cyBjb21wbGV0ZWQgYnkgQW5ndWxhciB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICBsaW5lcy5jaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKGxpbmVzKSkuc3Vic2NyaWJlKCh7IGxlbmd0aCB9KSA9PiB7XG4gICAgICAgIHNldENsYXNzKGVsZW1lbnQsIGAke3ByZWZpeH0tMi1saW5lYCwgZmFsc2UpO1xuICAgICAgICBzZXRDbGFzcyhlbGVtZW50LCBgJHtwcmVmaXh9LTMtbGluZWAsIGZhbHNlKTtcbiAgICAgICAgc2V0Q2xhc3MoZWxlbWVudCwgYCR7cHJlZml4fS1tdWx0aS1saW5lYCwgZmFsc2UpO1xuICAgICAgICBpZiAobGVuZ3RoID09PSAyIHx8IGxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgc2V0Q2xhc3MoZWxlbWVudCwgYCR7cHJlZml4fS0ke2xlbmd0aH0tbGluZWAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgIHNldENsYXNzKGVsZW1lbnQsIGAke3ByZWZpeH0tbXVsdGktbGluZWAsIHRydWUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKiogQWRkcyBvciByZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gc2V0Q2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lLCBpc0FkZCkge1xuICAgIGVsZW1lbnQubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgaXNBZGQpO1xufVxuY2xhc3MgTWF0TGluZU1vZHVsZSB7XG59XG5NYXRMaW5lTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0TGluZU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5NYXRMaW5lTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdExpbmVNb2R1bGUsIGRlY2xhcmF0aW9uczogW01hdExpbmVdLCBpbXBvcnRzOiBbTWF0Q29tbW9uTW9kdWxlXSwgZXhwb3J0czogW01hdExpbmUsIE1hdENvbW1vbk1vZHVsZV0gfSk7XG5NYXRMaW5lTW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdExpbmVNb2R1bGUsIGltcG9ydHM6IFtNYXRDb21tb25Nb2R1bGUsIE1hdENvbW1vbk1vZHVsZV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRMaW5lTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWF0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01hdExpbmUsIE1hdENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdExpbmVdLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogUmVmZXJlbmNlIHRvIGEgcHJldmlvdXNseSBsYXVuY2hlZCByaXBwbGUgZWxlbWVudC5cbiAqL1xuY2xhc3MgUmlwcGxlUmVmIHtcbiAgICBjb25zdHJ1Y3RvcihfcmVuZGVyZXIsIFxuICAgIC8qKiBSZWZlcmVuY2UgdG8gdGhlIHJpcHBsZSBIVE1MIGVsZW1lbnQuICovXG4gICAgZWxlbWVudCwgXG4gICAgLyoqIFJpcHBsZSBjb25maWd1cmF0aW9uIHVzZWQgZm9yIHRoZSByaXBwbGUuICovXG4gICAgY29uZmlnLCBcbiAgICAvKiBXaGV0aGVyIGFuaW1hdGlvbnMgYXJlIGZvcmNpYmx5IGRpc2FibGVkIGZvciByaXBwbGVzIHRocm91Z2ggQ1NTLiAqL1xuICAgIF9hbmltYXRpb25Gb3JjaWJseURpc2FibGVkVGhyb3VnaENzcyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uRm9yY2libHlEaXNhYmxlZFRocm91Z2hDc3MgPSBfYW5pbWF0aW9uRm9yY2libHlEaXNhYmxlZFRocm91Z2hDc3M7XG4gICAgICAgIC8qKiBDdXJyZW50IHN0YXRlIG9mIHRoZSByaXBwbGUuICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSAzIC8qIFJpcHBsZVN0YXRlLkhJRERFTiAqLztcbiAgICB9XG4gICAgLyoqIEZhZGVzIG91dCB0aGUgcmlwcGxlIGVsZW1lbnQuICovXG4gICAgZmFkZU91dCgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZmFkZU91dFJpcHBsZSh0aGlzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIE9wdGlvbnMgdXNlZCB0byBiaW5kIGEgcGFzc2l2ZSBjYXB0dXJpbmcgZXZlbnQuICovXG5jb25zdCBwYXNzaXZlQ2FwdHVyaW5nRXZlbnRPcHRpb25zJDEgPSBub3JtYWxpemVQYXNzaXZlTGlzdGVuZXJPcHRpb25zKHtcbiAgICBwYXNzaXZlOiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWUsXG59KTtcbi8qKiBNYW5hZ2VzIGV2ZW50cyB0aHJvdWdoIGRlbGVnYXRpb24gc28gdGhhdCBhcyBmZXcgZXZlbnQgaGFuZGxlcnMgYXMgcG9zc2libGUgYXJlIGJvdW5kLiAqL1xuY2xhc3MgUmlwcGxlRXZlbnRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogRXZlbnQgaGFuZGxlciB0aGF0IGlzIGJvdW5kIGFuZCB3aGljaCBkaXNwYXRjaGVzIHRoZSBldmVudHMgdG8gdGhlIGRpZmZlcmVudCB0YXJnZXRzLiAqL1xuICAgICAgICB0aGlzLl9kZWxlZ2F0ZUV2ZW50SGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gX2dldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZ2V0KGV2ZW50LnR5cGUpPy5mb3JFYWNoKChoYW5kbGVycywgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdGFyZ2V0IHx8IGVsZW1lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIuaGFuZGxlRXZlbnQoZXZlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQWRkcyBhbiBldmVudCBoYW5kbGVyLiAqL1xuICAgIGFkZEhhbmRsZXIobmdab25lLCBuYW1lLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzRm9yRXZlbnQgPSB0aGlzLl9ldmVudHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoaGFuZGxlcnNGb3JFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnNGb3JFbGVtZW50ID0gaGFuZGxlcnNGb3JFdmVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNGb3JFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNGb3JFbGVtZW50LmFkZChoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzRm9yRXZlbnQuc2V0KGVsZW1lbnQsIG5ldyBTZXQoW2hhbmRsZXJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuc2V0KG5hbWUsIG5ldyBNYXAoW1tlbGVtZW50LCBuZXcgU2V0KFtoYW5kbGVyXSldXSkpO1xuICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHRoaXMuX2RlbGVnYXRlRXZlbnRIYW5kbGVyLCBwYXNzaXZlQ2FwdHVyaW5nRXZlbnRPcHRpb25zJDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgYW4gZXZlbnQgaGFuZGxlci4gKi9cbiAgICByZW1vdmVIYW5kbGVyKG5hbWUsIGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlcnNGb3JFdmVudCA9IHRoaXMuX2V2ZW50cy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghaGFuZGxlcnNGb3JFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzRm9yRWxlbWVudCA9IGhhbmRsZXJzRm9yRXZlbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWhhbmRsZXJzRm9yRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJzRm9yRWxlbWVudC5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIGlmIChoYW5kbGVyc0ZvckVsZW1lbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgaGFuZGxlcnNGb3JFdmVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXJzRm9yRXZlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgdGhpcy5fZGVsZWdhdGVFdmVudEhhbmRsZXIsIHBhc3NpdmVDYXB0dXJpbmdFdmVudE9wdGlvbnMkMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGVmYXVsdCByaXBwbGUgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIHJpcHBsZXMgd2l0aG91dCBhbiBleHBsaWNpdFxuICogYW5pbWF0aW9uIGNvbmZpZyBzcGVjaWZpZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRSaXBwbGVBbmltYXRpb25Db25maWcgPSB7XG4gICAgZW50ZXJEdXJhdGlvbjogMjI1LFxuICAgIGV4aXREdXJhdGlvbjogMTUwLFxufTtcbi8qKlxuICogVGltZW91dCBmb3IgaWdub3JpbmcgbW91c2UgZXZlbnRzLiBNb3VzZSBldmVudHMgd2lsbCBiZSB0ZW1wb3JhcnkgaWdub3JlZCBhZnRlciB0b3VjaFxuICogZXZlbnRzIHRvIGF2b2lkIHN5bnRoZXRpYyBtb3VzZSBldmVudHMuXG4gKi9cbmNvbnN0IGlnbm9yZU1vdXNlRXZlbnRzVGltZW91dCA9IDgwMDtcbi8qKiBPcHRpb25zIHVzZWQgdG8gYmluZCBhIHBhc3NpdmUgY2FwdHVyaW5nIGV2ZW50LiAqL1xuY29uc3QgcGFzc2l2ZUNhcHR1cmluZ0V2ZW50T3B0aW9ucyA9IG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMoe1xuICAgIHBhc3NpdmU6IHRydWUsXG4gICAgY2FwdHVyZTogdHJ1ZSxcbn0pO1xuLyoqIEV2ZW50cyB0aGF0IHNpZ25hbCB0aGF0IHRoZSBwb2ludGVyIGlzIGRvd24uICovXG5jb25zdCBwb2ludGVyRG93bkV2ZW50cyA9IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXTtcbi8qKiBFdmVudHMgdGhhdCBzaWduYWwgdGhhdCB0aGUgcG9pbnRlciBpcyB1cC4gKi9cbmNvbnN0IHBvaW50ZXJVcEV2ZW50cyA9IFsnbW91c2V1cCcsICdtb3VzZWxlYXZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJ107XG4vKipcbiAqIEhlbHBlciBzZXJ2aWNlIHRoYXQgcGVyZm9ybXMgRE9NIG1hbmlwdWxhdGlvbnMuIE5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIG91dHNpZGUgdGhpcyBtb2R1bGUuXG4gKiBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSByZWZlcmVuY2UgdG8gdGhlIHJpcHBsZSBkaXJlY3RpdmUncyBob3N0IGVsZW1lbnQgYW5kIGEgbWFwIG9mIERPTVxuICogZXZlbnQgaGFuZGxlcnMgdG8gYmUgaW5zdGFsbGVkIG9uIHRoZSBlbGVtZW50IHRoYXQgdHJpZ2dlcnMgcmlwcGxlIGFuaW1hdGlvbnMuXG4gKiBUaGlzIHdpbGwgZXZlbnR1YWxseSBiZWNvbWUgYSBjdXN0b20gcmVuZGVyZXIgb25jZSBBbmd1bGFyIHN1cHBvcnQgZXhpc3RzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jbGFzcyBSaXBwbGVSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IoX3RhcmdldCwgX25nWm9uZSwgZWxlbWVudE9yRWxlbWVudFJlZiwgX3BsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IF90YXJnZXQ7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcG9pbnRlciBpcyBjdXJyZW50bHkgZG93biBvciBub3QuICovXG4gICAgICAgIHRoaXMuX2lzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBvZiBjdXJyZW50bHkgYWN0aXZlIHJpcHBsZSByZWZlcmVuY2VzLlxuICAgICAgICAgKiBUaGUgcmlwcGxlIHJlZmVyZW5jZSBpcyBtYXBwZWQgdG8gaXRzIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgKiBUaGUgcmVhc29uIHdoeSBgfCBudWxsYCBpcyB1c2VkIGlzIHRoYXQgZXZlbnQgbGlzdGVuZXJzIGFyZSBhZGRlZCBvbmx5XG4gICAgICAgICAqIHdoZW4gdGhlIGNvbmRpdGlvbiBpcyB0cnV0aHkgKHNlZSB0aGUgYF9zdGFydEZhZGVPdXRUcmFuc2l0aW9uYCBtZXRob2QpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIFdoZXRoZXIgcG9pbnRlci11cCBldmVudCBsaXN0ZW5lcnMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuICovXG4gICAgICAgIHRoaXMuX3BvaW50ZXJVcEV2ZW50c1JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gT25seSBkbyBhbnl0aGluZyBpZiB3ZSdyZSBvbiB0aGUgYnJvd3Nlci5cbiAgICAgICAgaWYgKF9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGVsZW1lbnRPckVsZW1lbnRSZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhZGVzIGluIGEgcmlwcGxlIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0geCBDb29yZGluYXRlIHdpdGhpbiB0aGUgZWxlbWVudCwgYWxvbmcgdGhlIFggYXhpcyBhdCB3aGljaCB0byBzdGFydCB0aGUgcmlwcGxlLlxuICAgICAqIEBwYXJhbSB5IENvb3JkaW5hdGUgd2l0aGluIHRoZSBlbGVtZW50LCBhbG9uZyB0aGUgWSBheGlzIGF0IHdoaWNoIHRvIHN0YXJ0IHRoZSByaXBwbGUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBFeHRyYSByaXBwbGUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmYWRlSW5SaXBwbGUoeCwgeSwgY29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9ICh0aGlzLl9jb250YWluZXJSZWN0ID1cbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lclJlY3QgfHwgdGhpcy5fY29udGFpbmVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbkNvbmZpZyA9IHsgLi4uZGVmYXVsdFJpcHBsZUFuaW1hdGlvbkNvbmZpZywgLi4uY29uZmlnLmFuaW1hdGlvbiB9O1xuICAgICAgICBpZiAoY29uZmlnLmNlbnRlcmVkKSB7XG4gICAgICAgICAgICB4ID0gY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyUmVjdC53aWR0aCAvIDI7XG4gICAgICAgICAgICB5ID0gY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFkaXVzID0gY29uZmlnLnJhZGl1cyB8fCBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIoeCwgeSwgY29udGFpbmVyUmVjdCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSB4IC0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBvZmZzZXRZID0geSAtIGNvbnRhaW5lclJlY3QudG9wO1xuICAgICAgICBjb25zdCBlbnRlckR1cmF0aW9uID0gYW5pbWF0aW9uQ29uZmlnLmVudGVyRHVyYXRpb247XG4gICAgICAgIGNvbnN0IHJpcHBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnbWF0LXJpcHBsZS1lbGVtZW50Jyk7XG4gICAgICAgIHJpcHBsZS5zdHlsZS5sZWZ0ID0gYCR7b2Zmc2V0WCAtIHJhZGl1c31weGA7XG4gICAgICAgIHJpcHBsZS5zdHlsZS50b3AgPSBgJHtvZmZzZXRZIC0gcmFkaXVzfXB4YDtcbiAgICAgICAgcmlwcGxlLnN0eWxlLmhlaWdodCA9IGAke3JhZGl1cyAqIDJ9cHhgO1xuICAgICAgICByaXBwbGUuc3R5bGUud2lkdGggPSBgJHtyYWRpdXMgKiAyfXB4YDtcbiAgICAgICAgLy8gSWYgYSBjdXN0b20gY29sb3IgaGFzIGJlZW4gc3BlY2lmaWVkLCBzZXQgaXQgYXMgaW5saW5lIHN0eWxlLiBJZiBubyBjb2xvciBpc1xuICAgICAgICAvLyBzZXQsIHRoZSBkZWZhdWx0IGNvbG9yIHdpbGwgYmUgYXBwbGllZCB0aHJvdWdoIHRoZSByaXBwbGUgdGhlbWUgc3R5bGVzLlxuICAgICAgICBpZiAoY29uZmlnLmNvbG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJpcHBsZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb25maWcuY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke2VudGVyRHVyYXRpb259bXNgO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHJpcHBsZSk7XG4gICAgICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVjYWxjdWxhdGUgdGhlIHN0eWxlcyBvZiBkeW5hbWljYWxseSBjcmVhdGVkXG4gICAgICAgIC8vIHJpcHBsZSBlbGVtZW50cy4gVGhpcyBpcyBjcml0aWNhbCB0byBlbnN1cmUgdGhhdCB0aGUgYHNjYWxlYCBhbmltYXRlcyBwcm9wZXJseS5cbiAgICAgICAgLy8gV2UgZW5mb3JjZSBhIHN0eWxlIHJlY2FsY3VsYXRpb24gYnkgY2FsbGluZyBgZ2V0Q29tcHV0ZWRTdHlsZWAgYW5kICphY2Nlc3NpbmcqIGEgcHJvcGVydHkuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocmlwcGxlKTtcbiAgICAgICAgY29uc3QgdXNlclRyYW5zaXRpb25Qcm9wZXJ0eSA9IGNvbXB1dGVkU3R5bGVzLnRyYW5zaXRpb25Qcm9wZXJ0eTtcbiAgICAgICAgY29uc3QgdXNlclRyYW5zaXRpb25EdXJhdGlvbiA9IGNvbXB1dGVkU3R5bGVzLnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgICAgICAgLy8gTm90ZTogV2UgZGV0ZWN0IHdoZXRoZXIgYW5pbWF0aW9uIGlzIGZvcmNpYmx5IGRpc2FibGVkIHRocm91Z2ggQ1NTIChlLmcuIHRocm91Z2hcbiAgICAgICAgLy8gYHRyYW5zaXRpb246IG5vbmVgIG9yIGBkaXNwbGF5OiBub25lYCkuIFRoaXMgaXMgdGVjaG5pY2FsbHkgdW5leHBlY3RlZCBzaW5jZSBhbmltYXRpb25zIGFyZVxuICAgICAgICAvLyBjb250cm9sbGVkIHRocm91Z2ggdGhlIGFuaW1hdGlvbiBjb25maWcsIGJ1dCB0aGlzIGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoaXNcbiAgICAgICAgLy8gbG9naWMgZG9lcyBub3QgbmVlZCB0byBiZSBzdXBlciBhY2N1cmF0ZSBzaW5jZSBpdCBjb3ZlcnMgc29tZSBlZGdlIGNhc2VzIHdoaWNoIGNhbiBiZSBlYXNpbHlcbiAgICAgICAgLy8gYXZvaWRlZCBieSB1c2Vycy5cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uRm9yY2libHlEaXNhYmxlZFRocm91Z2hDc3MgPSB1c2VyVHJhbnNpdGlvblByb3BlcnR5ID09PSAnbm9uZScgfHxcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBjYW5vbmljYWwgdW5pdCBmb3Igc2VyaWFsaXplZCBDU1MgYDx0aW1lPmAgcHJvcGVydGllcyBpcyBzZWNvbmRzLiBBZGRpdGlvbmFsbHlcbiAgICAgICAgICAgIC8vIHNvbWUgYnJvd3NlcnMgZXhwYW5kIHRoZSBkdXJhdGlvbiBmb3IgZXZlcnkgcHJvcGVydHkgKGluIG91ciBjYXNlIGBvcGFjaXR5YCBhbmQgYHRyYW5zZm9ybWApLlxuICAgICAgICAgICAgdXNlclRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJzBzJyB8fFxuICAgICAgICAgICAgdXNlclRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJzBzLCAwcycgfHxcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaXMgMHgwLCBpdCdzIGxpa2VseSBgZGlzcGxheTogbm9uZWAuXG4gICAgICAgICAgICAoY29udGFpbmVyUmVjdC53aWR0aCA9PT0gMCAmJiBjb250YWluZXJSZWN0LmhlaWdodCA9PT0gMCk7XG4gICAgICAgIC8vIEV4cG9zZWQgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICBjb25zdCByaXBwbGVSZWYgPSBuZXcgUmlwcGxlUmVmKHRoaXMsIHJpcHBsZSwgY29uZmlnLCBhbmltYXRpb25Gb3JjaWJseURpc2FibGVkVGhyb3VnaENzcyk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBlbnRlciBhbmltYXRpb24gYnkgc2V0dGluZyB0aGUgdHJhbnNmb3JtL3NjYWxlIHRvIDEwMCUuIFRoZSBhbmltYXRpb24gd2lsbFxuICAgICAgICAvLyBleGVjdXRlIGFzIHBhcnQgb2YgdGhpcyBzdGF0ZW1lbnQgYmVjYXVzZSB3ZSBmb3JjZWQgYSBzdHlsZSByZWNhbGN1bGF0aW9uIGJlZm9yZS5cbiAgICAgICAgLy8gTm90ZTogV2UgdXNlIGEgM2QgdHJhbnNmb3JtIGhlcmUgaW4gb3JkZXIgdG8gYXZvaWQgYW4gaXNzdWUgaW4gU2FmYXJpIHdoZXJlXG4gICAgICAgIC8vIHRoZSByaXBwbGVzIGFyZW4ndCBjbGlwcGVkIHdoZW4gaW5zaWRlIHRoZSBzaGFkb3cgRE9NIChzZWUgIzI0MDI4KS5cbiAgICAgICAgcmlwcGxlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZTNkKDEsIDEsIDEpJztcbiAgICAgICAgcmlwcGxlUmVmLnN0YXRlID0gMCAvKiBSaXBwbGVTdGF0ZS5GQURJTkdfSU4gKi87XG4gICAgICAgIGlmICghY29uZmlnLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX21vc3RSZWNlbnRUcmFuc2llbnRSaXBwbGUgPSByaXBwbGVSZWY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgLy8gRG8gbm90IHJlZ2lzdGVyIHRoZSBgdHJhbnNpdGlvbmAgZXZlbnQgbGlzdGVuZXIgaWYgZmFkZS1pbiBhbmQgZmFkZS1vdXQgZHVyYXRpb25cbiAgICAgICAgLy8gYXJlIHNldCB0byB6ZXJvLiBUaGUgZXZlbnRzIHdvbid0IGZpcmUgYW55d2F5IGFuZCB3ZSBjYW4gc2F2ZSByZXNvdXJjZXMgaGVyZS5cbiAgICAgICAgaWYgKCFhbmltYXRpb25Gb3JjaWJseURpc2FibGVkVGhyb3VnaENzcyAmJiAoZW50ZXJEdXJhdGlvbiB8fCBhbmltYXRpb25Db25maWcuZXhpdER1cmF0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSAoKSA9PiB0aGlzLl9maW5pc2hSaXBwbGVUcmFuc2l0aW9uKHJpcHBsZVJlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25UcmFuc2l0aW9uQ2FuY2VsID0gKCkgPT4gdGhpcy5fZGVzdHJveVJpcHBsZShyaXBwbGVSZWYpO1xuICAgICAgICAgICAgICAgIHJpcHBsZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNpdGlvbiBpcyBjYW5jZWxsZWQgKGUuZy4gZHVlIHRvIERPTSByZW1vdmFsKSwgd2UgZGVzdHJveSB0aGUgcmlwcGxlXG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgYXMgb3RoZXJ3aXNlIHdlIHdvdWxkIGtlZXAgaXQgcGFydCBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lciBmb3JldmVyLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdHJhbnNpdGlvbnMtMS8jOn46dGV4dD1ubyUyMGxvbmdlciUyMGluJTIwdGhlJTIwZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgcmlwcGxlLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25jYW5jZWwnLCBvblRyYW5zaXRpb25DYW5jZWwpO1xuICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzID0geyBvblRyYW5zaXRpb25FbmQsIG9uVHJhbnNpdGlvbkNhbmNlbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSByaXBwbGUgcmVmZXJlbmNlIHRvIHRoZSBsaXN0IG9mIGFsbCBhY3RpdmUgcmlwcGxlcy5cbiAgICAgICAgdGhpcy5fYWN0aXZlUmlwcGxlcy5zZXQocmlwcGxlUmVmLCBldmVudExpc3RlbmVycyk7XG4gICAgICAgIC8vIEluIGNhc2UgdGhlcmUgaXMgbm8gZmFkZS1pbiB0cmFuc2l0aW9uIGR1cmF0aW9uLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhlIHRyYW5zaXRpb25cbiAgICAgICAgLy8gZW5kIGxpc3RlbmVyIGJlY2F1c2UgYHRyYW5zaXRpb25lbmRgIGRvZXNuJ3QgZmlyZSBpZiB0aGVyZSBpcyBubyB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAoYW5pbWF0aW9uRm9yY2libHlEaXNhYmxlZFRocm91Z2hDc3MgfHwgIWVudGVyRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFJpcHBsZVRyYW5zaXRpb24ocmlwcGxlUmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmlwcGxlUmVmO1xuICAgIH1cbiAgICAvKiogRmFkZXMgb3V0IGEgcmlwcGxlIHJlZmVyZW5jZS4gKi9cbiAgICBmYWRlT3V0UmlwcGxlKHJpcHBsZVJlZikge1xuICAgICAgICAvLyBGb3IgcmlwcGxlcyBhbHJlYWR5IGZhZGluZyBvdXQgb3IgaGlkZGVuLCB0aGlzIHNob3VsZCBiZSBhIG5vb3AuXG4gICAgICAgIGlmIChyaXBwbGVSZWYuc3RhdGUgPT09IDIgLyogUmlwcGxlU3RhdGUuRkFESU5HX09VVCAqLyB8fCByaXBwbGVSZWYuc3RhdGUgPT09IDMgLyogUmlwcGxlU3RhdGUuSElEREVOICovKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlwcGxlRWwgPSByaXBwbGVSZWYuZWxlbWVudDtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uQ29uZmlnID0geyAuLi5kZWZhdWx0UmlwcGxlQW5pbWF0aW9uQ29uZmlnLCAuLi5yaXBwbGVSZWYuY29uZmlnLmFuaW1hdGlvbiB9O1xuICAgICAgICAvLyBUaGlzIHN0YXJ0cyB0aGUgZmFkZS1vdXQgdHJhbnNpdGlvbiBhbmQgd2lsbCBmaXJlIHRoZSB0cmFuc2l0aW9uIGVuZCBsaXN0ZW5lciB0aGF0XG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIHJpcHBsZSBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICAgICAgcmlwcGxlRWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7YW5pbWF0aW9uQ29uZmlnLmV4aXREdXJhdGlvbn1tc2A7XG4gICAgICAgIHJpcHBsZUVsLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIHJpcHBsZVJlZi5zdGF0ZSA9IDIgLyogUmlwcGxlU3RhdGUuRkFESU5HX09VVCAqLztcbiAgICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBubyBmYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uLCB3ZSBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgdGhlXG4gICAgICAgIC8vIHRyYW5zaXRpb24gZW5kIGxpc3RlbmVyIGJlY2F1c2UgYHRyYW5zaXRpb25lbmRgIGRvZXNuJ3QgZmlyZSBpZiB0aGVyZSBpcyBubyB0cmFuc2l0aW9uLlxuICAgICAgICBpZiAocmlwcGxlUmVmLl9hbmltYXRpb25Gb3JjaWJseURpc2FibGVkVGhyb3VnaENzcyB8fCAhYW5pbWF0aW9uQ29uZmlnLmV4aXREdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoUmlwcGxlVHJhbnNpdGlvbihyaXBwbGVSZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBhY3RpdmUgcmlwcGxlcy4gKi9cbiAgICBmYWRlT3V0QWxsKCkge1xuICAgICAgICB0aGlzLl9nZXRBY3RpdmVSaXBwbGVzKCkuZm9yRWFjaChyaXBwbGUgPT4gcmlwcGxlLmZhZGVPdXQoKSk7XG4gICAgfVxuICAgIC8qKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBhY3RpdmUgbm9uLXBlcnNpc3RlbnQgcmlwcGxlcy4gKi9cbiAgICBmYWRlT3V0QWxsTm9uUGVyc2lzdGVudCgpIHtcbiAgICAgICAgdGhpcy5fZ2V0QWN0aXZlUmlwcGxlcygpLmZvckVhY2gocmlwcGxlID0+IHtcbiAgICAgICAgICAgIGlmICghcmlwcGxlLmNvbmZpZy5wZXJzaXN0ZW50KSB7XG4gICAgICAgICAgICAgICAgcmlwcGxlLmZhZGVPdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBTZXRzIHVwIHRoZSB0cmlnZ2VyIGV2ZW50IGxpc3RlbmVycyAqL1xuICAgIHNldHVwVHJpZ2dlckV2ZW50cyhlbGVtZW50T3JFbGVtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGVsZW1lbnRPckVsZW1lbnRSZWYpO1xuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3NlciB8fCAhZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLl90cmlnZ2VyRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgcHJldmlvdXNseSByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSB0cmlnZ2VyIGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3JlbW92ZVRyaWdnZXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAvLyBVc2UgZXZlbnQgZGVsZWdhdGlvbiBmb3IgdGhlIHRyaWdnZXIgZXZlbnRzIHNpbmNlIHRoZXkncmVcbiAgICAgICAgLy8gc2V0IHVwIGR1cmluZyBjcmVhdGlvbiBhbmQgYXJlIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZS5cbiAgICAgICAgcG9pbnRlckRvd25FdmVudHMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICAgIFJpcHBsZVJlbmRlcmVyLl9ldmVudE1hbmFnZXIuYWRkSGFuZGxlcih0aGlzLl9uZ1pvbmUsIHR5cGUsIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbGwgcmVnaXN0ZXJlZCBldmVudHMuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgdGhpcy5fb25Nb3VzZWRvd24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgdGhpcy5fb25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29uUG9pbnRlclVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcG9pbnRlci11cCBldmVudHMgaGF2ZW4ndCBiZWVuIHJlZ2lzdGVyZWQgeWV0LCBkbyBzbyBub3cuXG4gICAgICAgIC8vIFdlIGRvIHRoaXMgb24tZGVtYW5kIGluIG9yZGVyIHRvIHJlZHVjZSB0aGUgdG90YWwgbnVtYmVyIG9mIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICAvLyByZWdpc3RlcmVkIGJ5IHRoZSByaXBwbGVzLCB3aGljaCBzcGVlZHMgdXAgdGhlIHJlbmRlcmluZyB0aW1lIGZvciBsYXJnZSBVSXMuXG4gICAgICAgIGlmICghdGhpcy5fcG9pbnRlclVwRXZlbnRzUmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGV2ZW50cyBmb3IgaGlkaW5nIHRoZSByaXBwbGUgYXJlIGJvdW5kIGRpcmVjdGx5IG9uIHRoZSB0cmlnZ2VyLCBiZWNhdXNlOlxuICAgICAgICAgICAgLy8gMS4gU29tZSBvZiB0aGVtIG9jY3VyIGZyZXF1ZW50bHkgKGUuZy4gYG1vdXNlbGVhdmVgKSBhbmQgYW55IGFkdmFudGFnZSB3ZSBnZXQgZnJvbVxuICAgICAgICAgICAgLy8gZGVsZWdhdGlvbiB3aWxsIGJlIGRpbWluaXNoZWQgYnkgaGF2aW5nIHRvIGxvb2sgdGhyb3VnaCBhbGwgdGhlIGRhdGEgc3RydWN0dXJlcyBvZnRlbi5cbiAgICAgICAgICAgIC8vIDIuIFRoZXkgYXJlbid0IGFzIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSwgYmVjYXVzZSB0aGV5J3JlIGJvdW5kIG9ubHkgYWZ0ZXIgdGhlIHVzZXJcbiAgICAgICAgICAgIC8vIGhhcyBpbnRlcmFjdGVkIHdpdGggYW4gZWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclVwRXZlbnRzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcywgcGFzc2l2ZUNhcHR1cmluZ0V2ZW50T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJVcEV2ZW50c1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNZXRob2QgdGhhdCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgZmFkZS1pbiBvciBmYWRlLWluIHRyYW5zaXRpb24gY29tcGxldGVkLiAqL1xuICAgIF9maW5pc2hSaXBwbGVUcmFuc2l0aW9uKHJpcHBsZVJlZikge1xuICAgICAgICBpZiAocmlwcGxlUmVmLnN0YXRlID09PSAwIC8qIFJpcHBsZVN0YXRlLkZBRElOR19JTiAqLykge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRGYWRlT3V0VHJhbnNpdGlvbihyaXBwbGVSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJpcHBsZVJlZi5zdGF0ZSA9PT0gMiAvKiBSaXBwbGVTdGF0ZS5GQURJTkdfT1VUICovKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95UmlwcGxlKHJpcHBsZVJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBmYWRlLW91dCB0cmFuc2l0aW9uIG9mIHRoZSBnaXZlbiByaXBwbGUgaWYgaXQncyBub3QgcGVyc2lzdGVudCBhbmQgdGhlIHBvaW50ZXJcbiAgICAgKiBpcyBub3QgaGVsZCBkb3duIGFueW1vcmUuXG4gICAgICovXG4gICAgX3N0YXJ0RmFkZU91dFRyYW5zaXRpb24ocmlwcGxlUmVmKSB7XG4gICAgICAgIGNvbnN0IGlzTW9zdFJlY2VudFRyYW5zaWVudFJpcHBsZSA9IHJpcHBsZVJlZiA9PT0gdGhpcy5fbW9zdFJlY2VudFRyYW5zaWVudFJpcHBsZTtcbiAgICAgICAgY29uc3QgeyBwZXJzaXN0ZW50IH0gPSByaXBwbGVSZWYuY29uZmlnO1xuICAgICAgICByaXBwbGVSZWYuc3RhdGUgPSAxIC8qIFJpcHBsZVN0YXRlLlZJU0lCTEUgKi87XG4gICAgICAgIC8vIFdoZW4gdGhlIHRpbWVyIHJ1bnMgb3V0IHdoaWxlIHRoZSB1c2VyIGhhcyBrZXB0IHRoZWlyIHBvaW50ZXIgZG93biwgd2Ugd2FudCB0b1xuICAgICAgICAvLyBrZWVwIG9ubHkgdGhlIHBlcnNpc3RlbnQgcmlwcGxlcyBhbmQgdGhlIGxhdGVzdCB0cmFuc2llbnQgcmlwcGxlLiBXZSBkbyB0aGlzLFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgc3RhY2tlZCB0cmFuc2llbnQgcmlwcGxlcyB0byBhcHBlYXIgYWZ0ZXIgdGhlaXIgZW50ZXJcbiAgICAgICAgLy8gYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cbiAgICAgICAgaWYgKCFwZXJzaXN0ZW50ICYmICghaXNNb3N0UmVjZW50VHJhbnNpZW50UmlwcGxlIHx8ICF0aGlzLl9pc1BvaW50ZXJEb3duKSkge1xuICAgICAgICAgICAgcmlwcGxlUmVmLmZhZGVPdXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRGVzdHJveXMgdGhlIGdpdmVuIHJpcHBsZSBieSByZW1vdmluZyBpdCBmcm9tIHRoZSBET00gYW5kIHVwZGF0aW5nIGl0cyBzdGF0ZS4gKi9cbiAgICBfZGVzdHJveVJpcHBsZShyaXBwbGVSZWYpIHtcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9hY3RpdmVSaXBwbGVzLmdldChyaXBwbGVSZWYpID8/IG51bGw7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVJpcHBsZXMuZGVsZXRlKHJpcHBsZVJlZik7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgY2FjaGVkIGJvdW5kaW5nIHJlY3QgaWYgd2UgaGF2ZSBubyBtb3JlIHJpcHBsZXMuXG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlUmlwcGxlcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXJSZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCByZWYgaXMgdGhlIG1vc3QgcmVjZW50IHRyYW5zaWVudCByaXBwbGUsIHVuc2V0IGl0XG4gICAgICAgIC8vIGF2b2lkIG1lbW9yeSBsZWFrcy5cbiAgICAgICAgaWYgKHJpcHBsZVJlZiA9PT0gdGhpcy5fbW9zdFJlY2VudFRyYW5zaWVudFJpcHBsZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9zdFJlY2VudFRyYW5zaWVudFJpcHBsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmlwcGxlUmVmLnN0YXRlID0gMyAvKiBSaXBwbGVTdGF0ZS5ISURERU4gKi87XG4gICAgICAgIGlmIChldmVudExpc3RlbmVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmlwcGxlUmVmLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGV2ZW50TGlzdGVuZXJzLm9uVHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICByaXBwbGVSZWYuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uY2FuY2VsJywgZXZlbnRMaXN0ZW5lcnMub25UcmFuc2l0aW9uQ2FuY2VsKTtcbiAgICAgICAgfVxuICAgICAgICByaXBwbGVSZWYuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9XG4gICAgLyoqIEZ1bmN0aW9uIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgdHJpZ2dlciBpcyBiZWluZyBwcmVzc2VkIHVzaW5nIG1vdXNlLiAqL1xuICAgIF9vbk1vdXNlZG93bihldmVudCkge1xuICAgICAgICAvLyBTY3JlZW4gcmVhZGVycyB3aWxsIGZpcmUgZmFrZSBtb3VzZSBldmVudHMgZm9yIHNwYWNlL2VudGVyLiBTa2lwIGxhdW5jaGluZyBhXG4gICAgICAgIC8vIHJpcHBsZSBpbiB0aGlzIGNhc2UgZm9yIGNvbnNpc3RlbmN5IHdpdGggdGhlIG5vbi1zY3JlZW4tcmVhZGVyIGV4cGVyaWVuY2UuXG4gICAgICAgIGNvbnN0IGlzRmFrZU1vdXNlZG93biA9IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpO1xuICAgICAgICBjb25zdCBpc1N5bnRoZXRpY0V2ZW50ID0gdGhpcy5fbGFzdFRvdWNoU3RhcnRFdmVudCAmJlxuICAgICAgICAgICAgRGF0ZS5ub3coKSA8IHRoaXMuX2xhc3RUb3VjaFN0YXJ0RXZlbnQgKyBpZ25vcmVNb3VzZUV2ZW50c1RpbWVvdXQ7XG4gICAgICAgIGlmICghdGhpcy5fdGFyZ2V0LnJpcHBsZURpc2FibGVkICYmICFpc0Zha2VNb3VzZWRvd24gJiYgIWlzU3ludGhldGljRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUG9pbnRlckRvd24gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5mYWRlSW5SaXBwbGUoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgdGhpcy5fdGFyZ2V0LnJpcHBsZUNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEZ1bmN0aW9uIGJlaW5nIGNhbGxlZCB3aGVuZXZlciB0aGUgdHJpZ2dlciBpcyBiZWluZyBwcmVzc2VkIHVzaW5nIHRvdWNoLiAqL1xuICAgIF9vblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90YXJnZXQucmlwcGxlRGlzYWJsZWQgJiYgIWlzRmFrZVRvdWNoc3RhcnRGcm9tU2NyZWVuUmVhZGVyKGV2ZW50KSkge1xuICAgICAgICAgICAgLy8gU29tZSBicm93c2VycyBmaXJlIG1vdXNlIGV2ZW50cyBhZnRlciBhIGB0b3VjaHN0YXJ0YCBldmVudC4gVGhvc2Ugc3ludGhldGljIG1vdXNlXG4gICAgICAgICAgICAvLyBldmVudHMgd2lsbCBsYXVuY2ggYSBzZWNvbmQgcmlwcGxlIGlmIHdlIGRvbid0IGlnbm9yZSBtb3VzZSBldmVudHMgZm9yIGEgc3BlY2lmaWNcbiAgICAgICAgICAgIC8vIHRpbWUgYWZ0ZXIgYSB0b3VjaHN0YXJ0IGV2ZW50LlxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoU3RhcnRFdmVudCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLl9pc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFVzZSBgY2hhbmdlZFRvdWNoZXNgIHNvIHdlIHNraXAgYW55IHRvdWNoZXMgd2hlcmUgdGhlIHVzZXIgcHV0XG4gICAgICAgICAgICAvLyB0aGVpciBmaW5nZXIgZG93biwgYnV0IHVzZWQgYW5vdGhlciBmaW5nZXIgdG8gdGFwIHRoZSBlbGVtZW50IGFnYWluLlxuICAgICAgICAgICAgY29uc3QgdG91Y2hlcyA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWRlSW5SaXBwbGUodG91Y2hlc1tpXS5jbGllbnRYLCB0b3VjaGVzW2ldLmNsaWVudFksIHRoaXMuX3RhcmdldC5yaXBwbGVDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBGdW5jdGlvbiBiZWluZyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHRyaWdnZXIgaXMgYmVpbmcgcmVsZWFzZWQuICovXG4gICAgX29uUG9pbnRlclVwKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzUG9pbnRlckRvd24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICAgIC8vIEZhZGUtb3V0IGFsbCByaXBwbGVzIHRoYXQgYXJlIHZpc2libGUgYW5kIG5vdCBwZXJzaXN0ZW50LlxuICAgICAgICB0aGlzLl9nZXRBY3RpdmVSaXBwbGVzKCkuZm9yRWFjaChyaXBwbGUgPT4ge1xuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgb25seSByaXBwbGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdmlzaWJsZSB3aWxsIGZhZGUgb3V0IG9uIHBvaW50ZXIgcmVsZWFzZS5cbiAgICAgICAgICAgIC8vIElmIHRoZSBgdGVybWluYXRlT25Qb2ludGVyVXBgIG9wdGlvbiBpcyBzZXQsIHJpcHBsZXMgdGhhdCBzdGlsbCBmYWRlIGluIHdpbGwgYWxzbyBmYWRlIG91dC5cbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IHJpcHBsZS5zdGF0ZSA9PT0gMSAvKiBSaXBwbGVTdGF0ZS5WSVNJQkxFICovIHx8XG4gICAgICAgICAgICAgICAgKHJpcHBsZS5jb25maWcudGVybWluYXRlT25Qb2ludGVyVXAgJiYgcmlwcGxlLnN0YXRlID09PSAwIC8qIFJpcHBsZVN0YXRlLkZBRElOR19JTiAqLyk7XG4gICAgICAgICAgICBpZiAoIXJpcHBsZS5jb25maWcucGVyc2lzdGVudCAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICByaXBwbGUuZmFkZU91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFjdGl2ZVJpcHBsZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2FjdGl2ZVJpcHBsZXMua2V5cygpKTtcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgcHJldmlvdXNseSByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSB0cmlnZ2VyIGVsZW1lbnQuICovXG4gICAgX3JlbW92ZVRyaWdnZXJFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyRWxlbWVudDtcbiAgICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIHBvaW50ZXJEb3duRXZlbnRzLmZvckVhY2godHlwZSA9PiBSaXBwbGVSZW5kZXJlci5fZXZlbnRNYW5hZ2VyLnJlbW92ZUhhbmRsZXIodHlwZSwgdHJpZ2dlciwgdGhpcykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50ZXJVcEV2ZW50c1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgICAgICAgICBwb2ludGVyVXBFdmVudHMuZm9yRWFjaCh0eXBlID0+IHRyaWdnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLCBwYXNzaXZlQ2FwdHVyaW5nRXZlbnRPcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5SaXBwbGVSZW5kZXJlci5fZXZlbnRNYW5hZ2VyID0gbmV3IFJpcHBsZUV2ZW50TWFuYWdlcigpO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCAoeCwgeSkgdG8gdGhlIGZ1cnRoZXN0IGNvcm5lciBvZiBhIHJlY3RhbmdsZS5cbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2VUb0Z1cnRoZXN0Q29ybmVyKHgsIHksIHJlY3QpIHtcbiAgICBjb25zdCBkaXN0WCA9IE1hdGgubWF4KE1hdGguYWJzKHggLSByZWN0LmxlZnQpLCBNYXRoLmFicyh4IC0gcmVjdC5yaWdodCkpO1xuICAgIGNvbnN0IGRpc3RZID0gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHJlY3QudG9wKSwgTWF0aC5hYnMoeSAtIHJlY3QuYm90dG9tKSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgdGhlIGdsb2JhbCByaXBwbGUgb3B0aW9ucy4gKi9cbmNvbnN0IE1BVF9SSVBQTEVfR0xPQkFMX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ21hdC1yaXBwbGUtZ2xvYmFsLW9wdGlvbnMnKTtcbmNsYXNzIE1hdFJpcHBsZSB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBjbGljayBldmVudHMgd2lsbCBub3QgdHJpZ2dlciB0aGUgcmlwcGxlLiBSaXBwbGVzIGNhbiBiZSBzdGlsbCBsYXVuY2hlZCBtYW51YWxseVxuICAgICAqIGJ5IHVzaW5nIHRoZSBgbGF1bmNoKClgIG1ldGhvZC5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mYWRlT3V0QWxsTm9uUGVyc2lzdGVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NldHVwVHJpZ2dlckV2ZW50c0lmRW5hYmxlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHRoZSByaXBwbGUgd2hlbiBjbGljayBldmVudHMgYXJlIHJlY2VpdmVkLlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBkaXJlY3RpdmUncyBob3N0IGVsZW1lbnQuXG4gICAgICovXG4gICAgZ2V0IHRyaWdnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmlnZ2VyIHx8IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgc2V0IHRyaWdnZXIodHJpZ2dlcikge1xuICAgICAgICB0aGlzLl90cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICAgICAgdGhpcy5fc2V0dXBUcmlnZ2VyRXZlbnRzSWZFbmFibGVkKCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmLCBuZ1pvbmUsIHBsYXRmb3JtLCBnbG9iYWxPcHRpb25zLCBfYW5pbWF0aW9uTW9kZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk1vZGUgPSBfYW5pbWF0aW9uTW9kZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCwgdGhlIHJhZGl1cyBpbiBwaXhlbHMgb2YgZm9yZWdyb3VuZCByaXBwbGVzIHdoZW4gZnVsbHkgZXhwYW5kZWQuIElmIHVuc2V0LCB0aGUgcmFkaXVzXG4gICAgICAgICAqIHdpbGwgYmUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgcmlwcGxlIHRvIHRoZSBmdXJ0aGVzdCBjb3JuZXIgb2YgdGhlIGhvc3QgZWxlbWVudCdzXG4gICAgICAgICAqIGJvdW5kaW5nIHJlY3RhbmdsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgcmlwcGxlIGRpcmVjdGl2ZSBpcyBpbml0aWFsaXplZCBhbmQgdGhlIGlucHV0IGJpbmRpbmdzIGFyZSBzZXQuICovXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyID0gbmV3IFJpcHBsZVJlbmRlcmVyKHRoaXMsIG5nWm9uZSwgX2VsZW1lbnRSZWYsIHBsYXRmb3JtKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zZXR1cFRyaWdnZXJFdmVudHNJZkVuYWJsZWQoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLl9yZW1vdmVUcmlnZ2VyRXZlbnRzKCk7XG4gICAgfVxuICAgIC8qKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBzaG93aW5nIHJpcHBsZSBlbGVtZW50cy4gKi9cbiAgICBmYWRlT3V0QWxsKCkge1xuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlT3V0QWxsKCk7XG4gICAgfVxuICAgIC8qKiBGYWRlcyBvdXQgYWxsIGN1cnJlbnRseSBzaG93aW5nIG5vbi1wZXJzaXN0ZW50IHJpcHBsZSBlbGVtZW50cy4gKi9cbiAgICBmYWRlT3V0QWxsTm9uUGVyc2lzdGVudCgpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuZmFkZU91dEFsbE5vblBlcnNpc3RlbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmlwcGxlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZGlyZWN0aXZlJ3MgaW5wdXQgdmFsdWVzLlxuICAgICAqIEBkb2NzLXByaXZhdGUgSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBSaXBwbGVUYXJnZXRcbiAgICAgKi9cbiAgICBnZXQgcmlwcGxlQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2VudGVyZWQ6IHRoaXMuY2VudGVyZWQsXG4gICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLFxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgICBhbmltYXRpb246IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9nbG9iYWxPcHRpb25zLmFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAuLi4odGhpcy5fYW5pbWF0aW9uTW9kZSA9PT0gJ05vb3BBbmltYXRpb25zJyA/IHsgZW50ZXJEdXJhdGlvbjogMCwgZXhpdER1cmF0aW9uOiAwIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5hbmltYXRpb24sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVybWluYXRlT25Qb2ludGVyVXA6IHRoaXMuX2dsb2JhbE9wdGlvbnMudGVybWluYXRlT25Qb2ludGVyVXAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmlwcGxlcyBvbiBwb2ludGVyLWRvd24gYXJlIGRpc2FibGVkIG9yIG5vdC5cbiAgICAgKiBAZG9jcy1wcml2YXRlIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgUmlwcGxlVGFyZ2V0XG4gICAgICovXG4gICAgZ2V0IHJpcHBsZURpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCB8fCAhIXRoaXMuX2dsb2JhbE9wdGlvbnMuZGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKiBTZXRzIHVwIHRoZSB0cmlnZ2VyIGV2ZW50IGxpc3RlbmVycyBpZiByaXBwbGVzIGFyZSBlbmFibGVkLiAqL1xuICAgIF9zZXR1cFRyaWdnZXJFdmVudHNJZkVuYWJsZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiB0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5zZXR1cFRyaWdnZXJFdmVudHModGhpcy50cmlnZ2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogTGF1bmNoZXMgYSBtYW51YWwgcmlwcGxlIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZWQgb3IganVzdCBieSB0aGUgcmlwcGxlIGNvbmZpZy4gKi9cbiAgICBsYXVuY2goY29uZmlnT3JYLCB5ID0gMCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnT3JYID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JpcHBsZVJlbmRlcmVyLmZhZGVJblJpcHBsZShjb25maWdPclgsIHksIHsgLi4udGhpcy5yaXBwbGVDb25maWcsIC4uLmNvbmZpZyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlSW5SaXBwbGUoMCwgMCwgeyAuLi50aGlzLnJpcHBsZUNvbmZpZywgLi4uY29uZmlnT3JYIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuTWF0UmlwcGxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UmlwcGxlLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMC5OZ1pvbmUgfSwgeyB0b2tlbjogaTEkMS5QbGF0Zm9ybSB9LCB7IHRva2VuOiBNQVRfUklQUExFX0dMT0JBTF9PUFRJT05TLCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBBTklNQVRJT05fTU9EVUxFX1RZUEUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbk1hdFJpcHBsZS7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdFJpcHBsZSwgc2VsZWN0b3I6IFwiW21hdC1yaXBwbGVdLCBbbWF0UmlwcGxlXVwiLCBpbnB1dHM6IHsgY29sb3I6IFtcIm1hdFJpcHBsZUNvbG9yXCIsIFwiY29sb3JcIl0sIHVuYm91bmRlZDogW1wibWF0UmlwcGxlVW5ib3VuZGVkXCIsIFwidW5ib3VuZGVkXCJdLCBjZW50ZXJlZDogW1wibWF0UmlwcGxlQ2VudGVyZWRcIiwgXCJjZW50ZXJlZFwiXSwgcmFkaXVzOiBbXCJtYXRSaXBwbGVSYWRpdXNcIiwgXCJyYWRpdXNcIl0sIGFuaW1hdGlvbjogW1wibWF0UmlwcGxlQW5pbWF0aW9uXCIsIFwiYW5pbWF0aW9uXCJdLCBkaXNhYmxlZDogW1wibWF0UmlwcGxlRGlzYWJsZWRcIiwgXCJkaXNhYmxlZFwiXSwgdHJpZ2dlcjogW1wibWF0UmlwcGxlVHJpZ2dlclwiLCBcInRyaWdnZXJcIl0gfSwgaG9zdDogeyBwcm9wZXJ0aWVzOiB7IFwiY2xhc3MubWF0LXJpcHBsZS11bmJvdW5kZWRcIjogXCJ1bmJvdW5kZWRcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJtYXQtcmlwcGxlXCIgfSwgZXhwb3J0QXM6IFtcIm1hdFJpcHBsZVwiXSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UmlwcGxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0LXJpcHBsZV0sIFttYXRSaXBwbGVdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdtYXRSaXBwbGUnLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LXJpcHBsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1yaXBwbGUtdW5ib3VuZGVkXSc6ICd1bmJvdW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IGkwLk5nWm9uZSB9LCB7IHR5cGU6IGkxJDEuUGxhdGZvcm0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtNQVRfUklQUExFX0dMT0JBTF9PUFRJT05TXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQU5JTUFUSU9OX01PRFVMRV9UWVBFXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBjb2xvcjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ21hdFJpcHBsZUNvbG9yJ11cbiAgICAgICAgICAgIH1dLCB1bmJvdW5kZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydtYXRSaXBwbGVVbmJvdW5kZWQnXVxuICAgICAgICAgICAgfV0sIGNlbnRlcmVkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbWF0UmlwcGxlQ2VudGVyZWQnXVxuICAgICAgICAgICAgfV0sIHJhZGl1czogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ21hdFJpcHBsZVJhZGl1cyddXG4gICAgICAgICAgICB9XSwgYW5pbWF0aW9uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbWF0UmlwcGxlQW5pbWF0aW9uJ11cbiAgICAgICAgICAgIH1dLCBkaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ21hdFJpcHBsZURpc2FibGVkJ11cbiAgICAgICAgICAgIH1dLCB0cmlnZ2VyOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbWF0UmlwcGxlVHJpZ2dlciddXG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIE1hdFJpcHBsZU1vZHVsZSB7XG59XG5NYXRSaXBwbGVNb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRSaXBwbGVNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pO1xuTWF0UmlwcGxlTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdFJpcHBsZU1vZHVsZSwgZGVjbGFyYXRpb25zOiBbTWF0UmlwcGxlXSwgaW1wb3J0czogW01hdENvbW1vbk1vZHVsZV0sIGV4cG9ydHM6IFtNYXRSaXBwbGUsIE1hdENvbW1vbk1vZHVsZV0gfSk7XG5NYXRSaXBwbGVNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UmlwcGxlTW9kdWxlLCBpbXBvcnRzOiBbTWF0Q29tbW9uTW9kdWxlLCBNYXRDb21tb25Nb2R1bGVdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UmlwcGxlTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbTWF0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01hdFJpcHBsZSwgTWF0Q29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWF0UmlwcGxlXSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IHNob3dzIGEgc2ltcGxpZmllZCBjaGVja2JveCB3aXRob3V0IGluY2x1ZGluZyBhbnkga2luZCBvZiBcInJlYWxcIiBjaGVja2JveC5cbiAqIE1lYW50IHRvIGJlIHVzZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgcHVyZWx5IGRlY29yYXRpdmUgYW5kIGEgbGFyZ2UgbnVtYmVyIG9mIHRoZW0gd2lsbCBiZVxuICogaW5jbHVkZWQsIHN1Y2ggYXMgZm9yIHRoZSBvcHRpb25zIGluIGEgbXVsdGktc2VsZWN0LiBVc2VzIG5vIFNWR3Mgb3IgY29tcGxleCBhbmltYXRpb25zLlxuICogTm90ZSB0aGF0IHRoZW1pbmcgaXMgbWVhbnQgdG8gYmUgaGFuZGxlZCBieSB0aGUgcGFyZW50IGVsZW1lbnQsIGUuZy5cbiAqIGBtYXQtcHJpbWFyeSAubWF0LXBzZXVkby1jaGVja2JveGAuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgY29tcG9uZW50IHdpbGwgYmUgY29tcGxldGVseSBpbnZpc2libGUgdG8gc2NyZWVuLXJlYWRlciB1c2Vycy4gVGhpcyBpcyAqbm90KlxuICogaW50ZXJjaGFuZ2VhYmxlIHdpdGggYDxtYXQtY2hlY2tib3g+YCBhbmQgc2hvdWxkICpub3QqIGJlIHVzZWQgaWYgdGhlIHVzZXIgd291bGQgZGlyZWN0bHlcbiAqIGludGVyYWN0IHdpdGggdGhlIGNoZWNrYm94LiBUaGUgcHNldWRvLWNoZWNrYm94IHNob3VsZCBvbmx5IGJlIHVzZWQgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsXG4gKiBvZiBtb3JlIGNvbXBsZXggY29tcG9uZW50cyB0aGF0IGFwcHJvcHJpYXRlbHkgaGFuZGxlIHNlbGVjdGVkIC8gY2hlY2tlZCBzdGF0ZS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgTWF0UHNldWRvQ2hlY2tib3gge1xuICAgIGNvbnN0cnVjdG9yKF9hbmltYXRpb25Nb2RlKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk1vZGUgPSBfYW5pbWF0aW9uTW9kZTtcbiAgICAgICAgLyoqIERpc3BsYXkgc3RhdGUgb2YgdGhlIGNoZWNrYm94LiAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gJ3VuY2hlY2tlZCc7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyBkaXNhYmxlZC4gKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZWFyYW5jZSBvZiB0aGUgcHNldWRvIGNoZWNrYm94LiBEZWZhdWx0IGFwcGVhcmFuY2Ugb2YgJ2Z1bGwnIHJlbmRlcnMgYSBjaGVja21hcmsvbWl4ZWRtYXJrXG4gICAgICAgICAqIGluZGljYXRvciBpbnNpZGUgYSBzcXVhcmUgYm94LiAnbWluaW1hbCcgYXBwZWFyYW5jZSBvbmx5IHJlbmRlcnMgdGhlIGNoZWNrbWFyay9taXhlZG1hcmsuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZnVsbCc7XG4gICAgfVxufVxuTWF0UHNldWRvQ2hlY2tib3guybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRQc2V1ZG9DaGVja2JveCwgZGVwczogW3sgdG9rZW46IEFOSU1BVElPTl9NT0RVTEVfVFlQRSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuTWF0UHNldWRvQ2hlY2tib3guybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRQc2V1ZG9DaGVja2JveCwgc2VsZWN0b3I6IFwibWF0LXBzZXVkby1jaGVja2JveFwiLCBpbnB1dHM6IHsgc3RhdGU6IFwic3RhdGVcIiwgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIiwgYXBwZWFyYW5jZTogXCJhcHBlYXJhbmNlXCIgfSwgaG9zdDogeyBwcm9wZXJ0aWVzOiB7IFwiY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1pbmRldGVybWluYXRlXCI6IFwic3RhdGUgPT09IFxcXCJpbmRldGVybWluYXRlXFxcIlwiLCBcImNsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZFwiOiBcInN0YXRlID09PSBcXFwiY2hlY2tlZFxcXCJcIiwgXCJjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LWRpc2FibGVkXCI6IFwiZGlzYWJsZWRcIiwgXCJjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LW1pbmltYWxcIjogXCJhcHBlYXJhbmNlID09PSBcXFwibWluaW1hbFxcXCJcIiwgXCJjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LWZ1bGxcIjogXCJhcHBlYXJhbmNlID09PSBcXFwiZnVsbFxcXCJcIiwgXCJjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZVwiOiBcIl9hbmltYXRpb25Nb2RlID09PSBcXFwiTm9vcEFuaW1hdGlvbnNcXFwiXCIgfSwgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LXBzZXVkby1jaGVja2JveFwiIH0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6ICcnLCBpc0lubGluZTogdHJ1ZSwgc3R5bGVzOiBbXCIubWF0LXBzZXVkby1jaGVja2JveHtib3JkZXItcmFkaXVzOjJweDtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjA7dHJhbnNpdGlvbjpib3JkZXItY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAwLjEpLGJhY2tncm91bmQtY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAwLjEpfS5tYXQtcHNldWRvLWNoZWNrYm94OjphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTtvcGFjaXR5OjA7Y29udGVudDpcXFwiXFxcIjtib3JkZXItYm90dG9tOjJweCBzb2xpZCBjdXJyZW50Q29sb3I7dHJhbnNpdGlvbjpvcGFjaXR5IDkwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKX0ubWF0LXBzZXVkby1jaGVja2JveC5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZXt0cmFuc2l0aW9uOm5vbmUgIWltcG9ydGFudDthbmltYXRpb246bm9uZSAhaW1wb3J0YW50fS5tYXQtcHNldWRvLWNoZWNrYm94Ll9tYXQtYW5pbWF0aW9uLW5vb3BhYmxlOjphZnRlcnt0cmFuc2l0aW9uOm5vbmV9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWR7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZTo6YWZ0ZXJ7bGVmdDoxcHg7b3BhY2l0eToxO2JvcmRlci1yYWRpdXM6MnB4fS5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWQ6OmFmdGVye2xlZnQ6MXB4O2JvcmRlci1sZWZ0OjJweCBzb2xpZCBjdXJyZW50Q29sb3I7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO29wYWNpdHk6MTtib3gtc2l6aW5nOmNvbnRlbnQtYm94fS5tYXQtcHNldWRvLWNoZWNrYm94LWZ1bGx7Ym9yZGVyOjJweCBzb2xpZH0ubWF0LXBzZXVkby1jaGVja2JveC1mdWxsLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZCwubWF0LXBzZXVkby1jaGVja2JveC1mdWxsLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZXtib3JkZXItY29sb3I6cmdiYSgwLDAsMCwwKX0ubWF0LXBzZXVkby1jaGVja2JveHt3aWR0aDoxOHB4O2hlaWdodDoxOHB4fS5tYXQtcHNldWRvLWNoZWNrYm94LW1pbmltYWwubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkOjphZnRlcnt3aWR0aDoxNHB4O2hlaWdodDo2cHg7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dG9wOi00LjI0MjY0MDY4NzFweDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDttYXJnaW46YXV0b30ubWF0LXBzZXVkby1jaGVja2JveC1taW5pbWFsLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZTo6YWZ0ZXJ7dG9wOjhweDt3aWR0aDoxNnB4fS5tYXQtcHNldWRvLWNoZWNrYm94LWZ1bGwubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkOjphZnRlcnt3aWR0aDoxMHB4O2hlaWdodDo0cHg7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7dG9wOi0yLjgyODQyNzEyNDdweDtsZWZ0OjA7Ym90dG9tOjA7cmlnaHQ6MDttYXJnaW46YXV0b30ubWF0LXBzZXVkby1jaGVja2JveC1mdWxsLm1hdC1wc2V1ZG8tY2hlY2tib3gtaW5kZXRlcm1pbmF0ZTo6YWZ0ZXJ7dG9wOjZweDt3aWR0aDoxMnB4fVwiXSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIGVuY2Fwc3VsYXRpb246IGkwLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRQc2V1ZG9DaGVja2JveCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7IGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCBzZWxlY3RvcjogJ21hdC1wc2V1ZG8tY2hlY2tib3gnLCB0ZW1wbGF0ZTogJycsIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtcHNldWRvLWNoZWNrYm94JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1pbmRldGVybWluYXRlXSc6ICdzdGF0ZSA9PT0gXCJpbmRldGVybWluYXRlXCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWRdJzogJ3N0YXRlID09PSBcImNoZWNrZWRcIicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWF0LXBzZXVkby1jaGVja2JveC1taW5pbWFsXSc6ICdhcHBlYXJhbmNlID09PSBcIm1pbmltYWxcIicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbF0nOiAnYXBwZWFyYW5jZSA9PT0gXCJmdWxsXCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZV0nOiAnX2FuaW1hdGlvbk1vZGUgPT09IFwiTm9vcEFuaW1hdGlvbnNcIicsXG4gICAgICAgICAgICAgICAgICAgIH0sIHN0eWxlczogW1wiLm1hdC1wc2V1ZG8tY2hlY2tib3h7Ym9yZGVyLXJhZGl1czoycHg7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtwb3NpdGlvbjpyZWxhdGl2ZTtmbGV4LXNocmluazowO3RyYW5zaXRpb246Ym9yZGVyLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKSxiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKX0ubWF0LXBzZXVkby1jaGVja2JveDo6YWZ0ZXJ7cG9zaXRpb246YWJzb2x1dGU7b3BhY2l0eTowO2NvbnRlbnQ6XFxcIlxcXCI7Ym9yZGVyLWJvdHRvbToycHggc29saWQgY3VycmVudENvbG9yO3RyYW5zaXRpb246b3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDAuMSl9Lm1hdC1wc2V1ZG8tY2hlY2tib3guX21hdC1hbmltYXRpb24tbm9vcGFibGV7dHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnQ7YW5pbWF0aW9uOm5vbmUgIWltcG9ydGFudH0ubWF0LXBzZXVkby1jaGVja2JveC5fbWF0LWFuaW1hdGlvbi1ub29wYWJsZTo6YWZ0ZXJ7dHJhbnNpdGlvbjpub25lfS5tYXQtcHNldWRvLWNoZWNrYm94LWRpc2FibGVke2N1cnNvcjpkZWZhdWx0fS5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGU6OmFmdGVye2xlZnQ6MXB4O29wYWNpdHk6MTtib3JkZXItcmFkaXVzOjJweH0ubWF0LXBzZXVkby1jaGVja2JveC1jaGVja2VkOjphZnRlcntsZWZ0OjFweDtib3JkZXItbGVmdDoycHggc29saWQgY3VycmVudENvbG9yO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTtvcGFjaXR5OjE7Ym94LXNpemluZzpjb250ZW50LWJveH0ubWF0LXBzZXVkby1jaGVja2JveC1mdWxse2JvcmRlcjoycHggc29saWR9Lm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbC5tYXQtcHNldWRvLWNoZWNrYm94LWNoZWNrZWQsLm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGV7Ym9yZGVyLWNvbG9yOnJnYmEoMCwwLDAsMCl9Lm1hdC1wc2V1ZG8tY2hlY2tib3h7d2lkdGg6MThweDtoZWlnaHQ6MThweH0ubWF0LXBzZXVkby1jaGVja2JveC1taW5pbWFsLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZDo6YWZ0ZXJ7d2lkdGg6MTRweDtoZWlnaHQ6NnB4O3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO3RvcDotNC4yNDI2NDA2ODcxcHg7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7bWFyZ2luOmF1dG99Lm1hdC1wc2V1ZG8tY2hlY2tib3gtbWluaW1hbC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGU6OmFmdGVye3RvcDo4cHg7d2lkdGg6MTZweH0ubWF0LXBzZXVkby1jaGVja2JveC1mdWxsLm1hdC1wc2V1ZG8tY2hlY2tib3gtY2hlY2tlZDo6YWZ0ZXJ7d2lkdGg6MTBweDtoZWlnaHQ6NHB4O3RyYW5zZm9ybS1vcmlnaW46Y2VudGVyO3RvcDotMi44Mjg0MjcxMjQ3cHg7bGVmdDowO2JvdHRvbTowO3JpZ2h0OjA7bWFyZ2luOmF1dG99Lm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbC5tYXQtcHNldWRvLWNoZWNrYm94LWluZGV0ZXJtaW5hdGU6OmFmdGVye3RvcDo2cHg7d2lkdGg6MTJweH1cIl0gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtBTklNQVRJT05fTU9EVUxFX1RZUEVdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IHN0YXRlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgZGlzYWJsZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBhcHBlYXJhbmNlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIE1hdFBzZXVkb0NoZWNrYm94TW9kdWxlIHtcbn1cbk1hdFBzZXVkb0NoZWNrYm94TW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UHNldWRvQ2hlY2tib3hNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pO1xuTWF0UHNldWRvQ2hlY2tib3hNb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UHNldWRvQ2hlY2tib3hNb2R1bGUsIGRlY2xhcmF0aW9uczogW01hdFBzZXVkb0NoZWNrYm94XSwgaW1wb3J0czogW01hdENvbW1vbk1vZHVsZV0sIGV4cG9ydHM6IFtNYXRQc2V1ZG9DaGVja2JveF0gfSk7XG5NYXRQc2V1ZG9DaGVja2JveE1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZSwgaW1wb3J0czogW01hdENvbW1vbk1vZHVsZV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW01hdENvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYXRQc2V1ZG9DaGVja2JveF0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01hdFBzZXVkb0NoZWNrYm94XSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdXNlZCB0byBwcm92aWRlIHRoZSBwYXJlbnQgY29tcG9uZW50IHRvIG9wdGlvbnMuXG4gKi9cbmNvbnN0IE1BVF9PUFRJT05fUEFSRU5UX0NPTVBPTkVOVCA9IG5ldyBJbmplY3Rpb25Ub2tlbignTUFUX09QVElPTl9QQVJFTlRfQ09NUE9ORU5UJyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLy8gTm90ZXMgb24gdGhlIGFjY2Vzc2liaWxpdHkgcGF0dGVybiB1c2VkIGZvciBgbWF0LW9wdGdyb3VwYC5cbi8vIFRoZSBvcHRpb24gZ3JvdXAgaGFzIHR3byBkaWZmZXJlbnQgXCJtb2Rlc1wiOiByZWd1bGFyIGFuZCBpbmVydC4gVGhlIHJlZ3VsYXIgbW9kZSB1c2VzIHRoZVxuLy8gcmVjb21tZW5kZWQgYTExeSBwYXR0ZXJuIHdoaWNoIGhhcyBgcm9sZT1cImdyb3VwXCJgIG9uIHRoZSBncm91cCBlbGVtZW50IHdpdGggYGFyaWEtbGFiZWxsZWRieWBcbi8vIHBvaW50aW5nIHRvIHRoZSBsYWJlbC4gVGhpcyB3b3JrcyBmb3IgYG1hdC1zZWxlY3RgLCBidXQgaXQgc2VlbXMgdG8gaGl0IGEgYnVnIGZvciBhdXRvY29tcGxldGVcbi8vIHVuZGVyIFZvaWNlT3ZlciB3aGVyZSB0aGUgZ3JvdXAgZG9lc24ndCBnZXQgcmVhZCBvdXQgYXQgYWxsLiBUaGUgYnVnIGFwcGVhcnMgdG8gYmUgdGhhdCBpZlxuLy8gdGhlcmUncyBfX2FueV9fIGExMXktcmVsYXRlZCBhdHRyaWJ1dGUgb24gdGhlIGdyb3VwIChlLmcuIGByb2xlYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCksXG4vLyBWb2ljZU92ZXIgb24gU2FmYXJpIHdvbid0IHJlYWQgaXQgb3V0LlxuLy8gV2UndmUgaW50cm9kdWNlZCB0aGUgYGluZXJ0YCBtb2RlIGFzIGEgd29ya2Fyb3VuZC4gVW5kZXIgdGhpcyBtb2RlLCBhbGwgYTExeSBhdHRyaWJ1dGVzIGFyZVxuLy8gcmVtb3ZlZCBmcm9tIHRoZSBncm91cCwgYW5kIHdlIGdldCB0aGUgc2NyZWVuIHJlYWRlciB0byByZWFkIG91dCB0aGUgZ3JvdXAgbGFiZWwgYnkgbWlycm9yaW5nIGl0XG4vLyBpbnNpZGUgYW4gaW52aXNpYmxlIGVsZW1lbnQgaW4gdGhlIG9wdGlvbi4gVGhpcyBpcyBzdWItb3B0aW1hbCwgYmVjYXVzZSB0aGUgc2NyZWVuIHJlYWRlciB3aWxsXG4vLyByZXBlYXQgdGhlIGdyb3VwIGxhYmVsIG9uIGVhY2ggbmF2aWdhdGlvbiwgd2hlcmVhcyB0aGUgZGVmYXVsdCBwYXR0ZXJuIG9ubHkgcmVhZHMgdGhlIGdyb3VwIHdoZW5cbi8vIHRoZSB1c2VyIGVudGVycyBhIG5ldyBncm91cC4gVGhlIGZvbGxvd2luZyBhbHRlcm5hdGUgYXBwcm9hY2hlcyB3ZXJlIGNvbnNpZGVyZWQ6XG4vLyAxLiBSZWFkaW5nIG91dCB0aGUgZ3JvdXAgbGFiZWwgdXNpbmcgdGhlIGBMaXZlQW5ub3VuY2VyYCBzb2x2ZXMgdGhlIHByb2JsZW0sIGJ1dCB3ZSBjYW4ndCBjb250cm9sXG4vLyAgICB3aGVuIHRoZSB0ZXh0IHdpbGwgYmUgcmVhZCBvdXQgc28gc29tZXRpbWVzIGl0IGNvbWVzIGluIHRvbyBsYXRlIG9yIG5ldmVyIGlmIHRoZSB1c2VyXG4vLyAgICBuYXZpZ2F0ZXMgcXVpY2tseS5cbi8vIDIuIGA8bWF0LW9wdGlvbiBhcmlhLWRlc2NyaWJlZGJ5PVwiZ3JvdXBMYWJlbFwiYCAtIFRoaXMgd29ya3Mgb24gU2FmYXJpLCBidXQgVm9pY2VPdmVyIGluIENocm9tZVxuLy8gICAgd29uJ3QgcmVhZCBvdXQgdGhlIGRlc2NyaXB0aW9uIGF0IGFsbC5cbi8vIDMuIGA8bWF0LW9wdGlvbiBhcmlhLWxhYmVsbGVkYnk9XCJvcHRpb25MYWJlbCBncm91cExhYmVsXCJgIC0gVGhpcyB3b3JrcyBvbiBDaHJvbWUsIGJ1dCBTYWZhcmlcbi8vICAgICBkb2Vzbid0IHJlYWQgb3V0IHRoZSB0ZXh0IGF0IGFsbC4gRnVydGhlcm1vcmUsIG9uXG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIE1hdE9wdGdyb3VwLlxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmNvbnN0IF9NYXRPcHRncm91cE1peGluQmFzZSA9IG1peGluRGlzYWJsZWQoY2xhc3Mge1xufSk7XG4vLyBDb3VudGVyIGZvciB1bmlxdWUgZ3JvdXAgaWRzLlxubGV0IF91bmlxdWVPcHRncm91cElkQ291bnRlciA9IDA7XG5jbGFzcyBfTWF0T3B0Z3JvdXBCYXNlIGV4dGVuZHMgX01hdE9wdGdyb3VwTWl4aW5CYXNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqIFVuaXF1ZSBpZCBmb3IgdGhlIHVuZGVybHlpbmcgbGFiZWwuICovXG4gICAgICAgIHRoaXMuX2xhYmVsSWQgPSBgbWF0LW9wdGdyb3VwLWxhYmVsLSR7X3VuaXF1ZU9wdGdyb3VwSWRDb3VudGVyKyt9YDtcbiAgICAgICAgdGhpcy5faW5lcnQgPSBwYXJlbnQ/LmluZXJ0R3JvdXBzID8/IGZhbHNlO1xuICAgIH1cbn1cbl9NYXRPcHRncm91cEJhc2UuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBfTWF0T3B0Z3JvdXBCYXNlLCBkZXBzOiBbeyB0b2tlbjogTUFUX09QVElPTl9QQVJFTlRfQ09NUE9ORU5ULCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5fTWF0T3B0Z3JvdXBCYXNlLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogX01hdE9wdGdyb3VwQmFzZSwgaW5wdXRzOiB7IGxhYmVsOiBcImxhYmVsXCIgfSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBfTWF0T3B0Z3JvdXBCYXNlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtNQVRfT1BUSU9OX1BBUkVOVF9DT01QT05FTlRdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH1dIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBsYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIGluc3RhbmNlcyBvZiBgTWF0T3B0Z3JvdXBgLiBJdCBzZXJ2ZXMgYXNcbiAqIGFsdGVybmF0aXZlIHRva2VuIHRvIHRoZSBhY3R1YWwgYE1hdE9wdGdyb3VwYCBjbGFzcyB3aGljaCBjb3VsZCBjYXVzZSB1bm5lY2Vzc2FyeVxuICogcmV0ZW50aW9uIG9mIHRoZSBjbGFzcyBhbmQgaXRzIGNvbXBvbmVudCBtZXRhZGF0YS5cbiAqL1xuY29uc3QgTUFUX09QVEdST1VQID0gbmV3IEluamVjdGlvblRva2VuKCdNYXRPcHRncm91cCcpO1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCBpcyB1c2VkIHRvIGdyb3VwIGluc3RhbmNlcyBvZiBgbWF0LW9wdGlvbmAuXG4gKi9cbmNsYXNzIE1hdE9wdGdyb3VwIGV4dGVuZHMgX01hdE9wdGdyb3VwQmFzZSB7XG59XG5NYXRPcHRncm91cC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE9wdGdyb3VwLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdE9wdGdyb3VwLsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0T3B0Z3JvdXAsIHNlbGVjdG9yOiBcIm1hdC1vcHRncm91cFwiLCBpbnB1dHM6IHsgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLnJvbGVcIjogXCJfaW5lcnQgPyBudWxsIDogXFxcImdyb3VwXFxcIlwiLCBcImF0dHIuYXJpYS1kaXNhYmxlZFwiOiBcIl9pbmVydCA/IG51bGwgOiBkaXNhYmxlZC50b1N0cmluZygpXCIsIFwiYXR0ci5hcmlhLWxhYmVsbGVkYnlcIjogXCJfaW5lcnQgPyBudWxsIDogX2xhYmVsSWRcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJtYXQtbWRjLW9wdGdyb3VwXCIgfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBNQVRfT1BUR1JPVVAsIHVzZUV4aXN0aW5nOiBNYXRPcHRncm91cCB9XSwgZXhwb3J0QXM6IFtcIm1hdE9wdGdyb3VwXCJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IFwiPHNwYW5cXG4gIGNsYXNzPVxcXCJtYXQtbWRjLW9wdGdyb3VwLWxhYmVsXFxcIlxcbiAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiXFxuICBbY2xhc3MubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gIFtpZF09XFxcIl9sYWJlbElkXFxcIj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZGMtbGlzdC1pdGVtX19wcmltYXJ5LXRleHRcXFwiPnt7IGxhYmVsIH19IDxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XFxuPC9zcGFuPlxcblxcbjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWF0LW9wdGlvbiwgbmctY29udGFpbmVyXFxcIj48L25nLWNvbnRlbnQ+XFxuXCIsIHN0eWxlczogW1wiLm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWx7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowO3BhZGRpbmctbGVmdDoxNnB4O3BhZGRpbmctcmlnaHQ6MTZweDttaW4taGVpZ2h0OjQ4cHh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWw6Zm9jdXN7b3V0bGluZTpub25lfVtkaXI9cnRsXSAubWF0LW1kYy1vcHRncm91cC1sYWJlbCwubWF0LW1kYy1vcHRncm91cC1sYWJlbFtkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWwubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWR7b3BhY2l0eTouMzh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWwgLm1kYy1saXN0LWl0ZW1fX3ByaW1hcnktdGV4dHt3aGl0ZS1zcGFjZTpub3JtYWx9XCJdLCBjaGFuZ2VEZXRlY3Rpb246IGkwLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgZW5jYXBzdWxhdGlvbjogaTAuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE9wdGdyb3VwLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdtYXQtb3B0Z3JvdXAnLCBleHBvcnRBczogJ21hdE9wdGdyb3VwJywgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSwgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIGlucHV0czogWydkaXNhYmxlZCddLCBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LW1kYy1vcHRncm91cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIucm9sZV0nOiAnX2luZXJ0ID8gbnVsbCA6IFwiZ3JvdXBcIicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnX2luZXJ0ID8gbnVsbCA6IGRpc2FibGVkLnRvU3RyaW5nKCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnX2luZXJ0ID8gbnVsbCA6IF9sYWJlbElkJyxcbiAgICAgICAgICAgICAgICAgICAgfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBNQVRfT1BUR1JPVVAsIHVzZUV4aXN0aW5nOiBNYXRPcHRncm91cCB9XSwgdGVtcGxhdGU6IFwiPHNwYW5cXG4gIGNsYXNzPVxcXCJtYXQtbWRjLW9wdGdyb3VwLWxhYmVsXFxcIlxcbiAgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiXFxuICBbY2xhc3MubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gIFtpZF09XFxcIl9sYWJlbElkXFxcIj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZGMtbGlzdC1pdGVtX19wcmltYXJ5LXRleHRcXFwiPnt7IGxhYmVsIH19IDxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XFxuPC9zcGFuPlxcblxcbjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWF0LW9wdGlvbiwgbmctY29udGFpbmVyXFxcIj48L25nLWNvbnRlbnQ+XFxuXCIsIHN0eWxlczogW1wiLm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWx7ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowO3BhZGRpbmctbGVmdDoxNnB4O3BhZGRpbmctcmlnaHQ6MTZweDttaW4taGVpZ2h0OjQ4cHh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWw6Zm9jdXN7b3V0bGluZTpub25lfVtkaXI9cnRsXSAubWF0LW1kYy1vcHRncm91cC1sYWJlbCwubWF0LW1kYy1vcHRncm91cC1sYWJlbFtkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWwubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWR7b3BhY2l0eTouMzh9Lm1hdC1tZGMtb3B0Z3JvdXAtbGFiZWwgLm1kYy1saXN0LWl0ZW1fX3ByaW1hcnktdGV4dHt3aGl0ZS1zcGFjZTpub3JtYWx9XCJdIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIE9wdGlvbiBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5sZXQgX3VuaXF1ZUlkQ291bnRlciA9IDA7XG4vKiogRXZlbnQgb2JqZWN0IGVtaXR0ZWQgYnkgTWF0T3B0aW9uIHdoZW4gc2VsZWN0ZWQgb3IgZGVzZWxlY3RlZC4gKi9cbmNsYXNzIE1hdE9wdGlvblNlbGVjdGlvbkNoYW5nZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFJlZmVyZW5jZSB0byB0aGUgb3B0aW9uIHRoYXQgZW1pdHRlZCB0aGUgZXZlbnQuICovXG4gICAgc291cmNlLCBcbiAgICAvKiogV2hldGhlciB0aGUgY2hhbmdlIGluIHRoZSBvcHRpb24ncyB2YWx1ZSB3YXMgYSByZXN1bHQgb2YgYSB1c2VyIGFjdGlvbi4gKi9cbiAgICBpc1VzZXJJbnB1dCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmlzVXNlcklucHV0ID0gaXNVc2VySW5wdXQ7XG4gICAgfVxufVxuY2xhc3MgX01hdE9wdGlvbkJhc2Uge1xuICAgIC8qKiBXaGV0aGVyIHRoZSB3cmFwcGluZyBjb21wb25lbnQgaXMgaW4gbXVsdGlwbGUgc2VsZWN0aW9uIG1vZGUuICovXG4gICAgZ2V0IG11bHRpcGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5tdWx0aXBsZTtcbiAgICB9XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBvcHRpb24gaXMgY3VycmVudGx5IHNlbGVjdGVkLiAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGUgb3B0aW9uIGlzIGRpc2FibGVkLiAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdyb3VwICYmIHRoaXMuZ3JvdXAuZGlzYWJsZWQpIHx8IHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKiogV2hldGhlciByaXBwbGVzIGZvciB0aGUgb3B0aW9uIGFyZSBkaXNhYmxlZC4gKi9cbiAgICBnZXQgZGlzYWJsZVJpcHBsZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuZGlzYWJsZVJpcHBsZSk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRvIGRpc3BsYXkgY2hlY2ttYXJrIGZvciBzaW5nbGUtc2VsZWN0aW9uLiAqL1xuICAgIGdldCBoaWRlU2luZ2xlU2VsZWN0aW9uSW5kaWNhdG9yKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5oaWRlU2luZ2xlU2VsZWN0aW9uSW5kaWNhdG9yKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnQsIF9jaGFuZ2VEZXRlY3RvclJlZiwgX3BhcmVudCwgZ3JvdXApIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9zdFJlY2VudFZpZXdWYWx1ZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHVuaXF1ZSBJRCBvZiB0aGUgb3B0aW9uLiAqL1xuICAgICAgICB0aGlzLmlkID0gYG1hdC1vcHRpb24tJHtfdW5pcXVlSWRDb3VudGVyKyt9YDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgb3B0aW9uIGlzIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1vdXRwdXQtb24tcHJlZml4XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgb3B0aW9uIGNoYW5nZXMgYW5kIGFueSBwYXJlbnRzIGhhdmUgdG8gYmUgbm90aWZpZWQuICovXG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBvcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZSBhbmQgcmVhZHkgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICogQW4gYWN0aXZlIG9wdGlvbiBkaXNwbGF5cyBzdHlsZXMgYXMgaWYgaXQgaXMgZm9jdXNlZCwgYnV0IHRoZVxuICAgICAqIGZvY3VzIGlzIGFjdHVhbGx5IHJldGFpbmVkIHNvbWV3aGVyZSBlbHNlLiBUaGlzIGNvbWVzIGluIGhhbmR5XG4gICAgICogZm9yIGNvbXBvbmVudHMgbGlrZSBhdXRvY29tcGxldGUgd2hlcmUgZm9jdXMgbXVzdCByZW1haW4gb24gdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkaXNwbGF5ZWQgdmFsdWUgb2YgdGhlIG9wdGlvbi4gSXQgaXMgbmVjZXNzYXJ5IHRvIHNob3cgdGhlIHNlbGVjdGVkIG9wdGlvbiBpbiB0aGVcbiAgICAgKiBzZWxlY3QncyB0cmlnZ2VyLlxuICAgICAqL1xuICAgIGdldCB2aWV3VmFsdWUoKSB7XG4gICAgICAgIC8vIFRPRE8oa2FyYSk6IEFkZCBpbnB1dCBwcm9wZXJ0eSBhbHRlcm5hdGl2ZSBmb3Igbm9kZSBlbnZzLlxuICAgICAgICByZXR1cm4gKHRoaXMuX3RleHQ/Lm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgfHwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgLyoqIFNlbGVjdHMgdGhlIG9wdGlvbi4gKi9cbiAgICBzZWxlY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIERlc2VsZWN0cyB0aGUgb3B0aW9uLiAqL1xuICAgIGRlc2VsZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZXRzIGZvY3VzIG9udG8gdGhpcyBvcHRpb24uICovXG4gICAgZm9jdXMoX29yaWdpbiwgb3B0aW9ucykge1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgYXJlbid0IHVzaW5nIGBfb3JpZ2luYCwgYnV0IHdlIG5lZWQgdG8ga2VlcCBpdCBiZWNhdXNlIHNvbWUgaW50ZXJuYWwgY29uc3VtZXJzXG4gICAgICAgIC8vIHVzZSBgTWF0T3B0aW9uYCBpbiBhIGBGb2N1c0tleU1hbmFnZXJgIGFuZCB3ZSBuZWVkIGl0IHRvIG1hdGNoIGBGb2N1c2FibGVPcHRpb25gLlxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0SG9zdEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgZGlzcGxheSBzdHlsZXMgb24gdGhlIG9wdGlvbiB0byBtYWtlIGl0IGFwcGVhclxuICAgICAqIGFjdGl2ZS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciBzbyBrZXlcbiAgICAgKiBldmVudHMgd2lsbCBkaXNwbGF5IHRoZSBwcm9wZXIgb3B0aW9ucyBhcyBhY3RpdmUgb24gYXJyb3cga2V5IGV2ZW50cy5cbiAgICAgKi9cbiAgICBzZXRBY3RpdmVTdHlsZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVtb3ZlcyBkaXNwbGF5IHN0eWxlcyBvbiB0aGUgb3B0aW9uIHRoYXQgbWFkZSBpdCBhcHBlYXJcbiAgICAgKiBhY3RpdmUuIFRoaXMgaXMgdXNlZCBieSB0aGUgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgc28ga2V5XG4gICAgICogZXZlbnRzIHdpbGwgZGlzcGxheSB0aGUgcHJvcGVyIG9wdGlvbnMgYXMgYWN0aXZlIG9uIGFycm93IGtleSBldmVudHMuXG4gICAgICovXG4gICAgc2V0SW5hY3RpdmVTdHlsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIGxhYmVsIHRvIGJlIHVzZWQgd2hlbiBkZXRlcm1pbmluZyB3aGV0aGVyIHRoZSBvcHRpb24gc2hvdWxkIGJlIGZvY3VzZWQuICovXG4gICAgZ2V0TGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdWYWx1ZTtcbiAgICB9XG4gICAgLyoqIEVuc3VyZXMgdGhlIG9wdGlvbiBpcyBzZWxlY3RlZCB3aGVuIGFjdGl2YXRlZCBmcm9tIHRoZSBrZXlib2FyZC4gKi9cbiAgICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgICAgICBpZiAoKGV2ZW50LmtleUNvZGUgPT09IEVOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IFNQQUNFKSAmJiAhaGFzTW9kaWZpZXJLZXkoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RWaWFJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZyBkb3duIGFuZCBmb3JtIHN1Ym1pdHMuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBTZWxlY3RzIHRoZSBvcHRpb24gd2hpbGUgaW5kaWNhdGluZyB0aGUgc2VsZWN0aW9uIGNhbWUgZnJvbSB0aGUgdXNlci4gVXNlZCB0b1xuICAgICAqIGRldGVybWluZSBpZiB0aGUgc2VsZWN0J3MgdmlldyAtPiBtb2RlbCBjYWxsYmFjayBzaG91bGQgYmUgaW52b2tlZC5gXG4gICAgICovXG4gICAgX3NlbGVjdFZpYUludGVyYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gdGhpcy5tdWx0aXBsZSA/ICF0aGlzLl9zZWxlY3RlZCA6IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRTZWxlY3Rpb25DaGFuZ2VFdmVudCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgY29ycmVjdCB0YWJpbmRleCBmb3IgdGhlIG9wdGlvbiBkZXBlbmRpbmcgb24gZGlzYWJsZWQgc3RhdGUuICovXG4gICAgX2dldFRhYkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICctMScgOiAnMCc7XG4gICAgfVxuICAgIC8qKiBHZXRzIHRoZSBob3N0IERPTSBlbGVtZW50LiAqL1xuICAgIF9nZXRIb3N0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICAvLyBTaW5jZSBwYXJlbnQgY29tcG9uZW50cyBjb3VsZCBiZSB1c2luZyB0aGUgb3B0aW9uJ3MgbGFiZWwgdG8gZGlzcGxheSB0aGUgc2VsZWN0ZWQgdmFsdWVzXG4gICAgICAgIC8vIChlLmcuIGBtYXQtc2VsZWN0YCkgYW5kIHRoZXkgZG9uJ3QgaGF2ZSBhIHdheSBvZiBrbm93aW5nIGlmIHRoZSBvcHRpb24ncyBsYWJlbCBoYXMgY2hhbmdlZFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIGNoZWNrIGZvciBjaGFuZ2VzIGluIHRoZSBET00gb3Vyc2VsdmVzIGFuZCBkaXNwYXRjaCBhbiBldmVudC4gVGhlc2UgY2hlY2tzIGFyZVxuICAgICAgICAvLyByZWxhdGl2ZWx5IGNoZWFwLCBob3dldmVyIHdlIHN0aWxsIGxpbWl0IHRoZW0gb25seSB0byBzZWxlY3RlZCBvcHRpb25zIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgIC8vIGhpdHRpbmcgdGhlIERPTSB0b28gb2Z0ZW4uXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgY29uc3Qgdmlld1ZhbHVlID0gdGhpcy52aWV3VmFsdWU7XG4gICAgICAgICAgICBpZiAodmlld1ZhbHVlICE9PSB0aGlzLl9tb3N0UmVjZW50Vmlld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX21vc3RSZWNlbnRWaWV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9zdFJlY2VudFZpZXdWYWx1ZSA9IHZpZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VzLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKiBFbWl0cyB0aGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudC4gKi9cbiAgICBfZW1pdFNlbGVjdGlvbkNoYW5nZUV2ZW50KGlzVXNlcklucHV0ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbkNoYW5nZS5lbWl0KG5ldyBNYXRPcHRpb25TZWxlY3Rpb25DaGFuZ2UodGhpcywgaXNVc2VySW5wdXQpKTtcbiAgICB9XG59XG5fTWF0T3B0aW9uQmFzZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IF9NYXRPcHRpb25CYXNlLCBkZXBzOiBcImludmFsaWRcIiwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5fTWF0T3B0aW9uQmFzZS7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IF9NYXRPcHRpb25CYXNlLCBpbnB1dHM6IHsgdmFsdWU6IFwidmFsdWVcIiwgaWQ6IFwiaWRcIiwgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIiB9LCBvdXRwdXRzOiB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBcIm9uU2VsZWN0aW9uQ2hhbmdlXCIgfSwgdmlld1F1ZXJpZXM6IFt7IHByb3BlcnR5TmFtZTogXCJfdGV4dFwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBbXCJ0ZXh0XCJdLCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH1dLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBfTWF0T3B0aW9uQmFzZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMC5DaGFuZ2VEZXRlY3RvclJlZiB9LCB7IHR5cGU6IHVuZGVmaW5lZCB9LCB7IHR5cGU6IF9NYXRPcHRncm91cEJhc2UgfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IHZhbHVlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgaWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBkaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIG9uU2VsZWN0aW9uQ2hhbmdlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIF90ZXh0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFZpZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ3RleHQnLCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogU2luZ2xlIG9wdGlvbiBpbnNpZGUgb2YgYSBgPG1hdC1zZWxlY3Q+YCBlbGVtZW50LlxuICovXG5jbGFzcyBNYXRPcHRpb24gZXh0ZW5kcyBfTWF0T3B0aW9uQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY2hhbmdlRGV0ZWN0b3JSZWYsIHBhcmVudCwgZ3JvdXApIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudCwgY2hhbmdlRGV0ZWN0b3JSZWYsIHBhcmVudCwgZ3JvdXApO1xuICAgIH1cbn1cbk1hdE9wdGlvbi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE9wdGlvbiwgZGVwczogW3sgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogaTAuQ2hhbmdlRGV0ZWN0b3JSZWYgfSwgeyB0b2tlbjogTUFUX09QVElPTl9QQVJFTlRfQ09NUE9ORU5ULCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBNQVRfT1BUR1JPVVAsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdE9wdGlvbi7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdE9wdGlvbiwgc2VsZWN0b3I6IFwibWF0LW9wdGlvblwiLCBob3N0OiB7IGF0dHJpYnV0ZXM6IHsgXCJyb2xlXCI6IFwib3B0aW9uXCIgfSwgbGlzdGVuZXJzOiB7IFwiY2xpY2tcIjogXCJfc2VsZWN0VmlhSW50ZXJhY3Rpb24oKVwiLCBcImtleWRvd25cIjogXCJfaGFuZGxlS2V5ZG93bigkZXZlbnQpXCIgfSwgcHJvcGVydGllczogeyBcImF0dHIudGFiaW5kZXhcIjogXCJfZ2V0VGFiSW5kZXgoKVwiLCBcImNsYXNzLm1kYy1saXN0LWl0ZW0tLXNlbGVjdGVkXCI6IFwic2VsZWN0ZWRcIiwgXCJjbGFzcy5tYXQtbWRjLW9wdGlvbi1tdWx0aXBsZVwiOiBcIm11bHRpcGxlXCIsIFwiY2xhc3MubWF0LW1kYy1vcHRpb24tYWN0aXZlXCI6IFwiYWN0aXZlXCIsIFwiY2xhc3MubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWRcIjogXCJkaXNhYmxlZFwiLCBcImlkXCI6IFwiaWRcIiwgXCJhdHRyLmFyaWEtc2VsZWN0ZWRcIjogXCJzZWxlY3RlZFwiLCBcImF0dHIuYXJpYS1kaXNhYmxlZFwiOiBcImRpc2FibGVkLnRvU3RyaW5nKClcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJtYXQtbWRjLW9wdGlvbiBtZGMtbGlzdC1pdGVtXCIgfSwgZXhwb3J0QXM6IFtcIm1hdE9wdGlvblwiXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBcIjxtYXQtcHNldWRvLWNoZWNrYm94ICpuZ0lmPVxcXCJtdWx0aXBsZVxcXCIgY2xhc3M9XFxcIm1hdC1tZGMtb3B0aW9uLXBzZXVkby1jaGVja2JveFxcXCJcXG4gICAgW3N0YXRlXT1cXFwic2VsZWN0ZWQgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJ1xcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiPjwvbWF0LXBzZXVkby1jaGVja2JveD5cXG5cXG48bmctY29udGVudCBzZWxlY3Q9XFxcIm1hdC1pY29uXFxcIj48L25nLWNvbnRlbnQ+XFxuXFxuPHNwYW4gY2xhc3M9XFxcIm1kYy1saXN0LWl0ZW1fX3ByaW1hcnktdGV4dFxcXCIgI3RleHQ+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cXG5cXG48IS0tIFJlbmRlciBjaGVja21hcmsgYXQgdGhlIGVuZCBmb3Igc2luZ2xlLXNlbGVjdGlvbi4gLS0+XFxuPG1hdC1wc2V1ZG8tY2hlY2tib3ggKm5nSWY9XFxcIiFtdWx0aXBsZSAmJiBzZWxlY3RlZCAmJiAhaGlkZVNpbmdsZVNlbGVjdGlvbkluZGljYXRvclxcXCJcXG4gICAgY2xhc3M9XFxcIm1hdC1tZGMtb3B0aW9uLXBzZXVkby1jaGVja2JveFxcXCIgc3RhdGU9XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICBhcHBlYXJhbmNlPVxcXCJtaW5pbWFsXFxcIj48L21hdC1wc2V1ZG8tY2hlY2tib3g+XFxuXFxuPCEtLSBTZWUgYTExeSBub3RlcyBpbnNpZGUgb3B0Z3JvdXAudHMgZm9yIGNvbnRleHQgYmVoaW5kIHRoaXMgZWxlbWVudC4gLS0+XFxuPHNwYW4gY2xhc3M9XFxcImNkay12aXN1YWxseS1oaWRkZW5cXFwiICpuZ0lmPVxcXCJncm91cCAmJiBncm91cC5faW5lcnRcXFwiPih7eyBncm91cC5sYWJlbCB9fSk8L3NwYW4+XFxuXFxuPGRpdiBjbGFzcz1cXFwibWF0LW1kYy1vcHRpb24tcmlwcGxlIG1hdC1tZGMtZm9jdXMtaW5kaWNhdG9yXFxcIiBtYXQtcmlwcGxlXFxuICAgICBbbWF0UmlwcGxlVHJpZ2dlcl09XFxcIl9nZXRIb3N0RWxlbWVudCgpXFxcIlxcbiAgICAgW21hdFJpcHBsZURpc2FibGVkXT1cXFwiZGlzYWJsZWQgfHwgZGlzYWJsZVJpcHBsZVxcXCI+XFxuPC9kaXY+XFxuXCIsIHN0eWxlczogW1wiLm1hdC1tZGMtb3B0aW9ue2Rpc3BsYXk6ZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6MDtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y3Vyc29yOnBvaW50ZXI7LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnJnYmEoMCwwLDAsMCk7bWluLWhlaWdodDo0OHB4fS5tYXQtbWRjLW9wdGlvbjpmb2N1c3tvdXRsaW5lOm5vbmV9W2Rpcj1ydGxdIC5tYXQtbWRjLW9wdGlvbiwubWF0LW1kYy1vcHRpb25bZGlyPXJ0bF17cGFkZGluZy1sZWZ0OjE2cHg7cGFkZGluZy1yaWdodDoxNnB4fS5tYXQtbWRjLW9wdGlvbi5tZGMtbGlzdC1pdGVte2FsaWduLWl0ZW1zOmNlbnRlcn0ubWF0LW1kYy1vcHRpb24ubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWR7b3BhY2l0eTouMzg7Y3Vyc29yOmRlZmF1bHR9Lm1hdC1tZGMtb3B0Z3JvdXAgLm1hdC1tZGMtb3B0aW9uOm5vdCgubWF0LW1kYy1vcHRpb24tbXVsdGlwbGUpe3BhZGRpbmctbGVmdDozMnB4fVtkaXI9cnRsXSAubWF0LW1kYy1vcHRncm91cCAubWF0LW1kYy1vcHRpb246bm90KC5tYXQtbWRjLW9wdGlvbi1tdWx0aXBsZSl7cGFkZGluZy1sZWZ0OjE2cHg7cGFkZGluZy1yaWdodDozMnB4fS5tYXQtbWRjLW9wdGlvbiAubWF0LWljb24sLm1hdC1tZGMtb3B0aW9uIC5tYXQtcHNldWRvLWNoZWNrYm94LWZ1bGx7bWFyZ2luLXJpZ2h0OjE2cHg7ZmxleC1zaHJpbms6MH1bZGlyPXJ0bF0gLm1hdC1tZGMtb3B0aW9uIC5tYXQtaWNvbixbZGlyPXJ0bF0gLm1hdC1tZGMtb3B0aW9uIC5tYXQtcHNldWRvLWNoZWNrYm94LWZ1bGx7bWFyZ2luLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MTZweH0ubWF0LW1kYy1vcHRpb24gLm1hdC1wc2V1ZG8tY2hlY2tib3gtbWluaW1hbHttYXJnaW4tbGVmdDoxNnB4O2ZsZXgtc2hyaW5rOjB9W2Rpcj1ydGxdIC5tYXQtbWRjLW9wdGlvbiAubWF0LXBzZXVkby1jaGVja2JveC1taW5pbWFse21hcmdpbi1yaWdodDoxNnB4O21hcmdpbi1sZWZ0OjB9Lm1hdC1tZGMtb3B0aW9uIC5tYXQtbWRjLW9wdGlvbi1yaXBwbGV7dG9wOjA7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZX0ubWF0LW1kYy1vcHRpb24gLm1kYy1saXN0LWl0ZW1fX3ByaW1hcnktdGV4dHt3aGl0ZS1zcGFjZTpub3JtYWw7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O2xpbmUtaGVpZ2h0OmluaGVyaXQ7Zm9udC1mYW1pbHk6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LXRyYW5zZm9ybTppbmhlcml0O21hcmdpbi1yaWdodDphdXRvfVtkaXI9cnRsXSAubWF0LW1kYy1vcHRpb24gLm1kYy1saXN0LWl0ZW1fX3ByaW1hcnktdGV4dHttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDphdXRvfS5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC1tZGMtb3B0aW9uLm1kYy1saXN0LWl0ZW0tLXNlbGVjdGVkOm5vdCgubWF0LW1kYy1vcHRpb24tbXVsdGlwbGUpOjphZnRlcntjb250ZW50OlxcXCJcXFwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7cmlnaHQ6MTZweDt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt3aWR0aDoxMHB4O2hlaWdodDowO2JvcmRlci1ib3R0b206c29saWQgMTBweDtib3JkZXItcmFkaXVzOjEwcHh9W2Rpcj1ydGxdIC5jZGstaGlnaC1jb250cmFzdC1hY3RpdmUgLm1hdC1tZGMtb3B0aW9uLm1kYy1saXN0LWl0ZW0tLXNlbGVjdGVkOm5vdCgubWF0LW1kYy1vcHRpb24tbXVsdGlwbGUpOjphZnRlcntyaWdodDphdXRvO2xlZnQ6MTZweH0ubWF0LW1kYy1vcHRpb24tYWN0aXZlIC5tYXQtbWRjLWZvY3VzLWluZGljYXRvcjo6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXCJ9XCJdLCBkZXBlbmRlbmNpZXM6IFt7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IE1hdFJpcHBsZSwgc2VsZWN0b3I6IFwiW21hdC1yaXBwbGVdLCBbbWF0UmlwcGxlXVwiLCBpbnB1dHM6IFtcIm1hdFJpcHBsZUNvbG9yXCIsIFwibWF0UmlwcGxlVW5ib3VuZGVkXCIsIFwibWF0UmlwcGxlQ2VudGVyZWRcIiwgXCJtYXRSaXBwbGVSYWRpdXNcIiwgXCJtYXRSaXBwbGVBbmltYXRpb25cIiwgXCJtYXRSaXBwbGVEaXNhYmxlZFwiLCBcIm1hdFJpcHBsZVRyaWdnZXJcIl0sIGV4cG9ydEFzOiBbXCJtYXRSaXBwbGVcIl0gfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBpMy5OZ0lmLCBzZWxlY3RvcjogXCJbbmdJZl1cIiwgaW5wdXRzOiBbXCJuZ0lmXCIsIFwibmdJZlRoZW5cIiwgXCJuZ0lmRWxzZVwiXSB9LCB7IGtpbmQ6IFwiY29tcG9uZW50XCIsIHR5cGU6IE1hdFBzZXVkb0NoZWNrYm94LCBzZWxlY3RvcjogXCJtYXQtcHNldWRvLWNoZWNrYm94XCIsIGlucHV0czogW1wic3RhdGVcIiwgXCJkaXNhYmxlZFwiLCBcImFwcGVhcmFuY2VcIl0gfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0T3B0aW9uLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdtYXQtb3B0aW9uJywgZXhwb3J0QXM6ICdtYXRPcHRpb24nLCBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfZ2V0VGFiSW5kZXgoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1kYy1saXN0LWl0ZW0tLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1tZGMtb3B0aW9uLW11bHRpcGxlXSc6ICdtdWx0aXBsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2NsYXNzLm1hdC1tZGMtb3B0aW9uLWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MubWRjLWxpc3QtaXRlbS0tZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbaWRdJzogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCBhcmlhLXNlbGVjdGVkIHRvIGZhbHNlIGZvciBub24tc2VsZWN0ZWQgaXRlbXMgYW5kIHRydWUgZm9yIHNlbGVjdGVkIGl0ZW1zLiBDb25mb3JtIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBbV0FJIEFSSUEgTGlzdGJveCBhdXRob3JpbmcgcHJhY3RpY2VzIGd1aWRlXShcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvKSwgXCJJZiBhbnkgb3B0aW9ucyBhcmUgc2VsZWN0ZWQsIGVhY2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGVkIG9wdGlvbiBoYXMgZWl0aGVyIGFyaWEtc2VsZWN0ZWQgb3IgYXJpYS1jaGVja2VkICBzZXQgdG8gdHJ1ZS4gQWxsIG9wdGlvbnMgdGhhdCBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdGFibGUgYnV0IG5vdCBzZWxlY3RlZCBoYXZlIGVpdGhlciBhcmlhLXNlbGVjdGVkIG9yIGFyaWEtY2hlY2tlZCBzZXQgdG8gZmFsc2UuXCIgQWxpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyaWEtc2VsZWN0ZWQgaW1wbGVtZW50YXRpb24gb2YgQ2hpcHMgYW5kIExpc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgYGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiYCBvbiBub3Qtc2VsZWN0ZWQgbGlzdGJveCBvcHRpb25zIHRvIGZpeCBWb2ljZU92ZXIgYW5ub3VuY2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgb3B0aW9uIGFzIFwic2VsZWN0ZWRcIiAoIzIxNDkxKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQudG9TdHJpbmcoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfc2VsZWN0VmlhSW50ZXJhY3Rpb24oKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1tZGMtb3B0aW9uIG1kYy1saXN0LWl0ZW0nLFxuICAgICAgICAgICAgICAgICAgICB9LCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgdGVtcGxhdGU6IFwiPG1hdC1wc2V1ZG8tY2hlY2tib3ggKm5nSWY9XFxcIm11bHRpcGxlXFxcIiBjbGFzcz1cXFwibWF0LW1kYy1vcHRpb24tcHNldWRvLWNoZWNrYm94XFxcIlxcbiAgICBbc3RhdGVdPVxcXCJzZWxlY3RlZCA/ICdjaGVja2VkJyA6ICd1bmNoZWNrZWQnXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCI+PC9tYXQtcHNldWRvLWNoZWNrYm94PlxcblxcbjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWF0LWljb25cXFwiPjwvbmctY29udGVudD5cXG5cXG48c3BhbiBjbGFzcz1cXFwibWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0XFxcIiAjdGV4dD48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPlxcblxcbjwhLS0gUmVuZGVyIGNoZWNrbWFyayBhdCB0aGUgZW5kIGZvciBzaW5nbGUtc2VsZWN0aW9uLiAtLT5cXG48bWF0LXBzZXVkby1jaGVja2JveCAqbmdJZj1cXFwiIW11bHRpcGxlICYmIHNlbGVjdGVkICYmICFoaWRlU2luZ2xlU2VsZWN0aW9uSW5kaWNhdG9yXFxcIlxcbiAgICBjbGFzcz1cXFwibWF0LW1kYy1vcHRpb24tcHNldWRvLWNoZWNrYm94XFxcIiBzdGF0ZT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgIGFwcGVhcmFuY2U9XFxcIm1pbmltYWxcXFwiPjwvbWF0LXBzZXVkby1jaGVja2JveD5cXG5cXG48IS0tIFNlZSBhMTF5IG5vdGVzIGluc2lkZSBvcHRncm91cC50cyBmb3IgY29udGV4dCBiZWhpbmQgdGhpcyBlbGVtZW50LiAtLT5cXG48c3BhbiBjbGFzcz1cXFwiY2RrLXZpc3VhbGx5LWhpZGRlblxcXCIgKm5nSWY9XFxcImdyb3VwICYmIGdyb3VwLl9pbmVydFxcXCI+KHt7IGdyb3VwLmxhYmVsIH19KTwvc3Bhbj5cXG5cXG48ZGl2IGNsYXNzPVxcXCJtYXQtbWRjLW9wdGlvbi1yaXBwbGUgbWF0LW1kYy1mb2N1cy1pbmRpY2F0b3JcXFwiIG1hdC1yaXBwbGVcXG4gICAgIFttYXRSaXBwbGVUcmlnZ2VyXT1cXFwiX2dldEhvc3RFbGVtZW50KClcXFwiXFxuICAgICBbbWF0UmlwcGxlRGlzYWJsZWRdPVxcXCJkaXNhYmxlZCB8fCBkaXNhYmxlUmlwcGxlXFxcIj5cXG48L2Rpdj5cXG5cIiwgc3R5bGVzOiBbXCIubWF0LW1kYy1vcHRpb257ZGlzcGxheTpmbGV4O3Bvc2l0aW9uOnJlbGF0aXZlO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtvdmVyZmxvdzpoaWRkZW47cGFkZGluZzowO3BhZGRpbmctbGVmdDoxNnB4O3BhZGRpbmctcmlnaHQ6MTZweDstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6cG9pbnRlcjstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKTttaW4taGVpZ2h0OjQ4cHh9Lm1hdC1tZGMtb3B0aW9uOmZvY3Vze291dGxpbmU6bm9uZX1bZGlyPXJ0bF0gLm1hdC1tZGMtb3B0aW9uLC5tYXQtbWRjLW9wdGlvbltkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjE2cHh9Lm1hdC1tZGMtb3B0aW9uLm1kYy1saXN0LWl0ZW17YWxpZ24taXRlbXM6Y2VudGVyfS5tYXQtbWRjLW9wdGlvbi5tZGMtbGlzdC1pdGVtLS1kaXNhYmxlZHtvcGFjaXR5Oi4zODtjdXJzb3I6ZGVmYXVsdH0ubWF0LW1kYy1vcHRncm91cCAubWF0LW1kYy1vcHRpb246bm90KC5tYXQtbWRjLW9wdGlvbi1tdWx0aXBsZSl7cGFkZGluZy1sZWZ0OjMycHh9W2Rpcj1ydGxdIC5tYXQtbWRjLW9wdGdyb3VwIC5tYXQtbWRjLW9wdGlvbjpub3QoLm1hdC1tZGMtb3B0aW9uLW11bHRpcGxlKXtwYWRkaW5nLWxlZnQ6MTZweDtwYWRkaW5nLXJpZ2h0OjMycHh9Lm1hdC1tZGMtb3B0aW9uIC5tYXQtaWNvbiwubWF0LW1kYy1vcHRpb24gLm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbHttYXJnaW4tcmlnaHQ6MTZweDtmbGV4LXNocmluazowfVtkaXI9cnRsXSAubWF0LW1kYy1vcHRpb24gLm1hdC1pY29uLFtkaXI9cnRsXSAubWF0LW1kYy1vcHRpb24gLm1hdC1wc2V1ZG8tY2hlY2tib3gtZnVsbHttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDoxNnB4fS5tYXQtbWRjLW9wdGlvbiAubWF0LXBzZXVkby1jaGVja2JveC1taW5pbWFse21hcmdpbi1sZWZ0OjE2cHg7ZmxleC1zaHJpbms6MH1bZGlyPXJ0bF0gLm1hdC1tZGMtb3B0aW9uIC5tYXQtcHNldWRvLWNoZWNrYm94LW1pbmltYWx7bWFyZ2luLXJpZ2h0OjE2cHg7bWFyZ2luLWxlZnQ6MH0ubWF0LW1kYy1vcHRpb24gLm1hdC1tZGMtb3B0aW9uLXJpcHBsZXt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lfS5tYXQtbWRjLW9wdGlvbiAubWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0e3doaXRlLXNwYWNlOm5vcm1hbDtmb250LXNpemU6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O3RleHQtZGVjb3JhdGlvbjppbmhlcml0O3RleHQtdHJhbnNmb3JtOmluaGVyaXQ7bWFyZ2luLXJpZ2h0OmF1dG99W2Rpcj1ydGxdIC5tYXQtbWRjLW9wdGlvbiAubWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0e21hcmdpbi1yaWdodDowO21hcmdpbi1sZWZ0OmF1dG99LmNkay1oaWdoLWNvbnRyYXN0LWFjdGl2ZSAubWF0LW1kYy1vcHRpb24ubWRjLWxpc3QtaXRlbS0tc2VsZWN0ZWQ6bm90KC5tYXQtbWRjLW9wdGlvbi1tdWx0aXBsZSk6OmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtyaWdodDoxNnB4O3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3dpZHRoOjEwcHg7aGVpZ2h0OjA7Ym9yZGVyLWJvdHRvbTpzb2xpZCAxMHB4O2JvcmRlci1yYWRpdXM6MTBweH1bZGlyPXJ0bF0gLmNkay1oaWdoLWNvbnRyYXN0LWFjdGl2ZSAubWF0LW1kYy1vcHRpb24ubWRjLWxpc3QtaXRlbS0tc2VsZWN0ZWQ6bm90KC5tYXQtbWRjLW9wdGlvbi1tdWx0aXBsZSk6OmFmdGVye3JpZ2h0OmF1dG87bGVmdDoxNnB4fS5tYXQtbWRjLW9wdGlvbi1hY3RpdmUgLm1hdC1tZGMtZm9jdXMtaW5kaWNhdG9yOjpiZWZvcmV7Y29udGVudDpcXFwiXFxcIn1cIl0gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5FbGVtZW50UmVmIH0sIHsgdHlwZTogaTAuQ2hhbmdlRGV0ZWN0b3JSZWYgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtNQVRfT1BUSU9OX1BBUkVOVF9DT01QT05FTlRdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBNYXRPcHRncm91cCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW01BVF9PUFRHUk9VUF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcbi8qKlxuICogQ291bnRzIHRoZSBhbW91bnQgb2Ygb3B0aW9uIGdyb3VwIGxhYmVscyB0aGF0IHByZWNlZGUgdGhlIHNwZWNpZmllZCBvcHRpb24uXG4gKiBAcGFyYW0gb3B0aW9uSW5kZXggSW5kZXggb2YgdGhlIG9wdGlvbiBhdCB3aGljaCB0byBzdGFydCBjb3VudGluZy5cbiAqIEBwYXJhbSBvcHRpb25zIEZsYXQgbGlzdCBvZiBhbGwgb2YgdGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9uR3JvdXBzIEZsYXQgbGlzdCBvZiBhbGwgb2YgdGhlIG9wdGlvbiBncm91cHMuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9jb3VudEdyb3VwTGFiZWxzQmVmb3JlT3B0aW9uKG9wdGlvbkluZGV4LCBvcHRpb25zLCBvcHRpb25Hcm91cHMpIHtcbiAgICBpZiAob3B0aW9uR3JvdXBzLmxlbmd0aCkge1xuICAgICAgICBsZXQgb3B0aW9uc0FycmF5ID0gb3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgIGxldCBncm91cHMgPSBvcHRpb25Hcm91cHMudG9BcnJheSgpO1xuICAgICAgICBsZXQgZ3JvdXBDb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHRpb25JbmRleCArIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNBcnJheVtpXS5ncm91cCAmJiBvcHRpb25zQXJyYXlbaV0uZ3JvdXAgPT09IGdyb3Vwc1tncm91cENvdW50ZXJdKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBDb3VudGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwQ291bnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHBvc2l0aW9uIHRvIHdoaWNoIHRvIHNjcm9sbCBhIHBhbmVsIGluIG9yZGVyIGZvciBhbiBvcHRpb24gdG8gYmUgaW50byB2aWV3LlxuICogQHBhcmFtIG9wdGlvbk9mZnNldCBPZmZzZXQgb2YgdGhlIG9wdGlvbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHBhbmVsLlxuICogQHBhcmFtIG9wdGlvbkhlaWdodCBIZWlnaHQgb2YgdGhlIG9wdGlvbnMuXG4gKiBAcGFyYW0gY3VycmVudFNjcm9sbFBvc2l0aW9uIEN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBwYW5lbC5cbiAqIEBwYXJhbSBwYW5lbEhlaWdodCBIZWlnaHQgb2YgdGhlIHBhbmVsLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0T3B0aW9uU2Nyb2xsUG9zaXRpb24ob3B0aW9uT2Zmc2V0LCBvcHRpb25IZWlnaHQsIGN1cnJlbnRTY3JvbGxQb3NpdGlvbiwgcGFuZWxIZWlnaHQpIHtcbiAgICBpZiAob3B0aW9uT2Zmc2V0IDwgY3VycmVudFNjcm9sbFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25PZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25PZmZzZXQgKyBvcHRpb25IZWlnaHQgPiBjdXJyZW50U2Nyb2xsUG9zaXRpb24gKyBwYW5lbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgb3B0aW9uT2Zmc2V0IC0gcGFuZWxIZWlnaHQgKyBvcHRpb25IZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFNjcm9sbFBvc2l0aW9uO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIE1hdE9wdGlvbk1vZHVsZSB7XG59XG5NYXRPcHRpb25Nb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRPcHRpb25Nb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pO1xuTWF0T3B0aW9uTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE9wdGlvbk1vZHVsZSwgZGVjbGFyYXRpb25zOiBbTWF0T3B0aW9uLCBNYXRPcHRncm91cF0sIGltcG9ydHM6IFtNYXRSaXBwbGVNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWF0Q29tbW9uTW9kdWxlLCBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZV0sIGV4cG9ydHM6IFtNYXRPcHRpb24sIE1hdE9wdGdyb3VwXSB9KTtcbk1hdE9wdGlvbk1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRPcHRpb25Nb2R1bGUsIGltcG9ydHM6IFtNYXRSaXBwbGVNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWF0Q29tbW9uTW9kdWxlLCBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRPcHRpb25Nb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNYXRSaXBwbGVNb2R1bGUsIENvbW1vbk1vZHVsZSwgTWF0Q29tbW9uTW9kdWxlLCBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtNYXRPcHRpb24sIE1hdE9wdGdyb3VwXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWF0T3B0aW9uLCBNYXRPcHRncm91cF0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBbmltYXRpb25DdXJ2ZXMsIEFuaW1hdGlvbkR1cmF0aW9ucywgRGF0ZUFkYXB0ZXIsIEVycm9yU3RhdGVNYXRjaGVyLCBNQVRFUklBTF9TQU5JVFlfQ0hFQ0tTLCBNQVRfREFURV9GT1JNQVRTLCBNQVRfREFURV9MT0NBTEUsIE1BVF9EQVRFX0xPQ0FMRV9GQUNUT1JZLCBNQVRfTkFUSVZFX0RBVEVfRk9STUFUUywgTUFUX09QVEdST1VQLCBNQVRfT1BUSU9OX1BBUkVOVF9DT01QT05FTlQsIE1BVF9SSVBQTEVfR0xPQkFMX09QVElPTlMsIE1hdENvbW1vbk1vZHVsZSwgTWF0TGluZSwgTWF0TGluZU1vZHVsZSwgTWF0TmF0aXZlRGF0ZU1vZHVsZSwgTWF0T3B0Z3JvdXAsIE1hdE9wdGlvbiwgTWF0T3B0aW9uTW9kdWxlLCBNYXRPcHRpb25TZWxlY3Rpb25DaGFuZ2UsIE1hdFBzZXVkb0NoZWNrYm94LCBNYXRQc2V1ZG9DaGVja2JveE1vZHVsZSwgTWF0UmlwcGxlLCBNYXRSaXBwbGVNb2R1bGUsIE5hdGl2ZURhdGVBZGFwdGVyLCBOYXRpdmVEYXRlTW9kdWxlLCBSaXBwbGVSZWYsIFJpcHBsZVJlbmRlcmVyLCBTaG93T25EaXJ0eUVycm9yU3RhdGVNYXRjaGVyLCBWRVJTSU9OLCBfTWF0T3B0Z3JvdXBCYXNlLCBfTWF0T3B0aW9uQmFzZSwgX2NvdW50R3JvdXBMYWJlbHNCZWZvcmVPcHRpb24sIF9nZXRPcHRpb25TY3JvbGxQb3NpdGlvbiwgZGVmYXVsdFJpcHBsZUFuaW1hdGlvbkNvbmZpZywgbWl4aW5Db2xvciwgbWl4aW5EaXNhYmxlUmlwcGxlLCBtaXhpbkRpc2FibGVkLCBtaXhpbkVycm9yU3RhdGUsIG1peGluSW5pdGlhbGl6ZWQsIG1peGluVGFiSW5kZXgsIHNldExpbmVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/material/fesm2020/core.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/material/fesm2020/table.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@angular/material/fesm2020/table.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MatCell\": function() { return /* binding */ MatCell; },\n/* harmony export */   \"MatCellDef\": function() { return /* binding */ MatCellDef; },\n/* harmony export */   \"MatColumnDef\": function() { return /* binding */ MatColumnDef; },\n/* harmony export */   \"MatFooterCell\": function() { return /* binding */ MatFooterCell; },\n/* harmony export */   \"MatFooterCellDef\": function() { return /* binding */ MatFooterCellDef; },\n/* harmony export */   \"MatFooterRow\": function() { return /* binding */ MatFooterRow; },\n/* harmony export */   \"MatFooterRowDef\": function() { return /* binding */ MatFooterRowDef; },\n/* harmony export */   \"MatHeaderCell\": function() { return /* binding */ MatHeaderCell; },\n/* harmony export */   \"MatHeaderCellDef\": function() { return /* binding */ MatHeaderCellDef; },\n/* harmony export */   \"MatHeaderRow\": function() { return /* binding */ MatHeaderRow; },\n/* harmony export */   \"MatHeaderRowDef\": function() { return /* binding */ MatHeaderRowDef; },\n/* harmony export */   \"MatNoDataRow\": function() { return /* binding */ MatNoDataRow; },\n/* harmony export */   \"MatRecycleRows\": function() { return /* binding */ MatRecycleRows; },\n/* harmony export */   \"MatRow\": function() { return /* binding */ MatRow; },\n/* harmony export */   \"MatRowDef\": function() { return /* binding */ MatRowDef; },\n/* harmony export */   \"MatTable\": function() { return /* binding */ MatTable; },\n/* harmony export */   \"MatTableDataSource\": function() { return /* binding */ MatTableDataSource; },\n/* harmony export */   \"MatTableModule\": function() { return /* binding */ MatTableModule; },\n/* harmony export */   \"MatTextColumn\": function() { return /* binding */ MatTextColumn; },\n/* harmony export */   \"_MatTableDataSource\": function() { return /* binding */ _MatTableDataSource; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/table */ \"./node_modules/@angular/cdk/fesm2020/table.mjs\");\n/* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/collections */ \"./node_modules/@angular/cdk/fesm2020/collections.mjs\");\n/* harmony import */ var _angular_material_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/material/core */ \"./node_modules/@angular/material/fesm2020/core.mjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Enables the recycle view repeater strategy, which reduces rendering latency. Not compatible with\n * tables that animate rows.\n */\nclass MatRecycleRows {\n}\nMatRecycleRows.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRecycleRows, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatRecycleRows.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatRecycleRows, selector: \"mat-table[recycleRows], table[mat-table][recycleRows]\", providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._RecycleViewRepeaterStrategy }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRecycleRows, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'mat-table[recycleRows], table[mat-table][recycleRows]',\n                    providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._RecycleViewRepeaterStrategy }],\n                }]\n        }] });\nclass MatTable extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTable {\n    constructor() {\n        super(...arguments);\n        /** Overrides the sticky CSS class set by the `CdkTable`. */\n        this.stickyCssClass = 'mat-mdc-table-sticky';\n        /** Overrides the need to add position: sticky on every sticky cell element in `CdkTable`. */\n        this.needsPositionStickyOnElement = false;\n    }\n    ngOnInit() {\n        super.ngOnInit();\n        // After ngOnInit, the `CdkTable` has created and inserted the table sections (thead, tbody,\n        // tfoot). MDC requires the `mdc-data-table__content` class to be added to the body. Note that\n        // this only applies to native tables, because we don't wrap the content of flexbox-based ones.\n        if (this._isNativeHtmlTable) {\n            const tbody = this._elementRef.nativeElement.querySelector('tbody');\n            tbody.classList.add('mdc-data-table__content');\n        }\n    }\n}\nMatTable.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTable, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatTable.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatTable, selector: \"mat-table, table[mat-table]\", host: { properties: { \"class.mdc-table-fixed-layout\": \"fixedLayout\" }, classAttribute: \"mat-mdc-table mdc-data-table__table\" }, providers: [\n        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTable, useExisting: MatTable },\n        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_TABLE, useExisting: MatTable },\n        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__._COALESCED_STYLE_SCHEDULER, useClass: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__._CoalescedStyleScheduler },\n        // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code\n        //  is only included in the build if used.\n        { provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._DisposeViewRepeaterStrategy },\n        // Prevent nested tables from seeing this table's StickyPositioningListener.\n        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.STICKY_POSITIONING_LISTENER, useValue: null },\n    ], exportAs: [\"matTable\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"\\n  <ng-content select=\\\"caption\\\"></ng-content>\\n  <ng-content select=\\\"colgroup, col\\\"></ng-content>\\n  <ng-container headerRowOutlet></ng-container>\\n  <ng-container rowOutlet></ng-container>\\n  <ng-container noDataRowOutlet></ng-container>\\n  <ng-container footerRowOutlet></ng-container>\\n\", isInline: true, styles: [\".mdc-data-table{border-radius:var(--mdc-shape-medium, 4px);border-width:1px;border-style:solid}.mdc-data-table .mdc-data-table__header-cell:first-child{border-top-left-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table .mdc-data-table__header-cell:first-child,.mdc-data-table .mdc-data-table__header-cell:first-child[dir=rtl]{border-top-right-radius:var(--mdc-shape-medium, 4px);border-top-left-radius:0}.mdc-data-table .mdc-data-table__header-cell:last-child{border-top-right-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table .mdc-data-table__header-cell:last-child,.mdc-data-table .mdc-data-table__header-cell:last-child[dir=rtl]{border-top-left-radius:var(--mdc-shape-medium, 4px);border-top-right-radius:0}.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child{border-bottom-left-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child,.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child[dir=rtl]{border-bottom-right-radius:var(--mdc-shape-medium, 4px);border-bottom-left-radius:0}.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child{border-bottom-right-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child,.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child[dir=rtl]{border-bottom-left-radius:var(--mdc-shape-medium, 4px);border-bottom-right-radius:0}.mdc-data-table__cell,.mdc-data-table__header-cell{border-bottom-width:1px;border-bottom-style:solid}.mdc-data-table__pagination{border-top-width:1px;border-top-style:solid}.mdc-data-table__row:last-child .mdc-data-table__cell{border-bottom:none}.mdc-data-table__row{height:52px}.mdc-data-table__pagination{min-height:52px}.mdc-data-table__header-row{height:56px}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px 0 16px}.mdc-data-table__header-cell--checkbox,.mdc-data-table__cell--checkbox{padding-left:4px;padding-right:0}[dir=rtl] .mdc-data-table__header-cell--checkbox,[dir=rtl] .mdc-data-table__cell--checkbox,.mdc-data-table__header-cell--checkbox[dir=rtl],.mdc-data-table__cell--checkbox[dir=rtl]{padding-left:0;padding-right:4px}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell,.mdc-data-table__cell[dir=rtl]{text-align:right}.mdc-data-table__cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__cell--numeric,.mdc-data-table__cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__cell--checkbox{width:1px}.mdc-data-table__header-cell{box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mdc-data-table__header-cell,.mdc-data-table__header-cell[dir=rtl]{text-align:right}.mdc-data-table__header-cell--checkbox{width:1px}.mdc-data-table__header-cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__header-cell--numeric,.mdc-data-table__header-cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__sort-icon-button{width:28px;height:28px;padding:2px;transform:rotate(0.0001deg);margin-left:4px;margin-right:0;opacity:0}.mdc-data-table__sort-icon-button .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:28px;height:28px;margin-top:0px;margin-bottom:0px;margin-right:0px;margin-left:0px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:28px;left:50%;width:28px;transform:translate(-50%, -50%)}[dir=rtl] .mdc-data-table__sort-icon-button,.mdc-data-table__sort-icon-button[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__header-cell--sorted-descending .mdc-data-table__sort-icon-button{transform:rotate(-180deg)}.mdc-data-table__sort-icon-button:focus,.mdc-data-table__header-cell:hover .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--sorted .mdc-data-table__sort-icon-button{opacity:1}.mdc-data-table__header-cell-wrapper{align-items:center;display:inline-flex;vertical-align:middle}.mdc-data-table__header-cell--with-sort{cursor:pointer}.mdc-data-table__sort-status-label{clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px}.mdc-data-table--sticky-header .mdc-data-table__header-cell{position:sticky;top:0;z-index:1}.mdc-data-table{-webkit-overflow-scrolling:touch;display:inline-flex;flex-direction:column;box-sizing:border-box;position:relative}.mdc-data-table__table-container{-webkit-overflow-scrolling:touch;overflow-x:auto;width:100%}.mdc-data-table__table{min-width:100%;border:0;white-space:nowrap;border-spacing:0;table-layout:fixed}.mdc-data-table__header-cell{box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mdc-data-table__header-cell,.mdc-data-table__header-cell[dir=rtl]{text-align:right}.mdc-data-table__header-cell--checkbox{width:1px}.mdc-data-table__header-cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__header-cell--numeric,.mdc-data-table__header-cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__sort-icon-button{width:28px;height:28px;padding:2px;transform:rotate(0.0001deg);margin-left:4px;margin-right:0;opacity:0}.mdc-data-table__sort-icon-button .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:28px;height:28px;margin-top:0px;margin-bottom:0px;margin-right:0px;margin-left:0px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:28px;left:50%;width:28px;transform:translate(-50%, -50%)}[dir=rtl] .mdc-data-table__sort-icon-button,.mdc-data-table__sort-icon-button[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__header-cell--sorted-descending .mdc-data-table__sort-icon-button{transform:rotate(-180deg)}.mdc-data-table__sort-icon-button:focus,.mdc-data-table__header-cell:hover .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--sorted .mdc-data-table__sort-icon-button{opacity:1}.mdc-data-table__header-cell-wrapper{align-items:center;display:inline-flex;vertical-align:middle}.mdc-data-table__header-cell--with-sort{cursor:pointer}.mdc-data-table__sort-status-label{clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell,.mdc-data-table__cell[dir=rtl]{text-align:right}.mdc-data-table__cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__cell--numeric,.mdc-data-table__cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__cell--checkbox{width:1px}.mdc-data-table__pagination{box-sizing:border-box;display:flex;justify-content:flex-end}.mdc-data-table__pagination-trailing{margin-left:4px;margin-right:0;align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end}[dir=rtl] .mdc-data-table__pagination-trailing,.mdc-data-table__pagination-trailing[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__pagination-navigation{align-items:center;display:flex}.mdc-data-table__pagination-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__pagination-button .mdc-button__icon,.mdc-data-table__pagination-button .mdc-button__icon[dir=rtl]{transform:rotate(180deg)}[dir=rtl] .mdc-data-table__pagination-button,.mdc-data-table__pagination-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__pagination-total{margin-left:14px;margin-right:36px;white-space:nowrap}[dir=rtl] .mdc-data-table__pagination-total,.mdc-data-table__pagination-total[dir=rtl]{margin-left:36px;margin-right:14px}.mdc-data-table__pagination-rows-per-page{margin-left:0;margin-right:22px;align-items:center;display:inline-flex}[dir=rtl] .mdc-data-table__pagination-rows-per-page,.mdc-data-table__pagination-rows-per-page[dir=rtl]{margin-left:22px;margin-right:0}.mdc-data-table__pagination-rows-per-page-label{margin-left:0;margin-right:12px;white-space:nowrap}[dir=rtl] .mdc-data-table__pagination-rows-per-page-label,.mdc-data-table__pagination-rows-per-page-label[dir=rtl]{margin-left:12px;margin-right:0}.mdc-data-table__pagination-rows-per-page-select{min-width:var(--mdc-menu-min-width, 80px);margin:8px 0}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor{width:100%;min-width:80px}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor{height:36px}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-floating-label--float-above{font-size:.75rem}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-data-table__pagination-rows-per-page-select .mdc-select__dropdown-icon{width:20px;height:20px}.mdc-data-table__pagination-rows-per-page-select.mdc-select--outlined .mdc-select__anchor :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 56px)}.mdc-data-table__pagination-rows-per-page-select .mdc-list-item.mdc-list-item--with-one-line{height:36px}.mdc-data-table__progress-indicator{display:none;position:absolute;width:100%}.mdc-data-table--in-progress .mdc-data-table__progress-indicator{display:block}.mdc-data-table__scrim{background-color:var(--mdc-theme-surface, #fff);height:100%;opacity:.32;position:absolute;top:0;width:100%}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table-sticky{position:sticky !important}.mat-mdc-table{table-layout:auto;white-space:normal}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table .mat-mdc-row:hover,.mat-mdc-table .mat-mdc-footer-row:hover{background-color:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}\"], dependencies: [{ kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.DataRowOutlet, selector: \"[rowOutlet]\" }, { kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.HeaderRowOutlet, selector: \"[headerRowOutlet]\" }, { kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.FooterRowOutlet, selector: \"[footerRowOutlet]\" }, { kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.NoDataRowOutlet, selector: \"[noDataRowOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTable, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ selector: 'mat-table, table[mat-table]', exportAs: 'matTable', template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_TABLE_TEMPLATE, host: {\n                        'class': 'mat-mdc-table mdc-data-table__table',\n                        '[class.mdc-table-fixed-layout]': 'fixedLayout',\n                    }, providers: [\n                        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTable, useExisting: MatTable },\n                        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_TABLE, useExisting: MatTable },\n                        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__._COALESCED_STYLE_SCHEDULER, useClass: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__._CoalescedStyleScheduler },\n                        // TODO(michaeljamesparsons) Abstract the view repeater strategy to a directive API so this code\n                        //  is only included in the build if used.\n                        { provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__._DisposeViewRepeaterStrategy },\n                        // Prevent nested tables from seeing this table's StickyPositioningListener.\n                        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.STICKY_POSITIONING_LISTENER, useValue: null },\n                    ], encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, styles: [\".mdc-data-table{border-radius:var(--mdc-shape-medium, 4px);border-width:1px;border-style:solid}.mdc-data-table .mdc-data-table__header-cell:first-child{border-top-left-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table .mdc-data-table__header-cell:first-child,.mdc-data-table .mdc-data-table__header-cell:first-child[dir=rtl]{border-top-right-radius:var(--mdc-shape-medium, 4px);border-top-left-radius:0}.mdc-data-table .mdc-data-table__header-cell:last-child{border-top-right-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table .mdc-data-table__header-cell:last-child,.mdc-data-table .mdc-data-table__header-cell:last-child[dir=rtl]{border-top-left-radius:var(--mdc-shape-medium, 4px);border-top-right-radius:0}.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child{border-bottom-left-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child,.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:first-child[dir=rtl]{border-bottom-right-radius:var(--mdc-shape-medium, 4px);border-bottom-left-radius:0}.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child{border-bottom-right-radius:var(--mdc-shape-medium, 4px)}[dir=rtl] .mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child,.mdc-data-table.mdc-data-table--without-footer .mdc-data-table__row:last-child .mdc-data-table__cell:last-child[dir=rtl]{border-bottom-left-radius:var(--mdc-shape-medium, 4px);border-bottom-right-radius:0}.mdc-data-table__cell,.mdc-data-table__header-cell{border-bottom-width:1px;border-bottom-style:solid}.mdc-data-table__pagination{border-top-width:1px;border-top-style:solid}.mdc-data-table__row:last-child .mdc-data-table__cell{border-bottom:none}.mdc-data-table__row{height:52px}.mdc-data-table__pagination{min-height:52px}.mdc-data-table__header-row{height:56px}.mdc-data-table__cell,.mdc-data-table__header-cell{padding:0 16px 0 16px}.mdc-data-table__header-cell--checkbox,.mdc-data-table__cell--checkbox{padding-left:4px;padding-right:0}[dir=rtl] .mdc-data-table__header-cell--checkbox,[dir=rtl] .mdc-data-table__cell--checkbox,.mdc-data-table__header-cell--checkbox[dir=rtl],.mdc-data-table__cell--checkbox[dir=rtl]{padding-left:0;padding-right:4px}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell,.mdc-data-table__cell[dir=rtl]{text-align:right}.mdc-data-table__cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__cell--numeric,.mdc-data-table__cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__cell--checkbox{width:1px}.mdc-data-table__header-cell{box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mdc-data-table__header-cell,.mdc-data-table__header-cell[dir=rtl]{text-align:right}.mdc-data-table__header-cell--checkbox{width:1px}.mdc-data-table__header-cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__header-cell--numeric,.mdc-data-table__header-cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__sort-icon-button{width:28px;height:28px;padding:2px;transform:rotate(0.0001deg);margin-left:4px;margin-right:0;opacity:0}.mdc-data-table__sort-icon-button .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:28px;height:28px;margin-top:0px;margin-bottom:0px;margin-right:0px;margin-left:0px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:28px;left:50%;width:28px;transform:translate(-50%, -50%)}[dir=rtl] .mdc-data-table__sort-icon-button,.mdc-data-table__sort-icon-button[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__header-cell--sorted-descending .mdc-data-table__sort-icon-button{transform:rotate(-180deg)}.mdc-data-table__sort-icon-button:focus,.mdc-data-table__header-cell:hover .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--sorted .mdc-data-table__sort-icon-button{opacity:1}.mdc-data-table__header-cell-wrapper{align-items:center;display:inline-flex;vertical-align:middle}.mdc-data-table__header-cell--with-sort{cursor:pointer}.mdc-data-table__sort-status-label{clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px}.mdc-data-table--sticky-header .mdc-data-table__header-cell{position:sticky;top:0;z-index:1}.mdc-data-table{-webkit-overflow-scrolling:touch;display:inline-flex;flex-direction:column;box-sizing:border-box;position:relative}.mdc-data-table__table-container{-webkit-overflow-scrolling:touch;overflow-x:auto;width:100%}.mdc-data-table__table{min-width:100%;border:0;white-space:nowrap;border-spacing:0;table-layout:fixed}.mdc-data-table__header-cell{box-sizing:border-box;text-overflow:ellipsis;overflow:hidden;outline:none;text-align:left}[dir=rtl] .mdc-data-table__header-cell,.mdc-data-table__header-cell[dir=rtl]{text-align:right}.mdc-data-table__header-cell--checkbox{width:1px}.mdc-data-table__header-cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__header-cell--numeric,.mdc-data-table__header-cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__sort-icon-button{width:28px;height:28px;padding:2px;transform:rotate(0.0001deg);margin-left:4px;margin-right:0;opacity:0}.mdc-data-table__sort-icon-button .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__ripple{width:28px;height:28px;margin-top:0px;margin-bottom:0px;margin-right:0px;margin-left:0px}.mdc-data-table__sort-icon-button.mdc-icon-button--reduced-size .mdc-icon-button__focus-ring{max-height:28px;max-width:28px}.mdc-data-table__sort-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:28px;left:50%;width:28px;transform:translate(-50%, -50%)}[dir=rtl] .mdc-data-table__sort-icon-button,.mdc-data-table__sort-icon-button[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--numeric .mdc-data-table__sort-icon-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__header-cell--sorted-descending .mdc-data-table__sort-icon-button{transform:rotate(-180deg)}.mdc-data-table__sort-icon-button:focus,.mdc-data-table__header-cell:hover .mdc-data-table__sort-icon-button,.mdc-data-table__header-cell--sorted .mdc-data-table__sort-icon-button{opacity:1}.mdc-data-table__header-cell-wrapper{align-items:center;display:inline-flex;vertical-align:middle}.mdc-data-table__header-cell--with-sort{cursor:pointer}.mdc-data-table__sort-status-label{clip:rect(1px, 1px, 1px, 1px);height:1px;overflow:hidden;position:absolute;white-space:nowrap;width:1px}.mdc-data-table__cell{box-sizing:border-box;overflow:hidden;text-align:left;text-overflow:ellipsis}[dir=rtl] .mdc-data-table__cell,.mdc-data-table__cell[dir=rtl]{text-align:right}.mdc-data-table__cell--numeric{text-align:right}[dir=rtl] .mdc-data-table__cell--numeric,.mdc-data-table__cell--numeric[dir=rtl]{text-align:left}.mdc-data-table__cell--checkbox{width:1px}.mdc-data-table__pagination{box-sizing:border-box;display:flex;justify-content:flex-end}.mdc-data-table__pagination-trailing{margin-left:4px;margin-right:0;align-items:center;display:flex;flex-wrap:wrap;justify-content:flex-end}[dir=rtl] .mdc-data-table__pagination-trailing,.mdc-data-table__pagination-trailing[dir=rtl]{margin-left:0;margin-right:4px}.mdc-data-table__pagination-navigation{align-items:center;display:flex}.mdc-data-table__pagination-button{margin-left:0;margin-right:4px}[dir=rtl] .mdc-data-table__pagination-button .mdc-button__icon,.mdc-data-table__pagination-button .mdc-button__icon[dir=rtl]{transform:rotate(180deg)}[dir=rtl] .mdc-data-table__pagination-button,.mdc-data-table__pagination-button[dir=rtl]{margin-left:4px;margin-right:0}.mdc-data-table__pagination-total{margin-left:14px;margin-right:36px;white-space:nowrap}[dir=rtl] .mdc-data-table__pagination-total,.mdc-data-table__pagination-total[dir=rtl]{margin-left:36px;margin-right:14px}.mdc-data-table__pagination-rows-per-page{margin-left:0;margin-right:22px;align-items:center;display:inline-flex}[dir=rtl] .mdc-data-table__pagination-rows-per-page,.mdc-data-table__pagination-rows-per-page[dir=rtl]{margin-left:22px;margin-right:0}.mdc-data-table__pagination-rows-per-page-label{margin-left:0;margin-right:12px;white-space:nowrap}[dir=rtl] .mdc-data-table__pagination-rows-per-page-label,.mdc-data-table__pagination-rows-per-page-label[dir=rtl]{margin-left:12px;margin-right:0}.mdc-data-table__pagination-rows-per-page-select{min-width:var(--mdc-menu-min-width, 80px);margin:8px 0}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor{width:100%;min-width:80px}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor{height:36px}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-floating-label--float-above{font-size:.75rem}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-data-table__pagination-rows-per-page-select .mdc-select__anchor .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-data-table__pagination-rows-per-page-select .mdc-select__dropdown-icon{width:20px;height:20px}.mdc-data-table__pagination-rows-per-page-select.mdc-select--outlined .mdc-select__anchor :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 56px)}.mdc-data-table__pagination-rows-per-page-select .mdc-list-item.mdc-list-item--with-one-line{height:36px}.mdc-data-table__progress-indicator{display:none;position:absolute;width:100%}.mdc-data-table--in-progress .mdc-data-table__progress-indicator{display:block}.mdc-data-table__scrim{background-color:var(--mdc-theme-surface, #fff);height:100%;opacity:.32;position:absolute;top:0;width:100%}mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}.mat-mdc-table-sticky{position:sticky !important}.mat-mdc-table{table-layout:auto;white-space:normal}mat-row.mat-mdc-row,mat-header-row.mat-mdc-header-row,mat-footer-row.mat-mdc-footer-row{border-bottom:none}.mat-mdc-table tbody,.mat-mdc-table tfoot,.mat-mdc-table thead,.mat-mdc-cell,.mat-mdc-footer-cell,.mat-mdc-header-row,.mat-mdc-row,.mat-mdc-footer-row,.mat-mdc-table .mat-mdc-header-cell{background:inherit}.mat-mdc-table .mat-mdc-row:hover,.mat-mdc-table .mat-mdc-footer-row:hover{background-color:inherit}.mat-mdc-table mat-header-row.mat-mdc-header-row,.mat-mdc-table mat-row.mat-mdc-row,.mat-mdc-table mat-footer-row.mat-mdc-footer-cell{height:unset}mat-header-cell.mat-mdc-header-cell,mat-cell.mat-mdc-cell,mat-footer-cell.mat-mdc-footer-cell{align-self:stretch}\"] }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Cell definition for the mat-table.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n */\nclass MatCellDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellDef {\n}\nMatCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCellDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatCellDef, selector: \"[matCellDef]\", providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellDef, useExisting: MatCellDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matCellDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellDef, useExisting: MatCellDef }],\n                }]\n        }] });\n/**\n * Header cell definition for the mat-table.\n * Captures the template of a column's header cell and as well as cell-specific properties.\n */\nclass MatHeaderCellDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderCellDef {\n}\nMatHeaderCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderCellDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatHeaderCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatHeaderCellDef, selector: \"[matHeaderCellDef]\", providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderCellDef, useExisting: MatHeaderCellDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matHeaderCellDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderCellDef, useExisting: MatHeaderCellDef }],\n                }]\n        }] });\n/**\n * Footer cell definition for the mat-table.\n * Captures the template of a column's footer cell and as well as cell-specific properties.\n */\nclass MatFooterCellDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterCellDef {\n}\nMatFooterCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterCellDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatFooterCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatFooterCellDef, selector: \"[matFooterCellDef]\", providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterCellDef, useExisting: MatFooterCellDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matFooterCellDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterCellDef, useExisting: MatFooterCellDef }],\n                }]\n        }] });\n/**\n * Column definition for the mat-table.\n * Defines a set of cells available for a table column.\n */\nclass MatColumnDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkColumnDef {\n    /** Unique name for this column. */\n    get name() {\n        return this._name;\n    }\n    set name(name) {\n        this._setNameInput(name);\n    }\n    /**\n     * Add \"mat-column-\" prefix in addition to \"cdk-column-\" prefix.\n     * In the future, this will only add \"mat-column-\" and columnCssClassName\n     * will change from type string[] to string.\n     * @docs-private\n     */\n    _updateColumnCssClassName() {\n        super._updateColumnCssClassName();\n        this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`);\n    }\n}\nMatColumnDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatColumnDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatColumnDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatColumnDef, selector: \"[matColumnDef]\", inputs: { sticky: \"sticky\", name: [\"matColumnDef\", \"name\"] }, providers: [\n        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkColumnDef, useExisting: MatColumnDef },\n        { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef },\n    ], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatColumnDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matColumnDef]',\n                    inputs: ['sticky'],\n                    providers: [\n                        { provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkColumnDef, useExisting: MatColumnDef },\n                        { provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: MatColumnDef },\n                    ],\n                }]\n        }], propDecorators: { name: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['matColumnDef']\n            }] } });\n/** Header cell template container that adds the right classes and role. */\nclass MatHeaderCell extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderCell {\n}\nMatHeaderCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderCell, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatHeaderCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatHeaderCell, selector: \"mat-header-cell, th[mat-header-cell]\", host: { attributes: { \"role\": \"columnheader\" }, classAttribute: \"mat-mdc-header-cell mdc-data-table__header-cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'mat-header-cell, th[mat-header-cell]',\n                    host: {\n                        'class': 'mat-mdc-header-cell mdc-data-table__header-cell',\n                        'role': 'columnheader',\n                    },\n                }]\n        }] });\n/** Footer cell template container that adds the right classes and role. */\nclass MatFooterCell extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterCell {\n}\nMatFooterCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterCell, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatFooterCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatFooterCell, selector: \"mat-footer-cell, td[mat-footer-cell]\", host: { classAttribute: \"mat-mdc-footer-cell mdc-data-table__cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'mat-footer-cell, td[mat-footer-cell]',\n                    host: {\n                        'class': 'mat-mdc-footer-cell mdc-data-table__cell',\n                    },\n                }]\n        }] });\n/** Cell template container that adds the right classes and role. */\nclass MatCell extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCell {\n}\nMatCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCell, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatCell, selector: \"mat-cell, td[mat-cell]\", host: { classAttribute: \"mat-mdc-cell mdc-data-table__cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'mat-cell, td[mat-cell]',\n                    host: {\n                        'class': 'mat-mdc-cell mdc-data-table__cell',\n                    },\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Header row definition for the mat-table.\n * Captures the header row's template and other header properties such as the columns to display.\n */\nclass MatHeaderRowDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRowDef {\n}\nMatHeaderRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderRowDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatHeaderRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatHeaderRowDef, selector: \"[matHeaderRowDef]\", inputs: { columns: [\"matHeaderRowDef\", \"columns\"], sticky: [\"matHeaderRowDefSticky\", \"sticky\"] }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRowDef, useExisting: MatHeaderRowDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matHeaderRowDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRowDef, useExisting: MatHeaderRowDef }],\n                    inputs: ['columns: matHeaderRowDef', 'sticky: matHeaderRowDefSticky'],\n                }]\n        }] });\n/**\n * Footer row definition for the mat-table.\n * Captures the footer row's template and other footer properties such as the columns to display.\n */\nclass MatFooterRowDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRowDef {\n}\nMatFooterRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterRowDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatFooterRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatFooterRowDef, selector: \"[matFooterRowDef]\", inputs: { columns: [\"matFooterRowDef\", \"columns\"], sticky: [\"matFooterRowDefSticky\", \"sticky\"] }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRowDef, useExisting: MatFooterRowDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matFooterRowDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRowDef, useExisting: MatFooterRowDef }],\n                    inputs: ['columns: matFooterRowDef', 'sticky: matFooterRowDefSticky'],\n                }]\n        }] });\n/**\n * Data row definition for the mat-table.\n * Captures the data row's template and other properties such as the columns to display and\n * a when predicate that describes when this row should be used.\n */\nclass MatRowDef extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRowDef {\n}\nMatRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRowDef, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatRowDef, selector: \"[matRowDef]\", inputs: { columns: [\"matRowDefColumns\", \"columns\"], when: [\"matRowDefWhen\", \"when\"] }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRowDef, useExisting: MatRowDef }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[matRowDef]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRowDef, useExisting: MatRowDef }],\n                    inputs: ['columns: matRowDefColumns', 'when: matRowDefWhen'],\n                }]\n        }] });\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\nclass MatHeaderRow extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRow {\n}\nMatHeaderRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderRow, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatHeaderRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatHeaderRow, selector: \"mat-header-row, tr[mat-header-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"mat-mdc-header-row mdc-data-table__header-row\" }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRow, useExisting: MatHeaderRow }], exportAs: [\"matHeaderRow\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatHeaderRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'mat-header-row, tr[mat-header-row]',\n                    template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'mat-mdc-header-row mdc-data-table__header-row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,\n                    exportAs: 'matHeaderRow',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkHeaderRow, useExisting: MatHeaderRow }],\n                }]\n        }] });\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\nclass MatFooterRow extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRow {\n}\nMatFooterRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterRow, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatFooterRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatFooterRow, selector: \"mat-footer-row, tr[mat-footer-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"mat-mdc-footer-row mdc-data-table__row\" }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRow, useExisting: MatFooterRow }], exportAs: [\"matFooterRow\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatFooterRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'mat-footer-row, tr[mat-footer-row]',\n                    template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'mat-mdc-footer-row mdc-data-table__row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,\n                    exportAs: 'matFooterRow',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkFooterRow, useExisting: MatFooterRow }],\n                }]\n        }] });\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\nclass MatRow extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRow {\n}\nMatRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRow, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatRow, selector: \"mat-row, tr[mat-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"mat-mdc-row mdc-data-table__row\" }, providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRow, useExisting: MatRow }], exportAs: [\"matRow\"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'mat-row, tr[mat-row]',\n                    template: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'mat-mdc-row mdc-data-table__row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,\n                    exportAs: 'matRow',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkRow, useExisting: MatRow }],\n                }]\n        }] });\n/** Row that can be used to display a message when no data is shown in the table. */\nclass MatNoDataRow extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkNoDataRow {\n    constructor() {\n        super(...arguments);\n        this._contentClassName = 'mat-mdc-no-data-row';\n    }\n}\nMatNoDataRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNoDataRow, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nMatNoDataRow.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatNoDataRow, selector: \"ng-template[matNoDataRow]\", providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkNoDataRow, useExisting: MatNoDataRow }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatNoDataRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'ng-template[matNoDataRow]',\n                    providers: [{ provide: _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkNoDataRow, useExisting: MatNoDataRow }],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Column that simply shows text content for the header and row cells. Assumes that the table\n * is using the native table implementation (`<table>`).\n *\n * By default, the name of this column will be the header text and data property accessor.\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\n * input.\n */\nclass MatTextColumn extends _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTextColumn {\n}\nMatTextColumn.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTextColumn, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nMatTextColumn.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: MatTextColumn, selector: \"mat-text-column\", usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `\n    <ng-container matColumnDef>\n      <th mat-header-cell *matHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td mat-cell *matCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  `, isInline: true, dependencies: [{ kind: \"directive\", type: MatHeaderCellDef, selector: \"[matHeaderCellDef]\" }, { kind: \"directive\", type: MatColumnDef, selector: \"[matColumnDef]\", inputs: [\"sticky\", \"matColumnDef\"] }, { kind: \"directive\", type: MatCellDef, selector: \"[matCellDef]\" }, { kind: \"directive\", type: MatHeaderCell, selector: \"mat-header-cell, th[mat-header-cell]\" }, { kind: \"directive\", type: MatCell, selector: \"mat-cell, td[mat-cell]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTextColumn, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'mat-text-column',\n                    template: `\n    <ng-container matColumnDef>\n      <th mat-header-cell *matHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td mat-cell *matCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  `,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None,\n                    // Change detection is intentionally not set to OnPush. This component's template will be provided\n                    // to the table to be inserted into its view. This is problematic when change detection runs since\n                    // the bindings in this template will be evaluated _after_ the table's view is evaluated, which\n                    // mean's the template in the table's view will not have the updated value (and in fact will cause\n                    // an ExpressionChangedAfterItHasBeenCheckedError).\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.Default,\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EXPORTED_DECLARATIONS = [\n    // Table\n    MatTable,\n    MatRecycleRows,\n    // Template defs\n    MatHeaderCellDef,\n    MatHeaderRowDef,\n    MatColumnDef,\n    MatCellDef,\n    MatRowDef,\n    MatFooterCellDef,\n    MatFooterRowDef,\n    // Cell directives\n    MatHeaderCell,\n    MatCell,\n    MatFooterCell,\n    // Row directives\n    MatHeaderRow,\n    MatRow,\n    MatFooterRow,\n    MatNoDataRow,\n    MatTextColumn,\n];\nclass MatTableModule {\n}\nMatTableModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTableModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nMatTableModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTableModule, declarations: [\n        // Table\n        MatTable,\n        MatRecycleRows,\n        // Template defs\n        MatHeaderCellDef,\n        MatHeaderRowDef,\n        MatColumnDef,\n        MatCellDef,\n        MatRowDef,\n        MatFooterCellDef,\n        MatFooterRowDef,\n        // Cell directives\n        MatHeaderCell,\n        MatCell,\n        MatFooterCell,\n        // Row directives\n        MatHeaderRow,\n        MatRow,\n        MatFooterRow,\n        MatNoDataRow,\n        MatTextColumn], imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule, _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTableModule], exports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule, \n        // Table\n        MatTable,\n        MatRecycleRows,\n        // Template defs\n        MatHeaderCellDef,\n        MatHeaderRowDef,\n        MatColumnDef,\n        MatCellDef,\n        MatRowDef,\n        MatFooterCellDef,\n        MatFooterRowDef,\n        // Cell directives\n        MatHeaderCell,\n        MatCell,\n        MatFooterCell,\n        // Row directives\n        MatHeaderRow,\n        MatRow,\n        MatFooterRow,\n        MatNoDataRow,\n        MatTextColumn] });\nMatTableModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTableModule, imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule, _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTableModule, _angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MatTableModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule, _angular_cdk_table__WEBPACK_IMPORTED_MODULE_4__.CdkTableModule],\n                    exports: [_angular_material_core__WEBPACK_IMPORTED_MODULE_5__.MatCommonModule, EXPORTED_DECLARATIONS],\n                    declarations: EXPORTED_DECLARATIONS,\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to\n * flaky browser support and the value not being defined in Closure's typings.\n */\nconst MAX_SAFE_INTEGER = 9007199254740991;\n/** Shared base class with MDC-based implementation. */\nclass _MatTableDataSource extends _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_3__.DataSource {\n    /** Array of data that should be rendered by the table, where each object represents one row. */\n    get data() {\n        return this._data.value;\n    }\n    set data(data) {\n        data = Array.isArray(data) ? data : [];\n        this._data.next(data);\n        // Normally the `filteredData` is updated by the re-render\n        // subscription, but that won't happen if it's inactive.\n        if (!this._renderChangesSubscription) {\n            this._filterData(data);\n        }\n    }\n    /**\n     * Filter term that should be used to filter out objects from the data array. To override how\n     * data objects match to this filter string, provide a custom function for filterPredicate.\n     */\n    get filter() {\n        return this._filter.value;\n    }\n    set filter(filter) {\n        this._filter.next(filter);\n        // Normally the `filteredData` is updated by the re-render\n        // subscription, but that won't happen if it's inactive.\n        if (!this._renderChangesSubscription) {\n            this._filterData(this.data);\n        }\n    }\n    /**\n     * Instance of the MatSort directive used by the table to control its sorting. Sort changes\n     * emitted by the MatSort will trigger an update to the table's rendered data.\n     */\n    get sort() {\n        return this._sort;\n    }\n    set sort(sort) {\n        this._sort = sort;\n        this._updateChangeSubscription();\n    }\n    /**\n     * Instance of the paginator component used by the table to control what page of the data is\n     * displayed. Page changes emitted by the paginator will trigger an update to the\n     * table's rendered data.\n     *\n     * Note that the data source uses the paginator's properties to calculate which page of data\n     * should be displayed. If the paginator receives its properties as template inputs,\n     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been\n     * initialized before assigning it to this data source.\n     */\n    get paginator() {\n        return this._paginator;\n    }\n    set paginator(paginator) {\n        this._paginator = paginator;\n        this._updateChangeSubscription();\n    }\n    constructor(initialData = []) {\n        super();\n        /** Stream emitting render data to the table (depends on ordered data changes). */\n        this._renderData = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject([]);\n        /** Stream that emits when a new filter string is set on the data source. */\n        this._filter = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject('');\n        /** Used to react to internal changes of the paginator that are made by the data source itself. */\n        this._internalPageChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /**\n         * Subscription to the changes that should trigger an update to the table's rendered rows, such\n         * as filtering, sorting, pagination, or base data changes.\n         */\n        this._renderChangesSubscription = null;\n        /**\n         * Data accessor function that is used for accessing data properties for sorting through\n         * the default sortData function.\n         * This default function assumes that the sort header IDs (which defaults to the column name)\n         * matches the data's properties (e.g. column Xyz represents data['Xyz']).\n         * May be set to a custom function for different behavior.\n         * @param data Data object that is being accessed.\n         * @param sortHeaderId The name of the column that represents the data.\n         */\n        this.sortingDataAccessor = (data, sortHeaderId) => {\n            const value = data[sortHeaderId];\n            if ((0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__._isNumberValue)(value)) {\n                const numberValue = Number(value);\n                // Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we\n                // leave them as strings. For more info: https://goo.gl/y5vbSg\n                return numberValue < MAX_SAFE_INTEGER ? numberValue : value;\n            }\n            return value;\n        };\n        /**\n         * Gets a sorted copy of the data array based on the state of the MatSort. Called\n         * after changes are made to the filtered data or when sort changes are emitted from MatSort.\n         * By default, the function retrieves the active sort and its direction and compares data\n         * by retrieving data using the sortingDataAccessor. May be overridden for a custom implementation\n         * of data ordering.\n         * @param data The array of data that should be sorted.\n         * @param sort The connected MatSort that holds the current sort state.\n         */\n        this.sortData = (data, sort) => {\n            const active = sort.active;\n            const direction = sort.direction;\n            if (!active || direction == '') {\n                return data;\n            }\n            return data.sort((a, b) => {\n                let valueA = this.sortingDataAccessor(a, active);\n                let valueB = this.sortingDataAccessor(b, active);\n                // If there are data in the column that can be converted to a number,\n                // it must be ensured that the rest of the data\n                // is of the same type so as not to order incorrectly.\n                const valueAType = typeof valueA;\n                const valueBType = typeof valueB;\n                if (valueAType !== valueBType) {\n                    if (valueAType === 'number') {\n                        valueA += '';\n                    }\n                    if (valueBType === 'number') {\n                        valueB += '';\n                    }\n                }\n                // If both valueA and valueB exist (truthy), then compare the two. Otherwise, check if\n                // one value exists while the other doesn't. In this case, existing value should come last.\n                // This avoids inconsistent results when comparing values to undefined/null.\n                // If neither value exists, return 0 (equal).\n                let comparatorResult = 0;\n                if (valueA != null && valueB != null) {\n                    // Check if one value is greater than the other; if equal, comparatorResult should remain 0.\n                    if (valueA > valueB) {\n                        comparatorResult = 1;\n                    }\n                    else if (valueA < valueB) {\n                        comparatorResult = -1;\n                    }\n                }\n                else if (valueA != null) {\n                    comparatorResult = 1;\n                }\n                else if (valueB != null) {\n                    comparatorResult = -1;\n                }\n                return comparatorResult * (direction == 'asc' ? 1 : -1);\n            });\n        };\n        /**\n         * Checks if a data object matches the data source's filter string. By default, each data object\n         * is converted to a string of its properties and returns true if the filter has\n         * at least one occurrence in that string. By default, the filter string has its whitespace\n         * trimmed and the match is case-insensitive. May be overridden for a custom implementation of\n         * filter matching.\n         * @param data Data object used to check against the filter.\n         * @param filter Filter string that has been set on the data source.\n         * @returns Whether the filter matches against the data\n         */\n        this.filterPredicate = (data, filter) => {\n            // Transform the data into a lowercase string of all property values.\n            const dataStr = Object.keys(data)\n                .reduce((currentTerm, key) => {\n                // Use an obscure Unicode character to delimit the words in the concatenated string.\n                // This avoids matches where the values of two columns combined will match the user's query\n                // (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something\n                // that has a very low chance of being typed in by somebody in a text field. This one in\n                // particular is \"White up-pointing triangle with dot\" from\n                // https://en.wikipedia.org/wiki/List_of_Unicode_characters\n                return currentTerm + data[key] + '◬';\n            }, '')\n                .toLowerCase();\n            // Transform the filter by converting it to lowercase and removing whitespace.\n            const transformedFilter = filter.trim().toLowerCase();\n            return dataStr.indexOf(transformedFilter) != -1;\n        };\n        this._data = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(initialData);\n        this._updateChangeSubscription();\n    }\n    /**\n     * Subscribe to changes that should trigger an update to the table's rendered rows. When the\n     * changes occur, process the current state of the filter, sort, and pagination along with\n     * the provided base data and send it to the table for rendering.\n     */\n    _updateChangeSubscription() {\n        // Sorting and/or pagination should be watched if sort and/or paginator are provided.\n        // The events should emit whenever the component emits a change or initializes, or if no\n        // component is provided, a stream with just a null event should be provided.\n        // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the\n        // pipeline can progress to the next step. Note that the value from these streams are not used,\n        // they purely act as a signal to progress in the pipeline.\n        const sortChange = this._sort\n            ? (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.merge)(this._sort.sortChange, this._sort.initialized)\n            : (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(null);\n        const pageChange = this._paginator\n            ? (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.merge)(this._paginator.page, this._internalPageChanges, this._paginator.initialized)\n            : (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(null);\n        const dataStream = this._data;\n        // Watch for base data or filter changes to provide a filtered set of data.\n        const filteredData = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([dataStream, this._filter]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(([data]) => this._filterData(data)));\n        // Watch for filtered data or sort changes to provide an ordered set of data.\n        const orderedData = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([filteredData, sortChange]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(([data]) => this._orderData(data)));\n        // Watch for ordered data or page changes to provide a paged set of data.\n        const paginatedData = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.combineLatest)([orderedData, pageChange]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(([data]) => this._pageData(data)));\n        // Watched for paged data changes and send the result to the table to render.\n        this._renderChangesSubscription?.unsubscribe();\n        this._renderChangesSubscription = paginatedData.subscribe(data => this._renderData.next(data));\n    }\n    /**\n     * Returns a filtered data array where each filter object contains the filter string within\n     * the result of the filterPredicate function. If no filter is set, returns the data array\n     * as provided.\n     */\n    _filterData(data) {\n        // If there is a filter string, filter out data that does not contain it.\n        // Each data object is converted to a string using the function defined by filterPredicate.\n        // May be overridden for customization.\n        this.filteredData =\n            this.filter == null || this.filter === ''\n                ? data\n                : data.filter(obj => this.filterPredicate(obj, this.filter));\n        if (this.paginator) {\n            this._updatePaginator(this.filteredData.length);\n        }\n        return this.filteredData;\n    }\n    /**\n     * Returns a sorted copy of the data if MatSort has a sort applied, otherwise just returns the\n     * data array as provided. Uses the default data accessor for data lookup, unless a\n     * sortDataAccessor function is defined.\n     */\n    _orderData(data) {\n        // If there is no active sort or direction, return the data without trying to sort.\n        if (!this.sort) {\n            return data;\n        }\n        return this.sortData(data.slice(), this.sort);\n    }\n    /**\n     * Returns a paged slice of the provided data array according to the provided paginator's page\n     * index and length. If there is no paginator provided, returns the data array as provided.\n     */\n    _pageData(data) {\n        if (!this.paginator) {\n            return data;\n        }\n        const startIndex = this.paginator.pageIndex * this.paginator.pageSize;\n        return data.slice(startIndex, startIndex + this.paginator.pageSize);\n    }\n    /**\n     * Updates the paginator to reflect the length of the filtered data, and makes sure that the page\n     * index does not exceed the paginator's last page. Values are changed in a resolved promise to\n     * guard against making property changes within a round of change detection.\n     */\n    _updatePaginator(filteredDataLength) {\n        Promise.resolve().then(() => {\n            const paginator = this.paginator;\n            if (!paginator) {\n                return;\n            }\n            paginator.length = filteredDataLength;\n            // If the page index is set beyond the page, reduce it to the last page.\n            if (paginator.pageIndex > 0) {\n                const lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;\n                const newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);\n                if (newPageIndex !== paginator.pageIndex) {\n                    paginator.pageIndex = newPageIndex;\n                    // Since the paginator only emits after user-generated changes,\n                    // we need our own stream so we know to should re-render the data.\n                    this._internalPageChanges.next();\n                }\n            }\n        });\n    }\n    /**\n     * Used by the MatTable. Called when it connects to the data source.\n     * @docs-private\n     */\n    connect() {\n        if (!this._renderChangesSubscription) {\n            this._updateChangeSubscription();\n        }\n        return this._renderData;\n    }\n    /**\n     * Used by the MatTable. Called when it disconnects from the data source.\n     * @docs-private\n     */\n    disconnect() {\n        this._renderChangesSubscription?.unsubscribe();\n        this._renderChangesSubscription = null;\n    }\n}\n/**\n * Data source that accepts a client-side data array and includes native support of filtering,\n * sorting (using MatSort), and pagination (using MatPaginator).\n *\n * Allows for sort customization by overriding sortingDataAccessor, which defines how data\n * properties are accessed. Also allows for filter customization by overriding filterPredicate,\n * which defines how row data is converted to a string for filter matching.\n *\n * **Note:** This class is meant to be a simple data source to help you get started. As such\n * it isn't equipped to handle some more advanced cases like robust i18n support or server-side\n * interactions. If your app needs to support more advanced use cases, consider implementing your\n * own `DataSource`.\n */\nclass MatTableDataSource extends _MatTableDataSource {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=table.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvbWF0ZXJpYWwvZmVzbTIwMjAvdGFibGUubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9tYXRlcmlhbC9mZXNtMjAyMC90YWJsZS5tanM/ZDIwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpMCBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIElucHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY2RrL3RhYmxlJztcbmltcG9ydCB7IENka1RhYmxlLCBDREtfVEFCTEUsIF9DT0FMRVNDRURfU1RZTEVfU0NIRURVTEVSLCBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIsIFNUSUNLWV9QT1NJVElPTklOR19MSVNURU5FUiwgQ0RLX1RBQkxFX1RFTVBMQVRFLCBDZGtDZWxsRGVmLCBDZGtIZWFkZXJDZWxsRGVmLCBDZGtGb290ZXJDZWxsRGVmLCBDZGtDb2x1bW5EZWYsIENka0hlYWRlckNlbGwsIENka0Zvb3RlckNlbGwsIENka0NlbGwsIENka0hlYWRlclJvd0RlZiwgQ2RrRm9vdGVyUm93RGVmLCBDZGtSb3dEZWYsIENka0hlYWRlclJvdywgQ0RLX1JPV19URU1QTEFURSwgQ2RrRm9vdGVyUm93LCBDZGtSb3csIENka05vRGF0YVJvdywgQ2RrVGV4dENvbHVtbiwgQ2RrVGFibGVNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHsgX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1ksIF9SZWN5Y2xlVmlld1JlcGVhdGVyU3RyYXRlZ3ksIF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3ksIERhdGFTb3VyY2UgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuaW1wb3J0IHsgTWF0Q29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YmplY3QsIG1lcmdlLCBvZiwgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgX2lzTnVtYmVyVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogRW5hYmxlcyB0aGUgcmVjeWNsZSB2aWV3IHJlcGVhdGVyIHN0cmF0ZWd5LCB3aGljaCByZWR1Y2VzIHJlbmRlcmluZyBsYXRlbmN5LiBOb3QgY29tcGF0aWJsZSB3aXRoXG4gKiB0YWJsZXMgdGhhdCBhbmltYXRlIHJvd3MuXG4gKi9cbmNsYXNzIE1hdFJlY3ljbGVSb3dzIHtcbn1cbk1hdFJlY3ljbGVSb3dzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0UmVjeWNsZVJvd3MsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbk1hdFJlY3ljbGVSb3dzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0UmVjeWNsZVJvd3MsIHNlbGVjdG9yOiBcIm1hdC10YWJsZVtyZWN5Y2xlUm93c10sIHRhYmxlW21hdC10YWJsZV1bcmVjeWNsZVJvd3NdXCIsIHByb3ZpZGVyczogW3sgcHJvdmlkZTogX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1ksIHVzZUNsYXNzOiBfUmVjeWNsZVZpZXdSZXBlYXRlclN0cmF0ZWd5IH1dLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRSZWN5Y2xlUm93cywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXRhYmxlW3JlY3ljbGVSb3dzXSwgdGFibGVbbWF0LXRhYmxlXVtyZWN5Y2xlUm93c10nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCB1c2VDbGFzczogX1JlY3ljbGVWaWV3UmVwZWF0ZXJTdHJhdGVneSB9XSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcbmNsYXNzIE1hdFRhYmxlIGV4dGVuZHMgQ2RrVGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogT3ZlcnJpZGVzIHRoZSBzdGlja3kgQ1NTIGNsYXNzIHNldCBieSB0aGUgYENka1RhYmxlYC4gKi9cbiAgICAgICAgdGhpcy5zdGlja3lDc3NDbGFzcyA9ICdtYXQtbWRjLXRhYmxlLXN0aWNreSc7XG4gICAgICAgIC8qKiBPdmVycmlkZXMgdGhlIG5lZWQgdG8gYWRkIHBvc2l0aW9uOiBzdGlja3kgb24gZXZlcnkgc3RpY2t5IGNlbGwgZWxlbWVudCBpbiBgQ2RrVGFibGVgLiAqL1xuICAgICAgICB0aGlzLm5lZWRzUG9zaXRpb25TdGlja3lPbkVsZW1lbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIEFmdGVyIG5nT25Jbml0LCB0aGUgYENka1RhYmxlYCBoYXMgY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgdGhlIHRhYmxlIHNlY3Rpb25zICh0aGVhZCwgdGJvZHksXG4gICAgICAgIC8vIHRmb290KS4gTURDIHJlcXVpcmVzIHRoZSBgbWRjLWRhdGEtdGFibGVfX2NvbnRlbnRgIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBib2R5LiBOb3RlIHRoYXRcbiAgICAgICAgLy8gdGhpcyBvbmx5IGFwcGxpZXMgdG8gbmF0aXZlIHRhYmxlcywgYmVjYXVzZSB3ZSBkb24ndCB3cmFwIHRoZSBjb250ZW50IG9mIGZsZXhib3gtYmFzZWQgb25lcy5cbiAgICAgICAgaWYgKHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB0Ym9keSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xuICAgICAgICAgICAgdGJvZHkuY2xhc3NMaXN0LmFkZCgnbWRjLWRhdGEtdGFibGVfX2NvbnRlbnQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk1hdFRhYmxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0VGFibGUsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuTWF0VGFibGUuybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRUYWJsZSwgc2VsZWN0b3I6IFwibWF0LXRhYmxlLCB0YWJsZVttYXQtdGFibGVdXCIsIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImNsYXNzLm1kYy10YWJsZS1maXhlZC1sYXlvdXRcIjogXCJmaXhlZExheW91dFwiIH0sIGNsYXNzQXR0cmlidXRlOiBcIm1hdC1tZGMtdGFibGUgbWRjLWRhdGEtdGFibGVfX3RhYmxlXCIgfSwgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogQ2RrVGFibGUsIHVzZUV4aXN0aW5nOiBNYXRUYWJsZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IENES19UQUJMRSwgdXNlRXhpc3Rpbmc6IE1hdFRhYmxlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsIHVzZUNsYXNzOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgfSxcbiAgICAgICAgLy8gVE9ETyhtaWNoYWVsamFtZXNwYXJzb25zKSBBYnN0cmFjdCB0aGUgdmlldyByZXBlYXRlciBzdHJhdGVneSB0byBhIGRpcmVjdGl2ZSBBUEkgc28gdGhpcyBjb2RlXG4gICAgICAgIC8vICBpcyBvbmx5IGluY2x1ZGVkIGluIHRoZSBidWlsZCBpZiB1c2VkLlxuICAgICAgICB7IHByb3ZpZGU6IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCB1c2VDbGFzczogX0Rpc3Bvc2VWaWV3UmVwZWF0ZXJTdHJhdGVneSB9LFxuICAgICAgICAvLyBQcmV2ZW50IG5lc3RlZCB0YWJsZXMgZnJvbSBzZWVpbmcgdGhpcyB0YWJsZSdzIFN0aWNreVBvc2l0aW9uaW5nTGlzdGVuZXIuXG4gICAgICAgIHsgcHJvdmlkZTogU1RJQ0tZX1BPU0lUSU9OSU5HX0xJU1RFTkVSLCB1c2VWYWx1ZTogbnVsbCB9LFxuICAgIF0sIGV4cG9ydEFzOiBbXCJtYXRUYWJsZVwiXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBcIlxcbiAgPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJjYXB0aW9uXFxcIj48L25nLWNvbnRlbnQ+XFxuICA8bmctY29udGVudCBzZWxlY3Q9XFxcImNvbGdyb3VwLCBjb2xcXFwiPjwvbmctY29udGVudD5cXG4gIDxuZy1jb250YWluZXIgaGVhZGVyUm93T3V0bGV0PjwvbmctY29udGFpbmVyPlxcbiAgPG5nLWNvbnRhaW5lciByb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XFxuICA8bmctY29udGFpbmVyIG5vRGF0YVJvd091dGxldD48L25nLWNvbnRhaW5lcj5cXG4gIDxuZy1jb250YWluZXIgZm9vdGVyUm93T3V0bGV0PjwvbmctY29udGFpbmVyPlxcblwiLCBpc0lubGluZTogdHJ1ZSwgc3R5bGVzOiBbXCIubWRjLWRhdGEtdGFibGV7Ym9yZGVyLXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpO2JvcmRlci13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkfS5tZGMtZGF0YS10YWJsZSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmZpcnN0LWNoaWxke2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KX1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGw6Zmlyc3QtY2hpbGQsLm1kYy1kYXRhLXRhYmxlIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGw6Zmlyc3QtY2hpbGRbZGlyPXJ0bF17Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KTtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9Lm1kYy1kYXRhLXRhYmxlIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGw6bGFzdC1jaGlsZHtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGUgLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbDpsYXN0LWNoaWxkLC5tZGMtZGF0YS10YWJsZSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmxhc3QtY2hpbGRbZGlyPXJ0bF17Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9Lm1kYy1kYXRhLXRhYmxlLm1kYy1kYXRhLXRhYmxlLS13aXRob3V0LWZvb3RlciAubWRjLWRhdGEtdGFibGVfX3JvdzpsYXN0LWNoaWxkIC5tZGMtZGF0YS10YWJsZV9fY2VsbDpmaXJzdC1jaGlsZHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLW1kYy1zaGFwZS1tZWRpdW0sIDRweCl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZS5tZGMtZGF0YS10YWJsZS0td2l0aG91dC1mb290ZXIgLm1kYy1kYXRhLXRhYmxlX19yb3c6bGFzdC1jaGlsZCAubWRjLWRhdGEtdGFibGVfX2NlbGw6Zmlyc3QtY2hpbGQsLm1kYy1kYXRhLXRhYmxlLm1kYy1kYXRhLXRhYmxlLS13aXRob3V0LWZvb3RlciAubWRjLWRhdGEtdGFibGVfX3JvdzpsYXN0LWNoaWxkIC5tZGMtZGF0YS10YWJsZV9fY2VsbDpmaXJzdC1jaGlsZFtkaXI9cnRsXXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MH0ubWRjLWRhdGEtdGFibGUubWRjLWRhdGEtdGFibGUtLXdpdGhvdXQtZm9vdGVyIC5tZGMtZGF0YS10YWJsZV9fcm93Omxhc3QtY2hpbGQgLm1kYy1kYXRhLXRhYmxlX19jZWxsOmxhc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KX1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlLm1kYy1kYXRhLXRhYmxlLS13aXRob3V0LWZvb3RlciAubWRjLWRhdGEtdGFibGVfX3JvdzpsYXN0LWNoaWxkIC5tZGMtZGF0YS10YWJsZV9fY2VsbDpsYXN0LWNoaWxkLC5tZGMtZGF0YS10YWJsZS5tZGMtZGF0YS10YWJsZS0td2l0aG91dC1mb290ZXIgLm1kYy1kYXRhLXRhYmxlX19yb3c6bGFzdC1jaGlsZCAubWRjLWRhdGEtdGFibGVfX2NlbGw6bGFzdC1jaGlsZFtkaXI9cnRsXXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOnZhcigtLW1kYy1zaGFwZS1tZWRpdW0sIDRweCk7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH0ubWRjLWRhdGEtdGFibGVfX2NlbGwsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbHtib3JkZXItYm90dG9tLXdpZHRoOjFweDtib3JkZXItYm90dG9tLXN0eWxlOnNvbGlkfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbntib3JkZXItdG9wLXdpZHRoOjFweDtib3JkZXItdG9wLXN0eWxlOnNvbGlkfS5tZGMtZGF0YS10YWJsZV9fcm93Omxhc3QtY2hpbGQgLm1kYy1kYXRhLXRhYmxlX19jZWxse2JvcmRlci1ib3R0b206bm9uZX0ubWRjLWRhdGEtdGFibGVfX3Jvd3toZWlnaHQ6NTJweH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb257bWluLWhlaWdodDo1MnB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvd3toZWlnaHQ6NTZweH0ubWRjLWRhdGEtdGFibGVfX2NlbGwsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbHtwYWRkaW5nOjAgMTZweCAwIDE2cHh9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3gsLm1kYy1kYXRhLXRhYmxlX19jZWxsLS1jaGVja2JveHtwYWRkaW5nLWxlZnQ6NHB4O3BhZGRpbmctcmlnaHQ6MH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3gsW2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3gsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3hbZGlyPXJ0bF0sLm1kYy1kYXRhLXRhYmxlX19jZWxsLS1jaGVja2JveFtkaXI9cnRsXXtwYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjRweH0ubWRjLWRhdGEtdGFibGVfX2NlbGx7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OmhpZGRlbjt0ZXh0LWFsaWduOmxlZnQ7dGV4dC1vdmVyZmxvdzplbGxpcHNpc31bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19jZWxsLC5tZGMtZGF0YS10YWJsZV9fY2VsbFtkaXI9cnRsXXt0ZXh0LWFsaWduOnJpZ2h0fS5tZGMtZGF0YS10YWJsZV9fY2VsbC0tbnVtZXJpY3t0ZXh0LWFsaWduOnJpZ2h0fVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWMsLm1kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljW2Rpcj1ydGxde3RleHQtYWxpZ246bGVmdH0ubWRjLWRhdGEtdGFibGVfX2NlbGwtLWNoZWNrYm94e3dpZHRoOjFweH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxse2JveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO292ZXJmbG93OmhpZGRlbjtvdXRsaW5lOm5vbmU7dGV4dC1hbGlnbjpsZWZ0fVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGxbZGlyPXJ0bF17dGV4dC1hbGlnbjpyaWdodH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1jaGVja2JveHt3aWR0aDoxcHh9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpY3t0ZXh0LWFsaWduOnJpZ2h0fVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWNbZGlyPXJ0bF17dGV4dC1hbGlnbjpsZWZ0fS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbnt3aWR0aDoyOHB4O2hlaWdodDoyOHB4O3BhZGRpbmc6MnB4O3RyYW5zZm9ybTpyb3RhdGUoMC4wMDAxZGVnKTttYXJnaW4tbGVmdDo0cHg7bWFyZ2luLXJpZ2h0OjA7b3BhY2l0eTowfS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiAubWRjLWljb24tYnV0dG9uX19mb2N1cy1yaW5ne21heC1oZWlnaHQ6MjhweDttYXgtd2lkdGg6MjhweH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24ubWRjLWljb24tYnV0dG9uLS1yZWR1Y2VkLXNpemUgLm1kYy1pY29uLWJ1dHRvbl9fcmlwcGxle3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHg7bWFyZ2luLXRvcDowcHg7bWFyZ2luLWJvdHRvbTowcHg7bWFyZ2luLXJpZ2h0OjBweDttYXJnaW4tbGVmdDowcHh9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLm1kYy1pY29uLWJ1dHRvbi0tcmVkdWNlZC1zaXplIC5tZGMtaWNvbi1idXR0b25fX2ZvY3VzLXJpbmd7bWF4LWhlaWdodDoyOHB4O21heC13aWR0aDoyOHB4fS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiAubWRjLWljb24tYnV0dG9uX190b3VjaHtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2hlaWdodDoyOHB4O2xlZnQ6NTAlO3dpZHRoOjI4cHg7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKX1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbltkaXI9cnRsXXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDo0cHh9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b257bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiwubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbltkaXI9cnRsXXttYXJnaW4tbGVmdDo0cHg7bWFyZ2luLXJpZ2h0OjB9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tc29ydGVkLWRlc2NlbmRpbmcgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue3RyYW5zZm9ybTpyb3RhdGUoLTE4MGRlZyl9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uOmZvY3VzLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGw6aG92ZXIgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZCAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b257b3BhY2l0eToxfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtd3JhcHBlcnthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTppbmxpbmUtZmxleDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0td2l0aC1zb3J0e2N1cnNvcjpwb2ludGVyfS5tZGMtZGF0YS10YWJsZV9fc29ydC1zdGF0dXMtbGFiZWx7Y2xpcDpyZWN0KDFweCwgMXB4LCAxcHgsIDFweCk7aGVpZ2h0OjFweDtvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246YWJzb2x1dGU7d2hpdGUtc3BhY2U6bm93cmFwO3dpZHRoOjFweH0ubWRjLWRhdGEtdGFibGUtLXN0aWNreS1oZWFkZXIgLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbHtwb3NpdGlvbjpzdGlja3k7dG9wOjA7ei1pbmRleDoxfS5tZGMtZGF0YS10YWJsZXstd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzp0b3VjaDtkaXNwbGF5OmlubGluZS1mbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmV9Lm1kYy1kYXRhLXRhYmxlX190YWJsZS1jb250YWluZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7b3ZlcmZsb3cteDphdXRvO3dpZHRoOjEwMCV9Lm1kYy1kYXRhLXRhYmxlX190YWJsZXttaW4td2lkdGg6MTAwJTtib3JkZXI6MDt3aGl0ZS1zcGFjZTpub3dyYXA7Ym9yZGVyLXNwYWNpbmc6MDt0YWJsZS1sYXlvdXQ6Zml4ZWR9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbHtib3gtc2l6aW5nOmJvcmRlci1ib3g7dGV4dC1vdmVyZmxvdzplbGxpcHNpcztvdmVyZmxvdzpoaWRkZW47b3V0bGluZTpub25lO3RleHQtYWxpZ246bGVmdH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbCwubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsW2Rpcj1ydGxde3RleHQtYWxpZ246cmlnaHR9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3h7d2lkdGg6MXB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWN7dGV4dC1hbGlnbjpyaWdodH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYywubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljW2Rpcj1ydGxde3RleHQtYWxpZ246bGVmdH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b257d2lkdGg6MjhweDtoZWlnaHQ6MjhweDtwYWRkaW5nOjJweDt0cmFuc2Zvcm06cm90YXRlKDAuMDAwMWRlZyk7bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowO29wYWNpdHk6MH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24gLm1kYy1pY29uLWJ1dHRvbl9fZm9jdXMtcmluZ3ttYXgtaGVpZ2h0OjI4cHg7bWF4LXdpZHRoOjI4cHh9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLm1kYy1pY29uLWJ1dHRvbi0tcmVkdWNlZC1zaXplIC5tZGMtaWNvbi1idXR0b25fX3JpcHBsZXt3aWR0aDoyOHB4O2hlaWdodDoyOHB4O21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206MHB4O21hcmdpbi1yaWdodDowcHg7bWFyZ2luLWxlZnQ6MHB4fS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbi5tZGMtaWNvbi1idXR0b24tLXJlZHVjZWQtc2l6ZSAubWRjLWljb24tYnV0dG9uX19mb2N1cy1yaW5ne21heC1oZWlnaHQ6MjhweDttYXgtd2lkdGg6MjhweH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24gLm1kYy1pY29uLWJ1dHRvbl9fdG91Y2h7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtoZWlnaHQ6MjhweDtsZWZ0OjUwJTt3aWR0aDoyOHB4O3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiwubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjRweH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24sLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZC1kZXNjZW5kaW5nIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbnt0cmFuc2Zvcm06cm90YXRlKC0xODBkZWcpfS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbjpmb2N1cywubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmhvdmVyIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiwubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1zb3J0ZWQgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue29wYWNpdHk6MX0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLXdyYXBwZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXdpdGgtc29ydHtjdXJzb3I6cG9pbnRlcn0ubWRjLWRhdGEtdGFibGVfX3NvcnQtc3RhdHVzLWxhYmVse2NsaXA6cmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpO2hlaWdodDoxcHg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOmFic29sdXRlO3doaXRlLXNwYWNlOm5vd3JhcDt3aWR0aDoxcHh9Lm1kYy1kYXRhLXRhYmxlX19jZWxse2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW47dGV4dC1hbGlnbjpsZWZ0O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fY2VsbCwubWRjLWRhdGEtdGFibGVfX2NlbGxbZGlyPXJ0bF17dGV4dC1hbGlnbjpyaWdodH0ubWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWN7dGV4dC1hbGlnbjpyaWdodH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljLC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tbnVtZXJpY1tkaXI9cnRsXXt0ZXh0LWFsaWduOmxlZnR9Lm1kYy1kYXRhLXRhYmxlX19jZWxsLS1jaGVja2JveHt3aWR0aDoxcHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9ue2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10cmFpbGluZ3ttYXJnaW4tbGVmdDo0cHg7bWFyZ2luLXJpZ2h0OjA7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6d3JhcDtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10cmFpbGluZywubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdHJhaWxpbmdbZGlyPXJ0bF17bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1uYXZpZ2F0aW9ue2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLWJ1dHRvbnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDo0cHh9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b24gLm1kYy1idXR0b25fX2ljb24sLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLWJ1dHRvbiAubWRjLWJ1dHRvbl9faWNvbltkaXI9cnRsXXt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b24sLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLWJ1dHRvbltkaXI9cnRsXXttYXJnaW4tbGVmdDo0cHg7bWFyZ2luLXJpZ2h0OjB9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRvdGFse21hcmdpbi1sZWZ0OjE0cHg7bWFyZ2luLXJpZ2h0OjM2cHg7d2hpdGUtc3BhY2U6bm93cmFwfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdG90YWwsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRvdGFsW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjM2cHg7bWFyZ2luLXJpZ2h0OjE0cHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2V7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MjJweDthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTppbmxpbmUtZmxleH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2VbZGlyPXJ0bF17bWFyZ2luLWxlZnQ6MjJweDttYXJnaW4tcmlnaHQ6MH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1sYWJlbHttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDoxMnB4O3doaXRlLXNwYWNlOm5vd3JhcH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWwsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWxbZGlyPXJ0bF17bWFyZ2luLWxlZnQ6MTJweDttYXJnaW4tcmlnaHQ6MH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3R7bWluLXdpZHRoOnZhcigtLW1kYy1tZW51LW1pbi13aWR0aCwgODBweCk7bWFyZ2luOjhweCAwfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9ye3dpZHRoOjEwMCU7bWluLXdpZHRoOjgwcHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3J7aGVpZ2h0OjM2cHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3IgLm1kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTI3LjI1cHgpIHNjYWxlKDEpfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9yIC5tZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3Zle2ZvbnQtc2l6ZTouNzVyZW19Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3IubWRjLW5vdGNoZWQtb3V0bGluZS0tdXBncmFkZWQgLm1kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3IgLm1kYy1ub3RjaGVkLW91dGxpbmUtLXVwZ3JhZGVkIC5tZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3Zle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0yNC43NXB4KSBzY2FsZSgwLjc1KX0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QgLm1kYy1zZWxlY3RfX2FuY2hvci5tZGMtbm90Y2hlZC1vdXRsaW5lLS11cGdyYWRlZCAubWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZSwubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QgLm1kYy1zZWxlY3RfX2FuY2hvciAubWRjLW5vdGNoZWQtb3V0bGluZS0tdXBncmFkZWQgLm1kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmV7Zm9udC1zaXplOjFyZW19Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19kcm9wZG93bi1pY29ue3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0Lm1kYy1zZWxlY3QtLW91dGxpbmVkIC5tZGMtc2VsZWN0X19hbmNob3IgOm5vdCgubWRjLW5vdGNoZWQtb3V0bGluZS0tbm90Y2hlZCkgLm1kYy1ub3RjaGVkLW91dGxpbmVfX25vdGNoe21heC13aWR0aDpjYWxjKDEwMCUgLSA1NnB4KX0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QgLm1kYy1saXN0LWl0ZW0ubWRjLWxpc3QtaXRlbS0td2l0aC1vbmUtbGluZXtoZWlnaHQ6MzZweH0ubWRjLWRhdGEtdGFibGVfX3Byb2dyZXNzLWluZGljYXRvcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTAwJX0ubWRjLWRhdGEtdGFibGUtLWluLXByb2dyZXNzIC5tZGMtZGF0YS10YWJsZV9fcHJvZ3Jlc3MtaW5kaWNhdG9ye2Rpc3BsYXk6YmxvY2t9Lm1kYy1kYXRhLXRhYmxlX19zY3JpbXtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLW1kYy10aGVtZS1zdXJmYWNlLCAjZmZmKTtoZWlnaHQ6MTAwJTtvcGFjaXR5Oi4zMjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDt3aWR0aDoxMDAlfW1hdC10YWJsZXtkaXNwbGF5OmJsb2NrfW1hdC1oZWFkZXItcm93e21pbi1oZWlnaHQ6NTZweH1tYXQtcm93LG1hdC1mb290ZXItcm93e21pbi1oZWlnaHQ6NDhweH1tYXQtcm93LG1hdC1oZWFkZXItcm93LG1hdC1mb290ZXItcm93e2Rpc3BsYXk6ZmxleDtib3JkZXItd2lkdGg6MDtib3JkZXItYm90dG9tLXdpZHRoOjFweDtib3JkZXItc3R5bGU6c29saWQ7YWxpZ24taXRlbXM6Y2VudGVyO2JveC1zaXppbmc6Ym9yZGVyLWJveH1tYXQtY2VsbDpmaXJzdC1vZi10eXBlLG1hdC1oZWFkZXItY2VsbDpmaXJzdC1vZi10eXBlLG1hdC1mb290ZXItY2VsbDpmaXJzdC1vZi10eXBle3BhZGRpbmctbGVmdDoyNHB4fVtkaXI9cnRsXSBtYXQtY2VsbDpmaXJzdC1vZi10eXBlOm5vdCg6b25seS1vZi10eXBlKSxbZGlyPXJ0bF0gbWF0LWhlYWRlci1jZWxsOmZpcnN0LW9mLXR5cGU6bm90KDpvbmx5LW9mLXR5cGUpLFtkaXI9cnRsXSBtYXQtZm9vdGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZTpub3QoOm9ubHktb2YtdHlwZSl7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDoyNHB4fW1hdC1jZWxsOmxhc3Qtb2YtdHlwZSxtYXQtaGVhZGVyLWNlbGw6bGFzdC1vZi10eXBlLG1hdC1mb290ZXItY2VsbDpsYXN0LW9mLXR5cGV7cGFkZGluZy1yaWdodDoyNHB4fVtkaXI9cnRsXSBtYXQtY2VsbDpsYXN0LW9mLXR5cGU6bm90KDpvbmx5LW9mLXR5cGUpLFtkaXI9cnRsXSBtYXQtaGVhZGVyLWNlbGw6bGFzdC1vZi10eXBlOm5vdCg6b25seS1vZi10eXBlKSxbZGlyPXJ0bF0gbWF0LWZvb3Rlci1jZWxsOmxhc3Qtb2YtdHlwZTpub3QoOm9ubHktb2YtdHlwZSl7cGFkZGluZy1yaWdodDowO3BhZGRpbmctbGVmdDoyNHB4fW1hdC1jZWxsLG1hdC1oZWFkZXItY2VsbCxtYXQtZm9vdGVyLWNlbGx7ZmxleDoxO2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7b3ZlcmZsb3c6aGlkZGVuO3dvcmQtd3JhcDpicmVhay13b3JkO21pbi1oZWlnaHQ6aW5oZXJpdH0ubWF0LW1kYy10YWJsZS1zdGlja3l7cG9zaXRpb246c3RpY2t5ICFpbXBvcnRhbnR9Lm1hdC1tZGMtdGFibGV7dGFibGUtbGF5b3V0OmF1dG87d2hpdGUtc3BhY2U6bm9ybWFsfW1hdC1yb3cubWF0LW1kYy1yb3csbWF0LWhlYWRlci1yb3cubWF0LW1kYy1oZWFkZXItcm93LG1hdC1mb290ZXItcm93Lm1hdC1tZGMtZm9vdGVyLXJvd3tib3JkZXItYm90dG9tOm5vbmV9Lm1hdC1tZGMtdGFibGUgdGJvZHksLm1hdC1tZGMtdGFibGUgdGZvb3QsLm1hdC1tZGMtdGFibGUgdGhlYWQsLm1hdC1tZGMtY2VsbCwubWF0LW1kYy1mb290ZXItY2VsbCwubWF0LW1kYy1oZWFkZXItcm93LC5tYXQtbWRjLXJvdywubWF0LW1kYy1mb290ZXItcm93LC5tYXQtbWRjLXRhYmxlIC5tYXQtbWRjLWhlYWRlci1jZWxse2JhY2tncm91bmQ6aW5oZXJpdH0ubWF0LW1kYy10YWJsZSAubWF0LW1kYy1yb3c6aG92ZXIsLm1hdC1tZGMtdGFibGUgLm1hdC1tZGMtZm9vdGVyLXJvdzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmluaGVyaXR9Lm1hdC1tZGMtdGFibGUgbWF0LWhlYWRlci1yb3cubWF0LW1kYy1oZWFkZXItcm93LC5tYXQtbWRjLXRhYmxlIG1hdC1yb3cubWF0LW1kYy1yb3csLm1hdC1tZGMtdGFibGUgbWF0LWZvb3Rlci1yb3cubWF0LW1kYy1mb290ZXItY2VsbHtoZWlnaHQ6dW5zZXR9bWF0LWhlYWRlci1jZWxsLm1hdC1tZGMtaGVhZGVyLWNlbGwsbWF0LWNlbGwubWF0LW1kYy1jZWxsLG1hdC1mb290ZXItY2VsbC5tYXQtbWRjLWZvb3Rlci1jZWxse2FsaWduLXNlbGY6c3RyZXRjaH1cIl0sIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTEuRGF0YVJvd091dGxldCwgc2VsZWN0b3I6IFwiW3Jvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGkxLkhlYWRlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2hlYWRlclJvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGkxLkZvb3RlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2Zvb3RlclJvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGkxLk5vRGF0YVJvd091dGxldCwgc2VsZWN0b3I6IFwiW25vRGF0YVJvd091dGxldF1cIiB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0VGFibGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ21hdC10YWJsZSwgdGFibGVbbWF0LXRhYmxlXScsIGV4cG9ydEFzOiAnbWF0VGFibGUnLCB0ZW1wbGF0ZTogQ0RLX1RBQkxFX1RFTVBMQVRFLCBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LW1kYy10YWJsZSBtZGMtZGF0YS10YWJsZV9fdGFibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5tZGMtdGFibGUtZml4ZWQtbGF5b3V0XSc6ICdmaXhlZExheW91dCcsXG4gICAgICAgICAgICAgICAgICAgIH0sIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBDZGtUYWJsZSwgdXNlRXhpc3Rpbmc6IE1hdFRhYmxlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IENES19UQUJMRSwgdXNlRXhpc3Rpbmc6IE1hdFRhYmxlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IF9DT0FMRVNDRURfU1RZTEVfU0NIRURVTEVSLCB1c2VDbGFzczogX0NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG1pY2hhZWxqYW1lc3BhcnNvbnMpIEFic3RyYWN0IHRoZSB2aWV3IHJlcGVhdGVyIHN0cmF0ZWd5IHRvIGEgZGlyZWN0aXZlIEFQSSBzbyB0aGlzIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpcyBvbmx5IGluY2x1ZGVkIGluIHRoZSBidWlsZCBpZiB1c2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgdXNlQ2xhc3M6IF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3kgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmVzdGVkIHRhYmxlcyBmcm9tIHNlZWluZyB0aGlzIHRhYmxlJ3MgU3RpY2t5UG9zaXRpb25pbmdMaXN0ZW5lci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogU1RJQ0tZX1BPU0lUSU9OSU5HX0xJU1RFTkVSLCB1c2VWYWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBdLCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsIHN0eWxlczogW1wiLm1kYy1kYXRhLXRhYmxle2JvcmRlci1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KTtib3JkZXItd2lkdGg6MXB4O2JvcmRlci1zdHlsZTpzb2xpZH0ubWRjLWRhdGEtdGFibGUgLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbDpmaXJzdC1jaGlsZHtib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLW1kYy1zaGFwZS1tZWRpdW0sIDRweCl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmZpcnN0LWNoaWxkLC5tZGMtZGF0YS10YWJsZSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmZpcnN0LWNoaWxkW2Rpcj1ydGxde2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLW1kYy1zaGFwZS1tZWRpdW0sIDRweCk7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5tZGMtZGF0YS10YWJsZSAubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmxhc3QtY2hpbGR7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KX1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGw6bGFzdC1jaGlsZCwubWRjLWRhdGEtdGFibGUgLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbDpsYXN0LWNoaWxkW2Rpcj1ydGxde2JvcmRlci10b3AtbGVmdC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5tZGMtZGF0YS10YWJsZS5tZGMtZGF0YS10YWJsZS0td2l0aG91dC1mb290ZXIgLm1kYy1kYXRhLXRhYmxlX19yb3c6bGFzdC1jaGlsZCAubWRjLWRhdGEtdGFibGVfX2NlbGw6Zmlyc3QtY2hpbGR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGUubWRjLWRhdGEtdGFibGUtLXdpdGhvdXQtZm9vdGVyIC5tZGMtZGF0YS10YWJsZV9fcm93Omxhc3QtY2hpbGQgLm1kYy1kYXRhLXRhYmxlX19jZWxsOmZpcnN0LWNoaWxkLC5tZGMtZGF0YS10YWJsZS5tZGMtZGF0YS10YWJsZS0td2l0aG91dC1mb290ZXIgLm1kYy1kYXRhLXRhYmxlX19yb3c6bGFzdC1jaGlsZCAubWRjLWRhdGEtdGFibGVfX2NlbGw6Zmlyc3QtY2hpbGRbZGlyPXJ0bF17Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tbWRjLXNoYXBlLW1lZGl1bSwgNHB4KTtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9Lm1kYy1kYXRhLXRhYmxlLm1kYy1kYXRhLXRhYmxlLS13aXRob3V0LWZvb3RlciAubWRjLWRhdGEtdGFibGVfX3JvdzpsYXN0LWNoaWxkIC5tZGMtZGF0YS10YWJsZV9fY2VsbDpsYXN0LWNoaWxke2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnZhcigtLW1kYy1zaGFwZS1tZWRpdW0sIDRweCl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZS5tZGMtZGF0YS10YWJsZS0td2l0aG91dC1mb290ZXIgLm1kYy1kYXRhLXRhYmxlX19yb3c6bGFzdC1jaGlsZCAubWRjLWRhdGEtdGFibGVfX2NlbGw6bGFzdC1jaGlsZCwubWRjLWRhdGEtdGFibGUubWRjLWRhdGEtdGFibGUtLXdpdGhvdXQtZm9vdGVyIC5tZGMtZGF0YS10YWJsZV9fcm93Omxhc3QtY2hpbGQgLm1kYy1kYXRhLXRhYmxlX19jZWxsOmxhc3QtY2hpbGRbZGlyPXJ0bF17Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1tZGMtc2hhcGUtbWVkaXVtLCA0cHgpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjB9Lm1kYy1kYXRhLXRhYmxlX19jZWxsLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGx7Ym9yZGVyLWJvdHRvbS13aWR0aDoxcHg7Ym9yZGVyLWJvdHRvbS1zdHlsZTpzb2xpZH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb257Ym9yZGVyLXRvcC13aWR0aDoxcHg7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZH0ubWRjLWRhdGEtdGFibGVfX3JvdzpsYXN0LWNoaWxkIC5tZGMtZGF0YS10YWJsZV9fY2VsbHtib3JkZXItYm90dG9tOm5vbmV9Lm1kYy1kYXRhLXRhYmxlX19yb3d7aGVpZ2h0OjUycHh9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9ue21pbi1oZWlnaHQ6NTJweH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1yb3d7aGVpZ2h0OjU2cHh9Lm1kYy1kYXRhLXRhYmxlX19jZWxsLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGx7cGFkZGluZzowIDE2cHggMCAxNnB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94LC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3h7cGFkZGluZy1sZWZ0OjRweDtwYWRkaW5nLXJpZ2h0OjB9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94LFtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2NlbGwtLWNoZWNrYm94LC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94W2Rpcj1ydGxdLC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3hbZGlyPXJ0bF17cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDo0cHh9Lm1kYy1kYXRhLXRhYmxlX19jZWxse2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpoaWRkZW47dGV4dC1hbGlnbjpsZWZ0O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fY2VsbCwubWRjLWRhdGEtdGFibGVfX2NlbGxbZGlyPXJ0bF17dGV4dC1hbGlnbjpyaWdodH0ubWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWN7dGV4dC1hbGlnbjpyaWdodH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmljLC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tbnVtZXJpY1tkaXI9cnRsXXt0ZXh0LWFsaWduOmxlZnR9Lm1kYy1kYXRhLXRhYmxlX19jZWxsLS1jaGVja2JveHt3aWR0aDoxcHh9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbHtib3gtc2l6aW5nOmJvcmRlci1ib3g7dGV4dC1vdmVyZmxvdzplbGxpcHNpcztvdmVyZmxvdzpoaWRkZW47b3V0bGluZTpub25lO3RleHQtYWxpZ246bGVmdH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbCwubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsW2Rpcj1ydGxde3RleHQtYWxpZ246cmlnaHR9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tY2hlY2tib3h7d2lkdGg6MXB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWN7dGV4dC1hbGlnbjpyaWdodH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYywubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljW2Rpcj1ydGxde3RleHQtYWxpZ246bGVmdH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b257d2lkdGg6MjhweDtoZWlnaHQ6MjhweDtwYWRkaW5nOjJweDt0cmFuc2Zvcm06cm90YXRlKDAuMDAwMWRlZyk7bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowO29wYWNpdHk6MH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24gLm1kYy1pY29uLWJ1dHRvbl9fZm9jdXMtcmluZ3ttYXgtaGVpZ2h0OjI4cHg7bWF4LXdpZHRoOjI4cHh9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLm1kYy1pY29uLWJ1dHRvbi0tcmVkdWNlZC1zaXplIC5tZGMtaWNvbi1idXR0b25fX3JpcHBsZXt3aWR0aDoyOHB4O2hlaWdodDoyOHB4O21hcmdpbi10b3A6MHB4O21hcmdpbi1ib3R0b206MHB4O21hcmdpbi1yaWdodDowcHg7bWFyZ2luLWxlZnQ6MHB4fS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbi5tZGMtaWNvbi1idXR0b24tLXJlZHVjZWQtc2l6ZSAubWRjLWljb24tYnV0dG9uX19mb2N1cy1yaW5ne21heC1oZWlnaHQ6MjhweDttYXgtd2lkdGg6MjhweH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24gLm1kYy1pY29uLWJ1dHRvbl9fdG91Y2h7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtoZWlnaHQ6MjhweDtsZWZ0OjUwJTt3aWR0aDoyOHB4O3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSl9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiwubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjRweH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24sLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpYyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXNvcnRlZC1kZXNjZW5kaW5nIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbnt0cmFuc2Zvcm06cm90YXRlKC0xODBkZWcpfS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbjpmb2N1cywubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsOmhvdmVyIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbiwubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1zb3J0ZWQgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue29wYWNpdHk6MX0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLXdyYXBwZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWZsZXg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLXdpdGgtc29ydHtjdXJzb3I6cG9pbnRlcn0ubWRjLWRhdGEtdGFibGVfX3NvcnQtc3RhdHVzLWxhYmVse2NsaXA6cmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpO2hlaWdodDoxcHg7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOmFic29sdXRlO3doaXRlLXNwYWNlOm5vd3JhcDt3aWR0aDoxcHh9Lm1kYy1kYXRhLXRhYmxlLS1zdGlja3ktaGVhZGVyIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGx7cG9zaXRpb246c3RpY2t5O3RvcDowO3otaW5kZXg6MX0ubWRjLWRhdGEtdGFibGV7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7ZGlzcGxheTppbmxpbmUtZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlfS5tZGMtZGF0YS10YWJsZV9fdGFibGUtY29udGFpbmVyey13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO292ZXJmbG93LXg6YXV0bzt3aWR0aDoxMDAlfS5tZGMtZGF0YS10YWJsZV9fdGFibGV7bWluLXdpZHRoOjEwMCU7Ym9yZGVyOjA7d2hpdGUtc3BhY2U6bm93cmFwO2JvcmRlci1zcGFjaW5nOjA7dGFibGUtbGF5b3V0OmZpeGVkfS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGx7Ym94LXNpemluZzpib3JkZXItYm94O3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7b3ZlcmZsb3c6aGlkZGVuO291dGxpbmU6bm9uZTt0ZXh0LWFsaWduOmxlZnR9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbFtkaXI9cnRsXXt0ZXh0LWFsaWduOnJpZ2h0fS5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLWNoZWNrYm94e3dpZHRoOjFweH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmlje3RleHQtYWxpZ246cmlnaHR9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tbnVtZXJpY1tkaXI9cnRsXXt0ZXh0LWFsaWduOmxlZnR9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9ue3dpZHRoOjI4cHg7aGVpZ2h0OjI4cHg7cGFkZGluZzoycHg7dHJhbnNmb3JtOnJvdGF0ZSgwLjAwMDFkZWcpO21hcmdpbi1sZWZ0OjRweDttYXJnaW4tcmlnaHQ6MDtvcGFjaXR5OjB9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uIC5tZGMtaWNvbi1idXR0b25fX2ZvY3VzLXJpbmd7bWF4LWhlaWdodDoyOHB4O21heC13aWR0aDoyOHB4fS5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbi5tZGMtaWNvbi1idXR0b24tLXJlZHVjZWQtc2l6ZSAubWRjLWljb24tYnV0dG9uX19yaXBwbGV7d2lkdGg6MjhweDtoZWlnaHQ6MjhweDttYXJnaW4tdG9wOjBweDttYXJnaW4tYm90dG9tOjBweDttYXJnaW4tcmlnaHQ6MHB4O21hcmdpbi1sZWZ0OjBweH0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24ubWRjLWljb24tYnV0dG9uLS1yZWR1Y2VkLXNpemUgLm1kYy1pY29uLWJ1dHRvbl9fZm9jdXMtcmluZ3ttYXgtaGVpZ2h0OjI4cHg7bWF4LXdpZHRoOjI4cHh9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uIC5tZGMtaWNvbi1idXR0b25fX3RvdWNoe3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7aGVpZ2h0OjI4cHg7bGVmdDo1MCU7d2lkdGg6MjhweDt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24sLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjRweH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1udW1lcmljIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbnttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDo0cHh9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uLC5tZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGwtLW51bWVyaWMgLm1kYy1kYXRhLXRhYmxlX19zb3J0LWljb24tYnV0dG9uW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjRweDttYXJnaW4tcmlnaHQ6MH0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS1zb3J0ZWQtZGVzY2VuZGluZyAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b257dHJhbnNmb3JtOnJvdGF0ZSgtMTgwZGVnKX0ubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b246Zm9jdXMsLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbDpob3ZlciAubWRjLWRhdGEtdGFibGVfX3NvcnQtaWNvbi1idXR0b24sLm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC0tc29ydGVkIC5tZGMtZGF0YS10YWJsZV9fc29ydC1pY29uLWJ1dHRvbntvcGFjaXR5OjF9Lm1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbC13cmFwcGVye2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmlubGluZS1mbGV4O3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWRjLWRhdGEtdGFibGVfX2hlYWRlci1jZWxsLS13aXRoLXNvcnR7Y3Vyc29yOnBvaW50ZXJ9Lm1kYy1kYXRhLXRhYmxlX19zb3J0LXN0YXR1cy1sYWJlbHtjbGlwOnJlY3QoMXB4LCAxcHgsIDFweCwgMXB4KTtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjphYnNvbHV0ZTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MXB4fS5tZGMtZGF0YS10YWJsZV9fY2VsbHtib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6aGlkZGVuO3RleHQtYWxpZ246bGVmdDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX2NlbGwsLm1kYy1kYXRhLXRhYmxlX19jZWxsW2Rpcj1ydGxde3RleHQtYWxpZ246cmlnaHR9Lm1kYy1kYXRhLXRhYmxlX19jZWxsLS1udW1lcmlje3RleHQtYWxpZ246cmlnaHR9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fY2VsbC0tbnVtZXJpYywubWRjLWRhdGEtdGFibGVfX2NlbGwtLW51bWVyaWNbZGlyPXJ0bF17dGV4dC1hbGlnbjpsZWZ0fS5tZGMtZGF0YS10YWJsZV9fY2VsbC0tY2hlY2tib3h7d2lkdGg6MXB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbntib3gtc2l6aW5nOmJvcmRlci1ib3g7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpmbGV4LWVuZH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdHJhaWxpbmd7bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowO2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOndyYXA7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tdHJhaWxpbmcsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRyYWlsaW5nW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjRweH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tbmF2aWdhdGlvbnthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b257bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6NHB4fVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tYnV0dG9uIC5tZGMtYnV0dG9uX19pY29uLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b24gLm1kYy1idXR0b25fX2ljb25bZGlyPXJ0bF17dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfVtkaXI9cnRsXSAubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tYnV0dG9uLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1idXR0b25bZGlyPXJ0bF17bWFyZ2luLWxlZnQ6NHB4O21hcmdpbi1yaWdodDowfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10b3RhbHttYXJnaW4tbGVmdDoxNHB4O21hcmdpbi1yaWdodDozNnB4O3doaXRlLXNwYWNlOm5vd3JhcH1bZGlyPXJ0bF0gLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXRvdGFsLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi10b3RhbFtkaXI9cnRsXXttYXJnaW4tbGVmdDozNnB4O21hcmdpbi1yaWdodDoxNHB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdle21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjIycHg7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWZsZXh9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjIycHg7bWFyZ2luLXJpZ2h0OjB9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2UtbGFiZWx7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MTJweDt3aGl0ZS1zcGFjZTpub3dyYXB9W2Rpcj1ydGxdIC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLWxhYmVsLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLWxhYmVsW2Rpcj1ydGxde21hcmdpbi1sZWZ0OjEycHg7bWFyZ2luLXJpZ2h0OjB9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0e21pbi13aWR0aDp2YXIoLS1tZGMtbWVudS1taW4td2lkdGgsIDgwcHgpO21hcmdpbjo4cHggMH0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QgLm1kYy1zZWxlY3RfX2FuY2hvcnt3aWR0aDoxMDAlO21pbi13aWR0aDo4MHB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9ye2hlaWdodDozNnB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9yIC5tZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3Zle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0yNy4yNXB4KSBzY2FsZSgxKX0ubWRjLWRhdGEtdGFibGVfX3BhZ2luYXRpb24tcm93cy1wZXItcGFnZS1zZWxlY3QgLm1kYy1zZWxlY3RfX2FuY2hvciAubWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZXtmb250LXNpemU6Ljc1cmVtfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9yLm1kYy1ub3RjaGVkLW91dGxpbmUtLXVwZ3JhZGVkIC5tZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3ZlLC5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fYW5jaG9yIC5tZGMtbm90Y2hlZC1vdXRsaW5lLS11cGdyYWRlZCAubWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMjQuNzVweCkgc2NhbGUoMC43NSl9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3IubWRjLW5vdGNoZWQtb3V0bGluZS0tdXBncmFkZWQgLm1kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUsLm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtc2VsZWN0X19hbmNob3IgLm1kYy1ub3RjaGVkLW91dGxpbmUtLXVwZ3JhZGVkIC5tZGMtZmxvYXRpbmctbGFiZWwtLWZsb2F0LWFib3Zle2ZvbnQtc2l6ZToxcmVtfS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdCAubWRjLXNlbGVjdF9fZHJvcGRvd24taWNvbnt3aWR0aDoyMHB4O2hlaWdodDoyMHB4fS5tZGMtZGF0YS10YWJsZV9fcGFnaW5hdGlvbi1yb3dzLXBlci1wYWdlLXNlbGVjdC5tZGMtc2VsZWN0LS1vdXRsaW5lZCAubWRjLXNlbGVjdF9fYW5jaG9yIDpub3QoLm1kYy1ub3RjaGVkLW91dGxpbmUtLW5vdGNoZWQpIC5tZGMtbm90Y2hlZC1vdXRsaW5lX19ub3RjaHttYXgtd2lkdGg6Y2FsYygxMDAlIC0gNTZweCl9Lm1kYy1kYXRhLXRhYmxlX19wYWdpbmF0aW9uLXJvd3MtcGVyLXBhZ2Utc2VsZWN0IC5tZGMtbGlzdC1pdGVtLm1kYy1saXN0LWl0ZW0tLXdpdGgtb25lLWxpbmV7aGVpZ2h0OjM2cHh9Lm1kYy1kYXRhLXRhYmxlX19wcm9ncmVzcy1pbmRpY2F0b3J7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEwMCV9Lm1kYy1kYXRhLXRhYmxlLS1pbi1wcm9ncmVzcyAubWRjLWRhdGEtdGFibGVfX3Byb2dyZXNzLWluZGljYXRvcntkaXNwbGF5OmJsb2NrfS5tZGMtZGF0YS10YWJsZV9fc2NyaW17YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1tZGMtdGhlbWUtc3VyZmFjZSwgI2ZmZik7aGVpZ2h0OjEwMCU7b3BhY2l0eTouMzI7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7d2lkdGg6MTAwJX1tYXQtdGFibGV7ZGlzcGxheTpibG9ja31tYXQtaGVhZGVyLXJvd3ttaW4taGVpZ2h0OjU2cHh9bWF0LXJvdyxtYXQtZm9vdGVyLXJvd3ttaW4taGVpZ2h0OjQ4cHh9bWF0LXJvdyxtYXQtaGVhZGVyLXJvdyxtYXQtZm9vdGVyLXJvd3tkaXNwbGF5OmZsZXg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLWJvdHRvbS13aWR0aDoxcHg7Ym9yZGVyLXN0eWxlOnNvbGlkO2FsaWduLWl0ZW1zOmNlbnRlcjtib3gtc2l6aW5nOmJvcmRlci1ib3h9bWF0LWNlbGw6Zmlyc3Qtb2YtdHlwZSxtYXQtaGVhZGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZSxtYXQtZm9vdGVyLWNlbGw6Zmlyc3Qtb2YtdHlwZXtwYWRkaW5nLWxlZnQ6MjRweH1bZGlyPXJ0bF0gbWF0LWNlbGw6Zmlyc3Qtb2YtdHlwZTpub3QoOm9ubHktb2YtdHlwZSksW2Rpcj1ydGxdIG1hdC1oZWFkZXItY2VsbDpmaXJzdC1vZi10eXBlOm5vdCg6b25seS1vZi10eXBlKSxbZGlyPXJ0bF0gbWF0LWZvb3Rlci1jZWxsOmZpcnN0LW9mLXR5cGU6bm90KDpvbmx5LW9mLXR5cGUpe3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MjRweH1tYXQtY2VsbDpsYXN0LW9mLXR5cGUsbWF0LWhlYWRlci1jZWxsOmxhc3Qtb2YtdHlwZSxtYXQtZm9vdGVyLWNlbGw6bGFzdC1vZi10eXBle3BhZGRpbmctcmlnaHQ6MjRweH1bZGlyPXJ0bF0gbWF0LWNlbGw6bGFzdC1vZi10eXBlOm5vdCg6b25seS1vZi10eXBlKSxbZGlyPXJ0bF0gbWF0LWhlYWRlci1jZWxsOmxhc3Qtb2YtdHlwZTpub3QoOm9ubHktb2YtdHlwZSksW2Rpcj1ydGxdIG1hdC1mb290ZXItY2VsbDpsYXN0LW9mLXR5cGU6bm90KDpvbmx5LW9mLXR5cGUpe3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MjRweH1tYXQtY2VsbCxtYXQtaGVhZGVyLWNlbGwsbWF0LWZvb3Rlci1jZWxse2ZsZXg6MTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO292ZXJmbG93OmhpZGRlbjt3b3JkLXdyYXA6YnJlYWstd29yZDttaW4taGVpZ2h0OmluaGVyaXR9Lm1hdC1tZGMtdGFibGUtc3RpY2t5e3Bvc2l0aW9uOnN0aWNreSAhaW1wb3J0YW50fS5tYXQtbWRjLXRhYmxle3RhYmxlLWxheW91dDphdXRvO3doaXRlLXNwYWNlOm5vcm1hbH1tYXQtcm93Lm1hdC1tZGMtcm93LG1hdC1oZWFkZXItcm93Lm1hdC1tZGMtaGVhZGVyLXJvdyxtYXQtZm9vdGVyLXJvdy5tYXQtbWRjLWZvb3Rlci1yb3d7Ym9yZGVyLWJvdHRvbTpub25lfS5tYXQtbWRjLXRhYmxlIHRib2R5LC5tYXQtbWRjLXRhYmxlIHRmb290LC5tYXQtbWRjLXRhYmxlIHRoZWFkLC5tYXQtbWRjLWNlbGwsLm1hdC1tZGMtZm9vdGVyLWNlbGwsLm1hdC1tZGMtaGVhZGVyLXJvdywubWF0LW1kYy1yb3csLm1hdC1tZGMtZm9vdGVyLXJvdywubWF0LW1kYy10YWJsZSAubWF0LW1kYy1oZWFkZXItY2VsbHtiYWNrZ3JvdW5kOmluaGVyaXR9Lm1hdC1tZGMtdGFibGUgLm1hdC1tZGMtcm93OmhvdmVyLC5tYXQtbWRjLXRhYmxlIC5tYXQtbWRjLWZvb3Rlci1yb3c6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjppbmhlcml0fS5tYXQtbWRjLXRhYmxlIG1hdC1oZWFkZXItcm93Lm1hdC1tZGMtaGVhZGVyLXJvdywubWF0LW1kYy10YWJsZSBtYXQtcm93Lm1hdC1tZGMtcm93LC5tYXQtbWRjLXRhYmxlIG1hdC1mb290ZXItcm93Lm1hdC1tZGMtZm9vdGVyLWNlbGx7aGVpZ2h0OnVuc2V0fW1hdC1oZWFkZXItY2VsbC5tYXQtbWRjLWhlYWRlci1jZWxsLG1hdC1jZWxsLm1hdC1tZGMtY2VsbCxtYXQtZm9vdGVyLWNlbGwubWF0LW1kYy1mb290ZXItY2VsbHthbGlnbi1zZWxmOnN0cmV0Y2h9XCJdIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2VsbCBkZWZpbml0aW9uIGZvciB0aGUgbWF0LXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZGF0YSByb3cgY2VsbCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgTWF0Q2VsbERlZiBleHRlbmRzIENka0NlbGxEZWYge1xufVxuTWF0Q2VsbERlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdENlbGxEZWYsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuTWF0Q2VsbERlZi7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdENlbGxEZWYsIHNlbGVjdG9yOiBcIlttYXRDZWxsRGVmXVwiLCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0NlbGxEZWYsIHVzZUV4aXN0aW5nOiBNYXRDZWxsRGVmIH1dLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdENlbGxEZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXRDZWxsRGVmXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IE1hdENlbGxEZWYgfV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIEhlYWRlciBjZWxsIGRlZmluaXRpb24gZm9yIHRoZSBtYXQtdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBoZWFkZXIgY2VsbCBhbmQgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIE1hdEhlYWRlckNlbGxEZWYgZXh0ZW5kcyBDZGtIZWFkZXJDZWxsRGVmIHtcbn1cbk1hdEhlYWRlckNlbGxEZWYuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRIZWFkZXJDZWxsRGVmLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbk1hdEhlYWRlckNlbGxEZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRIZWFkZXJDZWxsRGVmLCBzZWxlY3RvcjogXCJbbWF0SGVhZGVyQ2VsbERlZl1cIiwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtIZWFkZXJDZWxsRGVmLCB1c2VFeGlzdGluZzogTWF0SGVhZGVyQ2VsbERlZiB9XSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRIZWFkZXJDZWxsRGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0SGVhZGVyQ2VsbERlZl0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0hlYWRlckNlbGxEZWYsIHVzZUV4aXN0aW5nOiBNYXRIZWFkZXJDZWxsRGVmIH1dLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBGb290ZXIgY2VsbCBkZWZpbml0aW9uIGZvciB0aGUgbWF0LXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgZm9vdGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBNYXRGb290ZXJDZWxsRGVmIGV4dGVuZHMgQ2RrRm9vdGVyQ2VsbERlZiB7XG59XG5NYXRGb290ZXJDZWxsRGVmLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Rm9vdGVyQ2VsbERlZiwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRGb290ZXJDZWxsRGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0Rm9vdGVyQ2VsbERlZiwgc2VsZWN0b3I6IFwiW21hdEZvb3RlckNlbGxEZWZdXCIsIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrRm9vdGVyQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IE1hdEZvb3RlckNlbGxEZWYgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Rm9vdGVyQ2VsbERlZiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21hdEZvb3RlckNlbGxEZWZdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtGb290ZXJDZWxsRGVmLCB1c2VFeGlzdGluZzogTWF0Rm9vdGVyQ2VsbERlZiB9XSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQ29sdW1uIGRlZmluaXRpb24gZm9yIHRoZSBtYXQtdGFibGUuXG4gKiBEZWZpbmVzIGEgc2V0IG9mIGNlbGxzIGF2YWlsYWJsZSBmb3IgYSB0YWJsZSBjb2x1bW4uXG4gKi9cbmNsYXNzIE1hdENvbHVtbkRlZiBleHRlbmRzIENka0NvbHVtbkRlZiB7XG4gICAgLyoqIFVuaXF1ZSBuYW1lIGZvciB0aGlzIGNvbHVtbi4gKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fc2V0TmFtZUlucHV0KG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgXCJtYXQtY29sdW1uLVwiIHByZWZpeCBpbiBhZGRpdGlvbiB0byBcImNkay1jb2x1bW4tXCIgcHJlZml4LlxuICAgICAqIEluIHRoZSBmdXR1cmUsIHRoaXMgd2lsbCBvbmx5IGFkZCBcIm1hdC1jb2x1bW4tXCIgYW5kIGNvbHVtbkNzc0NsYXNzTmFtZVxuICAgICAqIHdpbGwgY2hhbmdlIGZyb20gdHlwZSBzdHJpbmdbXSB0byBzdHJpbmcuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVDb2x1bW5Dc3NDbGFzc05hbWUoKSB7XG4gICAgICAgIHN1cGVyLl91cGRhdGVDb2x1bW5Dc3NDbGFzc05hbWUoKTtcbiAgICAgICAgdGhpcy5fY29sdW1uQ3NzQ2xhc3NOYW1lLnB1c2goYG1hdC1jb2x1bW4tJHt0aGlzLmNzc0NsYXNzRnJpZW5kbHlOYW1lfWApO1xuICAgIH1cbn1cbk1hdENvbHVtbkRlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdENvbHVtbkRlZiwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRDb2x1bW5EZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRDb2x1bW5EZWYsIHNlbGVjdG9yOiBcIlttYXRDb2x1bW5EZWZdXCIsIGlucHV0czogeyBzdGlja3k6IFwic3RpY2t5XCIsIG5hbWU6IFtcIm1hdENvbHVtbkRlZlwiLCBcIm5hbWVcIl0gfSwgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogQ2RrQ29sdW1uRGVmLCB1c2VFeGlzdGluZzogTWF0Q29sdW1uRGVmIH0sXG4gICAgICAgIHsgcHJvdmlkZTogJ01BVF9TT1JUX0hFQURFUl9DT0xVTU5fREVGJywgdXNlRXhpc3Rpbmc6IE1hdENvbHVtbkRlZiB9LFxuICAgIF0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Q29sdW1uRGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0Q29sdW1uRGVmXScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydzdGlja3knXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IENka0NvbHVtbkRlZiwgdXNlRXhpc3Rpbmc6IE1hdENvbHVtbkRlZiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiAnTUFUX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYnLCB1c2VFeGlzdGluZzogTWF0Q29sdW1uRGVmIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IG5hbWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydtYXRDb2x1bW5EZWYnXVxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKiBIZWFkZXIgY2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xuY2xhc3MgTWF0SGVhZGVyQ2VsbCBleHRlbmRzIENka0hlYWRlckNlbGwge1xufVxuTWF0SGVhZGVyQ2VsbC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdEhlYWRlckNlbGwsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuTWF0SGVhZGVyQ2VsbC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdEhlYWRlckNlbGwsIHNlbGVjdG9yOiBcIm1hdC1oZWFkZXItY2VsbCwgdGhbbWF0LWhlYWRlci1jZWxsXVwiLCBob3N0OiB7IGF0dHJpYnV0ZXM6IHsgXCJyb2xlXCI6IFwiY29sdW1uaGVhZGVyXCIgfSwgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LW1kYy1oZWFkZXItY2VsbCBtZGMtZGF0YS10YWJsZV9faGVhZGVyLWNlbGxcIiB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdEhlYWRlckNlbGwsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21hdC1oZWFkZXItY2VsbCwgdGhbbWF0LWhlYWRlci1jZWxsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYXQtbWRjLWhlYWRlci1jZWxsIG1kYy1kYXRhLXRhYmxlX19oZWFkZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdjb2x1bW5oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqIEZvb3RlciBjZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuICovXG5jbGFzcyBNYXRGb290ZXJDZWxsIGV4dGVuZHMgQ2RrRm9vdGVyQ2VsbCB7XG59XG5NYXRGb290ZXJDZWxsLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Rm9vdGVyQ2VsbCwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRGb290ZXJDZWxsLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0Rm9vdGVyQ2VsbCwgc2VsZWN0b3I6IFwibWF0LWZvb3Rlci1jZWxsLCB0ZFttYXQtZm9vdGVyLWNlbGxdXCIsIGhvc3Q6IHsgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LW1kYy1mb290ZXItY2VsbCBtZGMtZGF0YS10YWJsZV9fY2VsbFwiIH0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Rm9vdGVyQ2VsbCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LWZvb3Rlci1jZWxsLCB0ZFttYXQtZm9vdGVyLWNlbGxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1tZGMtZm9vdGVyLWNlbGwgbWRjLWRhdGEtdGFibGVfX2NlbGwnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqIENlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbmNsYXNzIE1hdENlbGwgZXh0ZW5kcyBDZGtDZWxsIHtcbn1cbk1hdENlbGwuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRDZWxsLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbk1hdENlbGwuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRDZWxsLCBzZWxlY3RvcjogXCJtYXQtY2VsbCwgdGRbbWF0LWNlbGxdXCIsIGhvc3Q6IHsgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LW1kYy1jZWxsIG1kYy1kYXRhLXRhYmxlX19jZWxsXCIgfSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRDZWxsLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdtYXQtY2VsbCwgdGRbbWF0LWNlbGxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1tZGMtY2VsbCBtZGMtZGF0YS10YWJsZV9fY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBIZWFkZXIgcm93IGRlZmluaXRpb24gZm9yIHRoZSBtYXQtdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgaGVhZGVyIHJvdydzIHRlbXBsYXRlIGFuZCBvdGhlciBoZWFkZXIgcHJvcGVydGllcyBzdWNoIGFzIHRoZSBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gKi9cbmNsYXNzIE1hdEhlYWRlclJvd0RlZiBleHRlbmRzIENka0hlYWRlclJvd0RlZiB7XG59XG5NYXRIZWFkZXJSb3dEZWYuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRIZWFkZXJSb3dEZWYsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuTWF0SGVhZGVyUm93RGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogTWF0SGVhZGVyUm93RGVmLCBzZWxlY3RvcjogXCJbbWF0SGVhZGVyUm93RGVmXVwiLCBpbnB1dHM6IHsgY29sdW1uczogW1wibWF0SGVhZGVyUm93RGVmXCIsIFwiY29sdW1uc1wiXSwgc3RpY2t5OiBbXCJtYXRIZWFkZXJSb3dEZWZTdGlja3lcIiwgXCJzdGlja3lcIl0gfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtIZWFkZXJSb3dEZWYsIHVzZUV4aXN0aW5nOiBNYXRIZWFkZXJSb3dEZWYgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0SGVhZGVyUm93RGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0SGVhZGVyUm93RGVmXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrSGVhZGVyUm93RGVmLCB1c2VFeGlzdGluZzogTWF0SGVhZGVyUm93RGVmIH1dLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sdW1uczogbWF0SGVhZGVyUm93RGVmJywgJ3N0aWNreTogbWF0SGVhZGVyUm93RGVmU3RpY2t5J10sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIEZvb3RlciByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIG1hdC10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBmb290ZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIGZvb3RlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xuY2xhc3MgTWF0Rm9vdGVyUm93RGVmIGV4dGVuZHMgQ2RrRm9vdGVyUm93RGVmIHtcbn1cbk1hdEZvb3RlclJvd0RlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdEZvb3RlclJvd0RlZiwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRGb290ZXJSb3dEZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRGb290ZXJSb3dEZWYsIHNlbGVjdG9yOiBcIlttYXRGb290ZXJSb3dEZWZdXCIsIGlucHV0czogeyBjb2x1bW5zOiBbXCJtYXRGb290ZXJSb3dEZWZcIiwgXCJjb2x1bW5zXCJdLCBzdGlja3k6IFtcIm1hdEZvb3RlclJvd0RlZlN0aWNreVwiLCBcInN0aWNreVwiXSB9LCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0Zvb3RlclJvd0RlZiwgdXNlRXhpc3Rpbmc6IE1hdEZvb3RlclJvd0RlZiB9XSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRGb290ZXJSb3dEZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttYXRGb290ZXJSb3dEZWZdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtGb290ZXJSb3dEZWYsIHVzZUV4aXN0aW5nOiBNYXRGb290ZXJSb3dEZWYgfV0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydjb2x1bW5zOiBtYXRGb290ZXJSb3dEZWYnLCAnc3RpY2t5OiBtYXRGb290ZXJSb3dEZWZTdGlja3knXSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogRGF0YSByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIG1hdC10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBkYXRhIHJvdydzIHRlbXBsYXRlIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheSBhbmRcbiAqIGEgd2hlbiBwcmVkaWNhdGUgdGhhdCBkZXNjcmliZXMgd2hlbiB0aGlzIHJvdyBzaG91bGQgYmUgdXNlZC5cbiAqL1xuY2xhc3MgTWF0Um93RGVmIGV4dGVuZHMgQ2RrUm93RGVmIHtcbn1cbk1hdFJvd0RlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdFJvd0RlZiwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXRSb3dEZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRSb3dEZWYsIHNlbGVjdG9yOiBcIlttYXRSb3dEZWZdXCIsIGlucHV0czogeyBjb2x1bW5zOiBbXCJtYXRSb3dEZWZDb2x1bW5zXCIsIFwiY29sdW1uc1wiXSwgd2hlbjogW1wibWF0Um93RGVmV2hlblwiLCBcIndoZW5cIl0gfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtSb3dEZWYsIHVzZUV4aXN0aW5nOiBNYXRSb3dEZWYgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Um93RGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWF0Um93RGVmXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrUm93RGVmLCB1c2VFeGlzdGluZzogTWF0Um93RGVmIH1dLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sdW1uczogbWF0Um93RGVmQ29sdW1ucycsICd3aGVuOiBtYXRSb3dEZWZXaGVuJ10sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKiogRm9vdGVyIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuICovXG5jbGFzcyBNYXRIZWFkZXJSb3cgZXh0ZW5kcyBDZGtIZWFkZXJSb3cge1xufVxuTWF0SGVhZGVyUm93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0SGVhZGVyUm93LCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdEhlYWRlclJvdy7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdEhlYWRlclJvdywgc2VsZWN0b3I6IFwibWF0LWhlYWRlci1yb3csIHRyW21hdC1oZWFkZXItcm93XVwiLCBob3N0OiB7IGF0dHJpYnV0ZXM6IHsgXCJyb2xlXCI6IFwicm93XCIgfSwgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LW1kYy1oZWFkZXItcm93IG1kYy1kYXRhLXRhYmxlX19oZWFkZXItcm93XCIgfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtIZWFkZXJSb3csIHVzZUV4aXN0aW5nOiBNYXRIZWFkZXJSb3cgfV0sIGV4cG9ydEFzOiBbXCJtYXRIZWFkZXJSb3dcIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogXCI8bmctY29udGFpbmVyIGNka0NlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+XCIsIGlzSW5saW5lOiB0cnVlLCBkZXBlbmRlbmNpZXM6IFt7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGkxLkNka0NlbGxPdXRsZXQsIHNlbGVjdG9yOiBcIltjZGtDZWxsT3V0bGV0XVwiIH1dLCBjaGFuZ2VEZXRlY3Rpb246IGkwLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsIGVuY2Fwc3VsYXRpb246IGkwLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRIZWFkZXJSb3csIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ21hdC1oZWFkZXItcm93LCB0clttYXQtaGVhZGVyLXJvd10nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1tZGMtaGVhZGVyLXJvdyBtZGMtZGF0YS10YWJsZV9faGVhZGVyLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgbm90ZSBvbiBDZGtUYWJsZSBmb3IgZXhwbGFuYXRpb24gb24gd2h5IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCBjaGFuZ2UgZGV0ZWN0aW9uIHN0cmF0ZWd5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFsaWRhdGUtZGVjb3JhdG9yc1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbWF0SGVhZGVyUm93JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtIZWFkZXJSb3csIHVzZUV4aXN0aW5nOiBNYXRIZWFkZXJSb3cgfV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKiogRm9vdGVyIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuICovXG5jbGFzcyBNYXRGb290ZXJSb3cgZXh0ZW5kcyBDZGtGb290ZXJSb3cge1xufVxuTWF0Rm9vdGVyUm93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Rm9vdGVyUm93LCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdEZvb3RlclJvdy7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdEZvb3RlclJvdywgc2VsZWN0b3I6IFwibWF0LWZvb3Rlci1yb3csIHRyW21hdC1mb290ZXItcm93XVwiLCBob3N0OiB7IGF0dHJpYnV0ZXM6IHsgXCJyb2xlXCI6IFwicm93XCIgfSwgY2xhc3NBdHRyaWJ1dGU6IFwibWF0LW1kYy1mb290ZXItcm93IG1kYy1kYXRhLXRhYmxlX19yb3dcIiB9LCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0Zvb3RlclJvdywgdXNlRXhpc3Rpbmc6IE1hdEZvb3RlclJvdyB9XSwgZXhwb3J0QXM6IFtcIm1hdEZvb3RlclJvd1wiXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBcIjxuZy1jb250YWluZXIgY2RrQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5cIiwgaXNJbmxpbmU6IHRydWUsIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTEuQ2RrQ2VsbE91dGxldCwgc2VsZWN0b3I6IFwiW2Nka0NlbGxPdXRsZXRdXCIgfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCwgZW5jYXBzdWxhdGlvbjogaTAuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdEZvb3RlclJvdywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LWZvb3Rlci1yb3csIHRyW21hdC1mb290ZXItcm93XScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBDREtfUk9XX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWF0LW1kYy1mb290ZXItcm93IG1kYy1kYXRhLXRhYmxlX19yb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIG5vdGUgb24gQ2RrVGFibGUgZm9yIGV4cGxhbmF0aW9uIG9uIHdoeSB0aGlzIHVzZXMgdGhlIGRlZmF1bHQgY2hhbmdlIGRldGVjdGlvbiBzdHJhdGVneS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhbGlkYXRlLWRlY29yYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21hdEZvb3RlclJvdycsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrRm9vdGVyUm93LCB1c2VFeGlzdGluZzogTWF0Rm9vdGVyUm93IH1dLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqIERhdGEgcm93IHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuICovXG5jbGFzcyBNYXRSb3cgZXh0ZW5kcyBDZGtSb3cge1xufVxuTWF0Um93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Um93LCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdFJvdy7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE1hdFJvdywgc2VsZWN0b3I6IFwibWF0LXJvdywgdHJbbWF0LXJvd11cIiwgaG9zdDogeyBhdHRyaWJ1dGVzOiB7IFwicm9sZVwiOiBcInJvd1wiIH0sIGNsYXNzQXR0cmlidXRlOiBcIm1hdC1tZGMtcm93IG1kYy1kYXRhLXRhYmxlX19yb3dcIiB9LCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka1JvdywgdXNlRXhpc3Rpbmc6IE1hdFJvdyB9XSwgZXhwb3J0QXM6IFtcIm1hdFJvd1wiXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBcIjxuZy1jb250YWluZXIgY2RrQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5cIiwgaXNJbmxpbmU6IHRydWUsIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTEuQ2RrQ2VsbE91dGxldCwgc2VsZWN0b3I6IFwiW2Nka0NlbGxPdXRsZXRdXCIgfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCwgZW5jYXBzdWxhdGlvbjogaTAuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdFJvdywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXJvdywgdHJbbWF0LXJvd10nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ21hdC1tZGMtcm93IG1kYy1kYXRhLXRhYmxlX19yb3cnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncm93JyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIG5vdGUgb24gQ2RrVGFibGUgZm9yIGV4cGxhbmF0aW9uIG9uIHdoeSB0aGlzIHVzZXMgdGhlIGRlZmF1bHQgY2hhbmdlIGRldGVjdGlvbiBzdHJhdGVneS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhbGlkYXRlLWRlY29yYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ21hdFJvdycsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrUm93LCB1c2VFeGlzdGluZzogTWF0Um93IH1dLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqIFJvdyB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgYSBtZXNzYWdlIHdoZW4gbm8gZGF0YSBpcyBzaG93biBpbiB0aGUgdGFibGUuICovXG5jbGFzcyBNYXROb0RhdGFSb3cgZXh0ZW5kcyBDZGtOb0RhdGFSb3cge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jb250ZW50Q2xhc3NOYW1lID0gJ21hdC1tZGMtbm8tZGF0YS1yb3cnO1xuICAgIH1cbn1cbk1hdE5vRGF0YVJvdy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdE5vRGF0YVJvdywgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5NYXROb0RhdGFSb3cuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXROb0RhdGFSb3csIHNlbGVjdG9yOiBcIm5nLXRlbXBsYXRlW21hdE5vRGF0YVJvd11cIiwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtOb0RhdGFSb3csIHVzZUV4aXN0aW5nOiBNYXROb0RhdGFSb3cgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0Tm9EYXRhUm93LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVttYXROb0RhdGFSb3ddJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtOb0RhdGFSb3csIHVzZUV4aXN0aW5nOiBNYXROb0RhdGFSb3cgfV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb2x1bW4gdGhhdCBzaW1wbHkgc2hvd3MgdGV4dCBjb250ZW50IGZvciB0aGUgaGVhZGVyIGFuZCByb3cgY2VsbHMuIEFzc3VtZXMgdGhhdCB0aGUgdGFibGVcbiAqIGlzIHVzaW5nIHRoZSBuYXRpdmUgdGFibGUgaW1wbGVtZW50YXRpb24gKGA8dGFibGU+YCkuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIG5hbWUgb2YgdGhpcyBjb2x1bW4gd2lsbCBiZSB0aGUgaGVhZGVyIHRleHQgYW5kIGRhdGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gKiBUaGUgaGVhZGVyIHRleHQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgYGhlYWRlclRleHRgIGlucHV0LiBDZWxsIHZhbHVlcyBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoXG4gKiB0aGUgYGRhdGFBY2Nlc3NvcmAgaW5wdXQuIENoYW5nZSB0aGUgdGV4dCBqdXN0aWZpY2F0aW9uIHRvIHRoZSBzdGFydCBvciBlbmQgdXNpbmcgdGhlIGBqdXN0aWZ5YFxuICogaW5wdXQuXG4gKi9cbmNsYXNzIE1hdFRleHRDb2x1bW4gZXh0ZW5kcyBDZGtUZXh0Q29sdW1uIHtcbn1cbk1hdFRleHRDb2x1bW4uybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXRUZXh0Q29sdW1uLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbk1hdFRleHRDb2x1bW4uybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBNYXRUZXh0Q29sdW1uLCBzZWxlY3RvcjogXCJtYXQtdGV4dC1jb2x1bW5cIiwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBtYXRDb2x1bW5EZWY+XG4gICAgICA8dGggbWF0LWhlYWRlci1jZWxsICptYXRIZWFkZXJDZWxsRGVmIFtzdHlsZS50ZXh0LWFsaWduXT1cImp1c3RpZnlcIj5cbiAgICAgICAge3toZWFkZXJUZXh0fX1cbiAgICAgIDwvdGg+XG4gICAgICA8dGQgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgZGF0YVwiIFtzdHlsZS50ZXh0LWFsaWduXT1cImp1c3RpZnlcIj5cbiAgICAgICAge3tkYXRhQWNjZXNzb3IoZGF0YSwgbmFtZSl9fVxuICAgICAgPC90ZD5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCwgaXNJbmxpbmU6IHRydWUsIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogTWF0SGVhZGVyQ2VsbERlZiwgc2VsZWN0b3I6IFwiW21hdEhlYWRlckNlbGxEZWZdXCIgfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBNYXRDb2x1bW5EZWYsIHNlbGVjdG9yOiBcIlttYXRDb2x1bW5EZWZdXCIsIGlucHV0czogW1wic3RpY2t5XCIsIFwibWF0Q29sdW1uRGVmXCJdIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogTWF0Q2VsbERlZiwgc2VsZWN0b3I6IFwiW21hdENlbGxEZWZdXCIgfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBNYXRIZWFkZXJDZWxsLCBzZWxlY3RvcjogXCJtYXQtaGVhZGVyLWNlbGwsIHRoW21hdC1oZWFkZXItY2VsbF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IE1hdENlbGwsIHNlbGVjdG9yOiBcIm1hdC1jZWxsLCB0ZFttYXQtY2VsbF1cIiB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0VGV4dENvbHVtbiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbWF0LXRleHQtY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj5cbiAgICAgIDx0aCBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWYgW3N0eWxlLnRleHQtYWxpZ25dPVwianVzdGlmeVwiPlxuICAgICAgICB7e2hlYWRlclRleHR9fVxuICAgICAgPC90aD5cbiAgICAgIDx0ZCBtYXQtY2VsbCAqbWF0Q2VsbERlZj1cImxldCBkYXRhXCIgW3N0eWxlLnRleHQtYWxpZ25dPVwianVzdGlmeVwiPlxuICAgICAgICB7e2RhdGFBY2Nlc3NvcihkYXRhLCBuYW1lKX19XG4gICAgICA8L3RkPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICAgICAgICAgICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgZGV0ZWN0aW9uIGlzIGludGVudGlvbmFsbHkgbm90IHNldCB0byBPblB1c2guIFRoaXMgY29tcG9uZW50J3MgdGVtcGxhdGUgd2lsbCBiZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0aGUgdGFibGUgdG8gYmUgaW5zZXJ0ZWQgaW50byBpdHMgdmlldy4gVGhpcyBpcyBwcm9ibGVtYXRpYyB3aGVuIGNoYW5nZSBkZXRlY3Rpb24gcnVucyBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYmluZGluZ3MgaW4gdGhpcyB0ZW1wbGF0ZSB3aWxsIGJlIGV2YWx1YXRlZCBfYWZ0ZXJfIHRoZSB0YWJsZSdzIHZpZXcgaXMgZXZhbHVhdGVkLCB3aGljaFxuICAgICAgICAgICAgICAgICAgICAvLyBtZWFuJ3MgdGhlIHRlbXBsYXRlIGluIHRoZSB0YWJsZSdzIHZpZXcgd2lsbCBub3QgaGF2ZSB0aGUgdXBkYXRlZCB2YWx1ZSAoYW5kIGluIGZhY3Qgd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBhbiBFeHByZXNzaW9uQ2hhbmdlZEFmdGVySXRIYXNCZWVuQ2hlY2tlZEVycm9yKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhbGlkYXRlLWRlY29yYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNvbnN0IEVYUE9SVEVEX0RFQ0xBUkFUSU9OUyA9IFtcbiAgICAvLyBUYWJsZVxuICAgIE1hdFRhYmxlLFxuICAgIE1hdFJlY3ljbGVSb3dzLFxuICAgIC8vIFRlbXBsYXRlIGRlZnNcbiAgICBNYXRIZWFkZXJDZWxsRGVmLFxuICAgIE1hdEhlYWRlclJvd0RlZixcbiAgICBNYXRDb2x1bW5EZWYsXG4gICAgTWF0Q2VsbERlZixcbiAgICBNYXRSb3dEZWYsXG4gICAgTWF0Rm9vdGVyQ2VsbERlZixcbiAgICBNYXRGb290ZXJSb3dEZWYsXG4gICAgLy8gQ2VsbCBkaXJlY3RpdmVzXG4gICAgTWF0SGVhZGVyQ2VsbCxcbiAgICBNYXRDZWxsLFxuICAgIE1hdEZvb3RlckNlbGwsXG4gICAgLy8gUm93IGRpcmVjdGl2ZXNcbiAgICBNYXRIZWFkZXJSb3csXG4gICAgTWF0Um93LFxuICAgIE1hdEZvb3RlclJvdyxcbiAgICBNYXROb0RhdGFSb3csXG4gICAgTWF0VGV4dENvbHVtbixcbl07XG5jbGFzcyBNYXRUYWJsZU1vZHVsZSB7XG59XG5NYXRUYWJsZU1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdFRhYmxlTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbk1hdFRhYmxlTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1hdFRhYmxlTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgLy8gVGFibGVcbiAgICAgICAgTWF0VGFibGUsXG4gICAgICAgIE1hdFJlY3ljbGVSb3dzLFxuICAgICAgICAvLyBUZW1wbGF0ZSBkZWZzXG4gICAgICAgIE1hdEhlYWRlckNlbGxEZWYsXG4gICAgICAgIE1hdEhlYWRlclJvd0RlZixcbiAgICAgICAgTWF0Q29sdW1uRGVmLFxuICAgICAgICBNYXRDZWxsRGVmLFxuICAgICAgICBNYXRSb3dEZWYsXG4gICAgICAgIE1hdEZvb3RlckNlbGxEZWYsXG4gICAgICAgIE1hdEZvb3RlclJvd0RlZixcbiAgICAgICAgLy8gQ2VsbCBkaXJlY3RpdmVzXG4gICAgICAgIE1hdEhlYWRlckNlbGwsXG4gICAgICAgIE1hdENlbGwsXG4gICAgICAgIE1hdEZvb3RlckNlbGwsXG4gICAgICAgIC8vIFJvdyBkaXJlY3RpdmVzXG4gICAgICAgIE1hdEhlYWRlclJvdyxcbiAgICAgICAgTWF0Um93LFxuICAgICAgICBNYXRGb290ZXJSb3csXG4gICAgICAgIE1hdE5vRGF0YVJvdyxcbiAgICAgICAgTWF0VGV4dENvbHVtbl0sIGltcG9ydHM6IFtNYXRDb21tb25Nb2R1bGUsIENka1RhYmxlTW9kdWxlXSwgZXhwb3J0czogW01hdENvbW1vbk1vZHVsZSwgXG4gICAgICAgIC8vIFRhYmxlXG4gICAgICAgIE1hdFRhYmxlLFxuICAgICAgICBNYXRSZWN5Y2xlUm93cyxcbiAgICAgICAgLy8gVGVtcGxhdGUgZGVmc1xuICAgICAgICBNYXRIZWFkZXJDZWxsRGVmLFxuICAgICAgICBNYXRIZWFkZXJSb3dEZWYsXG4gICAgICAgIE1hdENvbHVtbkRlZixcbiAgICAgICAgTWF0Q2VsbERlZixcbiAgICAgICAgTWF0Um93RGVmLFxuICAgICAgICBNYXRGb290ZXJDZWxsRGVmLFxuICAgICAgICBNYXRGb290ZXJSb3dEZWYsXG4gICAgICAgIC8vIENlbGwgZGlyZWN0aXZlc1xuICAgICAgICBNYXRIZWFkZXJDZWxsLFxuICAgICAgICBNYXRDZWxsLFxuICAgICAgICBNYXRGb290ZXJDZWxsLFxuICAgICAgICAvLyBSb3cgZGlyZWN0aXZlc1xuICAgICAgICBNYXRIZWFkZXJSb3csXG4gICAgICAgIE1hdFJvdyxcbiAgICAgICAgTWF0Rm9vdGVyUm93LFxuICAgICAgICBNYXROb0RhdGFSb3csXG4gICAgICAgIE1hdFRleHRDb2x1bW5dIH0pO1xuTWF0VGFibGVNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0VGFibGVNb2R1bGUsIGltcG9ydHM6IFtNYXRDb21tb25Nb2R1bGUsIENka1RhYmxlTW9kdWxlLCBNYXRDb21tb25Nb2R1bGVdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF0VGFibGVNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtNYXRDb21tb25Nb2R1bGUsIENka1RhYmxlTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW01hdENvbW1vbk1vZHVsZSwgRVhQT1JURURfREVDTEFSQVRJT05TXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBFWFBPUlRFRF9ERUNMQVJBVElPTlMsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb3JyZXNwb25kcyB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLiBNb3ZlZCBvdXQgaW50byBhIHZhcmlhYmxlIGhlcmUgZHVlIHRvXG4gKiBmbGFreSBicm93c2VyIHN1cHBvcnQgYW5kIHRoZSB2YWx1ZSBub3QgYmVpbmcgZGVmaW5lZCBpbiBDbG9zdXJlJ3MgdHlwaW5ncy5cbiAqL1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG4vKiogU2hhcmVkIGJhc2UgY2xhc3Mgd2l0aCBNREMtYmFzZWQgaW1wbGVtZW50YXRpb24uICovXG5jbGFzcyBfTWF0VGFibGVEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XG4gICAgLyoqIEFycmF5IG9mIGRhdGEgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYnkgdGhlIHRhYmxlLCB3aGVyZSBlYWNoIG9iamVjdCByZXByZXNlbnRzIG9uZSByb3cuICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnZhbHVlO1xuICAgIH1cbiAgICBzZXQgZGF0YShkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtdO1xuICAgICAgICB0aGlzLl9kYXRhLm5leHQoZGF0YSk7XG4gICAgICAgIC8vIE5vcm1hbGx5IHRoZSBgZmlsdGVyZWREYXRhYCBpcyB1cGRhdGVkIGJ5IHRoZSByZS1yZW5kZXJcbiAgICAgICAgLy8gc3Vic2NyaXB0aW9uLCBidXQgdGhhdCB3b24ndCBoYXBwZW4gaWYgaXQncyBpbmFjdGl2ZS5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJDaGFuZ2VzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJEYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlciB0ZXJtIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZmlsdGVyIG91dCBvYmplY3RzIGZyb20gdGhlIGRhdGEgYXJyYXkuIFRvIG92ZXJyaWRlIGhvd1xuICAgICAqIGRhdGEgb2JqZWN0cyBtYXRjaCB0byB0aGlzIGZpbHRlciBzdHJpbmcsIHByb3ZpZGUgYSBjdXN0b20gZnVuY3Rpb24gZm9yIGZpbHRlclByZWRpY2F0ZS5cbiAgICAgKi9cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyLnZhbHVlO1xuICAgIH1cbiAgICBzZXQgZmlsdGVyKGZpbHRlcikge1xuICAgICAgICB0aGlzLl9maWx0ZXIubmV4dChmaWx0ZXIpO1xuICAgICAgICAvLyBOb3JtYWxseSB0aGUgYGZpbHRlcmVkRGF0YWAgaXMgdXBkYXRlZCBieSB0aGUgcmUtcmVuZGVyXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvbiwgYnV0IHRoYXQgd29uJ3QgaGFwcGVuIGlmIGl0J3MgaW5hY3RpdmUuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyQ2hhbmdlc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyRGF0YSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbmNlIG9mIHRoZSBNYXRTb3J0IGRpcmVjdGl2ZSB1c2VkIGJ5IHRoZSB0YWJsZSB0byBjb250cm9sIGl0cyBzb3J0aW5nLiBTb3J0IGNoYW5nZXNcbiAgICAgKiBlbWl0dGVkIGJ5IHRoZSBNYXRTb3J0IHdpbGwgdHJpZ2dlciBhbiB1cGRhdGUgdG8gdGhlIHRhYmxlJ3MgcmVuZGVyZWQgZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgc29ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnQ7XG4gICAgfVxuICAgIHNldCBzb3J0KHNvcnQpIHtcbiAgICAgICAgdGhpcy5fc29ydCA9IHNvcnQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZSBvZiB0aGUgcGFnaW5hdG9yIGNvbXBvbmVudCB1c2VkIGJ5IHRoZSB0YWJsZSB0byBjb250cm9sIHdoYXQgcGFnZSBvZiB0aGUgZGF0YSBpc1xuICAgICAqIGRpc3BsYXllZC4gUGFnZSBjaGFuZ2VzIGVtaXR0ZWQgYnkgdGhlIHBhZ2luYXRvciB3aWxsIHRyaWdnZXIgYW4gdXBkYXRlIHRvIHRoZVxuICAgICAqIHRhYmxlJ3MgcmVuZGVyZWQgZGF0YS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGUgZGF0YSBzb3VyY2UgdXNlcyB0aGUgcGFnaW5hdG9yJ3MgcHJvcGVydGllcyB0byBjYWxjdWxhdGUgd2hpY2ggcGFnZSBvZiBkYXRhXG4gICAgICogc2hvdWxkIGJlIGRpc3BsYXllZC4gSWYgdGhlIHBhZ2luYXRvciByZWNlaXZlcyBpdHMgcHJvcGVydGllcyBhcyB0ZW1wbGF0ZSBpbnB1dHMsXG4gICAgICogZS5nLiBgW3BhZ2VMZW5ndGhdPTEwMGAgb3IgYFtwYWdlSW5kZXhdPTFgLCB0aGVuIGJlIHN1cmUgdGhhdCB0aGUgcGFnaW5hdG9yJ3MgdmlldyBoYXMgYmVlblxuICAgICAqIGluaXRpYWxpemVkIGJlZm9yZSBhc3NpZ25pbmcgaXQgdG8gdGhpcyBkYXRhIHNvdXJjZS5cbiAgICAgKi9cbiAgICBnZXQgcGFnaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnaW5hdG9yO1xuICAgIH1cbiAgICBzZXQgcGFnaW5hdG9yKHBhZ2luYXRvcikge1xuICAgICAgICB0aGlzLl9wYWdpbmF0b3IgPSBwYWdpbmF0b3I7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsRGF0YSA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKiBTdHJlYW0gZW1pdHRpbmcgcmVuZGVyIGRhdGEgdG8gdGhlIHRhYmxlIChkZXBlbmRzIG9uIG9yZGVyZWQgZGF0YSBjaGFuZ2VzKS4gKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyRGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3QoW10pO1xuICAgICAgICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBhIG5ldyBmaWx0ZXIgc3RyaW5nIGlzIHNldCBvbiB0aGUgZGF0YSBzb3VyY2UuICovXG4gICAgICAgIHRoaXMuX2ZpbHRlciA9IG5ldyBCZWhhdmlvclN1YmplY3QoJycpO1xuICAgICAgICAvKiogVXNlZCB0byByZWFjdCB0byBpbnRlcm5hbCBjaGFuZ2VzIG9mIHRoZSBwYWdpbmF0b3IgdGhhdCBhcmUgbWFkZSBieSB0aGUgZGF0YSBzb3VyY2UgaXRzZWxmLiAqL1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhZ2VDaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgY2hhbmdlcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSB0byB0aGUgdGFibGUncyByZW5kZXJlZCByb3dzLCBzdWNoXG4gICAgICAgICAqIGFzIGZpbHRlcmluZywgc29ydGluZywgcGFnaW5hdGlvbiwgb3IgYmFzZSBkYXRhIGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFuZ2VzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGEgYWNjZXNzb3IgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIGZvciBhY2Nlc3NpbmcgZGF0YSBwcm9wZXJ0aWVzIGZvciBzb3J0aW5nIHRocm91Z2hcbiAgICAgICAgICogdGhlIGRlZmF1bHQgc29ydERhdGEgZnVuY3Rpb24uXG4gICAgICAgICAqIFRoaXMgZGVmYXVsdCBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHNvcnQgaGVhZGVyIElEcyAod2hpY2ggZGVmYXVsdHMgdG8gdGhlIGNvbHVtbiBuYW1lKVxuICAgICAgICAgKiBtYXRjaGVzIHRoZSBkYXRhJ3MgcHJvcGVydGllcyAoZS5nLiBjb2x1bW4gWHl6IHJlcHJlc2VudHMgZGF0YVsnWHl6J10pLlxuICAgICAgICAgKiBNYXkgYmUgc2V0IHRvIGEgY3VzdG9tIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgYmVoYXZpb3IuXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0IHRoYXQgaXMgYmVpbmcgYWNjZXNzZWQuXG4gICAgICAgICAqIEBwYXJhbSBzb3J0SGVhZGVySWQgVGhlIG5hbWUgb2YgdGhlIGNvbHVtbiB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRpbmdEYXRhQWNjZXNzb3IgPSAoZGF0YSwgc29ydEhlYWRlcklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFbc29ydEhlYWRlcklkXTtcbiAgICAgICAgICAgIGlmIChfaXNOdW1iZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXJWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gTnVtYmVycyBiZXlvbmQgYE1BWF9TQUZFX0lOVEVHRVJgIGNhbid0IGJlIGNvbXBhcmVkIHJlbGlhYmx5IHNvIHdlXG4gICAgICAgICAgICAgICAgLy8gbGVhdmUgdGhlbSBhcyBzdHJpbmdzLiBGb3IgbW9yZSBpbmZvOiBodHRwczovL2dvby5nbC95NXZiU2dcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyVmFsdWUgPCBNQVhfU0FGRV9JTlRFR0VSID8gbnVtYmVyVmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSBzb3J0ZWQgY29weSBvZiB0aGUgZGF0YSBhcnJheSBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIE1hdFNvcnQuIENhbGxlZFxuICAgICAgICAgKiBhZnRlciBjaGFuZ2VzIGFyZSBtYWRlIHRvIHRoZSBmaWx0ZXJlZCBkYXRhIG9yIHdoZW4gc29ydCBjaGFuZ2VzIGFyZSBlbWl0dGVkIGZyb20gTWF0U29ydC5cbiAgICAgICAgICogQnkgZGVmYXVsdCwgdGhlIGZ1bmN0aW9uIHJldHJpZXZlcyB0aGUgYWN0aXZlIHNvcnQgYW5kIGl0cyBkaXJlY3Rpb24gYW5kIGNvbXBhcmVzIGRhdGFcbiAgICAgICAgICogYnkgcmV0cmlldmluZyBkYXRhIHVzaW5nIHRoZSBzb3J0aW5nRGF0YUFjY2Vzc29yLiBNYXkgYmUgb3ZlcnJpZGRlbiBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgICAgICogb2YgZGF0YSBvcmRlcmluZy5cbiAgICAgICAgICogQHBhcmFtIGRhdGEgVGhlIGFycmF5IG9mIGRhdGEgdGhhdCBzaG91bGQgYmUgc29ydGVkLlxuICAgICAgICAgKiBAcGFyYW0gc29ydCBUaGUgY29ubmVjdGVkIE1hdFNvcnQgdGhhdCBob2xkcyB0aGUgY3VycmVudCBzb3J0IHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0RGF0YSA9IChkYXRhLCBzb3J0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSBzb3J0LmFjdGl2ZTtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHNvcnQuZGlyZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCFhY3RpdmUgfHwgZGlyZWN0aW9uID09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlQSA9IHRoaXMuc29ydGluZ0RhdGFBY2Nlc3NvcihhLCBhY3RpdmUpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUIgPSB0aGlzLnNvcnRpbmdEYXRhQWNjZXNzb3IoYiwgYWN0aXZlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgZGF0YSBpbiB0aGUgY29sdW1uIHRoYXQgY2FuIGJlIGNvbnZlcnRlZCB0byBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBpdCBtdXN0IGJlIGVuc3VyZWQgdGhhdCB0aGUgcmVzdCBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIC8vIGlzIG9mIHRoZSBzYW1lIHR5cGUgc28gYXMgbm90IHRvIG9yZGVyIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQVR5cGUgPSB0eXBlb2YgdmFsdWVBO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQlR5cGUgPSB0eXBlb2YgdmFsdWVCO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFUeXBlICE9PSB2YWx1ZUJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVBICs9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUJUeXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVCICs9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggdmFsdWVBIGFuZCB2YWx1ZUIgZXhpc3QgKHRydXRoeSksIHRoZW4gY29tcGFyZSB0aGUgdHdvLiBPdGhlcndpc2UsIGNoZWNrIGlmXG4gICAgICAgICAgICAgICAgLy8gb25lIHZhbHVlIGV4aXN0cyB3aGlsZSB0aGUgb3RoZXIgZG9lc24ndC4gSW4gdGhpcyBjYXNlLCBleGlzdGluZyB2YWx1ZSBzaG91bGQgY29tZSBsYXN0LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIGluY29uc2lzdGVudCByZXN1bHRzIHdoZW4gY29tcGFyaW5nIHZhbHVlcyB0byB1bmRlZmluZWQvbnVsbC5cbiAgICAgICAgICAgICAgICAvLyBJZiBuZWl0aGVyIHZhbHVlIGV4aXN0cywgcmV0dXJuIDAgKGVxdWFsKS5cbiAgICAgICAgICAgICAgICBsZXQgY29tcGFyYXRvclJlc3VsdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlQSAhPSBudWxsICYmIHZhbHVlQiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIG9uZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIG90aGVyOyBpZiBlcXVhbCwgY29tcGFyYXRvclJlc3VsdCBzaG91bGQgcmVtYWluIDAuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUEgPiB2YWx1ZUIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBhcmF0b3JSZXN1bHQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlQSA8IHZhbHVlQikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyYXRvclJlc3VsdCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlQSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBhcmF0b3JSZXN1bHQgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZUIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wYXJhdG9yUmVzdWx0ID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yUmVzdWx0ICogKGRpcmVjdGlvbiA9PSAnYXNjJyA/IDEgOiAtMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBpZiBhIGRhdGEgb2JqZWN0IG1hdGNoZXMgdGhlIGRhdGEgc291cmNlJ3MgZmlsdGVyIHN0cmluZy4gQnkgZGVmYXVsdCwgZWFjaCBkYXRhIG9iamVjdFxuICAgICAgICAgKiBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgaXRzIHByb3BlcnRpZXMgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsdGVyIGhhc1xuICAgICAgICAgKiBhdCBsZWFzdCBvbmUgb2NjdXJyZW5jZSBpbiB0aGF0IHN0cmluZy4gQnkgZGVmYXVsdCwgdGhlIGZpbHRlciBzdHJpbmcgaGFzIGl0cyB3aGl0ZXNwYWNlXG4gICAgICAgICAqIHRyaW1tZWQgYW5kIHRoZSBtYXRjaCBpcyBjYXNlLWluc2Vuc2l0aXZlLiBNYXkgYmUgb3ZlcnJpZGRlbiBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgICAgICogZmlsdGVyIG1hdGNoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdCB1c2VkIHRvIGNoZWNrIGFnYWluc3QgdGhlIGZpbHRlci5cbiAgICAgICAgICogQHBhcmFtIGZpbHRlciBGaWx0ZXIgc3RyaW5nIHRoYXQgaGFzIGJlZW4gc2V0IG9uIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZmlsdGVyIG1hdGNoZXMgYWdhaW5zdCB0aGUgZGF0YVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJQcmVkaWNhdGUgPSAoZGF0YSwgZmlsdGVyKSA9PiB7XG4gICAgICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIGRhdGEgaW50byBhIGxvd2VyY2FzZSBzdHJpbmcgb2YgYWxsIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgICAgICAgIGNvbnN0IGRhdGFTdHIgPSBPYmplY3Qua2V5cyhkYXRhKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGN1cnJlbnRUZXJtLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYW4gb2JzY3VyZSBVbmljb2RlIGNoYXJhY3RlciB0byBkZWxpbWl0IHRoZSB3b3JkcyBpbiB0aGUgY29uY2F0ZW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBtYXRjaGVzIHdoZXJlIHRoZSB2YWx1ZXMgb2YgdHdvIGNvbHVtbnMgY29tYmluZWQgd2lsbCBtYXRjaCB0aGUgdXNlcidzIHF1ZXJ5XG4gICAgICAgICAgICAgICAgLy8gKGUuZy4gYEZsdXRlYCBhbmQgYFN0b3BgIHdpbGwgbWF0Y2ggYFRlc3RgKS4gVGhlIGNoYXJhY3RlciBpcyBpbnRlbmRlZCB0byBiZSBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGhhcyBhIHZlcnkgbG93IGNoYW5jZSBvZiBiZWluZyB0eXBlZCBpbiBieSBzb21lYm9keSBpbiBhIHRleHQgZmllbGQuIFRoaXMgb25lIGluXG4gICAgICAgICAgICAgICAgLy8gcGFydGljdWxhciBpcyBcIldoaXRlIHVwLXBvaW50aW5nIHRyaWFuZ2xlIHdpdGggZG90XCIgZnJvbVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRUZXJtICsgZGF0YVtrZXldICsgJ+KXrCc7XG4gICAgICAgICAgICB9LCAnJylcbiAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgZmlsdGVyIGJ5IGNvbnZlcnRpbmcgaXQgdG8gbG93ZXJjYXNlIGFuZCByZW1vdmluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRGaWx0ZXIgPSBmaWx0ZXIudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVN0ci5pbmRleE9mKHRyYW5zZm9ybWVkRmlsdGVyKSAhPSAtMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBCZWhhdmlvclN1YmplY3QoaW5pdGlhbERhdGEpO1xuICAgICAgICB0aGlzLl91cGRhdGVDaGFuZ2VTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGNoYW5nZXMgdGhhdCBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgdG8gdGhlIHRhYmxlJ3MgcmVuZGVyZWQgcm93cy4gV2hlbiB0aGVcbiAgICAgKiBjaGFuZ2VzIG9jY3VyLCBwcm9jZXNzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmaWx0ZXIsIHNvcnQsIGFuZCBwYWdpbmF0aW9uIGFsb25nIHdpdGhcbiAgICAgKiB0aGUgcHJvdmlkZWQgYmFzZSBkYXRhIGFuZCBzZW5kIGl0IHRvIHRoZSB0YWJsZSBmb3IgcmVuZGVyaW5nLlxuICAgICAqL1xuICAgIF91cGRhdGVDaGFuZ2VTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIC8vIFNvcnRpbmcgYW5kL29yIHBhZ2luYXRpb24gc2hvdWxkIGJlIHdhdGNoZWQgaWYgc29ydCBhbmQvb3IgcGFnaW5hdG9yIGFyZSBwcm92aWRlZC5cbiAgICAgICAgLy8gVGhlIGV2ZW50cyBzaG91bGQgZW1pdCB3aGVuZXZlciB0aGUgY29tcG9uZW50IGVtaXRzIGEgY2hhbmdlIG9yIGluaXRpYWxpemVzLCBvciBpZiBub1xuICAgICAgICAvLyBjb21wb25lbnQgaXMgcHJvdmlkZWQsIGEgc3RyZWFtIHdpdGgganVzdCBhIG51bGwgZXZlbnQgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAgICAgICAvLyBUaGUgYHNvcnRDaGFuZ2VgIGFuZCBgcGFnZUNoYW5nZWAgYWN0cyBhcyBhIHNpZ25hbCB0byB0aGUgY29tYmluZUxhdGVzdHMgYmVsb3cgc28gdGhhdCB0aGVcbiAgICAgICAgLy8gcGlwZWxpbmUgY2FuIHByb2dyZXNzIHRvIHRoZSBuZXh0IHN0ZXAuIE5vdGUgdGhhdCB0aGUgdmFsdWUgZnJvbSB0aGVzZSBzdHJlYW1zIGFyZSBub3QgdXNlZCxcbiAgICAgICAgLy8gdGhleSBwdXJlbHkgYWN0IGFzIGEgc2lnbmFsIHRvIHByb2dyZXNzIGluIHRoZSBwaXBlbGluZS5cbiAgICAgICAgY29uc3Qgc29ydENoYW5nZSA9IHRoaXMuX3NvcnRcbiAgICAgICAgICAgID8gbWVyZ2UodGhpcy5fc29ydC5zb3J0Q2hhbmdlLCB0aGlzLl9zb3J0LmluaXRpYWxpemVkKVxuICAgICAgICAgICAgOiBvZihudWxsKTtcbiAgICAgICAgY29uc3QgcGFnZUNoYW5nZSA9IHRoaXMuX3BhZ2luYXRvclxuICAgICAgICAgICAgPyBtZXJnZSh0aGlzLl9wYWdpbmF0b3IucGFnZSwgdGhpcy5faW50ZXJuYWxQYWdlQ2hhbmdlcywgdGhpcy5fcGFnaW5hdG9yLmluaXRpYWxpemVkKVxuICAgICAgICAgICAgOiBvZihudWxsKTtcbiAgICAgICAgY29uc3QgZGF0YVN0cmVhbSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIC8vIFdhdGNoIGZvciBiYXNlIGRhdGEgb3IgZmlsdGVyIGNoYW5nZXMgdG8gcHJvdmlkZSBhIGZpbHRlcmVkIHNldCBvZiBkYXRhLlxuICAgICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBjb21iaW5lTGF0ZXN0KFtkYXRhU3RyZWFtLCB0aGlzLl9maWx0ZXJdKS5waXBlKG1hcCgoW2RhdGFdKSA9PiB0aGlzLl9maWx0ZXJEYXRhKGRhdGEpKSk7XG4gICAgICAgIC8vIFdhdGNoIGZvciBmaWx0ZXJlZCBkYXRhIG9yIHNvcnQgY2hhbmdlcyB0byBwcm92aWRlIGFuIG9yZGVyZWQgc2V0IG9mIGRhdGEuXG4gICAgICAgIGNvbnN0IG9yZGVyZWREYXRhID0gY29tYmluZUxhdGVzdChbZmlsdGVyZWREYXRhLCBzb3J0Q2hhbmdlXSkucGlwZShtYXAoKFtkYXRhXSkgPT4gdGhpcy5fb3JkZXJEYXRhKGRhdGEpKSk7XG4gICAgICAgIC8vIFdhdGNoIGZvciBvcmRlcmVkIGRhdGEgb3IgcGFnZSBjaGFuZ2VzIHRvIHByb3ZpZGUgYSBwYWdlZCBzZXQgb2YgZGF0YS5cbiAgICAgICAgY29uc3QgcGFnaW5hdGVkRGF0YSA9IGNvbWJpbmVMYXRlc3QoW29yZGVyZWREYXRhLCBwYWdlQ2hhbmdlXSkucGlwZShtYXAoKFtkYXRhXSkgPT4gdGhpcy5fcGFnZURhdGEoZGF0YSkpKTtcbiAgICAgICAgLy8gV2F0Y2hlZCBmb3IgcGFnZWQgZGF0YSBjaGFuZ2VzIGFuZCBzZW5kIHRoZSByZXN1bHQgdG8gdGhlIHRhYmxlIHRvIHJlbmRlci5cbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IHBhZ2luYXRlZERhdGEuc3Vic2NyaWJlKGRhdGEgPT4gdGhpcy5fcmVuZGVyRGF0YS5uZXh0KGRhdGEpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZpbHRlcmVkIGRhdGEgYXJyYXkgd2hlcmUgZWFjaCBmaWx0ZXIgb2JqZWN0IGNvbnRhaW5zIHRoZSBmaWx0ZXIgc3RyaW5nIHdpdGhpblxuICAgICAqIHRoZSByZXN1bHQgb2YgdGhlIGZpbHRlclByZWRpY2F0ZSBmdW5jdGlvbi4gSWYgbm8gZmlsdGVyIGlzIHNldCwgcmV0dXJucyB0aGUgZGF0YSBhcnJheVxuICAgICAqIGFzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIF9maWx0ZXJEYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBmaWx0ZXIgc3RyaW5nLCBmaWx0ZXIgb3V0IGRhdGEgdGhhdCBkb2VzIG5vdCBjb250YWluIGl0LlxuICAgICAgICAvLyBFYWNoIGRhdGEgb2JqZWN0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyB1c2luZyB0aGUgZnVuY3Rpb24gZGVmaW5lZCBieSBmaWx0ZXJQcmVkaWNhdGUuXG4gICAgICAgIC8vIE1heSBiZSBvdmVycmlkZGVuIGZvciBjdXN0b21pemF0aW9uLlxuICAgICAgICB0aGlzLmZpbHRlcmVkRGF0YSA9XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9PSBudWxsIHx8IHRoaXMuZmlsdGVyID09PSAnJ1xuICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgIDogZGF0YS5maWx0ZXIob2JqID0+IHRoaXMuZmlsdGVyUHJlZGljYXRlKG9iaiwgdGhpcy5maWx0ZXIpKTtcbiAgICAgICAgaWYgKHRoaXMucGFnaW5hdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQYWdpbmF0b3IodGhpcy5maWx0ZXJlZERhdGEubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzb3J0ZWQgY29weSBvZiB0aGUgZGF0YSBpZiBNYXRTb3J0IGhhcyBhIHNvcnQgYXBwbGllZCwgb3RoZXJ3aXNlIGp1c3QgcmV0dXJucyB0aGVcbiAgICAgKiBkYXRhIGFycmF5IGFzIHByb3ZpZGVkLiBVc2VzIHRoZSBkZWZhdWx0IGRhdGEgYWNjZXNzb3IgZm9yIGRhdGEgbG9va3VwLCB1bmxlc3MgYVxuICAgICAqIHNvcnREYXRhQWNjZXNzb3IgZnVuY3Rpb24gaXMgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBfb3JkZXJEYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYWN0aXZlIHNvcnQgb3IgZGlyZWN0aW9uLCByZXR1cm4gdGhlIGRhdGEgd2l0aG91dCB0cnlpbmcgdG8gc29ydC5cbiAgICAgICAgaWYgKCF0aGlzLnNvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnREYXRhKGRhdGEuc2xpY2UoKSwgdGhpcy5zb3J0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHBhZ2VkIHNsaWNlIG9mIHRoZSBwcm92aWRlZCBkYXRhIGFycmF5IGFjY29yZGluZyB0byB0aGUgcHJvdmlkZWQgcGFnaW5hdG9yJ3MgcGFnZVxuICAgICAqIGluZGV4IGFuZCBsZW5ndGguIElmIHRoZXJlIGlzIG5vIHBhZ2luYXRvciBwcm92aWRlZCwgcmV0dXJucyB0aGUgZGF0YSBhcnJheSBhcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBfcGFnZURhdGEoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMucGFnaW5hdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy5wYWdpbmF0b3IucGFnZUluZGV4ICogdGhpcy5wYWdpbmF0b3IucGFnZVNpemU7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0SW5kZXgsIHN0YXJ0SW5kZXggKyB0aGlzLnBhZ2luYXRvci5wYWdlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBhZ2luYXRvciB0byByZWZsZWN0IHRoZSBsZW5ndGggb2YgdGhlIGZpbHRlcmVkIGRhdGEsIGFuZCBtYWtlcyBzdXJlIHRoYXQgdGhlIHBhZ2VcbiAgICAgKiBpbmRleCBkb2VzIG5vdCBleGNlZWQgdGhlIHBhZ2luYXRvcidzIGxhc3QgcGFnZS4gVmFsdWVzIGFyZSBjaGFuZ2VkIGluIGEgcmVzb2x2ZWQgcHJvbWlzZSB0b1xuICAgICAqIGd1YXJkIGFnYWluc3QgbWFraW5nIHByb3BlcnR5IGNoYW5nZXMgd2l0aGluIGEgcm91bmQgb2YgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgKi9cbiAgICBfdXBkYXRlUGFnaW5hdG9yKGZpbHRlcmVkRGF0YUxlbmd0aCkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRvciA9IHRoaXMucGFnaW5hdG9yO1xuICAgICAgICAgICAgaWYgKCFwYWdpbmF0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWdpbmF0b3IubGVuZ3RoID0gZmlsdGVyZWREYXRhTGVuZ3RoO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBhZ2UgaW5kZXggaXMgc2V0IGJleW9uZCB0aGUgcGFnZSwgcmVkdWNlIGl0IHRvIHRoZSBsYXN0IHBhZ2UuXG4gICAgICAgICAgICBpZiAocGFnaW5hdG9yLnBhZ2VJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFnZUluZGV4ID0gTWF0aC5jZWlsKHBhZ2luYXRvci5sZW5ndGggLyBwYWdpbmF0b3IucGFnZVNpemUpIC0gMSB8fCAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhZ2VJbmRleCA9IE1hdGgubWluKHBhZ2luYXRvci5wYWdlSW5kZXgsIGxhc3RQYWdlSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdQYWdlSW5kZXggIT09IHBhZ2luYXRvci5wYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdG9yLnBhZ2VJbmRleCA9IG5ld1BhZ2VJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIHBhZ2luYXRvciBvbmx5IGVtaXRzIGFmdGVyIHVzZXItZ2VuZXJhdGVkIGNoYW5nZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgb3VyIG93biBzdHJlYW0gc28gd2Uga25vdyB0byBzaG91bGQgcmUtcmVuZGVyIHRoZSBkYXRhLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbFBhZ2VDaGFuZ2VzLm5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRoZSBNYXRUYWJsZS4gQ2FsbGVkIHdoZW4gaXQgY29ubmVjdHMgdG8gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlckNoYW5nZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRoZSBNYXRUYWJsZS4gQ2FsbGVkIHdoZW4gaXQgZGlzY29ubmVjdHMgZnJvbSB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYW5nZXNTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckNoYW5nZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogRGF0YSBzb3VyY2UgdGhhdCBhY2NlcHRzIGEgY2xpZW50LXNpZGUgZGF0YSBhcnJheSBhbmQgaW5jbHVkZXMgbmF0aXZlIHN1cHBvcnQgb2YgZmlsdGVyaW5nLFxuICogc29ydGluZyAodXNpbmcgTWF0U29ydCksIGFuZCBwYWdpbmF0aW9uICh1c2luZyBNYXRQYWdpbmF0b3IpLlxuICpcbiAqIEFsbG93cyBmb3Igc29ydCBjdXN0b21pemF0aW9uIGJ5IG92ZXJyaWRpbmcgc29ydGluZ0RhdGFBY2Nlc3Nvciwgd2hpY2ggZGVmaW5lcyBob3cgZGF0YVxuICogcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIEFsc28gYWxsb3dzIGZvciBmaWx0ZXIgY3VzdG9taXphdGlvbiBieSBvdmVycmlkaW5nIGZpbHRlclByZWRpY2F0ZSxcbiAqIHdoaWNoIGRlZmluZXMgaG93IHJvdyBkYXRhIGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBmb3IgZmlsdGVyIG1hdGNoaW5nLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGNsYXNzIGlzIG1lYW50IHRvIGJlIGEgc2ltcGxlIGRhdGEgc291cmNlIHRvIGhlbHAgeW91IGdldCBzdGFydGVkLiBBcyBzdWNoXG4gKiBpdCBpc24ndCBlcXVpcHBlZCB0byBoYW5kbGUgc29tZSBtb3JlIGFkdmFuY2VkIGNhc2VzIGxpa2Ugcm9idXN0IGkxOG4gc3VwcG9ydCBvciBzZXJ2ZXItc2lkZVxuICogaW50ZXJhY3Rpb25zLiBJZiB5b3VyIGFwcCBuZWVkcyB0byBzdXBwb3J0IG1vcmUgYWR2YW5jZWQgdXNlIGNhc2VzLCBjb25zaWRlciBpbXBsZW1lbnRpbmcgeW91clxuICogb3duIGBEYXRhU291cmNlYC5cbiAqL1xuY2xhc3MgTWF0VGFibGVEYXRhU291cmNlIGV4dGVuZHMgX01hdFRhYmxlRGF0YVNvdXJjZSB7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBNYXRDZWxsLCBNYXRDZWxsRGVmLCBNYXRDb2x1bW5EZWYsIE1hdEZvb3RlckNlbGwsIE1hdEZvb3RlckNlbGxEZWYsIE1hdEZvb3RlclJvdywgTWF0Rm9vdGVyUm93RGVmLCBNYXRIZWFkZXJDZWxsLCBNYXRIZWFkZXJDZWxsRGVmLCBNYXRIZWFkZXJSb3csIE1hdEhlYWRlclJvd0RlZiwgTWF0Tm9EYXRhUm93LCBNYXRSZWN5Y2xlUm93cywgTWF0Um93LCBNYXRSb3dEZWYsIE1hdFRhYmxlLCBNYXRUYWJsZURhdGFTb3VyY2UsIE1hdFRhYmxlTW9kdWxlLCBNYXRUZXh0Q29sdW1uLCBfTWF0VGFibGVEYXRhU291cmNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/material/fesm2020/table.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/platform-browser/fesm2020/animations.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@angular/platform-browser/fesm2020/animations.mjs ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ANIMATION_MODULE_TYPE\": function() { return /* reexport safe */ _angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE; },\n/* harmony export */   \"BrowserAnimationsModule\": function() { return /* binding */ BrowserAnimationsModule; },\n/* harmony export */   \"NoopAnimationsModule\": function() { return /* binding */ NoopAnimationsModule; },\n/* harmony export */   \"provideAnimations\": function() { return /* binding */ provideAnimations; },\n/* harmony export */   \"provideNoopAnimations\": function() { return /* binding */ provideNoopAnimations; },\n/* harmony export */   \"ɵAnimationRenderer\": function() { return /* binding */ AnimationRenderer; },\n/* harmony export */   \"ɵAnimationRendererFactory\": function() { return /* binding */ AnimationRendererFactory; },\n/* harmony export */   \"ɵBrowserAnimationBuilder\": function() { return /* binding */ BrowserAnimationBuilder; },\n/* harmony export */   \"ɵBrowserAnimationFactory\": function() { return /* binding */ BrowserAnimationFactory; },\n/* harmony export */   \"ɵInjectableAnimationEngine\": function() { return /* binding */ InjectableAnimationEngine; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/platform-browser */ \"webpack/sharing/consume/default/@angular/platform-browser/@angular/platform-browser\");\n/* harmony import */ var _angular_animations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/animations */ \"webpack/sharing/consume/default/@angular/animations/@angular/animations\");\n/* harmony import */ var _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/animations/browser */ \"./node_modules/@angular/animations/fesm2020/browser.mjs\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/**\n * @license Angular v15.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n\n\n\n\n\n\n\n\nclass BrowserAnimationBuilder extends _angular_animations__WEBPACK_IMPORTED_MODULE_2__.AnimationBuilder {\n    constructor(rootRenderer, doc) {\n        super();\n        this._nextAnimationId = 0;\n        const typeData = { id: '0', encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, styles: [], data: { animation: [] } };\n        this._renderer = rootRenderer.createRenderer(doc.body, typeData);\n    }\n    build(animation) {\n        const id = this._nextAnimationId.toString();\n        this._nextAnimationId++;\n        const entry = Array.isArray(animation) ? (0,_angular_animations__WEBPACK_IMPORTED_MODULE_2__.sequence)(animation) : animation;\n        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);\n        return new BrowserAnimationFactory(id, this._renderer);\n    }\n}\nBrowserAnimationBuilder.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationBuilder, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2 }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nBrowserAnimationBuilder.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationBuilder });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationBuilder, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2 }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT]\n                }] }]; } });\nclass BrowserAnimationFactory extends _angular_animations__WEBPACK_IMPORTED_MODULE_2__.AnimationFactory {\n    constructor(_id, _renderer) {\n        super();\n        this._id = _id;\n        this._renderer = _renderer;\n    }\n    create(element, options) {\n        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);\n    }\n}\nclass RendererAnimationPlayer {\n    constructor(id, element, options, _renderer) {\n        this.id = id;\n        this.element = element;\n        this._renderer = _renderer;\n        this.parentPlayer = null;\n        this._started = false;\n        this.totalTime = 0;\n        this._command('create', options);\n    }\n    _listen(eventName, callback) {\n        return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);\n    }\n    _command(command, ...args) {\n        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);\n    }\n    onDone(fn) {\n        this._listen('done', fn);\n    }\n    onStart(fn) {\n        this._listen('start', fn);\n    }\n    onDestroy(fn) {\n        this._listen('destroy', fn);\n    }\n    init() {\n        this._command('init');\n    }\n    hasStarted() {\n        return this._started;\n    }\n    play() {\n        this._command('play');\n        this._started = true;\n    }\n    pause() {\n        this._command('pause');\n    }\n    restart() {\n        this._command('restart');\n    }\n    finish() {\n        this._command('finish');\n    }\n    destroy() {\n        this._command('destroy');\n    }\n    reset() {\n        this._command('reset');\n        this._started = false;\n    }\n    setPosition(p) {\n        this._command('setPosition', p);\n    }\n    getPosition() {\n        return this._renderer.engine.players[+this.id]?.getPosition() ?? 0;\n    }\n}\nfunction issueAnimationCommand(renderer, element, id, command, args) {\n    return renderer.setProperty(element, `@@${id}:${command}`, args);\n}\n\nconst ANIMATION_PREFIX = '@';\nconst DISABLE_ANIMATIONS_FLAG = '@.disabled';\nclass AnimationRendererFactory {\n    constructor(delegate, engine, _zone) {\n        this.delegate = delegate;\n        this.engine = engine;\n        this._zone = _zone;\n        this._currentId = 0;\n        this._microtaskId = 1;\n        this._animationCallbacksBuffer = [];\n        this._rendererCache = new Map();\n        this._cdRecurDepth = 0;\n        this.promise = Promise.resolve(0);\n        engine.onRemovalComplete = (element, delegate) => {\n            // Note: if a component element has a leave animation, and a host leave animation,\n            // the view engine will call `removeChild` for the parent\n            // component renderer as well as for the child component renderer.\n            // Therefore, we need to check if we already removed the element.\n            const parentNode = delegate?.parentNode(element);\n            if (parentNode) {\n                delegate.removeChild(parentNode, element);\n            }\n        };\n    }\n    createRenderer(hostElement, type) {\n        const EMPTY_NAMESPACE_ID = '';\n        // cache the delegates to find out which cached delegate can\n        // be used by which cached renderer\n        const delegate = this.delegate.createRenderer(hostElement, type);\n        if (!hostElement || !type || !type.data || !type.data['animation']) {\n            let renderer = this._rendererCache.get(delegate);\n            if (!renderer) {\n                // Ensure that the renderer is removed from the cache on destroy\n                // since it may contain references to detached DOM nodes.\n                const onRendererDestroy = () => this._rendererCache.delete(delegate);\n                renderer =\n                    new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);\n                // only cache this result when the base renderer is used\n                this._rendererCache.set(delegate, renderer);\n            }\n            return renderer;\n        }\n        const componentId = type.id;\n        const namespaceId = type.id + '-' + this._currentId;\n        this._currentId++;\n        this.engine.register(namespaceId, hostElement);\n        const registerTrigger = (trigger) => {\n            if (Array.isArray(trigger)) {\n                trigger.forEach(registerTrigger);\n            }\n            else {\n                this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);\n            }\n        };\n        const animationTriggers = type.data['animation'];\n        animationTriggers.forEach(registerTrigger);\n        return new AnimationRenderer(this, namespaceId, delegate, this.engine);\n    }\n    begin() {\n        this._cdRecurDepth++;\n        if (this.delegate.begin) {\n            this.delegate.begin();\n        }\n    }\n    _scheduleCountTask() {\n        // always use promise to schedule microtask instead of use Zone\n        this.promise.then(() => {\n            this._microtaskId++;\n        });\n    }\n    /** @internal */\n    scheduleListenerCallback(count, fn, data) {\n        if (count >= 0 && count < this._microtaskId) {\n            this._zone.run(() => fn(data));\n            return;\n        }\n        if (this._animationCallbacksBuffer.length == 0) {\n            Promise.resolve(null).then(() => {\n                this._zone.run(() => {\n                    this._animationCallbacksBuffer.forEach(tuple => {\n                        const [fn, data] = tuple;\n                        fn(data);\n                    });\n                    this._animationCallbacksBuffer = [];\n                });\n            });\n        }\n        this._animationCallbacksBuffer.push([fn, data]);\n    }\n    end() {\n        this._cdRecurDepth--;\n        // this is to prevent animations from running twice when an inner\n        // component does CD when a parent component instead has inserted it\n        if (this._cdRecurDepth == 0) {\n            this._zone.runOutsideAngular(() => {\n                this._scheduleCountTask();\n                this.engine.flush(this._microtaskId);\n            });\n        }\n        if (this.delegate.end) {\n            this.delegate.end();\n        }\n    }\n    whenRenderingDone() {\n        return this.engine.whenRenderingDone();\n    }\n}\nAnimationRendererFactory.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationRendererFactory, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2 }, { token: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationEngine\"] }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nAnimationRendererFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationRendererFactory });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationRendererFactory, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2 }, { type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationEngine\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }]; } });\nclass BaseAnimationRenderer {\n    constructor(namespaceId, delegate, engine, _onDestroy) {\n        this.namespaceId = namespaceId;\n        this.delegate = delegate;\n        this.engine = engine;\n        this._onDestroy = _onDestroy;\n        this.destroyNode = this.delegate.destroyNode ? (n) => delegate.destroyNode(n) : null;\n    }\n    get data() {\n        return this.delegate.data;\n    }\n    destroy() {\n        this.engine.destroy(this.namespaceId, this.delegate);\n        this.delegate.destroy();\n        this._onDestroy?.();\n    }\n    createElement(name, namespace) {\n        return this.delegate.createElement(name, namespace);\n    }\n    createComment(value) {\n        return this.delegate.createComment(value);\n    }\n    createText(value) {\n        return this.delegate.createText(value);\n    }\n    appendChild(parent, newChild) {\n        this.delegate.appendChild(parent, newChild);\n        this.engine.onInsert(this.namespaceId, newChild, parent, false);\n    }\n    insertBefore(parent, newChild, refChild, isMove = true) {\n        this.delegate.insertBefore(parent, newChild, refChild);\n        // If `isMove` true than we should animate this insert.\n        this.engine.onInsert(this.namespaceId, newChild, parent, isMove);\n    }\n    removeChild(parent, oldChild, isHostElement) {\n        this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);\n    }\n    selectRootElement(selectorOrNode, preserveContent) {\n        return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n    }\n    parentNode(node) {\n        return this.delegate.parentNode(node);\n    }\n    nextSibling(node) {\n        return this.delegate.nextSibling(node);\n    }\n    setAttribute(el, name, value, namespace) {\n        this.delegate.setAttribute(el, name, value, namespace);\n    }\n    removeAttribute(el, name, namespace) {\n        this.delegate.removeAttribute(el, name, namespace);\n    }\n    addClass(el, name) {\n        this.delegate.addClass(el, name);\n    }\n    removeClass(el, name) {\n        this.delegate.removeClass(el, name);\n    }\n    setStyle(el, style, value, flags) {\n        this.delegate.setStyle(el, style, value, flags);\n    }\n    removeStyle(el, style, flags) {\n        this.delegate.removeStyle(el, style, flags);\n    }\n    setProperty(el, name, value) {\n        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {\n            this.disableAnimations(el, !!value);\n        }\n        else {\n            this.delegate.setProperty(el, name, value);\n        }\n    }\n    setValue(node, value) {\n        this.delegate.setValue(node, value);\n    }\n    listen(target, eventName, callback) {\n        return this.delegate.listen(target, eventName, callback);\n    }\n    disableAnimations(element, value) {\n        this.engine.disableAnimations(element, value);\n    }\n}\nclass AnimationRenderer extends BaseAnimationRenderer {\n    constructor(factory, namespaceId, delegate, engine, onDestroy) {\n        super(namespaceId, delegate, engine, onDestroy);\n        this.factory = factory;\n        this.namespaceId = namespaceId;\n    }\n    setProperty(el, name, value) {\n        if (name.charAt(0) == ANIMATION_PREFIX) {\n            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {\n                value = value === undefined ? true : !!value;\n                this.disableAnimations(el, value);\n            }\n            else {\n                this.engine.process(this.namespaceId, el, name.slice(1), value);\n            }\n        }\n        else {\n            this.delegate.setProperty(el, name, value);\n        }\n    }\n    listen(target, eventName, callback) {\n        if (eventName.charAt(0) == ANIMATION_PREFIX) {\n            const element = resolveElementFromTarget(target);\n            let name = eventName.slice(1);\n            let phase = '';\n            // @listener.phase is for trigger animation callbacks\n            // @@listener is for animation builder callbacks\n            if (name.charAt(0) != ANIMATION_PREFIX) {\n                [name, phase] = parseTriggerCallbackName(name);\n            }\n            return this.engine.listen(this.namespaceId, element, name, phase, event => {\n                const countId = event['_data'] || -1;\n                this.factory.scheduleListenerCallback(countId, callback, event);\n            });\n        }\n        return this.delegate.listen(target, eventName, callback);\n    }\n}\nfunction resolveElementFromTarget(target) {\n    switch (target) {\n        case 'body':\n            return document.body;\n        case 'document':\n            return document;\n        case 'window':\n            return window;\n        default:\n            return target;\n    }\n}\nfunction parseTriggerCallbackName(triggerName) {\n    const dotIndex = triggerName.indexOf('.');\n    const trigger = triggerName.substring(0, dotIndex);\n    const phase = triggerName.slice(dotIndex + 1);\n    return [trigger, phase];\n}\n\nclass InjectableAnimationEngine extends _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationEngine\"] {\n    // The `ApplicationRef` is injected here explicitly to force the dependency ordering.\n    // Since the `ApplicationRef` should be created earlier before the `AnimationEngine`, they\n    // both have `ngOnDestroy` hooks and `flush()` must be called after all views are destroyed.\n    constructor(doc, driver, normalizer, appRef) {\n        super(doc.body, driver, normalizer);\n    }\n    ngOnDestroy() {\n        this.flush();\n    }\n}\nInjectableAnimationEngine.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InjectableAnimationEngine, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT }, { token: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__.AnimationDriver }, { token: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationStyleNormalizer\"] }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nInjectableAnimationEngine.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InjectableAnimationEngine });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InjectableAnimationEngine, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT]\n                }] }, { type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__.AnimationDriver }, { type: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationStyleNormalizer\"] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef }]; } });\nfunction instantiateDefaultStyleNormalizer() {\n    return new _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵWebAnimationsStyleNormalizer\"]();\n}\nfunction instantiateRendererFactory(renderer, engine, zone) {\n    return new AnimationRendererFactory(renderer, engine, zone);\n}\nconst SHARED_ANIMATION_PROVIDERS = [\n    { provide: _angular_animations__WEBPACK_IMPORTED_MODULE_2__.AnimationBuilder, useClass: BrowserAnimationBuilder },\n    { provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationStyleNormalizer\"], useFactory: instantiateDefaultStyleNormalizer },\n    { provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationEngine\"], useClass: InjectableAnimationEngine }, {\n        provide: _angular_core__WEBPACK_IMPORTED_MODULE_0__.RendererFactory2,\n        useFactory: instantiateRendererFactory,\n        deps: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__[\"ɵDomRendererFactory2\"], _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵAnimationEngine\"], _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone]\n    }\n];\n/**\n * Separate providers from the actual module so that we can do a local modification in Google3 to\n * include them in the BrowserModule.\n */\nconst BROWSER_ANIMATIONS_PROVIDERS = [\n    { provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__.AnimationDriver, useFactory: () => new _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵWebAnimationsDriver\"]() },\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE, useValue: 'BrowserAnimations' }, ...SHARED_ANIMATION_PROVIDERS\n];\n/**\n * Separate providers from the actual module so that we can do a local modification in Google3 to\n * include them in the BrowserTestingModule.\n */\nconst BROWSER_NOOP_ANIMATIONS_PROVIDERS = [\n    { provide: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__.AnimationDriver, useClass: _angular_animations_browser__WEBPACK_IMPORTED_MODULE_4__[\"ɵNoopAnimationDriver\"] },\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ANIMATION_MODULE_TYPE, useValue: 'NoopAnimations' }, ...SHARED_ANIMATION_PROVIDERS\n];\n\n/**\n * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)\n * for use with animations. See [Animations](guide/animations).\n * @publicApi\n */\nclass BrowserAnimationsModule {\n    /**\n     * Configures the module based on the specified object.\n     *\n     * @param config Object used to configure the behavior of the `BrowserAnimationsModule`.\n     * @see `BrowserAnimationsModuleConfig`\n     *\n     * @usageNotes\n     * When registering the `BrowserAnimationsModule`, you can use the `withConfig`\n     * function as follows:\n     * ```\n     * @NgModule({\n     *   imports: [BrowserAnimationsModule.withConfig(config)]\n     * })\n     * class MyNgModule {}\n     * ```\n     */\n    static withConfig(config) {\n        return {\n            ngModule: BrowserAnimationsModule,\n            providers: config.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS :\n                BROWSER_ANIMATIONS_PROVIDERS\n        };\n    }\n}\nBrowserAnimationsModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nBrowserAnimationsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationsModule, exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule] });\nBrowserAnimationsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationsModule, providers: BROWSER_ANIMATIONS_PROVIDERS, imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BrowserAnimationsModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule],\n                    providers: BROWSER_ANIMATIONS_PROVIDERS,\n                }]\n        }] });\n/**\n * Returns the set of [dependency-injection providers](guide/glossary#provider)\n * to enable animations in an application. See [animations guide](guide/animations)\n * to learn more about animations in Angular.\n *\n * @usageNotes\n *\n * The function is useful when you want to enable animations in an application\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\n * providers returned by this function to the `providers` list as show below.\n *\n * ```typescript\n * bootstrapApplication(RootComponent, {\n *   providers: [\n *     provideAnimations()\n *   ]\n * });\n * ```\n *\n * @publicApi\n */\nfunction provideAnimations() {\n    // Return a copy to prevent changes to the original array in case any in-place\n    // alterations are performed to the `provideAnimations` call results in app code.\n    return [...BROWSER_ANIMATIONS_PROVIDERS];\n}\n/**\n * A null player that must be imported to allow disabling of animations.\n * @publicApi\n */\nclass NoopAnimationsModule {\n}\nNoopAnimationsModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NoopAnimationsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nNoopAnimationsModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NoopAnimationsModule, exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule] });\nNoopAnimationsModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NoopAnimationsModule, providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS, imports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NoopAnimationsModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    exports: [_angular_platform_browser__WEBPACK_IMPORTED_MODULE_1__.BrowserModule],\n                    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,\n                }]\n        }] });\n/**\n * Returns the set of [dependency-injection providers](guide/glossary#provider)\n * to disable animations in an application. See [animations guide](guide/animations)\n * to learn more about animations in Angular.\n *\n * @usageNotes\n *\n * The function is useful when you want to bootstrap an application using\n * the `bootstrapApplication` function, but you need to disable animations\n * (for example, when running tests).\n *\n * ```typescript\n * bootstrapApplication(RootComponent, {\n *   providers: [\n *     provideNoopAnimations()\n *   ]\n * });\n * ```\n *\n * @publicApi\n */\nfunction provideNoopAnimations() {\n    // Return a copy to prevent changes to the original array in case any in-place\n    // alterations are performed to the `provideNoopAnimations` call results in app code.\n    return [...BROWSER_NOOP_ANIMATIONS_PROVIDERS];\n}\n\n/**\n * @module\n * @description\n * Entry point for all animation APIs of the animation browser package.\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=animations.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9mZXNtMjAyMC9hbmltYXRpb25zLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvZmVzbTIwMjAvYW5pbWF0aW9ucy5tanM/YTkzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXIgdjE1LjIuN1xuICogKGMpIDIwMTAtMjAyMiBHb29nbGUgTExDLiBodHRwczovL2FuZ3VsYXIuaW8vXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG5pbXBvcnQgKiBhcyBpMCBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZpZXdFbmNhcHN1bGF0aW9uLCBJbmplY3RhYmxlLCBJbmplY3QsIFJlbmRlcmVyRmFjdG9yeTIsIE5nWm9uZSwgQU5JTUFUSU9OX01PRFVMRV9UWVBFLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuZXhwb3J0IHsgQU5JTUFUSU9OX01PRFVMRV9UWVBFIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyDJtURvbVJlbmRlcmVyRmFjdG9yeTIsIEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IEFuaW1hdGlvbkJ1aWxkZXIsIHNlcXVlbmNlLCBBbmltYXRpb25GYWN0b3J5IH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgKiBhcyBpMSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInO1xuaW1wb3J0IHsgybVBbmltYXRpb25FbmdpbmUsIMm1V2ViQW5pbWF0aW9uc1N0eWxlTm9ybWFsaXplciwgybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIEFuaW1hdGlvbkRyaXZlciwgybVXZWJBbmltYXRpb25zRHJpdmVyLCDJtU5vb3BBbmltYXRpb25Ecml2ZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zL2Jyb3dzZXInO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5jbGFzcyBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciBleHRlbmRzIEFuaW1hdGlvbkJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHJvb3RSZW5kZXJlciwgZG9jKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX25leHRBbmltYXRpb25JZCA9IDA7XG4gICAgICAgIGNvbnN0IHR5cGVEYXRhID0geyBpZDogJzAnLCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLCBzdHlsZXM6IFtdLCBkYXRhOiB7IGFuaW1hdGlvbjogW10gfSB9O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJvb3RSZW5kZXJlci5jcmVhdGVSZW5kZXJlcihkb2MuYm9keSwgdHlwZURhdGEpO1xuICAgIH1cbiAgICBidWlsZChhbmltYXRpb24pIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLl9uZXh0QW5pbWF0aW9uSWQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fbmV4dEFuaW1hdGlvbklkKys7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gQXJyYXkuaXNBcnJheShhbmltYXRpb24pID8gc2VxdWVuY2UoYW5pbWF0aW9uKSA6IGFuaW1hdGlvbjtcbiAgICAgICAgaXNzdWVBbmltYXRpb25Db21tYW5kKHRoaXMuX3JlbmRlcmVyLCBudWxsLCBpZCwgJ3JlZ2lzdGVyJywgW2VudHJ5XSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvd3NlckFuaW1hdGlvbkZhY3RvcnkoaWQsIHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9XG59XG5Ccm93c2VyQW5pbWF0aW9uQnVpbGRlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyRmFjdG9yeTIgfSwgeyB0b2tlbjogRE9DVU1FTlQgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkJyb3dzZXJBbmltYXRpb25CdWlsZGVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5SZW5kZXJlckZhY3RvcnkyIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcbmNsYXNzIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5IGV4dGVuZHMgQW5pbWF0aW9uRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoX2lkLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5faWQgPSBfaWQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgIH1cbiAgICBjcmVhdGUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFJlbmRlcmVyQW5pbWF0aW9uUGxheWVyKHRoaXMuX2lkLCBlbGVtZW50LCBvcHRpb25zIHx8IHt9LCB0aGlzLl9yZW5kZXJlcik7XG4gICAgfVxufVxuY2xhc3MgUmVuZGVyZXJBbmltYXRpb25QbGF5ZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBlbGVtZW50LCBvcHRpb25zLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5wYXJlbnRQbGF5ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudG90YWxUaW1lID0gMDtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgnY3JlYXRlJywgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9saXN0ZW4oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuZWxlbWVudCwgYEBAJHt0aGlzLmlkfToke2V2ZW50TmFtZX1gLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIF9jb21tYW5kKGNvbW1hbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGlzc3VlQW5pbWF0aW9uQ29tbWFuZCh0aGlzLl9yZW5kZXJlciwgdGhpcy5lbGVtZW50LCB0aGlzLmlkLCBjb21tYW5kLCBhcmdzKTtcbiAgICB9XG4gICAgb25Eb25lKGZuKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbignZG9uZScsIGZuKTtcbiAgICB9XG4gICAgb25TdGFydChmbikge1xuICAgICAgICB0aGlzLl9saXN0ZW4oJ3N0YXJ0JywgZm4pO1xuICAgIH1cbiAgICBvbkRlc3Ryb3koZm4pIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuKCdkZXN0cm95JywgZm4pO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdpbml0Jyk7XG4gICAgfVxuICAgIGhhc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFydGVkO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdwbGF5Jyk7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgncGF1c2UnKTtcbiAgICB9XG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgncmVzdGFydCcpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMuX2NvbW1hbmQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdkZXN0cm95Jyk7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9jb21tYW5kKCdyZXNldCcpO1xuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHNldFBvc2l0aW9uKHApIHtcbiAgICAgICAgdGhpcy5fY29tbWFuZCgnc2V0UG9zaXRpb24nLCBwKTtcbiAgICB9XG4gICAgZ2V0UG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlci5lbmdpbmUucGxheWVyc1srdGhpcy5pZF0/LmdldFBvc2l0aW9uKCkgPz8gMDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc3N1ZUFuaW1hdGlvbkNvbW1hbmQocmVuZGVyZXIsIGVsZW1lbnQsIGlkLCBjb21tYW5kLCBhcmdzKSB7XG4gICAgcmV0dXJuIHJlbmRlcmVyLnNldFByb3BlcnR5KGVsZW1lbnQsIGBAQCR7aWR9OiR7Y29tbWFuZH1gLCBhcmdzKTtcbn1cblxuY29uc3QgQU5JTUFUSU9OX1BSRUZJWCA9ICdAJztcbmNvbnN0IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHID0gJ0AuZGlzYWJsZWQnO1xuY2xhc3MgQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgZW5naW5lLCBfem9uZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJZCA9IDA7XG4gICAgICAgIHRoaXMuX21pY3JvdGFza0lkID0gMTtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NkUmVjdXJEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgwKTtcbiAgICAgICAgZW5naW5lLm9uUmVtb3ZhbENvbXBsZXRlID0gKGVsZW1lbnQsIGRlbGVnYXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBOb3RlOiBpZiBhIGNvbXBvbmVudCBlbGVtZW50IGhhcyBhIGxlYXZlIGFuaW1hdGlvbiwgYW5kIGEgaG9zdCBsZWF2ZSBhbmltYXRpb24sXG4gICAgICAgICAgICAvLyB0aGUgdmlldyBlbmdpbmUgd2lsbCBjYWxsIGByZW1vdmVDaGlsZGAgZm9yIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCByZW5kZXJlciBhcyB3ZWxsIGFzIGZvciB0aGUgY2hpbGQgY29tcG9uZW50IHJlbmRlcmVyLlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgcmVtb3ZlZCB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBkZWxlZ2F0ZT8ucGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZGVsZWdhdGUucmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVJlbmRlcmVyKGhvc3RFbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IEVNUFRZX05BTUVTUEFDRV9JRCA9ICcnO1xuICAgICAgICAvLyBjYWNoZSB0aGUgZGVsZWdhdGVzIHRvIGZpbmQgb3V0IHdoaWNoIGNhY2hlZCBkZWxlZ2F0ZSBjYW5cbiAgICAgICAgLy8gYmUgdXNlZCBieSB3aGljaCBjYWNoZWQgcmVuZGVyZXJcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0aGlzLmRlbGVnYXRlLmNyZWF0ZVJlbmRlcmVyKGhvc3RFbGVtZW50LCB0eXBlKTtcbiAgICAgICAgaWYgKCFob3N0RWxlbWVudCB8fCAhdHlwZSB8fCAhdHlwZS5kYXRhIHx8ICF0eXBlLmRhdGFbJ2FuaW1hdGlvbiddKSB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlckNhY2hlLmdldChkZWxlZ2F0ZSk7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHJlbmRlcmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgb24gZGVzdHJveVxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IG1heSBjb250YWluIHJlZmVyZW5jZXMgdG8gZGV0YWNoZWQgRE9NIG5vZGVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVuZGVyZXJEZXN0cm95ID0gKCkgPT4gdGhpcy5fcmVuZGVyZXJDYWNoZS5kZWxldGUoZGVsZWdhdGUpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyID1cbiAgICAgICAgICAgICAgICAgICAgbmV3IEJhc2VBbmltYXRpb25SZW5kZXJlcihFTVBUWV9OQU1FU1BBQ0VfSUQsIGRlbGVnYXRlLCB0aGlzLmVuZ2luZSwgb25SZW5kZXJlckRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FjaGUgdGhpcyByZXN1bHQgd2hlbiB0aGUgYmFzZSByZW5kZXJlciBpcyB1c2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJDYWNoZS5zZXQoZGVsZWdhdGUsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb25lbnRJZCA9IHR5cGUuaWQ7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZUlkID0gdHlwZS5pZCArICctJyArIHRoaXMuX2N1cnJlbnRJZDtcbiAgICAgICAgdGhpcy5fY3VycmVudElkKys7XG4gICAgICAgIHRoaXMuZW5naW5lLnJlZ2lzdGVyKG5hbWVzcGFjZUlkLCBob3N0RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyVHJpZ2dlciA9ICh0cmlnZ2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VyKSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXIuZm9yRWFjaChyZWdpc3RlclRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucmVnaXN0ZXJUcmlnZ2VyKGNvbXBvbmVudElkLCBuYW1lc3BhY2VJZCwgaG9zdEVsZW1lbnQsIHRyaWdnZXIubmFtZSwgdHJpZ2dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvblRyaWdnZXJzID0gdHlwZS5kYXRhWydhbmltYXRpb24nXTtcbiAgICAgICAgYW5pbWF0aW9uVHJpZ2dlcnMuZm9yRWFjaChyZWdpc3RlclRyaWdnZXIpO1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblJlbmRlcmVyKHRoaXMsIG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgdGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgICBiZWdpbigpIHtcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoKys7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmJlZ2luKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmJlZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NjaGVkdWxlQ291bnRUYXNrKCkge1xuICAgICAgICAvLyBhbHdheXMgdXNlIHByb21pc2UgdG8gc2NoZWR1bGUgbWljcm90YXNrIGluc3RlYWQgb2YgdXNlIFpvbmVcbiAgICAgICAgdGhpcy5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWljcm90YXNrSWQrKztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzY2hlZHVsZUxpc3RlbmVyQ2FsbGJhY2soY291bnQsIGZuLCBkYXRhKSB7XG4gICAgICAgIGlmIChjb3VudCA+PSAwICYmIGNvdW50IDwgdGhpcy5fbWljcm90YXNrSWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IGZuKGRhdGEpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25DYWxsYmFja3NCdWZmZXIuZm9yRWFjaCh0dXBsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbZm4sIGRhdGFdID0gdHVwbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbGxiYWNrc0J1ZmZlciA9IFtdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FsbGJhY2tzQnVmZmVyLnB1c2goW2ZuLCBkYXRhXSk7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy5fY2RSZWN1ckRlcHRoLS07XG4gICAgICAgIC8vIHRoaXMgaXMgdG8gcHJldmVudCBhbmltYXRpb25zIGZyb20gcnVubmluZyB0d2ljZSB3aGVuIGFuIGlubmVyXG4gICAgICAgIC8vIGNvbXBvbmVudCBkb2VzIENEIHdoZW4gYSBwYXJlbnQgY29tcG9uZW50IGluc3RlYWQgaGFzIGluc2VydGVkIGl0XG4gICAgICAgIGlmICh0aGlzLl9jZFJlY3VyRGVwdGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVDb3VudFRhc2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5mbHVzaCh0aGlzLl9taWNyb3Rhc2tJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hlblJlbmRlcmluZ0RvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS53aGVuUmVuZGVyaW5nRG9uZSgpO1xuICAgIH1cbn1cbkFuaW1hdGlvblJlbmRlcmVyRmFjdG9yeS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBbmltYXRpb25SZW5kZXJlckZhY3RvcnksIGRlcHM6IFt7IHRva2VuOiBpMC5SZW5kZXJlckZhY3RvcnkyIH0sIHsgdG9rZW46IGkxLsm1QW5pbWF0aW9uRW5naW5lIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5Lsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQW5pbWF0aW9uUmVuZGVyZXJGYWN0b3J5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLlJlbmRlcmVyRmFjdG9yeTIgfSwgeyB0eXBlOiBpMS7JtUFuaW1hdGlvbkVuZ2luZSB9LCB7IHR5cGU6IGkwLk5nWm9uZSB9XTsgfSB9KTtcbmNsYXNzIEJhc2VBbmltYXRpb25SZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IobmFtZXNwYWNlSWQsIGRlbGVnYXRlLCBlbmdpbmUsIF9vbkRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2VJZCA9IG5hbWVzcGFjZUlkO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kgPSBfb25EZXN0cm95O1xuICAgICAgICB0aGlzLmRlc3Ryb3lOb2RlID0gdGhpcy5kZWxlZ2F0ZS5kZXN0cm95Tm9kZSA/IChuKSA9PiBkZWxlZ2F0ZS5kZXN0cm95Tm9kZShuKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5kYXRhO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5kZXN0cm95KHRoaXMubmFtZXNwYWNlSWQsIHRoaXMuZGVsZWdhdGUpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Py4oKTtcbiAgICB9XG4gICAgY3JlYXRlRWxlbWVudChuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUuY3JlYXRlRWxlbWVudChuYW1lLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBjcmVhdGVDb21tZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZUNvbW1lbnQodmFsdWUpO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmNyZWF0ZVRleHQodmFsdWUpO1xuICAgIH1cbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5ld0NoaWxkKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdDaGlsZCk7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uSW5zZXJ0KHRoaXMubmFtZXNwYWNlSWQsIG5ld0NoaWxkLCBwYXJlbnQsIGZhbHNlKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkLCBpc01vdmUgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuaW5zZXJ0QmVmb3JlKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkKTtcbiAgICAgICAgLy8gSWYgYGlzTW92ZWAgdHJ1ZSB0aGFuIHdlIHNob3VsZCBhbmltYXRlIHRoaXMgaW5zZXJ0LlxuICAgICAgICB0aGlzLmVuZ2luZS5vbkluc2VydCh0aGlzLm5hbWVzcGFjZUlkLCBuZXdDaGlsZCwgcGFyZW50LCBpc01vdmUpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZChwYXJlbnQsIG9sZENoaWxkLCBpc0hvc3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZW5naW5lLm9uUmVtb3ZlKHRoaXMubmFtZXNwYWNlSWQsIG9sZENoaWxkLCB0aGlzLmRlbGVnYXRlLCBpc0hvc3RFbGVtZW50KTtcbiAgICB9XG4gICAgc2VsZWN0Um9vdEVsZW1lbnQoc2VsZWN0b3JPck5vZGUsIHByZXNlcnZlQ29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zZWxlY3RSb290RWxlbWVudChzZWxlY3Rvck9yTm9kZSwgcHJlc2VydmVDb250ZW50KTtcbiAgICB9XG4gICAgcGFyZW50Tm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnBhcmVudE5vZGUobm9kZSk7XG4gICAgfVxuICAgIG5leHRTaWJsaW5nKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubmV4dFNpYmxpbmcobm9kZSk7XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShlbCwgbmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lLCBuYW1lc3BhY2UpO1xuICAgIH1cbiAgICBhZGRDbGFzcyhlbCwgbmFtZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLmFkZENsYXNzKGVsLCBuYW1lKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5yZW1vdmVDbGFzcyhlbCwgbmFtZSk7XG4gICAgfVxuICAgIHNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0U3R5bGUoZWwsIHN0eWxlLCB2YWx1ZSwgZmxhZ3MpO1xuICAgIH1cbiAgICByZW1vdmVTdHlsZShlbCwgc3R5bGUsIGZsYWdzKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucmVtb3ZlU3R5bGUoZWwsIHN0eWxlLCBmbGFncyk7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVBbmltYXRpb25zKGVsLCAhIXZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZShub2RlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNldFZhbHVlKG5vZGUsIHZhbHVlKTtcbiAgICB9XG4gICAgbGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5saXN0ZW4odGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZGlzYWJsZUFuaW1hdGlvbnMoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuZGlzYWJsZUFuaW1hdGlvbnMoZWxlbWVudCwgdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEFuaW1hdGlvblJlbmRlcmVyIGV4dGVuZHMgQmFzZUFuaW1hdGlvblJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3J5LCBuYW1lc3BhY2VJZCwgZGVsZWdhdGUsIGVuZ2luZSwgb25EZXN0cm95KSB7XG4gICAgICAgIHN1cGVyKG5hbWVzcGFjZUlkLCBkZWxlZ2F0ZSwgZW5naW5lLCBvbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLm5hbWVzcGFjZUlkID0gbmFtZXNwYWNlSWQ7XG4gICAgfVxuICAgIHNldFByb3BlcnR5KGVsLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDEpID09ICcuJyAmJiBuYW1lID09IERJU0FCTEVfQU5JTUFUSU9OU19GTEFHKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlQW5pbWF0aW9ucyhlbCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucHJvY2Vzcyh0aGlzLm5hbWVzcGFjZUlkLCBlbCwgbmFtZS5zbGljZSgxKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zZXRQcm9wZXJ0eShlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxpc3Rlbih0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5jaGFyQXQoMCkgPT0gQU5JTUFUSU9OX1BSRUZJWCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlc29sdmVFbGVtZW50RnJvbVRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBldmVudE5hbWUuc2xpY2UoMSk7XG4gICAgICAgICAgICBsZXQgcGhhc2UgPSAnJztcbiAgICAgICAgICAgIC8vIEBsaXN0ZW5lci5waGFzZSBpcyBmb3IgdHJpZ2dlciBhbmltYXRpb24gY2FsbGJhY2tzXG4gICAgICAgICAgICAvLyBAQGxpc3RlbmVyIGlzIGZvciBhbmltYXRpb24gYnVpbGRlciBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPSBBTklNQVRJT05fUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgW25hbWUsIHBoYXNlXSA9IHBhcnNlVHJpZ2dlckNhbGxiYWNrTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5saXN0ZW4odGhpcy5uYW1lc3BhY2VJZCwgZWxlbWVudCwgbmFtZSwgcGhhc2UsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudElkID0gZXZlbnRbJ19kYXRhJ10gfHwgLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5LnNjaGVkdWxlTGlzdGVuZXJDYWxsYmFjayhjb3VudElkLCBjYWxsYmFjaywgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubGlzdGVuKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRGcm9tVGFyZ2V0KHRhcmdldCkge1xuICAgIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgY2FzZSAnd2luZG93JzpcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlckNhbGxiYWNrTmFtZSh0cmlnZ2VyTmFtZSkge1xuICAgIGNvbnN0IGRvdEluZGV4ID0gdHJpZ2dlck5hbWUuaW5kZXhPZignLicpO1xuICAgIGNvbnN0IHRyaWdnZXIgPSB0cmlnZ2VyTmFtZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgIGNvbnN0IHBoYXNlID0gdHJpZ2dlck5hbWUuc2xpY2UoZG90SW5kZXggKyAxKTtcbiAgICByZXR1cm4gW3RyaWdnZXIsIHBoYXNlXTtcbn1cblxuY2xhc3MgSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSBleHRlbmRzIMm1QW5pbWF0aW9uRW5naW5lIHtcbiAgICAvLyBUaGUgYEFwcGxpY2F0aW9uUmVmYCBpcyBpbmplY3RlZCBoZXJlIGV4cGxpY2l0bHkgdG8gZm9yY2UgdGhlIGRlcGVuZGVuY3kgb3JkZXJpbmcuXG4gICAgLy8gU2luY2UgdGhlIGBBcHBsaWNhdGlvblJlZmAgc2hvdWxkIGJlIGNyZWF0ZWQgZWFybGllciBiZWZvcmUgdGhlIGBBbmltYXRpb25FbmdpbmVgLCB0aGV5XG4gICAgLy8gYm90aCBoYXZlIGBuZ09uRGVzdHJveWAgaG9va3MgYW5kIGBmbHVzaCgpYCBtdXN0IGJlIGNhbGxlZCBhZnRlciBhbGwgdmlld3MgYXJlIGRlc3Ryb3llZC5cbiAgICBjb25zdHJ1Y3Rvcihkb2MsIGRyaXZlciwgbm9ybWFsaXplciwgYXBwUmVmKSB7XG4gICAgICAgIHN1cGVyKGRvYy5ib2R5LCBkcml2ZXIsIG5vcm1hbGl6ZXIpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbn1cbkluamVjdGFibGVBbmltYXRpb25FbmdpbmUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSwgZGVwczogW3sgdG9rZW46IERPQ1VNRU5UIH0sIHsgdG9rZW46IGkxLkFuaW1hdGlvbkRyaXZlciB9LCB7IHRva2VuOiBpMS7JtUFuaW1hdGlvblN0eWxlTm9ybWFsaXplciB9LCB7IHRva2VuOiBpMC5BcHBsaWNhdGlvblJlZiB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSW5qZWN0YWJsZUFuaW1hdGlvbkVuZ2luZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMS5BbmltYXRpb25Ecml2ZXIgfSwgeyB0eXBlOiBpMS7JtUFuaW1hdGlvblN0eWxlTm9ybWFsaXplciB9LCB7IHR5cGU6IGkwLkFwcGxpY2F0aW9uUmVmIH1dOyB9IH0pO1xuZnVuY3Rpb24gaW5zdGFudGlhdGVEZWZhdWx0U3R5bGVOb3JtYWxpemVyKCkge1xuICAgIHJldHVybiBuZXcgybVXZWJBbmltYXRpb25zU3R5bGVOb3JtYWxpemVyKCk7XG59XG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlbmRlcmVyRmFjdG9yeShyZW5kZXJlciwgZW5naW5lLCB6b25lKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkocmVuZGVyZXIsIGVuZ2luZSwgem9uZSk7XG59XG5jb25zdCBTSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IEFuaW1hdGlvbkJ1aWxkZXIsIHVzZUNsYXNzOiBCcm93c2VyQW5pbWF0aW9uQnVpbGRlciB9LFxuICAgIHsgcHJvdmlkZTogybVBbmltYXRpb25TdHlsZU5vcm1hbGl6ZXIsIHVzZUZhY3Rvcnk6IGluc3RhbnRpYXRlRGVmYXVsdFN0eWxlTm9ybWFsaXplciB9LFxuICAgIHsgcHJvdmlkZTogybVBbmltYXRpb25FbmdpbmUsIHVzZUNsYXNzOiBJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lIH0sIHtcbiAgICAgICAgcHJvdmlkZTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICAgICAgdXNlRmFjdG9yeTogaW5zdGFudGlhdGVSZW5kZXJlckZhY3RvcnksXG4gICAgICAgIGRlcHM6IFvJtURvbVJlbmRlcmVyRmFjdG9yeTIsIMm1QW5pbWF0aW9uRW5naW5lLCBOZ1pvbmVdXG4gICAgfVxuXTtcbi8qKlxuICogU2VwYXJhdGUgcHJvdmlkZXJzIGZyb20gdGhlIGFjdHVhbCBtb2R1bGUgc28gdGhhdCB3ZSBjYW4gZG8gYSBsb2NhbCBtb2RpZmljYXRpb24gaW4gR29vZ2xlMyB0b1xuICogaW5jbHVkZSB0aGVtIGluIHRoZSBCcm93c2VyTW9kdWxlLlxuICovXG5jb25zdCBCUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogQW5pbWF0aW9uRHJpdmVyLCB1c2VGYWN0b3J5OiAoKSA9PiBuZXcgybVXZWJBbmltYXRpb25zRHJpdmVyKCkgfSxcbiAgICB7IHByb3ZpZGU6IEFOSU1BVElPTl9NT0RVTEVfVFlQRSwgdXNlVmFsdWU6ICdCcm93c2VyQW5pbWF0aW9ucycgfSwgLi4uU0hBUkVEX0FOSU1BVElPTl9QUk9WSURFUlNcbl07XG4vKipcbiAqIFNlcGFyYXRlIHByb3ZpZGVycyBmcm9tIHRoZSBhY3R1YWwgbW9kdWxlIHNvIHRoYXQgd2UgY2FuIGRvIGEgbG9jYWwgbW9kaWZpY2F0aW9uIGluIEdvb2dsZTMgdG9cbiAqIGluY2x1ZGUgdGhlbSBpbiB0aGUgQnJvd3NlclRlc3RpbmdNb2R1bGUuXG4gKi9cbmNvbnN0IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyA9IFtcbiAgICB7IHByb3ZpZGU6IEFuaW1hdGlvbkRyaXZlciwgdXNlQ2xhc3M6IMm1Tm9vcEFuaW1hdGlvbkRyaXZlciB9LFxuICAgIHsgcHJvdmlkZTogQU5JTUFUSU9OX01PRFVMRV9UWVBFLCB1c2VWYWx1ZTogJ05vb3BBbmltYXRpb25zJyB9LCAuLi5TSEFSRURfQU5JTUFUSU9OX1BST1ZJREVSU1xuXTtcblxuLyoqXG4gKiBFeHBvcnRzIGBCcm93c2VyTW9kdWxlYCB3aXRoIGFkZGl0aW9uYWwgW2RlcGVuZGVuY3ktaW5qZWN0aW9uIHByb3ZpZGVyc10oZ3VpZGUvZ2xvc3NhcnkjcHJvdmlkZXIpXG4gKiBmb3IgdXNlIHdpdGggYW5pbWF0aW9ucy4gU2VlIFtBbmltYXRpb25zXShndWlkZS9hbmltYXRpb25zKS5cbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIG1vZHVsZSBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgT2JqZWN0IHVzZWQgdG8gY29uZmlndXJlIHRoZSBiZWhhdmlvciBvZiB0aGUgYEJyb3dzZXJBbmltYXRpb25zTW9kdWxlYC5cbiAgICAgKiBAc2VlIGBCcm93c2VyQW5pbWF0aW9uc01vZHVsZUNvbmZpZ2BcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogV2hlbiByZWdpc3RlcmluZyB0aGUgYEJyb3dzZXJBbmltYXRpb25zTW9kdWxlYCwgeW91IGNhbiB1c2UgdGhlIGB3aXRoQ29uZmlnYFxuICAgICAqIGZ1bmN0aW9uIGFzIGZvbGxvd3M6XG4gICAgICogYGBgXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtCcm93c2VyQW5pbWF0aW9uc01vZHVsZS53aXRoQ29uZmlnKGNvbmZpZyldXG4gICAgICogfSlcbiAgICAgKiBjbGFzcyBNeU5nTW9kdWxlIHt9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc3RhdGljIHdpdGhDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IGNvbmZpZy5kaXNhYmxlQW5pbWF0aW9ucyA/IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUyA6XG4gICAgICAgICAgICAgICAgQlJPV1NFUl9BTklNQVRJT05TX1BST1ZJREVSU1xuICAgICAgICB9O1xuICAgIH1cbn1cbkJyb3dzZXJBbmltYXRpb25zTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkJyb3dzZXJBbmltYXRpb25zTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgZXhwb3J0czogW0Jyb3dzZXJNb2R1bGVdIH0pO1xuQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJyb3dzZXJBbmltYXRpb25zTW9kdWxlLCBwcm92aWRlcnM6IEJST1dTRVJfQU5JTUFUSU9OU19QUk9WSURFUlMsIGltcG9ydHM6IFtCcm93c2VyTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyQW5pbWF0aW9uc01vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0Jyb3dzZXJNb2R1bGVdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IEJST1dTRVJfQU5JTUFUSU9OU19QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIFJldHVybnMgdGhlIHNldCBvZiBbZGVwZW5kZW5jeS1pbmplY3Rpb24gcHJvdmlkZXJzXShndWlkZS9nbG9zc2FyeSNwcm92aWRlcilcbiAqIHRvIGVuYWJsZSBhbmltYXRpb25zIGluIGFuIGFwcGxpY2F0aW9uLiBTZWUgW2FuaW1hdGlvbnMgZ3VpZGVdKGd1aWRlL2FuaW1hdGlvbnMpXG4gKiB0byBsZWFybiBtb3JlIGFib3V0IGFuaW1hdGlvbnMgaW4gQW5ndWxhci5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFRoZSBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBlbmFibGUgYW5pbWF0aW9ucyBpbiBhbiBhcHBsaWNhdGlvblxuICogYm9vdHN0cmFwcGVkIHVzaW5nIHRoZSBgYm9vdHN0cmFwQXBwbGljYXRpb25gIGZ1bmN0aW9uLiBJbiB0aGlzIHNjZW5hcmlvIHRoZXJlXG4gKiBpcyBubyBuZWVkIHRvIGltcG9ydCB0aGUgYEJyb3dzZXJBbmltYXRpb25zTW9kdWxlYCBOZ01vZHVsZSBhdCBhbGwsIGp1c3QgYWRkXG4gKiBwcm92aWRlcnMgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiB0byB0aGUgYHByb3ZpZGVyc2AgbGlzdCBhcyBzaG93IGJlbG93LlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGJvb3RzdHJhcEFwcGxpY2F0aW9uKFJvb3RDb21wb25lbnQsIHtcbiAqICAgcHJvdmlkZXJzOiBbXG4gKiAgICAgcHJvdmlkZUFuaW1hdGlvbnMoKVxuICogICBdXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gcHJvdmlkZUFuaW1hdGlvbnMoKSB7XG4gICAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGFycmF5IGluIGNhc2UgYW55IGluLXBsYWNlXG4gICAgLy8gYWx0ZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0byB0aGUgYHByb3ZpZGVBbmltYXRpb25zYCBjYWxsIHJlc3VsdHMgaW4gYXBwIGNvZGUuXG4gICAgcmV0dXJuIFsuLi5CUk9XU0VSX0FOSU1BVElPTlNfUFJPVklERVJTXTtcbn1cbi8qKlxuICogQSBudWxsIHBsYXllciB0aGF0IG11c3QgYmUgaW1wb3J0ZWQgdG8gYWxsb3cgZGlzYWJsaW5nIG9mIGFuaW1hdGlvbnMuXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5vb3BBbmltYXRpb25zTW9kdWxlIHtcbn1cbk5vb3BBbmltYXRpb25zTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vb3BBbmltYXRpb25zTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbk5vb3BBbmltYXRpb25zTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOb29wQW5pbWF0aW9uc01vZHVsZSwgZXhwb3J0czogW0Jyb3dzZXJNb2R1bGVdIH0pO1xuTm9vcEFuaW1hdGlvbnNNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vb3BBbmltYXRpb25zTW9kdWxlLCBwcm92aWRlcnM6IEJST1dTRVJfTk9PUF9BTklNQVRJT05TX1BST1ZJREVSUywgaW1wb3J0czogW0Jyb3dzZXJNb2R1bGVdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vb3BBbmltYXRpb25zTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbQnJvd3Nlck1vZHVsZV0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogQlJPV1NFUl9OT09QX0FOSU1BVElPTlNfUFJPVklERVJTLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZXQgb2YgW2RlcGVuZGVuY3ktaW5qZWN0aW9uIHByb3ZpZGVyc10oZ3VpZGUvZ2xvc3NhcnkjcHJvdmlkZXIpXG4gKiB0byBkaXNhYmxlIGFuaW1hdGlvbnMgaW4gYW4gYXBwbGljYXRpb24uIFNlZSBbYW5pbWF0aW9ucyBndWlkZV0oZ3VpZGUvYW5pbWF0aW9ucylcbiAqIHRvIGxlYXJuIG1vcmUgYWJvdXQgYW5pbWF0aW9ucyBpbiBBbmd1bGFyLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogVGhlIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGJvb3RzdHJhcCBhbiBhcHBsaWNhdGlvbiB1c2luZ1xuICogdGhlIGBib290c3RyYXBBcHBsaWNhdGlvbmAgZnVuY3Rpb24sIGJ1dCB5b3UgbmVlZCB0byBkaXNhYmxlIGFuaW1hdGlvbnNcbiAqIChmb3IgZXhhbXBsZSwgd2hlbiBydW5uaW5nIHRlc3RzKS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBib290c3RyYXBBcHBsaWNhdGlvbihSb290Q29tcG9uZW50LCB7XG4gKiAgIHByb3ZpZGVyczogW1xuICogICAgIHByb3ZpZGVOb29wQW5pbWF0aW9ucygpXG4gKiAgIF1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBwcm92aWRlTm9vcEFuaW1hdGlvbnMoKSB7XG4gICAgLy8gUmV0dXJuIGEgY29weSB0byBwcmV2ZW50IGNoYW5nZXMgdG8gdGhlIG9yaWdpbmFsIGFycmF5IGluIGNhc2UgYW55IGluLXBsYWNlXG4gICAgLy8gYWx0ZXJhdGlvbnMgYXJlIHBlcmZvcm1lZCB0byB0aGUgYHByb3ZpZGVOb29wQW5pbWF0aW9uc2AgY2FsbCByZXN1bHRzIGluIGFwcCBjb2RlLlxuICAgIHJldHVybiBbLi4uQlJPV1NFUl9OT09QX0FOSU1BVElPTlNfUFJPVklERVJTXTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgYW5pbWF0aW9uIEFQSXMgb2YgdGhlIGFuaW1hdGlvbiBicm93c2VyIHBhY2thZ2UuXG4gKi9cblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhpcyBwYWNrYWdlLlxuICovXG5cbi8vIFRoaXMgZmlsZSBpcyBub3QgdXNlZCB0byBidWlsZCB0aGlzIG1vZHVsZS4gSXQgaXMgb25seSB1c2VkIGR1cmluZyBlZGl0aW5nXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGUsIE5vb3BBbmltYXRpb25zTW9kdWxlLCBwcm92aWRlQW5pbWF0aW9ucywgcHJvdmlkZU5vb3BBbmltYXRpb25zLCBBbmltYXRpb25SZW5kZXJlciBhcyDJtUFuaW1hdGlvblJlbmRlcmVyLCBBbmltYXRpb25SZW5kZXJlckZhY3RvcnkgYXMgybVBbmltYXRpb25SZW5kZXJlckZhY3RvcnksIEJyb3dzZXJBbmltYXRpb25CdWlsZGVyIGFzIMm1QnJvd3NlckFuaW1hdGlvbkJ1aWxkZXIsIEJyb3dzZXJBbmltYXRpb25GYWN0b3J5IGFzIMm1QnJvd3NlckFuaW1hdGlvbkZhY3RvcnksIEluamVjdGFibGVBbmltYXRpb25FbmdpbmUgYXMgybVJbmplY3RhYmxlQW5pbWF0aW9uRW5naW5lIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25zLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/platform-browser/fesm2020/animations.mjs\n");

/***/ })

}]);