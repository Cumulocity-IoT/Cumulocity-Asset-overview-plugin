"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_ngx-formly_core_fesm2020_ngx-formly-core_mjs"],{

/***/ "./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FORMLY_CONFIG\": function() { return /* binding */ FORMLY_CONFIG; },\n/* harmony export */   \"FieldArrayType\": function() { return /* binding */ FieldArrayType; },\n/* harmony export */   \"FieldType\": function() { return /* binding */ FieldType; },\n/* harmony export */   \"FieldWrapper\": function() { return /* binding */ FieldWrapper; },\n/* harmony export */   \"FormlyConfig\": function() { return /* binding */ FormlyConfig; },\n/* harmony export */   \"FormlyField\": function() { return /* binding */ FormlyField; },\n/* harmony export */   \"FormlyForm\": function() { return /* binding */ FormlyForm; },\n/* harmony export */   \"FormlyFormBuilder\": function() { return /* binding */ FormlyFormBuilder; },\n/* harmony export */   \"FormlyModule\": function() { return /* binding */ FormlyModule; },\n/* harmony export */   \"ɵFormlyAttributes\": function() { return /* binding */ FormlyAttributes; },\n/* harmony export */   \"ɵFormlyGroup\": function() { return /* binding */ FormlyGroup; },\n/* harmony export */   \"ɵFormlyTemplate\": function() { return /* binding */ FormlyTemplate; },\n/* harmony export */   \"ɵFormlyValidationMessage\": function() { return /* binding */ FormlyValidationMessage; },\n/* harmony export */   \"ɵclone\": function() { return /* binding */ clone; },\n/* harmony export */   \"ɵdefineHiddenProp\": function() { return /* binding */ defineHiddenProp; },\n/* harmony export */   \"ɵgetFieldValue\": function() { return /* binding */ getFieldValue; },\n/* harmony export */   \"ɵhasKey\": function() { return /* binding */ hasKey; },\n/* harmony export */   \"ɵobserve\": function() { return /* binding */ observe; },\n/* harmony export */   \"ɵreverseDeepMerge\": function() { return /* binding */ reverseDeepMerge; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/forms */ \"webpack/sharing/consume/default/@angular/forms/@angular/forms\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/platform-browser */ \"webpack/sharing/consume/default/@angular/platform-browser/@angular/platform-browser\");\n\n\n\n\n\n\n\n\n\n\nfunction disableTreeValidityCall(form, callback) {\n    const _updateTreeValidity = form._updateTreeValidity.bind(form);\n    form._updateTreeValidity = () => { };\n    callback();\n    form._updateTreeValidity = _updateTreeValidity;\n}\nfunction getFieldId(formId, field, index) {\n    if (field.id) {\n        return field.id;\n    }\n    let type = field.type;\n    if (!type && field.template) {\n        type = 'template';\n    }\n    if (type instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.Type) {\n        type = type.prototype.constructor.name;\n    }\n    return [formId, type, field.key, index].join('_');\n}\nfunction hasKey(field) {\n    return !isNil(field.key) && field.key !== '';\n}\nfunction getKeyPath(field) {\n    if (!hasKey(field)) {\n        return [];\n    }\n    /* We store the keyPath in the field for performance reasons. This function will be called frequently. */\n    if (field._keyPath?.key !== field.key) {\n        let path = [];\n        if (typeof field.key === 'string') {\n            const key = field.key.indexOf('[') === -1 ? field.key : field.key.replace(/\\[(\\w+)\\]/g, '.$1');\n            path = key.indexOf('.') !== -1 ? key.split('.') : [key];\n        }\n        else if (Array.isArray(field.key)) {\n            path = field.key.slice(0);\n        }\n        else {\n            path = [`${field.key}`];\n        }\n        defineHiddenProp(field, '_keyPath', { key: field.key, path });\n    }\n    return field._keyPath.path.slice(0);\n}\nconst FORMLY_VALIDATORS = ['required', 'pattern', 'minLength', 'maxLength', 'min', 'max'];\nfunction assignFieldValue(field, value) {\n    let paths = getKeyPath(field);\n    if (paths.length === 0) {\n        return;\n    }\n    let root = field;\n    while (root.parent) {\n        root = root.parent;\n        paths = [...getKeyPath(root), ...paths];\n    }\n    if (value === undefined && field.resetOnHide) {\n        const k = paths.pop();\n        const m = paths.reduce((model, path) => model[path] || {}, root.model);\n        delete m[k];\n        return;\n    }\n    assignModelValue(root.model, paths, value);\n}\nfunction assignModelValue(model, paths, value) {\n    for (let i = 0; i < paths.length - 1; i++) {\n        const path = paths[i];\n        if (!model[path] || !isObject(model[path])) {\n            model[path] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n        }\n        model = model[path];\n    }\n    model[paths[paths.length - 1]] = clone(value);\n}\nfunction getFieldValue(field) {\n    let model = field.parent ? field.parent.model : field.model;\n    for (const path of getKeyPath(field)) {\n        if (!model) {\n            return model;\n        }\n        model = model[path];\n    }\n    return model;\n}\nfunction reverseDeepMerge(dest, ...args) {\n    args.forEach((src) => {\n        for (const srcArg in src) {\n            if (isNil(dest[srcArg]) || isBlankString(dest[srcArg])) {\n                dest[srcArg] = clone(src[srcArg]);\n            }\n            else if (objAndSameType(dest[srcArg], src[srcArg])) {\n                reverseDeepMerge(dest[srcArg], src[srcArg]);\n            }\n        }\n    });\n    return dest;\n}\n// check a value is null or undefined\nfunction isNil(value) {\n    return value == null;\n}\nfunction isUndefined(value) {\n    return value === undefined;\n}\nfunction isBlankString(value) {\n    return value === '';\n}\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\nfunction objAndSameType(obj1, obj2) {\n    return (isObject(obj1) &&\n        isObject(obj2) &&\n        Object.getPrototypeOf(obj1) === Object.getPrototypeOf(obj2) &&\n        !(Array.isArray(obj1) || Array.isArray(obj2)));\n}\nfunction isObject(x) {\n    return x != null && typeof x === 'object';\n}\nfunction isPromise(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nfunction clone(value) {\n    if (!isObject(value) ||\n        (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(value) ||\n        value instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef ||\n        /* instanceof SafeHtmlImpl */ value.changingThisBreaksApplicationSecurity ||\n        ['RegExp', 'FileList', 'File', 'Blob'].indexOf(value.constructor.name) !== -1) {\n        return value;\n    }\n    if (value instanceof Set) {\n        return new Set(value);\n    }\n    if (value instanceof Map) {\n        return new Map(value);\n    }\n    // https://github.com/moment/moment/blob/master/moment.js#L252\n    if (value._isAMomentObject && isFunction(value.clone)) {\n        return value.clone();\n    }\n    if (value instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.AbstractControl) {\n        return null;\n    }\n    if (value instanceof Date) {\n        return new Date(value.getTime());\n    }\n    if (Array.isArray(value)) {\n        return value.slice(0).map((v) => clone(v));\n    }\n    // best way to clone a js object maybe\n    // https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\n    const proto = Object.getPrototypeOf(value);\n    let c = Object.create(proto);\n    c = Object.setPrototypeOf(c, proto);\n    // need to make a deep copy so we dont use Object.assign\n    // also Object.assign wont copy property descriptor exactly\n    return Object.keys(value).reduce((newVal, prop) => {\n        const propDesc = Object.getOwnPropertyDescriptor(value, prop);\n        if (propDesc.get) {\n            Object.defineProperty(newVal, prop, propDesc);\n        }\n        else {\n            newVal[prop] = clone(value[prop]);\n        }\n        return newVal;\n    }, c);\n}\nfunction defineHiddenProp(field, prop, defaultValue) {\n    Object.defineProperty(field, prop, { enumerable: false, writable: true, configurable: true });\n    field[prop] = defaultValue;\n}\nfunction observeDeep(source, paths, setFn) {\n    let observers = [];\n    const unsubscribe = () => {\n        observers.forEach((observer) => observer());\n        observers = [];\n    };\n    const observer = observe(source, paths, ({ firstChange, currentValue }) => {\n        !firstChange && setFn();\n        unsubscribe();\n        if (isObject(currentValue) && currentValue.constructor.name === 'Object') {\n            Object.keys(currentValue).forEach((prop) => {\n                observers.push(observeDeep(source, [...paths, prop], setFn));\n            });\n        }\n    });\n    return () => {\n        observer.unsubscribe();\n        unsubscribe();\n    };\n}\nfunction observe(o, paths, setFn) {\n    if (!o._observers) {\n        defineHiddenProp(o, '_observers', {});\n    }\n    let target = o;\n    for (let i = 0; i < paths.length - 1; i++) {\n        if (!target[paths[i]] || !isObject(target[paths[i]])) {\n            target[paths[i]] = /^\\d+$/.test(paths[i + 1]) ? [] : {};\n        }\n        target = target[paths[i]];\n    }\n    const key = paths[paths.length - 1];\n    const prop = paths.join('.');\n    if (!o._observers[prop]) {\n        o._observers[prop] = { value: target[key], onChange: [] };\n    }\n    const state = o._observers[prop];\n    if (target[key] !== state.value) {\n        state.value = target[key];\n    }\n    if (state.onChange.indexOf(setFn) === -1) {\n        state.onChange.push(setFn);\n        setFn({ currentValue: state.value, firstChange: true });\n        if (state.onChange.length >= 1) {\n            const { enumerable } = Object.getOwnPropertyDescriptor(target, key) || { enumerable: true };\n            Object.defineProperty(target, key, {\n                enumerable,\n                configurable: true,\n                get: () => state.value,\n                set: (currentValue) => {\n                    if (currentValue !== state.value) {\n                        const previousValue = state.value;\n                        state.value = currentValue;\n                        state.onChange.forEach((changeFn) => changeFn({ previousValue, currentValue, firstChange: false }));\n                    }\n                },\n            });\n        }\n    }\n    return {\n        setValue(value) {\n            state.value = value;\n        },\n        unsubscribe() {\n            state.onChange = state.onChange.filter((changeFn) => changeFn !== setFn);\n            if (state.onChange.length === 0) {\n                delete o._observers[prop];\n            }\n        },\n    };\n}\nfunction getField(f, key) {\n    key = (Array.isArray(key) ? key.join('.') : key);\n    if (!f.fieldGroup) {\n        return undefined;\n    }\n    for (let i = 0, len = f.fieldGroup.length; i < len; i++) {\n        const c = f.fieldGroup[i];\n        const k = (Array.isArray(c.key) ? c.key.join('.') : c.key);\n        if (k === key) {\n            return c;\n        }\n        if (c.fieldGroup && (isNil(k) || key.indexOf(`${k}.`) === 0)) {\n            const field = getField(c, isNil(k) ? key : key.slice(k.length + 1));\n            if (field) {\n                return field;\n            }\n        }\n    }\n    return undefined;\n}\nfunction markFieldForCheck(field) {\n    field._componentRefs?.forEach((ref) => {\n        // NOTE: we cannot use ref.changeDetectorRef, see https://github.com/ngx-formly/ngx-formly/issues/2191\n        if (ref instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentRef) {\n            const changeDetectorRef = ref.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef);\n            changeDetectorRef.markForCheck();\n        }\n        else {\n            ref.markForCheck();\n        }\n    });\n}\n\n/**\n * An InjectionToken for registering additional formly config options (types, wrappers ...).\n */\nconst FORMLY_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('FORMLY_CONFIG');\n/**\n * Maintains list of formly config options. This can be used to register new field type.\n */\nclass FormlyConfig {\n    constructor() {\n        this.types = {};\n        this.validators = {};\n        this.wrappers = {};\n        this.messages = {};\n        this.extras = {\n            checkExpressionOn: 'modelChange',\n            lazyRender: true,\n            resetFieldOnHide: true,\n            renderFormlyFieldElement: true,\n            showError(field) {\n                return (field.formControl?.invalid &&\n                    (field.formControl?.touched || field.options.parentForm?.submitted || !!field.field.validation?.show));\n            },\n        };\n        this.extensions = {};\n        this.presets = {};\n        this.extensionsByPriority = {};\n    }\n    addConfig(config) {\n        if (config.types) {\n            config.types.forEach((type) => this.setType(type));\n        }\n        if (config.validators) {\n            config.validators.forEach((validator) => this.setValidator(validator));\n        }\n        if (config.wrappers) {\n            config.wrappers.forEach((wrapper) => this.setWrapper(wrapper));\n        }\n        if (config.validationMessages) {\n            config.validationMessages.forEach((validation) => this.addValidatorMessage(validation.name, validation.message));\n        }\n        if (config.extensions) {\n            this.setSortedExtensions(config.extensions);\n        }\n        if (config.extras) {\n            this.extras = { ...this.extras, ...config.extras };\n        }\n        if (config.presets) {\n            this.presets = {\n                ...this.presets,\n                ...config.presets.reduce((acc, curr) => ({ ...acc, [curr.name]: curr.config }), {}),\n            };\n        }\n    }\n    /**\n     * Allows you to specify a custom type which you can use in your field configuration.\n     * You can pass an object of options, or an array of objects of options.\n     */\n    setType(options) {\n        if (Array.isArray(options)) {\n            options.forEach((option) => this.setType(option));\n        }\n        else {\n            if (!this.types[options.name]) {\n                this.types[options.name] = { name: options.name };\n            }\n            ['component', 'extends', 'defaultOptions', 'wrappers'].forEach((prop) => {\n                if (options.hasOwnProperty(prop)) {\n                    this.types[options.name][prop] = options[prop];\n                }\n            });\n        }\n    }\n    getType(name, throwIfNotFound = false) {\n        if (name instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.Type) {\n            return { component: name, name: name.prototype.constructor.name };\n        }\n        if (!this.types[name]) {\n            if (throwIfNotFound) {\n                throw new Error(`[Formly Error] The type \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n            }\n            return null;\n        }\n        this.mergeExtendedType(name);\n        return this.types[name];\n    }\n    /** @ignore */\n    getMergedField(field = {}) {\n        const type = this.getType(field.type);\n        if (!type) {\n            return;\n        }\n        if (type.defaultOptions) {\n            reverseDeepMerge(field, type.defaultOptions);\n        }\n        const extendDefaults = type.extends && this.getType(type.extends).defaultOptions;\n        if (extendDefaults) {\n            reverseDeepMerge(field, extendDefaults);\n        }\n        if (field?.optionsTypes) {\n            field.optionsTypes.forEach((option) => {\n                const defaultOptions = this.getType(option).defaultOptions;\n                if (defaultOptions) {\n                    reverseDeepMerge(field, defaultOptions);\n                }\n            });\n        }\n        const componentRef = this.resolveFieldTypeRef(field);\n        if (componentRef?.instance?.defaultOptions) {\n            reverseDeepMerge(field, componentRef.instance.defaultOptions);\n        }\n        if (!field.wrappers && type.wrappers) {\n            field.wrappers = [...type.wrappers];\n        }\n    }\n    /** @ignore @internal */\n    resolveFieldTypeRef(field = {}) {\n        const type = this.getType(field.type);\n        if (!type) {\n            return null;\n        }\n        if (!type.component || type._componentRef) {\n            return type._componentRef;\n        }\n        const { _viewContainerRef, _injector } = field.options;\n        if (!_viewContainerRef || !_injector) {\n            return null;\n        }\n        const componentRef = _viewContainerRef.createComponent(type.component, { injector: _injector });\n        defineHiddenProp(type, '_componentRef', componentRef);\n        try {\n            componentRef.destroy();\n        }\n        catch (e) {\n            console.error(`An error occurred while destroying the Formly component type \"${field.type}\"`, e);\n        }\n        return type._componentRef;\n    }\n    setWrapper(options) {\n        this.wrappers[options.name] = options;\n        if (options.types) {\n            options.types.forEach((type) => {\n                this.setTypeWrapper(type, options.name);\n            });\n        }\n    }\n    getWrapper(name) {\n        if (name instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.Type) {\n            return { component: name, name: name.prototype.constructor.name };\n        }\n        if (!this.wrappers[name]) {\n            throw new Error(`[Formly Error] The wrapper \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n        }\n        return this.wrappers[name];\n    }\n    /** @ignore */\n    setTypeWrapper(type, name) {\n        if (!this.types[type]) {\n            this.types[type] = {};\n        }\n        if (!this.types[type].wrappers) {\n            this.types[type].wrappers = [];\n        }\n        if (this.types[type].wrappers.indexOf(name) === -1) {\n            this.types[type].wrappers.push(name);\n        }\n    }\n    setValidator(options) {\n        this.validators[options.name] = options;\n    }\n    getValidator(name) {\n        if (!this.validators[name]) {\n            throw new Error(`[Formly Error] The validator \"${name}\" could not be found. Please make sure that is registered through the FormlyModule declaration.`);\n        }\n        return this.validators[name];\n    }\n    addValidatorMessage(name, message) {\n        this.messages[name] = message;\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const deprecated = { minlength: 'minLength', maxlength: 'maxLength' };\n            if (deprecated[name]) {\n                console.warn(`Formly deprecation: passing validation messages key '${name}' is deprecated since v6.0, use '${deprecated[name]}' instead.`);\n                this.messages[deprecated[name]] = message;\n            }\n        }\n    }\n    getValidatorMessage(name) {\n        return this.messages[name];\n    }\n    setSortedExtensions(extensionOptions) {\n        // insert new extensions, grouped by priority\n        extensionOptions.forEach((extensionOption) => {\n            const priority = extensionOption.priority ?? 1;\n            this.extensionsByPriority[priority] = {\n                ...this.extensionsByPriority[priority],\n                [extensionOption.name]: extensionOption.extension,\n            };\n        });\n        // flatten extensions object with sorted keys\n        this.extensions = Object.keys(this.extensionsByPriority)\n            .map(Number)\n            .sort((a, b) => a - b)\n            .reduce((acc, prio) => ({\n            ...acc,\n            ...this.extensionsByPriority[prio],\n        }), {});\n    }\n    mergeExtendedType(name) {\n        if (!this.types[name].extends) {\n            return;\n        }\n        const extendedType = this.getType(this.types[name].extends);\n        if (!this.types[name].component) {\n            this.types[name].component = extendedType.component;\n        }\n        if (!this.types[name].wrappers) {\n            this.types[name].wrappers = extendedType.wrappers;\n        }\n    }\n}\nFormlyConfig.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyConfig, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nFormlyConfig.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyConfig, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyConfig, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\nclass FormlyFormBuilder {\n    constructor(config, injector, viewContainerRef, parentForm) {\n        this.config = config;\n        this.injector = injector;\n        this.viewContainerRef = viewContainerRef;\n        this.parentForm = parentForm;\n    }\n    buildForm(form, fieldGroup = [], model, options) {\n        this.build({ fieldGroup, model, form, options });\n    }\n    build(field) {\n        if (!this.config.extensions.core) {\n            throw new Error('NgxFormly: missing `forRoot()` call. use `forRoot()` when registering the `FormlyModule`.');\n        }\n        if (!field.parent) {\n            this._setOptions(field);\n            disableTreeValidityCall(field.form, () => {\n                this._build(field);\n                const options = field.options;\n                options.checkExpressions?.(field, true);\n                options.detectChanges?.(field);\n            });\n        }\n        else {\n            this._build(field);\n        }\n    }\n    _build(field) {\n        if (!field) {\n            return;\n        }\n        const extensions = Object.values(this.config.extensions);\n        extensions.forEach((extension) => extension.prePopulate?.(field));\n        extensions.forEach((extension) => extension.onPopulate?.(field));\n        field.fieldGroup?.forEach((f) => this._build(f));\n        extensions.forEach((extension) => extension.postPopulate?.(field));\n    }\n    _setOptions(field) {\n        field.form = field.form || new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup({});\n        field.model = field.model || {};\n        field.options = field.options || {};\n        const options = field.options;\n        if (!options._viewContainerRef) {\n            defineHiddenProp(options, '_viewContainerRef', this.viewContainerRef);\n        }\n        if (!options._injector) {\n            defineHiddenProp(options, '_injector', this.injector);\n        }\n        if (!options.build) {\n            options._buildForm = () => {\n                console.warn(`Formly: 'options._buildForm' is deprecated since v6.0, use 'options.build' instead.`);\n                this.build(field);\n            };\n            options.build = (f = field) => {\n                this.build(f);\n                return f;\n            };\n        }\n        if (!options.parentForm && this.parentForm) {\n            defineHiddenProp(options, 'parentForm', this.parentForm);\n            observe(options, ['parentForm', 'submitted'], ({ firstChange }) => {\n                if (!firstChange) {\n                    options.checkExpressions(field);\n                    options.detectChanges(field);\n                }\n            });\n        }\n    }\n}\nFormlyFormBuilder.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFormBuilder, deps: [{ token: FormlyConfig }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, optional: true }, { token: _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroupDirective, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nFormlyFormBuilder.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFormBuilder, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFormBuilder, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: FormlyConfig }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }, { type: _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroupDirective, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; } });\n\nfunction unregisterControl(field, emitEvent = false) {\n    const control = field.formControl;\n    const fieldIndex = control._fields ? control._fields.indexOf(field) : -1;\n    if (fieldIndex !== -1) {\n        control._fields.splice(fieldIndex, 1);\n    }\n    const form = control.parent;\n    if (!form) {\n        return;\n    }\n    const opts = { emitEvent };\n    if (form instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormArray) {\n        const key = form.controls.findIndex((c) => c === control);\n        if (key !== -1) {\n            form.removeAt(key, opts);\n        }\n    }\n    else if (form instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup) {\n        const paths = getKeyPath(field);\n        const key = paths[paths.length - 1];\n        if (form.get([key]) === control) {\n            form.removeControl(key, opts);\n        }\n    }\n    control.setParent(null);\n}\nfunction findControl(field) {\n    if (field.formControl) {\n        return field.formControl;\n    }\n    if (field.shareFormControl === false) {\n        return null;\n    }\n    return field.form?.get(getKeyPath(field));\n}\nfunction registerControl(field, control, emitEvent = false) {\n    control = control || field.formControl;\n    if (!control._fields) {\n        defineHiddenProp(control, '_fields', []);\n    }\n    if (control._fields.indexOf(field) === -1) {\n        control._fields.push(field);\n    }\n    if (!field.formControl && control) {\n        defineHiddenProp(field, 'formControl', control);\n        control.setValidators(null);\n        control.setAsyncValidators(null);\n        field.props.disabled = !!field.props.disabled;\n        const disabledObserver = observe(field, ['props', 'disabled'], ({ firstChange, currentValue }) => {\n            if (!firstChange) {\n                currentValue ? field.formControl.disable() : field.formControl.enable();\n            }\n        });\n        if (control instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormControl) {\n            control.registerOnDisabledChange(disabledObserver.setValue);\n        }\n    }\n    if (!field.form || !hasKey(field)) {\n        return;\n    }\n    let form = field.form;\n    const paths = getKeyPath(field);\n    const value = getFieldValue(field);\n    if (!(isNil(control.value) && isNil(value)) && control.value !== value && control instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormControl) {\n        control.patchValue(value);\n    }\n    for (let i = 0; i < paths.length - 1; i++) {\n        const path = paths[i];\n        if (!form.get([path])) {\n            form.setControl(path, new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup({}), { emitEvent });\n        }\n        form = form.get([path]);\n    }\n    const key = paths[paths.length - 1];\n    if (!field._hide && form.get([key]) !== control) {\n        form.setControl(key, control, { emitEvent });\n    }\n}\nfunction updateValidity(c, onlySelf = false) {\n    const status = c.status;\n    const value = c.value;\n    c.updateValueAndValidity({ emitEvent: false, onlySelf });\n    if (status !== c.status) {\n        c.statusChanges.emit(c.status);\n    }\n    if (value !== c.value) {\n        c.valueChanges.emit(c.value);\n    }\n}\nfunction clearControl(form) {\n    delete form?._fields;\n    form.setValidators(null);\n    form.setAsyncValidators(null);\n    if (form instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup || form instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormArray) {\n        Object.values(form.controls).forEach((c) => clearControl(c));\n    }\n}\n\nclass FormlyTemplate {\n    constructor(ref) {\n        this.ref = ref;\n    }\n    ngOnChanges() {\n        this.name = this.name || 'formly-group';\n    }\n}\nFormlyTemplate.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyTemplate, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nFormlyTemplate.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyTemplate, selector: \"[formlyTemplate]\", inputs: { name: [\"formlyTemplate\", \"name\"] }, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyTemplate, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{ selector: '[formlyTemplate]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef }]; }, propDecorators: { name: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['formlyTemplate']\n            }] } });\n// workarround for https://github.com/angular/angular/issues/43227#issuecomment-904173738\nclass FormlyFieldTemplates {\n}\nFormlyFieldTemplates.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFieldTemplates, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nFormlyFieldTemplates.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFieldTemplates });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyFieldTemplates, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable\n        }] });\n\n/**\n * The `<formly-field>` component is used to render the UI widget (layout + type) of a given `field`.\n */\nclass FormlyField {\n    constructor(config, renderer, _elementRef, hostContainerRef, form) {\n        this.config = config;\n        this.renderer = renderer;\n        this._elementRef = _elementRef;\n        this.hostContainerRef = hostContainerRef;\n        this.form = form;\n        this.hostObservers = [];\n        this.componentRefs = [];\n        this.hooksObservers = [];\n        this.detectFieldBuild = false;\n        this.valueChangesUnsubscribe = () => { };\n    }\n    get containerRef() {\n        return this.config.extras.renderFormlyFieldElement ? this.viewContainerRef : this.hostContainerRef;\n    }\n    get elementRef() {\n        if (this.config.extras.renderFormlyFieldElement) {\n            return this._elementRef;\n        }\n        if (this.componentRefs?.[0] instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentRef) {\n            return this.componentRefs[0].location;\n        }\n        return null;\n    }\n    ngAfterContentInit() {\n        this.triggerHook('afterContentInit');\n    }\n    ngAfterViewInit() {\n        this.triggerHook('afterViewInit');\n    }\n    ngDoCheck() {\n        if (this.detectFieldBuild && this.field && this.field.options) {\n            this.render();\n        }\n    }\n    ngOnInit() {\n        this.triggerHook('onInit');\n    }\n    ngOnChanges(changes) {\n        this.triggerHook('onChanges', changes);\n    }\n    ngOnDestroy() {\n        this.resetRefs(this.field);\n        this.hostObservers.forEach((hostObserver) => hostObserver.unsubscribe());\n        this.hooksObservers.forEach((unsubscribe) => unsubscribe());\n        this.valueChangesUnsubscribe();\n        this.triggerHook('onDestroy');\n    }\n    renderField(containerRef, f, wrappers = []) {\n        if (this.containerRef === containerRef) {\n            this.resetRefs(this.field);\n            this.containerRef.clear();\n            wrappers = this.field?.wrappers;\n        }\n        if (wrappers?.length > 0) {\n            const [wrapper, ...wps] = wrappers;\n            const { component } = this.config.getWrapper(wrapper);\n            const ref = containerRef.createComponent(component);\n            this.attachComponentRef(ref, f);\n            observe(ref.instance, ['fieldComponent'], ({ currentValue, previousValue, firstChange }) => {\n                if (currentValue) {\n                    if (previousValue && previousValue._lContainer === currentValue._lContainer) {\n                        return;\n                    }\n                    const viewRef = previousValue ? previousValue.detach() : null;\n                    if (viewRef && !viewRef.destroyed) {\n                        currentValue.insert(viewRef);\n                    }\n                    else {\n                        this.renderField(currentValue, f, wps);\n                    }\n                    !firstChange && ref.changeDetectorRef.detectChanges();\n                }\n            });\n        }\n        else if (f?.type) {\n            const inlineType = this.form?.templates?.find((ref) => ref.name === f.type);\n            let ref;\n            if (inlineType) {\n                ref = containerRef.createEmbeddedView(inlineType.ref, { $implicit: f });\n            }\n            else {\n                const { component } = this.config.getType(f.type, true);\n                ref = containerRef.createComponent(component);\n            }\n            this.attachComponentRef(ref, f);\n        }\n    }\n    triggerHook(name, changes) {\n        if (name === 'onInit' || (name === 'onChanges' && changes.field && !changes.field.firstChange)) {\n            this.valueChangesUnsubscribe = this.fieldChanges(this.field);\n        }\n        if (this.field?.hooks?.[name]) {\n            if (!changes || changes.field) {\n                const r = this.field.hooks[name](this.field);\n                if ((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(r) && ['onInit', 'afterContentInit', 'afterViewInit'].indexOf(name) !== -1) {\n                    const sub = r.subscribe();\n                    this.hooksObservers.push(() => sub.unsubscribe());\n                }\n            }\n        }\n        if (name === 'onChanges' && changes.field) {\n            this.resetRefs(changes.field.previousValue);\n            this.render();\n        }\n    }\n    attachComponentRef(ref, field) {\n        this.componentRefs.push(ref);\n        field._componentRefs.push(ref);\n        if (ref instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentRef) {\n            Object.assign(ref.instance, { field });\n        }\n    }\n    render() {\n        if (!this.field) {\n            return;\n        }\n        // require Formly build\n        if (!this.field.options) {\n            this.detectFieldBuild = true;\n            return;\n        }\n        this.detectFieldBuild = false;\n        this.hostObservers.forEach((hostObserver) => hostObserver.unsubscribe());\n        this.hostObservers = [\n            observe(this.field, ['hide'], ({ firstChange, currentValue }) => {\n                const containerRef = this.containerRef;\n                if (this.config.extras.lazyRender === false) {\n                    firstChange && this.renderField(containerRef, this.field);\n                    if (!firstChange || (firstChange && currentValue)) {\n                        this.elementRef &&\n                            this.renderer.setStyle(this.elementRef.nativeElement, 'display', currentValue ? 'none' : '');\n                    }\n                }\n                else {\n                    if (currentValue) {\n                        containerRef.clear();\n                        if (this.field.className) {\n                            this.renderer.removeAttribute(this.elementRef.nativeElement, 'class');\n                        }\n                    }\n                    else {\n                        this.renderField(containerRef, this.field);\n                        if (this.field.className) {\n                            this.renderer.setAttribute(this.elementRef.nativeElement, 'class', this.field.className);\n                        }\n                    }\n                }\n                !firstChange && this.field.options.detectChanges(this.field);\n            }),\n            observe(this.field, ['className'], ({ firstChange, currentValue }) => {\n                if ((!firstChange || (firstChange && currentValue)) &&\n                    (!this.config.extras.lazyRender || this.field.hide !== true)) {\n                    this.elementRef && this.renderer.setAttribute(this.elementRef.nativeElement, 'class', currentValue);\n                }\n            }),\n            ...['touched', 'pristine', 'status'].map((prop) => observe(this.field, ['formControl', prop], ({ firstChange }) => !firstChange && markFieldForCheck(this.field))),\n        ];\n    }\n    resetRefs(field) {\n        if (field) {\n            if (field._componentRefs) {\n                field._componentRefs = field._componentRefs.filter((ref) => this.componentRefs.indexOf(ref) === -1);\n            }\n            else {\n                defineHiddenProp(this.field, '_componentRefs', []);\n            }\n        }\n        this.componentRefs = [];\n    }\n    fieldChanges(field) {\n        this.valueChangesUnsubscribe();\n        if (!field) {\n            return () => { };\n        }\n        const subscribes = [\n            observeDeep(field, ['props'], () => field.options.detectChanges(field)),\n            observeDeep(field.options, ['formState'], () => field.options.detectChanges(field)),\n        ];\n        for (const key of Object.keys(field._expressions || {})) {\n            const expressionObserver = observe(field, ['_expressions', key], ({ currentValue, previousValue }) => {\n                if (previousValue?.subscription) {\n                    previousValue.subscription.unsubscribe();\n                    previousValue.subscription = null;\n                }\n                if ((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(currentValue.value$)) {\n                    currentValue.subscription = currentValue.value$.subscribe();\n                }\n            });\n            subscribes.push(() => {\n                if (field._expressions[key]?.subscription) {\n                    field._expressions[key].subscription.unsubscribe();\n                }\n                expressionObserver.unsubscribe();\n            });\n        }\n        for (const path of [['template'], ['fieldGroupClassName'], ['validation', 'show']]) {\n            const fieldObserver = observe(field, path, ({ firstChange }) => !firstChange && field.options.detectChanges(field));\n            subscribes.push(() => fieldObserver.unsubscribe());\n        }\n        if (field.formControl && !field.fieldGroup) {\n            const control = field.formControl;\n            let valueChanges = control.valueChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.distinctUntilChanged)((x, y) => {\n                if (x !== y || Array.isArray(x) || isObject(x)) {\n                    return false;\n                }\n                return true;\n            }));\n            if (control.value !== getFieldValue(field)) {\n                valueChanges = valueChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(control.value));\n            }\n            const { updateOn, debounce } = field.modelOptions;\n            if ((!updateOn || updateOn === 'change') && debounce?.default > 0) {\n                valueChanges = control.valueChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.debounceTime)(debounce.default));\n            }\n            const sub = valueChanges.subscribe((value) => {\n                // workaround for https://github.com/angular/angular/issues/13792\n                if (control._fields?.length > 1 && control instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormControl) {\n                    control.patchValue(value, { emitEvent: false, onlySelf: true });\n                }\n                field.parsers?.forEach((parserFn) => (value = parserFn(value)));\n                if (value !== field.formControl.value) {\n                    field.formControl.setValue(value);\n                    return;\n                }\n                if (hasKey(field)) {\n                    assignFieldValue(field, value);\n                }\n                field.options.fieldChanges.next({ value, field, type: 'valueChanges' });\n            });\n            subscribes.push(() => sub.unsubscribe());\n        }\n        return () => subscribes.forEach((subscribe) => subscribe());\n    }\n}\nFormlyField.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyField, deps: [{ token: FormlyConfig }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }, { token: FormlyFieldTemplates, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nFormlyField.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyField, selector: \"formly-field\", inputs: { field: \"field\" }, viewQueries: [{ propertyName: \"viewContainerRef\", first: true, predicate: [\"container\"], descendants: true, read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }], usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: '<ng-template #container></ng-template>', isInline: true, styles: [\":host:empty{display:none}\\n\"] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyField, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ selector: 'formly-field', template: '<ng-template #container></ng-template>', styles: [\":host:empty{display:none}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: FormlyConfig }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }, { type: FormlyFieldTemplates, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; }, propDecorators: { field: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], viewContainerRef: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,\n                args: ['container', { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }]\n            }] } });\n\n/**\n * The `<form-form>` component is the main container of the form,\n * which takes care of managing the form state\n * and delegates the rendering of each field to `<formly-field>` component.\n */\nclass FormlyForm {\n    constructor(builder, config, ngZone, fieldTemplates) {\n        this.builder = builder;\n        this.config = config;\n        this.ngZone = ngZone;\n        this.fieldTemplates = fieldTemplates;\n        /** Event that is emitted when the model value is changed */\n        this.modelChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this.field = { type: 'formly-group' };\n        this._modelChangeValue = {};\n        this.valueChangesUnsubscribe = () => { };\n    }\n    /** The form instance which allow to track model value and validation status. */\n    set form(form) {\n        this.field.form = form;\n    }\n    get form() {\n        return this.field.form;\n    }\n    /** The model to be represented by the form. */\n    set model(model) {\n        if (this.config.extras.immutable && this._modelChangeValue === model) {\n            return;\n        }\n        this.setField({ model });\n    }\n    get model() {\n        return this.field.model;\n    }\n    /** The field configurations for building the form. */\n    set fields(fieldGroup) {\n        this.setField({ fieldGroup });\n    }\n    get fields() {\n        return this.field.fieldGroup;\n    }\n    /** Options for the form. */\n    set options(options) {\n        this.setField({ options });\n    }\n    get options() {\n        return this.field.options;\n    }\n    set templates(templates) {\n        this.fieldTemplates.templates = templates;\n    }\n    ngDoCheck() {\n        if (this.config.extras.checkExpressionOn === 'changeDetectionCheck') {\n            this.checkExpressionChange();\n        }\n    }\n    ngOnChanges(changes) {\n        if (changes.fields && this.form) {\n            clearControl(this.form);\n        }\n        if (changes.fields || changes.form || (changes.model && this._modelChangeValue !== changes.model.currentValue)) {\n            this.valueChangesUnsubscribe();\n            this.builder.build(this.field);\n            this.valueChangesUnsubscribe = this.valueChanges();\n        }\n    }\n    ngOnDestroy() {\n        this.valueChangesUnsubscribe();\n    }\n    checkExpressionChange() {\n        this.field.options.checkExpressions?.(this.field);\n    }\n    valueChanges() {\n        this.valueChangesUnsubscribe();\n        const sub = this.field.options.fieldChanges\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(({ field, type }) => hasKey(field) && type === 'valueChanges'), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.switchMap)(() => this.ngZone.onStable.asObservable().pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1))))\n            .subscribe(() => this.ngZone.runGuarded(() => {\n            // runGuarded is used to keep in sync the expression changes\n            // https://github.com/ngx-formly/ngx-formly/issues/2095\n            this.checkExpressionChange();\n            this.modelChange.emit((this._modelChangeValue = clone(this.model)));\n        }));\n        return () => sub.unsubscribe();\n    }\n    setField(field) {\n        if (this.config.extras.immutable) {\n            this.field = { ...this.field, ...clone(field) };\n        }\n        else {\n            Object.keys(field).forEach((p) => (this.field[p] = field[p]));\n        }\n    }\n}\nFormlyForm.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyForm, deps: [{ token: FormlyFormBuilder }, { token: FormlyConfig }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: FormlyFieldTemplates }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nFormlyForm.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyForm, selector: \"formly-form\", inputs: { form: \"form\", model: \"model\", fields: \"fields\", options: \"options\" }, outputs: { modelChange: \"modelChange\" }, providers: [FormlyFormBuilder, FormlyFieldTemplates], queries: [{ propertyName: \"templates\", predicate: FormlyTemplate }], usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: '<formly-field [field]=\"field\"></formly-field>', isInline: true, components: [{ type: FormlyField, selector: \"formly-field\", inputs: [\"field\"] }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyForm, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'formly-form',\n                    template: '<formly-field [field]=\"field\"></formly-field>',\n                    providers: [FormlyFormBuilder, FormlyFieldTemplates],\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,\n                }]\n        }], ctorParameters: function () { return [{ type: FormlyFormBuilder }, { type: FormlyConfig }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: FormlyFieldTemplates }]; }, propDecorators: { form: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], model: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], fields: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], options: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], modelChange: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output\n            }], templates: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChildren,\n                args: [FormlyTemplate]\n            }] } });\n\n/**\n * Allow to link the `field` HTML attributes (`id`, `name` ...) and Event attributes (`focus`, `blur` ...) to an element in the DOM.\n */\nclass FormlyAttributes {\n    constructor(renderer, elementRef, _document) {\n        this.renderer = renderer;\n        this.elementRef = elementRef;\n        this.uiAttributesCache = {};\n        /**\n         * HostBinding doesn't register listeners conditionally which may produce some perf issues.\n         *\n         * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1991\n         */\n        this.uiEvents = {\n            listeners: [],\n            events: ['click', 'keyup', 'keydown', 'keypress', 'focus', 'blur', 'change'],\n            callback: (eventName, $event) => {\n                switch (eventName) {\n                    case 'focus':\n                        return this.onFocus($event);\n                    case 'blur':\n                        return this.onBlur($event);\n                    case 'change':\n                        return this.onChange($event);\n                    default:\n                        return this.props[eventName](this.field, $event);\n                }\n            },\n        };\n        this.document = _document;\n    }\n    get props() {\n        return this.field.props || {};\n    }\n    get fieldAttrElements() {\n        return this.field?.['_elementRefs'] || [];\n    }\n    ngOnChanges(changes) {\n        if (changes.field) {\n            this.field.name && this.setAttribute('name', this.field.name);\n            this.uiEvents.listeners.forEach((listener) => listener());\n            this.uiEvents.events.forEach((eventName) => {\n                if (this.props?.[eventName] || ['focus', 'blur', 'change'].indexOf(eventName) !== -1) {\n                    this.uiEvents.listeners.push(this.renderer.listen(this.elementRef.nativeElement, eventName, (e) => this.uiEvents.callback(eventName, e)));\n                }\n            });\n            if (this.props?.attributes) {\n                observe(this.field, ['props', 'attributes'], ({ currentValue, previousValue }) => {\n                    if (previousValue) {\n                        Object.keys(previousValue).forEach((attr) => this.removeAttribute(attr));\n                    }\n                    if (currentValue) {\n                        Object.keys(currentValue).forEach((attr) => {\n                            if (currentValue[attr] != null) {\n                                this.setAttribute(attr, currentValue[attr]);\n                            }\n                        });\n                    }\n                });\n            }\n            this.detachElementRef(changes.field.previousValue);\n            this.attachElementRef(changes.field.currentValue);\n            if (this.fieldAttrElements.length === 1) {\n                !this.id && this.field.id && this.setAttribute('id', this.field.id);\n                this.focusObserver = observe(this.field, ['focus'], ({ currentValue }) => {\n                    this.toggleFocus(currentValue);\n                });\n            }\n        }\n        if (changes.id) {\n            this.setAttribute('id', this.id);\n        }\n    }\n    /**\n     * We need to re-evaluate all the attributes on every change detection cycle, because\n     * by using a HostBinding we run into certain edge cases. This means that whatever logic\n     * is in here has to be super lean or we risk seriously damaging or destroying the performance.\n     *\n     * Formly issue: https://github.com/ngx-formly/ngx-formly/issues/1317\n     * Material issue: https://github.com/angular/components/issues/14024\n     */\n    ngDoCheck() {\n        if (!this.uiAttributes) {\n            const element = this.elementRef.nativeElement;\n            this.uiAttributes = [...FORMLY_VALIDATORS, 'tabindex', 'placeholder', 'readonly', 'disabled', 'step'].filter((attr) => !element.hasAttribute || !element.hasAttribute(attr));\n        }\n        this.uiAttributes.forEach((attr) => {\n            const value = this.props[attr];\n            if (this.uiAttributesCache[attr] !== value &&\n                (!this.props.attributes || !this.props.attributes.hasOwnProperty(attr.toLowerCase()))) {\n                this.uiAttributesCache[attr] = value;\n                if (value || value === 0) {\n                    this.setAttribute(attr, value === true ? attr : `${value}`);\n                }\n                else {\n                    this.removeAttribute(attr);\n                }\n            }\n        });\n    }\n    ngOnDestroy() {\n        this.uiEvents.listeners.forEach((listener) => listener());\n        this.detachElementRef(this.field);\n        this.focusObserver?.unsubscribe();\n    }\n    toggleFocus(value) {\n        const element = this.fieldAttrElements ? this.fieldAttrElements[0] : null;\n        if (!element || !element.nativeElement.focus) {\n            return;\n        }\n        const isFocused = !!this.document.activeElement &&\n            this.fieldAttrElements.some(({ nativeElement }) => this.document.activeElement === nativeElement || nativeElement.contains(this.document.activeElement));\n        if (value && !isFocused) {\n            Promise.resolve().then(() => element.nativeElement.focus());\n        }\n        else if (!value && isFocused) {\n            Promise.resolve().then(() => element.nativeElement.blur());\n        }\n    }\n    onFocus($event) {\n        this.focusObserver?.setValue(true);\n        this.props.focus?.(this.field, $event);\n    }\n    onBlur($event) {\n        this.focusObserver?.setValue(false);\n        this.props.blur?.(this.field, $event);\n    }\n    // handle custom `change` event, for regular ones rely on DOM listener\n    onHostChange($event) {\n        if ($event instanceof Event) {\n            return;\n        }\n        this.onChange($event);\n    }\n    onChange($event) {\n        this.props.change?.(this.field, $event);\n        this.field.formControl?.markAsDirty();\n    }\n    attachElementRef(f) {\n        if (!f) {\n            return;\n        }\n        if (f['_elementRefs']?.indexOf(this.elementRef) === -1) {\n            f['_elementRefs'].push(this.elementRef);\n        }\n        else {\n            defineHiddenProp(f, '_elementRefs', [this.elementRef]);\n        }\n    }\n    detachElementRef(f) {\n        const index = f?.['_elementRefs'] ? this.fieldAttrElements.indexOf(this.elementRef) : -1;\n        if (index !== -1) {\n            f['_elementRefs'].splice(index, 1);\n        }\n    }\n    setAttribute(attr, value) {\n        this.renderer.setAttribute(this.elementRef.nativeElement, attr, value);\n    }\n    removeAttribute(attr) {\n        this.renderer.removeAttribute(this.elementRef.nativeElement, attr);\n    }\n}\nFormlyAttributes.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyAttributes, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nFormlyAttributes.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyAttributes, selector: \"[formlyAttributes]\", inputs: { field: [\"formlyAttributes\", \"field\"], id: \"id\" }, host: { listeners: { \"change\": \"onHostChange($event)\" } }, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyAttributes, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[formlyAttributes]',\n                    host: {\n                        '(change)': 'onHostChange($event)',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.DOCUMENT]\n                }] }]; }, propDecorators: { field: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['formlyAttributes']\n            }], id: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\nclass FieldType {\n    get model() {\n        return this.field.model;\n    }\n    get form() {\n        return this.field.form;\n    }\n    get options() {\n        return this.field.options;\n    }\n    get key() {\n        return this.field.key;\n    }\n    get formControl() {\n        return this.field.formControl;\n    }\n    get props() {\n        return (this.field.props || {});\n    }\n    /** @deprecated Use `props` instead. */\n    get to() {\n        return this.props;\n    }\n    get showError() {\n        return this.options.showError(this);\n    }\n    get id() {\n        return this.field.id;\n    }\n    get formState() {\n        return this.options.formState || {};\n    }\n}\nFieldType.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldType, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nFieldType.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FieldType, inputs: { field: \"field\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldType, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }], propDecorators: { field: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\n/** @ignore */\nclass FormlyGroup extends FieldType {\n}\nFormlyGroup.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyGroup, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nFormlyGroup.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyGroup, selector: \"formly-group\", host: { properties: { \"class\": \"field.fieldGroupClassName || \\\"\\\"\" } }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `\n    <formly-field *ngFor=\"let f of field.fieldGroup\" [field]=\"f\"></formly-field>\n    <ng-content></ng-content>\n  `, isInline: true, components: [{ type: FormlyField, selector: \"formly-field\", inputs: [\"field\"] }], directives: [{ type: _angular_common__WEBPACK_IMPORTED_MODULE_4__.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyGroup, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'formly-group',\n                    template: `\n    <formly-field *ngFor=\"let f of field.fieldGroup\" [field]=\"f\"></formly-field>\n    <ng-content></ng-content>\n  `,\n                    host: {\n                        '[class]': 'field.fieldGroupClassName || \"\"',\n                    },\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,\n                }]\n        }] });\n\n/**\n * The `<formly-validation-message>` component renders the error message of a given `field`.\n */\nclass FormlyValidationMessage {\n    constructor(config) {\n        this.config = config;\n    }\n    ngOnChanges() {\n        const EXPR_VALIDATORS = FORMLY_VALIDATORS.map((v) => `templateOptions.${v}`);\n        this.errorMessage$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.merge)(this.field.formControl.statusChanges, !this.field.options\n            ? (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null)\n            : this.field.options.fieldChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(({ field, type, property }) => {\n                return (field === this.field &&\n                    type === 'expressionChanges' &&\n                    (property.indexOf('validation') !== -1 || EXPR_VALIDATORS.indexOf(property) !== -1));\n            }))).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.startWith)(null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.switchMap)(() => ((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(this.errorMessage) ? this.errorMessage : (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(this.errorMessage))));\n    }\n    get errorMessage() {\n        const fieldForm = this.field.formControl;\n        for (const error in fieldForm.errors) {\n            if (fieldForm.errors.hasOwnProperty(error)) {\n                let message = this.config.getValidatorMessage(error);\n                if (isObject(fieldForm.errors[error])) {\n                    if (fieldForm.errors[error].errorPath) {\n                        return undefined;\n                    }\n                    if (fieldForm.errors[error].message) {\n                        message = fieldForm.errors[error].message;\n                    }\n                }\n                if (this.field.validation?.messages?.[error]) {\n                    message = this.field.validation.messages[error];\n                }\n                if (this.field.validators?.[error]?.message) {\n                    message = this.field.validators[error].message;\n                }\n                if (this.field.asyncValidators?.[error]?.message) {\n                    message = this.field.asyncValidators[error].message;\n                }\n                if (typeof message === 'function') {\n                    return message(fieldForm.errors[error], this.field);\n                }\n                return message;\n            }\n        }\n        return undefined;\n    }\n}\nFormlyValidationMessage.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyValidationMessage, deps: [{ token: FormlyConfig }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nFormlyValidationMessage.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyValidationMessage, selector: \"formly-validation-message\", inputs: { field: \"field\" }, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: '{{ errorMessage$ | async }}', isInline: true, pipes: { \"async\": _angular_common__WEBPACK_IMPORTED_MODULE_4__.AsyncPipe }, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyValidationMessage, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'formly-validation-message',\n                    template: '{{ errorMessage$ | async }}',\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,\n                }]\n        }], ctorParameters: function () { return [{ type: FormlyConfig }]; }, propDecorators: { field: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\nclass FieldArrayType extends FieldType {\n    onPopulate(field) {\n        if (!field.formControl && hasKey(field)) {\n            const control = findControl(field);\n            registerControl(field, control ? control : new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormArray([], { updateOn: field.modelOptions.updateOn }));\n        }\n        field.fieldGroup = field.fieldGroup || [];\n        const length = Array.isArray(field.model) ? field.model.length : 0;\n        if (field.fieldGroup.length > length) {\n            for (let i = field.fieldGroup.length - 1; i >= length; --i) {\n                unregisterControl(field.fieldGroup[i], true);\n                field.fieldGroup.splice(i, 1);\n            }\n        }\n        for (let i = field.fieldGroup.length; i < length; i++) {\n            const f = {\n                ...clone(typeof field.fieldArray === 'function' ? field.fieldArray(field) : field.fieldArray),\n                key: `${i}`,\n            };\n            field.fieldGroup.push(f);\n        }\n    }\n    add(i, initialModel, { markAsDirty } = { markAsDirty: true }) {\n        i = i == null ? this.field.fieldGroup.length : i;\n        if (!this.model) {\n            assignFieldValue(this.field, []);\n        }\n        this.model.splice(i, 0, initialModel ? clone(initialModel) : undefined);\n        this._build();\n        markAsDirty && this.formControl.markAsDirty();\n    }\n    remove(i, { markAsDirty } = { markAsDirty: true }) {\n        this.model.splice(i, 1);\n        const field = this.field.fieldGroup[i];\n        this.field.fieldGroup.splice(i, 1);\n        this.field.fieldGroup.forEach((f, key) => (f.key = `${key}`));\n        unregisterControl(field, true);\n        this._build();\n        markAsDirty && this.formControl.markAsDirty();\n    }\n    _build() {\n        const fields = this.field.formControl._fields ?? [this.field];\n        fields.forEach((f) => this.options.build(f));\n        this.options.fieldChanges.next({\n            field: this.field,\n            value: getFieldValue(this.field),\n            type: 'valueChanges',\n        });\n    }\n}\nFieldArrayType.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldArrayType, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nFieldArrayType.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FieldArrayType, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldArrayType, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }] });\n\nclass FieldWrapper extends FieldType {\n    set _staticContent(content) {\n        this.fieldComponent = content;\n    }\n}\nFieldWrapper.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldWrapper, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nFieldWrapper.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FieldWrapper, viewQueries: [{ propertyName: \"fieldComponent\", first: true, predicate: [\"fieldComponent\"], descendants: true, read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }, { propertyName: \"_staticContent\", first: true, predicate: [\"fieldComponent\"], descendants: true, read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FieldWrapper, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }], propDecorators: { fieldComponent: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,\n                args: ['fieldComponent', { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }]\n            }], _staticContent: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,\n                args: ['fieldComponent', { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }]\n            }] } });\n\n/** @ignore */\nclass FormlyTemplateType extends FieldType {\n    constructor(sanitizer) {\n        super();\n        this.sanitizer = sanitizer;\n        this.innerHtml = {};\n    }\n    get template() {\n        if (this.field && this.field.template !== this.innerHtml.template) {\n            this.innerHtml = {\n                template: this.field.template,\n                content: this.props.safeHtml\n                    ? this.sanitizer.bypassSecurityTrustHtml(this.field.template)\n                    : this.field.template,\n            };\n        }\n        return this.innerHtml.content;\n    }\n}\nFormlyTemplateType.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyTemplateType, deps: [{ token: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__.DomSanitizer }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nFormlyTemplateType.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", type: FormlyTemplateType, selector: \"formly-template\", usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `<div [innerHtml]=\"template\"></div>`, isInline: true, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyTemplateType, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{\n                    selector: 'formly-template',\n                    template: `<div [innerHtml]=\"template\"></div>`,\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_5__.DomSanitizer }]; } });\n\nfunction evalStringExpression(expression, argNames) {\n    try {\n        return Function(...argNames, `return ${expression};`);\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nfunction evalExpression(expression, thisArg, argVal) {\n    if (typeof expression === 'function') {\n        return expression.apply(thisArg, argVal);\n    }\n    else {\n        return expression ? true : false;\n    }\n}\n\nclass FieldExpressionExtension {\n    onPopulate(field) {\n        if (field._expressions) {\n            return;\n        }\n        // cache built expression\n        defineHiddenProp(field, '_expressions', {});\n        observe(field, ['hide'], ({ currentValue, firstChange }) => {\n            defineHiddenProp(field, '_hide', !!currentValue);\n            if (!firstChange || (firstChange && currentValue === true)) {\n                field.props.hidden = currentValue;\n                field.options._hiddenFieldsForCheck.push(field);\n            }\n        });\n        if (field.hideExpression) {\n            observe(field, ['hideExpression'], ({ currentValue: expr }) => {\n                field._expressions.hide = this.parseExpressions(field, 'hide', typeof expr === 'boolean' ? () => expr : expr);\n            });\n        }\n        const evalExpr = (key, expr) => {\n            if (typeof expr === 'string' || isFunction(expr)) {\n                field._expressions[key] = this.parseExpressions(field, key, expr);\n            }\n            else if (expr instanceof rxjs__WEBPACK_IMPORTED_MODULE_2__.Observable) {\n                field._expressions[key] = {\n                    value$: expr.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)((v) => {\n                        this.evalExpr(field, key, v);\n                        field.options.detectChanges(field);\n                    })),\n                };\n            }\n        };\n        field.expressions = field.expressions || {};\n        for (const key of Object.keys(field.expressions)) {\n            observe(field, ['expressions', key], ({ currentValue: expr }) => {\n                evalExpr(key, isFunction(expr) ? (...args) => expr(field, args[3]) : expr);\n            });\n        }\n        field.expressionProperties = field.expressionProperties || {};\n        for (const key of Object.keys(field.expressionProperties)) {\n            observe(field, ['expressionProperties', key], ({ currentValue }) => evalExpr(key, currentValue));\n        }\n    }\n    postPopulate(field) {\n        if (field.parent) {\n            return;\n        }\n        if (!field.options.checkExpressions) {\n            let checkLocked = false;\n            field.options.checkExpressions = (f, ignoreCache) => {\n                if (checkLocked) {\n                    return;\n                }\n                checkLocked = true;\n                const fieldChanged = this.checkExpressions(f, ignoreCache);\n                const options = field.options;\n                options._hiddenFieldsForCheck\n                    .sort((f) => (f.hide ? -1 : 1))\n                    .forEach((f) => this.changeHideState(f, f.hide, !ignoreCache));\n                options._hiddenFieldsForCheck = [];\n                if (fieldChanged) {\n                    this.checkExpressions(field);\n                    if (field.options && field.options.detectChanges) {\n                        field.options.detectChanges(field);\n                    }\n                }\n                checkLocked = false;\n            };\n            field.options._checkField = (f, ignoreCache) => {\n                console.warn(`Formly: 'options._checkField' is deprecated since v6.0, use 'options.checkExpressions' instead.`);\n                field.options.checkExpressions(f, ignoreCache);\n            };\n        }\n    }\n    parseExpressions(field, path, expr) {\n        let parentExpression;\n        if (field.parent && ['hide', 'props.disabled'].includes(path)) {\n            const rootValue = (f) => {\n                return path === 'hide' ? f.hide : f.props.disabled;\n            };\n            parentExpression = () => {\n                let root = field.parent;\n                while (root.parent && !rootValue(root)) {\n                    root = root.parent;\n                }\n                return rootValue(root);\n            };\n        }\n        expr = expr || (() => false);\n        if (typeof expr === 'string') {\n            expr = evalStringExpression(expr, ['model', 'formState', 'field']);\n        }\n        let currentValue;\n        return {\n            callback: (ignoreCache) => {\n                try {\n                    const exprValue = evalExpression(parentExpression ? (...args) => parentExpression(field) || expr(...args) : expr, { field }, [field.model, field.options.formState, field, ignoreCache]);\n                    if (ignoreCache ||\n                        (currentValue !== exprValue &&\n                            (!isObject(exprValue) ||\n                                (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(exprValue) ||\n                                JSON.stringify(exprValue) !== JSON.stringify(currentValue)))) {\n                        currentValue = exprValue;\n                        this.evalExpr(field, path, exprValue);\n                        return true;\n                    }\n                    return false;\n                }\n                catch (error) {\n                    error.message = `[Formly Error] [Expression \"${path}\"] ${error.message}`;\n                    throw error;\n                }\n            },\n        };\n    }\n    checkExpressions(field, ignoreCache = false) {\n        if (!field) {\n            return false;\n        }\n        let fieldChanged = false;\n        if (field._expressions) {\n            for (const key of Object.keys(field._expressions)) {\n                field._expressions[key].callback?.(ignoreCache) && (fieldChanged = true);\n            }\n        }\n        field.fieldGroup?.forEach((f) => this.checkExpressions(f, ignoreCache) && (fieldChanged = true));\n        return fieldChanged;\n    }\n    changeDisabledState(field, value) {\n        if (field.fieldGroup) {\n            field.fieldGroup\n                .filter((f) => !f._expressions.hasOwnProperty('props.disabled'))\n                .forEach((f) => this.changeDisabledState(f, value));\n        }\n        if (hasKey(field) && field.props.disabled !== value) {\n            field.props.disabled = value;\n        }\n    }\n    changeHideState(field, hide, resetOnHide) {\n        if (field.fieldGroup) {\n            field.fieldGroup\n                .filter((f) => !f._expressions.hide)\n                .forEach((f) => this.changeHideState(f, hide, resetOnHide));\n        }\n        if (field.formControl && hasKey(field)) {\n            defineHiddenProp(field, '_hide', !!(hide || field.hide));\n            const c = field.formControl;\n            if (c._fields?.length > 1) {\n                updateValidity(c);\n            }\n            if (hide === true && (!c._fields || c._fields.every((f) => !!f._hide))) {\n                unregisterControl(field, true);\n                if (resetOnHide && field.resetOnHide) {\n                    assignFieldValue(field, undefined);\n                    field.formControl.reset({ value: undefined, disabled: field.formControl.disabled });\n                    field.options.fieldChanges.next({ value: undefined, field, type: 'valueChanges' });\n                    if (field.fieldGroup && field.formControl instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormArray) {\n                        field.fieldGroup.length = 0;\n                    }\n                }\n            }\n            else if (hide === false) {\n                if (field.resetOnHide && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n                    assignFieldValue(field, field.defaultValue);\n                }\n                registerControl(field, undefined, true);\n                if (field.resetOnHide && field.fieldArray && field.fieldGroup?.length !== field.model?.length) {\n                    field.options.build(field);\n                }\n            }\n        }\n        if (field.options.fieldChanges) {\n            field.options.fieldChanges.next({ field, type: 'hidden', value: hide });\n        }\n    }\n    evalExpr(field, prop, value) {\n        try {\n            let target = field;\n            const paths = this._evalExpressionPath(field, prop);\n            const lastIndex = paths.length - 1;\n            for (let i = 0; i < lastIndex; i++) {\n                target = target[paths[i]];\n            }\n            target[paths[lastIndex]] = value;\n        }\n        catch (error) {\n            error.message = `[Formly Error] [Expression \"${prop}\"] ${error.message}`;\n            throw error;\n        }\n        if (['templateOptions.disabled', 'props.disabled'].includes(prop) && hasKey(field)) {\n            this.changeDisabledState(field, value);\n        }\n        if (prop.indexOf('model.') === 0) {\n            const key = prop.replace(/^model\\./, ''), control = field?.key === key ? field.formControl : field.form.get(key);\n            if (control && !(isNil(control.value) && isNil(value)) && control.value !== value) {\n                control.patchValue(value);\n            }\n        }\n        this.emitExpressionChanges(field, prop, value);\n    }\n    emitExpressionChanges(field, property, value) {\n        if (!field.options.fieldChanges) {\n            return;\n        }\n        field.options.fieldChanges.next({\n            field,\n            type: 'expressionChanges',\n            property,\n            value,\n        });\n    }\n    _evalExpressionPath(field, prop) {\n        if (field._expressions[prop] && field._expressions[prop].paths) {\n            return field._expressions[prop].paths;\n        }\n        let paths = [];\n        if (prop.indexOf('[') === -1) {\n            paths = prop.split('.');\n        }\n        else {\n            prop\n                .split(/[[\\]]{1,2}/) // https://stackoverflow.com/a/20198206\n                .filter((p) => p)\n                .forEach((path) => {\n                const arrayPath = path.match(/['|\"](.*?)['|\"]/);\n                if (arrayPath) {\n                    paths.push(arrayPath[1]);\n                }\n                else {\n                    paths.push(...path.split('.').filter((p) => p));\n                }\n            });\n        }\n        if (field._expressions[prop]) {\n            field._expressions[prop].paths = paths;\n        }\n        return paths;\n    }\n}\n\nclass FieldValidationExtension {\n    constructor(config) {\n        this.config = config;\n    }\n    onPopulate(field) {\n        this.initFieldValidation(field, 'validators');\n        this.initFieldValidation(field, 'asyncValidators');\n    }\n    initFieldValidation(field, type) {\n        const validators = [];\n        if (type === 'validators' && !(field.hasOwnProperty('fieldGroup') && !hasKey(field))) {\n            validators.push(this.getPredefinedFieldValidation(field));\n        }\n        if (field[type]) {\n            for (const validatorName of Object.keys(field[type])) {\n                validatorName === 'validation'\n                    ? validators.push(...field[type].validation.map((v) => this.wrapNgValidatorFn(field, v)))\n                    : validators.push(this.wrapNgValidatorFn(field, field[type][validatorName], validatorName));\n            }\n        }\n        defineHiddenProp(field, '_' + type, validators);\n    }\n    getPredefinedFieldValidation(field) {\n        let VALIDATORS = [];\n        FORMLY_VALIDATORS.forEach((opt) => observe(field, ['props', opt], ({ currentValue, firstChange }) => {\n            VALIDATORS = VALIDATORS.filter((o) => o !== opt);\n            if (currentValue != null && currentValue !== false) {\n                VALIDATORS.push(opt);\n            }\n            if (!firstChange && field.formControl) {\n                updateValidity(field.formControl);\n            }\n        }));\n        return (control) => {\n            if (VALIDATORS.length === 0) {\n                return null;\n            }\n            return _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.compose(VALIDATORS.map((opt) => () => {\n                const value = field.props[opt];\n                switch (opt) {\n                    case 'required':\n                        return _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.required(control);\n                    case 'pattern':\n                        return _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.pattern(value)(control);\n                    case 'minLength':\n                        const minLengthResult = _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.minLength(value)(control);\n                        const minLengthKey = this.config.getValidatorMessage('minlength') || field.validation?.messages?.minlength\n                            ? 'minlength'\n                            : 'minLength';\n                        return minLengthResult ? { [minLengthKey]: minLengthResult.minlength } : null;\n                    case 'maxLength':\n                        const maxLengthResult = _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.maxLength(value)(control);\n                        const maxLengthKey = this.config.getValidatorMessage('maxlength') || field.validation?.messages?.maxlength\n                            ? 'maxlength'\n                            : 'maxLength';\n                        return maxLengthResult ? { [maxLengthKey]: maxLengthResult.maxlength } : null;\n                    case 'min':\n                        return _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.min(value)(control);\n                    case 'max':\n                        return _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.max(value)(control);\n                    default:\n                        return null;\n                }\n            }))(control);\n        };\n    }\n    wrapNgValidatorFn(field, validator, validatorName) {\n        let validatorOption;\n        if (typeof validator === 'string') {\n            validatorOption = clone(this.config.getValidator(validator));\n        }\n        if (typeof validator === 'object' && validator.name) {\n            validatorOption = clone(this.config.getValidator(validator.name));\n            if (validator.options) {\n                validatorOption.options = validator.options;\n            }\n        }\n        if (typeof validator === 'object' && validator.expression) {\n            const { expression, ...options } = validator;\n            validatorOption = {\n                name: validatorName,\n                validation: expression,\n                options: Object.keys(options).length > 0 ? options : null,\n            };\n        }\n        if (typeof validator === 'function') {\n            validatorOption = {\n                name: validatorName,\n                validation: validator,\n            };\n        }\n        return (control) => {\n            const errors = validatorOption.validation(control, field, validatorOption.options);\n            if (isPromise(errors)) {\n                return errors.then((v) => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption));\n            }\n            if ((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.isObservable)(errors)) {\n                return errors.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)((v) => this.handleAsyncResult(field, validatorName ? !!v : v, validatorOption)));\n            }\n            return this.handleResult(field, validatorName ? !!errors : errors, validatorOption);\n        };\n    }\n    handleAsyncResult(field, errors, options) {\n        // workaround for https://github.com/angular/angular/issues/13200\n        field.options.detectChanges(field);\n        return this.handleResult(field, errors, options);\n    }\n    handleResult(field, errors, { name, options }) {\n        if (typeof errors === 'boolean') {\n            errors = errors ? null : { [name]: options ? options : true };\n        }\n        const ctrl = field.formControl;\n        ctrl?._childrenErrors?.[name]?.();\n        if (isObject(errors)) {\n            Object.keys(errors).forEach((name) => {\n                const errorPath = errors[name].errorPath ? errors[name].errorPath : options?.errorPath;\n                const childCtrl = errorPath ? field.formControl.get(errorPath) : null;\n                if (childCtrl) {\n                    const { errorPath: _errorPath, ...opts } = errors[name];\n                    childCtrl.setErrors({ ...(childCtrl.errors || {}), [name]: opts });\n                    !ctrl._childrenErrors && defineHiddenProp(ctrl, '_childrenErrors', {});\n                    ctrl._childrenErrors[name] = () => {\n                        const { [name]: _toDelete, ...childErrors } = childCtrl.errors || {};\n                        childCtrl.setErrors(Object.keys(childErrors).length === 0 ? null : childErrors);\n                    };\n                }\n            });\n        }\n        return errors;\n    }\n}\n\nclass FieldFormExtension {\n    prePopulate(field) {\n        if (!this.root) {\n            this.root = field;\n        }\n        if (field.parent) {\n            Object.defineProperty(field, 'form', {\n                get: () => field.parent.formControl,\n                configurable: true,\n            });\n        }\n    }\n    onPopulate(field) {\n        if (field.hasOwnProperty('fieldGroup') && !hasKey(field)) {\n            defineHiddenProp(field, 'formControl', field.form);\n        }\n        else {\n            this.addFormControl(field);\n        }\n    }\n    postPopulate(field) {\n        if (this.root !== field) {\n            return;\n        }\n        this.root = null;\n        const markForCheck = this.setValidators(field);\n        if (markForCheck && field.parent) {\n            let parent = field.parent;\n            while (parent) {\n                if (hasKey(parent) || !parent.parent) {\n                    updateValidity(parent.formControl, true);\n                }\n                parent = parent.parent;\n            }\n        }\n    }\n    addFormControl(field) {\n        let control = findControl(field);\n        if (!control) {\n            const controlOptions = { updateOn: field.modelOptions.updateOn };\n            if (field.fieldGroup) {\n                control = new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup({}, controlOptions);\n            }\n            else {\n                const value = hasKey(field) ? getFieldValue(field) : field.defaultValue;\n                control = new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormControl({ value, disabled: false }, { ...controlOptions, initialValueIsDefault: true });\n            }\n        }\n        registerControl(field, control);\n    }\n    setValidators(field, disabled = false) {\n        if (disabled === false && hasKey(field) && field.props?.disabled) {\n            disabled = true;\n        }\n        let markForCheck = false;\n        field.fieldGroup?.forEach((f) => f && this.setValidators(f, disabled) && (markForCheck = true));\n        if (hasKey(field) || !field.parent || (!hasKey(field) && !field.fieldGroup)) {\n            const { formControl: c } = field;\n            if (c) {\n                if (hasKey(field) && c instanceof _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormControl) {\n                    if (disabled && c.enabled) {\n                        c.disable({ emitEvent: false, onlySelf: true });\n                        markForCheck = true;\n                    }\n                    if (!disabled && c.disabled) {\n                        c.enable({ emitEvent: false, onlySelf: true });\n                        markForCheck = true;\n                    }\n                }\n                if (null === c.validator || null === c.asyncValidator) {\n                    c.setValidators(() => {\n                        const v = _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.compose(this.mergeValidators(field, '_validators'));\n                        return v ? v(c) : null;\n                    });\n                    c.setAsyncValidators(() => {\n                        const v = _angular_forms__WEBPACK_IMPORTED_MODULE_1__.Validators.composeAsync(this.mergeValidators(field, '_asyncValidators'));\n                        return v ? v(c) : (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);\n                    });\n                    markForCheck = true;\n                }\n                if (markForCheck) {\n                    updateValidity(c, true);\n                    // update validity of `FormGroup` instance created by field with nested key.\n                    let parent = c.parent;\n                    for (let i = 1; i < getKeyPath(field).length; i++) {\n                        if (parent) {\n                            updateValidity(parent, true);\n                            parent = parent.parent;\n                        }\n                    }\n                }\n            }\n        }\n        return markForCheck;\n    }\n    mergeValidators(field, type) {\n        const validators = [];\n        const c = field.formControl;\n        if (c?._fields?.length > 1) {\n            c._fields\n                .filter((f) => !f._hide)\n                .forEach((f) => validators.push(...f[type]));\n        }\n        else if (field[type]) {\n            validators.push(...field[type]);\n        }\n        if (field.fieldGroup) {\n            field.fieldGroup\n                .filter((f) => f?.fieldGroup && !hasKey(f))\n                .forEach((f) => validators.push(...this.mergeValidators(f, type)));\n        }\n        return validators;\n    }\n}\n\nclass CoreExtension {\n    constructor(config) {\n        this.config = config;\n        this.formId = 0;\n    }\n    prePopulate(field) {\n        const root = field.parent;\n        this.initRootOptions(field);\n        this.initFieldProps(field);\n        if (root) {\n            Object.defineProperty(field, 'options', { get: () => root.options, configurable: true });\n            Object.defineProperty(field, 'model', {\n                get: () => (hasKey(field) && field.fieldGroup ? getFieldValue(field) : root.model),\n                configurable: true,\n            });\n        }\n        Object.defineProperty(field, 'get', {\n            value: (key) => getField(field, key),\n            configurable: true,\n        });\n        this.getFieldComponentInstance(field).prePopulate?.(field);\n    }\n    onPopulate(field) {\n        this.initFieldOptions(field);\n        this.getFieldComponentInstance(field).onPopulate?.(field);\n        if (field.fieldGroup) {\n            field.fieldGroup.forEach((f, index) => {\n                if (f) {\n                    Object.defineProperty(f, 'parent', { get: () => field, configurable: true });\n                    Object.defineProperty(f, 'index', { get: () => index, configurable: true });\n                }\n                this.formId++;\n            });\n        }\n    }\n    postPopulate(field) {\n        this.getFieldComponentInstance(field).postPopulate?.(field);\n    }\n    initFieldProps(field) {\n        field.props ?? (field.props = field.templateOptions);\n        Object.defineProperty(field, 'templateOptions', {\n            get: () => field.props,\n            set: (props) => (field.props = props),\n            configurable: true,\n        });\n    }\n    initRootOptions(field) {\n        if (field.parent) {\n            return;\n        }\n        const options = field.options;\n        field.options.formState = field.options.formState || {};\n        if (!options.showError) {\n            options.showError = this.config.extras.showError;\n        }\n        if (!options.fieldChanges) {\n            defineHiddenProp(options, 'fieldChanges', new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject());\n        }\n        if (!options._hiddenFieldsForCheck) {\n            options._hiddenFieldsForCheck = [];\n        }\n        options._markForCheck = (f) => {\n            console.warn(`Formly: 'options._markForCheck' is deprecated since v6.0, use 'options.detectChanges' instead.`);\n            options.detectChanges(f);\n        };\n        options.detectChanges = (f) => {\n            if (f._componentRefs) {\n                f.options.checkExpressions(f);\n                markFieldForCheck(f);\n            }\n            f.fieldGroup?.forEach((f) => f && options.detectChanges(f));\n        };\n        options.resetModel = (model) => {\n            model = clone(model ?? options._initialModel);\n            if (field.model) {\n                Object.keys(field.model).forEach((k) => delete field.model[k]);\n                Object.assign(field.model, model || {});\n            }\n            options.build(field);\n            field.form.reset(field.model);\n            if (options.parentForm && options.parentForm.control === field.formControl) {\n                options.parentForm.submitted = false;\n            }\n        };\n        options.updateInitialValue = (model) => (options._initialModel = clone(model ?? field.model));\n        field.options.updateInitialValue();\n    }\n    initFieldOptions(field) {\n        reverseDeepMerge(field, {\n            id: getFieldId(`formly_${this.formId}`, field, field.index),\n            hooks: {},\n            modelOptions: {},\n            validation: { messages: {} },\n            props: !field.type || !hasKey(field)\n                ? {}\n                : {\n                    label: '',\n                    placeholder: '',\n                    disabled: false,\n                },\n        });\n        if (this.config.extras.resetFieldOnHide && field.resetOnHide !== false) {\n            field.resetOnHide = true;\n        }\n        if (field.type !== 'formly-template' &&\n            (field.template || field.expressions?.template || field.expressionProperties?.template)) {\n            field.type = 'formly-template';\n        }\n        if (!field.type && field.fieldGroup) {\n            field.type = 'formly-group';\n        }\n        if (field.type) {\n            this.config.getMergedField(field);\n        }\n        if (hasKey(field) && !isUndefined(field.defaultValue) && isUndefined(getFieldValue(field))) {\n            const isHidden = (f) => f.hide || f.expressions?.hide || f.hideExpression;\n            let setDefaultValue = !field.resetOnHide || !isHidden(field);\n            if (!isHidden(field) && field.resetOnHide) {\n                let parent = field.parent;\n                while (parent && !isHidden(parent)) {\n                    parent = parent.parent;\n                }\n                setDefaultValue = !parent || !isHidden(parent);\n            }\n            if (setDefaultValue) {\n                assignFieldValue(field, field.defaultValue);\n            }\n        }\n        field.wrappers = field.wrappers || [];\n    }\n    getFieldComponentInstance(field) {\n        const componentRefInstance = () => {\n            let componentRef = this.config.resolveFieldTypeRef(field);\n            const fieldComponentRef = field._componentRefs?.slice(-1)[0];\n            if (fieldComponentRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ComponentRef &&\n                fieldComponentRef?.componentType === componentRef?.componentType) {\n                componentRef = fieldComponentRef;\n            }\n            return componentRef?.instance;\n        };\n        if (!field._proxyInstance) {\n            defineHiddenProp(field, '_proxyInstance', new Proxy({}, {\n                get: (_, prop) => componentRefInstance()?.[prop],\n                set: (_, prop, value) => (componentRefInstance()[prop] = value),\n            }));\n        }\n        return field._proxyInstance;\n    }\n}\n\nfunction defaultFormlyConfig(config) {\n    return {\n        types: [\n            { name: 'formly-group', component: FormlyGroup },\n            { name: 'formly-template', component: FormlyTemplateType },\n        ],\n        extensions: [\n            { name: 'core', extension: new CoreExtension(config), priority: -250 },\n            { name: 'field-validation', extension: new FieldValidationExtension(config), priority: -200 },\n            { name: 'field-form', extension: new FieldFormExtension(), priority: -150 },\n            { name: 'field-expression', extension: new FieldExpressionExtension(), priority: -100 },\n        ],\n    };\n}\nclass FormlyModule {\n    constructor(configService, configs = []) {\n        if (!configs) {\n            return;\n        }\n        configs.forEach((config) => configService.addConfig(config));\n    }\n    static forRoot(config = {}) {\n        return {\n            ngModule: FormlyModule,\n            providers: [\n                { provide: FORMLY_CONFIG, multi: true, useFactory: defaultFormlyConfig, deps: [FormlyConfig] },\n                { provide: FORMLY_CONFIG, useValue: config, multi: true },\n                FormlyConfig,\n                FormlyFormBuilder,\n            ],\n        };\n    }\n    static forChild(config = {}) {\n        return {\n            ngModule: FormlyModule,\n            providers: [\n                { provide: FORMLY_CONFIG, multi: true, useFactory: defaultFormlyConfig, deps: [FormlyConfig] },\n                { provide: FORMLY_CONFIG, useValue: config, multi: true },\n                FormlyFormBuilder,\n            ],\n        };\n    }\n}\nFormlyModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyModule, deps: [{ token: FormlyConfig }, { token: FORMLY_CONFIG, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nFormlyModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyModule, declarations: [FormlyTemplate,\n        FormlyForm,\n        FormlyField,\n        FormlyAttributes,\n        FormlyGroup,\n        FormlyValidationMessage,\n        FormlyTemplateType], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule], exports: [FormlyTemplate, FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage] });\nFormlyModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyModule, imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule]] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    declarations: [\n                        FormlyTemplate,\n                        FormlyForm,\n                        FormlyField,\n                        FormlyAttributes,\n                        FormlyGroup,\n                        FormlyValidationMessage,\n                        FormlyTemplateType,\n                    ],\n                    exports: [FormlyTemplate, FormlyForm, FormlyField, FormlyAttributes, FormlyGroup, FormlyValidationMessage],\n                    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_4__.CommonModule],\n                }]\n        }], ctorParameters: function () { return [{ type: FormlyConfig }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [FORMLY_CONFIG]\n                }] }]; } });\n\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=ngx-formly-core.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5neC1mb3JtbHkvY29yZS9mZXNtMjAyMC9uZ3gtZm9ybWx5LWNvcmUubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQG5neC1mb3JtbHkvY29yZS9mZXNtMjAyMC9uZ3gtZm9ybWx5LWNvcmUubWpzP2Q5MTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUeXBlLCBUZW1wbGF0ZVJlZiwgQ29tcG9uZW50UmVmLCBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0aW9uVG9rZW4sIEluamVjdGFibGUsIE9wdGlvbmFsLCBEaXJlY3RpdmUsIElucHV0LCBWaWV3Q29udGFpbmVyUmVmLCBDb21wb25lbnQsIFZpZXdDaGlsZCwgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgT3V0cHV0LCBDb250ZW50Q2hpbGRyZW4sIEluamVjdCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIGkyIGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgRm9ybUdyb3VwLCBGb3JtQXJyYXksIEZvcm1Db250cm9sLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBtZXJnZSwgb2YsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBzdGFydFdpdGgsIGRlYm91bmNlVGltZSwgZmlsdGVyLCBzd2l0Y2hNYXAsIHRha2UsIHRhcCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0ICogYXMgaTIkMSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRE9DVU1FTlQsIENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBpMSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcblxuZnVuY3Rpb24gZGlzYWJsZVRyZWVWYWxpZGl0eUNhbGwoZm9ybSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBfdXBkYXRlVHJlZVZhbGlkaXR5ID0gZm9ybS5fdXBkYXRlVHJlZVZhbGlkaXR5LmJpbmQoZm9ybSk7XG4gICAgZm9ybS5fdXBkYXRlVHJlZVZhbGlkaXR5ID0gKCkgPT4geyB9O1xuICAgIGNhbGxiYWNrKCk7XG4gICAgZm9ybS5fdXBkYXRlVHJlZVZhbGlkaXR5ID0gX3VwZGF0ZVRyZWVWYWxpZGl0eTtcbn1cbmZ1bmN0aW9uIGdldEZpZWxkSWQoZm9ybUlkLCBmaWVsZCwgaW5kZXgpIHtcbiAgICBpZiAoZmllbGQuaWQpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmlkO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IGZpZWxkLnR5cGU7XG4gICAgaWYgKCF0eXBlICYmIGZpZWxkLnRlbXBsYXRlKSB7XG4gICAgICAgIHR5cGUgPSAndGVtcGxhdGUnO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBbZm9ybUlkLCB0eXBlLCBmaWVsZC5rZXksIGluZGV4XS5qb2luKCdfJyk7XG59XG5mdW5jdGlvbiBoYXNLZXkoZmllbGQpIHtcbiAgICByZXR1cm4gIWlzTmlsKGZpZWxkLmtleSkgJiYgZmllbGQua2V5ICE9PSAnJztcbn1cbmZ1bmN0aW9uIGdldEtleVBhdGgoZmllbGQpIHtcbiAgICBpZiAoIWhhc0tleShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKiBXZSBzdG9yZSB0aGUga2V5UGF0aCBpbiB0aGUgZmllbGQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgZnJlcXVlbnRseS4gKi9cbiAgICBpZiAoZmllbGQuX2tleVBhdGg/LmtleSAhPT0gZmllbGQua2V5KSB7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGQua2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZmllbGQua2V5LmluZGV4T2YoJ1snKSA9PT0gLTEgPyBmaWVsZC5rZXkgOiBmaWVsZC5rZXkucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csICcuJDEnKTtcbiAgICAgICAgICAgIHBhdGggPSBrZXkuaW5kZXhPZignLicpICE9PSAtMSA/IGtleS5zcGxpdCgnLicpIDogW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZC5rZXkpKSB7XG4gICAgICAgICAgICBwYXRoID0gZmllbGQua2V5LnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IFtgJHtmaWVsZC5rZXl9YF07XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChmaWVsZCwgJ19rZXlQYXRoJywgeyBrZXk6IGZpZWxkLmtleSwgcGF0aCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLl9rZXlQYXRoLnBhdGguc2xpY2UoMCk7XG59XG5jb25zdCBGT1JNTFlfVkFMSURBVE9SUyA9IFsncmVxdWlyZWQnLCAncGF0dGVybicsICdtaW5MZW5ndGgnLCAnbWF4TGVuZ3RoJywgJ21pbicsICdtYXgnXTtcbmZ1bmN0aW9uIGFzc2lnbkZpZWxkVmFsdWUoZmllbGQsIHZhbHVlKSB7XG4gICAgbGV0IHBhdGhzID0gZ2V0S2V5UGF0aChmaWVsZCk7XG4gICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByb290ID0gZmllbGQ7XG4gICAgd2hpbGUgKHJvb3QucGFyZW50KSB7XG4gICAgICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgICAgICAgcGF0aHMgPSBbLi4uZ2V0S2V5UGF0aChyb290KSwgLi4ucGF0aHNdO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBmaWVsZC5yZXNldE9uSGlkZSkge1xuICAgICAgICBjb25zdCBrID0gcGF0aHMucG9wKCk7XG4gICAgICAgIGNvbnN0IG0gPSBwYXRocy5yZWR1Y2UoKG1vZGVsLCBwYXRoKSA9PiBtb2RlbFtwYXRoXSB8fCB7fSwgcm9vdC5tb2RlbCk7XG4gICAgICAgIGRlbGV0ZSBtW2tdO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFzc2lnbk1vZGVsVmFsdWUocm9vdC5tb2RlbCwgcGF0aHMsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzc2lnbk1vZGVsVmFsdWUobW9kZWwsIHBhdGhzLCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgaWYgKCFtb2RlbFtwYXRoXSB8fCAhaXNPYmplY3QobW9kZWxbcGF0aF0pKSB7XG4gICAgICAgICAgICBtb2RlbFtwYXRoXSA9IC9eXFxkKyQvLnRlc3QocGF0aHNbaSArIDFdKSA/IFtdIDoge307XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwgPSBtb2RlbFtwYXRoXTtcbiAgICB9XG4gICAgbW9kZWxbcGF0aHNbcGF0aHMubGVuZ3RoIC0gMV1dID0gY2xvbmUodmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0RmllbGRWYWx1ZShmaWVsZCkge1xuICAgIGxldCBtb2RlbCA9IGZpZWxkLnBhcmVudCA/IGZpZWxkLnBhcmVudC5tb2RlbCA6IGZpZWxkLm1vZGVsO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBnZXRLZXlQYXRoKGZpZWxkKSkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwgPSBtb2RlbFtwYXRoXTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xufVxuZnVuY3Rpb24gcmV2ZXJzZURlZXBNZXJnZShkZXN0LCAuLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKChzcmMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzcmNBcmcgaW4gc3JjKSB7XG4gICAgICAgICAgICBpZiAoaXNOaWwoZGVzdFtzcmNBcmddKSB8fCBpc0JsYW5rU3RyaW5nKGRlc3Rbc3JjQXJnXSkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W3NyY0FyZ10gPSBjbG9uZShzcmNbc3JjQXJnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmpBbmRTYW1lVHlwZShkZXN0W3NyY0FyZ10sIHNyY1tzcmNBcmddKSkge1xuICAgICAgICAgICAgICAgIHJldmVyc2VEZWVwTWVyZ2UoZGVzdFtzcmNBcmddLCBzcmNbc3JjQXJnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdDtcbn1cbi8vIGNoZWNrIGEgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG59XG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNCbGFua1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIG9iakFuZFNhbWVUeXBlKG9iajEsIG9iajIpIHtcbiAgICByZXR1cm4gKGlzT2JqZWN0KG9iajEpICYmXG4gICAgICAgIGlzT2JqZWN0KG9iajIpICYmXG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmoxKSA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iajIpICYmXG4gICAgICAgICEoQXJyYXkuaXNBcnJheShvYmoxKSB8fCBBcnJheS5pc0FycmF5KG9iajIpKSk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgaXNPYnNlcnZhYmxlKHZhbHVlKSB8fFxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmIHx8XG4gICAgICAgIC8qIGluc3RhbmNlb2YgU2FmZUh0bWxJbXBsICovIHZhbHVlLmNoYW5naW5nVGhpc0JyZWFrc0FwcGxpY2F0aW9uU2VjdXJpdHkgfHxcbiAgICAgICAgWydSZWdFeHAnLCAnRmlsZUxpc3QnLCAnRmlsZScsICdCbG9iJ10uaW5kZXhPZih2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAodmFsdWUpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9ibG9iL21hc3Rlci9tb21lbnQuanMjTDI1MlxuICAgIGlmICh2YWx1ZS5faXNBTW9tZW50T2JqZWN0ICYmIGlzRnVuY3Rpb24odmFsdWUuY2xvbmUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jbG9uZSgpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdENvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCkubWFwKCh2KSA9PiBjbG9uZSh2KSk7XG4gICAgfVxuICAgIC8vIGJlc3Qgd2F5IHRvIGNsb25lIGEganMgb2JqZWN0IG1heWJlXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDE0NzQ5ODYvaG93LXRvLWNsb25lLWEtamF2YXNjcmlwdC1lczYtY2xhc3MtaW5zdGFuY2VcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgbGV0IGMgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICBjID0gT2JqZWN0LnNldFByb3RvdHlwZU9mKGMsIHByb3RvKTtcbiAgICAvLyBuZWVkIHRvIG1ha2UgYSBkZWVwIGNvcHkgc28gd2UgZG9udCB1c2UgT2JqZWN0LmFzc2lnblxuICAgIC8vIGFsc28gT2JqZWN0LmFzc2lnbiB3b250IGNvcHkgcHJvcGVydHkgZGVzY3JpcHRvciBleGFjdGx5XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoKG5ld1ZhbCwgcHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIHByb3ApO1xuICAgICAgICBpZiAocHJvcERlc2MuZ2V0KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3VmFsLCBwcm9wLCBwcm9wRGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWxbcHJvcF0gPSBjbG9uZSh2YWx1ZVtwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9LCBjKTtcbn1cbmZ1bmN0aW9uIGRlZmluZUhpZGRlblByb3AoZmllbGQsIHByb3AsIGRlZmF1bHRWYWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWVsZCwgcHJvcCwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBmaWVsZFtwcm9wXSA9IGRlZmF1bHRWYWx1ZTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVEZWVwKHNvdXJjZSwgcGF0aHMsIHNldEZuKSB7XG4gICAgbGV0IG9ic2VydmVycyA9IFtdO1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyKCkpO1xuICAgICAgICBvYnNlcnZlcnMgPSBbXTtcbiAgICB9O1xuICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2ZShzb3VyY2UsIHBhdGhzLCAoeyBmaXJzdENoYW5nZSwgY3VycmVudFZhbHVlIH0pID0+IHtcbiAgICAgICAgIWZpcnN0Q2hhbmdlICYmIHNldEZuKCk7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmIChpc09iamVjdChjdXJyZW50VmFsdWUpICYmIGN1cnJlbnRWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoY3VycmVudFZhbHVlKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZURlZXAoc291cmNlLCBbLi4ucGF0aHMsIHByb3BdLCBzZXRGbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBvYnNlcnZlKG8sIHBhdGhzLCBzZXRGbikge1xuICAgIGlmICghby5fb2JzZXJ2ZXJzKSB7XG4gICAgICAgIGRlZmluZUhpZGRlblByb3AobywgJ19vYnNlcnZlcnMnLCB7fSk7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBvO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmICghdGFyZ2V0W3BhdGhzW2ldXSB8fCAhaXNPYmplY3QodGFyZ2V0W3BhdGhzW2ldXSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtwYXRoc1tpXV0gPSAvXlxcZCskLy50ZXN0KHBhdGhzW2kgKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoc1tpXV07XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHBhdGhzW3BhdGhzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHByb3AgPSBwYXRocy5qb2luKCcuJyk7XG4gICAgaWYgKCFvLl9vYnNlcnZlcnNbcHJvcF0pIHtcbiAgICAgICAgby5fb2JzZXJ2ZXJzW3Byb3BdID0geyB2YWx1ZTogdGFyZ2V0W2tleV0sIG9uQ2hhbmdlOiBbXSB9O1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IG8uX29ic2VydmVyc1twcm9wXTtcbiAgICBpZiAodGFyZ2V0W2tleV0gIT09IHN0YXRlLnZhbHVlKSB7XG4gICAgICAgIHN0YXRlLnZhbHVlID0gdGFyZ2V0W2tleV07XG4gICAgfVxuICAgIGlmIChzdGF0ZS5vbkNoYW5nZS5pbmRleE9mKHNldEZuKSA9PT0gLTEpIHtcbiAgICAgICAgc3RhdGUub25DaGFuZ2UucHVzaChzZXRGbik7XG4gICAgICAgIHNldEZuKHsgY3VycmVudFZhbHVlOiBzdGF0ZS52YWx1ZSwgZmlyc3RDaGFuZ2U6IHRydWUgfSk7XG4gICAgICAgIGlmIChzdGF0ZS5vbkNoYW5nZS5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgY29uc3QgeyBlbnVtZXJhYmxlIH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSB8fCB7IGVudW1lcmFibGU6IHRydWUgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gc3RhdGUudmFsdWUsXG4gICAgICAgICAgICAgICAgc2V0OiAoY3VycmVudFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHN0YXRlLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLm9uQ2hhbmdlLmZvckVhY2goKGNoYW5nZUZuKSA9PiBjaGFuZ2VGbih7IHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmlyc3RDaGFuZ2U6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgICAgICBzdGF0ZS5vbkNoYW5nZSA9IHN0YXRlLm9uQ2hhbmdlLmZpbHRlcigoY2hhbmdlRm4pID0+IGNoYW5nZUZuICE9PSBzZXRGbik7XG4gICAgICAgICAgICBpZiAoc3RhdGUub25DaGFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG8uX29ic2VydmVyc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RmllbGQoZiwga2V5KSB7XG4gICAga2V5ID0gKEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXkpO1xuICAgIGlmICghZi5maWVsZEdyb3VwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBmLmZpZWxkR3JvdXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGYuZmllbGRHcm91cFtpXTtcbiAgICAgICAgY29uc3QgayA9IChBcnJheS5pc0FycmF5KGMua2V5KSA/IGMua2V5LmpvaW4oJy4nKSA6IGMua2V5KTtcbiAgICAgICAgaWYgKGsgPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuZmllbGRHcm91cCAmJiAoaXNOaWwoaykgfHwga2V5LmluZGV4T2YoYCR7a30uYCkgPT09IDApKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldEZpZWxkKGMsIGlzTmlsKGspID8ga2V5IDoga2V5LnNsaWNlKGsubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBtYXJrRmllbGRGb3JDaGVjayhmaWVsZCkge1xuICAgIGZpZWxkLl9jb21wb25lbnRSZWZzPy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgICAgLy8gTk9URTogd2UgY2Fubm90IHVzZSByZWYuY2hhbmdlRGV0ZWN0b3JSZWYsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbmd4LWZvcm1seS9uZ3gtZm9ybWx5L2lzc3Vlcy8yMTkxXG4gICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBDb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZURldGVjdG9yUmVmID0gcmVmLmluamVjdG9yLmdldChDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEFuIEluamVjdGlvblRva2VuIGZvciByZWdpc3RlcmluZyBhZGRpdGlvbmFsIGZvcm1seSBjb25maWcgb3B0aW9ucyAodHlwZXMsIHdyYXBwZXJzIC4uLikuXG4gKi9cbmNvbnN0IEZPUk1MWV9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0ZPUk1MWV9DT05GSUcnKTtcbi8qKlxuICogTWFpbnRhaW5zIGxpc3Qgb2YgZm9ybWx5IGNvbmZpZyBvcHRpb25zLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIG5ldyBmaWVsZCB0eXBlLlxuICovXG5jbGFzcyBGb3JtbHlDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnR5cGVzID0ge307XG4gICAgICAgIHRoaXMudmFsaWRhdG9ycyA9IHt9O1xuICAgICAgICB0aGlzLndyYXBwZXJzID0ge307XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSB7fTtcbiAgICAgICAgdGhpcy5leHRyYXMgPSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb25PbjogJ21vZGVsQ2hhbmdlJyxcbiAgICAgICAgICAgIGxhenlSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICByZXNldEZpZWxkT25IaWRlOiB0cnVlLFxuICAgICAgICAgICAgcmVuZGVyRm9ybWx5RmllbGRFbGVtZW50OiB0cnVlLFxuICAgICAgICAgICAgc2hvd0Vycm9yKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaWVsZC5mb3JtQ29udHJvbD8uaW52YWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGQuZm9ybUNvbnRyb2w/LnRvdWNoZWQgfHwgZmllbGQub3B0aW9ucy5wYXJlbnRGb3JtPy5zdWJtaXR0ZWQgfHwgISFmaWVsZC5maWVsZC52YWxpZGF0aW9uPy5zaG93KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5wcmVzZXRzID0ge307XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uc0J5UHJpb3JpdHkgPSB7fTtcbiAgICB9XG4gICAgYWRkQ29uZmlnKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLnR5cGVzKSB7XG4gICAgICAgICAgICBjb25maWcudHlwZXMuZm9yRWFjaCgodHlwZSkgPT4gdGhpcy5zZXRUeXBlKHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGNvbmZpZy52YWxpZGF0b3JzLmZvckVhY2goKHZhbGlkYXRvcikgPT4gdGhpcy5zZXRWYWxpZGF0b3IodmFsaWRhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy53cmFwcGVycykge1xuICAgICAgICAgICAgY29uZmlnLndyYXBwZXJzLmZvckVhY2goKHdyYXBwZXIpID0+IHRoaXMuc2V0V3JhcHBlcih3cmFwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy52YWxpZGF0aW9uTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGNvbmZpZy52YWxpZGF0aW9uTWVzc2FnZXMuZm9yRWFjaCgodmFsaWRhdGlvbikgPT4gdGhpcy5hZGRWYWxpZGF0b3JNZXNzYWdlKHZhbGlkYXRpb24ubmFtZSwgdmFsaWRhdGlvbi5tZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNvcnRlZEV4dGVuc2lvbnMoY29uZmlnLmV4dGVuc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuZXh0cmFzKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhcyA9IHsgLi4udGhpcy5leHRyYXMsIC4uLmNvbmZpZy5leHRyYXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnByZXNldHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc2V0cyA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByZXNldHMsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLnByZXNldHMucmVkdWNlKChhY2MsIGN1cnIpID0+ICh7IC4uLmFjYywgW2N1cnIubmFtZV06IGN1cnIuY29uZmlnIH0pLCB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gc3BlY2lmeSBhIGN1c3RvbSB0eXBlIHdoaWNoIHlvdSBjYW4gdXNlIGluIHlvdXIgZmllbGQgY29uZmlndXJhdGlvbi5cbiAgICAgKiBZb3UgY2FuIHBhc3MgYW4gb2JqZWN0IG9mIG9wdGlvbnMsIG9yIGFuIGFycmF5IG9mIG9iamVjdHMgb2Ygb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRUeXBlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB0aGlzLnNldFR5cGUob3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZXNbb3B0aW9ucy5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZXNbb3B0aW9ucy5uYW1lXSA9IHsgbmFtZTogb3B0aW9ucy5uYW1lIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbJ2NvbXBvbmVudCcsICdleHRlbmRzJywgJ2RlZmF1bHRPcHRpb25zJywgJ3dyYXBwZXJzJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZXNbb3B0aW9ucy5uYW1lXVtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZShuYW1lLCB0aHJvd0lmTm90Rm91bmQgPSBmYWxzZSkge1xuICAgICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbXBvbmVudDogbmFtZSwgbmFtZTogbmFtZS5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50eXBlc1tuYW1lXSkge1xuICAgICAgICAgICAgaWYgKHRocm93SWZOb3RGb3VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW0Zvcm1seSBFcnJvcl0gVGhlIHR5cGUgXCIke25hbWV9XCIgY291bGQgbm90IGJlIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgaXMgcmVnaXN0ZXJlZCB0aHJvdWdoIHRoZSBGb3JtbHlNb2R1bGUgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lcmdlRXh0ZW5kZWRUeXBlKG5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlc1tuYW1lXTtcbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgKi9cbiAgICBnZXRNZXJnZWRGaWVsZChmaWVsZCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoZmllbGQudHlwZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICByZXZlcnNlRGVlcE1lcmdlKGZpZWxkLCB0eXBlLmRlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlbmREZWZhdWx0cyA9IHR5cGUuZXh0ZW5kcyAmJiB0aGlzLmdldFR5cGUodHlwZS5leHRlbmRzKS5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKGV4dGVuZERlZmF1bHRzKSB7XG4gICAgICAgICAgICByZXZlcnNlRGVlcE1lcmdlKGZpZWxkLCBleHRlbmREZWZhdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkPy5vcHRpb25zVHlwZXMpIHtcbiAgICAgICAgICAgIGZpZWxkLm9wdGlvbnNUeXBlcy5mb3JFYWNoKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHRoaXMuZ2V0VHlwZShvcHRpb24pLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXZlcnNlRGVlcE1lcmdlKGZpZWxkLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9uZW50UmVmID0gdGhpcy5yZXNvbHZlRmllbGRUeXBlUmVmKGZpZWxkKTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFJlZj8uaW5zdGFuY2U/LmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICByZXZlcnNlRGVlcE1lcmdlKGZpZWxkLCBjb21wb25lbnRSZWYuaW5zdGFuY2UuZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmllbGQud3JhcHBlcnMgJiYgdHlwZS53cmFwcGVycykge1xuICAgICAgICAgICAgZmllbGQud3JhcHBlcnMgPSBbLi4udHlwZS53cmFwcGVyc107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpZ25vcmUgQGludGVybmFsICovXG4gICAgcmVzb2x2ZUZpZWxkVHlwZVJlZihmaWVsZCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoZmllbGQudHlwZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlLmNvbXBvbmVudCB8fCB0eXBlLl9jb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlLl9jb21wb25lbnRSZWY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBfdmlld0NvbnRhaW5lclJlZiwgX2luamVjdG9yIH0gPSBmaWVsZC5vcHRpb25zO1xuICAgICAgICBpZiAoIV92aWV3Q29udGFpbmVyUmVmIHx8ICFfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFJlZiA9IF92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudCh0eXBlLmNvbXBvbmVudCwgeyBpbmplY3RvcjogX2luamVjdG9yIH0pO1xuICAgICAgICBkZWZpbmVIaWRkZW5Qcm9wKHR5cGUsICdfY29tcG9uZW50UmVmJywgY29tcG9uZW50UmVmKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGRlc3Ryb3lpbmcgdGhlIEZvcm1seSBjb21wb25lbnQgdHlwZSBcIiR7ZmllbGQudHlwZX1cImAsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlLl9jb21wb25lbnRSZWY7XG4gICAgfVxuICAgIHNldFdyYXBwZXIob3B0aW9ucykge1xuICAgICAgICB0aGlzLndyYXBwZXJzW29wdGlvbnMubmFtZV0gPSBvcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlcykge1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUeXBlV3JhcHBlcih0eXBlLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0V3JhcHBlcihuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29tcG9uZW50OiBuYW1lLCBuYW1lOiBuYW1lLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLndyYXBwZXJzW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtGb3JtbHkgRXJyb3JdIFRoZSB3cmFwcGVyIFwiJHtuYW1lfVwiIGNvdWxkIG5vdCBiZSBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IGlzIHJlZ2lzdGVyZWQgdGhyb3VnaCB0aGUgRm9ybWx5TW9kdWxlIGRlY2xhcmF0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXJzW25hbWVdO1xuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIHNldFR5cGVXcmFwcGVyKHR5cGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVzW3R5cGVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnR5cGVzW3R5cGVdLndyYXBwZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVzW3R5cGVdLndyYXBwZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZXNbdHlwZV0ud3JhcHBlcnMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXNbdHlwZV0ud3JhcHBlcnMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWxpZGF0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLnZhbGlkYXRvcnNbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldFZhbGlkYXRvcihuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0b3JzW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtGb3JtbHkgRXJyb3JdIFRoZSB2YWxpZGF0b3IgXCIke25hbWV9XCIgY291bGQgbm90IGJlIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgaXMgcmVnaXN0ZXJlZCB0aHJvdWdoIHRoZSBGb3JtbHlNb2R1bGUgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yc1tuYW1lXTtcbiAgICB9XG4gICAgYWRkVmFsaWRhdG9yTWVzc2FnZShuYW1lLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXNbbmFtZV0gPSBtZXNzYWdlO1xuICAgICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBkZXByZWNhdGVkID0geyBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLCBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnIH07XG4gICAgICAgICAgICBpZiAoZGVwcmVjYXRlZFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRm9ybWx5IGRlcHJlY2F0aW9uOiBwYXNzaW5nIHZhbGlkYXRpb24gbWVzc2FnZXMga2V5ICcke25hbWV9JyBpcyBkZXByZWNhdGVkIHNpbmNlIHY2LjAsIHVzZSAnJHtkZXByZWNhdGVkW25hbWVdfScgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzW2RlcHJlY2F0ZWRbbmFtZV1dID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRWYWxpZGF0b3JNZXNzYWdlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbbmFtZV07XG4gICAgfVxuICAgIHNldFNvcnRlZEV4dGVuc2lvbnMoZXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAvLyBpbnNlcnQgbmV3IGV4dGVuc2lvbnMsIGdyb3VwZWQgYnkgcHJpb3JpdHlcbiAgICAgICAgZXh0ZW5zaW9uT3B0aW9ucy5mb3JFYWNoKChleHRlbnNpb25PcHRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5ID0gZXh0ZW5zaW9uT3B0aW9uLnByaW9yaXR5ID8/IDE7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnNCeVByaW9yaXR5W3ByaW9yaXR5XSA9IHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLmV4dGVuc2lvbnNCeVByaW9yaXR5W3ByaW9yaXR5XSxcbiAgICAgICAgICAgICAgICBbZXh0ZW5zaW9uT3B0aW9uLm5hbWVdOiBleHRlbnNpb25PcHRpb24uZXh0ZW5zaW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZsYXR0ZW4gZXh0ZW5zaW9ucyBvYmplY3Qgd2l0aCBzb3J0ZWQga2V5c1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBPYmplY3Qua2V5cyh0aGlzLmV4dGVuc2lvbnNCeVByaW9yaXR5KVxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICAgICAgICAucmVkdWNlKChhY2MsIHByaW8pID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAuLi50aGlzLmV4dGVuc2lvbnNCeVByaW9yaXR5W3ByaW9dLFxuICAgICAgICB9KSwge30pO1xuICAgIH1cbiAgICBtZXJnZUV4dGVuZGVkVHlwZShuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy50eXBlc1tuYW1lXS5leHRlbmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ZW5kZWRUeXBlID0gdGhpcy5nZXRUeXBlKHRoaXMudHlwZXNbbmFtZV0uZXh0ZW5kcyk7XG4gICAgICAgIGlmICghdGhpcy50eXBlc1tuYW1lXS5jb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXNbbmFtZV0uY29tcG9uZW50ID0gZXh0ZW5kZWRUeXBlLmNvbXBvbmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHlwZXNbbmFtZV0ud3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZXNbbmFtZV0ud3JhcHBlcnMgPSBleHRlbmRlZFR5cGUud3JhcHBlcnM7XG4gICAgICAgIH1cbiAgICB9XG59XG5Gb3JtbHlDb25maWcuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUNvbmZpZywgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkZvcm1seUNvbmZpZy7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUNvbmZpZywgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlDb25maWcsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dIH0pO1xuXG5jbGFzcyBGb3JtbHlGb3JtQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBpbmplY3Rvciwgdmlld0NvbnRhaW5lclJlZiwgcGFyZW50Rm9ybSkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLnBhcmVudEZvcm0gPSBwYXJlbnRGb3JtO1xuICAgIH1cbiAgICBidWlsZEZvcm0oZm9ybSwgZmllbGRHcm91cCA9IFtdLCBtb2RlbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJ1aWxkKHsgZmllbGRHcm91cCwgbW9kZWwsIGZvcm0sIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIGJ1aWxkKGZpZWxkKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuZXh0ZW5zaW9ucy5jb3JlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05neEZvcm1seTogbWlzc2luZyBgZm9yUm9vdCgpYCBjYWxsLiB1c2UgYGZvclJvb3QoKWAgd2hlbiByZWdpc3RlcmluZyB0aGUgYEZvcm1seU1vZHVsZWAuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaWVsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE9wdGlvbnMoZmllbGQpO1xuICAgICAgICAgICAgZGlzYWJsZVRyZWVWYWxpZGl0eUNhbGwoZmllbGQuZm9ybSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1aWxkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZmllbGQub3B0aW9ucztcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNoZWNrRXhwcmVzc2lvbnM/LihmaWVsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZXRlY3RDaGFuZ2VzPy4oZmllbGQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9idWlsZChmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkKGZpZWxkKSB7XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLmNvbmZpZy5leHRlbnNpb25zKTtcbiAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5wcmVQb3B1bGF0ZT8uKGZpZWxkKSk7XG4gICAgICAgIGV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0ZW5zaW9uKSA9PiBleHRlbnNpb24ub25Qb3B1bGF0ZT8uKGZpZWxkKSk7XG4gICAgICAgIGZpZWxkLmZpZWxkR3JvdXA/LmZvckVhY2goKGYpID0+IHRoaXMuX2J1aWxkKGYpKTtcbiAgICAgICAgZXh0ZW5zaW9ucy5mb3JFYWNoKChleHRlbnNpb24pID0+IGV4dGVuc2lvbi5wb3N0UG9wdWxhdGU/LihmaWVsZCkpO1xuICAgIH1cbiAgICBfc2V0T3B0aW9ucyhmaWVsZCkge1xuICAgICAgICBmaWVsZC5mb3JtID0gZmllbGQuZm9ybSB8fCBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgZmllbGQubW9kZWwgPSBmaWVsZC5tb2RlbCB8fCB7fTtcbiAgICAgICAgZmllbGQub3B0aW9ucyA9IGZpZWxkLm9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBmaWVsZC5vcHRpb25zO1xuICAgICAgICBpZiAoIW9wdGlvbnMuX3ZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3Aob3B0aW9ucywgJ192aWV3Q29udGFpbmVyUmVmJywgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuX2luamVjdG9yKSB7XG4gICAgICAgICAgICBkZWZpbmVIaWRkZW5Qcm9wKG9wdGlvbnMsICdfaW5qZWN0b3InLCB0aGlzLmluamVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuYnVpbGQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX2J1aWxkRm9ybSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZvcm1seTogJ29wdGlvbnMuX2J1aWxkRm9ybScgaXMgZGVwcmVjYXRlZCBzaW5jZSB2Ni4wLCB1c2UgJ29wdGlvbnMuYnVpbGQnIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZChmaWVsZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3B0aW9ucy5idWlsZCA9IChmID0gZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkKGYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMucGFyZW50Rm9ybSAmJiB0aGlzLnBhcmVudEZvcm0pIHtcbiAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3Aob3B0aW9ucywgJ3BhcmVudEZvcm0nLCB0aGlzLnBhcmVudEZvcm0pO1xuICAgICAgICAgICAgb2JzZXJ2ZShvcHRpb25zLCBbJ3BhcmVudEZvcm0nLCAnc3VibWl0dGVkJ10sICh7IGZpcnN0Q2hhbmdlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hlY2tFeHByZXNzaW9ucyhmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyhmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Gb3JtbHlGb3JtQnVpbGRlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5Rm9ybUJ1aWxkZXIsIGRlcHM6IFt7IHRva2VuOiBGb3JtbHlDb25maWcgfSwgeyB0b2tlbjogaTAuSW5qZWN0b3IgfSwgeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiwgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogaTIuRm9ybUdyb3VwRGlyZWN0aXZlLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRm9ybWx5Rm9ybUJ1aWxkZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGb3JtQnVpbGRlciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGb3JtQnVpbGRlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBGb3JtbHlDb25maWcgfSwgeyB0eXBlOiBpMC5JbmplY3RvciB9LCB7IHR5cGU6IGkwLlZpZXdDb250YWluZXJSZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMi5Gb3JtR3JvdXBEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbmZ1bmN0aW9uIHVucmVnaXN0ZXJDb250cm9sKGZpZWxkLCBlbWl0RXZlbnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvbnRyb2wgPSBmaWVsZC5mb3JtQ29udHJvbDtcbiAgICBjb25zdCBmaWVsZEluZGV4ID0gY29udHJvbC5fZmllbGRzID8gY29udHJvbC5fZmllbGRzLmluZGV4T2YoZmllbGQpIDogLTE7XG4gICAgaWYgKGZpZWxkSW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbnRyb2wuX2ZpZWxkcy5zcGxpY2UoZmllbGRJbmRleCwgMSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm0gPSBjb250cm9sLnBhcmVudDtcbiAgICBpZiAoIWZvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvcHRzID0geyBlbWl0RXZlbnQgfTtcbiAgICBpZiAoZm9ybSBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICBjb25zdCBrZXkgPSBmb3JtLmNvbnRyb2xzLmZpbmRJbmRleCgoYykgPT4gYyA9PT0gY29udHJvbCk7XG4gICAgICAgIGlmIChrZXkgIT09IC0xKSB7XG4gICAgICAgICAgICBmb3JtLnJlbW92ZUF0KGtleSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZm9ybSBpbnN0YW5jZW9mIEZvcm1Hcm91cCkge1xuICAgICAgICBjb25zdCBwYXRocyA9IGdldEtleVBhdGgoZmllbGQpO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoc1twYXRocy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGZvcm0uZ2V0KFtrZXldKSA9PT0gY29udHJvbCkge1xuICAgICAgICAgICAgZm9ybS5yZW1vdmVDb250cm9sKGtleSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udHJvbC5zZXRQYXJlbnQobnVsbCk7XG59XG5mdW5jdGlvbiBmaW5kQ29udHJvbChmaWVsZCkge1xuICAgIGlmIChmaWVsZC5mb3JtQ29udHJvbCkge1xuICAgICAgICByZXR1cm4gZmllbGQuZm9ybUNvbnRyb2w7XG4gICAgfVxuICAgIGlmIChmaWVsZC5zaGFyZUZvcm1Db250cm9sID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkLmZvcm0/LmdldChnZXRLZXlQYXRoKGZpZWxkKSk7XG59XG5mdW5jdGlvbiByZWdpc3RlckNvbnRyb2woZmllbGQsIGNvbnRyb2wsIGVtaXRFdmVudCA9IGZhbHNlKSB7XG4gICAgY29udHJvbCA9IGNvbnRyb2wgfHwgZmllbGQuZm9ybUNvbnRyb2w7XG4gICAgaWYgKCFjb250cm9sLl9maWVsZHMpIHtcbiAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChjb250cm9sLCAnX2ZpZWxkcycsIFtdKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyb2wuX2ZpZWxkcy5pbmRleE9mKGZpZWxkKSA9PT0gLTEpIHtcbiAgICAgICAgY29udHJvbC5fZmllbGRzLnB1c2goZmllbGQpO1xuICAgIH1cbiAgICBpZiAoIWZpZWxkLmZvcm1Db250cm9sICYmIGNvbnRyb2wpIHtcbiAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChmaWVsZCwgJ2Zvcm1Db250cm9sJywgY29udHJvbCk7XG4gICAgICAgIGNvbnRyb2wuc2V0VmFsaWRhdG9ycyhudWxsKTtcbiAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMobnVsbCk7XG4gICAgICAgIGZpZWxkLnByb3BzLmRpc2FibGVkID0gISFmaWVsZC5wcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRPYnNlcnZlciA9IG9ic2VydmUoZmllbGQsIFsncHJvcHMnLCAnZGlzYWJsZWQnXSwgKHsgZmlyc3RDaGFuZ2UsIGN1cnJlbnRWYWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID8gZmllbGQuZm9ybUNvbnRyb2wuZGlzYWJsZSgpIDogZmllbGQuZm9ybUNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29udHJvbCBpbnN0YW5jZW9mIEZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICBjb250cm9sLnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShkaXNhYmxlZE9ic2VydmVyLnNldFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZpZWxkLmZvcm0gfHwgIWhhc0tleShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZm9ybSA9IGZpZWxkLmZvcm07XG4gICAgY29uc3QgcGF0aHMgPSBnZXRLZXlQYXRoKGZpZWxkKTtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGQpO1xuICAgIGlmICghKGlzTmlsKGNvbnRyb2wudmFsdWUpICYmIGlzTmlsKHZhbHVlKSkgJiYgY29udHJvbC52YWx1ZSAhPT0gdmFsdWUgJiYgY29udHJvbCBpbnN0YW5jZW9mIEZvcm1Db250cm9sKSB7XG4gICAgICAgIGNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgaWYgKCFmb3JtLmdldChbcGF0aF0pKSB7XG4gICAgICAgICAgICBmb3JtLnNldENvbnRyb2wocGF0aCwgbmV3IEZvcm1Hcm91cCh7fSksIHsgZW1pdEV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcm0gPSBmb3JtLmdldChbcGF0aF0pO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSBwYXRoc1twYXRocy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWZpZWxkLl9oaWRlICYmIGZvcm0uZ2V0KFtrZXldKSAhPT0gY29udHJvbCkge1xuICAgICAgICBmb3JtLnNldENvbnRyb2woa2V5LCBjb250cm9sLCB7IGVtaXRFdmVudCB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVWYWxpZGl0eShjLCBvbmx5U2VsZiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RhdHVzID0gYy5zdGF0dXM7XG4gICAgY29uc3QgdmFsdWUgPSBjLnZhbHVlO1xuICAgIGMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UsIG9ubHlTZWxmIH0pO1xuICAgIGlmIChzdGF0dXMgIT09IGMuc3RhdHVzKSB7XG4gICAgICAgIGMuc3RhdHVzQ2hhbmdlcy5lbWl0KGMuc3RhdHVzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBjLnZhbHVlKSB7XG4gICAgICAgIGMudmFsdWVDaGFuZ2VzLmVtaXQoYy52YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJDb250cm9sKGZvcm0pIHtcbiAgICBkZWxldGUgZm9ybT8uX2ZpZWxkcztcbiAgICBmb3JtLnNldFZhbGlkYXRvcnMobnVsbCk7XG4gICAgZm9ybS5zZXRBc3luY1ZhbGlkYXRvcnMobnVsbCk7XG4gICAgaWYgKGZvcm0gaW5zdGFuY2VvZiBGb3JtR3JvdXAgfHwgZm9ybSBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICBPYmplY3QudmFsdWVzKGZvcm0uY29udHJvbHMpLmZvckVhY2goKGMpID0+IGNsZWFyQ29udHJvbChjKSk7XG4gICAgfVxufVxuXG5jbGFzcyBGb3JtbHlUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IocmVmKSB7XG4gICAgICAgIHRoaXMucmVmID0gcmVmO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5uYW1lIHx8ICdmb3JtbHktZ3JvdXAnO1xuICAgIH1cbn1cbkZvcm1seVRlbXBsYXRlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlUZW1wbGF0ZSwgZGVwczogW3sgdG9rZW46IGkwLlRlbXBsYXRlUmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkZvcm1seVRlbXBsYXRlLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCB0eXBlOiBGb3JtbHlUZW1wbGF0ZSwgc2VsZWN0b3I6IFwiW2Zvcm1seVRlbXBsYXRlXVwiLCBpbnB1dHM6IHsgbmFtZTogW1wiZm9ybWx5VGVtcGxhdGVcIiwgXCJuYW1lXCJdIH0sIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5VGVtcGxhdGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtbHlUZW1wbGF0ZV0nIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVGVtcGxhdGVSZWYgfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IG5hbWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtbHlUZW1wbGF0ZSddXG4gICAgICAgICAgICB9XSB9IH0pO1xuLy8gd29ya2Fycm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQzMjI3I2lzc3VlY29tbWVudC05MDQxNzM3MzhcbmNsYXNzIEZvcm1seUZpZWxkVGVtcGxhdGVzIHtcbn1cbkZvcm1seUZpZWxkVGVtcGxhdGVzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGaWVsZFRlbXBsYXRlcywgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkZvcm1seUZpZWxkVGVtcGxhdGVzLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5RmllbGRUZW1wbGF0ZXMgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUZpZWxkVGVtcGxhdGVzLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBUaGUgYDxmb3JtbHktZmllbGQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byByZW5kZXIgdGhlIFVJIHdpZGdldCAobGF5b3V0ICsgdHlwZSkgb2YgYSBnaXZlbiBgZmllbGRgLlxuICovXG5jbGFzcyBGb3JtbHlGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCByZW5kZXJlciwgX2VsZW1lbnRSZWYsIGhvc3RDb250YWluZXJSZWYsIGZvcm0pIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmhvc3RDb250YWluZXJSZWYgPSBob3N0Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgICAgICB0aGlzLmhvc3RPYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWZzID0gW107XG4gICAgICAgIHRoaXMuaG9va3NPYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kZXRlY3RGaWVsZEJ1aWxkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzVW5zdWJzY3JpYmUgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIGdldCBjb250YWluZXJSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5leHRyYXMucmVuZGVyRm9ybWx5RmllbGRFbGVtZW50ID8gdGhpcy52aWV3Q29udGFpbmVyUmVmIDogdGhpcy5ob3N0Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudFJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmV4dHJhcy5yZW5kZXJGb3JtbHlGaWVsZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFJlZnM/LlswXSBpbnN0YW5jZW9mIENvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50UmVmc1swXS5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJIb29rKCdhZnRlckNvbnRlbnRJbml0Jyk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VySG9vaygnYWZ0ZXJWaWV3SW5pdCcpO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRldGVjdEZpZWxkQnVpbGQgJiYgdGhpcy5maWVsZCAmJiB0aGlzLmZpZWxkLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckhvb2soJ29uSW5pdCcpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlckhvb2soJ29uQ2hhbmdlcycsIGNoYW5nZXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFJlZnModGhpcy5maWVsZCk7XG4gICAgICAgIHRoaXMuaG9zdE9ic2VydmVycy5mb3JFYWNoKChob3N0T2JzZXJ2ZXIpID0+IGhvc3RPYnNlcnZlci51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5ob29rc09ic2VydmVycy5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VySG9vaygnb25EZXN0cm95Jyk7XG4gICAgfVxuICAgIHJlbmRlckZpZWxkKGNvbnRhaW5lclJlZiwgZiwgd3JhcHBlcnMgPSBbXSkge1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXJSZWYgPT09IGNvbnRhaW5lclJlZikge1xuICAgICAgICAgICAgdGhpcy5yZXNldFJlZnModGhpcy5maWVsZCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lclJlZi5jbGVhcigpO1xuICAgICAgICAgICAgd3JhcHBlcnMgPSB0aGlzLmZpZWxkPy53cmFwcGVycztcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlcnM/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFt3cmFwcGVyLCAuLi53cHNdID0gd3JhcHBlcnM7XG4gICAgICAgICAgICBjb25zdCB7IGNvbXBvbmVudCB9ID0gdGhpcy5jb25maWcuZ2V0V3JhcHBlcih3cmFwcGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IGNvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ29tcG9uZW50UmVmKHJlZiwgZik7XG4gICAgICAgICAgICBvYnNlcnZlKHJlZi5pbnN0YW5jZSwgWydmaWVsZENvbXBvbmVudCddLCAoeyBjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUsIGZpcnN0Q2hhbmdlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlICYmIHByZXZpb3VzVmFsdWUuX2xDb250YWluZXIgPT09IGN1cnJlbnRWYWx1ZS5fbENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdSZWYgPSBwcmV2aW91c1ZhbHVlID8gcHJldmlvdXNWYWx1ZS5kZXRhY2goKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3UmVmICYmICF2aWV3UmVmLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLmluc2VydCh2aWV3UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmllbGQoY3VycmVudFZhbHVlLCBmLCB3cHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICFmaXJzdENoYW5nZSAmJiByZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGY/LnR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZVR5cGUgPSB0aGlzLmZvcm0/LnRlbXBsYXRlcz8uZmluZCgocmVmKSA9PiByZWYubmFtZSA9PT0gZi50eXBlKTtcbiAgICAgICAgICAgIGxldCByZWY7XG4gICAgICAgICAgICBpZiAoaW5saW5lVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlZiA9IGNvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcoaW5saW5lVHlwZS5yZWYsIHsgJGltcGxpY2l0OiBmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQgfSA9IHRoaXMuY29uZmlnLmdldFR5cGUoZi50eXBlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZWYgPSBjb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dGFjaENvbXBvbmVudFJlZihyZWYsIGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJIb29rKG5hbWUsIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdvbkluaXQnIHx8IChuYW1lID09PSAnb25DaGFuZ2VzJyAmJiBjaGFuZ2VzLmZpZWxkICYmICFjaGFuZ2VzLmZpZWxkLmZpcnN0Q2hhbmdlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXNVbnN1YnNjcmliZSA9IHRoaXMuZmllbGRDaGFuZ2VzKHRoaXMuZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpZWxkPy5ob29rcz8uW25hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMgfHwgY2hhbmdlcy5maWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmZpZWxkLmhvb2tzW25hbWVdKHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmFibGUocikgJiYgWydvbkluaXQnLCAnYWZ0ZXJDb250ZW50SW5pdCcsICdhZnRlclZpZXdJbml0J10uaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gci5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ob29rc09ic2VydmVycy5wdXNoKCgpID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdvbkNoYW5nZXMnICYmIGNoYW5nZXMuZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRSZWZzKGNoYW5nZXMuZmllbGQucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaENvbXBvbmVudFJlZihyZWYsIGZpZWxkKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmcy5wdXNoKHJlZik7XG4gICAgICAgIGZpZWxkLl9jb21wb25lbnRSZWZzLnB1c2gocmVmKTtcbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIENvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZWYuaW5zdGFuY2UsIHsgZmllbGQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1aXJlIEZvcm1seSBidWlsZFxuICAgICAgICBpZiAoIXRoaXMuZmllbGQub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5kZXRlY3RGaWVsZEJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGVjdEZpZWxkQnVpbGQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3N0T2JzZXJ2ZXJzLmZvckVhY2goKGhvc3RPYnNlcnZlcikgPT4gaG9zdE9ic2VydmVyLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLmhvc3RPYnNlcnZlcnMgPSBbXG4gICAgICAgICAgICBvYnNlcnZlKHRoaXMuZmllbGQsIFsnaGlkZSddLCAoeyBmaXJzdENoYW5nZSwgY3VycmVudFZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJSZWYgPSB0aGlzLmNvbnRhaW5lclJlZjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZXh0cmFzLmxhenlSZW5kZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hhbmdlICYmIHRoaXMucmVuZGVyRmllbGQoY29udGFpbmVyUmVmLCB0aGlzLmZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdENoYW5nZSB8fCAoZmlyc3RDaGFuZ2UgJiYgY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc3BsYXknLCBjdXJyZW50VmFsdWUgPyAnbm9uZScgOiAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclJlZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmllbGQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWVsZChjb250YWluZXJSZWYsIHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmllbGQuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGFzcycsIHRoaXMuZmllbGQuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhZmlyc3RDaGFuZ2UgJiYgdGhpcy5maWVsZC5vcHRpb25zLmRldGVjdENoYW5nZXModGhpcy5maWVsZCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9ic2VydmUodGhpcy5maWVsZCwgWydjbGFzc05hbWUnXSwgKHsgZmlyc3RDaGFuZ2UsIGN1cnJlbnRWYWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCghZmlyc3RDaGFuZ2UgfHwgKGZpcnN0Q2hhbmdlICYmIGN1cnJlbnRWYWx1ZSkpICYmXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5jb25maWcuZXh0cmFzLmxhenlSZW5kZXIgfHwgdGhpcy5maWVsZC5oaWRlICE9PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYgJiYgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGFzcycsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5bJ3RvdWNoZWQnLCAncHJpc3RpbmUnLCAnc3RhdHVzJ10ubWFwKChwcm9wKSA9PiBvYnNlcnZlKHRoaXMuZmllbGQsIFsnZm9ybUNvbnRyb2wnLCBwcm9wXSwgKHsgZmlyc3RDaGFuZ2UgfSkgPT4gIWZpcnN0Q2hhbmdlICYmIG1hcmtGaWVsZEZvckNoZWNrKHRoaXMuZmllbGQpKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJlc2V0UmVmcyhmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5fY29tcG9uZW50UmVmcykge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9jb21wb25lbnRSZWZzID0gZmllbGQuX2NvbXBvbmVudFJlZnMuZmlsdGVyKChyZWYpID0+IHRoaXMuY29tcG9uZW50UmVmcy5pbmRleE9mKHJlZikgPT09IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3AodGhpcy5maWVsZCwgJ19jb21wb25lbnRSZWZzJywgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmcyA9IFtdO1xuICAgIH1cbiAgICBmaWVsZENoYW5nZXMoZmllbGQpIHtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXNVbnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXMgPSBbXG4gICAgICAgICAgICBvYnNlcnZlRGVlcChmaWVsZCwgWydwcm9wcyddLCAoKSA9PiBmaWVsZC5vcHRpb25zLmRldGVjdENoYW5nZXMoZmllbGQpKSxcbiAgICAgICAgICAgIG9ic2VydmVEZWVwKGZpZWxkLm9wdGlvbnMsIFsnZm9ybVN0YXRlJ10sICgpID0+IGZpZWxkLm9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyhmaWVsZCkpLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZC5fZXhwcmVzc2lvbnMgfHwge30pKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uT2JzZXJ2ZXIgPSBvYnNlcnZlKGZpZWxkLCBbJ19leHByZXNzaW9ucycsIGtleV0sICh7IGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWU/LnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmFibGUoY3VycmVudFZhbHVlLnZhbHVlJCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnN1YnNjcmlwdGlvbiA9IGN1cnJlbnRWYWx1ZS52YWx1ZSQuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5fZXhwcmVzc2lvbnNba2V5XT8uc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9leHByZXNzaW9uc1trZXldLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHByZXNzaW9uT2JzZXJ2ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBbWyd0ZW1wbGF0ZSddLCBbJ2ZpZWxkR3JvdXBDbGFzc05hbWUnXSwgWyd2YWxpZGF0aW9uJywgJ3Nob3cnXV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkT2JzZXJ2ZXIgPSBvYnNlcnZlKGZpZWxkLCBwYXRoLCAoeyBmaXJzdENoYW5nZSB9KSA9PiAhZmlyc3RDaGFuZ2UgJiYgZmllbGQub3B0aW9ucy5kZXRlY3RDaGFuZ2VzKGZpZWxkKSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVzLnB1c2goKCkgPT4gZmllbGRPYnNlcnZlci51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQuZm9ybUNvbnRyb2wgJiYgIWZpZWxkLmZpZWxkR3JvdXApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSBmaWVsZC5mb3JtQ29udHJvbDtcbiAgICAgICAgICAgIGxldCB2YWx1ZUNoYW5nZXMgPSBjb250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCh4LCB5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHggIT09IHkgfHwgQXJyYXkuaXNBcnJheSh4KSB8fCBpc09iamVjdCh4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUgIT09IGdldEZpZWxkVmFsdWUoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVDaGFuZ2VzID0gdmFsdWVDaGFuZ2VzLnBpcGUoc3RhcnRXaXRoKGNvbnRyb2wudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdXBkYXRlT24sIGRlYm91bmNlIH0gPSBmaWVsZC5tb2RlbE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoKCF1cGRhdGVPbiB8fCB1cGRhdGVPbiA9PT0gJ2NoYW5nZScpICYmIGRlYm91bmNlPy5kZWZhdWx0ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlQ2hhbmdlcyA9IGNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoZGVib3VuY2VUaW1lKGRlYm91bmNlLmRlZmF1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTM3OTJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5fZmllbGRzPy5sZW5ndGggPiAxICYmIGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnBhdGNoVmFsdWUodmFsdWUsIHsgZW1pdEV2ZW50OiBmYWxzZSwgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpZWxkLnBhcnNlcnM/LmZvckVhY2goKHBhcnNlckZuKSA9PiAodmFsdWUgPSBwYXJzZXJGbih2YWx1ZSkpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGZpZWxkLmZvcm1Db250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzS2V5KGZpZWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NpZ25GaWVsZFZhbHVlKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuZmllbGRDaGFuZ2VzLm5leHQoeyB2YWx1ZSwgZmllbGQsIHR5cGU6ICd2YWx1ZUNoYW5nZXMnIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWJzY3JpYmVzLnB1c2goKCkgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiBzdWJzY3JpYmVzLmZvckVhY2goKHN1YnNjcmliZSkgPT4gc3Vic2NyaWJlKCkpO1xuICAgIH1cbn1cbkZvcm1seUZpZWxkLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGaWVsZCwgZGVwczogW3sgdG9rZW46IEZvcm1seUNvbmZpZyB9LCB7IHRva2VuOiBpMC5SZW5kZXJlcjIgfSwgeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdG9rZW46IEZvcm1seUZpZWxkVGVtcGxhdGVzLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5Db21wb25lbnQgfSk7XG5Gb3JtbHlGaWVsZC7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgdHlwZTogRm9ybWx5RmllbGQsIHNlbGVjdG9yOiBcImZvcm1seS1maWVsZFwiLCBpbnB1dHM6IHsgZmllbGQ6IFwiZmllbGRcIiB9LCB2aWV3UXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcInZpZXdDb250YWluZXJSZWZcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogW1wiY29udGFpbmVyXCJdLCBkZXNjZW5kYW50czogdHJ1ZSwgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH1dLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlICNjb250YWluZXI+PC9uZy10ZW1wbGF0ZT4nLCBpc0lubGluZTogdHJ1ZSwgc3R5bGVzOiBbXCI6aG9zdDplbXB0eXtkaXNwbGF5Om5vbmV9XFxuXCJdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGaWVsZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnZm9ybWx5LWZpZWxkJywgdGVtcGxhdGU6ICc8bmctdGVtcGxhdGUgI2NvbnRhaW5lcj48L25nLXRlbXBsYXRlPicsIHN0eWxlczogW1wiOmhvc3Q6ZW1wdHl7ZGlzcGxheTpub25lfVxcblwiXSB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IEZvcm1seUNvbmZpZyB9LCB7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdHlwZTogRm9ybWx5RmllbGRUZW1wbGF0ZXMsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IGZpZWxkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgdmlld0NvbnRhaW5lclJlZjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgYXJnczogWydjb250YWluZXInLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLyoqXG4gKiBUaGUgYDxmb3JtLWZvcm0+YCBjb21wb25lbnQgaXMgdGhlIG1haW4gY29udGFpbmVyIG9mIHRoZSBmb3JtLFxuICogd2hpY2ggdGFrZXMgY2FyZSBvZiBtYW5hZ2luZyB0aGUgZm9ybSBzdGF0ZVxuICogYW5kIGRlbGVnYXRlcyB0aGUgcmVuZGVyaW5nIG9mIGVhY2ggZmllbGQgdG8gYDxmb3JtbHktZmllbGQ+YCBjb21wb25lbnQuXG4gKi9cbmNsYXNzIEZvcm1seUZvcm0ge1xuICAgIGNvbnN0cnVjdG9yKGJ1aWxkZXIsIGNvbmZpZywgbmdab25lLCBmaWVsZFRlbXBsYXRlcykge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuZmllbGRUZW1wbGF0ZXMgPSBmaWVsZFRlbXBsYXRlcztcbiAgICAgICAgLyoqIEV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBtb2RlbCB2YWx1ZSBpcyBjaGFuZ2VkICovXG4gICAgICAgIHRoaXMubW9kZWxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZmllbGQgPSB7IHR5cGU6ICdmb3JtbHktZ3JvdXAnIH07XG4gICAgICAgIHRoaXMuX21vZGVsQ2hhbmdlVmFsdWUgPSB7fTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXNVbnN1YnNjcmliZSA9ICgpID0+IHsgfTtcbiAgICB9XG4gICAgLyoqIFRoZSBmb3JtIGluc3RhbmNlIHdoaWNoIGFsbG93IHRvIHRyYWNrIG1vZGVsIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cy4gKi9cbiAgICBzZXQgZm9ybShmb3JtKSB7XG4gICAgICAgIHRoaXMuZmllbGQuZm9ybSA9IGZvcm07XG4gICAgfVxuICAgIGdldCBmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5mb3JtO1xuICAgIH1cbiAgICAvKiogVGhlIG1vZGVsIHRvIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBmb3JtLiAqL1xuICAgIHNldCBtb2RlbChtb2RlbCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuZXh0cmFzLmltbXV0YWJsZSAmJiB0aGlzLl9tb2RlbENoYW5nZVZhbHVlID09PSBtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RmllbGQoeyBtb2RlbCB9KTtcbiAgICB9XG4gICAgZ2V0IG1vZGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5tb2RlbDtcbiAgICB9XG4gICAgLyoqIFRoZSBmaWVsZCBjb25maWd1cmF0aW9ucyBmb3IgYnVpbGRpbmcgdGhlIGZvcm0uICovXG4gICAgc2V0IGZpZWxkcyhmaWVsZEdyb3VwKSB7XG4gICAgICAgIHRoaXMuc2V0RmllbGQoeyBmaWVsZEdyb3VwIH0pO1xuICAgIH1cbiAgICBnZXQgZmllbGRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5maWVsZEdyb3VwO1xuICAgIH1cbiAgICAvKiogT3B0aW9ucyBmb3IgdGhlIGZvcm0uICovXG4gICAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLnNldEZpZWxkKHsgb3B0aW9ucyB9KTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLm9wdGlvbnM7XG4gICAgfVxuICAgIHNldCB0ZW1wbGF0ZXModGVtcGxhdGVzKSB7XG4gICAgICAgIHRoaXMuZmllbGRUZW1wbGF0ZXMudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5leHRyYXMuY2hlY2tFeHByZXNzaW9uT24gPT09ICdjaGFuZ2VEZXRlY3Rpb25DaGVjaycpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5maWVsZHMgJiYgdGhpcy5mb3JtKSB7XG4gICAgICAgICAgICBjbGVhckNvbnRyb2wodGhpcy5mb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5maWVsZHMgfHwgY2hhbmdlcy5mb3JtIHx8IChjaGFuZ2VzLm1vZGVsICYmIHRoaXMuX21vZGVsQ2hhbmdlVmFsdWUgIT09IGNoYW5nZXMubW9kZWwuY3VycmVudFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXNVbnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyLmJ1aWxkKHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZXNVbnN1YnNjcmliZSA9IHRoaXMudmFsdWVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzVW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgY2hlY2tFeHByZXNzaW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmZpZWxkLm9wdGlvbnMuY2hlY2tFeHByZXNzaW9ucz8uKHRoaXMuZmllbGQpO1xuICAgIH1cbiAgICB2YWx1ZUNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzVW5zdWJzY3JpYmUoKTtcbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5maWVsZC5vcHRpb25zLmZpZWxkQ2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCh7IGZpZWxkLCB0eXBlIH0pID0+IGhhc0tleShmaWVsZCkgJiYgdHlwZSA9PT0gJ3ZhbHVlQ2hhbmdlcycpLCBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5uZ1pvbmUub25TdGFibGUuYXNPYnNlcnZhYmxlKCkucGlwZSh0YWtlKDEpKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMubmdab25lLnJ1bkd1YXJkZWQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gcnVuR3VhcmRlZCBpcyB1c2VkIHRvIGtlZXAgaW4gc3luYyB0aGUgZXhwcmVzc2lvbiBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbmd4LWZvcm1seS9uZ3gtZm9ybWx5L2lzc3Vlcy8yMDk1XG4gICAgICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkNoYW5nZSgpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KCh0aGlzLl9tb2RlbENoYW5nZVZhbHVlID0gY2xvbmUodGhpcy5tb2RlbCkpKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4gc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHNldEZpZWxkKGZpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5leHRyYXMuaW1tdXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0geyAuLi50aGlzLmZpZWxkLCAuLi5jbG9uZShmaWVsZCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGZpZWxkKS5mb3JFYWNoKChwKSA9PiAodGhpcy5maWVsZFtwXSA9IGZpZWxkW3BdKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Gb3JtbHlGb3JtLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlGb3JtLCBkZXBzOiBbeyB0b2tlbjogRm9ybWx5Rm9ybUJ1aWxkZXIgfSwgeyB0b2tlbjogRm9ybWx5Q29uZmlnIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBGb3JtbHlGaWVsZFRlbXBsYXRlcyB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5Db21wb25lbnQgfSk7XG5Gb3JtbHlGb3JtLsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCB0eXBlOiBGb3JtbHlGb3JtLCBzZWxlY3RvcjogXCJmb3JtbHktZm9ybVwiLCBpbnB1dHM6IHsgZm9ybTogXCJmb3JtXCIsIG1vZGVsOiBcIm1vZGVsXCIsIGZpZWxkczogXCJmaWVsZHNcIiwgb3B0aW9uczogXCJvcHRpb25zXCIgfSwgb3V0cHV0czogeyBtb2RlbENoYW5nZTogXCJtb2RlbENoYW5nZVwiIH0sIHByb3ZpZGVyczogW0Zvcm1seUZvcm1CdWlsZGVyLCBGb3JtbHlGaWVsZFRlbXBsYXRlc10sIHF1ZXJpZXM6IFt7IHByb3BlcnR5TmFtZTogXCJ0ZW1wbGF0ZXNcIiwgcHJlZGljYXRlOiBGb3JtbHlUZW1wbGF0ZSB9XSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogJzxmb3JtbHktZmllbGQgW2ZpZWxkXT1cImZpZWxkXCI+PC9mb3JtbHktZmllbGQ+JywgaXNJbmxpbmU6IHRydWUsIGNvbXBvbmVudHM6IFt7IHR5cGU6IEZvcm1seUZpZWxkLCBzZWxlY3RvcjogXCJmb3JtbHktZmllbGRcIiwgaW5wdXRzOiBbXCJmaWVsZFwiXSB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2ggfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUZvcm0sIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Zvcm1seS1mb3JtJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6ICc8Zm9ybWx5LWZpZWxkIFtmaWVsZF09XCJmaWVsZFwiPjwvZm9ybWx5LWZpZWxkPicsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0Zvcm1seUZvcm1CdWlsZGVyLCBGb3JtbHlGaWVsZFRlbXBsYXRlc10sXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogRm9ybWx5Rm9ybUJ1aWxkZXIgfSwgeyB0eXBlOiBGb3JtbHlDb25maWcgfSwgeyB0eXBlOiBpMC5OZ1pvbmUgfSwgeyB0eXBlOiBGb3JtbHlGaWVsZFRlbXBsYXRlcyB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgZm9ybTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIG1vZGVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgZmllbGRzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgb3B0aW9uczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIG1vZGVsQ2hhbmdlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIHRlbXBsYXRlczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBDb250ZW50Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgYXJnczogW0Zvcm1seVRlbXBsYXRlXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLyoqXG4gKiBBbGxvdyB0byBsaW5rIHRoZSBgZmllbGRgIEhUTUwgYXR0cmlidXRlcyAoYGlkYCwgYG5hbWVgIC4uLikgYW5kIEV2ZW50IGF0dHJpYnV0ZXMgKGBmb2N1c2AsIGBibHVyYCAuLi4pIHRvIGFuIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAqL1xuY2xhc3MgRm9ybWx5QXR0cmlidXRlcyB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGVsZW1lbnRSZWYsIF9kb2N1bWVudCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMudWlBdHRyaWJ1dGVzQ2FjaGUgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvc3RCaW5kaW5nIGRvZXNuJ3QgcmVnaXN0ZXIgbGlzdGVuZXJzIGNvbmRpdGlvbmFsbHkgd2hpY2ggbWF5IHByb2R1Y2Ugc29tZSBwZXJmIGlzc3Vlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9ybWx5IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vbmd4LWZvcm1seS9uZ3gtZm9ybWx5L2lzc3Vlcy8xOTkxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpRXZlbnRzID0ge1xuICAgICAgICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgICAgICAgIGV2ZW50czogWydjbGljaycsICdrZXl1cCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJ10sXG4gICAgICAgICAgICBjYWxsYmFjazogKGV2ZW50TmFtZSwgJGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Gb2N1cygkZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdibHVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uQmx1cigkZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaGFuZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub25DaGFuZ2UoJGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzW2V2ZW50TmFtZV0odGhpcy5maWVsZCwgJGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgIH1cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLnByb3BzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgZmllbGRBdHRyRWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkPy5bJ19lbGVtZW50UmVmcyddIHx8IFtdO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZpZWxkKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkLm5hbWUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCB0aGlzLmZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgdGhpcy51aUV2ZW50cy5saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKCkpO1xuICAgICAgICAgICAgdGhpcy51aUV2ZW50cy5ldmVudHMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvcHM/LltldmVudE5hbWVdIHx8IFsnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnXS5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlFdmVudHMubGlzdGVuZXJzLnB1c2godGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGV2ZW50TmFtZSwgKGUpID0+IHRoaXMudWlFdmVudHMuY2FsbGJhY2soZXZlbnROYW1lLCBlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHM/LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlKHRoaXMuZmllbGQsIFsncHJvcHMnLCAnYXR0cmlidXRlcyddLCAoeyBjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocHJldmlvdXNWYWx1ZSkuZm9yRWFjaCgoYXR0cikgPT4gdGhpcy5yZW1vdmVBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1cnJlbnRWYWx1ZSkuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWVbYXR0cl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyLCBjdXJyZW50VmFsdWVbYXR0cl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRldGFjaEVsZW1lbnRSZWYoY2hhbmdlcy5maWVsZC5wcmV2aW91c1ZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoRWxlbWVudFJlZihjaGFuZ2VzLmZpZWxkLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5maWVsZEF0dHJFbGVtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAhdGhpcy5pZCAmJiB0aGlzLmZpZWxkLmlkICYmIHRoaXMuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZmllbGQuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNPYnNlcnZlciA9IG9ic2VydmUodGhpcy5maWVsZCwgWydmb2N1cyddLCAoeyBjdXJyZW50VmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUZvY3VzKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgYWxsIHRoZSBhdHRyaWJ1dGVzIG9uIGV2ZXJ5IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUsIGJlY2F1c2VcbiAgICAgKiBieSB1c2luZyBhIEhvc3RCaW5kaW5nIHdlIHJ1biBpbnRvIGNlcnRhaW4gZWRnZSBjYXNlcy4gVGhpcyBtZWFucyB0aGF0IHdoYXRldmVyIGxvZ2ljXG4gICAgICogaXMgaW4gaGVyZSBoYXMgdG8gYmUgc3VwZXIgbGVhbiBvciB3ZSByaXNrIHNlcmlvdXNseSBkYW1hZ2luZyBvciBkZXN0cm95aW5nIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEZvcm1seSBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL25neC1mb3JtbHkvbmd4LWZvcm1seS9pc3N1ZXMvMTMxN1xuICAgICAqIE1hdGVyaWFsIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9jb21wb25lbnRzL2lzc3Vlcy8xNDAyNFxuICAgICAqL1xuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnVpQXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy51aUF0dHJpYnV0ZXMgPSBbLi4uRk9STUxZX1ZBTElEQVRPUlMsICd0YWJpbmRleCcsICdwbGFjZWhvbGRlcicsICdyZWFkb25seScsICdkaXNhYmxlZCcsICdzdGVwJ10uZmlsdGVyKChhdHRyKSA9PiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUgfHwgIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVpQXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucHJvcHNbYXR0cl07XG4gICAgICAgICAgICBpZiAodGhpcy51aUF0dHJpYnV0ZXNDYWNoZVthdHRyXSAhPT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAoIXRoaXMucHJvcHMuYXR0cmlidXRlcyB8fCAhdGhpcy5wcm9wcy5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIudG9Mb3dlckNhc2UoKSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51aUF0dHJpYnV0ZXNDYWNoZVthdHRyXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSA9PT0gdHJ1ZSA/IGF0dHIgOiBgJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnVpRXZlbnRzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoKSk7XG4gICAgICAgIHRoaXMuZGV0YWNoRWxlbWVudFJlZih0aGlzLmZpZWxkKTtcbiAgICAgICAgdGhpcy5mb2N1c09ic2VydmVyPy51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0b2dnbGVGb2N1cyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5maWVsZEF0dHJFbGVtZW50cyA/IHRoaXMuZmllbGRBdHRyRWxlbWVudHNbMF0gOiBudWxsO1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZCA9ICEhdGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG4gICAgICAgICAgICB0aGlzLmZpZWxkQXR0ckVsZW1lbnRzLnNvbWUoKHsgbmF0aXZlRWxlbWVudCB9KSA9PiB0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IG5hdGl2ZUVsZW1lbnQgfHwgbmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKTtcbiAgICAgICAgaWYgKHZhbHVlICYmICFpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWx1ZSAmJiBpc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZWxlbWVudC5uYXRpdmVFbGVtZW50LmJsdXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Gb2N1cygkZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c09ic2VydmVyPy5zZXRWYWx1ZSh0cnVlKTtcbiAgICAgICAgdGhpcy5wcm9wcy5mb2N1cz8uKHRoaXMuZmllbGQsICRldmVudCk7XG4gICAgfVxuICAgIG9uQmx1cigkZXZlbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c09ic2VydmVyPy5zZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMucHJvcHMuYmx1cj8uKHRoaXMuZmllbGQsICRldmVudCk7XG4gICAgfVxuICAgIC8vIGhhbmRsZSBjdXN0b20gYGNoYW5nZWAgZXZlbnQsIGZvciByZWd1bGFyIG9uZXMgcmVseSBvbiBET00gbGlzdGVuZXJcbiAgICBvbkhvc3RDaGFuZ2UoJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQgaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UoJGV2ZW50KTtcbiAgICB9XG4gICAgb25DaGFuZ2UoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMuY2hhbmdlPy4odGhpcy5maWVsZCwgJGV2ZW50KTtcbiAgICAgICAgdGhpcy5maWVsZC5mb3JtQ29udHJvbD8ubWFya0FzRGlydHkoKTtcbiAgICB9XG4gICAgYXR0YWNoRWxlbWVudFJlZihmKSB7XG4gICAgICAgIGlmICghZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmWydfZWxlbWVudFJlZnMnXT8uaW5kZXhPZih0aGlzLmVsZW1lbnRSZWYpID09PSAtMSkge1xuICAgICAgICAgICAgZlsnX2VsZW1lbnRSZWZzJ10ucHVzaCh0aGlzLmVsZW1lbnRSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChmLCAnX2VsZW1lbnRSZWZzJywgW3RoaXMuZWxlbWVudFJlZl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRldGFjaEVsZW1lbnRSZWYoZikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGY/LlsnX2VsZW1lbnRSZWZzJ10gPyB0aGlzLmZpZWxkQXR0ckVsZW1lbnRzLmluZGV4T2YodGhpcy5lbGVtZW50UmVmKSA6IC0xO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmWydfZWxlbWVudFJlZnMnXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICByZW1vdmVBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgYXR0cik7XG4gICAgfVxufVxuRm9ybWx5QXR0cmlidXRlcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5QXR0cmlidXRlcywgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IERPQ1VNRU5UIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkZvcm1seUF0dHJpYnV0ZXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIHR5cGU6IEZvcm1seUF0dHJpYnV0ZXMsIHNlbGVjdG9yOiBcIltmb3JtbHlBdHRyaWJ1dGVzXVwiLCBpbnB1dHM6IHsgZmllbGQ6IFtcImZvcm1seUF0dHJpYnV0ZXNcIiwgXCJmaWVsZFwiXSwgaWQ6IFwiaWRcIiB9LCBob3N0OiB7IGxpc3RlbmVyczogeyBcImNoYW5nZVwiOiBcIm9uSG9zdENoYW5nZSgkZXZlbnQpXCIgfSB9LCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUF0dHJpYnV0ZXMsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tmb3JtbHlBdHRyaWJ1dGVzXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoY2hhbmdlKSc6ICdvbkhvc3RDaGFuZ2UoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5SZW5kZXJlcjIgfSwgeyB0eXBlOiBpMC5FbGVtZW50UmVmIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgZmllbGQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtbHlBdHRyaWJ1dGVzJ11cbiAgICAgICAgICAgIH1dLCBpZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY2xhc3MgRmllbGRUeXBlIHtcbiAgICBnZXQgbW9kZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLm1vZGVsO1xuICAgIH1cbiAgICBnZXQgZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZm9ybTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmtleTtcbiAgICB9XG4gICAgZ2V0IGZvcm1Db250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5mb3JtQ29udHJvbDtcbiAgICB9XG4gICAgZ2V0IHByb3BzKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmllbGQucHJvcHMgfHwge30pO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIGBwcm9wc2AgaW5zdGVhZC4gKi9cbiAgICBnZXQgdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzO1xuICAgIH1cbiAgICBnZXQgc2hvd0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNob3dFcnJvcih0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5pZDtcbiAgICB9XG4gICAgZ2V0IGZvcm1TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mb3JtU3RhdGUgfHwge307XG4gICAgfVxufVxuRmllbGRUeXBlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGaWVsZFR5cGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkZpZWxkVHlwZS7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgdHlwZTogRmllbGRUeXBlLCBpbnB1dHM6IHsgZmllbGQ6IFwiZmllbGRcIiB9LCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZpZWxkVHlwZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgZmllbGQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKiBAaWdub3JlICovXG5jbGFzcyBGb3JtbHlHcm91cCBleHRlbmRzIEZpZWxkVHlwZSB7XG59XG5Gb3JtbHlHcm91cC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5R3JvdXAsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuRm9ybWx5R3JvdXAuybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIHR5cGU6IEZvcm1seUdyb3VwLCBzZWxlY3RvcjogXCJmb3JtbHktZ3JvdXBcIiwgaG9zdDogeyBwcm9wZXJ0aWVzOiB7IFwiY2xhc3NcIjogXCJmaWVsZC5maWVsZEdyb3VwQ2xhc3NOYW1lIHx8IFxcXCJcXFwiXCIgfSB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IGBcbiAgICA8Zm9ybWx5LWZpZWxkICpuZ0Zvcj1cImxldCBmIG9mIGZpZWxkLmZpZWxkR3JvdXBcIiBbZmllbGRdPVwiZlwiPjwvZm9ybWx5LWZpZWxkPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCwgaXNJbmxpbmU6IHRydWUsIGNvbXBvbmVudHM6IFt7IHR5cGU6IEZvcm1seUZpZWxkLCBzZWxlY3RvcjogXCJmb3JtbHktZmllbGRcIiwgaW5wdXRzOiBbXCJmaWVsZFwiXSB9XSwgZGlyZWN0aXZlczogW3sgdHlwZTogaTIkMS5OZ0Zvck9mLCBzZWxlY3RvcjogXCJbbmdGb3JdW25nRm9yT2ZdXCIsIGlucHV0czogW1wibmdGb3JPZlwiLCBcIm5nRm9yVHJhY2tCeVwiLCBcIm5nRm9yVGVtcGxhdGVcIl0gfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlHcm91cCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybWx5LWdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8Zm9ybWx5LWZpZWxkICpuZ0Zvcj1cImxldCBmIG9mIGZpZWxkLmZpZWxkR3JvdXBcIiBbZmllbGRdPVwiZlwiPjwvZm9ybWx5LWZpZWxkPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzc10nOiAnZmllbGQuZmllbGRHcm91cENsYXNzTmFtZSB8fCBcIlwiJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogVGhlIGA8Zm9ybWx5LXZhbGlkYXRpb24tbWVzc2FnZT5gIGNvbXBvbmVudCByZW5kZXJzIHRoZSBlcnJvciBtZXNzYWdlIG9mIGEgZ2l2ZW4gYGZpZWxkYC5cbiAqL1xuY2xhc3MgRm9ybWx5VmFsaWRhdGlvbk1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGNvbnN0IEVYUFJfVkFMSURBVE9SUyA9IEZPUk1MWV9WQUxJREFUT1JTLm1hcCgodikgPT4gYHRlbXBsYXRlT3B0aW9ucy4ke3Z9YCk7XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlJCA9IG1lcmdlKHRoaXMuZmllbGQuZm9ybUNvbnRyb2wuc3RhdHVzQ2hhbmdlcywgIXRoaXMuZmllbGQub3B0aW9uc1xuICAgICAgICAgICAgPyBvZihudWxsKVxuICAgICAgICAgICAgOiB0aGlzLmZpZWxkLm9wdGlvbnMuZmllbGRDaGFuZ2VzLnBpcGUoZmlsdGVyKCh7IGZpZWxkLCB0eXBlLCBwcm9wZXJ0eSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChmaWVsZCA9PT0gdGhpcy5maWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlID09PSAnZXhwcmVzc2lvbkNoYW5nZXMnICYmXG4gICAgICAgICAgICAgICAgICAgIChwcm9wZXJ0eS5pbmRleE9mKCd2YWxpZGF0aW9uJykgIT09IC0xIHx8IEVYUFJfVkFMSURBVE9SUy5pbmRleE9mKHByb3BlcnR5KSAhPT0gLTEpKTtcbiAgICAgICAgICAgIH0pKSkucGlwZShzdGFydFdpdGgobnVsbCksIHN3aXRjaE1hcCgoKSA9PiAoaXNPYnNlcnZhYmxlKHRoaXMuZXJyb3JNZXNzYWdlKSA/IHRoaXMuZXJyb3JNZXNzYWdlIDogb2YodGhpcy5lcnJvck1lc3NhZ2UpKSkpO1xuICAgIH1cbiAgICBnZXQgZXJyb3JNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBmaWVsZEZvcm0gPSB0aGlzLmZpZWxkLmZvcm1Db250cm9sO1xuICAgICAgICBmb3IgKGNvbnN0IGVycm9yIGluIGZpZWxkRm9ybS5lcnJvcnMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZEZvcm0uZXJyb3JzLmhhc093blByb3BlcnR5KGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5jb25maWcuZ2V0VmFsaWRhdG9yTWVzc2FnZShlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGZpZWxkRm9ybS5lcnJvcnNbZXJyb3JdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRGb3JtLmVycm9yc1tlcnJvcl0uZXJyb3JQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEZvcm0uZXJyb3JzW2Vycm9yXS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gZmllbGRGb3JtLmVycm9yc1tlcnJvcl0ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWVsZC52YWxpZGF0aW9uPy5tZXNzYWdlcz8uW2Vycm9yXSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5maWVsZC52YWxpZGF0aW9uLm1lc3NhZ2VzW2Vycm9yXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmllbGQudmFsaWRhdG9ycz8uW2Vycm9yXT8ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5maWVsZC52YWxpZGF0b3JzW2Vycm9yXS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWVsZC5hc3luY1ZhbGlkYXRvcnM/LltlcnJvcl0/Lm1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuZmllbGQuYXN5bmNWYWxpZGF0b3JzW2Vycm9yXS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UoZmllbGRGb3JtLmVycm9yc1tlcnJvcl0sIHRoaXMuZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbkZvcm1seVZhbGlkYXRpb25NZXNzYWdlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlWYWxpZGF0aW9uTWVzc2FnZSwgZGVwczogW3sgdG9rZW46IEZvcm1seUNvbmZpZyB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5Db21wb25lbnQgfSk7XG5Gb3JtbHlWYWxpZGF0aW9uTWVzc2FnZS7JtWNtcCA9IGkwLsm1ybVuZ0RlY2xhcmVDb21wb25lbnQoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgdHlwZTogRm9ybWx5VmFsaWRhdGlvbk1lc3NhZ2UsIHNlbGVjdG9yOiBcImZvcm1seS12YWxpZGF0aW9uLW1lc3NhZ2VcIiwgaW5wdXRzOiB7IGZpZWxkOiBcImZpZWxkXCIgfSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogJ3t7IGVycm9yTWVzc2FnZSQgfCBhc3luYyB9fScsIGlzSW5saW5lOiB0cnVlLCBwaXBlczogeyBcImFzeW5jXCI6IGkyJDEuQXN5bmNQaXBlIH0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlWYWxpZGF0aW9uTWVzc2FnZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybWx5LXZhbGlkYXRpb24tbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAne3sgZXJyb3JNZXNzYWdlJCB8IGFzeW5jIH19JyxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBGb3JtbHlDb25maWcgfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IGZpZWxkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuXG5jbGFzcyBGaWVsZEFycmF5VHlwZSBleHRlbmRzIEZpZWxkVHlwZSB7XG4gICAgb25Qb3B1bGF0ZShmaWVsZCkge1xuICAgICAgICBpZiAoIWZpZWxkLmZvcm1Db250cm9sICYmIGhhc0tleShmaWVsZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2wgPSBmaW5kQ29udHJvbChmaWVsZCk7XG4gICAgICAgICAgICByZWdpc3RlckNvbnRyb2woZmllbGQsIGNvbnRyb2wgPyBjb250cm9sIDogbmV3IEZvcm1BcnJheShbXSwgeyB1cGRhdGVPbjogZmllbGQubW9kZWxPcHRpb25zLnVwZGF0ZU9uIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZC5maWVsZEdyb3VwID0gZmllbGQuZmllbGRHcm91cCB8fCBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQXJyYXkuaXNBcnJheShmaWVsZC5tb2RlbCkgPyBmaWVsZC5tb2RlbC5sZW5ndGggOiAwO1xuICAgICAgICBpZiAoZmllbGQuZmllbGRHcm91cC5sZW5ndGggPiBsZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmaWVsZC5maWVsZEdyb3VwLmxlbmd0aCAtIDE7IGkgPj0gbGVuZ3RoOyAtLWkpIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyQ29udHJvbChmaWVsZC5maWVsZEdyb3VwW2ldLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmaWVsZC5maWVsZEdyb3VwLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZmllbGQuZmllbGRHcm91cC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZiA9IHtcbiAgICAgICAgICAgICAgICAuLi5jbG9uZSh0eXBlb2YgZmllbGQuZmllbGRBcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IGZpZWxkLmZpZWxkQXJyYXkoZmllbGQpIDogZmllbGQuZmllbGRBcnJheSksXG4gICAgICAgICAgICAgICAga2V5OiBgJHtpfWAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cC5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZChpLCBpbml0aWFsTW9kZWwsIHsgbWFya0FzRGlydHkgfSA9IHsgbWFya0FzRGlydHk6IHRydWUgfSkge1xuICAgICAgICBpID0gaSA9PSBudWxsID8gdGhpcy5maWVsZC5maWVsZEdyb3VwLmxlbmd0aCA6IGk7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbCkge1xuICAgICAgICAgICAgYXNzaWduRmllbGRWYWx1ZSh0aGlzLmZpZWxkLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbC5zcGxpY2UoaSwgMCwgaW5pdGlhbE1vZGVsID8gY2xvbmUoaW5pdGlhbE1vZGVsKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX2J1aWxkKCk7XG4gICAgICAgIG1hcmtBc0RpcnR5ICYmIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICB9XG4gICAgcmVtb3ZlKGksIHsgbWFya0FzRGlydHkgfSA9IHsgbWFya0FzRGlydHk6IHRydWUgfSkge1xuICAgICAgICB0aGlzLm1vZGVsLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkLmZpZWxkR3JvdXBbaV07XG4gICAgICAgIHRoaXMuZmllbGQuZmllbGRHcm91cC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuZmllbGQuZmllbGRHcm91cC5mb3JFYWNoKChmLCBrZXkpID0+IChmLmtleSA9IGAke2tleX1gKSk7XG4gICAgICAgIHVucmVnaXN0ZXJDb250cm9sKGZpZWxkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fYnVpbGQoKTtcbiAgICAgICAgbWFya0FzRGlydHkgJiYgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSgpO1xuICAgIH1cbiAgICBfYnVpbGQoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGQuZm9ybUNvbnRyb2wuX2ZpZWxkcyA/PyBbdGhpcy5maWVsZF07XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKChmKSA9PiB0aGlzLm9wdGlvbnMuYnVpbGQoZikpO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZmllbGRDaGFuZ2VzLm5leHQoe1xuICAgICAgICAgICAgZmllbGQ6IHRoaXMuZmllbGQsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RmllbGRWYWx1ZSh0aGlzLmZpZWxkKSxcbiAgICAgICAgICAgIHR5cGU6ICd2YWx1ZUNoYW5nZXMnLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5GaWVsZEFycmF5VHlwZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRmllbGRBcnJheVR5cGUsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuRmllbGRBcnJheVR5cGUuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIHR5cGU6IEZpZWxkQXJyYXlUeXBlLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRmllbGRBcnJheVR5cGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmVcbiAgICAgICAgfV0gfSk7XG5cbmNsYXNzIEZpZWxkV3JhcHBlciBleHRlbmRzIEZpZWxkVHlwZSB7XG4gICAgc2V0IF9zdGF0aWNDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5maWVsZENvbXBvbmVudCA9IGNvbnRlbnQ7XG4gICAgfVxufVxuRmllbGRXcmFwcGVyLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGaWVsZFdyYXBwZXIsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuRmllbGRXcmFwcGVyLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCB0eXBlOiBGaWVsZFdyYXBwZXIsIHZpZXdRdWVyaWVzOiBbeyBwcm9wZXJ0eU5hbWU6IFwiZmllbGRDb21wb25lbnRcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogW1wiZmllbGRDb21wb25lbnRcIl0sIGRlc2NlbmRhbnRzOiB0cnVlLCByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9zdGF0aWNDb250ZW50XCIsIGZpcnN0OiB0cnVlLCBwcmVkaWNhdGU6IFtcImZpZWxkQ29tcG9uZW50XCJdLCBkZXNjZW5kYW50czogdHJ1ZSwgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH1dLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRmllbGRXcmFwcGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBmaWVsZENvbXBvbmVudDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmaWVsZENvbXBvbmVudCcsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9XVxuICAgICAgICAgICAgfV0sIF9zdGF0aWNDb250ZW50OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFZpZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2ZpZWxkQ29tcG9uZW50JywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKiBAaWdub3JlICovXG5jbGFzcyBGb3JtbHlUZW1wbGF0ZVR5cGUgZXh0ZW5kcyBGaWVsZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNhbml0aXplcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNhbml0aXplciA9IHNhbml0aXplcjtcbiAgICAgICAgdGhpcy5pbm5lckh0bWwgPSB7fTtcbiAgICB9XG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5maWVsZCAmJiB0aGlzLmZpZWxkLnRlbXBsYXRlICE9PSB0aGlzLmlubmVySHRtbC50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5pbm5lckh0bWwgPSB7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuZmllbGQudGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGhpcy5wcm9wcy5zYWZlSHRtbFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RIdG1sKHRoaXMuZmllbGQudGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5maWVsZC50ZW1wbGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXJIdG1sLmNvbnRlbnQ7XG4gICAgfVxufVxuRm9ybWx5VGVtcGxhdGVUeXBlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlUZW1wbGF0ZVR5cGUsIGRlcHM6IFt7IHRva2VuOiBpMS5Eb21TYW5pdGl6ZXIgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuRm9ybWx5VGVtcGxhdGVUeXBlLsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCB0eXBlOiBGb3JtbHlUZW1wbGF0ZVR5cGUsIHNlbGVjdG9yOiBcImZvcm1seS10ZW1wbGF0ZVwiLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IGA8ZGl2IFtpbm5lckh0bWxdPVwidGVtcGxhdGVcIj48L2Rpdj5gLCBpc0lubGluZTogdHJ1ZSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2ggfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seVRlbXBsYXRlVHlwZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybWx5LXRlbXBsYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGA8ZGl2IFtpbm5lckh0bWxdPVwidGVtcGxhdGVcIj48L2Rpdj5gLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkxLkRvbVNhbml0aXplciB9XTsgfSB9KTtcblxuZnVuY3Rpb24gZXZhbFN0cmluZ0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgYXJnTmFtZXMpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oLi4uYXJnTmFtZXMsIGByZXR1cm4gJHtleHByZXNzaW9ufTtgKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV2YWxFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRoaXNBcmcsIGFyZ1ZhbCkge1xuICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5hcHBseSh0aGlzQXJnLCBhcmdWYWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24gPyB0cnVlIDogZmFsc2U7XG4gICAgfVxufVxuXG5jbGFzcyBGaWVsZEV4cHJlc3Npb25FeHRlbnNpb24ge1xuICAgIG9uUG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLl9leHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIGJ1aWx0IGV4cHJlc3Npb25cbiAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChmaWVsZCwgJ19leHByZXNzaW9ucycsIHt9KTtcbiAgICAgICAgb2JzZXJ2ZShmaWVsZCwgWydoaWRlJ10sICh7IGN1cnJlbnRWYWx1ZSwgZmlyc3RDaGFuZ2UgfSkgPT4ge1xuICAgICAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChmaWVsZCwgJ19oaWRlJywgISFjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdENoYW5nZSB8fCAoZmlyc3RDaGFuZ2UgJiYgY3VycmVudFZhbHVlID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLnByb3BzLmhpZGRlbiA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLl9oaWRkZW5GaWVsZHNGb3JDaGVjay5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWVsZC5oaWRlRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgb2JzZXJ2ZShmaWVsZCwgWydoaWRlRXhwcmVzc2lvbiddLCAoeyBjdXJyZW50VmFsdWU6IGV4cHIgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9leHByZXNzaW9ucy5oaWRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb25zKGZpZWxkLCAnaGlkZScsIHR5cGVvZiBleHByID09PSAnYm9vbGVhbicgPyAoKSA9PiBleHByIDogZXhwcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmFsRXhwciA9IChrZXksIGV4cHIpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXhwciA9PT0gJ3N0cmluZycgfHwgaXNGdW5jdGlvbihleHByKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9leHByZXNzaW9uc1trZXldID0gdGhpcy5wYXJzZUV4cHJlc3Npb25zKGZpZWxkLCBrZXksIGV4cHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZXhwcmVzc2lvbnNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUkOiBleHByLnBpcGUodGFwKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2YWxFeHByKGZpZWxkLCBrZXksIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQub3B0aW9ucy5kZXRlY3RDaGFuZ2VzKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZpZWxkLmV4cHJlc3Npb25zID0gZmllbGQuZXhwcmVzc2lvbnMgfHwge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkLmV4cHJlc3Npb25zKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZShmaWVsZCwgWydleHByZXNzaW9ucycsIGtleV0sICh7IGN1cnJlbnRWYWx1ZTogZXhwciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZhbEV4cHIoa2V5LCBpc0Z1bmN0aW9uKGV4cHIpID8gKC4uLmFyZ3MpID0+IGV4cHIoZmllbGQsIGFyZ3NbM10pIDogZXhwcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZC5leHByZXNzaW9uUHJvcGVydGllcyA9IGZpZWxkLmV4cHJlc3Npb25Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhmaWVsZC5leHByZXNzaW9uUHJvcGVydGllcykpIHtcbiAgICAgICAgICAgIG9ic2VydmUoZmllbGQsIFsnZXhwcmVzc2lvblByb3BlcnRpZXMnLCBrZXldLCAoeyBjdXJyZW50VmFsdWUgfSkgPT4gZXZhbEV4cHIoa2V5LCBjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3N0UG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmllbGQub3B0aW9ucy5jaGVja0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICBsZXQgY2hlY2tMb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuY2hlY2tFeHByZXNzaW9ucyA9IChmLCBpZ25vcmVDYWNoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0xvY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZENoYW5nZWQgPSB0aGlzLmNoZWNrRXhwcmVzc2lvbnMoZiwgaWdub3JlQ2FjaGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBmaWVsZC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX2hpZGRlbkZpZWxkc0ZvckNoZWNrXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChmKSA9PiAoZi5oaWRlID8gLTEgOiAxKSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGYpID0+IHRoaXMuY2hhbmdlSGlkZVN0YXRlKGYsIGYuaGlkZSwgIWlnbm9yZUNhY2hlKSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5faGlkZGVuRmllbGRzRm9yQ2hlY2sgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9ucyhmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5vcHRpb25zICYmIGZpZWxkLm9wdGlvbnMuZGV0ZWN0Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQub3B0aW9ucy5kZXRlY3RDaGFuZ2VzKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja0xvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpZWxkLm9wdGlvbnMuX2NoZWNrRmllbGQgPSAoZiwgaWdub3JlQ2FjaGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZvcm1seTogJ29wdGlvbnMuX2NoZWNrRmllbGQnIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjYuMCwgdXNlICdvcHRpb25zLmNoZWNrRXhwcmVzc2lvbnMnIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgZmllbGQub3B0aW9ucy5jaGVja0V4cHJlc3Npb25zKGYsIGlnbm9yZUNhY2hlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VFeHByZXNzaW9ucyhmaWVsZCwgcGF0aCwgZXhwcikge1xuICAgICAgICBsZXQgcGFyZW50RXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGZpZWxkLnBhcmVudCAmJiBbJ2hpZGUnLCAncHJvcHMuZGlzYWJsZWQnXS5pbmNsdWRlcyhwYXRoKSkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdFZhbHVlID0gKGYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCA9PT0gJ2hpZGUnID8gZi5oaWRlIDogZi5wcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwYXJlbnRFeHByZXNzaW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByb290ID0gZmllbGQucGFyZW50O1xuICAgICAgICAgICAgICAgIHdoaWxlIChyb290LnBhcmVudCAmJiAhcm9vdFZhbHVlKHJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RWYWx1ZShyb290KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZXhwciA9IGV4cHIgfHwgKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHByID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXhwciA9IGV2YWxTdHJpbmdFeHByZXNzaW9uKGV4cHIsIFsnbW9kZWwnLCAnZm9ybVN0YXRlJywgJ2ZpZWxkJ10pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50VmFsdWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxsYmFjazogKGlnbm9yZUNhY2hlKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwclZhbHVlID0gZXZhbEV4cHJlc3Npb24ocGFyZW50RXhwcmVzc2lvbiA/ICguLi5hcmdzKSA9PiBwYXJlbnRFeHByZXNzaW9uKGZpZWxkKSB8fCBleHByKC4uLmFyZ3MpIDogZXhwciwgeyBmaWVsZCB9LCBbZmllbGQubW9kZWwsIGZpZWxkLm9wdGlvbnMuZm9ybVN0YXRlLCBmaWVsZCwgaWdub3JlQ2FjaGVdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUNhY2hlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSBleHByVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWlzT2JqZWN0KGV4cHJWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPYnNlcnZhYmxlKGV4cHJWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZXhwclZhbHVlKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudFZhbHVlKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBleHByVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV2YWxFeHByKGZpZWxkLCBwYXRoLCBleHByVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9IGBbRm9ybWx5IEVycm9yXSBbRXhwcmVzc2lvbiBcIiR7cGF0aH1cIl0gJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrRXhwcmVzc2lvbnMoZmllbGQsIGlnbm9yZUNhY2hlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGZpZWxkLl9leHByZXNzaW9ucykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmllbGQuX2V4cHJlc3Npb25zKSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9leHByZXNzaW9uc1trZXldLmNhbGxiYWNrPy4oaWdub3JlQ2FjaGUpICYmIChmaWVsZENoYW5nZWQgPSB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWVsZC5maWVsZEdyb3VwPy5mb3JFYWNoKChmKSA9PiB0aGlzLmNoZWNrRXhwcmVzc2lvbnMoZiwgaWdub3JlQ2FjaGUpICYmIChmaWVsZENoYW5nZWQgPSB0cnVlKSk7XG4gICAgICAgIHJldHVybiBmaWVsZENoYW5nZWQ7XG4gICAgfVxuICAgIGNoYW5nZURpc2FibGVkU3RhdGUoZmllbGQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChmaWVsZC5maWVsZEdyb3VwKSB7XG4gICAgICAgICAgICBmaWVsZC5maWVsZEdyb3VwXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZikgPT4gIWYuX2V4cHJlc3Npb25zLmhhc093blByb3BlcnR5KCdwcm9wcy5kaXNhYmxlZCcpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChmKSA9PiB0aGlzLmNoYW5nZURpc2FibGVkU3RhdGUoZiwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzS2V5KGZpZWxkKSAmJiBmaWVsZC5wcm9wcy5kaXNhYmxlZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGZpZWxkLnByb3BzLmRpc2FibGVkID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhbmdlSGlkZVN0YXRlKGZpZWxkLCBoaWRlLCByZXNldE9uSGlkZSkge1xuICAgICAgICBpZiAoZmllbGQuZmllbGRHcm91cCkge1xuICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cFxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGYpID0+ICFmLl9leHByZXNzaW9ucy5oaWRlKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChmKSA9PiB0aGlzLmNoYW5nZUhpZGVTdGF0ZShmLCBoaWRlLCByZXNldE9uSGlkZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5mb3JtQ29udHJvbCAmJiBoYXNLZXkoZmllbGQpKSB7XG4gICAgICAgICAgICBkZWZpbmVIaWRkZW5Qcm9wKGZpZWxkLCAnX2hpZGUnLCAhIShoaWRlIHx8IGZpZWxkLmhpZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBmaWVsZC5mb3JtQ29udHJvbDtcbiAgICAgICAgICAgIGlmIChjLl9maWVsZHM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWxpZGl0eShjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWRlID09PSB0cnVlICYmICghYy5fZmllbGRzIHx8IGMuX2ZpZWxkcy5ldmVyeSgoZikgPT4gISFmLl9oaWRlKSkpIHtcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyQ29udHJvbChmaWVsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0T25IaWRlICYmIGZpZWxkLnJlc2V0T25IaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbkZpZWxkVmFsdWUoZmllbGQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmZvcm1Db250cm9sLnJlc2V0KHsgdmFsdWU6IHVuZGVmaW5lZCwgZGlzYWJsZWQ6IGZpZWxkLmZvcm1Db250cm9sLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5vcHRpb25zLmZpZWxkQ2hhbmdlcy5uZXh0KHsgdmFsdWU6IHVuZGVmaW5lZCwgZmllbGQsIHR5cGU6ICd2YWx1ZUNoYW5nZXMnIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuZmllbGRHcm91cCAmJiBmaWVsZC5mb3JtQ29udHJvbCBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVzZXRPbkhpZGUgJiYgIWlzVW5kZWZpbmVkKGZpZWxkLmRlZmF1bHRWYWx1ZSkgJiYgaXNVbmRlZmluZWQoZ2V0RmllbGRWYWx1ZShmaWVsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbkZpZWxkVmFsdWUoZmllbGQsIGZpZWxkLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyQ29udHJvbChmaWVsZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVzZXRPbkhpZGUgJiYgZmllbGQuZmllbGRBcnJheSAmJiBmaWVsZC5maWVsZEdyb3VwPy5sZW5ndGggIT09IGZpZWxkLm1vZGVsPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQub3B0aW9ucy5idWlsZChmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25zLmZpZWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgZmllbGQub3B0aW9ucy5maWVsZENoYW5nZXMubmV4dCh7IGZpZWxkLCB0eXBlOiAnaGlkZGVuJywgdmFsdWU6IGhpZGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZhbEV4cHIoZmllbGQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZmllbGQ7XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IHRoaXMuX2V2YWxFeHByZXNzaW9uUGF0aChmaWVsZCwgcHJvcCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBwYXRocy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtwYXRoc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcGF0aHNbbGFzdEluZGV4XV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgW0Zvcm1seSBFcnJvcl0gW0V4cHJlc3Npb24gXCIke3Byb3B9XCJdICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFsndGVtcGxhdGVPcHRpb25zLmRpc2FibGVkJywgJ3Byb3BzLmRpc2FibGVkJ10uaW5jbHVkZXMocHJvcCkgJiYgaGFzS2V5KGZpZWxkKSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEaXNhYmxlZFN0YXRlKGZpZWxkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3AuaW5kZXhPZignbW9kZWwuJykgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3AucmVwbGFjZSgvXm1vZGVsXFwuLywgJycpLCBjb250cm9sID0gZmllbGQ/LmtleSA9PT0ga2V5ID8gZmllbGQuZm9ybUNvbnRyb2wgOiBmaWVsZC5mb3JtLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wgJiYgIShpc05pbChjb250cm9sLnZhbHVlKSAmJiBpc05pbCh2YWx1ZSkpICYmIGNvbnRyb2wudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXRFeHByZXNzaW9uQ2hhbmdlcyhmaWVsZCwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgICBlbWl0RXhwcmVzc2lvbkNoYW5nZXMoZmllbGQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIWZpZWxkLm9wdGlvbnMuZmllbGRDaGFuZ2VzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmllbGQub3B0aW9ucy5maWVsZENoYW5nZXMubmV4dCh7XG4gICAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICAgIHR5cGU6ICdleHByZXNzaW9uQ2hhbmdlcycsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2V2YWxFeHByZXNzaW9uUGF0aChmaWVsZCwgcHJvcCkge1xuICAgICAgICBpZiAoZmllbGQuX2V4cHJlc3Npb25zW3Byb3BdICYmIGZpZWxkLl9leHByZXNzaW9uc1twcm9wXS5wYXRocykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkLl9leHByZXNzaW9uc1twcm9wXS5wYXRocztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF0aHMgPSBbXTtcbiAgICAgICAgaWYgKHByb3AuaW5kZXhPZignWycpID09PSAtMSkge1xuICAgICAgICAgICAgcGF0aHMgPSBwcm9wLnNwbGl0KCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICAgICAgLnNwbGl0KC9bW1xcXV17MSwyfS8pIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDE5ODIwNlxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHApID0+IHApXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheVBhdGggPSBwYXRoLm1hdGNoKC9bJ3xcIl0oLio/KVsnfFwiXS8pO1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChhcnJheVBhdGhbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCguLi5wYXRoLnNwbGl0KCcuJykuZmlsdGVyKChwKSA9PiBwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLl9leHByZXNzaW9uc1twcm9wXSkge1xuICAgICAgICAgICAgZmllbGQuX2V4cHJlc3Npb25zW3Byb3BdLnBhdGhzID0gcGF0aHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH1cbn1cblxuY2xhc3MgRmllbGRWYWxpZGF0aW9uRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIG9uUG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgdGhpcy5pbml0RmllbGRWYWxpZGF0aW9uKGZpZWxkLCAndmFsaWRhdG9ycycpO1xuICAgICAgICB0aGlzLmluaXRGaWVsZFZhbGlkYXRpb24oZmllbGQsICdhc3luY1ZhbGlkYXRvcnMnKTtcbiAgICB9XG4gICAgaW5pdEZpZWxkVmFsaWRhdGlvbihmaWVsZCwgdHlwZSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgICAgIGlmICh0eXBlID09PSAndmFsaWRhdG9ycycgJiYgIShmaWVsZC5oYXNPd25Qcm9wZXJ0eSgnZmllbGRHcm91cCcpICYmICFoYXNLZXkoZmllbGQpKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuZ2V0UHJlZGVmaW5lZEZpZWxkVmFsaWRhdGlvbihmaWVsZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFt0eXBlXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0b3JOYW1lIG9mIE9iamVjdC5rZXlzKGZpZWxkW3R5cGVdKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvck5hbWUgPT09ICd2YWxpZGF0aW9uJ1xuICAgICAgICAgICAgICAgICAgICA/IHZhbGlkYXRvcnMucHVzaCguLi5maWVsZFt0eXBlXS52YWxpZGF0aW9uLm1hcCgodikgPT4gdGhpcy53cmFwTmdWYWxpZGF0b3JGbihmaWVsZCwgdikpKVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkYXRvcnMucHVzaCh0aGlzLndyYXBOZ1ZhbGlkYXRvckZuKGZpZWxkLCBmaWVsZFt0eXBlXVt2YWxpZGF0b3JOYW1lXSwgdmFsaWRhdG9yTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlZmluZUhpZGRlblByb3AoZmllbGQsICdfJyArIHR5cGUsIHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICBnZXRQcmVkZWZpbmVkRmllbGRWYWxpZGF0aW9uKGZpZWxkKSB7XG4gICAgICAgIGxldCBWQUxJREFUT1JTID0gW107XG4gICAgICAgIEZPUk1MWV9WQUxJREFUT1JTLmZvckVhY2goKG9wdCkgPT4gb2JzZXJ2ZShmaWVsZCwgWydwcm9wcycsIG9wdF0sICh7IGN1cnJlbnRWYWx1ZSwgZmlyc3RDaGFuZ2UgfSkgPT4ge1xuICAgICAgICAgICAgVkFMSURBVE9SUyA9IFZBTElEQVRPUlMuZmlsdGVyKChvKSA9PiBvICE9PSBvcHQpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBWQUxJREFUT1JTLnB1c2gob3B0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmlyc3RDaGFuZ2UgJiYgZmllbGQuZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWxpZGl0eShmaWVsZC5mb3JtQ29udHJvbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBpZiAoVkFMSURBVE9SUy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBWYWxpZGF0b3JzLmNvbXBvc2UoVkFMSURBVE9SUy5tYXAoKG9wdCkgPT4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQucHJvcHNbb3B0XTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5yZXF1aXJlZChjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGF0dGVybic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5wYXR0ZXJuKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWluTGVuZ3RoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbkxlbmd0aFJlc3VsdCA9IFZhbGlkYXRvcnMubWluTGVuZ3RoKHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pbkxlbmd0aEtleSA9IHRoaXMuY29uZmlnLmdldFZhbGlkYXRvck1lc3NhZ2UoJ21pbmxlbmd0aCcpIHx8IGZpZWxkLnZhbGlkYXRpb24/Lm1lc3NhZ2VzPy5taW5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdtaW5sZW5ndGgnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWluTGVuZ3RoJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtaW5MZW5ndGhSZXN1bHQgPyB7IFttaW5MZW5ndGhLZXldOiBtaW5MZW5ndGhSZXN1bHQubWlubGVuZ3RoIH0gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXhMZW5ndGgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4TGVuZ3RoUmVzdWx0ID0gVmFsaWRhdG9ycy5tYXhMZW5ndGgodmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4TGVuZ3RoS2V5ID0gdGhpcy5jb25maWcuZ2V0VmFsaWRhdG9yTWVzc2FnZSgnbWF4bGVuZ3RoJykgfHwgZmllbGQudmFsaWRhdGlvbj8ubWVzc2FnZXM/Lm1heGxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ21heGxlbmd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdtYXhMZW5ndGgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1heExlbmd0aFJlc3VsdCA/IHsgW21heExlbmd0aEtleV06IG1heExlbmd0aFJlc3VsdC5tYXhsZW5ndGggfSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsaWRhdG9ycy5taW4odmFsdWUpKGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnMubWF4KHZhbHVlKShjb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKShjb250cm9sKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgd3JhcE5nVmFsaWRhdG9yRm4oZmllbGQsIHZhbGlkYXRvciwgdmFsaWRhdG9yTmFtZSkge1xuICAgICAgICBsZXQgdmFsaWRhdG9yT3B0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvck9wdGlvbiA9IGNsb25lKHRoaXMuY29uZmlnLmdldFZhbGlkYXRvcih2YWxpZGF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PT0gJ29iamVjdCcgJiYgdmFsaWRhdG9yLm5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvck9wdGlvbiA9IGNsb25lKHRoaXMuY29uZmlnLmdldFZhbGlkYXRvcih2YWxpZGF0b3IubmFtZSkpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yT3B0aW9uLm9wdGlvbnMgPSB2YWxpZGF0b3Iub3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PT0gJ29iamVjdCcgJiYgdmFsaWRhdG9yLmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXhwcmVzc2lvbiwgLi4ub3B0aW9ucyB9ID0gdmFsaWRhdG9yO1xuICAgICAgICAgICAgdmFsaWRhdG9yT3B0aW9uID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHZhbGlkYXRvck5hbWUsXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggPiAwID8gb3B0aW9ucyA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JPcHRpb24gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogdmFsaWRhdG9yTmFtZSxcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0b3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gdmFsaWRhdG9yT3B0aW9uLnZhbGlkYXRpb24oY29udHJvbCwgZmllbGQsIHZhbGlkYXRvck9wdGlvbi5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcnMudGhlbigodikgPT4gdGhpcy5oYW5kbGVBc3luY1Jlc3VsdChmaWVsZCwgdmFsaWRhdG9yTmFtZSA/ICEhdiA6IHYsIHZhbGlkYXRvck9wdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShlcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5waXBlKG1hcCgodikgPT4gdGhpcy5oYW5kbGVBc3luY1Jlc3VsdChmaWVsZCwgdmFsaWRhdG9yTmFtZSA/ICEhdiA6IHYsIHZhbGlkYXRvck9wdGlvbikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3VsdChmaWVsZCwgdmFsaWRhdG9yTmFtZSA/ICEhZXJyb3JzIDogZXJyb3JzLCB2YWxpZGF0b3JPcHRpb24pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBoYW5kbGVBc3luY1Jlc3VsdChmaWVsZCwgZXJyb3JzLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzEzMjAwXG4gICAgICAgIGZpZWxkLm9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyhmaWVsZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3VsdChmaWVsZCwgZXJyb3JzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KGZpZWxkLCBlcnJvcnMsIHsgbmFtZSwgb3B0aW9ucyB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3JzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyA/IG51bGwgOiB7IFtuYW1lXTogb3B0aW9ucyA/IG9wdGlvbnMgOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3RybCA9IGZpZWxkLmZvcm1Db250cm9sO1xuICAgICAgICBjdHJsPy5fY2hpbGRyZW5FcnJvcnM/LltuYW1lXT8uKCk7XG4gICAgICAgIGlmIChpc09iamVjdChlcnJvcnMpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhlcnJvcnMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclBhdGggPSBlcnJvcnNbbmFtZV0uZXJyb3JQYXRoID8gZXJyb3JzW25hbWVdLmVycm9yUGF0aCA6IG9wdGlvbnM/LmVycm9yUGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0cmwgPSBlcnJvclBhdGggPyBmaWVsZC5mb3JtQ29udHJvbC5nZXQoZXJyb3JQYXRoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3RybCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yUGF0aDogX2Vycm9yUGF0aCwgLi4ub3B0cyB9ID0gZXJyb3JzW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEN0cmwuc2V0RXJyb3JzKHsgLi4uKGNoaWxkQ3RybC5lcnJvcnMgfHwge30pLCBbbmFtZV06IG9wdHMgfSk7XG4gICAgICAgICAgICAgICAgICAgICFjdHJsLl9jaGlsZHJlbkVycm9ycyAmJiBkZWZpbmVIaWRkZW5Qcm9wKGN0cmwsICdfY2hpbGRyZW5FcnJvcnMnLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuX2NoaWxkcmVuRXJyb3JzW25hbWVdID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBbbmFtZV06IF90b0RlbGV0ZSwgLi4uY2hpbGRFcnJvcnMgfSA9IGNoaWxkQ3RybC5lcnJvcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZEN0cmwuc2V0RXJyb3JzKE9iamVjdC5rZXlzKGNoaWxkRXJyb3JzKS5sZW5ndGggPT09IDAgPyBudWxsIDogY2hpbGRFcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfVxufVxuXG5jbGFzcyBGaWVsZEZvcm1FeHRlbnNpb24ge1xuICAgIHByZVBvcHVsYXRlKGZpZWxkKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBmaWVsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQucGFyZW50KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmllbGQsICdmb3JtJywge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gZmllbGQucGFyZW50LmZvcm1Db250cm9sLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLmhhc093blByb3BlcnR5KCdmaWVsZEdyb3VwJykgJiYgIWhhc0tleShmaWVsZCkpIHtcbiAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3AoZmllbGQsICdmb3JtQ29udHJvbCcsIGZpZWxkLmZvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRGb3JtQ29udHJvbChmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zdFBvcHVsYXRlKGZpZWxkKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgIT09IGZpZWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgY29uc3QgbWFya0ZvckNoZWNrID0gdGhpcy5zZXRWYWxpZGF0b3JzKGZpZWxkKTtcbiAgICAgICAgaWYgKG1hcmtGb3JDaGVjayAmJiBmaWVsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSBmaWVsZC5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0tleShwYXJlbnQpIHx8ICFwYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkaXR5KHBhcmVudC5mb3JtQ29udHJvbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRm9ybUNvbnRyb2woZmllbGQpIHtcbiAgICAgICAgbGV0IGNvbnRyb2wgPSBmaW5kQ29udHJvbChmaWVsZCk7XG4gICAgICAgIGlmICghY29udHJvbCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbE9wdGlvbnMgPSB7IHVwZGF0ZU9uOiBmaWVsZC5tb2RlbE9wdGlvbnMudXBkYXRlT24gfTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5maWVsZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbCA9IG5ldyBGb3JtR3JvdXAoe30sIGNvbnRyb2xPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGFzS2V5KGZpZWxkKSA/IGdldEZpZWxkVmFsdWUoZmllbGQpIDogZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woeyB2YWx1ZSwgZGlzYWJsZWQ6IGZhbHNlIH0sIHsgLi4uY29udHJvbE9wdGlvbnMsIGluaXRpYWxWYWx1ZUlzRGVmYXVsdDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckNvbnRyb2woZmllbGQsIGNvbnRyb2wpO1xuICAgIH1cbiAgICBzZXRWYWxpZGF0b3JzKGZpZWxkLCBkaXNhYmxlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkaXNhYmxlZCA9PT0gZmFsc2UgJiYgaGFzS2V5KGZpZWxkKSAmJiBmaWVsZC5wcm9wcz8uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya0ZvckNoZWNrID0gZmFsc2U7XG4gICAgICAgIGZpZWxkLmZpZWxkR3JvdXA/LmZvckVhY2goKGYpID0+IGYgJiYgdGhpcy5zZXRWYWxpZGF0b3JzKGYsIGRpc2FibGVkKSAmJiAobWFya0ZvckNoZWNrID0gdHJ1ZSkpO1xuICAgICAgICBpZiAoaGFzS2V5KGZpZWxkKSB8fCAhZmllbGQucGFyZW50IHx8ICghaGFzS2V5KGZpZWxkKSAmJiAhZmllbGQuZmllbGRHcm91cCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybUNvbnRyb2w6IGMgfSA9IGZpZWxkO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzS2V5KGZpZWxkKSAmJiBjIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkICYmIGMuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5kaXNhYmxlKHsgZW1pdEV2ZW50OiBmYWxzZSwgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrRm9yQ2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQgJiYgYy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5lbmFibGUoeyBlbWl0RXZlbnQ6IGZhbHNlLCBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtGb3JDaGVjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT09IGMudmFsaWRhdG9yIHx8IG51bGwgPT09IGMuYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRWYWxpZGF0b3JzKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBWYWxpZGF0b3JzLmNvbXBvc2UodGhpcy5tZXJnZVZhbGlkYXRvcnMoZmllbGQsICdfdmFsaWRhdG9ycycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID8gdihjKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjLnNldEFzeW5jVmFsaWRhdG9ycygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModGhpcy5tZXJnZVZhbGlkYXRvcnMoZmllbGQsICdfYXN5bmNWYWxpZGF0b3JzJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPyB2KGMpIDogb2YobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBtYXJrRm9yQ2hlY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya0ZvckNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkaXR5KGMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdmFsaWRpdHkgb2YgYEZvcm1Hcm91cGAgaW5zdGFuY2UgY3JlYXRlZCBieSBmaWVsZCB3aXRoIG5lc3RlZCBrZXkuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBjLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBnZXRLZXlQYXRoKGZpZWxkKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkaXR5KHBhcmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya0ZvckNoZWNrO1xuICAgIH1cbiAgICBtZXJnZVZhbGlkYXRvcnMoZmllbGQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICBjb25zdCBjID0gZmllbGQuZm9ybUNvbnRyb2w7XG4gICAgICAgIGlmIChjPy5fZmllbGRzPy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjLl9maWVsZHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmKSA9PiAhZi5faGlkZSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZikgPT4gdmFsaWRhdG9ycy5wdXNoKC4uLmZbdHlwZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFt0eXBlXSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKC4uLmZpZWxkW3R5cGVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQuZmllbGRHcm91cCkge1xuICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cFxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGYpID0+IGY/LmZpZWxkR3JvdXAgJiYgIWhhc0tleShmKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoZikgPT4gdmFsaWRhdG9ycy5wdXNoKC4uLnRoaXMubWVyZ2VWYWxpZGF0b3JzKGYsIHR5cGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnM7XG4gICAgfVxufVxuXG5jbGFzcyBDb3JlRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuZm9ybUlkID0gMDtcbiAgICB9XG4gICAgcHJlUG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IGZpZWxkLnBhcmVudDtcbiAgICAgICAgdGhpcy5pbml0Um9vdE9wdGlvbnMoZmllbGQpO1xuICAgICAgICB0aGlzLmluaXRGaWVsZFByb3BzKGZpZWxkKTtcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWVsZCwgJ29wdGlvbnMnLCB7IGdldDogKCkgPT4gcm9vdC5vcHRpb25zLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmllbGQsICdtb2RlbCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IChoYXNLZXkoZmllbGQpICYmIGZpZWxkLmZpZWxkR3JvdXAgPyBnZXRGaWVsZFZhbHVlKGZpZWxkKSA6IHJvb3QubW9kZWwpLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWVsZCwgJ2dldCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAoa2V5KSA9PiBnZXRGaWVsZChmaWVsZCwga2V5KSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0RmllbGRDb21wb25lbnRJbnN0YW5jZShmaWVsZCkucHJlUG9wdWxhdGU/LihmaWVsZCk7XG4gICAgfVxuICAgIG9uUG9wdWxhdGUoZmllbGQpIHtcbiAgICAgICAgdGhpcy5pbml0RmllbGRPcHRpb25zKGZpZWxkKTtcbiAgICAgICAgdGhpcy5nZXRGaWVsZENvbXBvbmVudEluc3RhbmNlKGZpZWxkKS5vblBvcHVsYXRlPy4oZmllbGQpO1xuICAgICAgICBpZiAoZmllbGQuZmllbGRHcm91cCkge1xuICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cC5mb3JFYWNoKChmLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAncGFyZW50JywgeyBnZXQ6ICgpID0+IGZpZWxkLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCAnaW5kZXgnLCB7IGdldDogKCkgPT4gaW5kZXgsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtSWQrKztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc3RQb3B1bGF0ZShmaWVsZCkge1xuICAgICAgICB0aGlzLmdldEZpZWxkQ29tcG9uZW50SW5zdGFuY2UoZmllbGQpLnBvc3RQb3B1bGF0ZT8uKGZpZWxkKTtcbiAgICB9XG4gICAgaW5pdEZpZWxkUHJvcHMoZmllbGQpIHtcbiAgICAgICAgZmllbGQucHJvcHMgPz8gKGZpZWxkLnByb3BzID0gZmllbGQudGVtcGxhdGVPcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpZWxkLCAndGVtcGxhdGVPcHRpb25zJywge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiBmaWVsZC5wcm9wcyxcbiAgICAgICAgICAgIHNldDogKHByb3BzKSA9PiAoZmllbGQucHJvcHMgPSBwcm9wcyksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0Um9vdE9wdGlvbnMoZmllbGQpIHtcbiAgICAgICAgaWYgKGZpZWxkLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBmaWVsZC5vcHRpb25zO1xuICAgICAgICBmaWVsZC5vcHRpb25zLmZvcm1TdGF0ZSA9IGZpZWxkLm9wdGlvbnMuZm9ybVN0YXRlIHx8IHt9O1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2hvd0Vycm9yKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNob3dFcnJvciA9IHRoaXMuY29uZmlnLmV4dHJhcy5zaG93RXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLmZpZWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgZGVmaW5lSGlkZGVuUHJvcChvcHRpb25zLCAnZmllbGRDaGFuZ2VzJywgbmV3IFN1YmplY3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLl9oaWRkZW5GaWVsZHNGb3JDaGVjaykge1xuICAgICAgICAgICAgb3B0aW9ucy5faGlkZGVuRmllbGRzRm9yQ2hlY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLl9tYXJrRm9yQ2hlY2sgPSAoZikgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBGb3JtbHk6ICdvcHRpb25zLl9tYXJrRm9yQ2hlY2snIGlzIGRlcHJlY2F0ZWQgc2luY2UgdjYuMCwgdXNlICdvcHRpb25zLmRldGVjdENoYW5nZXMnIGluc3RlYWQuYCk7XG4gICAgICAgICAgICBvcHRpb25zLmRldGVjdENoYW5nZXMoZik7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyA9IChmKSA9PiB7XG4gICAgICAgICAgICBpZiAoZi5fY29tcG9uZW50UmVmcykge1xuICAgICAgICAgICAgICAgIGYub3B0aW9ucy5jaGVja0V4cHJlc3Npb25zKGYpO1xuICAgICAgICAgICAgICAgIG1hcmtGaWVsZEZvckNoZWNrKGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZi5maWVsZEdyb3VwPy5mb3JFYWNoKChmKSA9PiBmICYmIG9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyhmKSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMucmVzZXRNb2RlbCA9IChtb2RlbCkgPT4ge1xuICAgICAgICAgICAgbW9kZWwgPSBjbG9uZShtb2RlbCA/PyBvcHRpb25zLl9pbml0aWFsTW9kZWwpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGQubW9kZWwpLmZvckVhY2goKGspID0+IGRlbGV0ZSBmaWVsZC5tb2RlbFtrXSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihmaWVsZC5tb2RlbCwgbW9kZWwgfHwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5idWlsZChmaWVsZCk7XG4gICAgICAgICAgICBmaWVsZC5mb3JtLnJlc2V0KGZpZWxkLm1vZGVsKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBhcmVudEZvcm0gJiYgb3B0aW9ucy5wYXJlbnRGb3JtLmNvbnRyb2wgPT09IGZpZWxkLmZvcm1Db250cm9sKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXJlbnRGb3JtLnN1Ym1pdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVwZGF0ZUluaXRpYWxWYWx1ZSA9IChtb2RlbCkgPT4gKG9wdGlvbnMuX2luaXRpYWxNb2RlbCA9IGNsb25lKG1vZGVsID8/IGZpZWxkLm1vZGVsKSk7XG4gICAgICAgIGZpZWxkLm9wdGlvbnMudXBkYXRlSW5pdGlhbFZhbHVlKCk7XG4gICAgfVxuICAgIGluaXRGaWVsZE9wdGlvbnMoZmllbGQpIHtcbiAgICAgICAgcmV2ZXJzZURlZXBNZXJnZShmaWVsZCwge1xuICAgICAgICAgICAgaWQ6IGdldEZpZWxkSWQoYGZvcm1seV8ke3RoaXMuZm9ybUlkfWAsIGZpZWxkLCBmaWVsZC5pbmRleCksXG4gICAgICAgICAgICBob29rczoge30sXG4gICAgICAgICAgICBtb2RlbE9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBtZXNzYWdlczoge30gfSxcbiAgICAgICAgICAgIHByb3BzOiAhZmllbGQudHlwZSB8fCAhaGFzS2V5KGZpZWxkKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmV4dHJhcy5yZXNldEZpZWxkT25IaWRlICYmIGZpZWxkLnJlc2V0T25IaWRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZmllbGQucmVzZXRPbkhpZGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC50eXBlICE9PSAnZm9ybWx5LXRlbXBsYXRlJyAmJlxuICAgICAgICAgICAgKGZpZWxkLnRlbXBsYXRlIHx8IGZpZWxkLmV4cHJlc3Npb25zPy50ZW1wbGF0ZSB8fCBmaWVsZC5leHByZXNzaW9uUHJvcGVydGllcz8udGVtcGxhdGUpKSB7XG4gICAgICAgICAgICBmaWVsZC50eXBlID0gJ2Zvcm1seS10ZW1wbGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmaWVsZC50eXBlICYmIGZpZWxkLmZpZWxkR3JvdXApIHtcbiAgICAgICAgICAgIGZpZWxkLnR5cGUgPSAnZm9ybWx5LWdyb3VwJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuZ2V0TWVyZ2VkRmllbGQoZmllbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNLZXkoZmllbGQpICYmICFpc1VuZGVmaW5lZChmaWVsZC5kZWZhdWx0VmFsdWUpICYmIGlzVW5kZWZpbmVkKGdldEZpZWxkVmFsdWUoZmllbGQpKSkge1xuICAgICAgICAgICAgY29uc3QgaXNIaWRkZW4gPSAoZikgPT4gZi5oaWRlIHx8IGYuZXhwcmVzc2lvbnM/LmhpZGUgfHwgZi5oaWRlRXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGxldCBzZXREZWZhdWx0VmFsdWUgPSAhZmllbGQucmVzZXRPbkhpZGUgfHwgIWlzSGlkZGVuKGZpZWxkKTtcbiAgICAgICAgICAgIGlmICghaXNIaWRkZW4oZmllbGQpICYmIGZpZWxkLnJlc2V0T25IaWRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9IGZpZWxkLnBhcmVudDtcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmICFpc0hpZGRlbihwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldERlZmF1bHRWYWx1ZSA9ICFwYXJlbnQgfHwgIWlzSGlkZGVuKHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0RGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduRmllbGRWYWx1ZShmaWVsZCwgZmllbGQuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaWVsZC53cmFwcGVycyA9IGZpZWxkLndyYXBwZXJzIHx8IFtdO1xuICAgIH1cbiAgICBnZXRGaWVsZENvbXBvbmVudEluc3RhbmNlKGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFJlZkluc3RhbmNlID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudFJlZiA9IHRoaXMuY29uZmlnLnJlc29sdmVGaWVsZFR5cGVSZWYoZmllbGQpO1xuICAgICAgICAgICAgY29uc3QgZmllbGRDb21wb25lbnRSZWYgPSBmaWVsZC5fY29tcG9uZW50UmVmcz8uc2xpY2UoLTEpWzBdO1xuICAgICAgICAgICAgaWYgKGZpZWxkQ29tcG9uZW50UmVmIGluc3RhbmNlb2YgQ29tcG9uZW50UmVmICYmXG4gICAgICAgICAgICAgICAgZmllbGRDb21wb25lbnRSZWY/LmNvbXBvbmVudFR5cGUgPT09IGNvbXBvbmVudFJlZj8uY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJlZiA9IGZpZWxkQ29tcG9uZW50UmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZj8uaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghZmllbGQuX3Byb3h5SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGRlZmluZUhpZGRlblByb3AoZmllbGQsICdfcHJveHlJbnN0YW5jZScsIG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgICAgIGdldDogKF8sIHByb3ApID0+IGNvbXBvbmVudFJlZkluc3RhbmNlKCk/Lltwcm9wXSxcbiAgICAgICAgICAgICAgICBzZXQ6IChfLCBwcm9wLCB2YWx1ZSkgPT4gKGNvbXBvbmVudFJlZkluc3RhbmNlKClbcHJvcF0gPSB2YWx1ZSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkLl9wcm94eUluc3RhbmNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZvcm1seUNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnZm9ybWx5LWdyb3VwJywgY29tcG9uZW50OiBGb3JtbHlHcm91cCB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnZm9ybWx5LXRlbXBsYXRlJywgY29tcG9uZW50OiBGb3JtbHlUZW1wbGF0ZVR5cGUgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZXh0ZW5zaW9uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnY29yZScsIGV4dGVuc2lvbjogbmV3IENvcmVFeHRlbnNpb24oY29uZmlnKSwgcHJpb3JpdHk6IC0yNTAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2ZpZWxkLXZhbGlkYXRpb24nLCBleHRlbnNpb246IG5ldyBGaWVsZFZhbGlkYXRpb25FeHRlbnNpb24oY29uZmlnKSwgcHJpb3JpdHk6IC0yMDAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2ZpZWxkLWZvcm0nLCBleHRlbnNpb246IG5ldyBGaWVsZEZvcm1FeHRlbnNpb24oKSwgcHJpb3JpdHk6IC0xNTAgfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2ZpZWxkLWV4cHJlc3Npb24nLCBleHRlbnNpb246IG5ldyBGaWVsZEV4cHJlc3Npb25FeHRlbnNpb24oKSwgcHJpb3JpdHk6IC0xMDAgfSxcbiAgICAgICAgXSxcbiAgICB9O1xufVxuY2xhc3MgRm9ybWx5TW9kdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWdTZXJ2aWNlLCBjb25maWdzID0gW10pIHtcbiAgICAgICAgaWYgKCFjb25maWdzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlncy5mb3JFYWNoKChjb25maWcpID0+IGNvbmZpZ1NlcnZpY2UuYWRkQ29uZmlnKGNvbmZpZykpO1xuICAgIH1cbiAgICBzdGF0aWMgZm9yUm9vdChjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEZvcm1seU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRk9STUxZX0NPTkZJRywgbXVsdGk6IHRydWUsIHVzZUZhY3Rvcnk6IGRlZmF1bHRGb3JtbHlDb25maWcsIGRlcHM6IFtGb3JtbHlDb25maWddIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBGT1JNTFlfQ09ORklHLCB1c2VWYWx1ZTogY29uZmlnLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIEZvcm1seUNvbmZpZyxcbiAgICAgICAgICAgICAgICBGb3JtbHlGb3JtQnVpbGRlcixcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDaGlsZChjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEZvcm1seU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogRk9STUxZX0NPTkZJRywgbXVsdGk6IHRydWUsIHVzZUZhY3Rvcnk6IGRlZmF1bHRGb3JtbHlDb25maWcsIGRlcHM6IFtGb3JtbHlDb25maWddIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBGT1JNTFlfQ09ORklHLCB1c2VWYWx1ZTogY29uZmlnLCBtdWx0aTogdHJ1ZSB9LFxuICAgICAgICAgICAgICAgIEZvcm1seUZvcm1CdWlsZGVyLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Gb3JtbHlNb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seU1vZHVsZSwgZGVwczogW3sgdG9rZW46IEZvcm1seUNvbmZpZyB9LCB7IHRva2VuOiBGT1JNTFlfQ09ORklHLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkZvcm1seU1vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seU1vZHVsZSwgZGVjbGFyYXRpb25zOiBbRm9ybWx5VGVtcGxhdGUsXG4gICAgICAgIEZvcm1seUZvcm0sXG4gICAgICAgIEZvcm1seUZpZWxkLFxuICAgICAgICBGb3JtbHlBdHRyaWJ1dGVzLFxuICAgICAgICBGb3JtbHlHcm91cCxcbiAgICAgICAgRm9ybWx5VmFsaWRhdGlvbk1lc3NhZ2UsXG4gICAgICAgIEZvcm1seVRlbXBsYXRlVHlwZV0sIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBleHBvcnRzOiBbRm9ybWx5VGVtcGxhdGUsIEZvcm1seUZvcm0sIEZvcm1seUZpZWxkLCBGb3JtbHlBdHRyaWJ1dGVzLCBGb3JtbHlHcm91cCwgRm9ybWx5VmFsaWRhdGlvbk1lc3NhZ2VdIH0pO1xuRm9ybWx5TW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5TW9kdWxlLCBpbXBvcnRzOiBbW0NvbW1vbk1vZHVsZV1dIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgRm9ybWx5VGVtcGxhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JtbHlGb3JtLFxuICAgICAgICAgICAgICAgICAgICAgICAgRm9ybWx5RmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JtbHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgRm9ybWx5R3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBGb3JtbHlWYWxpZGF0aW9uTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvcm1seVRlbXBsYXRlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0Zvcm1seVRlbXBsYXRlLCBGb3JtbHlGb3JtLCBGb3JtbHlGaWVsZCwgRm9ybWx5QXR0cmlidXRlcywgRm9ybWx5R3JvdXAsIEZvcm1seVZhbGlkYXRpb25NZXNzYWdlXSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBGb3JtbHlDb25maWcgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtGT1JNTFlfQ09ORklHXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuXG4vKlxuICogUHVibGljIEFQSSBTdXJmYWNlIG9mIGNvcmVcbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEZPUk1MWV9DT05GSUcsIEZpZWxkQXJyYXlUeXBlLCBGaWVsZFR5cGUsIEZpZWxkV3JhcHBlciwgRm9ybWx5Q29uZmlnLCBGb3JtbHlGaWVsZCwgRm9ybWx5Rm9ybSwgRm9ybWx5Rm9ybUJ1aWxkZXIsIEZvcm1seU1vZHVsZSwgRm9ybWx5QXR0cmlidXRlcyBhcyDJtUZvcm1seUF0dHJpYnV0ZXMsIEZvcm1seUdyb3VwIGFzIMm1Rm9ybWx5R3JvdXAsIEZvcm1seVRlbXBsYXRlIGFzIMm1Rm9ybWx5VGVtcGxhdGUsIEZvcm1seVZhbGlkYXRpb25NZXNzYWdlIGFzIMm1Rm9ybWx5VmFsaWRhdGlvbk1lc3NhZ2UsIGNsb25lIGFzIMm1Y2xvbmUsIGRlZmluZUhpZGRlblByb3AgYXMgybVkZWZpbmVIaWRkZW5Qcm9wLCBnZXRGaWVsZFZhbHVlIGFzIMm1Z2V0RmllbGRWYWx1ZSwgaGFzS2V5IGFzIMm1aGFzS2V5LCBvYnNlcnZlIGFzIMm1b2JzZXJ2ZSwgcmV2ZXJzZURlZXBNZXJnZSBhcyDJtXJldmVyc2VEZWVwTWVyZ2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5neC1mb3JtbHktY29yZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core.mjs\n");

/***/ })

}]);