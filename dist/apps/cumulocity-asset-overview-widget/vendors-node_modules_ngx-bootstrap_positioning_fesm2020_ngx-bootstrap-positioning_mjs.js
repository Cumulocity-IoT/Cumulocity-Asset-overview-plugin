"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_ngx-bootstrap_positioning_fesm2020_ngx-bootstrap-positioning_mjs"],{

/***/ "./node_modules/ngx-bootstrap/positioning/fesm2020/ngx-bootstrap-positioning.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/ngx-bootstrap/positioning/fesm2020/ngx-bootstrap-positioning.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PlacementForBs5\": function() { return /* binding */ PlacementForBs5; },\n/* harmony export */   \"Positioning\": function() { return /* binding */ Positioning; },\n/* harmony export */   \"PositioningService\": function() { return /* binding */ PositioningService; },\n/* harmony export */   \"checkMargins\": function() { return /* binding */ checkMargins; },\n/* harmony export */   \"positionElements\": function() { return /* binding */ positionElements; }\n/* harmony export */ });\n/* harmony import */ var ngx_bootstrap_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ngx-bootstrap/utils */ \"webpack/sharing/consume/default/ngx-bootstrap/utils/ngx-bootstrap/utils\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n\n\n\n\n\n\nvar MapPlacementInToRL;\n(function (MapPlacementInToRL) {\n    MapPlacementInToRL[\"top\"] = \"top\";\n    MapPlacementInToRL[\"bottom\"] = \"bottom\";\n    MapPlacementInToRL[\"left\"] = \"left\";\n    MapPlacementInToRL[\"right\"] = \"right\";\n    MapPlacementInToRL[\"auto\"] = \"auto\";\n    MapPlacementInToRL[\"end\"] = \"right\";\n    MapPlacementInToRL[\"start\"] = \"left\";\n    MapPlacementInToRL[\"top left\"] = \"top left\";\n    MapPlacementInToRL[\"top right\"] = \"top right\";\n    MapPlacementInToRL[\"right top\"] = \"right top\";\n    MapPlacementInToRL[\"right bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom right\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom left\"] = \"bottom left\";\n    MapPlacementInToRL[\"left bottom\"] = \"left bottom\";\n    MapPlacementInToRL[\"left top\"] = \"left top\";\n    MapPlacementInToRL[\"top start\"] = \"top left\";\n    MapPlacementInToRL[\"top end\"] = \"top right\";\n    MapPlacementInToRL[\"end top\"] = \"right top\";\n    MapPlacementInToRL[\"end bottom\"] = \"right bottom\";\n    MapPlacementInToRL[\"bottom end\"] = \"bottom right\";\n    MapPlacementInToRL[\"bottom start\"] = \"bottom left\";\n    MapPlacementInToRL[\"start bottom\"] = \"start bottom\";\n    MapPlacementInToRL[\"start top\"] = \"left top\";\n})(MapPlacementInToRL || (MapPlacementInToRL = {}));\nvar PlacementForBs5;\n(function (PlacementForBs5) {\n    PlacementForBs5[\"top\"] = \"top\";\n    PlacementForBs5[\"bottom\"] = \"bottom\";\n    PlacementForBs5[\"left\"] = \"start\";\n    PlacementForBs5[\"right\"] = \"end\";\n    PlacementForBs5[\"auto\"] = \"auto\";\n    PlacementForBs5[\"end\"] = \"end\";\n    PlacementForBs5[\"start\"] = \"start\";\n    PlacementForBs5[\"top left\"] = \"top start\";\n    PlacementForBs5[\"top right\"] = \"top end\";\n    PlacementForBs5[\"right top\"] = \"end top\";\n    PlacementForBs5[\"right bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom right\"] = \"bottom end\";\n    PlacementForBs5[\"bottom left\"] = \"bottom start\";\n    PlacementForBs5[\"left bottom\"] = \"start bottom\";\n    PlacementForBs5[\"left top\"] = \"start top\";\n    PlacementForBs5[\"top start\"] = \"top start\";\n    PlacementForBs5[\"top end\"] = \"top end\";\n    PlacementForBs5[\"end top\"] = \"end top\";\n    PlacementForBs5[\"end bottom\"] = \"end bottom\";\n    PlacementForBs5[\"bottom end\"] = \"bottom end\";\n    PlacementForBs5[\"bottom start\"] = \"bottom start\";\n    PlacementForBs5[\"start bottom\"] = \"start bottom\";\n    PlacementForBs5[\"start top\"] = \"start top\";\n})(PlacementForBs5 || (PlacementForBs5 = {}));\n\nfunction getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const window = element.ownerDocument.defaultView;\n    const css = window?.getComputedStyle(element, null);\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return property ? css && css[property] : css;\n}\n\n/**\n * Returns the offset parent of the given element\n */\nfunction getOffsetParent(element) {\n    if (!element) {\n        return document.documentElement;\n    }\n    const noOffsetParent = null;\n    // NOTE: 1 DOM access here\n    let offsetParent = element?.offsetParent;\n    // Skip hidden elements which don't have an offsetParent\n    let sibling = void 0;\n    while (offsetParent === noOffsetParent\n        && element.nextElementSibling\n        && sibling !== element.nextElementSibling) {\n        // todo: valorkin fix\n        sibling = element.nextElementSibling;\n        offsetParent = sibling.offsetParent;\n    }\n    const nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n        return sibling ? sibling.ownerDocument.documentElement : document.documentElement;\n    }\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    if (offsetParent &&\n        ['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 &&\n        getStyleComputedProperty(offsetParent, 'position') === 'static') {\n        return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n}\n\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isOffsetContainer(element) {\n    const { nodeName } = element;\n    if (nodeName === 'BODY') {\n        return false;\n    }\n    return (nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element);\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n */\nfunction getRoot(node) {\n    if (node.parentNode !== null) {\n        return getRoot(node.parentNode);\n    }\n    return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n */\nfunction findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n        return document.documentElement;\n    }\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    const order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    const start = order ? element1 : element2;\n    const end = order ? element2 : element1;\n    // Get common ancestor container\n    const range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    // todo: valorkin fix\n    const commonAncestorContainer = range.commonAncestorContainer;\n    // Both nodes are inside #document\n    if ((element1 !== commonAncestorContainer &&\n        element2 !== commonAncestorContainer) ||\n        start.contains(end)) {\n        if (isOffsetContainer(commonAncestorContainer)) {\n            return commonAncestorContainer;\n        }\n        return getOffsetParent(commonAncestorContainer);\n    }\n    // one of the nodes is inside shadowDOM, find which one\n    const element1root = getRoot(element1);\n    if (element1root.host) {\n        return findCommonOffsetParent(element1root.host, element2);\n    }\n    else {\n        return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n */\nfunction getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement) {\n        return document.documentElement;\n    }\n    let el = element.parentElement;\n    while (el?.parentElement && getStyleComputedProperty(el, 'transform') === 'none') {\n        el = el.parentElement;\n    }\n    return el || document.documentElement;\n}\n\n/**\n * Helper to detect borders of a given element\n */\nfunction getBordersSize(styles, axis) {\n    const sideA = axis === 'x' ? 'Left' : 'Top';\n    const sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return (parseFloat(styles[`border${sideA}Width`]) +\n        parseFloat(styles[`border${sideB}Width`]));\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n    const _body = body;\n    const _html = html;\n    const _computedStyle = computedStyle;\n    return Math.max(_body[`offset${axis}`], _body[`scroll${axis}`], _html[`client${axis}`], _html[`offset${axis}`], _html[`scroll${axis}`], 0);\n}\nfunction getWindowSizes(document) {\n    const body = document.body;\n    const html = document.documentElement;\n    const computedStyle = void 0;\n    return {\n        height: getSize('Height', body, html, computedStyle),\n        width: getSize('Width', body, html, computedStyle)\n    };\n}\n\nfunction getClientRect(offsets) {\n    return {\n        ...offsets,\n        right: (offsets.left || 0) + offsets.width,\n        bottom: (offsets.top || 0) + offsets.height\n    };\n}\n\n/**\n * Tells if a given input is a number\n */\nfunction isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(Number(n));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\n/**\n * Get bounding client rect of given element\n */\nfunction getBoundingClientRect(element) {\n    const rect = element.getBoundingClientRect();\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    // try {\n    //   if (isIE(10)) {\n    //     const scrollTop = getScroll(element, 'top');\n    //     const scrollLeft = getScroll(element, 'left');\n    //     if (rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right)) {\n    //       rect.top += scrollTop;\n    //       rect.left += scrollLeft;\n    //       rect.bottom += scrollTop;\n    //       rect.right += scrollLeft;\n    //     }\n    //   }\n    // } catch (e) {\n    //   return rect;\n    // }\n    if (!(rect && isNumber(rect.top) && isNumber(rect.left) && isNumber(rect.bottom) && isNumber(rect.right))) {\n        return rect;\n    }\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n    };\n    // subtract scrollbar size from sizes\n    const sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : undefined;\n    const width = sizes?.width || element.clientWidth\n        || isNumber(rect.right) && isNumber(result.left) && rect.right - result.left || 0;\n    const height = sizes?.height || element.clientHeight\n        || isNumber(rect.bottom) && isNumber(result.top) && rect.bottom - result.top || 0;\n    let horizScrollbar = element.offsetWidth - width;\n    let vertScrollbar = element.offsetHeight - height;\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n        const styles = getStyleComputedProperty(element);\n        horizScrollbar -= getBordersSize(styles, 'x');\n        vertScrollbar -= getBordersSize(styles, 'y');\n        result.width -= horizScrollbar;\n        result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n}\n\n/**\n * Returns the parentNode or the host of the element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n */\n// todo: valorkin fix\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n        return document.body;\n    }\n    switch (element.nodeName) {\n        case 'HTML':\n        case 'BODY':\n            return element.ownerDocument.body;\n        case '#document':\n            return element.body;\n        default:\n    }\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll|overlay)/.test(String(overflow) + String(overflowY) + String(overflowX))) {\n        return element;\n    }\n    return getScrollParent(getParentNode(element));\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent, fixedPosition = false) {\n    const isHTML = parent.nodeName === 'HTML';\n    const childrenRect = getBoundingClientRect(children);\n    const parentRect = getBoundingClientRect(parent);\n    const scrollParent = getScrollParent(children);\n    const styles = getStyleComputedProperty(parent);\n    const borderTopWidth = parseFloat(styles.borderTopWidth);\n    const borderLeftWidth = parseFloat(styles.borderLeftWidth);\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n        parentRect.top = Math.max(parentRect.top ?? 0, 0);\n        parentRect.left = Math.max(parentRect.left ?? 0, 0);\n    }\n    const offsets = getClientRect({\n        top: (childrenRect.top ?? 0) - (parentRect.top ?? 0) - borderTopWidth,\n        left: (childrenRect.left ?? 0) - (parentRect.left ?? 0) - borderLeftWidth,\n        width: childrenRect.width,\n        height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (isHTML) {\n        const marginTop = parseFloat(styles.marginTop);\n        const marginLeft = parseFloat(styles.marginLeft);\n        if (isNumber(offsets.top)) {\n            offsets.top -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.bottom)) {\n            offsets.bottom -= borderTopWidth - marginTop;\n        }\n        if (isNumber(offsets.left)) {\n            offsets.left -= borderLeftWidth - marginLeft;\n        }\n        if (isNumber(offsets.right)) {\n            offsets.right -= borderLeftWidth - marginLeft;\n        }\n        // Attach marginTop and marginLeft because in some circumstances we may need them\n        offsets.marginTop = marginTop;\n        offsets.marginLeft = marginLeft;\n    }\n    return offsets;\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n */\nfunction getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        const html = element.ownerDocument.documentElement;\n        const scrollingElement = element.ownerDocument.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element, excludeScroll = false) {\n    const html = element.ownerDocument.documentElement;\n    const relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    const width = Math.max(html.clientWidth, window.innerWidth || 0);\n    const height = Math.max(html.clientHeight, window.innerHeight || 0);\n    const scrollTop = !excludeScroll ? getScroll(html) : 0;\n    const scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    const offset = {\n        top: scrollTop - Number(relativeOffset?.top) + Number(relativeOffset?.marginTop),\n        left: scrollLeft - Number(relativeOffset?.left) + Number(relativeOffset?.marginLeft),\n        width,\n        height\n    };\n    return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n */\nfunction isFixed(element) {\n    const nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n\nfunction getBoundaries(target, host, padding = 0, boundariesElement, fixedPosition = false) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = fixedPosition ? getFixedPositionOffsetParent(target) : findCommonOffsetParent(target, host);\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    }\n    else {\n        // Handle other cases based on DOM element used as boundaries\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(getParentNode(host));\n            if (boundariesNode.nodeName === 'BODY') {\n                boundariesNode = target.ownerDocument.documentElement;\n            }\n        }\n        else if (boundariesElement === 'window') {\n            boundariesNode = target.ownerDocument.documentElement;\n        }\n        else {\n            boundariesNode = boundariesElement;\n        }\n        const offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n        // In case of HTML, we need a different computation\n        if (offsets && boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n            const { height, width } = getWindowSizes(target.ownerDocument);\n            if (isNumber(boundaries.top) && isNumber(offsets.top) && isNumber(offsets.marginTop)) {\n                boundaries.top += offsets.top - offsets.marginTop;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.bottom = Number(height) + Number(offsets.top);\n            }\n            if (isNumber(boundaries.left) && isNumber(offsets.left) && isNumber(offsets.marginLeft)) {\n                boundaries.left += offsets.left - offsets.marginLeft;\n            }\n            if (isNumber(boundaries.top)) {\n                boundaries.right = Number(width) + Number(offsets.left);\n            }\n        }\n        else if (offsets) {\n            // for all the other DOM elements, this one is good\n            boundaries = offsets;\n        }\n    }\n    // Add paddings\n    if (isNumber(boundaries.left)) {\n        boundaries.left += padding;\n    }\n    if (isNumber(boundaries.top)) {\n        boundaries.top += padding;\n    }\n    if (isNumber(boundaries.right)) {\n        boundaries.right -= padding;\n    }\n    if (isNumber(boundaries.bottom)) {\n        boundaries.bottom -= padding;\n    }\n    return boundaries;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n */\nfunction getArea({ width, height }) {\n    return width * height;\n}\nfunction computeAutoPlacement(placement, refRect, target, host, allowedPositions = ['top', 'bottom', 'right', 'left'], boundariesElement = 'viewport', padding = 0) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n    const boundaries = getBoundaries(target, host, padding, boundariesElement);\n    const rects = {\n        top: {\n            width: boundaries?.width ?? 0,\n            height: (refRect?.top ?? 0) - (boundaries?.top ?? 0)\n        },\n        right: {\n            width: (boundaries?.right ?? 0) - (refRect?.right ?? 0),\n            height: boundaries?.height ?? 0\n        },\n        bottom: {\n            width: boundaries?.width ?? 0,\n            height: (boundaries?.bottom ?? 0) - (refRect?.bottom ?? 0)\n        },\n        left: {\n            width: (refRect.left ?? 0) - (boundaries?.left ?? 0),\n            height: boundaries?.height ?? 0\n        }\n    };\n    const sortedAreas = Object.keys(rects)\n        .map((key) => ({\n        position: key,\n        ...rects[key],\n        area: getArea(rects[key])\n    }))\n        .sort((a, b) => b.area - a.area);\n    let filteredAreas = sortedAreas.filter(({ width, height }) => {\n        return width >= target.clientWidth && height >= target.clientHeight;\n    });\n    filteredAreas = filteredAreas.filter(({ position }) => {\n        return allowedPositions.some((allowedPosition) => {\n            return allowedPosition === position;\n        });\n    });\n    const computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].position : sortedAreas[0].position;\n    const variation = placement.split(' ')[1];\n    // for tooltip on auto position\n    target.className = target.className.replace(/bs-tooltip-auto/g, `bs-tooltip-${(0,ngx_bootstrap_utils__WEBPACK_IMPORTED_MODULE_0__.getBsVer)().isBs5 ? PlacementForBs5[computedPlacement] : computedPlacement}`);\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n\nfunction getOffsets(data) {\n    return {\n        width: data.offsets.target.width,\n        height: data.offsets.target.height,\n        left: Math.floor(data.offsets.target.left ?? 0),\n        top: Math.round(data.offsets.target.top ?? 0),\n        bottom: Math.round(data.offsets.target.bottom ?? 0),\n        right: Math.floor(data.offsets.target.right ?? 0)\n    };\n}\n\n/**\n * Get the opposite placement of the given one\n */\nfunction getOppositePlacement(placement) {\n    const hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, matched => hash[matched]);\n}\n\n/**\n * Get the opposite placement variation of the given one\n */\nfunction getOppositeVariation(variation) {\n    if (variation === 'right') {\n        return 'left';\n    }\n    else if (variation === 'left') {\n        return 'right';\n    }\n    return variation;\n}\n\nconst parse = (value, def = 0) => value ? parseFloat(value) : def;\nfunction getOuterSizes(element) {\n    const window = element.ownerDocument.defaultView;\n    const styles = window?.getComputedStyle(element);\n    const x = parse(styles?.marginTop) + parse(styles?.marginBottom);\n    const y = parse(styles?.marginLeft) + parse(styles?.marginRight);\n    return {\n        width: Number(element.offsetWidth) + y,\n        height: Number(element.offsetHeight) + x\n    };\n}\n\n/**\n * Get offsets to the reference element\n */\nfunction getReferenceOffsets(target, host, fixedPosition) {\n    const commonOffsetParent = fixedPosition\n        ? getFixedPositionOffsetParent(target)\n        : findCommonOffsetParent(target, host);\n    return getOffsetRectRelativeToArbitraryNode(host, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get offsets to the target\n */\nfunction getTargetOffsets(target, hostOffsets, position) {\n    const placement = position.split(' ')[0];\n    // Get target node sizes\n    const targetRect = getOuterSizes(target);\n    // Add position, width and height to our offsets object\n    const targetOffsets = {\n        width: targetRect.width,\n        height: targetRect.height\n    };\n    // depending by the target placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    targetOffsets[mainSide] =\n        (hostOffsets[mainSide] ?? 0) +\n            hostOffsets[measurement] / 2 -\n            targetRect[measurement] / 2;\n    targetOffsets[secondarySide] = placement === secondarySide\n        ? (hostOffsets[secondarySide] ?? 0) - targetRect[secondaryMeasurement]\n        : hostOffsets[getOppositePlacement(secondarySide)] ?? 0;\n    return targetOffsets;\n}\n\nfunction isModifierEnabled(options, modifierName) {\n    return !!options.modifiers[modifierName]?.enabled;\n}\n\nconst availablePositions = {\n    top: ['top', 'top start', 'top end'],\n    bottom: ['bottom', 'bottom start', 'bottom end'],\n    start: ['start', 'start top', 'start bottom'],\n    end: ['end', 'end top', 'end bottom']\n};\nfunction checkPopoverMargin(placement, checkPosition) {\n    if (!(0,ngx_bootstrap_utils__WEBPACK_IMPORTED_MODULE_0__.getBsVer)().isBs5) {\n        return false;\n    }\n    return availablePositions[checkPosition].includes(placement);\n}\nfunction checkMargins(placement) {\n    if (!(0,ngx_bootstrap_utils__WEBPACK_IMPORTED_MODULE_0__.getBsVer)().isBs5) {\n        return '';\n    }\n    if (checkPopoverMargin(placement, 'end')) {\n        return 'ms-2';\n    }\n    if (checkPopoverMargin(placement, 'start')) {\n        return 'me-2';\n    }\n    if (checkPopoverMargin(placement, 'top')) {\n        return 'mb-2';\n    }\n    if (checkPopoverMargin(placement, 'bottom')) {\n        return 'mt-2';\n    }\n    return '';\n}\n\nfunction updateContainerClass(data, renderer) {\n    const target = data.instance.target;\n    let containerClass = target.className;\n    const dataPlacement = (0,ngx_bootstrap_utils__WEBPACK_IMPORTED_MODULE_0__.getBsVer)().isBs5 ? PlacementForBs5[data.placement] : data.placement;\n    if (data.placementAuto) {\n        containerClass = containerClass.replace(/bs-popover-auto/g, `bs-popover-${dataPlacement}`);\n        containerClass = containerClass.replace(/ms-2|me-2|mb-2|mt-2/g, '');\n        containerClass = containerClass.replace(/bs-tooltip-auto/g, `bs-tooltip-${dataPlacement}`);\n        containerClass = containerClass.replace(/\\sauto/g, ` ${dataPlacement}`);\n        if (containerClass.indexOf('popover') !== -1) {\n            containerClass = containerClass + ' ' + checkMargins(dataPlacement);\n        }\n        if (containerClass.indexOf('popover') !== -1 && containerClass.indexOf('popover-auto') === -1) {\n            containerClass += ' popover-auto';\n        }\n        if (containerClass.indexOf('tooltip') !== -1 && containerClass.indexOf('tooltip-auto') === -1) {\n            containerClass += ' tooltip-auto';\n        }\n    }\n    containerClass = containerClass.replace(/left|right|top|bottom|end|start/g, `${dataPlacement.split(' ')[0]}`);\n    if (renderer) {\n        renderer.setAttribute(target, 'class', containerClass);\n        return;\n    }\n    target.className = containerClass;\n}\n\nfunction setStyles(element, styles, renderer) {\n    if (!element || !styles) {\n        return;\n    }\n    Object.keys(styles).forEach((prop) => {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 &&\n            isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        if (renderer) {\n            renderer.setStyle(element, prop, `${String(styles[prop])}${unit}`);\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        element.style[prop] = String(styles[prop]) + unit;\n    });\n}\n\nfunction arrow(data) {\n    let targetOffsets = data.offsets.target;\n    // if arrowElement is a string, suppose it's a CSS selector\n    const arrowElement = data.instance.target.querySelector('.arrow');\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n        return data;\n    }\n    const isVertical = ['left', 'right'].indexOf(data.placement.split(' ')[0]) !== -1;\n    const len = isVertical ? 'height' : 'width';\n    const sideCapitalized = isVertical ? 'Top' : 'Left';\n    const side = sideCapitalized.toLowerCase();\n    const altSide = isVertical ? 'left' : 'top';\n    const opSide = isVertical ? 'bottom' : 'right';\n    const arrowElementSize = getOuterSizes(arrowElement)[len];\n    const placementVariation = data.placement.split(' ')[1];\n    // top/left side\n    if ((data.offsets.host[opSide] ?? 0) - arrowElementSize < (targetOffsets[side] ?? 0)) {\n        (targetOffsets)[side] -=\n            (targetOffsets[side] ?? 0) - ((data.offsets.host[opSide] ?? 0) - arrowElementSize);\n    }\n    // bottom/right side\n    if (Number((data).offsets.host[side]) + Number(arrowElementSize) > (targetOffsets[opSide] ?? 0)) {\n        (targetOffsets)[side] +=\n            Number((data).offsets.host[side]) + Number(arrowElementSize) - Number((targetOffsets)[opSide]);\n    }\n    targetOffsets = getClientRect(targetOffsets);\n    // Compute the sideValue using the updated target offsets\n    // take target margin in account because we don't have this info available\n    const css = getStyleComputedProperty(data.instance.target);\n    const targetMarginSide = parseFloat(css[`margin${sideCapitalized}`]) || 0;\n    const targetBorderSide = parseFloat(css[`border${sideCapitalized}Width`]) || 0;\n    // compute center of the target\n    let center;\n    if (!placementVariation) {\n        center = Number((data).offsets.host[side]) + Number(data.offsets.host[len] / 2 - arrowElementSize / 2);\n    }\n    else {\n        const targetBorderRadius = parseFloat(css[\"borderRadius\"]) || 0;\n        const targetSideArrowOffset = Number(targetMarginSide + targetBorderSide + targetBorderRadius);\n        center = side === placementVariation ?\n            Number((data).offsets.host[side]) + targetSideArrowOffset :\n            Number((data).offsets.host[side]) + Number(data.offsets.host[len] - targetSideArrowOffset);\n    }\n    let sideValue = center - (targetOffsets[side] ?? 0) - targetMarginSide - targetBorderSide;\n    // prevent arrowElement from being placed not contiguously to its target\n    sideValue = Math.max(Math.min(targetOffsets[len] - (arrowElementSize + 5), sideValue), 0);\n    data.offsets.arrow = {\n        [side]: Math.round(sideValue),\n        [altSide]: '' // make sure to unset any eventual altSide value from the DOM node\n    };\n    data.instance.arrow = arrowElement;\n    return data;\n}\n\nfunction flip(data) {\n    data.offsets.target = getClientRect(data.offsets.target);\n    if (!isModifierEnabled(data.options, 'flip')) {\n        data.offsets.target = {\n            ...data.offsets.target,\n            ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n        };\n        return data;\n    }\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    'viewport', false // positionFixed\n    );\n    let placement = data.placement.split(' ')[0];\n    let variation = data.placement.split(' ')[1] || '';\n    const offsetsHost = data.offsets.host;\n    const target = data.instance.target;\n    const host = data.instance.host;\n    const adaptivePosition = computeAutoPlacement('auto', offsetsHost, target, host, data.options.allowedPositions);\n    const flipOrder = [placement, adaptivePosition];\n    flipOrder.forEach((step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return;\n        }\n        placement = data.placement.split(' ')[0];\n        // using floor because the host offsets may contain decimals we are not going to consider here\n        const overlapsRef = (placement === 'left' &&\n            Math.floor(data.offsets.target.right ?? 0) > Math.floor(data.offsets.host.left ?? 0)) ||\n            (placement === 'right' &&\n                Math.floor(data.offsets.target.left ?? 0) < Math.floor(data.offsets.host.right ?? 0)) ||\n            (placement === 'top' &&\n                Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(data.offsets.host.top ?? 0)) ||\n            (placement === 'bottom' &&\n                Math.floor(data.offsets.target.top ?? 0) < Math.floor(data.offsets.host.bottom ?? 0));\n        const overflowsLeft = Math.floor(data.offsets.target.left ?? 0) < Math.floor(boundaries.left ?? 0);\n        const overflowsRight = Math.floor(data.offsets.target.right ?? 0) > Math.floor(boundaries.right ?? 0);\n        const overflowsTop = Math.floor(data.offsets.target.top ?? 0) < Math.floor(boundaries.top ?? 0);\n        const overflowsBottom = Math.floor(data.offsets.target.bottom ?? 0) > Math.floor(boundaries.bottom ?? 0);\n        const overflowsBoundaries = (placement === 'left' && overflowsLeft) ||\n            (placement === 'right' && overflowsRight) ||\n            (placement === 'top' && overflowsTop) ||\n            (placement === 'bottom' && overflowsBottom);\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = ((isVertical && variation === 'left' && overflowsLeft) ||\n            (isVertical && variation === 'right' && overflowsRight) ||\n            (!isVertical && variation === 'left' && overflowsTop) ||\n            (!isVertical && variation === 'right' && overflowsBottom));\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n            data.placement = placement + (variation ? ` ${variation}` : '');\n            data.offsets.target = {\n                ...data.offsets.target,\n                ...getTargetOffsets(data.instance.target, data.offsets.host, data.placement)\n            };\n        }\n    });\n    return data;\n}\n\nfunction initData(targetElement, hostElement, position, options) {\n    if (!targetElement || !hostElement) {\n        return;\n    }\n    const hostElPosition = getReferenceOffsets(targetElement, hostElement);\n    if (!position.match(/^(auto)*\\s*(left|right|top|bottom|start|end)*$/)\n        && !position.match(/^(left|right|top|bottom|start|end)*(?: (left|right|top|bottom|start|end))*$/)) {\n        position = 'auto';\n    }\n    const placementAuto = !!position.match(/auto/g);\n    // support old placements 'auto left|right|top|bottom'\n    let placement = position.match(/auto\\s(left|right|top|bottom|start|end)/)\n        ? position.split(' ')[1] || 'auto'\n        : position;\n    // Normalize placements that have identical main placement and variation (\"right right\" => \"right\").\n    const matches = placement.match(/^(left|right|top|bottom|start|end)* ?(?!\\1)(left|right|top|bottom|start|end)?/);\n    if (matches) {\n        placement = matches[1] + (matches[2] ? ` ${matches[2]}` : '');\n    }\n    // \"left right\", \"top bottom\" etc. placements also considered incorrect.\n    if (['left right', 'right left', 'top bottom', 'bottom top'].indexOf(placement) !== -1) {\n        placement = 'auto';\n    }\n    placement = computeAutoPlacement(placement, hostElPosition, targetElement, hostElement, options ? options.allowedPositions : undefined);\n    const targetOffset = getTargetOffsets(targetElement, hostElPosition, placement);\n    return {\n        options: options || { modifiers: {} },\n        instance: {\n            target: targetElement,\n            host: hostElement,\n            arrow: void 0\n        },\n        offsets: {\n            target: targetOffset,\n            host: hostElPosition,\n            arrow: void 0\n        },\n        positionFixed: false,\n        placement,\n        placementAuto\n    };\n}\n\nfunction preventOverflow(data) {\n    if (!isModifierEnabled(data.options, 'preventOverflow')) {\n        return data;\n    }\n    // NOTE: DOM access here\n    // resets the target Offsets's position so that the document size can be calculated excluding\n    // the size of the targetOffsets element itself\n    const transformProp = 'transform';\n    const targetStyles = data.instance.target.style; // assignment to help minification\n    const { top, left, [transformProp]: transform } = targetStyles;\n    targetStyles.top = '';\n    targetStyles.left = '';\n    targetStyles[transformProp] = '';\n    const boundaries = getBoundaries(data.instance.target, data.instance.host, 0, // padding\n    data.options.modifiers.preventOverflow?.boundariesElement || 'scrollParent', false // positionFixed\n    );\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    targetStyles.top = top;\n    targetStyles.left = left;\n    targetStyles[transformProp] = transform;\n    const order = ['left', 'right', 'top', 'bottom'];\n    const check = {\n        primary(placement) {\n            let value = data.offsets.target[placement];\n            // options.escapeWithReference\n            if ((data.offsets.target[placement] ?? 0) < (boundaries[placement] ?? 0)) {\n                value = Math.max(data.offsets.target[placement] ?? 0, boundaries[placement] ?? 0);\n            }\n            return { [placement]: value };\n        },\n        secondary(placement) {\n            const isPlacementHorizontal = placement === 'right';\n            const mainSide = isPlacementHorizontal ? 'left' : 'top';\n            const measurement = isPlacementHorizontal ? 'width' : 'height';\n            let value = data.offsets.target[mainSide];\n            // escapeWithReference\n            if ((data.offsets.target[placement] ?? 0) > (boundaries[placement] ?? 0)) {\n                value = Math.min(data.offsets.target[mainSide] ?? 0, (boundaries[placement] ?? 0) - data.offsets.target[measurement]);\n            }\n            return { [mainSide]: value };\n        }\n    };\n    order.forEach((placement) => {\n        const side = ['left', 'top', 'start'].indexOf(placement) !== -1 ? check['primary'] : check['secondary'];\n        data.offsets.target = {\n            ...data.offsets.target,\n            ...side(placement)\n        };\n    });\n    return data;\n}\n\nfunction shift(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split(' ')[0];\n    const shiftVariation = placement.split(' ')[1];\n    if (shiftVariation) {\n        const { host, target } = data.offsets;\n        const isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n        const side = isVertical ? 'left' : 'top';\n        const measurement = isVertical ? 'width' : 'height';\n        const shiftOffsets = {\n            start: { [side]: host[side] },\n            end: {\n                [side]: (host[side] ?? 0) + host[measurement] - target[measurement]\n            }\n        };\n        data.offsets.target = {\n            ...target, ...{\n                [side]: (side === shiftVariation ? shiftOffsets.start[side] : shiftOffsets.end[side])\n            }\n        };\n    }\n    return data;\n}\n\nclass Positioning {\n    position(hostElement, targetElement /*, round = true*/) {\n        return this.offset(hostElement, targetElement /*, false*/);\n    }\n    offset(hostElement, targetElement /*, round = true*/) {\n        return getReferenceOffsets(targetElement, hostElement);\n    }\n    positionElements(hostElement, targetElement, position, appendToBody, options) {\n        const chainOfModifiers = [flip, shift, preventOverflow, arrow];\n        const _position = MapPlacementInToRL[position];\n        const data = initData(targetElement, hostElement, _position, options);\n        if (!data) {\n            return;\n        }\n        return chainOfModifiers.reduce((modifiedData, modifier) => modifier(modifiedData), data);\n    }\n}\nconst positionService = new Positioning();\nfunction positionElements(hostElement, targetElement, placement, appendToBody, options, renderer) {\n    const data = positionService.positionElements(hostElement, targetElement, placement, appendToBody, options);\n    if (!data) {\n        return;\n    }\n    const offsets = getOffsets(data);\n    setStyles(targetElement, {\n        'will-change': 'transform',\n        top: '0px',\n        left: '0px',\n        transform: `translate3d(${offsets.left}px, ${offsets.top}px, 0px)`\n    }, renderer);\n    if (data.instance.arrow) {\n        setStyles(data.instance.arrow, data.offsets.arrow, renderer);\n    }\n    updateContainerClass(data, renderer);\n}\n\nclass PositioningService {\n    constructor(ngZone, rendererFactory, platformId) {\n        this.update$$ = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();\n        this.positionElements = new Map();\n        this.isDisabled = false;\n        if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_2__.isPlatformBrowser)(platformId)) {\n            ngZone.runOutsideAngular(() => {\n                this.triggerEvent$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.merge)((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.fromEvent)(window, 'scroll', { passive: true }), (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.fromEvent)(window, 'resize', { passive: true }), (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.of)(0, rxjs__WEBPACK_IMPORTED_MODULE_3__.animationFrameScheduler), this.update$$);\n                this.triggerEvent$.subscribe(() => {\n                    if (this.isDisabled) {\n                        return;\n                    }\n                    this.positionElements\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .forEach((positionElement) => {\n                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));\n                    });\n                });\n            });\n        }\n    }\n    position(options) {\n        this.addPositionElement(options);\n    }\n    get event$() {\n        return this.triggerEvent$;\n    }\n    disable() {\n        this.isDisabled = true;\n    }\n    enable() {\n        this.isDisabled = false;\n    }\n    addPositionElement(options) {\n        this.positionElements.set(_getHtmlElement(options.element), options);\n    }\n    calcPosition() {\n        this.update$$.next(null);\n    }\n    deletePositionElement(elRef) {\n        this.positionElements.delete(_getHtmlElement(elRef));\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n}\nPositioningService.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: PositioningService, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererFactory2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nPositioningService.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: PositioningService, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.0.3\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: PositioningService, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererFactory2 }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]\n                }] }]; } });\nfunction _getHtmlElement(element) {\n    // it means that we got a selector\n    if (typeof element === 'string') {\n        return document.querySelector(element);\n    }\n    if (element instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef) {\n        return element.nativeElement;\n    }\n    return element ?? null;\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=ngx-bootstrap-positioning.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmd4LWJvb3RzdHJhcC9wb3NpdGlvbmluZy9mZXNtMjAyMC9uZ3gtYm9vdHN0cmFwLXBvc2l0aW9uaW5nLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9uZ3gtYm9vdHN0cmFwL3Bvc2l0aW9uaW5nL2Zlc20yMDIwL25neC1ib290c3RyYXAtcG9zaXRpb25pbmcubWpzPzM4ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QnNWZXIgfSBmcm9tICduZ3gtYm9vdHN0cmFwL3V0aWxzJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdGFibGUsIEluamVjdCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgU3ViamVjdCwgbWVyZ2UsIGZyb21FdmVudCwgb2YsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIH0gZnJvbSAncnhqcyc7XG5cbnZhciBNYXBQbGFjZW1lbnRJblRvUkw7XG4oZnVuY3Rpb24gKE1hcFBsYWNlbWVudEluVG9STCkge1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcInRvcFwiXSA9IFwidG9wXCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wiYm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgICBNYXBQbGFjZW1lbnRJblRvUkxbXCJsZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wicmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wiYXV0b1wiXSA9IFwiYXV0b1wiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImVuZFwiXSA9IFwicmlnaHRcIjtcbiAgICBNYXBQbGFjZW1lbnRJblRvUkxbXCJzdGFydFwiXSA9IFwibGVmdFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcInRvcCBsZWZ0XCJdID0gXCJ0b3AgbGVmdFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcInRvcCByaWdodFwiXSA9IFwidG9wIHJpZ2h0XCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wicmlnaHQgdG9wXCJdID0gXCJyaWdodCB0b3BcIjtcbiAgICBNYXBQbGFjZW1lbnRJblRvUkxbXCJyaWdodCBib3R0b21cIl0gPSBcInJpZ2h0IGJvdHRvbVwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImJvdHRvbSByaWdodFwiXSA9IFwiYm90dG9tIHJpZ2h0XCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wiYm90dG9tIGxlZnRcIl0gPSBcImJvdHRvbSBsZWZ0XCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wibGVmdCBib3R0b21cIl0gPSBcImxlZnQgYm90dG9tXCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1wibGVmdCB0b3BcIl0gPSBcImxlZnQgdG9wXCI7XG4gICAgTWFwUGxhY2VtZW50SW5Ub1JMW1widG9wIHN0YXJ0XCJdID0gXCJ0b3AgbGVmdFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcInRvcCBlbmRcIl0gPSBcInRvcCByaWdodFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImVuZCB0b3BcIl0gPSBcInJpZ2h0IHRvcFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImVuZCBib3R0b21cIl0gPSBcInJpZ2h0IGJvdHRvbVwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImJvdHRvbSBlbmRcIl0gPSBcImJvdHRvbSByaWdodFwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcImJvdHRvbSBzdGFydFwiXSA9IFwiYm90dG9tIGxlZnRcIjtcbiAgICBNYXBQbGFjZW1lbnRJblRvUkxbXCJzdGFydCBib3R0b21cIl0gPSBcInN0YXJ0IGJvdHRvbVwiO1xuICAgIE1hcFBsYWNlbWVudEluVG9STFtcInN0YXJ0IHRvcFwiXSA9IFwibGVmdCB0b3BcIjtcbn0pKE1hcFBsYWNlbWVudEluVG9STCB8fCAoTWFwUGxhY2VtZW50SW5Ub1JMID0ge30pKTtcbnZhciBQbGFjZW1lbnRGb3JCczU7XG4oZnVuY3Rpb24gKFBsYWNlbWVudEZvckJzNSkge1xuICAgIFBsYWNlbWVudEZvckJzNVtcInRvcFwiXSA9IFwidG9wXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiYm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJsZWZ0XCJdID0gXCJzdGFydFwiO1xuICAgIFBsYWNlbWVudEZvckJzNVtcInJpZ2h0XCJdID0gXCJlbmRcIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJhdXRvXCJdID0gXCJhdXRvXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiZW5kXCJdID0gXCJlbmRcIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJzdGFydFwiXSA9IFwic3RhcnRcIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJ0b3AgbGVmdFwiXSA9IFwidG9wIHN0YXJ0XCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1widG9wIHJpZ2h0XCJdID0gXCJ0b3AgZW5kXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wicmlnaHQgdG9wXCJdID0gXCJlbmQgdG9wXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wicmlnaHQgYm90dG9tXCJdID0gXCJlbmQgYm90dG9tXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiYm90dG9tIHJpZ2h0XCJdID0gXCJib3R0b20gZW5kXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiYm90dG9tIGxlZnRcIl0gPSBcImJvdHRvbSBzdGFydFwiO1xuICAgIFBsYWNlbWVudEZvckJzNVtcImxlZnQgYm90dG9tXCJdID0gXCJzdGFydCBib3R0b21cIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJsZWZ0IHRvcFwiXSA9IFwic3RhcnQgdG9wXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1widG9wIHN0YXJ0XCJdID0gXCJ0b3Agc3RhcnRcIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJ0b3AgZW5kXCJdID0gXCJ0b3AgZW5kXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiZW5kIHRvcFwiXSA9IFwiZW5kIHRvcFwiO1xuICAgIFBsYWNlbWVudEZvckJzNVtcImVuZCBib3R0b21cIl0gPSBcImVuZCBib3R0b21cIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJib3R0b20gZW5kXCJdID0gXCJib3R0b20gZW5kXCI7XG4gICAgUGxhY2VtZW50Rm9yQnM1W1wiYm90dG9tIHN0YXJ0XCJdID0gXCJib3R0b20gc3RhcnRcIjtcbiAgICBQbGFjZW1lbnRGb3JCczVbXCJzdGFydCBib3R0b21cIl0gPSBcInN0YXJ0IGJvdHRvbVwiO1xuICAgIFBsYWNlbWVudEZvckJzNVtcInN0YXJ0IHRvcFwiXSA9IFwic3RhcnQgdG9wXCI7XG59KShQbGFjZW1lbnRGb3JCczUgfHwgKFBsYWNlbWVudEZvckJzNSA9IHt9KSk7XG5cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICBjb25zdCB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY3NzID0gd2luZG93Py5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHByb3BlcnR5ID8gY3NzICYmIGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICBjb25zdCBub09mZnNldFBhcmVudCA9IG51bGw7XG4gICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICBsZXQgb2Zmc2V0UGFyZW50ID0gZWxlbWVudD8ub2Zmc2V0UGFyZW50O1xuICAgIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gICAgbGV0IHNpYmxpbmcgPSB2b2lkIDA7XG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnRcbiAgICAgICAgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgJiYgc2libGluZyAhPT0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgLy8gdG9kbzogdmFsb3JraW4gZml4XG4gICAgICAgIHNpYmxpbmcgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgb2Zmc2V0UGFyZW50ID0gc2libGluZy5vZmZzZXRQYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcbiAgICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICByZXR1cm4gc2libGluZyA/IHNpYmxpbmcub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgICBpZiAob2Zmc2V0UGFyZW50ICYmXG4gICAgICAgIFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmXG4gICAgICAgIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbi8vIHRvZG86IHZhbG9ya2luIGZpeFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlbGVtZW50O1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudCk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gICAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gICAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgICBjb25zdCBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICAgIGNvbnN0IHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICAgIGNvbnN0IGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcbiAgICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gICAgLy8gdG9kbzogdmFsb3JraW4gZml4XG4gICAgY29uc3QgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG4gICAgaWYgKChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiZcbiAgICAgICAgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSB8fFxuICAgICAgICBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgICB9XG4gICAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICAgIGNvbnN0IGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICAgIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgICAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGxldCBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAoZWw/LnBhcmVudEVsZW1lbnQgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgICBjb25zdCBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICAgIGNvbnN0IHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcbiAgICByZXR1cm4gKHBhcnNlRmxvYXQoc3R5bGVzW2Bib3JkZXIke3NpZGVBfVdpZHRoYF0pICtcbiAgICAgICAgcGFyc2VGbG9hdChzdHlsZXNbYGJvcmRlciR7c2lkZUJ9V2lkdGhgXSkpO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgICBjb25zdCBfYm9keSA9IGJvZHk7XG4gICAgY29uc3QgX2h0bWwgPSBodG1sO1xuICAgIGNvbnN0IF9jb21wdXRlZFN0eWxlID0gY29tcHV0ZWRTdHlsZTtcbiAgICByZXR1cm4gTWF0aC5tYXgoX2JvZHlbYG9mZnNldCR7YXhpc31gXSwgX2JvZHlbYHNjcm9sbCR7YXhpc31gXSwgX2h0bWxbYGNsaWVudCR7YXhpc31gXSwgX2h0bWxbYG9mZnNldCR7YXhpc31gXSwgX2h0bWxbYHNjcm9sbCR7YXhpc31gXSwgMCk7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgICAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm9mZnNldHMsXG4gICAgICAgIHJpZ2h0OiAob2Zmc2V0cy5sZWZ0IHx8IDApICsgb2Zmc2V0cy53aWR0aCxcbiAgICAgICAgYm90dG9tOiAob2Zmc2V0cy50b3AgfHwgMCkgKyBvZmZzZXRzLmhlaWdodFxuICAgIH07XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICAgIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUoTnVtYmVyKG4pKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gICAgY29uc3QgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAgIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAgIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgICAvLyB0cnkge1xuICAgIC8vICAgaWYgKGlzSUUoMTApKSB7XG4gICAgLy8gICAgIGNvbnN0IHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgLy8gICAgIGNvbnN0IHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAvLyAgICAgaWYgKHJlY3QgJiYgaXNOdW1iZXIocmVjdC50b3ApICYmIGlzTnVtYmVyKHJlY3QubGVmdCkgJiYgaXNOdW1iZXIocmVjdC5ib3R0b20pICYmIGlzTnVtYmVyKHJlY3QucmlnaHQpKSB7XG4gICAgLy8gICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgIC8vICAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgIC8vICAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAvLyAgICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9IGNhdGNoIChlKSB7XG4gICAgLy8gICByZXR1cm4gcmVjdDtcbiAgICAvLyB9XG4gICAgaWYgKCEocmVjdCAmJiBpc051bWJlcihyZWN0LnRvcCkgJiYgaXNOdW1iZXIocmVjdC5sZWZ0KSAmJiBpc051bWJlcihyZWN0LmJvdHRvbSkgJiYgaXNOdW1iZXIocmVjdC5yaWdodCkpKSB7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICAgIH07XG4gICAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICAgIGNvbnN0IHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB3aWR0aCA9IHNpemVzPy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgIHx8IGlzTnVtYmVyKHJlY3QucmlnaHQpICYmIGlzTnVtYmVyKHJlc3VsdC5sZWZ0KSAmJiByZWN0LnJpZ2h0IC0gcmVzdWx0LmxlZnQgfHwgMDtcbiAgICBjb25zdCBoZWlnaHQgPSBzaXplcz8uaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgIHx8IGlzTnVtYmVyKHJlY3QuYm90dG9tKSAmJiBpc051bWJlcihyZXN1bHQudG9wKSAmJiByZWN0LmJvdHRvbSAtIHJlc3VsdC50b3AgfHwgMDtcbiAgICBsZXQgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gICAgbGV0IHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcbiAgICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAgIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICAgICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgICAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcbiAgICAgICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgICAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gICAgfVxuICAgIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICovXG4vLyB0b2RvOiB2YWxvcmtpbiBmaXhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKi9cbi8vIHRvZG86IHZhbG9ya2luIGZpeFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICAgIH1cbiAgICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICAgICAgY2FzZSAnSFRNTCc6XG4gICAgICAgIGNhc2UgJ0JPRFknOlxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gICAgY29uc3QgeyBvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1kgfSA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChTdHJpbmcob3ZlcmZsb3cpICsgU3RyaW5nKG92ZXJmbG93WSkgKyBTdHJpbmcob3ZlcmZsb3dYKSkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50LCBmaXhlZFBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgICBjb25zdCBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgICBjb25zdCBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuICAgIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICAgIGNvbnN0IGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICAgIGNvbnN0IGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gICAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AgPz8gMCwgMCk7XG4gICAgICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCA/PyAwLCAwKTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgICAgICB0b3A6IChjaGlsZHJlblJlY3QudG9wID8/IDApIC0gKHBhcmVudFJlY3QudG9wID8/IDApIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgICAgIGxlZnQ6IChjaGlsZHJlblJlY3QubGVmdCA/PyAwKSAtIChwYXJlbnRSZWN0LmxlZnQgPz8gMCkgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICAgIH0pO1xuICAgIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuICAgIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAgIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAgIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gICAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICAgIGlmIChpc0hUTUwpIHtcbiAgICAgICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICAgICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuICAgICAgICBpZiAoaXNOdW1iZXIob2Zmc2V0cy50b3ApKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIob2Zmc2V0cy5ib3R0b20pKSB7XG4gICAgICAgICAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIob2Zmc2V0cy5sZWZ0KSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKG9mZnNldHMucmlnaHQpKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgICAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQsIHNpZGUgPSAndG9wJykge1xuICAgIGNvbnN0IHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgY29uc3QgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgICAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCwgZXhjbHVkZVNjcm9sbCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgICBjb25zdCBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG4gICAgY29uc3Qgb2Zmc2V0ID0ge1xuICAgICAgICB0b3A6IHNjcm9sbFRvcCAtIE51bWJlcihyZWxhdGl2ZU9mZnNldD8udG9wKSArIE51bWJlcihyZWxhdGl2ZU9mZnNldD8ubWFyZ2luVG9wKSxcbiAgICAgICAgbGVmdDogc2Nyb2xsTGVmdCAtIE51bWJlcihyZWxhdGl2ZU9mZnNldD8ubGVmdCkgKyBOdW1iZXIocmVsYXRpdmVPZmZzZXQ/Lm1hcmdpbkxlZnQpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgfTtcbiAgICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0ZpeGVkKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHRhcmdldCwgaG9zdCwgcGFkZGluZyA9IDAsIGJvdW5kYXJpZXNFbGVtZW50LCBmaXhlZFBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgIGxldCBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICBjb25zdCBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCh0YXJnZXQpIDogZmluZENvbW1vbk9mZnNldFBhcmVudCh0YXJnZXQsIGhvc3QpO1xuICAgIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICAgICAgbGV0IGJvdW5kYXJpZXNOb2RlO1xuICAgICAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICAgICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGhvc3QpKTtcbiAgICAgICAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcmllc05vZGUgPSB0YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHRhcmdldC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgICAgIGlmIChvZmZzZXRzICYmIGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBnZXRXaW5kb3dTaXplcyh0YXJnZXQub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoYm91bmRhcmllcy50b3ApICYmIGlzTnVtYmVyKG9mZnNldHMudG9wKSAmJiBpc051bWJlcihvZmZzZXRzLm1hcmdpblRvcCkpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGJvdW5kYXJpZXMudG9wKSkge1xuICAgICAgICAgICAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gTnVtYmVyKGhlaWdodCkgKyBOdW1iZXIob2Zmc2V0cy50b3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGJvdW5kYXJpZXMubGVmdCkgJiYgaXNOdW1iZXIob2Zmc2V0cy5sZWZ0KSAmJiBpc051bWJlcihvZmZzZXRzLm1hcmdpbkxlZnQpKSB7XG4gICAgICAgICAgICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc051bWJlcihib3VuZGFyaWVzLnRvcCkpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gTnVtYmVyKHdpZHRoKSArIE51bWJlcihvZmZzZXRzLmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIHBhZGRpbmdzXG4gICAgaWYgKGlzTnVtYmVyKGJvdW5kYXJpZXMubGVmdCkpIHtcbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IHBhZGRpbmc7XG4gICAgfVxuICAgIGlmIChpc051bWJlcihib3VuZGFyaWVzLnRvcCkpIHtcbiAgICAgICAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGJvdW5kYXJpZXMucmlnaHQpKSB7XG4gICAgICAgIGJvdW5kYXJpZXMucmlnaHQgLT0gcGFkZGluZztcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGJvdW5kYXJpZXMuYm90dG9tKSkge1xuICAgICAgICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKi9cbmZ1bmN0aW9uIGdldEFyZWEoeyB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHRhcmdldCwgaG9zdCwgYWxsb3dlZFBvc2l0aW9ucyA9IFsndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdsZWZ0J10sIGJvdW5kYXJpZXNFbGVtZW50ID0gJ3ZpZXdwb3J0JywgcGFkZGluZyA9IDApIHtcbiAgICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICB9XG4gICAgY29uc3QgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXModGFyZ2V0LCBob3N0LCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG4gICAgY29uc3QgcmVjdHMgPSB7XG4gICAgICAgIHRvcDoge1xuICAgICAgICAgICAgd2lkdGg6IGJvdW5kYXJpZXM/LndpZHRoID8/IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IChyZWZSZWN0Py50b3AgPz8gMCkgLSAoYm91bmRhcmllcz8udG9wID8/IDApXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgICB3aWR0aDogKGJvdW5kYXJpZXM/LnJpZ2h0ID8/IDApIC0gKHJlZlJlY3Q/LnJpZ2h0ID8/IDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzPy5oZWlnaHQgPz8gMFxuICAgICAgICB9LFxuICAgICAgICBib3R0b206IHtcbiAgICAgICAgICAgIHdpZHRoOiBib3VuZGFyaWVzPy53aWR0aCA/PyAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAoYm91bmRhcmllcz8uYm90dG9tID8/IDApIC0gKHJlZlJlY3Q/LmJvdHRvbSA/PyAwKVxuICAgICAgICB9LFxuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgICB3aWR0aDogKHJlZlJlY3QubGVmdCA/PyAwKSAtIChib3VuZGFyaWVzPy5sZWZ0ID8/IDApLFxuICAgICAgICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzPy5oZWlnaHQgPz8gMFxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKVxuICAgICAgICAubWFwKChrZXkpID0+ICh7XG4gICAgICAgIHBvc2l0aW9uOiBrZXksXG4gICAgICAgIC4uLnJlY3RzW2tleV0sXG4gICAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuYXJlYSAtIGEuYXJlYSk7XG4gICAgbGV0IGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgIHJldHVybiB3aWR0aCA+PSB0YXJnZXQuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHRhcmdldC5jbGllbnRIZWlnaHQ7XG4gICAgfSk7XG4gICAgZmlsdGVyZWRBcmVhcyA9IGZpbHRlcmVkQXJlYXMuZmlsdGVyKCh7IHBvc2l0aW9uIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIGFsbG93ZWRQb3NpdGlvbnMuc29tZSgoYWxsb3dlZFBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWxsb3dlZFBvc2l0aW9uID09PSBwb3NpdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLnBvc2l0aW9uIDogc29ydGVkQXJlYXNbMF0ucG9zaXRpb247XG4gICAgY29uc3QgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCcgJylbMV07XG4gICAgLy8gZm9yIHRvb2x0aXAgb24gYXV0byBwb3NpdGlvblxuICAgIHRhcmdldC5jbGFzc05hbWUgPSB0YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2UoL2JzLXRvb2x0aXAtYXV0by9nLCBgYnMtdG9vbHRpcC0ke2dldEJzVmVyKCkuaXNCczUgPyBQbGFjZW1lbnRGb3JCczVbY29tcHV0ZWRQbGFjZW1lbnRdIDogY29tcHV0ZWRQbGFjZW1lbnR9YCk7XG4gICAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/IGAtJHt2YXJpYXRpb259YCA6ICcnKTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGRhdGEub2Zmc2V0cy50YXJnZXQud2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YS5vZmZzZXRzLnRhcmdldC5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnRhcmdldC5sZWZ0ID8/IDApLFxuICAgICAgICB0b3A6IE1hdGgucm91bmQoZGF0YS5vZmZzZXRzLnRhcmdldC50b3AgPz8gMCksXG4gICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChkYXRhLm9mZnNldHMudGFyZ2V0LmJvdHRvbSA/PyAwKSxcbiAgICAgICAgcmlnaHQ6IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnRhcmdldC5yaWdodCA/PyAwKVxuICAgIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICBjb25zdCBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gICAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgbWF0Y2hlZCA9PiBoYXNoW21hdGNoZWRdKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgICBpZiAodmFyaWF0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG5jb25zdCBwYXJzZSA9ICh2YWx1ZSwgZGVmID0gMCkgPT4gdmFsdWUgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IGRlZjtcbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3c/LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgeCA9IHBhcnNlKHN0eWxlcz8ubWFyZ2luVG9wKSArIHBhcnNlKHN0eWxlcz8ubWFyZ2luQm90dG9tKTtcbiAgICBjb25zdCB5ID0gcGFyc2Uoc3R5bGVzPy5tYXJnaW5MZWZ0KSArIHBhcnNlKHN0eWxlcz8ubWFyZ2luUmlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBOdW1iZXIoZWxlbWVudC5vZmZzZXRXaWR0aCkgKyB5LFxuICAgICAgICBoZWlnaHQ6IE51bWJlcihlbGVtZW50Lm9mZnNldEhlaWdodCkgKyB4XG4gICAgfTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0YXJnZXQsIGhvc3QsIGZpeGVkUG9zaXRpb24pIHtcbiAgICBjb25zdCBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uXG4gICAgICAgID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCh0YXJnZXQpXG4gICAgICAgIDogZmluZENvbW1vbk9mZnNldFBhcmVudCh0YXJnZXQsIGhvc3QpO1xuICAgIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoaG9zdCwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldFRhcmdldE9mZnNldHModGFyZ2V0LCBob3N0T2Zmc2V0cywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSBwb3NpdGlvbi5zcGxpdCgnICcpWzBdO1xuICAgIC8vIEdldCB0YXJnZXQgbm9kZSBzaXplc1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSBnZXRPdXRlclNpemVzKHRhcmdldCk7XG4gICAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICAgIGNvbnN0IHRhcmdldE9mZnNldHMgPSB7XG4gICAgICAgIHdpZHRoOiB0YXJnZXRSZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRhcmdldFJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgICAvLyBkZXBlbmRpbmcgYnkgdGhlIHRhcmdldCBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgY29uc3QgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgY29uc3QgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3Qgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgICBjb25zdCBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgY29uc3Qgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB0YXJnZXRPZmZzZXRzW21haW5TaWRlXSA9XG4gICAgICAgIChob3N0T2Zmc2V0c1ttYWluU2lkZV0gPz8gMCkgK1xuICAgICAgICAgICAgaG9zdE9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtXG4gICAgICAgICAgICB0YXJnZXRSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gICAgdGFyZ2V0T2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZVxuICAgICAgICA/IChob3N0T2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA/PyAwKSAtIHRhcmdldFJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdXG4gICAgICAgIDogaG9zdE9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldID8/IDA7XG4gICAgcmV0dXJuIHRhcmdldE9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG9wdGlvbnMsIG1vZGlmaWVyTmFtZSkge1xuICAgIHJldHVybiAhIW9wdGlvbnMubW9kaWZpZXJzW21vZGlmaWVyTmFtZV0/LmVuYWJsZWQ7XG59XG5cbmNvbnN0IGF2YWlsYWJsZVBvc2l0aW9ucyA9IHtcbiAgICB0b3A6IFsndG9wJywgJ3RvcCBzdGFydCcsICd0b3AgZW5kJ10sXG4gICAgYm90dG9tOiBbJ2JvdHRvbScsICdib3R0b20gc3RhcnQnLCAnYm90dG9tIGVuZCddLFxuICAgIHN0YXJ0OiBbJ3N0YXJ0JywgJ3N0YXJ0IHRvcCcsICdzdGFydCBib3R0b20nXSxcbiAgICBlbmQ6IFsnZW5kJywgJ2VuZCB0b3AnLCAnZW5kIGJvdHRvbSddXG59O1xuZnVuY3Rpb24gY2hlY2tQb3BvdmVyTWFyZ2luKHBsYWNlbWVudCwgY2hlY2tQb3NpdGlvbikge1xuICAgIGlmICghZ2V0QnNWZXIoKS5pc0JzNSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhdmFpbGFibGVQb3NpdGlvbnNbY2hlY2tQb3NpdGlvbl0uaW5jbHVkZXMocGxhY2VtZW50KTtcbn1cbmZ1bmN0aW9uIGNoZWNrTWFyZ2lucyhwbGFjZW1lbnQpIHtcbiAgICBpZiAoIWdldEJzVmVyKCkuaXNCczUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoY2hlY2tQb3BvdmVyTWFyZ2luKHBsYWNlbWVudCwgJ2VuZCcpKSB7XG4gICAgICAgIHJldHVybiAnbXMtMic7XG4gICAgfVxuICAgIGlmIChjaGVja1BvcG92ZXJNYXJnaW4ocGxhY2VtZW50LCAnc3RhcnQnKSkge1xuICAgICAgICByZXR1cm4gJ21lLTInO1xuICAgIH1cbiAgICBpZiAoY2hlY2tQb3BvdmVyTWFyZ2luKHBsYWNlbWVudCwgJ3RvcCcpKSB7XG4gICAgICAgIHJldHVybiAnbWItMic7XG4gICAgfVxuICAgIGlmIChjaGVja1BvcG92ZXJNYXJnaW4ocGxhY2VtZW50LCAnYm90dG9tJykpIHtcbiAgICAgICAgcmV0dXJuICdtdC0yJztcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXJDbGFzcyhkYXRhLCByZW5kZXJlcikge1xuICAgIGNvbnN0IHRhcmdldCA9IGRhdGEuaW5zdGFuY2UudGFyZ2V0O1xuICAgIGxldCBjb250YWluZXJDbGFzcyA9IHRhcmdldC5jbGFzc05hbWU7XG4gICAgY29uc3QgZGF0YVBsYWNlbWVudCA9IGdldEJzVmVyKCkuaXNCczUgPyBQbGFjZW1lbnRGb3JCczVbZGF0YS5wbGFjZW1lbnRdIDogZGF0YS5wbGFjZW1lbnQ7XG4gICAgaWYgKGRhdGEucGxhY2VtZW50QXV0bykge1xuICAgICAgICBjb250YWluZXJDbGFzcyA9IGNvbnRhaW5lckNsYXNzLnJlcGxhY2UoL2JzLXBvcG92ZXItYXV0by9nLCBgYnMtcG9wb3Zlci0ke2RhdGFQbGFjZW1lbnR9YCk7XG4gICAgICAgIGNvbnRhaW5lckNsYXNzID0gY29udGFpbmVyQ2xhc3MucmVwbGFjZSgvbXMtMnxtZS0yfG1iLTJ8bXQtMi9nLCAnJyk7XG4gICAgICAgIGNvbnRhaW5lckNsYXNzID0gY29udGFpbmVyQ2xhc3MucmVwbGFjZSgvYnMtdG9vbHRpcC1hdXRvL2csIGBicy10b29sdGlwLSR7ZGF0YVBsYWNlbWVudH1gKTtcbiAgICAgICAgY29udGFpbmVyQ2xhc3MgPSBjb250YWluZXJDbGFzcy5yZXBsYWNlKC9cXHNhdXRvL2csIGAgJHtkYXRhUGxhY2VtZW50fWApO1xuICAgICAgICBpZiAoY29udGFpbmVyQ2xhc3MuaW5kZXhPZigncG9wb3ZlcicpICE9PSAtMSkge1xuICAgICAgICAgICAgY29udGFpbmVyQ2xhc3MgPSBjb250YWluZXJDbGFzcyArICcgJyArIGNoZWNrTWFyZ2lucyhkYXRhUGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyQ2xhc3MuaW5kZXhPZigncG9wb3ZlcicpICE9PSAtMSAmJiBjb250YWluZXJDbGFzcy5pbmRleE9mKCdwb3BvdmVyLWF1dG8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzICs9ICcgcG9wb3Zlci1hdXRvJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbmVyQ2xhc3MuaW5kZXhPZigndG9vbHRpcCcpICE9PSAtMSAmJiBjb250YWluZXJDbGFzcy5pbmRleE9mKCd0b29sdGlwLWF1dG8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckNsYXNzICs9ICcgdG9vbHRpcC1hdXRvJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWluZXJDbGFzcyA9IGNvbnRhaW5lckNsYXNzLnJlcGxhY2UoL2xlZnR8cmlnaHR8dG9wfGJvdHRvbXxlbmR8c3RhcnQvZywgYCR7ZGF0YVBsYWNlbWVudC5zcGxpdCgnICcpWzBdfWApO1xuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlci5zZXRBdHRyaWJ1dGUodGFyZ2V0LCAnY2xhc3MnLCBjb250YWluZXJDbGFzcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGFyZ2V0LmNsYXNzTmFtZSA9IGNvbnRhaW5lckNsYXNzO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzLCByZW5kZXJlcikge1xuICAgIGlmICghZWxlbWVudCB8fCAhc3R5bGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGxldCB1bml0ID0gJyc7XG4gICAgICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiZcbiAgICAgICAgICAgIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICAgICAgICB1bml0ID0gJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFN0eWxlKGVsZW1lbnQsIHByb3AsIGAke1N0cmluZyhzdHlsZXNbcHJvcF0pfSR7dW5pdH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gU3RyaW5nKHN0eWxlc1twcm9wXSkgKyB1bml0O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhcnJvdyhkYXRhKSB7XG4gICAgbGV0IHRhcmdldE9mZnNldHMgPSBkYXRhLm9mZnNldHMudGFyZ2V0O1xuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gICAgY29uc3QgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS50YXJnZXQucXVlcnlTZWxlY3RvcignLmFycm93Jyk7XG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudC5zcGxpdCgnICcpWzBdKSAhPT0gLTE7XG4gICAgY29uc3QgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICBjb25zdCBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gICAgY29uc3Qgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgY29uc3Qgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgICBjb25zdCBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG4gICAgY29uc3QgcGxhY2VtZW50VmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJyAnKVsxXTtcbiAgICAvLyB0b3AvbGVmdCBzaWRlXG4gICAgaWYgKChkYXRhLm9mZnNldHMuaG9zdFtvcFNpZGVdID8/IDApIC0gYXJyb3dFbGVtZW50U2l6ZSA8ICh0YXJnZXRPZmZzZXRzW3NpZGVdID8/IDApKSB7XG4gICAgICAgICh0YXJnZXRPZmZzZXRzKVtzaWRlXSAtPVxuICAgICAgICAgICAgKHRhcmdldE9mZnNldHNbc2lkZV0gPz8gMCkgLSAoKGRhdGEub2Zmc2V0cy5ob3N0W29wU2lkZV0gPz8gMCkgLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgICB9XG4gICAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgICBpZiAoTnVtYmVyKChkYXRhKS5vZmZzZXRzLmhvc3Rbc2lkZV0pICsgTnVtYmVyKGFycm93RWxlbWVudFNpemUpID4gKHRhcmdldE9mZnNldHNbb3BTaWRlXSA/PyAwKSkge1xuICAgICAgICAodGFyZ2V0T2Zmc2V0cylbc2lkZV0gKz1cbiAgICAgICAgICAgIE51bWJlcigoZGF0YSkub2Zmc2V0cy5ob3N0W3NpZGVdKSArIE51bWJlcihhcnJvd0VsZW1lbnRTaXplKSAtIE51bWJlcigodGFyZ2V0T2Zmc2V0cylbb3BTaWRlXSk7XG4gICAgfVxuICAgIHRhcmdldE9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHRhcmdldE9mZnNldHMpO1xuICAgIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCB0YXJnZXQgb2Zmc2V0c1xuICAgIC8vIHRha2UgdGFyZ2V0IG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gICAgY29uc3QgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UudGFyZ2V0KTtcbiAgICBjb25zdCB0YXJnZXRNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbYG1hcmdpbiR7c2lkZUNhcGl0YWxpemVkfWBdKSB8fCAwO1xuICAgIGNvbnN0IHRhcmdldEJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1tgYm9yZGVyJHtzaWRlQ2FwaXRhbGl6ZWR9V2lkdGhgXSkgfHwgMDtcbiAgICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgdGFyZ2V0XG4gICAgbGV0IGNlbnRlcjtcbiAgICBpZiAoIXBsYWNlbWVudFZhcmlhdGlvbikge1xuICAgICAgICBjZW50ZXIgPSBOdW1iZXIoKGRhdGEpLm9mZnNldHMuaG9zdFtzaWRlXSkgKyBOdW1iZXIoZGF0YS5vZmZzZXRzLmhvc3RbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXRCb3JkZXJSYWRpdXMgPSBwYXJzZUZsb2F0KGNzc1tcImJvcmRlclJhZGl1c1wiXSkgfHwgMDtcbiAgICAgICAgY29uc3QgdGFyZ2V0U2lkZUFycm93T2Zmc2V0ID0gTnVtYmVyKHRhcmdldE1hcmdpblNpZGUgKyB0YXJnZXRCb3JkZXJTaWRlICsgdGFyZ2V0Qm9yZGVyUmFkaXVzKTtcbiAgICAgICAgY2VudGVyID0gc2lkZSA9PT0gcGxhY2VtZW50VmFyaWF0aW9uID9cbiAgICAgICAgICAgIE51bWJlcigoZGF0YSkub2Zmc2V0cy5ob3N0W3NpZGVdKSArIHRhcmdldFNpZGVBcnJvd09mZnNldCA6XG4gICAgICAgICAgICBOdW1iZXIoKGRhdGEpLm9mZnNldHMuaG9zdFtzaWRlXSkgKyBOdW1iZXIoZGF0YS5vZmZzZXRzLmhvc3RbbGVuXSAtIHRhcmdldFNpZGVBcnJvd09mZnNldCk7XG4gICAgfVxuICAgIGxldCBzaWRlVmFsdWUgPSBjZW50ZXIgLSAodGFyZ2V0T2Zmc2V0c1tzaWRlXSA/PyAwKSAtIHRhcmdldE1hcmdpblNpZGUgLSB0YXJnZXRCb3JkZXJTaWRlO1xuICAgIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHRhcmdldFxuICAgIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHRhcmdldE9mZnNldHNbbGVuXSAtIChhcnJvd0VsZW1lbnRTaXplICsgNSksIHNpZGVWYWx1ZSksIDApO1xuICAgIGRhdGEub2Zmc2V0cy5hcnJvdyA9IHtcbiAgICAgICAgW3NpZGVdOiBNYXRoLnJvdW5kKHNpZGVWYWx1ZSksXG4gICAgICAgIFthbHRTaWRlXTogJycgLy8gbWFrZSBzdXJlIHRvIHVuc2V0IGFueSBldmVudHVhbCBhbHRTaWRlIHZhbHVlIGZyb20gdGhlIERPTSBub2RlXG4gICAgfTtcbiAgICBkYXRhLmluc3RhbmNlLmFycm93ID0gYXJyb3dFbGVtZW50O1xuICAgIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBmbGlwKGRhdGEpIHtcbiAgICBkYXRhLm9mZnNldHMudGFyZ2V0ID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMudGFyZ2V0KTtcbiAgICBpZiAoIWlzTW9kaWZpZXJFbmFibGVkKGRhdGEub3B0aW9ucywgJ2ZsaXAnKSkge1xuICAgICAgICBkYXRhLm9mZnNldHMudGFyZ2V0ID0ge1xuICAgICAgICAgICAgLi4uZGF0YS5vZmZzZXRzLnRhcmdldCxcbiAgICAgICAgICAgIC4uLmdldFRhcmdldE9mZnNldHMoZGF0YS5pbnN0YW5jZS50YXJnZXQsIGRhdGEub2Zmc2V0cy5ob3N0LCBkYXRhLnBsYWNlbWVudClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UudGFyZ2V0LCBkYXRhLmluc3RhbmNlLmhvc3QsIDAsIC8vIHBhZGRpbmdcbiAgICAndmlld3BvcnQnLCBmYWxzZSAvLyBwb3NpdGlvbkZpeGVkXG4gICAgKTtcbiAgICBsZXQgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJyAnKVswXTtcbiAgICBsZXQgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJyAnKVsxXSB8fCAnJztcbiAgICBjb25zdCBvZmZzZXRzSG9zdCA9IGRhdGEub2Zmc2V0cy5ob3N0O1xuICAgIGNvbnN0IHRhcmdldCA9IGRhdGEuaW5zdGFuY2UudGFyZ2V0O1xuICAgIGNvbnN0IGhvc3QgPSBkYXRhLmluc3RhbmNlLmhvc3Q7XG4gICAgY29uc3QgYWRhcHRpdmVQb3NpdGlvbiA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KCdhdXRvJywgb2Zmc2V0c0hvc3QsIHRhcmdldCwgaG9zdCwgZGF0YS5vcHRpb25zLmFsbG93ZWRQb3NpdGlvbnMpO1xuICAgIGNvbnN0IGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIGFkYXB0aXZlUG9zaXRpb25dO1xuICAgIGZsaXBPcmRlci5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCcgJylbMF07XG4gICAgICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIGhvc3Qgb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICAgICAgY29uc3Qgb3ZlcmxhcHNSZWYgPSAocGxhY2VtZW50ID09PSAnbGVmdCcgJiZcbiAgICAgICAgICAgIE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnRhcmdldC5yaWdodCA/PyAwKSA+IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLmhvc3QubGVmdCA/PyAwKSkgfHxcbiAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdyaWdodCcgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmZsb29yKGRhdGEub2Zmc2V0cy50YXJnZXQubGVmdCA/PyAwKSA8IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLmhvc3QucmlnaHQgPz8gMCkpIHx8XG4gICAgICAgICAgICAocGxhY2VtZW50ID09PSAndG9wJyAmJlxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnRhcmdldC5ib3R0b20gPz8gMCkgPiBNYXRoLmZsb29yKGRhdGEub2Zmc2V0cy5ob3N0LnRvcCA/PyAwKSkgfHxcbiAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdib3R0b20nICYmXG4gICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkYXRhLm9mZnNldHMudGFyZ2V0LnRvcCA/PyAwKSA8IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLmhvc3QuYm90dG9tID8/IDApKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dzTGVmdCA9IE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnRhcmdldC5sZWZ0ID8/IDApIDwgTWF0aC5mbG9vcihib3VuZGFyaWVzLmxlZnQgPz8gMCk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93c1JpZ2h0ID0gTWF0aC5mbG9vcihkYXRhLm9mZnNldHMudGFyZ2V0LnJpZ2h0ID8/IDApID4gTWF0aC5mbG9vcihib3VuZGFyaWVzLnJpZ2h0ID8/IDApO1xuICAgICAgICBjb25zdCBvdmVyZmxvd3NUb3AgPSBNYXRoLmZsb29yKGRhdGEub2Zmc2V0cy50YXJnZXQudG9wID8/IDApIDwgTWF0aC5mbG9vcihib3VuZGFyaWVzLnRvcCA/PyAwKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dzQm90dG9tID0gTWF0aC5mbG9vcihkYXRhLm9mZnNldHMudGFyZ2V0LmJvdHRvbSA/PyAwKSA+IE1hdGguZmxvb3IoYm91bmRhcmllcy5ib3R0b20gPz8gMCk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93c0JvdW5kYXJpZXMgPSAocGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCkgfHxcbiAgICAgICAgICAgIChwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQpIHx8XG4gICAgICAgICAgICAocGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3ApIHx8XG4gICAgICAgICAgICAocGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuICAgICAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgICAgIGNvbnN0IGZsaXBwZWRWYXJpYXRpb24gPSAoKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCkgfHxcbiAgICAgICAgICAgIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCkgfHxcbiAgICAgICAgICAgICghaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NUb3ApIHx8XG4gICAgICAgICAgICAoIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAncmlnaHQnICYmIG92ZXJmbG93c0JvdHRvbSkpO1xuICAgICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gYCAke3ZhcmlhdGlvbn1gIDogJycpO1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLm9mZnNldHMudGFyZ2V0LFxuICAgICAgICAgICAgICAgIC4uLmdldFRhcmdldE9mZnNldHMoZGF0YS5pbnN0YW5jZS50YXJnZXQsIGRhdGEub2Zmc2V0cy5ob3N0LCBkYXRhLnBsYWNlbWVudClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEodGFyZ2V0RWxlbWVudCwgaG9zdEVsZW1lbnQsIHBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0YXJnZXRFbGVtZW50IHx8ICFob3N0RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvc3RFbFBvc2l0aW9uID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0YXJnZXRFbGVtZW50LCBob3N0RWxlbWVudCk7XG4gICAgaWYgKCFwb3NpdGlvbi5tYXRjaCgvXihhdXRvKSpcXHMqKGxlZnR8cmlnaHR8dG9wfGJvdHRvbXxzdGFydHxlbmQpKiQvKVxuICAgICAgICAmJiAhcG9zaXRpb24ubWF0Y2goL14obGVmdHxyaWdodHx0b3B8Ym90dG9tfHN0YXJ0fGVuZCkqKD86IChsZWZ0fHJpZ2h0fHRvcHxib3R0b218c3RhcnR8ZW5kKSkqJC8pKSB7XG4gICAgICAgIHBvc2l0aW9uID0gJ2F1dG8nO1xuICAgIH1cbiAgICBjb25zdCBwbGFjZW1lbnRBdXRvID0gISFwb3NpdGlvbi5tYXRjaCgvYXV0by9nKTtcbiAgICAvLyBzdXBwb3J0IG9sZCBwbGFjZW1lbnRzICdhdXRvIGxlZnR8cmlnaHR8dG9wfGJvdHRvbSdcbiAgICBsZXQgcGxhY2VtZW50ID0gcG9zaXRpb24ubWF0Y2goL2F1dG9cXHMobGVmdHxyaWdodHx0b3B8Ym90dG9tfHN0YXJ0fGVuZCkvKVxuICAgICAgICA/IHBvc2l0aW9uLnNwbGl0KCcgJylbMV0gfHwgJ2F1dG8nXG4gICAgICAgIDogcG9zaXRpb247XG4gICAgLy8gTm9ybWFsaXplIHBsYWNlbWVudHMgdGhhdCBoYXZlIGlkZW50aWNhbCBtYWluIHBsYWNlbWVudCBhbmQgdmFyaWF0aW9uIChcInJpZ2h0IHJpZ2h0XCIgPT4gXCJyaWdodFwiKS5cbiAgICBjb25zdCBtYXRjaGVzID0gcGxhY2VtZW50Lm1hdGNoKC9eKGxlZnR8cmlnaHR8dG9wfGJvdHRvbXxzdGFydHxlbmQpKiA/KD8hXFwxKShsZWZ0fHJpZ2h0fHRvcHxib3R0b218c3RhcnR8ZW5kKT8vKTtcbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBtYXRjaGVzWzFdICsgKG1hdGNoZXNbMl0gPyBgICR7bWF0Y2hlc1syXX1gIDogJycpO1xuICAgIH1cbiAgICAvLyBcImxlZnQgcmlnaHRcIiwgXCJ0b3AgYm90dG9tXCIgZXRjLiBwbGFjZW1lbnRzIGFsc28gY29uc2lkZXJlZCBpbmNvcnJlY3QuXG4gICAgaWYgKFsnbGVmdCByaWdodCcsICdyaWdodCBsZWZ0JywgJ3RvcCBib3R0b20nLCAnYm90dG9tIHRvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gJ2F1dG8nO1xuICAgIH1cbiAgICBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIGhvc3RFbFBvc2l0aW9uLCB0YXJnZXRFbGVtZW50LCBob3N0RWxlbWVudCwgb3B0aW9ucyA/IG9wdGlvbnMuYWxsb3dlZFBvc2l0aW9ucyA6IHVuZGVmaW5lZCk7XG4gICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gZ2V0VGFyZ2V0T2Zmc2V0cyh0YXJnZXRFbGVtZW50LCBob3N0RWxQb3NpdGlvbiwgcGxhY2VtZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHsgbW9kaWZpZXJzOiB7fSB9LFxuICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRFbGVtZW50LFxuICAgICAgICAgICAgaG9zdDogaG9zdEVsZW1lbnQsXG4gICAgICAgICAgICBhcnJvdzogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldHM6IHtcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0T2Zmc2V0LFxuICAgICAgICAgICAgaG9zdDogaG9zdEVsUG9zaXRpb24sXG4gICAgICAgICAgICBhcnJvdzogdm9pZCAwXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYWNlbWVudEF1dG9cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSkge1xuICAgIGlmICghaXNNb2RpZmllckVuYWJsZWQoZGF0YS5vcHRpb25zLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAgIC8vIHJlc2V0cyB0aGUgdGFyZ2V0IE9mZnNldHMncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAgIC8vIHRoZSBzaXplIG9mIHRoZSB0YXJnZXRPZmZzZXRzIGVsZW1lbnQgaXRzZWxmXG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcCA9ICd0cmFuc2Zvcm0nO1xuICAgIGNvbnN0IHRhcmdldFN0eWxlcyA9IGRhdGEuaW5zdGFuY2UudGFyZ2V0LnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIFt0cmFuc2Zvcm1Qcm9wXTogdHJhbnNmb3JtIH0gPSB0YXJnZXRTdHlsZXM7XG4gICAgdGFyZ2V0U3R5bGVzLnRvcCA9ICcnO1xuICAgIHRhcmdldFN0eWxlcy5sZWZ0ID0gJyc7XG4gICAgdGFyZ2V0U3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG4gICAgY29uc3QgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS50YXJnZXQsIGRhdGEuaW5zdGFuY2UuaG9zdCwgMCwgLy8gcGFkZGluZ1xuICAgIGRhdGEub3B0aW9ucy5tb2RpZmllcnMucHJldmVudE92ZXJmbG93Py5ib3VuZGFyaWVzRWxlbWVudCB8fCAnc2Nyb2xsUGFyZW50JywgZmFsc2UgLy8gcG9zaXRpb25GaXhlZFxuICAgICk7XG4gICAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gICAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gICAgdGFyZ2V0U3R5bGVzLnRvcCA9IHRvcDtcbiAgICB0YXJnZXRTdHlsZXMubGVmdCA9IGxlZnQ7XG4gICAgdGFyZ2V0U3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuICAgIGNvbnN0IG9yZGVyID0gWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXTtcbiAgICBjb25zdCBjaGVjayA9IHtcbiAgICAgICAgcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGEub2Zmc2V0cy50YXJnZXRbcGxhY2VtZW50XTtcbiAgICAgICAgICAgIC8vIG9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZVxuICAgICAgICAgICAgaWYgKChkYXRhLm9mZnNldHMudGFyZ2V0W3BsYWNlbWVudF0gPz8gMCkgPCAoYm91bmRhcmllc1twbGFjZW1lbnRdID8/IDApKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChkYXRhLm9mZnNldHMudGFyZ2V0W3BsYWNlbWVudF0gPz8gMCwgYm91bmRhcmllc1twbGFjZW1lbnRdID8/IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgW3BsYWNlbWVudF06IHZhbHVlIH07XG4gICAgICAgIH0sXG4gICAgICAgIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUGxhY2VtZW50SG9yaXpvbnRhbCA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JztcbiAgICAgICAgICAgIGNvbnN0IG1haW5TaWRlID0gaXNQbGFjZW1lbnRIb3Jpem9udGFsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IGlzUGxhY2VtZW50SG9yaXpvbnRhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRhdGEub2Zmc2V0cy50YXJnZXRbbWFpblNpZGVdO1xuICAgICAgICAgICAgLy8gZXNjYXBlV2l0aFJlZmVyZW5jZVxuICAgICAgICAgICAgaWYgKChkYXRhLm9mZnNldHMudGFyZ2V0W3BsYWNlbWVudF0gPz8gMCkgPiAoYm91bmRhcmllc1twbGFjZW1lbnRdID8/IDApKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihkYXRhLm9mZnNldHMudGFyZ2V0W21haW5TaWRlXSA/PyAwLCAoYm91bmRhcmllc1twbGFjZW1lbnRdID8/IDApIC0gZGF0YS5vZmZzZXRzLnRhcmdldFttZWFzdXJlbWVudF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgW21haW5TaWRlXTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgb3JkZXIuZm9yRWFjaCgocGxhY2VtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZGUgPSBbJ2xlZnQnLCAndG9wJywgJ3N0YXJ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/IGNoZWNrWydwcmltYXJ5J10gOiBjaGVja1snc2Vjb25kYXJ5J107XG4gICAgICAgIGRhdGEub2Zmc2V0cy50YXJnZXQgPSB7XG4gICAgICAgICAgICAuLi5kYXRhLm9mZnNldHMudGFyZ2V0LFxuICAgICAgICAgICAgLi4uc2lkZShwbGFjZW1lbnQpXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgICBjb25zdCBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgICBjb25zdCBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCcgJylbMF07XG4gICAgY29uc3Qgc2hpZnRWYXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJyAnKVsxXTtcbiAgICBpZiAoc2hpZnRWYXJpYXRpb24pIHtcbiAgICAgICAgY29uc3QgeyBob3N0LCB0YXJnZXQgfSA9IGRhdGEub2Zmc2V0cztcbiAgICAgICAgY29uc3QgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgICAgICBjb25zdCBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiB7IFtzaWRlXTogaG9zdFtzaWRlXSB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgW3NpZGVdOiAoaG9zdFtzaWRlXSA/PyAwKSArIGhvc3RbbWVhc3VyZW1lbnRdIC0gdGFyZ2V0W21lYXN1cmVtZW50XVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkYXRhLm9mZnNldHMudGFyZ2V0ID0ge1xuICAgICAgICAgICAgLi4udGFyZ2V0LCAuLi57XG4gICAgICAgICAgICAgICAgW3NpZGVdOiAoc2lkZSA9PT0gc2hpZnRWYXJpYXRpb24gPyBzaGlmdE9mZnNldHMuc3RhcnRbc2lkZV0gOiBzaGlmdE9mZnNldHMuZW5kW3NpZGVdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cblxuY2xhc3MgUG9zaXRpb25pbmcge1xuICAgIHBvc2l0aW9uKGhvc3RFbGVtZW50LCB0YXJnZXRFbGVtZW50IC8qLCByb3VuZCA9IHRydWUqLykge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQoaG9zdEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgLyosIGZhbHNlKi8pO1xuICAgIH1cbiAgICBvZmZzZXQoaG9zdEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgLyosIHJvdW5kID0gdHJ1ZSovKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWZlcmVuY2VPZmZzZXRzKHRhcmdldEVsZW1lbnQsIGhvc3RFbGVtZW50KTtcbiAgICB9XG4gICAgcG9zaXRpb25FbGVtZW50cyhob3N0RWxlbWVudCwgdGFyZ2V0RWxlbWVudCwgcG9zaXRpb24sIGFwcGVuZFRvQm9keSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGFpbk9mTW9kaWZpZXJzID0gW2ZsaXAsIHNoaWZ0LCBwcmV2ZW50T3ZlcmZsb3csIGFycm93XTtcbiAgICAgICAgY29uc3QgX3Bvc2l0aW9uID0gTWFwUGxhY2VtZW50SW5Ub1JMW3Bvc2l0aW9uXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGluaXREYXRhKHRhcmdldEVsZW1lbnQsIGhvc3RFbGVtZW50LCBfcG9zaXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhaW5PZk1vZGlmaWVycy5yZWR1Y2UoKG1vZGlmaWVkRGF0YSwgbW9kaWZpZXIpID0+IG1vZGlmaWVyKG1vZGlmaWVkRGF0YSksIGRhdGEpO1xuICAgIH1cbn1cbmNvbnN0IHBvc2l0aW9uU2VydmljZSA9IG5ldyBQb3NpdGlvbmluZygpO1xuZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50cyhob3N0RWxlbWVudCwgdGFyZ2V0RWxlbWVudCwgcGxhY2VtZW50LCBhcHBlbmRUb0JvZHksIG9wdGlvbnMsIHJlbmRlcmVyKSB7XG4gICAgY29uc3QgZGF0YSA9IHBvc2l0aW9uU2VydmljZS5wb3NpdGlvbkVsZW1lbnRzKGhvc3RFbGVtZW50LCB0YXJnZXRFbGVtZW50LCBwbGFjZW1lbnQsIGFwcGVuZFRvQm9keSwgb3B0aW9ucyk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0cyA9IGdldE9mZnNldHMoZGF0YSk7XG4gICAgc2V0U3R5bGVzKHRhcmdldEVsZW1lbnQsIHtcbiAgICAgICAgJ3dpbGwtY2hhbmdlJzogJ3RyYW5zZm9ybScsXG4gICAgICAgIHRvcDogJzBweCcsXG4gICAgICAgIGxlZnQ6ICcwcHgnLFxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke29mZnNldHMubGVmdH1weCwgJHtvZmZzZXRzLnRvcH1weCwgMHB4KWBcbiAgICB9LCByZW5kZXJlcik7XG4gICAgaWYgKGRhdGEuaW5zdGFuY2UuYXJyb3cpIHtcbiAgICAgICAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UuYXJyb3csIGRhdGEub2Zmc2V0cy5hcnJvdywgcmVuZGVyZXIpO1xuICAgIH1cbiAgICB1cGRhdGVDb250YWluZXJDbGFzcyhkYXRhLCByZW5kZXJlcik7XG59XG5cbmNsYXNzIFBvc2l0aW9uaW5nU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iobmdab25lLCByZW5kZXJlckZhY3RvcnksIHBsYXRmb3JtSWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGUkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCQgPSBtZXJnZShmcm9tRXZlbnQod2luZG93LCAnc2Nyb2xsJywgeyBwYXNzaXZlOiB0cnVlIH0pLCBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJywgeyBwYXNzaXZlOiB0cnVlIH0pLCBvZigwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciksIHRoaXMudXBkYXRlJCQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50JC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKHBvc2l0aW9uRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50cyhfZ2V0SHRtbEVsZW1lbnQocG9zaXRpb25FbGVtZW50LnRhcmdldCksIF9nZXRIdG1sRWxlbWVudChwb3NpdGlvbkVsZW1lbnQuZWxlbWVudCksIHBvc2l0aW9uRWxlbWVudC5hdHRhY2htZW50LCBwb3NpdGlvbkVsZW1lbnQuYXBwZW5kVG9Cb2R5LCB0aGlzLm9wdGlvbnMsIHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zaXRpb24ob3B0aW9ucykge1xuICAgICAgICB0aGlzLmFkZFBvc2l0aW9uRWxlbWVudChvcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50JCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50JDtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYWRkUG9zaXRpb25FbGVtZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnRzLnNldChfZ2V0SHRtbEVsZW1lbnQob3B0aW9ucy5lbGVtZW50KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhbGNQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUkJC5uZXh0KG51bGwpO1xuICAgIH1cbiAgICBkZWxldGVQb3NpdGlvbkVsZW1lbnQoZWxSZWYpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnRzLmRlbGV0ZShfZ2V0SHRtbEVsZW1lbnQoZWxSZWYpKTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxufVxuUG9zaXRpb25pbmdTZXJ2aWNlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjAuM1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBvc2l0aW9uaW5nU2VydmljZSwgZGVwczogW3sgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBpMC5SZW5kZXJlckZhY3RvcnkyIH0sIHsgdG9rZW46IFBMQVRGT1JNX0lEIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5Qb3NpdGlvbmluZ1NlcnZpY2UuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjAuM1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBvc2l0aW9uaW5nU2VydmljZSwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjAuM1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBvc2l0aW9uaW5nU2VydmljZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5OZ1pvbmUgfSwgeyB0eXBlOiBpMC5SZW5kZXJlckZhY3RvcnkyIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtQTEFURk9STV9JRF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcbmZ1bmN0aW9uIF9nZXRIdG1sRWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBnb3QgYSBzZWxlY3RvclxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudCA/PyBudWxsO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IFBsYWNlbWVudEZvckJzNSwgUG9zaXRpb25pbmcsIFBvc2l0aW9uaW5nU2VydmljZSwgY2hlY2tNYXJnaW5zLCBwb3NpdGlvbkVsZW1lbnRzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZ3gtYm9vdHN0cmFwLXBvc2l0aW9uaW5nLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ngx-bootstrap/positioning/fesm2020/ngx-bootstrap-positioning.mjs\n");

/***/ })

}]);