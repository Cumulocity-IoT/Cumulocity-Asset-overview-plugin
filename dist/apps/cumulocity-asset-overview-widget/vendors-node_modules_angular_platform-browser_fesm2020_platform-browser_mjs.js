"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_angular_platform-browser_fesm2020_platform-browser_mjs"],{

/***/ "./node_modules/@angular/platform-browser/fesm2020/platform-browser.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@angular/platform-browser/fesm2020/platform-browser.mjs ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BrowserModule\": function() { return /* binding */ BrowserModule; },\n/* harmony export */   \"BrowserTransferStateModule\": function() { return /* binding */ BrowserTransferStateModule; },\n/* harmony export */   \"By\": function() { return /* binding */ By; },\n/* harmony export */   \"DomSanitizer\": function() { return /* binding */ DomSanitizer; },\n/* harmony export */   \"EVENT_MANAGER_PLUGINS\": function() { return /* binding */ EVENT_MANAGER_PLUGINS; },\n/* harmony export */   \"EventManager\": function() { return /* binding */ EventManager; },\n/* harmony export */   \"HAMMER_GESTURE_CONFIG\": function() { return /* binding */ HAMMER_GESTURE_CONFIG; },\n/* harmony export */   \"HAMMER_LOADER\": function() { return /* binding */ HAMMER_LOADER; },\n/* harmony export */   \"HammerGestureConfig\": function() { return /* binding */ HammerGestureConfig; },\n/* harmony export */   \"HammerModule\": function() { return /* binding */ HammerModule; },\n/* harmony export */   \"Meta\": function() { return /* binding */ Meta; },\n/* harmony export */   \"REMOVE_STYLES_ON_COMPONENT_DESTROY\": function() { return /* binding */ REMOVE_STYLES_ON_COMPONENT_DESTROY; },\n/* harmony export */   \"Title\": function() { return /* binding */ Title; },\n/* harmony export */   \"TransferState\": function() { return /* binding */ TransferState; },\n/* harmony export */   \"VERSION\": function() { return /* binding */ VERSION; },\n/* harmony export */   \"bootstrapApplication\": function() { return /* binding */ bootstrapApplication; },\n/* harmony export */   \"createApplication\": function() { return /* binding */ createApplication; },\n/* harmony export */   \"disableDebugTools\": function() { return /* binding */ disableDebugTools; },\n/* harmony export */   \"enableDebugTools\": function() { return /* binding */ enableDebugTools; },\n/* harmony export */   \"makeStateKey\": function() { return /* binding */ makeStateKey; },\n/* harmony export */   \"platformBrowser\": function() { return /* binding */ platformBrowser; },\n/* harmony export */   \"provideProtractorTestingSupport\": function() { return /* binding */ provideProtractorTestingSupport; },\n/* harmony export */   \"ɵBrowserDomAdapter\": function() { return /* binding */ BrowserDomAdapter; },\n/* harmony export */   \"ɵBrowserGetTestability\": function() { return /* binding */ BrowserGetTestability; },\n/* harmony export */   \"ɵDomEventsPlugin\": function() { return /* binding */ DomEventsPlugin; },\n/* harmony export */   \"ɵDomRendererFactory2\": function() { return /* binding */ DomRendererFactory2; },\n/* harmony export */   \"ɵDomSanitizerImpl\": function() { return /* binding */ DomSanitizerImpl; },\n/* harmony export */   \"ɵDomSharedStylesHost\": function() { return /* binding */ DomSharedStylesHost; },\n/* harmony export */   \"ɵHammerGesturesPlugin\": function() { return /* binding */ HammerGesturesPlugin; },\n/* harmony export */   \"ɵINTERNAL_BROWSER_PLATFORM_PROVIDERS\": function() { return /* binding */ INTERNAL_BROWSER_PLATFORM_PROVIDERS; },\n/* harmony export */   \"ɵKeyEventsPlugin\": function() { return /* binding */ KeyEventsPlugin; },\n/* harmony export */   \"ɵNAMESPACE_URIS\": function() { return /* binding */ NAMESPACE_URIS; },\n/* harmony export */   \"ɵSharedStylesHost\": function() { return /* binding */ SharedStylesHost; },\n/* harmony export */   \"ɵTRANSITION_ID\": function() { return /* binding */ TRANSITION_ID; },\n/* harmony export */   \"ɵescapeHtml\": function() { return /* binding */ escapeHtml; },\n/* harmony export */   \"ɵflattenStyles\": function() { return /* binding */ flattenStyles; },\n/* harmony export */   \"ɵgetDOM\": function() { return /* reexport safe */ _angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"]; },\n/* harmony export */   \"ɵinitDomAdapter\": function() { return /* binding */ initDomAdapter; },\n/* harmony export */   \"ɵshimContentAttribute\": function() { return /* binding */ shimContentAttribute; },\n/* harmony export */   \"ɵshimHostAttribute\": function() { return /* binding */ shimHostAttribute; }\n/* harmony export */ });\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/**\n * @license Angular v15.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n\n\n\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nclass GenericBrowserDomAdapter extends _angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵDomAdapter\"] {\n    constructor() {\n        super(...arguments);\n        this.supportsDOMEvents = true;\n    }\n}\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n/* tslint:disable:requireParameterType no-console */\nclass BrowserDomAdapter extends GenericBrowserDomAdapter {\n    static makeCurrent() {\n        (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵsetRootDomAdapter\"])(new BrowserDomAdapter());\n    }\n    onAndCancel(el, evt, listener) {\n        el.addEventListener(evt, listener, false);\n        // Needed to follow Dart's subscription semantic, until fix of\n        // https://code.google.com/p/dart/issues/detail?id=17406\n        return () => {\n            el.removeEventListener(evt, listener, false);\n        };\n    }\n    dispatchEvent(el, evt) {\n        el.dispatchEvent(evt);\n    }\n    remove(node) {\n        if (node.parentNode) {\n            node.parentNode.removeChild(node);\n        }\n    }\n    createElement(tagName, doc) {\n        doc = doc || this.getDefaultDocument();\n        return doc.createElement(tagName);\n    }\n    createHtmlDocument() {\n        return document.implementation.createHTMLDocument('fakeTitle');\n    }\n    getDefaultDocument() {\n        return document;\n    }\n    isElementNode(node) {\n        return node.nodeType === Node.ELEMENT_NODE;\n    }\n    isShadowRoot(node) {\n        return node instanceof DocumentFragment;\n    }\n    /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n    getGlobalEventTarget(doc, target) {\n        if (target === 'window') {\n            return window;\n        }\n        if (target === 'document') {\n            return doc;\n        }\n        if (target === 'body') {\n            return doc.body;\n        }\n        return null;\n    }\n    getBaseHref(doc) {\n        const href = getBaseElementHref();\n        return href == null ? null : relativePath(href);\n    }\n    resetBaseElement() {\n        baseElement = null;\n    }\n    getUserAgent() {\n        return window.navigator.userAgent;\n    }\n    getCookie(name) {\n        return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵparseCookieValue\"])(document.cookie, name);\n    }\n}\nlet baseElement = null;\nfunction getBaseElementHref() {\n    baseElement = baseElement || document.querySelector('base');\n    return baseElement ? baseElement.getAttribute('href') : null;\n}\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode;\nfunction relativePath(url) {\n    urlParsingNode = urlParsingNode || document.createElement('a');\n    urlParsingNode.setAttribute('href', url);\n    const pathName = urlParsingNode.pathname;\n    return pathName.charAt(0) === '/' ? pathName : `/${pathName}`;\n}\n\n/**\n * An id that identifies a particular application being bootstrapped, that should\n * match across the client/server boundary.\n */\nconst TRANSITION_ID = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('TRANSITION_ID');\nfunction appInitializerFactory(transitionId, document, injector) {\n    return () => {\n        // Wait for all application initializers to be completed before removing the styles set by\n        // the server.\n        injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationInitStatus).donePromise.then(() => {\n            const dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])();\n            const styles = document.querySelectorAll(`style[ng-transition=\"${transitionId}\"]`);\n            for (let i = 0; i < styles.length; i++) {\n                dom.remove(styles[i]);\n            }\n        });\n    };\n}\nconst SERVER_TRANSITION_PROVIDERS = [\n    {\n        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_INITIALIZER,\n        useFactory: appInitializerFactory,\n        deps: [TRANSITION_ID, _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector],\n        multi: true\n    },\n];\n\nclass BrowserGetTestability {\n    addToWindow(registry) {\n        _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].getAngularTestability = (elem, findInAncestors = true) => {\n            const testability = registry.findTestabilityInTree(elem, findInAncestors);\n            if (testability == null) {\n                throw new Error('Could not find testability for element.');\n            }\n            return testability;\n        };\n        _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].getAllAngularTestabilities = () => registry.getAllTestabilities();\n        _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].getAllAngularRootElements = () => registry.getAllRootElements();\n        const whenAllStable = (callback /** TODO #9100 */) => {\n            const testabilities = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].getAllAngularTestabilities();\n            let count = testabilities.length;\n            let didWork = false;\n            const decrement = function (didWork_ /** TODO #9100 */) {\n                didWork = didWork || didWork_;\n                count--;\n                if (count == 0) {\n                    callback(didWork);\n                }\n            };\n            testabilities.forEach(function (testability /** TODO #9100 */) {\n                testability.whenStable(decrement);\n            });\n        };\n        if (!_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].frameworkStabilizers) {\n            _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].frameworkStabilizers = [];\n        }\n        _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].frameworkStabilizers.push(whenAllStable);\n    }\n    findTestabilityInTree(registry, elem, findInAncestors) {\n        if (elem == null) {\n            return null;\n        }\n        const t = registry.getTestability(elem);\n        if (t != null) {\n            return t;\n        }\n        else if (!findInAncestors) {\n            return null;\n        }\n        if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])().isShadowRoot(elem)) {\n            return this.findTestabilityInTree(registry, elem.host, true);\n        }\n        return this.findTestabilityInTree(registry, elem.parentElement, true);\n    }\n}\n\n/**\n * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.\n */\nclass BrowserXhr {\n    build() {\n        return new XMLHttpRequest();\n    }\n}\nBrowserXhr.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserXhr, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nBrowserXhr.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserXhr });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserXhr, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }] });\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nconst EVENT_MANAGER_PLUGINS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('EventManagerPlugins');\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\nclass EventManager {\n    /**\n     * Initializes an instance of the event-manager service.\n     */\n    constructor(plugins, _zone) {\n        this._zone = _zone;\n        this._eventNameToPlugin = new Map();\n        plugins.forEach((plugin) => {\n            plugin.manager = this;\n        });\n        this._plugins = plugins.slice().reverse();\n    }\n    /**\n     * Registers a handler for a specific element and event.\n     *\n     * @param element The HTML element to receive event notifications.\n     * @param eventName The name of the event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns  A callback function that can be used to remove the handler.\n     */\n    addEventListener(element, eventName, handler) {\n        const plugin = this._findPluginFor(eventName);\n        return plugin.addEventListener(element, eventName, handler);\n    }\n    /**\n     * Registers a global handler for an event in a target view.\n     *\n     * @param target A target for global event notifications. One of \"window\", \"document\", or \"body\".\n     * @param eventName The name of the event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns A callback function that can be used to remove the handler.\n     * @deprecated No longer being used in Ivy code. To be removed in version 14.\n     */\n    addGlobalEventListener(target, eventName, handler) {\n        const plugin = this._findPluginFor(eventName);\n        return plugin.addGlobalEventListener(target, eventName, handler);\n    }\n    /**\n     * Retrieves the compilation zone in which event listeners are registered.\n     */\n    getZone() {\n        return this._zone;\n    }\n    /** @internal */\n    _findPluginFor(eventName) {\n        const plugin = this._eventNameToPlugin.get(eventName);\n        if (plugin) {\n            return plugin;\n        }\n        const plugins = this._plugins;\n        for (let i = 0; i < plugins.length; i++) {\n            const plugin = plugins[i];\n            if (plugin.supports(eventName)) {\n                this._eventNameToPlugin.set(eventName, plugin);\n                return plugin;\n            }\n        }\n        throw new Error(`No event manager plugin found for event ${eventName}`);\n    }\n}\nEventManager.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: EventManager, deps: [{ token: EVENT_MANAGER_PLUGINS }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nEventManager.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: EventManager });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: EventManager, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [EVENT_MANAGER_PLUGINS]\n                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }]; } });\nclass EventManagerPlugin {\n    constructor(_doc) {\n        this._doc = _doc;\n    }\n    addGlobalEventListener(element, eventName, handler) {\n        const target = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])().getGlobalEventTarget(this._doc, element);\n        if (!target) {\n            throw new Error(`Unsupported event target ${target} for event ${eventName}`);\n        }\n        return this.addEventListener(target, eventName, handler);\n    }\n}\n\nclass SharedStylesHost {\n    constructor() {\n        this.usageCount = new Map();\n    }\n    addStyles(styles) {\n        for (const style of styles) {\n            const usageCount = this.changeUsageCount(style, 1);\n            if (usageCount === 1) {\n                this.onStyleAdded(style);\n            }\n        }\n    }\n    removeStyles(styles) {\n        for (const style of styles) {\n            const usageCount = this.changeUsageCount(style, -1);\n            if (usageCount === 0) {\n                this.onStyleRemoved(style);\n            }\n        }\n    }\n    onStyleRemoved(style) { }\n    onStyleAdded(style) { }\n    getAllStyles() {\n        return this.usageCount.keys();\n    }\n    changeUsageCount(style, delta) {\n        const map = this.usageCount;\n        let usage = map.get(style) ?? 0;\n        usage += delta;\n        if (usage > 0) {\n            map.set(style, usage);\n        }\n        else {\n            map.delete(style);\n        }\n        return usage;\n    }\n    ngOnDestroy() {\n        for (const style of this.getAllStyles()) {\n            this.onStyleRemoved(style);\n        }\n        this.usageCount.clear();\n    }\n}\nSharedStylesHost.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: SharedStylesHost, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nSharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: SharedStylesHost });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: SharedStylesHost, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }] });\nclass DomSharedStylesHost extends SharedStylesHost {\n    constructor(doc) {\n        super();\n        this.doc = doc;\n        // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n        this.styleRef = new Map();\n        this.hostNodes = new Set();\n        this.resetHostNodes();\n    }\n    onStyleAdded(style) {\n        for (const host of this.hostNodes) {\n            this.addStyleToHost(host, style);\n        }\n    }\n    onStyleRemoved(style) {\n        const styleRef = this.styleRef;\n        const styleElements = styleRef.get(style);\n        styleElements?.forEach(e => e.remove());\n        styleRef.delete(style);\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.styleRef.clear();\n        this.resetHostNodes();\n    }\n    addHost(hostNode) {\n        this.hostNodes.add(hostNode);\n        for (const style of this.getAllStyles()) {\n            this.addStyleToHost(hostNode, style);\n        }\n    }\n    removeHost(hostNode) {\n        this.hostNodes.delete(hostNode);\n    }\n    addStyleToHost(host, style) {\n        const styleEl = this.doc.createElement('style');\n        styleEl.textContent = style;\n        host.appendChild(styleEl);\n        const styleElRef = this.styleRef.get(style);\n        if (styleElRef) {\n            styleElRef.push(styleEl);\n        }\n        else {\n            this.styleRef.set(style, [styleEl]);\n        }\n    }\n    resetHostNodes() {\n        const hostNodes = this.hostNodes;\n        hostNodes.clear();\n        // Re-add the head element back since this is the default host.\n        hostNodes.add(this.doc.head);\n    }\n}\nDomSharedStylesHost.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSharedStylesHost, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nDomSharedStylesHost.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSharedStylesHost });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSharedStylesHost, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\nconst NAMESPACE_URIS = {\n    'svg': 'http://www.w3.org/2000/svg',\n    'xhtml': 'http://www.w3.org/1999/xhtml',\n    'xlink': 'http://www.w3.org/1999/xlink',\n    'xml': 'http://www.w3.org/XML/1998/namespace',\n    'xmlns': 'http://www.w3.org/2000/xmlns/',\n    'math': 'http://www.w3.org/1998/MathML/',\n};\nconst COMPONENT_REGEX = /%COMP%/g;\nconst NG_DEV_MODE$1 = typeof ngDevMode === 'undefined' || !!ngDevMode;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n/**\n * The default value for the `REMOVE_STYLES_ON_COMPONENT_DESTROY` DI token.\n */\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = false;\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates whether styles\n * of destroyed components should be removed from DOM.\n *\n * By default, the value is set to `false`. This will be changed in the next major version.\n * @publicApi\n */\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('RemoveStylesOnCompDestory', {\n    providedIn: 'root',\n    factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT,\n});\nfunction shimContentAttribute(componentShortId) {\n    return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction shimHostAttribute(componentShortId) {\n    return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction flattenStyles(compId, styles) {\n    // Cannot use `Infinity` as depth as `infinity` is not a number literal in TypeScript.\n    // See: https://github.com/microsoft/TypeScript/issues/32277\n    return styles.flat(100).map(s => s.replace(COMPONENT_REGEX, compId));\n}\nfunction decoratePreventDefault(eventHandler) {\n    // `DebugNode.triggerEventHandler` needs to know if the listener was created with\n    // decoratePreventDefault or is a listener added outside the Angular context so it can handle the\n    // two differently. In the first case, the special '__ngUnwrap__' token is passed to the unwrap\n    // the listener (see below).\n    return (event) => {\n        // Ivy uses '__ngUnwrap__' as a special token that allows us to unwrap the function\n        // so that it can be invoked programmatically by `DebugNode.triggerEventHandler`. The debug_node\n        // can inspect the listener toString contents for the existence of this special token. Because\n        // the token is a string literal, it is ensured to not be modified by compiled code.\n        if (event === '__ngUnwrap__') {\n            return eventHandler;\n        }\n        const allowDefaultBehavior = eventHandler(event);\n        if (allowDefaultBehavior === false) {\n            // TODO(tbosch): move preventDefault into event plugins...\n            event.preventDefault();\n            event.returnValue = false;\n        }\n        return undefined;\n    };\n}\nclass DomRendererFactory2 {\n    constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestory) {\n        this.eventManager = eventManager;\n        this.sharedStylesHost = sharedStylesHost;\n        this.appId = appId;\n        this.removeStylesOnCompDestory = removeStylesOnCompDestory;\n        this.rendererByCompId = new Map();\n        this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n    }\n    createRenderer(element, type) {\n        if (!element || !type) {\n            return this.defaultRenderer;\n        }\n        const renderer = this.getOrCreateRenderer(element, type);\n        // Renderers have different logic due to different encapsulation behaviours.\n        // Ex: for emulated, an attribute is added to the element.\n        if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n            renderer.applyToHost(element);\n        }\n        else if (renderer instanceof NoneEncapsulationDomRenderer) {\n            renderer.applyStyles();\n        }\n        return renderer;\n    }\n    getOrCreateRenderer(element, type) {\n        const rendererByCompId = this.rendererByCompId;\n        let renderer = rendererByCompId.get(type.id);\n        if (!renderer) {\n            const eventManager = this.eventManager;\n            const sharedStylesHost = this.sharedStylesHost;\n            const removeStylesOnCompDestory = this.removeStylesOnCompDestory;\n            switch (type.encapsulation) {\n                case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.Emulated:\n                    renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestory);\n                    break;\n                case _angular_core__WEBPACK_IMPORTED_MODULE_1__.ViewEncapsulation.ShadowDom:\n                    return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type);\n                default:\n                    renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestory);\n                    break;\n            }\n            renderer.onDestroy = () => rendererByCompId.delete(type.id);\n            rendererByCompId.set(type.id, renderer);\n        }\n        return renderer;\n    }\n    ngOnDestroy() {\n        this.rendererByCompId.clear();\n    }\n    begin() { }\n    end() { }\n}\nDomRendererFactory2.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomRendererFactory2, deps: [{ token: EventManager }, { token: DomSharedStylesHost }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID }, { token: REMOVE_STYLES_ON_COMPONENT_DESTROY }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nDomRendererFactory2.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomRendererFactory2 });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomRendererFactory2, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: EventManager }, { type: DomSharedStylesHost }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]\n                }] }]; } });\nclass DefaultDomRenderer2 {\n    constructor(eventManager) {\n        this.eventManager = eventManager;\n        this.data = Object.create(null);\n        this.destroyNode = null;\n    }\n    destroy() { }\n    createElement(name, namespace) {\n        if (namespace) {\n            // TODO: `|| namespace` was added in\n            // https://github.com/angular/angular/commit/2b9cc8503d48173492c29f5a271b61126104fbdb to\n            // support how Ivy passed around the namespace URI rather than short name at the time. It did\n            // not, however extend the support to other parts of the system (setAttribute, setAttribute,\n            // and the ServerRenderer). We should decide what exactly the semantics for dealing with\n            // namespaces should be and make it consistent.\n            // Related issues:\n            // https://github.com/angular/angular/issues/44028\n            // https://github.com/angular/angular/issues/44883\n            return document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n        }\n        return document.createElement(name);\n    }\n    createComment(value) {\n        return document.createComment(value);\n    }\n    createText(value) {\n        return document.createTextNode(value);\n    }\n    appendChild(parent, newChild) {\n        const targetParent = isTemplateNode(parent) ? parent.content : parent;\n        targetParent.appendChild(newChild);\n    }\n    insertBefore(parent, newChild, refChild) {\n        if (parent) {\n            const targetParent = isTemplateNode(parent) ? parent.content : parent;\n            targetParent.insertBefore(newChild, refChild);\n        }\n    }\n    removeChild(parent, oldChild) {\n        if (parent) {\n            parent.removeChild(oldChild);\n        }\n    }\n    selectRootElement(selectorOrNode, preserveContent) {\n        let el = typeof selectorOrNode === 'string' ? document.querySelector(selectorOrNode) :\n            selectorOrNode;\n        if (!el) {\n            throw new Error(`The selector \"${selectorOrNode}\" did not match any elements`);\n        }\n        if (!preserveContent) {\n            el.textContent = '';\n        }\n        return el;\n    }\n    parentNode(node) {\n        return node.parentNode;\n    }\n    nextSibling(node) {\n        return node.nextSibling;\n    }\n    setAttribute(el, name, value, namespace) {\n        if (namespace) {\n            name = namespace + ':' + name;\n            const namespaceUri = NAMESPACE_URIS[namespace];\n            if (namespaceUri) {\n                el.setAttributeNS(namespaceUri, name, value);\n            }\n            else {\n                el.setAttribute(name, value);\n            }\n        }\n        else {\n            el.setAttribute(name, value);\n        }\n    }\n    removeAttribute(el, name, namespace) {\n        if (namespace) {\n            const namespaceUri = NAMESPACE_URIS[namespace];\n            if (namespaceUri) {\n                el.removeAttributeNS(namespaceUri, name);\n            }\n            else {\n                el.removeAttribute(`${namespace}:${name}`);\n            }\n        }\n        else {\n            el.removeAttribute(name);\n        }\n    }\n    addClass(el, name) {\n        el.classList.add(name);\n    }\n    removeClass(el, name) {\n        el.classList.remove(name);\n    }\n    setStyle(el, style, value, flags) {\n        if (flags & (_angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase | _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important)) {\n            el.style.setProperty(style, value, flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.Important ? 'important' : '');\n        }\n        else {\n            el.style[style] = value;\n        }\n    }\n    removeStyle(el, style, flags) {\n        if (flags & _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererStyleFlags2.DashCase) {\n            el.style.removeProperty(style);\n        }\n        else {\n            // IE requires '' instead of null\n            // see https://github.com/angular/angular/issues/7916\n            el.style[style] = '';\n        }\n    }\n    setProperty(el, name, value) {\n        NG_DEV_MODE$1 && checkNoSyntheticProp(name, 'property');\n        el[name] = value;\n    }\n    setValue(node, value) {\n        node.nodeValue = value;\n    }\n    listen(target, event, callback) {\n        NG_DEV_MODE$1 && checkNoSyntheticProp(event, 'listener');\n        if (typeof target === 'string') {\n            return this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback));\n        }\n        return this.eventManager.addEventListener(target, event, decoratePreventDefault(callback));\n    }\n}\nconst AT_CHARCODE = (() => '@'.charCodeAt(0))();\nfunction checkNoSyntheticProp(name, nameKind) {\n    if (name.charCodeAt(0) === AT_CHARCODE) {\n        throw new Error(`Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Either \\`BrowserAnimationsModule\\` or \\`NoopAnimationsModule\\` are imported in your application.\n  - There is corresponding configuration for the animation named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.io/api/core/Component#animations).`);\n    }\n}\nfunction isTemplateNode(node) {\n    return node.tagName === 'TEMPLATE' && node.content !== undefined;\n}\nclass ShadowDomRenderer extends DefaultDomRenderer2 {\n    constructor(eventManager, sharedStylesHost, hostEl, component) {\n        super(eventManager);\n        this.sharedStylesHost = sharedStylesHost;\n        this.hostEl = hostEl;\n        this.shadowRoot = hostEl.attachShadow({ mode: 'open' });\n        this.sharedStylesHost.addHost(this.shadowRoot);\n        const styles = flattenStyles(component.id, component.styles);\n        for (const style of styles) {\n            const styleEl = document.createElement('style');\n            styleEl.textContent = style;\n            this.shadowRoot.appendChild(styleEl);\n        }\n    }\n    nodeOrShadowRoot(node) {\n        return node === this.hostEl ? this.shadowRoot : node;\n    }\n    appendChild(parent, newChild) {\n        return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n    }\n    insertBefore(parent, newChild, refChild) {\n        return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n    }\n    removeChild(parent, oldChild) {\n        return super.removeChild(this.nodeOrShadowRoot(parent), oldChild);\n    }\n    parentNode(node) {\n        return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n    }\n    destroy() {\n        this.sharedStylesHost.removeHost(this.shadowRoot);\n    }\n}\nclass NoneEncapsulationDomRenderer extends DefaultDomRenderer2 {\n    constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestory, compId = component.id) {\n        super(eventManager);\n        this.sharedStylesHost = sharedStylesHost;\n        this.removeStylesOnCompDestory = removeStylesOnCompDestory;\n        this.rendererUsageCount = 0;\n        this.styles = flattenStyles(compId, component.styles);\n    }\n    applyStyles() {\n        this.sharedStylesHost.addStyles(this.styles);\n        this.rendererUsageCount++;\n    }\n    destroy() {\n        if (!this.removeStylesOnCompDestory) {\n            return;\n        }\n        this.sharedStylesHost.removeStyles(this.styles);\n        this.rendererUsageCount--;\n        if (this.rendererUsageCount === 0) {\n            this.onDestroy?.();\n        }\n    }\n}\nclass EmulatedEncapsulationDomRenderer2 extends NoneEncapsulationDomRenderer {\n    constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestory) {\n        const compId = appId + '-' + component.id;\n        super(eventManager, sharedStylesHost, component, removeStylesOnCompDestory, compId);\n        this.contentAttr = shimContentAttribute(compId);\n        this.hostAttr = shimHostAttribute(compId);\n    }\n    applyToHost(element) {\n        this.applyStyles();\n        this.setAttribute(element, this.hostAttr, '');\n    }\n    createElement(parent, name) {\n        const el = super.createElement(parent, name);\n        super.setAttribute(el, this.contentAttr, '');\n        return el;\n    }\n}\n\nclass DomEventsPlugin extends EventManagerPlugin {\n    constructor(doc) {\n        super(doc);\n    }\n    // This plugin should come last in the list of plugins, because it accepts all\n    // events.\n    supports(eventName) {\n        return true;\n    }\n    addEventListener(element, eventName, handler) {\n        element.addEventListener(eventName, handler, false);\n        return () => this.removeEventListener(element, eventName, handler);\n    }\n    removeEventListener(target, eventName, callback) {\n        return target.removeEventListener(eventName, callback);\n    }\n}\nDomEventsPlugin.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomEventsPlugin, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nDomEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomEventsPlugin });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomEventsPlugin, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\n/**\n * Defines supported modifiers for key events.\n */\nconst MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];\n// The following values are here for cross-browser compatibility and to match the W3C standard\n// cf https://www.w3.org/TR/DOM-Level-3-Events-key/\nconst _keyMap = {\n    '\\b': 'Backspace',\n    '\\t': 'Tab',\n    '\\x7F': 'Delete',\n    '\\x1B': 'Escape',\n    'Del': 'Delete',\n    'Esc': 'Escape',\n    'Left': 'ArrowLeft',\n    'Right': 'ArrowRight',\n    'Up': 'ArrowUp',\n    'Down': 'ArrowDown',\n    'Menu': 'ContextMenu',\n    'Scroll': 'ScrollLock',\n    'Win': 'OS'\n};\n/**\n * Retrieves modifiers from key-event objects.\n */\nconst MODIFIER_KEY_GETTERS = {\n    'alt': (event) => event.altKey,\n    'control': (event) => event.ctrlKey,\n    'meta': (event) => event.metaKey,\n    'shift': (event) => event.shiftKey\n};\n/**\n * @publicApi\n * A browser plug-in that provides support for handling of key events in Angular.\n */\nclass KeyEventsPlugin extends EventManagerPlugin {\n    /**\n     * Initializes an instance of the browser plug-in.\n     * @param doc The document in which key events will be detected.\n     */\n    constructor(doc) {\n        super(doc);\n    }\n    /**\n     * Reports whether a named key event is supported.\n     * @param eventName The event name to query.\n     * @return True if the named key event is supported.\n     */\n    supports(eventName) {\n        return KeyEventsPlugin.parseEventName(eventName) != null;\n    }\n    /**\n     * Registers a handler for a specific element and key event.\n     * @param element The HTML element to receive event notifications.\n     * @param eventName The name of the key event to listen for.\n     * @param handler A function to call when the notification occurs. Receives the\n     * event object as an argument.\n     * @returns The key event that was registered.\n     */\n    addEventListener(element, eventName, handler) {\n        const parsedEvent = KeyEventsPlugin.parseEventName(eventName);\n        const outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());\n        return this.manager.getZone().runOutsideAngular(() => {\n            return (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);\n        });\n    }\n    /**\n     * Parses the user provided full keyboard event definition and normalizes it for\n     * later internal use. It ensures the string is all lowercase, converts special\n     * characters to a standard spelling, and orders all the values consistently.\n     *\n     * @param eventName The name of the key event to listen for.\n     * @returns an object with the full, normalized string, and the dom event name\n     * or null in the case when the event doesn't match a keyboard event.\n     */\n    static parseEventName(eventName) {\n        const parts = eventName.toLowerCase().split('.');\n        const domEventName = parts.shift();\n        if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {\n            return null;\n        }\n        const key = KeyEventsPlugin._normalizeKey(parts.pop());\n        let fullKey = '';\n        let codeIX = parts.indexOf('code');\n        if (codeIX > -1) {\n            parts.splice(codeIX, 1);\n            fullKey = 'code.';\n        }\n        MODIFIER_KEYS.forEach(modifierName => {\n            const index = parts.indexOf(modifierName);\n            if (index > -1) {\n                parts.splice(index, 1);\n                fullKey += modifierName + '.';\n            }\n        });\n        fullKey += key;\n        if (parts.length != 0 || key.length === 0) {\n            // returning null instead of throwing to let another plugin process the event\n            return null;\n        }\n        // NOTE: Please don't rewrite this as so, as it will break JSCompiler property renaming.\n        //       The code must remain in the `result['domEventName']` form.\n        // return {domEventName, fullKey};\n        const result = {};\n        result['domEventName'] = domEventName;\n        result['fullKey'] = fullKey;\n        return result;\n    }\n    /**\n     * Determines whether the actual keys pressed match the configured key code string.\n     * The `fullKeyCode` event is normalized in the `parseEventName` method when the\n     * event is attached to the DOM during the `addEventListener` call. This is unseen\n     * by the end user and is normalized for internal consistency and parsing.\n     *\n     * @param event The keyboard event.\n     * @param fullKeyCode The normalized user defined expected key event string\n     * @returns boolean.\n     */\n    static matchEventFullKeyCode(event, fullKeyCode) {\n        let keycode = _keyMap[event.key] || event.key;\n        let key = '';\n        if (fullKeyCode.indexOf('code.') > -1) {\n            keycode = event.code;\n            key = 'code.';\n        }\n        // the keycode could be unidentified so we have to check here\n        if (keycode == null || !keycode)\n            return false;\n        keycode = keycode.toLowerCase();\n        if (keycode === ' ') {\n            keycode = 'space'; // for readability\n        }\n        else if (keycode === '.') {\n            keycode = 'dot'; // because '.' is used as a separator in event names\n        }\n        MODIFIER_KEYS.forEach(modifierName => {\n            if (modifierName !== keycode) {\n                const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n                if (modifierGetter(event)) {\n                    key += modifierName + '.';\n                }\n            }\n        });\n        key += keycode;\n        return key === fullKeyCode;\n    }\n    /**\n     * Configures a handler callback for a key event.\n     * @param fullKey The event name that combines all simultaneous keystrokes.\n     * @param handler The function that responds to the key event.\n     * @param zone The zone in which the event occurred.\n     * @returns A callback function.\n     */\n    static eventCallback(fullKey, handler, zone) {\n        return (event) => {\n            if (KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {\n                zone.runGuarded(() => handler(event));\n            }\n        };\n    }\n    /** @internal */\n    static _normalizeKey(keyName) {\n        // TODO: switch to a Map if the mapping grows too much\n        switch (keyName) {\n            case 'esc':\n                return 'escape';\n            default:\n                return keyName;\n        }\n    }\n}\nKeyEventsPlugin.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: KeyEventsPlugin, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nKeyEventsPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: KeyEventsPlugin });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: KeyEventsPlugin, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\n/**\n * Bootstraps an instance of an Angular application and renders a standalone component as the\n * application's root component. More information about standalone components can be found in [this\n * guide](guide/standalone-components).\n *\n * @usageNotes\n * The root component passed into this function *must* be a standalone one (should have the\n * `standalone: true` flag in the `@Component` decorator config).\n *\n * ```typescript\n * @Component({\n *   standalone: true,\n *   template: 'Hello world!'\n * })\n * class RootComponent {}\n *\n * const appRef: ApplicationRef = await bootstrapApplication(RootComponent);\n * ```\n *\n * You can add the list of providers that should be available in the application injector by\n * specifying the `providers` field in an object passed as the second argument:\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     {provide: BACKEND_URL, useValue: 'https://yourdomain.com/api'}\n *   ]\n * });\n * ```\n *\n * The `importProvidersFrom` helper method can be used to collect all providers from any\n * existing NgModule (and transitively from all NgModules that it imports):\n *\n * ```typescript\n * await bootstrapApplication(RootComponent, {\n *   providers: [\n *     importProvidersFrom(SomeNgModule)\n *   ]\n * });\n * ```\n *\n * Note: the `bootstrapApplication` method doesn't include [Testability](api/core/Testability) by\n * default. You can add [Testability](api/core/Testability) by getting the list of necessary\n * providers using `provideProtractorTestingSupport()` function and adding them into the `providers`\n * array, for example:\n *\n * ```typescript\n * import {provideProtractorTestingSupport} from '@angular/platform-browser';\n *\n * await bootstrapApplication(RootComponent, {providers: [provideProtractorTestingSupport()]});\n * ```\n *\n * @param rootComponent A reference to a standalone component that should be rendered.\n * @param options Extra configuration for the bootstrap operation, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n */\nfunction bootstrapApplication(rootComponent, options) {\n    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵinternalCreateApplication\"])({ rootComponent, ...createProvidersConfig(options) });\n}\n/**\n * Create an instance of an Angular application without bootstrapping any components. This is useful\n * for the situation where one wants to decouple application environment creation (a platform and\n * associated injectors) from rendering components on a screen. Components can be subsequently\n * bootstrapped on the returned `ApplicationRef`.\n *\n * @param options Extra configuration for the application environment, see `ApplicationConfig` for\n *     additional info.\n * @returns A promise that returns an `ApplicationRef` instance once resolved.\n *\n * @publicApi\n */\nfunction createApplication(options) {\n    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵinternalCreateApplication\"])(createProvidersConfig(options));\n}\nfunction createProvidersConfig(options) {\n    return {\n        appProviders: [\n            ...BROWSER_MODULE_PROVIDERS,\n            ...(options?.providers ?? []),\n        ],\n        platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS\n    };\n}\n/**\n * Returns a set of providers required to setup [Testability](api/core/Testability) for an\n * application bootstrapped using the `bootstrapApplication` function. The set of providers is\n * needed to support testing an application with Protractor (which relies on the Testability APIs\n * to be present).\n *\n * @returns An array of providers required to setup Testability for an application and make it\n *     available for testing using Protractor.\n *\n * @publicApi\n */\nfunction provideProtractorTestingSupport() {\n    // Return a copy to prevent changes to the original array in case any in-place\n    // alterations are performed to the `provideProtractorTestingSupport` call results in app code.\n    return [...TESTABILITY_PROVIDERS];\n}\nfunction initDomAdapter() {\n    BrowserDomAdapter.makeCurrent();\n}\nfunction errorHandler() {\n    return new _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler();\n}\nfunction _document() {\n    // Tell ivy about the global document\n    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵsetDocument\"])(document);\n    return document;\n}\nconst INTERNAL_BROWSER_PLATFORM_PROVIDERS = [\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID, useValue: _angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵPLATFORM_BROWSER_ID\"] },\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },\n    { provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, useFactory: _document, deps: [] },\n];\n/**\n * A factory function that returns a `PlatformRef` instance associated with browser service\n * providers.\n *\n * @publicApi\n */\nconst platformBrowser = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.createPlatformFactory)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);\n/**\n * Internal marker to signal whether providers from the `BrowserModule` are already present in DI.\n * This is needed to avoid loading `BrowserModule` providers twice. We can't rely on the\n * `BrowserModule` presence itself, since the standalone-based bootstrap just imports\n * `BrowserModule` providers without referencing the module itself.\n */\nconst BROWSER_MODULE_PROVIDERS_MARKER = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken(NG_DEV_MODE ? 'BrowserModule Providers Marker' : '');\nconst TESTABILITY_PROVIDERS = [\n    {\n        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵTESTABILITY_GETTER\"],\n        useClass: BrowserGetTestability,\n        deps: [],\n    },\n    {\n        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵTESTABILITY\"],\n        useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,\n        deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone, _angular_core__WEBPACK_IMPORTED_MODULE_1__.TestabilityRegistry, _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵTESTABILITY_GETTER\"]]\n    },\n    {\n        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,\n        useClass: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Testability,\n        deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone, _angular_core__WEBPACK_IMPORTED_MODULE_1__.TestabilityRegistry, _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵTESTABILITY_GETTER\"]]\n    }\n];\nconst BROWSER_MODULE_PROVIDERS = [\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵINJECTOR_SCOPE\"], useValue: 'root' },\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler, useFactory: errorHandler, deps: [] }, {\n        provide: EVENT_MANAGER_PLUGINS,\n        useClass: DomEventsPlugin,\n        multi: true,\n        deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone, _angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]\n    },\n    { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true, deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT] }, {\n        provide: DomRendererFactory2,\n        useClass: DomRendererFactory2,\n        deps: [EventManager, DomSharedStylesHost, _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID, REMOVE_STYLES_ON_COMPONENT_DESTROY]\n    },\n    { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.RendererFactory2, useExisting: DomRendererFactory2 },\n    { provide: SharedStylesHost, useExisting: DomSharedStylesHost },\n    { provide: DomSharedStylesHost, useClass: DomSharedStylesHost, deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT] },\n    { provide: EventManager, useClass: EventManager, deps: [EVENT_MANAGER_PLUGINS, _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone] },\n    { provide: _angular_common__WEBPACK_IMPORTED_MODULE_0__.XhrFactory, useClass: BrowserXhr, deps: [] },\n    NG_DEV_MODE ? { provide: BROWSER_MODULE_PROVIDERS_MARKER, useValue: true } : []\n];\n/**\n * Exports required infrastructure for all Angular apps.\n * Included by default in all Angular apps created with the CLI\n * `new` command.\n * Re-exports `CommonModule` and `ApplicationModule`, making their\n * exports and providers available to all apps.\n *\n * @publicApi\n */\nclass BrowserModule {\n    constructor(providersAlreadyPresent) {\n        if (NG_DEV_MODE && providersAlreadyPresent) {\n            throw new Error(`Providers from the \\`BrowserModule\\` have already been loaded. If you need access ` +\n                `to common directives such as NgIf and NgFor, import the \\`CommonModule\\` instead.`);\n        }\n    }\n    /**\n     * Configures a browser-based app to transition from a server-rendered app, if\n     * one is present on the page.\n     *\n     * @param params An object containing an identifier for the app to transition.\n     * The ID must match between the client and server versions of the app.\n     * @returns The reconfigured `BrowserModule` to import into the app's root `AppModule`.\n     */\n    static withServerTransition(params) {\n        return {\n            ngModule: BrowserModule,\n            providers: [\n                { provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID, useValue: params.appId },\n                { provide: TRANSITION_ID, useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID },\n                SERVER_TRANSITION_PROVIDERS,\n            ],\n        };\n    }\n}\nBrowserModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserModule, deps: [{ token: BROWSER_MODULE_PROVIDERS_MARKER, optional: true, skipSelf: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].NgModule });\nBrowserModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserModule, exports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule] });\nBrowserModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserModule, providers: [\n        ...BROWSER_MODULE_PROVIDERS,\n        ...TESTABILITY_PROVIDERS\n    ], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,\n            args: [{\n                    providers: [\n                        ...BROWSER_MODULE_PROVIDERS,\n                        ...TESTABILITY_PROVIDERS\n                    ],\n                    exports: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.CommonModule, _angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationModule],\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.SkipSelf\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [BROWSER_MODULE_PROVIDERS_MARKER]\n                }] }]; } });\n\n/**\n * Factory to create a `Meta` service instance for the current DOM document.\n */\nfunction createMeta() {\n    return new Meta((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵinject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));\n}\n/**\n * A service for managing HTML `<meta>` tags.\n *\n * Properties of the `MetaDefinition` object match the attributes of the\n * HTML `<meta>` tag. These tags define document metadata that is important for\n * things like configuring a Content Security Policy, defining browser compatibility\n * and security settings, setting HTTP Headers, defining rich content for social sharing,\n * and Search Engine Optimization (SEO).\n *\n * To identify specific `<meta>` tags in a document, use an attribute selection\n * string in the format `\"tag_attribute='value string'\"`.\n * For example, an `attrSelector` value of `\"name='description'\"` matches a tag\n * whose `name` attribute has the value `\"description\"`.\n * Selectors are used with the `querySelector()` Document method,\n * in the format `meta[{attrSelector}]`.\n *\n * @see [HTML meta tag](https://developer.mozilla.org/docs/Web/HTML/Element/meta)\n * @see [Document.querySelector()](https://developer.mozilla.org/docs/Web/API/Document/querySelector)\n *\n *\n * @publicApi\n */\nclass Meta {\n    constructor(_doc) {\n        this._doc = _doc;\n        this._dom = (0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])();\n    }\n    /**\n     * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * If an existing element is found, it is returned and is not modified in any way.\n     * @param tag The definition of a `<meta>` element to match or create.\n     * @param forceCreation True to create a new element without checking whether one already exists.\n     * @returns The existing element with the same attributes and values if found,\n     * the new element if no match is found, or `null` if the tag parameter is not defined.\n     */\n    addTag(tag, forceCreation = false) {\n        if (!tag)\n            return null;\n        return this._getOrCreateElement(tag, forceCreation);\n    }\n    /**\n     * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n     * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n     * values in the provided tag definition, and verifies that all other attribute values are equal.\n     * @param tags An array of tag definitions to match or create.\n     * @param forceCreation True to create new elements without checking whether they already exist.\n     * @returns The matching elements if found, or the new elements.\n     */\n    addTags(tags, forceCreation = false) {\n        if (!tags)\n            return [];\n        return tags.reduce((result, tag) => {\n            if (tag) {\n                result.push(this._getOrCreateElement(tag, forceCreation));\n            }\n            return result;\n        }, []);\n    }\n    /**\n     * Retrieves a `<meta>` tag element in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching element, if any.\n     */\n    getTag(attrSelector) {\n        if (!attrSelector)\n            return null;\n        return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n    }\n    /**\n     * Retrieves a set of `<meta>` tag elements in the current HTML document.\n     * @param attrSelector The tag attribute and value to match against, in the format\n     * `\"tag_attribute='value string'\"`.\n     * @returns The matching elements, if any.\n     */\n    getTags(attrSelector) {\n        if (!attrSelector)\n            return [];\n        const list /*NodeList*/ = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n        return list ? [].slice.call(list) : [];\n    }\n    /**\n     * Modifies an existing `<meta>` tag element in the current HTML document.\n     * @param tag The tag description with which to replace the existing tag content.\n     * @param selector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n     * replacement tag.\n     * @return The modified element.\n     */\n    updateTag(tag, selector) {\n        if (!tag)\n            return null;\n        selector = selector || this._parseSelector(tag);\n        const meta = this.getTag(selector);\n        if (meta) {\n            return this._setMetaElementAttributes(tag, meta);\n        }\n        return this._getOrCreateElement(tag, true);\n    }\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param attrSelector A tag attribute and value to match against, to identify\n     * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n     */\n    removeTag(attrSelector) {\n        this.removeTagElement(this.getTag(attrSelector));\n    }\n    /**\n     * Removes an existing `<meta>` tag element from the current HTML document.\n     * @param meta The tag definition to match against to identify an existing tag.\n     */\n    removeTagElement(meta) {\n        if (meta) {\n            this._dom.remove(meta);\n        }\n    }\n    _getOrCreateElement(meta, forceCreation = false) {\n        if (!forceCreation) {\n            const selector = this._parseSelector(meta);\n            // It's allowed to have multiple elements with the same name so it's not enough to\n            // just check that element with the same name already present on the page. We also need to\n            // check if element has tag attributes\n            const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];\n            if (elem !== undefined)\n                return elem;\n        }\n        const element = this._dom.createElement('meta');\n        this._setMetaElementAttributes(meta, element);\n        const head = this._doc.getElementsByTagName('head')[0];\n        head.appendChild(element);\n        return element;\n    }\n    _setMetaElementAttributes(tag, el) {\n        Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));\n        return el;\n    }\n    _parseSelector(tag) {\n        const attr = tag.name ? 'name' : 'property';\n        return `${attr}=\"${tag[attr]}\"`;\n    }\n    _containsAttributes(tag, elem) {\n        return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);\n    }\n    _getMetaKeyMap(prop) {\n        return META_KEYS_MAP[prop] || prop;\n    }\n}\nMeta.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Meta, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nMeta.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Meta, providedIn: 'root', useFactory: createMeta, deps: [] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Meta, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root', useFactory: createMeta, deps: [] }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n/**\n * Mapping for MetaDefinition properties with their correct meta attribute names\n */\nconst META_KEYS_MAP = {\n    httpEquiv: 'http-equiv'\n};\n\n/**\n * Factory to create Title service.\n */\nfunction createTitle() {\n    return new Title((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵinject\"])(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));\n}\n/**\n * A service that can be used to get and set the title of a current HTML document.\n *\n * Since an Angular application can't be bootstrapped on the entire HTML document (`<html>` tag)\n * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements\n * (representing the `<title>` tag). Instead, this service can be used to set and get the current\n * title value.\n *\n * @publicApi\n */\nclass Title {\n    constructor(_doc) {\n        this._doc = _doc;\n    }\n    /**\n     * Get the title of the current HTML document.\n     */\n    getTitle() {\n        return this._doc.title;\n    }\n    /**\n     * Set the title of the current HTML document.\n     * @param newTitle\n     */\n    setTitle(newTitle) {\n        this._doc.title = newTitle || '';\n    }\n}\nTitle.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Title, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nTitle.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Title, providedIn: 'root', useFactory: createTitle, deps: [] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: Title, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root', useFactory: createTitle, deps: [] }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\n/**\n * Exports the value under a given `name` in the global property `ng`. For example `ng.probe` if\n * `name` is `'probe'`.\n * @param name Name under which it will be exported. Keep in mind this will be a property of the\n * global `ng` object.\n * @param value The value to export.\n */\nfunction exportNgVar(name, value) {\n    if (typeof COMPILED === 'undefined' || !COMPILED) {\n        // Note: we can't export `ng` when using closure enhanced optimization as:\n        // - closure declares globals itself for minified names, which sometimes clobber our `ng` global\n        // - we can't declare a closure extern as the namespace `ng` is already used within Google\n        //   for typings for angularJS (via `goog.provide('ng....')`).\n        const ng = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].ng = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵglobal\"].ng || {};\n        ng[name] = value;\n    }\n}\n\nconst win = typeof window !== 'undefined' && window || {};\n\nclass ChangeDetectionPerfRecord {\n    constructor(msPerTick, numTicks) {\n        this.msPerTick = msPerTick;\n        this.numTicks = numTicks;\n    }\n}\n/**\n * Entry point for all Angular profiling-related debug tools. This object\n * corresponds to the `ng.profiler` in the dev console.\n */\nclass AngularProfiler {\n    constructor(ref) {\n        this.appRef = ref.injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.ApplicationRef);\n    }\n    // tslint:disable:no-console\n    /**\n     * Exercises change detection in a loop and then prints the average amount of\n     * time in milliseconds how long a single round of change detection takes for\n     * the current state of the UI. It runs a minimum of 5 rounds for a minimum\n     * of 500 milliseconds.\n     *\n     * Optionally, a user may pass a `config` parameter containing a map of\n     * options. Supported options are:\n     *\n     * `record` (boolean) - causes the profiler to record a CPU profile while\n     * it exercises the change detector. Example:\n     *\n     * ```\n     * ng.profiler.timeChangeDetection({record: true})\n     * ```\n     */\n    timeChangeDetection(config) {\n        const record = config && config['record'];\n        const profileName = 'Change Detection';\n        // Profiler is not available in Android browsers without dev tools opened\n        const isProfilerAvailable = win.console.profile != null;\n        if (record && isProfilerAvailable) {\n            win.console.profile(profileName);\n        }\n        const start = performanceNow();\n        let numTicks = 0;\n        while (numTicks < 5 || (performanceNow() - start) < 500) {\n            this.appRef.tick();\n            numTicks++;\n        }\n        const end = performanceNow();\n        if (record && isProfilerAvailable) {\n            win.console.profileEnd(profileName);\n        }\n        const msPerTick = (end - start) / numTicks;\n        win.console.log(`ran ${numTicks} change detection cycles`);\n        win.console.log(`${msPerTick.toFixed(2)} ms per check`);\n        return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n    }\n}\nfunction performanceNow() {\n    return win.performance && win.performance.now ? win.performance.now() :\n        new Date().getTime();\n}\n\nconst PROFILER_GLOBAL_NAME = 'profiler';\n/**\n * Enabled Angular debug tools that are accessible via your browser's\n * developer console.\n *\n * Usage:\n *\n * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)\n * 1. Type `ng.` (usually the console will show auto-complete suggestion)\n * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`\n *    then hit Enter.\n *\n * @publicApi\n */\nfunction enableDebugTools(ref) {\n    exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n    return ref;\n}\n/**\n * Disables Angular tools.\n *\n * @publicApi\n */\nfunction disableDebugTools() {\n    exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\n\nfunction escapeHtml(text) {\n    const escapedText = {\n        '&': '&a;',\n        '\"': '&q;',\n        '\\'': '&s;',\n        '<': '&l;',\n        '>': '&g;',\n    };\n    return text.replace(/[&\"'<>]/g, s => escapedText[s]);\n}\nfunction unescapeHtml(text) {\n    const unescapedText = {\n        '&a;': '&',\n        '&q;': '\"',\n        '&s;': '\\'',\n        '&l;': '<',\n        '&g;': '>',\n    };\n    return text.replace(/&[^;]+;/g, s => unescapedText[s]);\n}\n/**\n * Create a `StateKey<T>` that can be used to store value of type T with `TransferState`.\n *\n * Example:\n *\n * ```\n * const COUNTER_KEY = makeStateKey<number>('counter');\n * let value = 10;\n *\n * transferState.set(COUNTER_KEY, value);\n * ```\n *\n * @publicApi\n */\nfunction makeStateKey(key) {\n    return key;\n}\n/**\n * A key value store that is transferred from the application on the server side to the application\n * on the client side.\n *\n * The `TransferState` is available as an injectable token.\n * On the client, just inject this token using DI and use it, it will be lazily initialized.\n * On the server it's already included if `renderApplication` function is used. Otherwise, import\n * the `ServerTransferStateModule` module to make the `TransferState` available.\n *\n * The values in the store are serialized/deserialized using JSON.stringify/JSON.parse. So only\n * boolean, number, string, null and non-class objects will be serialized and deserialized in a\n * non-lossy manner.\n *\n * @publicApi\n */\nclass TransferState {\n    constructor() {\n        this.store = {};\n        this.onSerializeCallbacks = {};\n        this.store = retrieveTransferredState((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT), (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID));\n    }\n    /**\n     * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n     */\n    get(key, defaultValue) {\n        return this.store[key] !== undefined ? this.store[key] : defaultValue;\n    }\n    /**\n     * Set the value corresponding to a key.\n     */\n    set(key, value) {\n        this.store[key] = value;\n    }\n    /**\n     * Remove a key from the store.\n     */\n    remove(key) {\n        delete this.store[key];\n    }\n    /**\n     * Test whether a key exists in the store.\n     */\n    hasKey(key) {\n        return this.store.hasOwnProperty(key);\n    }\n    /**\n     * Indicates whether the state is empty.\n     */\n    get isEmpty() {\n        return Object.keys(this.store).length === 0;\n    }\n    /**\n     * Register a callback to provide the value for a key when `toJson` is called.\n     */\n    onSerialize(key, callback) {\n        this.onSerializeCallbacks[key] = callback;\n    }\n    /**\n     * Serialize the current state of the store to JSON.\n     */\n    toJson() {\n        // Call the onSerialize callbacks and put those values into the store.\n        for (const key in this.onSerializeCallbacks) {\n            if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n                try {\n                    this.store[key] = this.onSerializeCallbacks[key]();\n                }\n                catch (e) {\n                    console.warn('Exception in onSerialize callback: ', e);\n                }\n            }\n        }\n        return JSON.stringify(this.store);\n    }\n}\nTransferState.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: TransferState, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nTransferState.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: TransferState, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: TransferState, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return []; } });\nfunction retrieveTransferredState(doc, appId) {\n    // Locate the script tag with the JSON data transferred from the server.\n    // The id of the script tag is set to the Angular appId + 'state'.\n    const script = doc.getElementById(appId + '-state');\n    let initialState = {};\n    if (script && script.textContent) {\n        try {\n            // Avoid using any here as it triggers lint errors in google3 (any is not allowed).\n            initialState = JSON.parse(unescapeHtml(script.textContent));\n        }\n        catch (e) {\n            console.warn('Exception while restoring TransferState for app ' + appId, e);\n        }\n    }\n    return initialState;\n}\n/**\n * NgModule to install on the client side while using the `TransferState` to transfer state from\n * server to client.\n *\n * @publicApi\n * @deprecated no longer needed, you can inject the `TransferState` in an app without providing\n *     this module.\n */\nclass BrowserTransferStateModule {\n}\nBrowserTransferStateModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserTransferStateModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].NgModule });\nBrowserTransferStateModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserTransferStateModule });\nBrowserTransferStateModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserTransferStateModule });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: BrowserTransferStateModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,\n            args: [{}]\n        }] });\n\n/**\n * Predicates for use with {@link DebugElement}'s query functions.\n *\n * @publicApi\n */\nclass By {\n    /**\n     * Match all nodes.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}\n     */\n    static all() {\n        return () => true;\n    }\n    /**\n     * Match elements by the given CSS selector.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}\n     */\n    static css(selector) {\n        return (debugElement) => {\n            return debugElement.nativeElement != null ?\n                elementMatches(debugElement.nativeElement, selector) :\n                false;\n        };\n    }\n    /**\n     * Match nodes that have the given directive present.\n     *\n     * @usageNotes\n     * ### Example\n     *\n     * {@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}\n     */\n    static directive(type) {\n        return (debugNode) => debugNode.providerTokens.indexOf(type) !== -1;\n    }\n}\nfunction elementMatches(n, selector) {\n    if ((0,_angular_common__WEBPACK_IMPORTED_MODULE_0__[\"ɵgetDOM\"])().isElementNode(n)) {\n        return n.matches && n.matches(selector) ||\n            n.msMatchesSelector && n.msMatchesSelector(selector) ||\n            n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n    }\n    return false;\n}\n\n/**\n * Supported HammerJS recognizer event names.\n */\nconst EVENT_NAMES = {\n    // pan\n    'pan': true,\n    'panstart': true,\n    'panmove': true,\n    'panend': true,\n    'pancancel': true,\n    'panleft': true,\n    'panright': true,\n    'panup': true,\n    'pandown': true,\n    // pinch\n    'pinch': true,\n    'pinchstart': true,\n    'pinchmove': true,\n    'pinchend': true,\n    'pinchcancel': true,\n    'pinchin': true,\n    'pinchout': true,\n    // press\n    'press': true,\n    'pressup': true,\n    // rotate\n    'rotate': true,\n    'rotatestart': true,\n    'rotatemove': true,\n    'rotateend': true,\n    'rotatecancel': true,\n    // swipe\n    'swipe': true,\n    'swipeleft': true,\n    'swiperight': true,\n    'swipeup': true,\n    'swipedown': true,\n    // tap\n    'tap': true,\n    'doubletap': true\n};\n/**\n * DI token for providing [HammerJS](https://hammerjs.github.io/) support to Angular.\n * @see `HammerGestureConfig`\n *\n * @ngModule HammerModule\n * @publicApi\n */\nconst HAMMER_GESTURE_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerGestureConfig');\n/**\n * Injection token used to provide a {@link HammerLoader} to Angular.\n *\n * @publicApi\n */\nconst HAMMER_LOADER = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('HammerLoader');\n/**\n * An injectable [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n * for gesture recognition. Configures specific event recognition.\n * @publicApi\n */\nclass HammerGestureConfig {\n    constructor() {\n        /**\n         * A set of supported event names for gestures to be used in Angular.\n         * Angular supports all built-in recognizers, as listed in\n         * [HammerJS documentation](https://hammerjs.github.io/).\n         */\n        this.events = [];\n        /**\n         * Maps gesture event names to a set of configuration options\n         * that specify overrides to the default values for specific properties.\n         *\n         * The key is a supported event name to be configured,\n         * and the options object contains a set of properties, with override values\n         * to be applied to the named recognizer event.\n         * For example, to disable recognition of the rotate event, specify\n         *  `{\"rotate\": {\"enable\": false}}`.\n         *\n         * Properties that are not present take the HammerJS default values.\n         * For information about which properties are supported for which events,\n         * and their allowed and default values, see\n         * [HammerJS documentation](https://hammerjs.github.io/).\n         *\n         */\n        this.overrides = {};\n    }\n    /**\n     * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n     * and attaches it to a given HTML element.\n     * @param element The element that will recognize gestures.\n     * @returns A HammerJS event-manager object.\n     */\n    buildHammer(element) {\n        const mc = new Hammer(element, this.options);\n        mc.get('pinch').set({ enable: true });\n        mc.get('rotate').set({ enable: true });\n        for (const eventName in this.overrides) {\n            mc.get(eventName).set(this.overrides[eventName]);\n        }\n        return mc;\n    }\n}\nHammerGestureConfig.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGestureConfig, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nHammerGestureConfig.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGestureConfig });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGestureConfig, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }] });\n/**\n * Event plugin that adds Hammer support to an application.\n *\n * @ngModule HammerModule\n */\nclass HammerGesturesPlugin extends EventManagerPlugin {\n    constructor(doc, _config, console, loader) {\n        super(doc);\n        this._config = _config;\n        this.console = console;\n        this.loader = loader;\n        this._loaderPromise = null;\n    }\n    supports(eventName) {\n        if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n            return false;\n        }\n        if (!window.Hammer && !this.loader) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                this.console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not ` +\n                    `loaded and no custom loader has been specified.`);\n            }\n            return false;\n        }\n        return true;\n    }\n    addEventListener(element, eventName, handler) {\n        const zone = this.manager.getZone();\n        eventName = eventName.toLowerCase();\n        // If Hammer is not present but a loader is specified, we defer adding the event listener\n        // until Hammer is loaded.\n        if (!window.Hammer && this.loader) {\n            this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());\n            // This `addEventListener` method returns a function to remove the added listener.\n            // Until Hammer is loaded, the returned function needs to *cancel* the registration rather\n            // than remove anything.\n            let cancelRegistration = false;\n            let deregister = () => {\n                cancelRegistration = true;\n            };\n            zone.runOutsideAngular(() => this._loaderPromise\n                .then(() => {\n                // If Hammer isn't actually loaded when the custom loader resolves, give up.\n                if (!window.Hammer) {\n                    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                        this.console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n                    }\n                    deregister = () => { };\n                    return;\n                }\n                if (!cancelRegistration) {\n                    // Now that Hammer is loaded and the listener is being loaded for real,\n                    // the deregistration function changes from canceling registration to\n                    // removal.\n                    deregister = this.addEventListener(element, eventName, handler);\n                }\n            })\n                .catch(() => {\n                if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                    this.console.warn(`The \"${eventName}\" event cannot be bound because the custom ` +\n                        `Hammer.JS loader failed.`);\n                }\n                deregister = () => { };\n            }));\n            // Return a function that *executes* `deregister` (and not `deregister` itself) so that we\n            // can change the behavior of `deregister` once the listener is added. Using a closure in\n            // this way allows us to avoid any additional data structures to track listener removal.\n            return () => {\n                deregister();\n            };\n        }\n        return zone.runOutsideAngular(() => {\n            // Creating the manager bind events, must be done outside of angular\n            const mc = this._config.buildHammer(element);\n            const callback = function (eventObj) {\n                zone.runGuarded(function () {\n                    handler(eventObj);\n                });\n            };\n            mc.on(eventName, callback);\n            return () => {\n                mc.off(eventName, callback);\n                // destroy mc to prevent memory leak\n                if (typeof mc.destroy === 'function') {\n                    mc.destroy();\n                }\n            };\n        });\n    }\n    isCustomEvent(eventName) {\n        return this._config.events.indexOf(eventName) > -1;\n    }\n}\nHammerGesturesPlugin.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGesturesPlugin, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }, { token: HAMMER_GESTURE_CONFIG }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵConsole\"] }, { token: HAMMER_LOADER, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nHammerGesturesPlugin.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGesturesPlugin });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerGesturesPlugin, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: HammerGestureConfig, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [HAMMER_GESTURE_CONFIG]\n                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵConsole\"] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [HAMMER_LOADER]\n                }] }]; } });\n/**\n * Adds support for HammerJS.\n *\n * Import this module at the root of your application so that Angular can work with\n * HammerJS to detect gesture events.\n *\n * Note that applications still need to include the HammerJS script itself. This module\n * simply sets up the coordination layer between HammerJS and Angular's EventManager.\n *\n * @publicApi\n */\nclass HammerModule {\n}\nHammerModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].NgModule });\nHammerModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerModule });\nHammerModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerModule, providers: [\n        {\n            provide: EVENT_MANAGER_PLUGINS,\n            useClass: HammerGesturesPlugin,\n            multi: true,\n            deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵConsole\"], [new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional(), HAMMER_LOADER]]\n        },\n        { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] },\n    ] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HammerModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,\n            args: [{\n                    providers: [\n                        {\n                            provide: EVENT_MANAGER_PLUGINS,\n                            useClass: HammerGesturesPlugin,\n                            multi: true,\n                            deps: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, HAMMER_GESTURE_CONFIG, _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵConsole\"], [new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional(), HAMMER_LOADER]]\n                        },\n                        { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig, deps: [] },\n                    ]\n                }]\n        }] });\n\n/**\n * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing\n * values to be safe to use in the different DOM contexts.\n *\n * For example, when binding a URL in an `<a [href]=\"someValue\">` hyperlink, `someValue` will be\n * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on\n * the website.\n *\n * In specific situations, it might be necessary to disable sanitization, for example if the\n * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.\n * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`\n * methods, and then binding to that value from the template.\n *\n * These situations should be very rare, and extraordinary care must be taken to avoid creating a\n * Cross Site Scripting (XSS) security bug!\n *\n * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as\n * close as possible to the source of the value, to make it easy to verify no security bug is\n * created by its use.\n *\n * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that\n * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous\n * code. The sanitizer leaves safe values intact.\n *\n * @security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in\n * sanitization for the value passed in. Carefully check and audit all values and code paths going\n * into this call. Make sure any user data is appropriately escaped for this security context.\n * For more detail, see the [Security Guide](https://g.co/ng/security).\n *\n * @publicApi\n */\nclass DomSanitizer {\n}\nDomSanitizer.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizer, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nDomSanitizer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizer, providedIn: 'root', useExisting: _angular_core__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function () { return DomSanitizerImpl; }) });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizer, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root', useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(() => DomSanitizerImpl) }]\n        }] });\nfunction domSanitizerImplFactory(injector) {\n    return new DomSanitizerImpl(injector.get(_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT));\n}\nclass DomSanitizerImpl extends DomSanitizer {\n    constructor(_doc) {\n        super();\n        this._doc = _doc;\n    }\n    sanitize(ctx, value) {\n        if (value == null)\n            return null;\n        switch (ctx) {\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.NONE:\n                return value;\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.HTML:\n                if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵallowSanitizationBypassAndThrow\"])(value, \"HTML\" /* BypassType.Html */)) {\n                    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵunwrapSafeValue\"])(value);\n                }\n                return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵ_sanitizeHtml\"])(this._doc, String(value)).toString();\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.STYLE:\n                if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵallowSanitizationBypassAndThrow\"])(value, \"Style\" /* BypassType.Style */)) {\n                    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵunwrapSafeValue\"])(value);\n                }\n                return value;\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.SCRIPT:\n                if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵallowSanitizationBypassAndThrow\"])(value, \"Script\" /* BypassType.Script */)) {\n                    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵunwrapSafeValue\"])(value);\n                }\n                throw new Error('unsafe value used in a script context');\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.URL:\n                if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵallowSanitizationBypassAndThrow\"])(value, \"URL\" /* BypassType.Url */)) {\n                    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵunwrapSafeValue\"])(value);\n                }\n                return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵ_sanitizeUrl\"])(String(value));\n            case _angular_core__WEBPACK_IMPORTED_MODULE_1__.SecurityContext.RESOURCE_URL:\n                if ((0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵallowSanitizationBypassAndThrow\"])(value, \"ResourceURL\" /* BypassType.ResourceUrl */)) {\n                    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵunwrapSafeValue\"])(value);\n                }\n                throw new Error(`unsafe value used in a resource URL context (see ${_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵXSS_SECURITY_URL\"]})`);\n            default:\n                throw new Error(`Unexpected SecurityContext ${ctx} (see ${_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵXSS_SECURITY_URL\"]})`);\n        }\n    }\n    bypassSecurityTrustHtml(value) {\n        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵbypassSanitizationTrustHtml\"])(value);\n    }\n    bypassSecurityTrustStyle(value) {\n        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵbypassSanitizationTrustStyle\"])(value);\n    }\n    bypassSecurityTrustScript(value) {\n        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵbypassSanitizationTrustScript\"])(value);\n    }\n    bypassSecurityTrustUrl(value) {\n        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵbypassSanitizationTrustUrl\"])(value);\n    }\n    bypassSecurityTrustResourceUrl(value) {\n        return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵbypassSanitizationTrustResourceUrl\"])(value);\n    }\n}\nDomSanitizerImpl.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizerImpl, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nDomSanitizerImpl.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizerImpl, providedIn: 'root', useFactory: domSanitizerImplFactory, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector }] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.7\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: DomSanitizerImpl, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root', useFactory: domSanitizerImplFactory, deps: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.Injector] }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the platform-browser package.\n */\n/**\n * @publicApi\n */\nconst VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.Version('15.2.7');\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform-browser.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9mZXNtMjAyMC9wbGF0Zm9ybS1icm93c2VyLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9mZXNtMjAyMC9wbGF0Zm9ybS1icm93c2VyLm1qcz8wYjNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2MTUuMi43XG4gKiAoYykgMjAxMC0yMDIyIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCB7IMm1RG9tQWRhcHRlciwgybVzZXRSb290RG9tQWRhcHRlciwgybVwYXJzZUNvb2tpZVZhbHVlLCDJtWdldERPTSwgRE9DVU1FTlQsIMm1UExBVEZPUk1fQlJPV1NFUl9JRCwgWGhyRmFjdG9yeSwgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmV4cG9ydCB7IMm1Z2V0RE9NIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIEFwcGxpY2F0aW9uSW5pdFN0YXR1cywgQVBQX0lOSVRJQUxJWkVSLCBJbmplY3RvciwgybVnbG9iYWwsIEluamVjdGFibGUsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb24sIEFQUF9JRCwgUmVuZGVyZXJTdHlsZUZsYWdzMiwgybVpbnRlcm5hbENyZWF0ZUFwcGxpY2F0aW9uLCBFcnJvckhhbmRsZXIsIMm1c2V0RG9jdW1lbnQsIFBMQVRGT1JNX0lELCBQTEFURk9STV9JTklUSUFMSVpFUiwgY3JlYXRlUGxhdGZvcm1GYWN0b3J5LCBwbGF0Zm9ybUNvcmUsIMm1VEVTVEFCSUxJVFlfR0VUVEVSLCDJtVRFU1RBQklMSVRZLCBUZXN0YWJpbGl0eSwgTmdab25lLCBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCDJtUlOSkVDVE9SX1NDT1BFLCBSZW5kZXJlckZhY3RvcnkyLCBBcHBsaWNhdGlvbk1vZHVsZSwgTmdNb2R1bGUsIE9wdGlvbmFsLCBTa2lwU2VsZiwgybXJtWluamVjdCwgQXBwbGljYXRpb25SZWYsIGluamVjdCwgybVDb25zb2xlLCBmb3J3YXJkUmVmLCDJtVhTU19TRUNVUklUWV9VUkwsIFNlY3VyaXR5Q29udGV4dCwgybVhbGxvd1Nhbml0aXphdGlvbkJ5cGFzc0FuZFRocm93LCDJtXVud3JhcFNhZmVWYWx1ZSwgybVfc2FuaXRpemVVcmwsIMm1X3Nhbml0aXplSHRtbCwgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdEh0bWwsIMm1YnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTdHlsZSwgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdFNjcmlwdCwgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdFVybCwgybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdFJlc291cmNlVXJsLCBWZXJzaW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogUHJvdmlkZXMgRE9NIG9wZXJhdGlvbnMgaW4gYW55IGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gKlxuICogQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICovXG5jbGFzcyBHZW5lcmljQnJvd3NlckRvbUFkYXB0ZXIgZXh0ZW5kcyDJtURvbUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN1cHBvcnRzRE9NRXZlbnRzID0gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBgRG9tQWRhcHRlcmAgcG93ZXJlZCBieSBmdWxsIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHNlY3VyaXR5IFRyZWFkIGNhcmVmdWxseSEgSW50ZXJhY3Rpbmcgd2l0aCB0aGUgRE9NIGRpcmVjdGx5IGlzIGRhbmdlcm91cyBhbmRcbiAqIGNhbiBpbnRyb2R1Y2UgWFNTIHJpc2tzLlxuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZTpyZXF1aXJlUGFyYW1ldGVyVHlwZSBuby1jb25zb2xlICovXG5jbGFzcyBCcm93c2VyRG9tQWRhcHRlciBleHRlbmRzIEdlbmVyaWNCcm93c2VyRG9tQWRhcHRlciB7XG4gICAgc3RhdGljIG1ha2VDdXJyZW50KCkge1xuICAgICAgICDJtXNldFJvb3REb21BZGFwdGVyKG5ldyBCcm93c2VyRG9tQWRhcHRlcigpKTtcbiAgICB9XG4gICAgb25BbmRDYW5jZWwoZWwsIGV2dCwgbGlzdGVuZXIpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgIC8vIE5lZWRlZCB0byBmb2xsb3cgRGFydCdzIHN1YnNjcmlwdGlvbiBzZW1hbnRpYywgdW50aWwgZml4IG9mXG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZGFydC9pc3N1ZXMvZGV0YWlsP2lkPTE3NDA2XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGlzcGF0Y2hFdmVudChlbCwgZXZ0KSB7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9XG4gICAgcmVtb3ZlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgZG9jKSB7XG4gICAgICAgIGRvYyA9IGRvYyB8fCB0aGlzLmdldERlZmF1bHREb2N1bWVudCgpO1xuICAgICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgfVxuICAgIGNyZWF0ZUh0bWxEb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnZmFrZVRpdGxlJyk7XG4gICAgfVxuICAgIGdldERlZmF1bHREb2N1bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xuICAgIH1cbiAgICBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCBObyBsb25nZXIgYmVpbmcgdXNlZCBpbiBJdnkgY29kZS4gVG8gYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDE0LiAqL1xuICAgIGdldEdsb2JhbEV2ZW50VGFyZ2V0KGRvYywgdGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICd3aW5kb3cnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgPT09ICdkb2N1bWVudCcpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEJhc2VIcmVmKGRvYykge1xuICAgICAgICBjb25zdCBocmVmID0gZ2V0QmFzZUVsZW1lbnRIcmVmKCk7XG4gICAgICAgIHJldHVybiBocmVmID09IG51bGwgPyBudWxsIDogcmVsYXRpdmVQYXRoKGhyZWYpO1xuICAgIH1cbiAgICByZXNldEJhc2VFbGVtZW50KCkge1xuICAgICAgICBiYXNlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIGdldFVzZXJBZ2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIH1cbiAgICBnZXRDb29raWUobmFtZSkge1xuICAgICAgICByZXR1cm4gybVwYXJzZUNvb2tpZVZhbHVlKGRvY3VtZW50LmNvb2tpZSwgbmFtZSk7XG4gICAgfVxufVxubGV0IGJhc2VFbGVtZW50ID0gbnVsbDtcbmZ1bmN0aW9uIGdldEJhc2VFbGVtZW50SHJlZigpIHtcbiAgICBiYXNlRWxlbWVudCA9IGJhc2VFbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICByZXR1cm4gYmFzZUVsZW1lbnQgPyBiYXNlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSA6IG51bGw7XG59XG4vLyBiYXNlZCBvbiB1cmxVdGlscy5qcyBpbiBBbmd1bGFySlMgMVxubGV0IHVybFBhcnNpbmdOb2RlO1xuZnVuY3Rpb24gcmVsYXRpdmVQYXRoKHVybCkge1xuICAgIHVybFBhcnNpbmdOb2RlID0gdXJsUGFyc2luZ05vZGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XG4gICAgY29uc3QgcGF0aE5hbWUgPSB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZTtcbiAgICByZXR1cm4gcGF0aE5hbWUuY2hhckF0KDApID09PSAnLycgPyBwYXRoTmFtZSA6IGAvJHtwYXRoTmFtZX1gO1xufVxuXG4vKipcbiAqIEFuIGlkIHRoYXQgaWRlbnRpZmllcyBhIHBhcnRpY3VsYXIgYXBwbGljYXRpb24gYmVpbmcgYm9vdHN0cmFwcGVkLCB0aGF0IHNob3VsZFxuICogbWF0Y2ggYWNyb3NzIHRoZSBjbGllbnQvc2VydmVyIGJvdW5kYXJ5LlxuICovXG5jb25zdCBUUkFOU0lUSU9OX0lEID0gbmV3IEluamVjdGlvblRva2VuKCdUUkFOU0lUSU9OX0lEJyk7XG5mdW5jdGlvbiBhcHBJbml0aWFsaXplckZhY3RvcnkodHJhbnNpdGlvbklkLCBkb2N1bWVudCwgaW5qZWN0b3IpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAvLyBXYWl0IGZvciBhbGwgYXBwbGljYXRpb24gaW5pdGlhbGl6ZXJzIHRvIGJlIGNvbXBsZXRlZCBiZWZvcmUgcmVtb3ZpbmcgdGhlIHN0eWxlcyBzZXQgYnlcbiAgICAgICAgLy8gdGhlIHNlcnZlci5cbiAgICAgICAgaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uSW5pdFN0YXR1cykuZG9uZVByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb20gPSDJtWdldERPTSgpO1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgc3R5bGVbbmctdHJhbnNpdGlvbj1cIiR7dHJhbnNpdGlvbklkfVwiXWApO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlKHN0eWxlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jb25zdCBTRVJWRVJfVFJBTlNJVElPTl9QUk9WSURFUlMgPSBbXG4gICAge1xuICAgICAgICBwcm92aWRlOiBBUFBfSU5JVElBTElaRVIsXG4gICAgICAgIHVzZUZhY3Rvcnk6IGFwcEluaXRpYWxpemVyRmFjdG9yeSxcbiAgICAgICAgZGVwczogW1RSQU5TSVRJT05fSUQsIERPQ1VNRU5ULCBJbmplY3Rvcl0sXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfSxcbl07XG5cbmNsYXNzIEJyb3dzZXJHZXRUZXN0YWJpbGl0eSB7XG4gICAgYWRkVG9XaW5kb3cocmVnaXN0cnkpIHtcbiAgICAgICAgybVnbG9iYWxbJ2dldEFuZ3VsYXJUZXN0YWJpbGl0eSddID0gKGVsZW0sIGZpbmRJbkFuY2VzdG9ycyA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RhYmlsaXR5ID0gcmVnaXN0cnkuZmluZFRlc3RhYmlsaXR5SW5UcmVlKGVsZW0sIGZpbmRJbkFuY2VzdG9ycyk7XG4gICAgICAgICAgICBpZiAodGVzdGFiaWxpdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgdGVzdGFiaWxpdHkgZm9yIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGVzdGFiaWxpdHk7XG4gICAgICAgIH07XG4gICAgICAgIMm1Z2xvYmFsWydnZXRBbGxBbmd1bGFyVGVzdGFiaWxpdGllcyddID0gKCkgPT4gcmVnaXN0cnkuZ2V0QWxsVGVzdGFiaWxpdGllcygpO1xuICAgICAgICDJtWdsb2JhbFsnZ2V0QWxsQW5ndWxhclJvb3RFbGVtZW50cyddID0gKCkgPT4gcmVnaXN0cnkuZ2V0QWxsUm9vdEVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHdoZW5BbGxTdGFibGUgPSAoY2FsbGJhY2sgLyoqIFRPRE8gIzkxMDAgKi8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RhYmlsaXRpZXMgPSDJtWdsb2JhbFsnZ2V0QWxsQW5ndWxhclRlc3RhYmlsaXRpZXMnXSgpO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGVzdGFiaWxpdGllcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZGlkV29yayA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZGVjcmVtZW50ID0gZnVuY3Rpb24gKGRpZFdvcmtfIC8qKiBUT0RPICM5MTAwICovKSB7XG4gICAgICAgICAgICAgICAgZGlkV29yayA9IGRpZFdvcmsgfHwgZGlkV29ya187XG4gICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkaWRXb3JrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGVzdGFiaWxpdGllcy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXN0YWJpbGl0eSAvKiogVE9ETyAjOTEwMCAqLykge1xuICAgICAgICAgICAgICAgIHRlc3RhYmlsaXR5LndoZW5TdGFibGUoZGVjcmVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIcm1Z2xvYmFsWydmcmFtZXdvcmtTdGFiaWxpemVycyddKSB7XG4gICAgICAgICAgICDJtWdsb2JhbFsnZnJhbWV3b3JrU3RhYmlsaXplcnMnXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIMm1Z2xvYmFsWydmcmFtZXdvcmtTdGFiaWxpemVycyddLnB1c2god2hlbkFsbFN0YWJsZSk7XG4gICAgfVxuICAgIGZpbmRUZXN0YWJpbGl0eUluVHJlZShyZWdpc3RyeSwgZWxlbSwgZmluZEluQW5jZXN0b3JzKSB7XG4gICAgICAgIGlmIChlbGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSByZWdpc3RyeS5nZXRUZXN0YWJpbGl0eShlbGVtKTtcbiAgICAgICAgaWYgKHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZpbmRJbkFuY2VzdG9ycykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKMm1Z2V0RE9NKCkuaXNTaGFkb3dSb290KGVsZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVzdGFiaWxpdHlJblRyZWUocmVnaXN0cnksIGVsZW0uaG9zdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFRlc3RhYmlsaXR5SW5UcmVlKHJlZ2lzdHJ5LCBlbGVtLnBhcmVudEVsZW1lbnQsIHRydWUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGBIdHRwWGhyQmFja2VuZGAgdGhhdCB1c2VzIHRoZSBgWE1MSHR0cFJlcXVlc3RgIGJyb3dzZXIgQVBJLlxuICovXG5jbGFzcyBCcm93c2VyWGhyIHtcbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbn1cbkJyb3dzZXJYaHIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3NlclhociwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkJyb3dzZXJYaHIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJyb3dzZXJYaHIgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3NlclhociwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogVGhlIGluamVjdGlvbiB0b2tlbiBmb3IgdGhlIGV2ZW50LW1hbmFnZXIgcGx1Zy1pbiBzZXJ2aWNlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgRVZFTlRfTUFOQUdFUl9QTFVHSU5TID0gbmV3IEluamVjdGlvblRva2VuKCdFdmVudE1hbmFnZXJQbHVnaW5zJyk7XG4vKipcbiAqIEFuIGluamVjdGFibGUgc2VydmljZSB0aGF0IHByb3ZpZGVzIGV2ZW50IG1hbmFnZW1lbnQgZm9yIEFuZ3VsYXJcbiAqIHRocm91Z2ggYSBicm93c2VyIHBsdWctaW4uXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBFdmVudE1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIGluc3RhbmNlIG9mIHRoZSBldmVudC1tYW5hZ2VyIHNlcnZpY2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGx1Z2lucywgX3pvbmUpIHtcbiAgICAgICAgdGhpcy5fem9uZSA9IF96b25lO1xuICAgICAgICB0aGlzLl9ldmVudE5hbWVUb1BsdWdpbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHtcbiAgICAgICAgICAgIHBsdWdpbi5tYW5hZ2VyID0gdGhpcztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBoYW5kbGVyIGZvciBhIHNwZWNpZmljIGVsZW1lbnQgYW5kIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIEhUTUwgZWxlbWVudCB0byByZWNlaXZlIGV2ZW50IG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciBBIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgbm90aWZpY2F0aW9uIG9jY3Vycy4gUmVjZWl2ZXMgdGhlXG4gICAgICogZXZlbnQgb2JqZWN0IGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbiA9IHRoaXMuX2ZpbmRQbHVnaW5Gb3IoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbi5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGdsb2JhbCBoYW5kbGVyIGZvciBhbiBldmVudCBpbiBhIHRhcmdldCB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldCBBIHRhcmdldCBmb3IgZ2xvYmFsIGV2ZW50IG5vdGlmaWNhdGlvbnMuIE9uZSBvZiBcIndpbmRvd1wiLCBcImRvY3VtZW50XCIsIG9yIFwiYm9keVwiLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIGhhbmRsZXIgQSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIG5vdGlmaWNhdGlvbiBvY2N1cnMuIFJlY2VpdmVzIHRoZVxuICAgICAqIGV2ZW50IG9iamVjdCBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJucyBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBoYW5kbGVyLlxuICAgICAqIEBkZXByZWNhdGVkIE5vIGxvbmdlciBiZWluZyB1c2VkIGluIEl2eSBjb2RlLiBUbyBiZSByZW1vdmVkIGluIHZlcnNpb24gMTQuXG4gICAgICovXG4gICAgYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSB0aGlzLl9maW5kUGx1Z2luRm9yKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiBwbHVnaW4uYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY29tcGlsYXRpb24gem9uZSBpbiB3aGljaCBldmVudCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQuXG4gICAgICovXG4gICAgZ2V0Wm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmluZFBsdWdpbkZvcihldmVudE5hbWUpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5fZXZlbnROYW1lVG9QbHVnaW4uZ2V0KGV2ZW50TmFtZSk7XG4gICAgICAgIGlmIChwbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwbHVnaW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgICAgIGlmIChwbHVnaW4uc3VwcG9ydHMoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TmFtZVRvUGx1Z2luLnNldChldmVudE5hbWUsIHBsdWdpbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGV2ZW50IG1hbmFnZXIgcGx1Z2luIGZvdW5kIGZvciBldmVudCAke2V2ZW50TmFtZX1gKTtcbiAgICB9XG59XG5FdmVudE1hbmFnZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRXZlbnRNYW5hZ2VyLCBkZXBzOiBbeyB0b2tlbjogRVZFTlRfTUFOQUdFUl9QTFVHSU5TIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRXZlbnRNYW5hZ2VyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBFdmVudE1hbmFnZXIgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRXZlbnRNYW5hZ2VyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRVZFTlRfTUFOQUdFUl9QTFVHSU5TXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogaTAuTmdab25lIH1dOyB9IH0pO1xuY2xhc3MgRXZlbnRNYW5hZ2VyUGx1Z2luIHtcbiAgICBjb25zdHJ1Y3RvcihfZG9jKSB7XG4gICAgICAgIHRoaXMuX2RvYyA9IF9kb2M7XG4gICAgfVxuICAgIGFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IMm1Z2V0RE9NKCkuZ2V0R2xvYmFsRXZlbnRUYXJnZXQodGhpcy5fZG9jLCBlbGVtZW50KTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZXZlbnQgdGFyZ2V0ICR7dGFyZ2V0fSBmb3IgZXZlbnQgJHtldmVudE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxufVxuXG5jbGFzcyBTaGFyZWRTdHlsZXNIb3N0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy51c2FnZUNvdW50ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhZGRTdHlsZXMoc3R5bGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1c2FnZUNvdW50ID0gdGhpcy5jaGFuZ2VVc2FnZUNvdW50KHN0eWxlLCAxKTtcbiAgICAgICAgICAgIGlmICh1c2FnZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0eWxlQWRkZWQoc3R5bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVN0eWxlcyhzdHlsZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiBzdHlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzYWdlQ291bnQgPSB0aGlzLmNoYW5nZVVzYWdlQ291bnQoc3R5bGUsIC0xKTtcbiAgICAgICAgICAgIGlmICh1c2FnZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0eWxlUmVtb3ZlZChzdHlsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TdHlsZVJlbW92ZWQoc3R5bGUpIHsgfVxuICAgIG9uU3R5bGVBZGRlZChzdHlsZSkgeyB9XG4gICAgZ2V0QWxsU3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51c2FnZUNvdW50LmtleXMoKTtcbiAgICB9XG4gICAgY2hhbmdlVXNhZ2VDb3VudChzdHlsZSwgZGVsdGEpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy51c2FnZUNvdW50O1xuICAgICAgICBsZXQgdXNhZ2UgPSBtYXAuZ2V0KHN0eWxlKSA/PyAwO1xuICAgICAgICB1c2FnZSArPSBkZWx0YTtcbiAgICAgICAgaWYgKHVzYWdlID4gMCkge1xuICAgICAgICAgICAgbWFwLnNldChzdHlsZSwgdXNhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFwLmRlbGV0ZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVzYWdlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiB0aGlzLmdldEFsbFN0eWxlcygpKSB7XG4gICAgICAgICAgICB0aGlzLm9uU3R5bGVSZW1vdmVkKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzYWdlQ291bnQuY2xlYXIoKTtcbiAgICB9XG59XG5TaGFyZWRTdHlsZXNIb3N0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNoYXJlZFN0eWxlc0hvc3QsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5TaGFyZWRTdHlsZXNIb3N0Lsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBTaGFyZWRTdHlsZXNIb3N0IH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNoYXJlZFN0eWxlc0hvc3QsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlXG4gICAgICAgIH1dIH0pO1xuY2xhc3MgRG9tU2hhcmVkU3R5bGVzSG9zdCBleHRlbmRzIFNoYXJlZFN0eWxlc0hvc3Qge1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgLy8gTWFwcyBhbGwgcmVnaXN0ZXJlZCBob3N0IG5vZGVzIHRvIGEgbGlzdCBvZiBzdHlsZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaG9zdCBub2RlLlxuICAgICAgICB0aGlzLnN0eWxlUmVmID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhvc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5yZXNldEhvc3ROb2RlcygpO1xuICAgIH1cbiAgICBvblN0eWxlQWRkZWQoc3R5bGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBob3N0IG9mIHRoaXMuaG9zdE5vZGVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFN0eWxlVG9Ib3N0KGhvc3QsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblN0eWxlUmVtb3ZlZChzdHlsZSkge1xuICAgICAgICBjb25zdCBzdHlsZVJlZiA9IHRoaXMuc3R5bGVSZWY7XG4gICAgICAgIGNvbnN0IHN0eWxlRWxlbWVudHMgPSBzdHlsZVJlZi5nZXQoc3R5bGUpO1xuICAgICAgICBzdHlsZUVsZW1lbnRzPy5mb3JFYWNoKGUgPT4gZS5yZW1vdmUoKSk7XG4gICAgICAgIHN0eWxlUmVmLmRlbGV0ZShzdHlsZSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0eWxlUmVmLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVzZXRIb3N0Tm9kZXMoKTtcbiAgICB9XG4gICAgYWRkSG9zdChob3N0Tm9kZSkge1xuICAgICAgICB0aGlzLmhvc3ROb2Rlcy5hZGQoaG9zdE5vZGUpO1xuICAgICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIHRoaXMuZ2V0QWxsU3R5bGVzKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU3R5bGVUb0hvc3QoaG9zdE5vZGUsIHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVIb3N0KGhvc3ROb2RlKSB7XG4gICAgICAgIHRoaXMuaG9zdE5vZGVzLmRlbGV0ZShob3N0Tm9kZSk7XG4gICAgfVxuICAgIGFkZFN0eWxlVG9Ib3N0KGhvc3QsIHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlRWwgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZUVsLnRleHRDb250ZW50ID0gc3R5bGU7XG4gICAgICAgIGhvc3QuYXBwZW5kQ2hpbGQoc3R5bGVFbCk7XG4gICAgICAgIGNvbnN0IHN0eWxlRWxSZWYgPSB0aGlzLnN0eWxlUmVmLmdldChzdHlsZSk7XG4gICAgICAgIGlmIChzdHlsZUVsUmVmKSB7XG4gICAgICAgICAgICBzdHlsZUVsUmVmLnB1c2goc3R5bGVFbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlUmVmLnNldChzdHlsZSwgW3N0eWxlRWxdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEhvc3ROb2RlcygpIHtcbiAgICAgICAgY29uc3QgaG9zdE5vZGVzID0gdGhpcy5ob3N0Tm9kZXM7XG4gICAgICAgIGhvc3ROb2Rlcy5jbGVhcigpO1xuICAgICAgICAvLyBSZS1hZGQgdGhlIGhlYWQgZWxlbWVudCBiYWNrIHNpbmNlIHRoaXMgaXMgdGhlIGRlZmF1bHQgaG9zdC5cbiAgICAgICAgaG9zdE5vZGVzLmFkZCh0aGlzLmRvYy5oZWFkKTtcbiAgICB9XG59XG5Eb21TaGFyZWRTdHlsZXNIb3N0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERvbVNoYXJlZFN0eWxlc0hvc3QsIGRlcHM6IFt7IHRva2VuOiBET0NVTUVOVCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRG9tU2hhcmVkU3R5bGVzSG9zdC7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tU2hhcmVkU3R5bGVzSG9zdCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21TaGFyZWRTdHlsZXNIb3N0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbmNvbnN0IE5BTUVTUEFDRV9VUklTID0ge1xuICAgICdzdmcnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4aHRtbCc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgICAneGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICAgJ3htbCc6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuICAgICd4bWxucyc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycsXG4gICAgJ21hdGgnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoTUwvJyxcbn07XG5jb25zdCBDT01QT05FTlRfUkVHRVggPSAvJUNPTVAlL2c7XG5jb25zdCBOR19ERVZfTU9ERSQxID0gdHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgISFuZ0Rldk1vZGU7XG5jb25zdCBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbmNvbnN0IEhPU1RfQVRUUiA9IGBfbmdob3N0LSR7Q09NUE9ORU5UX1ZBUklBQkxFfWA7XG5jb25zdCBDT05URU5UX0FUVFIgPSBgX25nY29udGVudC0ke0NPTVBPTkVOVF9WQVJJQUJMRX1gO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGBSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZYCBESSB0b2tlbi5cbiAqL1xuY29uc3QgUkVNT1ZFX1NUWUxFU19PTl9DT01QT05FTlRfREVTVFJPWV9ERUZBVUxUID0gZmFsc2U7XG4vKipcbiAqIEEgW0RJIHRva2VuXShndWlkZS9nbG9zc2FyeSNkaS10b2tlbiBcIkRJIHRva2VuIGRlZmluaXRpb25cIikgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBzdHlsZXNcbiAqIG9mIGRlc3Ryb3llZCBjb21wb25lbnRzIHNob3VsZCBiZSByZW1vdmVkIGZyb20gRE9NLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSBpcyBzZXQgdG8gYGZhbHNlYC4gVGhpcyB3aWxsIGJlIGNoYW5nZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgUkVNT1ZFX1NUWUxFU19PTl9DT01QT05FTlRfREVTVFJPWSA9IG5ldyBJbmplY3Rpb25Ub2tlbignUmVtb3ZlU3R5bGVzT25Db21wRGVzdG9yeScsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogKCkgPT4gUkVNT1ZFX1NUWUxFU19PTl9DT01QT05FTlRfREVTVFJPWV9ERUZBVUxULFxufSk7XG5mdW5jdGlvbiBzaGltQ29udGVudEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkKSB7XG4gICAgcmV0dXJuIENPTlRFTlRfQVRUUi5yZXBsYWNlKENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50U2hvcnRJZCk7XG59XG5mdW5jdGlvbiBzaGltSG9zdEF0dHJpYnV0ZShjb21wb25lbnRTaG9ydElkKSB7XG4gICAgcmV0dXJuIEhPU1RfQVRUUi5yZXBsYWNlKENPTVBPTkVOVF9SRUdFWCwgY29tcG9uZW50U2hvcnRJZCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuU3R5bGVzKGNvbXBJZCwgc3R5bGVzKSB7XG4gICAgLy8gQ2Fubm90IHVzZSBgSW5maW5pdHlgIGFzIGRlcHRoIGFzIGBpbmZpbml0eWAgaXMgbm90IGEgbnVtYmVyIGxpdGVyYWwgaW4gVHlwZVNjcmlwdC5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzIyNzdcbiAgICByZXR1cm4gc3R5bGVzLmZsYXQoMTAwKS5tYXAocyA9PiBzLnJlcGxhY2UoQ09NUE9ORU5UX1JFR0VYLCBjb21wSWQpKTtcbn1cbmZ1bmN0aW9uIGRlY29yYXRlUHJldmVudERlZmF1bHQoZXZlbnRIYW5kbGVyKSB7XG4gICAgLy8gYERlYnVnTm9kZS50cmlnZ2VyRXZlbnRIYW5kbGVyYCBuZWVkcyB0byBrbm93IGlmIHRoZSBsaXN0ZW5lciB3YXMgY3JlYXRlZCB3aXRoXG4gICAgLy8gZGVjb3JhdGVQcmV2ZW50RGVmYXVsdCBvciBpcyBhIGxpc3RlbmVyIGFkZGVkIG91dHNpZGUgdGhlIEFuZ3VsYXIgY29udGV4dCBzbyBpdCBjYW4gaGFuZGxlIHRoZVxuICAgIC8vIHR3byBkaWZmZXJlbnRseS4gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBzcGVjaWFsICdfX25nVW53cmFwX18nIHRva2VuIGlzIHBhc3NlZCB0byB0aGUgdW53cmFwXG4gICAgLy8gdGhlIGxpc3RlbmVyIChzZWUgYmVsb3cpLlxuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gSXZ5IHVzZXMgJ19fbmdVbndyYXBfXycgYXMgYSBzcGVjaWFsIHRva2VuIHRoYXQgYWxsb3dzIHVzIHRvIHVud3JhcCB0aGUgZnVuY3Rpb25cbiAgICAgICAgLy8gc28gdGhhdCBpdCBjYW4gYmUgaW52b2tlZCBwcm9ncmFtbWF0aWNhbGx5IGJ5IGBEZWJ1Z05vZGUudHJpZ2dlckV2ZW50SGFuZGxlcmAuIFRoZSBkZWJ1Z19ub2RlXG4gICAgICAgIC8vIGNhbiBpbnNwZWN0IHRoZSBsaXN0ZW5lciB0b1N0cmluZyBjb250ZW50cyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGlzIHNwZWNpYWwgdG9rZW4uIEJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHRva2VuIGlzIGEgc3RyaW5nIGxpdGVyYWwsIGl0IGlzIGVuc3VyZWQgdG8gbm90IGJlIG1vZGlmaWVkIGJ5IGNvbXBpbGVkIGNvZGUuXG4gICAgICAgIGlmIChldmVudCA9PT0gJ19fbmdVbndyYXBfXycpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudEhhbmRsZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsb3dEZWZhdWx0QmVoYXZpb3IgPSBldmVudEhhbmRsZXIoZXZlbnQpO1xuICAgICAgICBpZiAoYWxsb3dEZWZhdWx0QmVoYXZpb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHRib3NjaCk6IG1vdmUgcHJldmVudERlZmF1bHQgaW50byBldmVudCBwbHVnaW5zLi4uXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5jbGFzcyBEb21SZW5kZXJlckZhY3RvcnkyIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGFwcElkLCByZW1vdmVTdHlsZXNPbkNvbXBEZXN0b3J5KSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QgPSBzaGFyZWRTdHlsZXNIb3N0O1xuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgICAgIHRoaXMucmVtb3ZlU3R5bGVzT25Db21wRGVzdG9yeSA9IHJlbW92ZVN0eWxlc09uQ29tcERlc3Rvcnk7XG4gICAgICAgIHRoaXMucmVuZGVyZXJCeUNvbXBJZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0UmVuZGVyZXIgPSBuZXcgRGVmYXVsdERvbVJlbmRlcmVyMihldmVudE1hbmFnZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSZW5kZXJlcihlbGVtZW50LCB0eXBlKSB7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdFJlbmRlcmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gdGhpcy5nZXRPckNyZWF0ZVJlbmRlcmVyKGVsZW1lbnQsIHR5cGUpO1xuICAgICAgICAvLyBSZW5kZXJlcnMgaGF2ZSBkaWZmZXJlbnQgbG9naWMgZHVlIHRvIGRpZmZlcmVudCBlbmNhcHN1bGF0aW9uIGJlaGF2aW91cnMuXG4gICAgICAgIC8vIEV4OiBmb3IgZW11bGF0ZWQsIGFuIGF0dHJpYnV0ZSBpcyBhZGRlZCB0byB0aGUgZWxlbWVudC5cbiAgICAgICAgaWYgKHJlbmRlcmVyIGluc3RhbmNlb2YgRW11bGF0ZWRFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5hcHBseVRvSG9zdChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW5kZXJlciBpbnN0YW5jZW9mIE5vbmVFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmFwcGx5U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyO1xuICAgIH1cbiAgICBnZXRPckNyZWF0ZVJlbmRlcmVyKGVsZW1lbnQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZXJCeUNvbXBJZCA9IHRoaXMucmVuZGVyZXJCeUNvbXBJZDtcbiAgICAgICAgbGV0IHJlbmRlcmVyID0gcmVuZGVyZXJCeUNvbXBJZC5nZXQodHlwZS5pZCk7XG4gICAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU3R5bGVzSG9zdCA9IHRoaXMuc2hhcmVkU3R5bGVzSG9zdDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZVN0eWxlc09uQ29tcERlc3RvcnkgPSB0aGlzLnJlbW92ZVN0eWxlc09uQ29tcERlc3Rvcnk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuZW5jYXBzdWxhdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQ6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IEVtdWxhdGVkRW5jYXBzdWxhdGlvbkRvbVJlbmRlcmVyMihldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIHR5cGUsIHRoaXMuYXBwSWQsIHJlbW92ZVN0eWxlc09uQ29tcERlc3RvcnkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFZpZXdFbmNhcHN1bGF0aW9uLlNoYWRvd0RvbTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaGFkb3dEb21SZW5kZXJlcihldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGVsZW1lbnQsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IE5vbmVFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIoZXZlbnRNYW5hZ2VyLCBzaGFyZWRTdHlsZXNIb3N0LCB0eXBlLCByZW1vdmVTdHlsZXNPbkNvbXBEZXN0b3J5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlci5vbkRlc3Ryb3kgPSAoKSA9PiByZW5kZXJlckJ5Q29tcElkLmRlbGV0ZSh0eXBlLmlkKTtcbiAgICAgICAgICAgIHJlbmRlcmVyQnlDb21wSWQuc2V0KHR5cGUuaWQsIHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyQnlDb21wSWQuY2xlYXIoKTtcbiAgICB9XG4gICAgYmVnaW4oKSB7IH1cbiAgICBlbmQoKSB7IH1cbn1cbkRvbVJlbmRlcmVyRmFjdG9yeTIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tUmVuZGVyZXJGYWN0b3J5MiwgZGVwczogW3sgdG9rZW46IEV2ZW50TWFuYWdlciB9LCB7IHRva2VuOiBEb21TaGFyZWRTdHlsZXNIb3N0IH0sIHsgdG9rZW46IEFQUF9JRCB9LCB7IHRva2VuOiBSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5Eb21SZW5kZXJlckZhY3RvcnkyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21SZW5kZXJlckZhY3RvcnkyIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERvbVJlbmRlcmVyRmFjdG9yeTIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogRXZlbnRNYW5hZ2VyIH0sIHsgdHlwZTogRG9tU2hhcmVkU3R5bGVzSG9zdCB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQVBQX0lEXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuY2xhc3MgRGVmYXVsdERvbVJlbmRlcmVyMiB7XG4gICAgY29uc3RydWN0b3IoZXZlbnRNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xuICAgICAgICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLmRlc3Ryb3lOb2RlID0gbnVsbDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxuICAgIGNyZWF0ZUVsZW1lbnQobmFtZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGB8fCBuYW1lc3BhY2VgIHdhcyBhZGRlZCBpblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9jb21taXQvMmI5Y2M4NTAzZDQ4MTczNDkyYzI5ZjVhMjcxYjYxMTI2MTA0ZmJkYiB0b1xuICAgICAgICAgICAgLy8gc3VwcG9ydCBob3cgSXZ5IHBhc3NlZCBhcm91bmQgdGhlIG5hbWVzcGFjZSBVUkkgcmF0aGVyIHRoYW4gc2hvcnQgbmFtZSBhdCB0aGUgdGltZS4gSXQgZGlkXG4gICAgICAgICAgICAvLyBub3QsIGhvd2V2ZXIgZXh0ZW5kIHRoZSBzdXBwb3J0IHRvIG90aGVyIHBhcnRzIG9mIHRoZSBzeXN0ZW0gKHNldEF0dHJpYnV0ZSwgc2V0QXR0cmlidXRlLFxuICAgICAgICAgICAgLy8gYW5kIHRoZSBTZXJ2ZXJSZW5kZXJlcikuIFdlIHNob3VsZCBkZWNpZGUgd2hhdCBleGFjdGx5IHRoZSBzZW1hbnRpY3MgZm9yIGRlYWxpbmcgd2l0aFxuICAgICAgICAgICAgLy8gbmFtZXNwYWNlcyBzaG91bGQgYmUgYW5kIG1ha2UgaXQgY29uc2lzdGVudC5cbiAgICAgICAgICAgIC8vIFJlbGF0ZWQgaXNzdWVzOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNDQwMjhcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQ0ODgzXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKE5BTUVTUEFDRV9VUklTW25hbWVzcGFjZV0gfHwgbmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICB9XG4gICAgY3JlYXRlQ29tbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh2YWx1ZSk7XG4gICAgfVxuICAgIGNyZWF0ZVRleHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdDaGlsZCkge1xuICAgICAgICBjb25zdCB0YXJnZXRQYXJlbnQgPSBpc1RlbXBsYXRlTm9kZShwYXJlbnQpID8gcGFyZW50LmNvbnRlbnQgOiBwYXJlbnQ7XG4gICAgICAgIHRhcmdldFBhcmVudC5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgfVxuICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5ld0NoaWxkLCByZWZDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQYXJlbnQgPSBpc1RlbXBsYXRlTm9kZShwYXJlbnQpID8gcGFyZW50LmNvbnRlbnQgOiBwYXJlbnQ7XG4gICAgICAgICAgICB0YXJnZXRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0NoaWxkLCByZWZDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBvbGRDaGlsZCkge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQob2xkQ2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFJvb3RFbGVtZW50KHNlbGVjdG9yT3JOb2RlLCBwcmVzZXJ2ZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGVsID0gdHlwZW9mIHNlbGVjdG9yT3JOb2RlID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JPck5vZGUpIDpcbiAgICAgICAgICAgIHNlbGVjdG9yT3JOb2RlO1xuICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZWxlY3RvciBcIiR7c2VsZWN0b3JPck5vZGV9XCIgZGlkIG5vdCBtYXRjaCBhbnkgZWxlbWVudHNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZXNlcnZlQ29udGVudCkge1xuICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIHBhcmVudE5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBuZXh0U2libGluZyhub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVzcGFjZSArICc6JyArIG5hbWU7XG4gICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VVcmkgPSBOQU1FU1BBQ0VfVVJJU1tuYW1lc3BhY2VdO1xuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZVVyaSkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZVVyaSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQXR0cmlidXRlKGVsLCBuYW1lLCBuYW1lc3BhY2UpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlVXJpID0gTkFNRVNQQUNFX1VSSVNbbmFtZXNwYWNlXTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2VVcmkpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVcmksIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGAke25hbWVzcGFjZX06JHtuYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENsYXNzKGVsLCBuYW1lKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgfVxuICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgfVxuICAgIHNldFN0eWxlKGVsLCBzdHlsZSwgdmFsdWUsIGZsYWdzKSB7XG4gICAgICAgIGlmIChmbGFncyAmIChSZW5kZXJlclN0eWxlRmxhZ3MyLkRhc2hDYXNlIHwgUmVuZGVyZXJTdHlsZUZsYWdzMi5JbXBvcnRhbnQpKSB7XG4gICAgICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZSwgdmFsdWUsIGZsYWdzICYgUmVuZGVyZXJTdHlsZUZsYWdzMi5JbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlW3N0eWxlXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVN0eWxlKGVsLCBzdHlsZSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKGZsYWdzICYgUmVuZGVyZXJTdHlsZUZsYWdzMi5EYXNoQ2FzZSkge1xuICAgICAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSUUgcmVxdWlyZXMgJycgaW5zdGVhZCBvZiBudWxsXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNzkxNlxuICAgICAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJvcGVydHkoZWwsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIE5HX0RFVl9NT0RFJDEgJiYgY2hlY2tOb1N5bnRoZXRpY1Byb3AobmFtZSwgJ3Byb3BlcnR5Jyk7XG4gICAgICAgIGVsW25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGxpc3Rlbih0YXJnZXQsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBOR19ERVZfTU9ERSQxICYmIGNoZWNrTm9TeW50aGV0aWNQcm9wKGV2ZW50LCAnbGlzdGVuZXInKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBkZWNvcmF0ZVByZXZlbnREZWZhdWx0KGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudCwgZGVjb3JhdGVQcmV2ZW50RGVmYXVsdChjYWxsYmFjaykpO1xuICAgIH1cbn1cbmNvbnN0IEFUX0NIQVJDT0RFID0gKCgpID0+ICdAJy5jaGFyQ29kZUF0KDApKSgpO1xuZnVuY3Rpb24gY2hlY2tOb1N5bnRoZXRpY1Byb3AobmFtZSwgbmFtZUtpbmQpIHtcbiAgICBpZiAobmFtZS5jaGFyQ29kZUF0KDApID09PSBBVF9DSEFSQ09ERSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3ludGhldGljICR7bmFtZUtpbmR9ICR7bmFtZX0gZm91bmQuIFBsZWFzZSBtYWtlIHN1cmUgdGhhdDpcbiAgLSBFaXRoZXIgXFxgQnJvd3NlckFuaW1hdGlvbnNNb2R1bGVcXGAgb3IgXFxgTm9vcEFuaW1hdGlvbnNNb2R1bGVcXGAgYXJlIGltcG9ydGVkIGluIHlvdXIgYXBwbGljYXRpb24uXG4gIC0gVGhlcmUgaXMgY29ycmVzcG9uZGluZyBjb25maWd1cmF0aW9uIGZvciB0aGUgYW5pbWF0aW9uIG5hbWVkIFxcYCR7bmFtZX1cXGAgZGVmaW5lZCBpbiB0aGUgXFxgYW5pbWF0aW9uc1xcYCBmaWVsZCBvZiB0aGUgXFxgQENvbXBvbmVudFxcYCBkZWNvcmF0b3IgKHNlZSBodHRwczovL2FuZ3VsYXIuaW8vYXBpL2NvcmUvQ29tcG9uZW50I2FuaW1hdGlvbnMpLmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVGVtcGxhdGVOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnVEVNUExBVEUnICYmIG5vZGUuY29udGVudCAhPT0gdW5kZWZpbmVkO1xufVxuY2xhc3MgU2hhZG93RG9tUmVuZGVyZXIgZXh0ZW5kcyBEZWZhdWx0RG9tUmVuZGVyZXIyIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudE1hbmFnZXIsIHNoYXJlZFN0eWxlc0hvc3QsIGhvc3RFbCwgY29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGV2ZW50TWFuYWdlcik7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdCA9IHNoYXJlZFN0eWxlc0hvc3Q7XG4gICAgICAgIHRoaXMuaG9zdEVsID0gaG9zdEVsO1xuICAgICAgICB0aGlzLnNoYWRvd1Jvb3QgPSBob3N0RWwuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB0aGlzLnNoYXJlZFN0eWxlc0hvc3QuYWRkSG9zdCh0aGlzLnNoYWRvd1Jvb3QpO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSBmbGF0dGVuU3R5bGVzKGNvbXBvbmVudC5pZCwgY29tcG9uZW50LnN0eWxlcyk7XG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlRWwudGV4dENvbnRlbnQgPSBzdHlsZTtcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChzdHlsZUVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlT3JTaGFkb3dSb290KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IHRoaXMuaG9zdEVsID8gdGhpcy5zaGFkb3dSb290IDogbm9kZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdDaGlsZCkge1xuICAgICAgICByZXR1cm4gc3VwZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2RlT3JTaGFkb3dSb290KHBhcmVudCksIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbmV3Q2hpbGQsIHJlZkNoaWxkKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRCZWZvcmUodGhpcy5ub2RlT3JTaGFkb3dSb290KHBhcmVudCksIG5ld0NoaWxkLCByZWZDaGlsZCk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgb2xkQ2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnJlbW92ZUNoaWxkKHRoaXMubm9kZU9yU2hhZG93Um9vdChwYXJlbnQpLCBvbGRDaGlsZCk7XG4gICAgfVxuICAgIHBhcmVudE5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlT3JTaGFkb3dSb290KHN1cGVyLnBhcmVudE5vZGUodGhpcy5ub2RlT3JTaGFkb3dSb290KG5vZGUpKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVIb3N0KHRoaXMuc2hhZG93Um9vdCk7XG4gICAgfVxufVxuY2xhc3MgTm9uZUVuY2Fwc3VsYXRpb25Eb21SZW5kZXJlciBleHRlbmRzIERlZmF1bHREb21SZW5kZXJlcjIge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgY29tcG9uZW50LCByZW1vdmVTdHlsZXNPbkNvbXBEZXN0b3J5LCBjb21wSWQgPSBjb21wb25lbnQuaWQpIHtcbiAgICAgICAgc3VwZXIoZXZlbnRNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5zaGFyZWRTdHlsZXNIb3N0ID0gc2hhcmVkU3R5bGVzSG9zdDtcbiAgICAgICAgdGhpcy5yZW1vdmVTdHlsZXNPbkNvbXBEZXN0b3J5ID0gcmVtb3ZlU3R5bGVzT25Db21wRGVzdG9yeTtcbiAgICAgICAgdGhpcy5yZW5kZXJlclVzYWdlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IGZsYXR0ZW5TdHlsZXMoY29tcElkLCBjb21wb25lbnQuc3R5bGVzKTtcbiAgICB9XG4gICAgYXBwbHlTdHlsZXMoKSB7XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5hZGRTdHlsZXModGhpcy5zdHlsZXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyVXNhZ2VDb3VudCsrO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVtb3ZlU3R5bGVzT25Db21wRGVzdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hhcmVkU3R5bGVzSG9zdC5yZW1vdmVTdHlsZXModGhpcy5zdHlsZXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyVXNhZ2VDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJlclVzYWdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub25EZXN0cm95Py4oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVtdWxhdGVkRW5jYXBzdWxhdGlvbkRvbVJlbmRlcmVyMiBleHRlbmRzIE5vbmVFbmNhcHN1bGF0aW9uRG9tUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50TWFuYWdlciwgc2hhcmVkU3R5bGVzSG9zdCwgY29tcG9uZW50LCBhcHBJZCwgcmVtb3ZlU3R5bGVzT25Db21wRGVzdG9yeSkge1xuICAgICAgICBjb25zdCBjb21wSWQgPSBhcHBJZCArICctJyArIGNvbXBvbmVudC5pZDtcbiAgICAgICAgc3VwZXIoZXZlbnRNYW5hZ2VyLCBzaGFyZWRTdHlsZXNIb3N0LCBjb21wb25lbnQsIHJlbW92ZVN0eWxlc09uQ29tcERlc3RvcnksIGNvbXBJZCk7XG4gICAgICAgIHRoaXMuY29udGVudEF0dHIgPSBzaGltQ29udGVudEF0dHJpYnV0ZShjb21wSWQpO1xuICAgICAgICB0aGlzLmhvc3RBdHRyID0gc2hpbUhvc3RBdHRyaWJ1dGUoY29tcElkKTtcbiAgICB9XG4gICAgYXBwbHlUb0hvc3QoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmFwcGx5U3R5bGVzKCk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGVsZW1lbnQsIHRoaXMuaG9zdEF0dHIsICcnKTtcbiAgICB9XG4gICAgY3JlYXRlRWxlbWVudChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgY29uc3QgZWwgPSBzdXBlci5jcmVhdGVFbGVtZW50KHBhcmVudCwgbmFtZSk7XG4gICAgICAgIHN1cGVyLnNldEF0dHJpYnV0ZShlbCwgdGhpcy5jb250ZW50QXR0ciwgJycpO1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgfVxufVxuXG5jbGFzcyBEb21FdmVudHNQbHVnaW4gZXh0ZW5kcyBFdmVudE1hbmFnZXJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKGRvYykge1xuICAgICAgICBzdXBlcihkb2MpO1xuICAgIH1cbiAgICAvLyBUaGlzIHBsdWdpbiBzaG91bGQgY29tZSBsYXN0IGluIHRoZSBsaXN0IG9mIHBsdWdpbnMsIGJlY2F1c2UgaXQgYWNjZXB0cyBhbGxcbiAgICAvLyBldmVudHMuXG4gICAgc3VwcG9ydHMoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbn1cbkRvbUV2ZW50c1BsdWdpbi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21FdmVudHNQbHVnaW4sIGRlcHM6IFt7IHRva2VuOiBET0NVTUVOVCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRG9tRXZlbnRzUGx1Z2luLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21FdmVudHNQbHVnaW4gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tRXZlbnRzUGx1Z2luLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogRGVmaW5lcyBzdXBwb3J0ZWQgbW9kaWZpZXJzIGZvciBrZXkgZXZlbnRzLlxuICovXG5jb25zdCBNT0RJRklFUl9LRVlTID0gWydhbHQnLCAnY29udHJvbCcsICdtZXRhJywgJ3NoaWZ0J107XG4vLyBUaGUgZm9sbG93aW5nIHZhbHVlcyBhcmUgaGVyZSBmb3IgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5IGFuZCB0byBtYXRjaCB0aGUgVzNDIHN0YW5kYXJkXG4vLyBjZiBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLWtleS9cbmNvbnN0IF9rZXlNYXAgPSB7XG4gICAgJ1xcYic6ICdCYWNrc3BhY2UnLFxuICAgICdcXHQnOiAnVGFiJyxcbiAgICAnXFx4N0YnOiAnRGVsZXRlJyxcbiAgICAnXFx4MUInOiAnRXNjYXBlJyxcbiAgICAnRGVsJzogJ0RlbGV0ZScsXG4gICAgJ0VzYyc6ICdFc2NhcGUnLFxuICAgICdMZWZ0JzogJ0Fycm93TGVmdCcsXG4gICAgJ1JpZ2h0JzogJ0Fycm93UmlnaHQnLFxuICAgICdVcCc6ICdBcnJvd1VwJyxcbiAgICAnRG93bic6ICdBcnJvd0Rvd24nLFxuICAgICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAgICdXaW4nOiAnT1MnXG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgbW9kaWZpZXJzIGZyb20ga2V5LWV2ZW50IG9iamVjdHMuXG4gKi9cbmNvbnN0IE1PRElGSUVSX0tFWV9HRVRURVJTID0ge1xuICAgICdhbHQnOiAoZXZlbnQpID0+IGV2ZW50LmFsdEtleSxcbiAgICAnY29udHJvbCc6IChldmVudCkgPT4gZXZlbnQuY3RybEtleSxcbiAgICAnbWV0YSc6IChldmVudCkgPT4gZXZlbnQubWV0YUtleSxcbiAgICAnc2hpZnQnOiAoZXZlbnQpID0+IGV2ZW50LnNoaWZ0S2V5XG59O1xuLyoqXG4gKiBAcHVibGljQXBpXG4gKiBBIGJyb3dzZXIgcGx1Zy1pbiB0aGF0IHByb3ZpZGVzIHN1cHBvcnQgZm9yIGhhbmRsaW5nIG9mIGtleSBldmVudHMgaW4gQW5ndWxhci5cbiAqL1xuY2xhc3MgS2V5RXZlbnRzUGx1Z2luIGV4dGVuZHMgRXZlbnRNYW5hZ2VyUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBpbnN0YW5jZSBvZiB0aGUgYnJvd3NlciBwbHVnLWluLlxuICAgICAqIEBwYXJhbSBkb2MgVGhlIGRvY3VtZW50IGluIHdoaWNoIGtleSBldmVudHMgd2lsbCBiZSBkZXRlY3RlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihkb2MpIHtcbiAgICAgICAgc3VwZXIoZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIGEgbmFtZWQga2V5IGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgbmFtZWQga2V5IGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBzdXBwb3J0cyhldmVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEtleUV2ZW50c1BsdWdpbi5wYXJzZUV2ZW50TmFtZShldmVudE5hbWUpICE9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGhhbmRsZXIgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCBhbmQga2V5IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBIVE1MIGVsZW1lbnQgdG8gcmVjZWl2ZSBldmVudCBub3RpZmljYXRpb25zLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleSBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIEEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBub3RpZmljYXRpb24gb2NjdXJzLiBSZWNlaXZlcyB0aGVcbiAgICAgKiBldmVudCBvYmplY3QgYXMgYW4gYXJndW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIGtleSBldmVudCB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gS2V5RXZlbnRzUGx1Z2luLnBhcnNlRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IG91dHNpZGVIYW5kbGVyID0gS2V5RXZlbnRzUGx1Z2luLmV2ZW50Q2FsbGJhY2socGFyc2VkRXZlbnRbJ2Z1bGxLZXknXSwgaGFuZGxlciwgdGhpcy5tYW5hZ2VyLmdldFpvbmUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuZ2V0Wm9uZSgpLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiDJtWdldERPTSgpLm9uQW5kQ2FuY2VsKGVsZW1lbnQsIHBhcnNlZEV2ZW50Wydkb21FdmVudE5hbWUnXSwgb3V0c2lkZUhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSB1c2VyIHByb3ZpZGVkIGZ1bGwga2V5Ym9hcmQgZXZlbnQgZGVmaW5pdGlvbiBhbmQgbm9ybWFsaXplcyBpdCBmb3JcbiAgICAgKiBsYXRlciBpbnRlcm5hbCB1c2UuIEl0IGVuc3VyZXMgdGhlIHN0cmluZyBpcyBhbGwgbG93ZXJjYXNlLCBjb252ZXJ0cyBzcGVjaWFsXG4gICAgICogY2hhcmFjdGVycyB0byBhIHN0YW5kYXJkIHNwZWxsaW5nLCBhbmQgb3JkZXJzIGFsbCB0aGUgdmFsdWVzIGNvbnNpc3RlbnRseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleSBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmdWxsLCBub3JtYWxpemVkIHN0cmluZywgYW5kIHRoZSBkb20gZXZlbnQgbmFtZVxuICAgICAqIG9yIG51bGwgaW4gdGhlIGNhc2Ugd2hlbiB0aGUgZXZlbnQgZG9lc24ndCBtYXRjaCBhIGtleWJvYXJkIGV2ZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCBkb21FdmVudE5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoKHBhcnRzLmxlbmd0aCA9PT0gMCkgfHwgIShkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBLZXlFdmVudHNQbHVnaW4uX25vcm1hbGl6ZUtleShwYXJ0cy5wb3AoKSk7XG4gICAgICAgIGxldCBmdWxsS2V5ID0gJyc7XG4gICAgICAgIGxldCBjb2RlSVggPSBwYXJ0cy5pbmRleE9mKCdjb2RlJyk7XG4gICAgICAgIGlmIChjb2RlSVggPiAtMSkge1xuICAgICAgICAgICAgcGFydHMuc3BsaWNlKGNvZGVJWCwgMSk7XG4gICAgICAgICAgICBmdWxsS2V5ID0gJ2NvZGUuJztcbiAgICAgICAgfVxuICAgICAgICBNT0RJRklFUl9LRVlTLmZvckVhY2gobW9kaWZpZXJOYW1lID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFydHMuaW5kZXhPZihtb2RpZmllck5hbWUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGZ1bGxLZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVsbEtleSArPSBrZXk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT0gMCB8fCBrZXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgbnVsbCBpbnN0ZWFkIG9mIHRocm93aW5nIHRvIGxldCBhbm90aGVyIHBsdWdpbiBwcm9jZXNzIHRoZSBldmVudFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogUGxlYXNlIGRvbid0IHJld3JpdGUgdGhpcyBhcyBzbywgYXMgaXQgd2lsbCBicmVhayBKU0NvbXBpbGVyIHByb3BlcnR5IHJlbmFtaW5nLlxuICAgICAgICAvLyAgICAgICBUaGUgY29kZSBtdXN0IHJlbWFpbiBpbiB0aGUgYHJlc3VsdFsnZG9tRXZlbnROYW1lJ11gIGZvcm0uXG4gICAgICAgIC8vIHJldHVybiB7ZG9tRXZlbnROYW1lLCBmdWxsS2V5fTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIHJlc3VsdFsnZG9tRXZlbnROYW1lJ10gPSBkb21FdmVudE5hbWU7XG4gICAgICAgIHJlc3VsdFsnZnVsbEtleSddID0gZnVsbEtleTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBhY3R1YWwga2V5cyBwcmVzc2VkIG1hdGNoIHRoZSBjb25maWd1cmVkIGtleSBjb2RlIHN0cmluZy5cbiAgICAgKiBUaGUgYGZ1bGxLZXlDb2RlYCBldmVudCBpcyBub3JtYWxpemVkIGluIHRoZSBgcGFyc2VFdmVudE5hbWVgIG1ldGhvZCB3aGVuIHRoZVxuICAgICAqIGV2ZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00gZHVyaW5nIHRoZSBgYWRkRXZlbnRMaXN0ZW5lcmAgY2FsbC4gVGhpcyBpcyB1bnNlZW5cbiAgICAgKiBieSB0aGUgZW5kIHVzZXIgYW5kIGlzIG5vcm1hbGl6ZWQgZm9yIGludGVybmFsIGNvbnNpc3RlbmN5IGFuZCBwYXJzaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cbiAgICAgKiBAcGFyYW0gZnVsbEtleUNvZGUgVGhlIG5vcm1hbGl6ZWQgdXNlciBkZWZpbmVkIGV4cGVjdGVkIGtleSBldmVudCBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyBib29sZWFuLlxuICAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEV2ZW50RnVsbEtleUNvZGUoZXZlbnQsIGZ1bGxLZXlDb2RlKSB7XG4gICAgICAgIGxldCBrZXljb2RlID0gX2tleU1hcFtldmVudC5rZXldIHx8IGV2ZW50LmtleTtcbiAgICAgICAgbGV0IGtleSA9ICcnO1xuICAgICAgICBpZiAoZnVsbEtleUNvZGUuaW5kZXhPZignY29kZS4nKSA+IC0xKSB7XG4gICAgICAgICAgICBrZXljb2RlID0gZXZlbnQuY29kZTtcbiAgICAgICAgICAgIGtleSA9ICdjb2RlLic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGtleWNvZGUgY291bGQgYmUgdW5pZGVudGlmaWVkIHNvIHdlIGhhdmUgdG8gY2hlY2sgaGVyZVxuICAgICAgICBpZiAoa2V5Y29kZSA9PSBudWxsIHx8ICFrZXljb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBrZXljb2RlID0ga2V5Y29kZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoa2V5Y29kZSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBrZXljb2RlID0gJ3NwYWNlJzsgLy8gZm9yIHJlYWRhYmlsaXR5XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5Y29kZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBrZXljb2RlID0gJ2RvdCc7IC8vIGJlY2F1c2UgJy4nIGlzIHVzZWQgYXMgYSBzZXBhcmF0b3IgaW4gZXZlbnQgbmFtZXNcbiAgICAgICAgfVxuICAgICAgICBNT0RJRklFUl9LRVlTLmZvckVhY2gobW9kaWZpZXJOYW1lID0+IHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllck5hbWUgIT09IGtleWNvZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllckdldHRlciA9IE1PRElGSUVSX0tFWV9HRVRURVJTW21vZGlmaWVyTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVyR2V0dGVyKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgKz0gbW9kaWZpZXJOYW1lICsgJy4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGtleSArPSBrZXljb2RlO1xuICAgICAgICByZXR1cm4ga2V5ID09PSBmdWxsS2V5Q29kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyBhIGhhbmRsZXIgY2FsbGJhY2sgZm9yIGEga2V5IGV2ZW50LlxuICAgICAqIEBwYXJhbSBmdWxsS2V5IFRoZSBldmVudCBuYW1lIHRoYXQgY29tYmluZXMgYWxsIHNpbXVsdGFuZW91cyBrZXlzdHJva2VzLlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBmdW5jdGlvbiB0aGF0IHJlc3BvbmRzIHRvIHRoZSBrZXkgZXZlbnQuXG4gICAgICogQHBhcmFtIHpvbmUgVGhlIHpvbmUgaW4gd2hpY2ggdGhlIGV2ZW50IG9jY3VycmVkLlxuICAgICAqIEByZXR1cm5zIEEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGV2ZW50Q2FsbGJhY2soZnVsbEtleSwgaGFuZGxlciwgem9uZSkge1xuICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoS2V5RXZlbnRzUGx1Z2luLm1hdGNoRXZlbnRGdWxsS2V5Q29kZShldmVudCwgZnVsbEtleSkpIHtcbiAgICAgICAgICAgICAgICB6b25lLnJ1bkd1YXJkZWQoKCkgPT4gaGFuZGxlcihldmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIF9ub3JtYWxpemVLZXkoa2V5TmFtZSkge1xuICAgICAgICAvLyBUT0RPOiBzd2l0Y2ggdG8gYSBNYXAgaWYgdGhlIG1hcHBpbmcgZ3Jvd3MgdG9vIG11Y2hcbiAgICAgICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdlc2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiAnZXNjYXBlJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleU5hbWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5LZXlFdmVudHNQbHVnaW4uybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogS2V5RXZlbnRzUGx1Z2luLCBkZXBzOiBbeyB0b2tlbjogRE9DVU1FTlQgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbktleUV2ZW50c1BsdWdpbi7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogS2V5RXZlbnRzUGx1Z2luIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEtleUV2ZW50c1BsdWdpbiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuXG5jb25zdCBOR19ERVZfTU9ERSA9IHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8ICEhbmdEZXZNb2RlO1xuLyoqXG4gKiBCb290c3RyYXBzIGFuIGluc3RhbmNlIG9mIGFuIEFuZ3VsYXIgYXBwbGljYXRpb24gYW5kIHJlbmRlcnMgYSBzdGFuZGFsb25lIGNvbXBvbmVudCBhcyB0aGVcbiAqIGFwcGxpY2F0aW9uJ3Mgcm9vdCBjb21wb25lbnQuIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgc3RhbmRhbG9uZSBjb21wb25lbnRzIGNhbiBiZSBmb3VuZCBpbiBbdGhpc1xuICogZ3VpZGVdKGd1aWRlL3N0YW5kYWxvbmUtY29tcG9uZW50cykuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqIFRoZSByb290IGNvbXBvbmVudCBwYXNzZWQgaW50byB0aGlzIGZ1bmN0aW9uICptdXN0KiBiZSBhIHN0YW5kYWxvbmUgb25lIChzaG91bGQgaGF2ZSB0aGVcbiAqIGBzdGFuZGFsb25lOiB0cnVlYCBmbGFnIGluIHRoZSBgQENvbXBvbmVudGAgZGVjb3JhdG9yIGNvbmZpZykuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQENvbXBvbmVudCh7XG4gKiAgIHN0YW5kYWxvbmU6IHRydWUsXG4gKiAgIHRlbXBsYXRlOiAnSGVsbG8gd29ybGQhJ1xuICogfSlcbiAqIGNsYXNzIFJvb3RDb21wb25lbnQge31cbiAqXG4gKiBjb25zdCBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmID0gYXdhaXQgYm9vdHN0cmFwQXBwbGljYXRpb24oUm9vdENvbXBvbmVudCk7XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGFkZCB0aGUgbGlzdCBvZiBwcm92aWRlcnMgdGhhdCBzaG91bGQgYmUgYXZhaWxhYmxlIGluIHRoZSBhcHBsaWNhdGlvbiBpbmplY3RvciBieVxuICogc3BlY2lmeWluZyB0aGUgYHByb3ZpZGVyc2AgZmllbGQgaW4gYW4gb2JqZWN0IHBhc3NlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50OlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGF3YWl0IGJvb3RzdHJhcEFwcGxpY2F0aW9uKFJvb3RDb21wb25lbnQsIHtcbiAqICAgcHJvdmlkZXJzOiBbXG4gKiAgICAge3Byb3ZpZGU6IEJBQ0tFTkRfVVJMLCB1c2VWYWx1ZTogJ2h0dHBzOi8veW91cmRvbWFpbi5jb20vYXBpJ31cbiAqICAgXVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBUaGUgYGltcG9ydFByb3ZpZGVyc0Zyb21gIGhlbHBlciBtZXRob2QgY2FuIGJlIHVzZWQgdG8gY29sbGVjdCBhbGwgcHJvdmlkZXJzIGZyb20gYW55XG4gKiBleGlzdGluZyBOZ01vZHVsZSAoYW5kIHRyYW5zaXRpdmVseSBmcm9tIGFsbCBOZ01vZHVsZXMgdGhhdCBpdCBpbXBvcnRzKTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBhd2FpdCBib290c3RyYXBBcHBsaWNhdGlvbihSb290Q29tcG9uZW50LCB7XG4gKiAgIHByb3ZpZGVyczogW1xuICogICAgIGltcG9ydFByb3ZpZGVyc0Zyb20oU29tZU5nTW9kdWxlKVxuICogICBdXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE5vdGU6IHRoZSBgYm9vdHN0cmFwQXBwbGljYXRpb25gIG1ldGhvZCBkb2Vzbid0IGluY2x1ZGUgW1Rlc3RhYmlsaXR5XShhcGkvY29yZS9UZXN0YWJpbGl0eSkgYnlcbiAqIGRlZmF1bHQuIFlvdSBjYW4gYWRkIFtUZXN0YWJpbGl0eV0oYXBpL2NvcmUvVGVzdGFiaWxpdHkpIGJ5IGdldHRpbmcgdGhlIGxpc3Qgb2YgbmVjZXNzYXJ5XG4gKiBwcm92aWRlcnMgdXNpbmcgYHByb3ZpZGVQcm90cmFjdG9yVGVzdGluZ1N1cHBvcnQoKWAgZnVuY3Rpb24gYW5kIGFkZGluZyB0aGVtIGludG8gdGhlIGBwcm92aWRlcnNgXG4gKiBhcnJheSwgZm9yIGV4YW1wbGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHtwcm92aWRlUHJvdHJhY3RvclRlc3RpbmdTdXBwb3J0fSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqXG4gKiBhd2FpdCBib290c3RyYXBBcHBsaWNhdGlvbihSb290Q29tcG9uZW50LCB7cHJvdmlkZXJzOiBbcHJvdmlkZVByb3RyYWN0b3JUZXN0aW5nU3VwcG9ydCgpXX0pO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHJvb3RDb21wb25lbnQgQSByZWZlcmVuY2UgdG8gYSBzdGFuZGFsb25lIGNvbXBvbmVudCB0aGF0IHNob3VsZCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBvcHRpb25zIEV4dHJhIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBib290c3RyYXAgb3BlcmF0aW9uLCBzZWUgYEFwcGxpY2F0aW9uQ29uZmlnYCBmb3JcbiAqICAgICBhZGRpdGlvbmFsIGluZm8uXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXR1cm5zIGFuIGBBcHBsaWNhdGlvblJlZmAgaW5zdGFuY2Ugb25jZSByZXNvbHZlZC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGJvb3RzdHJhcEFwcGxpY2F0aW9uKHJvb3RDb21wb25lbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gybVpbnRlcm5hbENyZWF0ZUFwcGxpY2F0aW9uKHsgcm9vdENvbXBvbmVudCwgLi4uY3JlYXRlUHJvdmlkZXJzQ29uZmlnKG9wdGlvbnMpIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYW4gQW5ndWxhciBhcHBsaWNhdGlvbiB3aXRob3V0IGJvb3RzdHJhcHBpbmcgYW55IGNvbXBvbmVudHMuIFRoaXMgaXMgdXNlZnVsXG4gKiBmb3IgdGhlIHNpdHVhdGlvbiB3aGVyZSBvbmUgd2FudHMgdG8gZGVjb3VwbGUgYXBwbGljYXRpb24gZW52aXJvbm1lbnQgY3JlYXRpb24gKGEgcGxhdGZvcm0gYW5kXG4gKiBhc3NvY2lhdGVkIGluamVjdG9ycykgZnJvbSByZW5kZXJpbmcgY29tcG9uZW50cyBvbiBhIHNjcmVlbi4gQ29tcG9uZW50cyBjYW4gYmUgc3Vic2VxdWVudGx5XG4gKiBib290c3RyYXBwZWQgb24gdGhlIHJldHVybmVkIGBBcHBsaWNhdGlvblJlZmAuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgRXh0cmEgY29uZmlndXJhdGlvbiBmb3IgdGhlIGFwcGxpY2F0aW9uIGVudmlyb25tZW50LCBzZWUgYEFwcGxpY2F0aW9uQ29uZmlnYCBmb3JcbiAqICAgICBhZGRpdGlvbmFsIGluZm8uXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXR1cm5zIGFuIGBBcHBsaWNhdGlvblJlZmAgaW5zdGFuY2Ugb25jZSByZXNvbHZlZC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFwcGxpY2F0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gybVpbnRlcm5hbENyZWF0ZUFwcGxpY2F0aW9uKGNyZWF0ZVByb3ZpZGVyc0NvbmZpZyhvcHRpb25zKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlcnNDb25maWcob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFwcFByb3ZpZGVyczogW1xuICAgICAgICAgICAgLi4uQlJPV1NFUl9NT0RVTEVfUFJPVklERVJTLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LnByb3ZpZGVycyA/PyBbXSksXG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtUHJvdmlkZXJzOiBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSU1xuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgYSBzZXQgb2YgcHJvdmlkZXJzIHJlcXVpcmVkIHRvIHNldHVwIFtUZXN0YWJpbGl0eV0oYXBpL2NvcmUvVGVzdGFiaWxpdHkpIGZvciBhblxuICogYXBwbGljYXRpb24gYm9vdHN0cmFwcGVkIHVzaW5nIHRoZSBgYm9vdHN0cmFwQXBwbGljYXRpb25gIGZ1bmN0aW9uLiBUaGUgc2V0IG9mIHByb3ZpZGVycyBpc1xuICogbmVlZGVkIHRvIHN1cHBvcnQgdGVzdGluZyBhbiBhcHBsaWNhdGlvbiB3aXRoIFByb3RyYWN0b3IgKHdoaWNoIHJlbGllcyBvbiB0aGUgVGVzdGFiaWxpdHkgQVBJc1xuICogdG8gYmUgcHJlc2VudCkuXG4gKlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgcHJvdmlkZXJzIHJlcXVpcmVkIHRvIHNldHVwIFRlc3RhYmlsaXR5IGZvciBhbiBhcHBsaWNhdGlvbiBhbmQgbWFrZSBpdFxuICogICAgIGF2YWlsYWJsZSBmb3IgdGVzdGluZyB1c2luZyBQcm90cmFjdG9yLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuZnVuY3Rpb24gcHJvdmlkZVByb3RyYWN0b3JUZXN0aW5nU3VwcG9ydCgpIHtcbiAgICAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgYXJyYXkgaW4gY2FzZSBhbnkgaW4tcGxhY2VcbiAgICAvLyBhbHRlcmF0aW9ucyBhcmUgcGVyZm9ybWVkIHRvIHRoZSBgcHJvdmlkZVByb3RyYWN0b3JUZXN0aW5nU3VwcG9ydGAgY2FsbCByZXN1bHRzIGluIGFwcCBjb2RlLlxuICAgIHJldHVybiBbLi4uVEVTVEFCSUxJVFlfUFJPVklERVJTXTtcbn1cbmZ1bmN0aW9uIGluaXREb21BZGFwdGVyKCkge1xuICAgIEJyb3dzZXJEb21BZGFwdGVyLm1ha2VDdXJyZW50KCk7XG59XG5mdW5jdGlvbiBlcnJvckhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvckhhbmRsZXIoKTtcbn1cbmZ1bmN0aW9uIF9kb2N1bWVudCgpIHtcbiAgICAvLyBUZWxsIGl2eSBhYm91dCB0aGUgZ2xvYmFsIGRvY3VtZW50XG4gICAgybVzZXREb2N1bWVudChkb2N1bWVudCk7XG4gICAgcmV0dXJuIGRvY3VtZW50O1xufVxuY29uc3QgSU5URVJOQUxfQlJPV1NFUl9QTEFURk9STV9QUk9WSURFUlMgPSBbXG4gICAgeyBwcm92aWRlOiBQTEFURk9STV9JRCwgdXNlVmFsdWU6IMm1UExBVEZPUk1fQlJPV1NFUl9JRCB9LFxuICAgIHsgcHJvdmlkZTogUExBVEZPUk1fSU5JVElBTElaRVIsIHVzZVZhbHVlOiBpbml0RG9tQWRhcHRlciwgbXVsdGk6IHRydWUgfSxcbiAgICB7IHByb3ZpZGU6IERPQ1VNRU5ULCB1c2VGYWN0b3J5OiBfZG9jdW1lbnQsIGRlcHM6IFtdIH0sXG5dO1xuLyoqXG4gKiBBIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYFBsYXRmb3JtUmVmYCBpbnN0YW5jZSBhc3NvY2lhdGVkIHdpdGggYnJvd3NlciBzZXJ2aWNlXG4gKiBwcm92aWRlcnMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBwbGF0Zm9ybUJyb3dzZXIgPSBjcmVhdGVQbGF0Zm9ybUZhY3RvcnkocGxhdGZvcm1Db3JlLCAnYnJvd3NlcicsIElOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTKTtcbi8qKlxuICogSW50ZXJuYWwgbWFya2VyIHRvIHNpZ25hbCB3aGV0aGVyIHByb3ZpZGVycyBmcm9tIHRoZSBgQnJvd3Nlck1vZHVsZWAgYXJlIGFscmVhZHkgcHJlc2VudCBpbiBESS5cbiAqIFRoaXMgaXMgbmVlZGVkIHRvIGF2b2lkIGxvYWRpbmcgYEJyb3dzZXJNb2R1bGVgIHByb3ZpZGVycyB0d2ljZS4gV2UgY2FuJ3QgcmVseSBvbiB0aGVcbiAqIGBCcm93c2VyTW9kdWxlYCBwcmVzZW5jZSBpdHNlbGYsIHNpbmNlIHRoZSBzdGFuZGFsb25lLWJhc2VkIGJvb3RzdHJhcCBqdXN0IGltcG9ydHNcbiAqIGBCcm93c2VyTW9kdWxlYCBwcm92aWRlcnMgd2l0aG91dCByZWZlcmVuY2luZyB0aGUgbW9kdWxlIGl0c2VsZi5cbiAqL1xuY29uc3QgQlJPV1NFUl9NT0RVTEVfUFJPVklERVJTX01BUktFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbihOR19ERVZfTU9ERSA/ICdCcm93c2VyTW9kdWxlIFByb3ZpZGVycyBNYXJrZXInIDogJycpO1xuY29uc3QgVEVTVEFCSUxJVFlfUFJPVklERVJTID0gW1xuICAgIHtcbiAgICAgICAgcHJvdmlkZTogybVURVNUQUJJTElUWV9HRVRURVIsXG4gICAgICAgIHVzZUNsYXNzOiBCcm93c2VyR2V0VGVzdGFiaWxpdHksXG4gICAgICAgIGRlcHM6IFtdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiDJtVRFU1RBQklMSVRZLFxuICAgICAgICB1c2VDbGFzczogVGVzdGFiaWxpdHksXG4gICAgICAgIGRlcHM6IFtOZ1pvbmUsIFRlc3RhYmlsaXR5UmVnaXN0cnksIMm1VEVTVEFCSUxJVFlfR0VUVEVSXVxuICAgIH0sXG4gICAge1xuICAgICAgICBwcm92aWRlOiBUZXN0YWJpbGl0eSxcbiAgICAgICAgdXNlQ2xhc3M6IFRlc3RhYmlsaXR5LFxuICAgICAgICBkZXBzOiBbTmdab25lLCBUZXN0YWJpbGl0eVJlZ2lzdHJ5LCDJtVRFU1RBQklMSVRZX0dFVFRFUl1cbiAgICB9XG5dO1xuY29uc3QgQlJPV1NFUl9NT0RVTEVfUFJPVklERVJTID0gW1xuICAgIHsgcHJvdmlkZTogybVJTkpFQ1RPUl9TQ09QRSwgdXNlVmFsdWU6ICdyb290JyB9LFxuICAgIHsgcHJvdmlkZTogRXJyb3JIYW5kbGVyLCB1c2VGYWN0b3J5OiBlcnJvckhhbmRsZXIsIGRlcHM6IFtdIH0sIHtcbiAgICAgICAgcHJvdmlkZTogRVZFTlRfTUFOQUdFUl9QTFVHSU5TLFxuICAgICAgICB1c2VDbGFzczogRG9tRXZlbnRzUGx1Z2luLFxuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgZGVwczogW0RPQ1VNRU5ULCBOZ1pvbmUsIFBMQVRGT1JNX0lEXVxuICAgIH0sXG4gICAgeyBwcm92aWRlOiBFVkVOVF9NQU5BR0VSX1BMVUdJTlMsIHVzZUNsYXNzOiBLZXlFdmVudHNQbHVnaW4sIG11bHRpOiB0cnVlLCBkZXBzOiBbRE9DVU1FTlRdIH0sIHtcbiAgICAgICAgcHJvdmlkZTogRG9tUmVuZGVyZXJGYWN0b3J5MixcbiAgICAgICAgdXNlQ2xhc3M6IERvbVJlbmRlcmVyRmFjdG9yeTIsXG4gICAgICAgIGRlcHM6IFtFdmVudE1hbmFnZXIsIERvbVNoYXJlZFN0eWxlc0hvc3QsIEFQUF9JRCwgUkVNT1ZFX1NUWUxFU19PTl9DT01QT05FTlRfREVTVFJPWV1cbiAgICB9LFxuICAgIHsgcHJvdmlkZTogUmVuZGVyZXJGYWN0b3J5MiwgdXNlRXhpc3Rpbmc6IERvbVJlbmRlcmVyRmFjdG9yeTIgfSxcbiAgICB7IHByb3ZpZGU6IFNoYXJlZFN0eWxlc0hvc3QsIHVzZUV4aXN0aW5nOiBEb21TaGFyZWRTdHlsZXNIb3N0IH0sXG4gICAgeyBwcm92aWRlOiBEb21TaGFyZWRTdHlsZXNIb3N0LCB1c2VDbGFzczogRG9tU2hhcmVkU3R5bGVzSG9zdCwgZGVwczogW0RPQ1VNRU5UXSB9LFxuICAgIHsgcHJvdmlkZTogRXZlbnRNYW5hZ2VyLCB1c2VDbGFzczogRXZlbnRNYW5hZ2VyLCBkZXBzOiBbRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCBOZ1pvbmVdIH0sXG4gICAgeyBwcm92aWRlOiBYaHJGYWN0b3J5LCB1c2VDbGFzczogQnJvd3NlclhociwgZGVwczogW10gfSxcbiAgICBOR19ERVZfTU9ERSA/IHsgcHJvdmlkZTogQlJPV1NFUl9NT0RVTEVfUFJPVklERVJTX01BUktFUiwgdXNlVmFsdWU6IHRydWUgfSA6IFtdXG5dO1xuLyoqXG4gKiBFeHBvcnRzIHJlcXVpcmVkIGluZnJhc3RydWN0dXJlIGZvciBhbGwgQW5ndWxhciBhcHBzLlxuICogSW5jbHVkZWQgYnkgZGVmYXVsdCBpbiBhbGwgQW5ndWxhciBhcHBzIGNyZWF0ZWQgd2l0aCB0aGUgQ0xJXG4gKiBgbmV3YCBjb21tYW5kLlxuICogUmUtZXhwb3J0cyBgQ29tbW9uTW9kdWxlYCBhbmQgYEFwcGxpY2F0aW9uTW9kdWxlYCwgbWFraW5nIHRoZWlyXG4gKiBleHBvcnRzIGFuZCBwcm92aWRlcnMgYXZhaWxhYmxlIHRvIGFsbCBhcHBzLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgQnJvd3Nlck1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXJzQWxyZWFkeVByZXNlbnQpIHtcbiAgICAgICAgaWYgKE5HX0RFVl9NT0RFICYmIHByb3ZpZGVyc0FscmVhZHlQcmVzZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVycyBmcm9tIHRoZSBcXGBCcm93c2VyTW9kdWxlXFxgIGhhdmUgYWxyZWFkeSBiZWVuIGxvYWRlZC4gSWYgeW91IG5lZWQgYWNjZXNzIGAgK1xuICAgICAgICAgICAgICAgIGB0byBjb21tb24gZGlyZWN0aXZlcyBzdWNoIGFzIE5nSWYgYW5kIE5nRm9yLCBpbXBvcnQgdGhlIFxcYENvbW1vbk1vZHVsZVxcYCBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgYSBicm93c2VyLWJhc2VkIGFwcCB0byB0cmFuc2l0aW9uIGZyb20gYSBzZXJ2ZXItcmVuZGVyZWQgYXBwLCBpZlxuICAgICAqIG9uZSBpcyBwcmVzZW50IG9uIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3QgY29udGFpbmluZyBhbiBpZGVudGlmaWVyIGZvciB0aGUgYXBwIHRvIHRyYW5zaXRpb24uXG4gICAgICogVGhlIElEIG11c3QgbWF0Y2ggYmV0d2VlbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgdmVyc2lvbnMgb2YgdGhlIGFwcC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVjb25maWd1cmVkIGBCcm93c2VyTW9kdWxlYCB0byBpbXBvcnQgaW50byB0aGUgYXBwJ3Mgcm9vdCBgQXBwTW9kdWxlYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgd2l0aFNlcnZlclRyYW5zaXRpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQnJvd3Nlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogQVBQX0lELCB1c2VWYWx1ZTogcGFyYW1zLmFwcElkIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBUUkFOU0lUSU9OX0lELCB1c2VFeGlzdGluZzogQVBQX0lEIH0sXG4gICAgICAgICAgICAgICAgU0VSVkVSX1RSQU5TSVRJT05fUFJPVklERVJTLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5Ccm93c2VyTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJyb3dzZXJNb2R1bGUsIGRlcHM6IFt7IHRva2VuOiBCUk9XU0VSX01PRFVMRV9QUk9WSURFUlNfTUFSS0VSLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5Ccm93c2VyTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyTW9kdWxlLCBleHBvcnRzOiBbQ29tbW9uTW9kdWxlLCBBcHBsaWNhdGlvbk1vZHVsZV0gfSk7XG5Ccm93c2VyTW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyTW9kdWxlLCBwcm92aWRlcnM6IFtcbiAgICAgICAgLi4uQlJPV1NFUl9NT0RVTEVfUFJPVklERVJTLFxuICAgICAgICAuLi5URVNUQUJJTElUWV9QUk9WSURFUlNcbiAgICBdLCBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBBcHBsaWNhdGlvbk1vZHVsZV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3Nlck1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5CUk9XU0VSX01PRFVMRV9QUk9WSURFUlMsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5URVNUQUJJTElUWV9QUk9WSURFUlNcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0NvbW1vbk1vZHVsZSwgQXBwbGljYXRpb25Nb2R1bGVdLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0JST1dTRVJfTU9EVUxFX1BST1ZJREVSU19NQVJLRVJdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogRmFjdG9yeSB0byBjcmVhdGUgYSBgTWV0YWAgc2VydmljZSBpbnN0YW5jZSBmb3IgdGhlIGN1cnJlbnQgRE9NIGRvY3VtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXRhKCkge1xuICAgIHJldHVybiBuZXcgTWV0YSjJtcm1aW5qZWN0KERPQ1VNRU5UKSk7XG59XG4vKipcbiAqIEEgc2VydmljZSBmb3IgbWFuYWdpbmcgSFRNTCBgPG1ldGE+YCB0YWdzLlxuICpcbiAqIFByb3BlcnRpZXMgb2YgdGhlIGBNZXRhRGVmaW5pdGlvbmAgb2JqZWN0IG1hdGNoIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZVxuICogSFRNTCBgPG1ldGE+YCB0YWcuIFRoZXNlIHRhZ3MgZGVmaW5lIGRvY3VtZW50IG1ldGFkYXRhIHRoYXQgaXMgaW1wb3J0YW50IGZvclxuICogdGhpbmdzIGxpa2UgY29uZmlndXJpbmcgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSwgZGVmaW5pbmcgYnJvd3NlciBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc2VjdXJpdHkgc2V0dGluZ3MsIHNldHRpbmcgSFRUUCBIZWFkZXJzLCBkZWZpbmluZyByaWNoIGNvbnRlbnQgZm9yIHNvY2lhbCBzaGFyaW5nLFxuICogYW5kIFNlYXJjaCBFbmdpbmUgT3B0aW1pemF0aW9uIChTRU8pLlxuICpcbiAqIFRvIGlkZW50aWZ5IHNwZWNpZmljIGA8bWV0YT5gIHRhZ3MgaW4gYSBkb2N1bWVudCwgdXNlIGFuIGF0dHJpYnV0ZSBzZWxlY3Rpb25cbiAqIHN0cmluZyBpbiB0aGUgZm9ybWF0IGBcInRhZ19hdHRyaWJ1dGU9J3ZhbHVlIHN0cmluZydcImAuXG4gKiBGb3IgZXhhbXBsZSwgYW4gYGF0dHJTZWxlY3RvcmAgdmFsdWUgb2YgYFwibmFtZT0nZGVzY3JpcHRpb24nXCJgIG1hdGNoZXMgYSB0YWdcbiAqIHdob3NlIGBuYW1lYCBhdHRyaWJ1dGUgaGFzIHRoZSB2YWx1ZSBgXCJkZXNjcmlwdGlvblwiYC5cbiAqIFNlbGVjdG9ycyBhcmUgdXNlZCB3aXRoIHRoZSBgcXVlcnlTZWxlY3RvcigpYCBEb2N1bWVudCBtZXRob2QsXG4gKiBpbiB0aGUgZm9ybWF0IGBtZXRhW3thdHRyU2VsZWN0b3J9XWAuXG4gKlxuICogQHNlZSBbSFRNTCBtZXRhIHRhZ10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRNTC9FbGVtZW50L21ldGEpXG4gKiBAc2VlIFtEb2N1bWVudC5xdWVyeVNlbGVjdG9yKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9xdWVyeVNlbGVjdG9yKVxuICpcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE1ldGEge1xuICAgIGNvbnN0cnVjdG9yKF9kb2MpIHtcbiAgICAgICAgdGhpcy5fZG9jID0gX2RvYztcbiAgICAgICAgdGhpcy5fZG9tID0gybVnZXRET00oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9yIGNyZWF0ZXMgYSBzcGVjaWZpYyBgPG1ldGE+YCB0YWcgZWxlbWVudCBpbiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAqIEluIHNlYXJjaGluZyBmb3IgYW4gZXhpc3RpbmcgdGFnLCBBbmd1bGFyIGF0dGVtcHRzIHRvIG1hdGNoIHRoZSBgbmFtZWAgb3IgYHByb3BlcnR5YCBhdHRyaWJ1dGVcbiAgICAgKiB2YWx1ZXMgaW4gdGhlIHByb3ZpZGVkIHRhZyBkZWZpbml0aW9uLCBhbmQgdmVyaWZpZXMgdGhhdCBhbGwgb3RoZXIgYXR0cmlidXRlIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICogSWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBmb3VuZCwgaXQgaXMgcmV0dXJuZWQgYW5kIGlzIG5vdCBtb2RpZmllZCBpbiBhbnkgd2F5LlxuICAgICAqIEBwYXJhbSB0YWcgVGhlIGRlZmluaXRpb24gb2YgYSBgPG1ldGE+YCBlbGVtZW50IHRvIG1hdGNoIG9yIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0gZm9yY2VDcmVhdGlvbiBUcnVlIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50IHdpdGhvdXQgY2hlY2tpbmcgd2hldGhlciBvbmUgYWxyZWFkeSBleGlzdHMuXG4gICAgICogQHJldHVybnMgVGhlIGV4aXN0aW5nIGVsZW1lbnQgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzIGFuZCB2YWx1ZXMgaWYgZm91bmQsXG4gICAgICogdGhlIG5ldyBlbGVtZW50IGlmIG5vIG1hdGNoIGlzIGZvdW5kLCBvciBgbnVsbGAgaWYgdGhlIHRhZyBwYXJhbWV0ZXIgaXMgbm90IGRlZmluZWQuXG4gICAgICovXG4gICAgYWRkVGFnKHRhZywgZm9yY2VDcmVhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGFnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZUVsZW1lbnQodGFnLCBmb3JjZUNyZWF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG9yIGNyZWF0ZXMgYSBzZXQgb2YgYDxtZXRhPmAgdGFnIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogSW4gc2VhcmNoaW5nIGZvciBhbiBleGlzdGluZyB0YWcsIEFuZ3VsYXIgYXR0ZW1wdHMgdG8gbWF0Y2ggdGhlIGBuYW1lYCBvciBgcHJvcGVydHlgIGF0dHJpYnV0ZVxuICAgICAqIHZhbHVlcyBpbiB0aGUgcHJvdmlkZWQgdGFnIGRlZmluaXRpb24sIGFuZCB2ZXJpZmllcyB0aGF0IGFsbCBvdGhlciBhdHRyaWJ1dGUgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgKiBAcGFyYW0gdGFncyBBbiBhcnJheSBvZiB0YWcgZGVmaW5pdGlvbnMgdG8gbWF0Y2ggb3IgY3JlYXRlLlxuICAgICAqIEBwYXJhbSBmb3JjZUNyZWF0aW9uIFRydWUgdG8gY3JlYXRlIG5ldyBlbGVtZW50cyB3aXRob3V0IGNoZWNraW5nIHdoZXRoZXIgdGhleSBhbHJlYWR5IGV4aXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRjaGluZyBlbGVtZW50cyBpZiBmb3VuZCwgb3IgdGhlIG5ldyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBhZGRUYWdzKHRhZ3MsIGZvcmNlQ3JlYXRpb24gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRhZ3MpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0YWdzLnJlZHVjZSgocmVzdWx0LCB0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLl9nZXRPckNyZWF0ZUVsZW1lbnQodGFnLCBmb3JjZUNyZWF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGA8bWV0YT5gIHRhZyBlbGVtZW50IGluIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIGF0dHJTZWxlY3RvciBUaGUgdGFnIGF0dHJpYnV0ZSBhbmQgdmFsdWUgdG8gbWF0Y2ggYWdhaW5zdCwgaW4gdGhlIGZvcm1hdFxuICAgICAqIGBcInRhZ19hdHRyaWJ1dGU9J3ZhbHVlIHN0cmluZydcImAuXG4gICAgICogQHJldHVybnMgVGhlIG1hdGNoaW5nIGVsZW1lbnQsIGlmIGFueS5cbiAgICAgKi9cbiAgICBnZXRUYWcoYXR0clNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghYXR0clNlbGVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2MucXVlcnlTZWxlY3RvcihgbWV0YVske2F0dHJTZWxlY3Rvcn1dYCkgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgc2V0IG9mIGA8bWV0YT5gIHRhZyBlbGVtZW50cyBpbiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBhdHRyU2VsZWN0b3IgVGhlIHRhZyBhdHRyaWJ1dGUgYW5kIHZhbHVlIHRvIG1hdGNoIGFnYWluc3QsIGluIHRoZSBmb3JtYXRcbiAgICAgKiBgXCJ0YWdfYXR0cmlidXRlPSd2YWx1ZSBzdHJpbmcnXCJgLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYXRjaGluZyBlbGVtZW50cywgaWYgYW55LlxuICAgICAqL1xuICAgIGdldFRhZ3MoYXR0clNlbGVjdG9yKSB7XG4gICAgICAgIGlmICghYXR0clNlbGVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBsaXN0IC8qTm9kZUxpc3QqLyA9IHRoaXMuX2RvYy5xdWVyeVNlbGVjdG9yQWxsKGBtZXRhWyR7YXR0clNlbGVjdG9yfV1gKTtcbiAgICAgICAgcmV0dXJuIGxpc3QgPyBbXS5zbGljZS5jYWxsKGxpc3QpIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVzIGFuIGV4aXN0aW5nIGA8bWV0YT5gIHRhZyBlbGVtZW50IGluIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHRhZyBUaGUgdGFnIGRlc2NyaXB0aW9uIHdpdGggd2hpY2ggdG8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgdGFnIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHNlbGVjdG9yIEEgdGFnIGF0dHJpYnV0ZSBhbmQgdmFsdWUgdG8gbWF0Y2ggYWdhaW5zdCwgdG8gaWRlbnRpZnlcbiAgICAgKiBhbiBleGlzdGluZyB0YWcuIEEgc3RyaW5nIGluIHRoZSBmb3JtYXQgYFwidGFnX2F0dHJpYnV0ZT1gdmFsdWUgc3RyaW5nYFwiYC5cbiAgICAgKiBJZiBub3Qgc3VwcGxpZWQsIG1hdGNoZXMgYSB0YWcgd2l0aCB0aGUgc2FtZSBgbmFtZWAgb3IgYHByb3BlcnR5YCBhdHRyaWJ1dGUgdmFsdWUgYXMgdGhlXG4gICAgICogcmVwbGFjZW1lbnQgdGFnLlxuICAgICAqIEByZXR1cm4gVGhlIG1vZGlmaWVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgdXBkYXRlVGFnKHRhZywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCF0YWcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCB0aGlzLl9wYXJzZVNlbGVjdG9yKHRhZyk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldFRhZyhzZWxlY3Rvcik7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0TWV0YUVsZW1lbnRBdHRyaWJ1dGVzKHRhZywgbWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlRWxlbWVudCh0YWcsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGV4aXN0aW5nIGA8bWV0YT5gIHRhZyBlbGVtZW50IGZyb20gdGhlIGN1cnJlbnQgSFRNTCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gYXR0clNlbGVjdG9yIEEgdGFnIGF0dHJpYnV0ZSBhbmQgdmFsdWUgdG8gbWF0Y2ggYWdhaW5zdCwgdG8gaWRlbnRpZnlcbiAgICAgKiBhbiBleGlzdGluZyB0YWcuIEEgc3RyaW5nIGluIHRoZSBmb3JtYXQgYFwidGFnX2F0dHJpYnV0ZT1gdmFsdWUgc3RyaW5nYFwiYC5cbiAgICAgKi9cbiAgICByZW1vdmVUYWcoYXR0clNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVGFnRWxlbWVudCh0aGlzLmdldFRhZyhhdHRyU2VsZWN0b3IpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBleGlzdGluZyBgPG1ldGE+YCB0YWcgZWxlbWVudCBmcm9tIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIG1ldGEgVGhlIHRhZyBkZWZpbml0aW9uIHRvIG1hdGNoIGFnYWluc3QgdG8gaWRlbnRpZnkgYW4gZXhpc3RpbmcgdGFnLlxuICAgICAqL1xuICAgIHJlbW92ZVRhZ0VsZW1lbnQobWV0YSkge1xuICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fZG9tLnJlbW92ZShtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0T3JDcmVhdGVFbGVtZW50KG1ldGEsIGZvcmNlQ3JlYXRpb24gPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZvcmNlQ3JlYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5fcGFyc2VTZWxlY3RvcihtZXRhKTtcbiAgICAgICAgICAgIC8vIEl0J3MgYWxsb3dlZCB0byBoYXZlIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgbmFtZSBzbyBpdCdzIG5vdCBlbm91Z2ggdG9cbiAgICAgICAgICAgIC8vIGp1c3QgY2hlY2sgdGhhdCBlbGVtZW50IHdpdGggdGhlIHNhbWUgbmFtZSBhbHJlYWR5IHByZXNlbnQgb24gdGhlIHBhZ2UuIFdlIGFsc28gbmVlZCB0b1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgZWxlbWVudCBoYXMgdGFnIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLmdldFRhZ3Moc2VsZWN0b3IpLmZpbHRlcihlbGVtID0+IHRoaXMuX2NvbnRhaW5zQXR0cmlidXRlcyhtZXRhLCBlbGVtKSlbMF07XG4gICAgICAgICAgICBpZiAoZWxlbSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9kb20uY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICB0aGlzLl9zZXRNZXRhRWxlbWVudEF0dHJpYnV0ZXMobWV0YSwgZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLl9kb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIF9zZXRNZXRhRWxlbWVudEF0dHJpYnV0ZXModGFnLCBlbCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0YWcpLmZvckVhY2goKHByb3ApID0+IGVsLnNldEF0dHJpYnV0ZSh0aGlzLl9nZXRNZXRhS2V5TWFwKHByb3ApLCB0YWdbcHJvcF0pKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBfcGFyc2VTZWxlY3Rvcih0YWcpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHRhZy5uYW1lID8gJ25hbWUnIDogJ3Byb3BlcnR5JztcbiAgICAgICAgcmV0dXJuIGAke2F0dHJ9PVwiJHt0YWdbYXR0cl19XCJgO1xuICAgIH1cbiAgICBfY29udGFpbnNBdHRyaWJ1dGVzKHRhZywgZWxlbSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGFnKS5ldmVyeSgoa2V5KSA9PiBlbGVtLmdldEF0dHJpYnV0ZSh0aGlzLl9nZXRNZXRhS2V5TWFwKGtleSkpID09PSB0YWdba2V5XSk7XG4gICAgfVxuICAgIF9nZXRNZXRhS2V5TWFwKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIE1FVEFfS0VZU19NQVBbcHJvcF0gfHwgcHJvcDtcbiAgICB9XG59XG5NZXRhLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1ldGEsIGRlcHM6IFt7IHRva2VuOiBET0NVTUVOVCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuTWV0YS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWV0YSwgcHJvdmlkZWRJbjogJ3Jvb3QnLCB1c2VGYWN0b3J5OiBjcmVhdGVNZXRhLCBkZXBzOiBbXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNZXRhLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JywgdXNlRmFjdG9yeTogY3JlYXRlTWV0YSwgZGVwczogW10gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuLyoqXG4gKiBNYXBwaW5nIGZvciBNZXRhRGVmaW5pdGlvbiBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgY29ycmVjdCBtZXRhIGF0dHJpYnV0ZSBuYW1lc1xuICovXG5jb25zdCBNRVRBX0tFWVNfTUFQID0ge1xuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG59O1xuXG4vKipcbiAqIEZhY3RvcnkgdG8gY3JlYXRlIFRpdGxlIHNlcnZpY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKCkge1xuICAgIHJldHVybiBuZXcgVGl0bGUoybXJtWluamVjdChET0NVTUVOVCkpO1xufVxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgYW5kIHNldCB0aGUgdGl0bGUgb2YgYSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gKlxuICogU2luY2UgYW4gQW5ndWxhciBhcHBsaWNhdGlvbiBjYW4ndCBiZSBib290c3RyYXBwZWQgb24gdGhlIGVudGlyZSBIVE1MIGRvY3VtZW50IChgPGh0bWw+YCB0YWcpXG4gKiBpdCBpcyBub3QgcG9zc2libGUgdG8gYmluZCB0byB0aGUgYHRleHRgIHByb3BlcnR5IG9mIHRoZSBgSFRNTFRpdGxlRWxlbWVudGAgZWxlbWVudHNcbiAqIChyZXByZXNlbnRpbmcgdGhlIGA8dGl0bGU+YCB0YWcpLiBJbnN0ZWFkLCB0aGlzIHNlcnZpY2UgY2FuIGJlIHVzZWQgdG8gc2V0IGFuZCBnZXQgdGhlIGN1cnJlbnRcbiAqIHRpdGxlIHZhbHVlLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgVGl0bGUge1xuICAgIGNvbnN0cnVjdG9yKF9kb2MpIHtcbiAgICAgICAgdGhpcy5fZG9jID0gX2RvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBIVE1MIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGdldFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jLnRpdGxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IEhUTUwgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIG5ld1RpdGxlXG4gICAgICovXG4gICAgc2V0VGl0bGUobmV3VGl0bGUpIHtcbiAgICAgICAgdGhpcy5fZG9jLnRpdGxlID0gbmV3VGl0bGUgfHwgJyc7XG4gICAgfVxufVxuVGl0bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVGl0bGUsIGRlcHM6IFt7IHRva2VuOiBET0NVTUVOVCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuVGl0bGUuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFRpdGxlLCBwcm92aWRlZEluOiAncm9vdCcsIHVzZUZhY3Rvcnk6IGNyZWF0ZVRpdGxlLCBkZXBzOiBbXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBUaXRsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcsIHVzZUZhY3Rvcnk6IGNyZWF0ZVRpdGxlLCBkZXBzOiBbXSB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogRXhwb3J0cyB0aGUgdmFsdWUgdW5kZXIgYSBnaXZlbiBgbmFtZWAgaW4gdGhlIGdsb2JhbCBwcm9wZXJ0eSBgbmdgLiBGb3IgZXhhbXBsZSBgbmcucHJvYmVgIGlmXG4gKiBgbmFtZWAgaXMgYCdwcm9iZSdgLlxuICogQHBhcmFtIG5hbWUgTmFtZSB1bmRlciB3aGljaCBpdCB3aWxsIGJlIGV4cG9ydGVkLiBLZWVwIGluIG1pbmQgdGhpcyB3aWxsIGJlIGEgcHJvcGVydHkgb2YgdGhlXG4gKiBnbG9iYWwgYG5nYCBvYmplY3QuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGV4cG9ydC5cbiAqL1xuZnVuY3Rpb24gZXhwb3J0TmdWYXIobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIENPTVBJTEVEID09PSAndW5kZWZpbmVkJyB8fCAhQ09NUElMRUQpIHtcbiAgICAgICAgLy8gTm90ZTogd2UgY2FuJ3QgZXhwb3J0IGBuZ2Agd2hlbiB1c2luZyBjbG9zdXJlIGVuaGFuY2VkIG9wdGltaXphdGlvbiBhczpcbiAgICAgICAgLy8gLSBjbG9zdXJlIGRlY2xhcmVzIGdsb2JhbHMgaXRzZWxmIGZvciBtaW5pZmllZCBuYW1lcywgd2hpY2ggc29tZXRpbWVzIGNsb2JiZXIgb3VyIGBuZ2AgZ2xvYmFsXG4gICAgICAgIC8vIC0gd2UgY2FuJ3QgZGVjbGFyZSBhIGNsb3N1cmUgZXh0ZXJuIGFzIHRoZSBuYW1lc3BhY2UgYG5nYCBpcyBhbHJlYWR5IHVzZWQgd2l0aGluIEdvb2dsZVxuICAgICAgICAvLyAgIGZvciB0eXBpbmdzIGZvciBhbmd1bGFySlMgKHZpYSBgZ29vZy5wcm92aWRlKCduZy4uLi4nKWApLlxuICAgICAgICBjb25zdCBuZyA9IMm1Z2xvYmFsWyduZyddID0gybVnbG9iYWxbJ25nJ10gfHwge307XG4gICAgICAgIG5nW25hbWVdID0gdmFsdWU7XG4gICAgfVxufVxuXG5jb25zdCB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwge307XG5cbmNsYXNzIENoYW5nZURldGVjdGlvblBlcmZSZWNvcmQge1xuICAgIGNvbnN0cnVjdG9yKG1zUGVyVGljaywgbnVtVGlja3MpIHtcbiAgICAgICAgdGhpcy5tc1BlclRpY2sgPSBtc1BlclRpY2s7XG4gICAgICAgIHRoaXMubnVtVGlja3MgPSBudW1UaWNrcztcbiAgICB9XG59XG4vKipcbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgQW5ndWxhciBwcm9maWxpbmctcmVsYXRlZCBkZWJ1ZyB0b29scy4gVGhpcyBvYmplY3RcbiAqIGNvcnJlc3BvbmRzIHRvIHRoZSBgbmcucHJvZmlsZXJgIGluIHRoZSBkZXYgY29uc29sZS5cbiAqL1xuY2xhc3MgQW5ndWxhclByb2ZpbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWYpIHtcbiAgICAgICAgdGhpcy5hcHBSZWYgPSByZWYuaW5qZWN0b3IuZ2V0KEFwcGxpY2F0aW9uUmVmKTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuICAgIC8qKlxuICAgICAqIEV4ZXJjaXNlcyBjaGFuZ2UgZGV0ZWN0aW9uIGluIGEgbG9vcCBhbmQgdGhlbiBwcmludHMgdGhlIGF2ZXJhZ2UgYW1vdW50IG9mXG4gICAgICogdGltZSBpbiBtaWxsaXNlY29uZHMgaG93IGxvbmcgYSBzaW5nbGUgcm91bmQgb2YgY2hhbmdlIGRldGVjdGlvbiB0YWtlcyBmb3JcbiAgICAgKiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgVUkuIEl0IHJ1bnMgYSBtaW5pbXVtIG9mIDUgcm91bmRzIGZvciBhIG1pbmltdW1cbiAgICAgKiBvZiA1MDAgbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogT3B0aW9uYWxseSwgYSB1c2VyIG1heSBwYXNzIGEgYGNvbmZpZ2AgcGFyYW1ldGVyIGNvbnRhaW5pbmcgYSBtYXAgb2ZcbiAgICAgKiBvcHRpb25zLiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiBgcmVjb3JkYCAoYm9vbGVhbikgLSBjYXVzZXMgdGhlIHByb2ZpbGVyIHRvIHJlY29yZCBhIENQVSBwcm9maWxlIHdoaWxlXG4gICAgICogaXQgZXhlcmNpc2VzIHRoZSBjaGFuZ2UgZGV0ZWN0b3IuIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBuZy5wcm9maWxlci50aW1lQ2hhbmdlRGV0ZWN0aW9uKHtyZWNvcmQ6IHRydWV9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRpbWVDaGFuZ2VEZXRlY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZCA9IGNvbmZpZyAmJiBjb25maWdbJ3JlY29yZCddO1xuICAgICAgICBjb25zdCBwcm9maWxlTmFtZSA9ICdDaGFuZ2UgRGV0ZWN0aW9uJztcbiAgICAgICAgLy8gUHJvZmlsZXIgaXMgbm90IGF2YWlsYWJsZSBpbiBBbmRyb2lkIGJyb3dzZXJzIHdpdGhvdXQgZGV2IHRvb2xzIG9wZW5lZFxuICAgICAgICBjb25zdCBpc1Byb2ZpbGVyQXZhaWxhYmxlID0gd2luLmNvbnNvbGUucHJvZmlsZSAhPSBudWxsO1xuICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHdpbi5jb25zb2xlLnByb2ZpbGUocHJvZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgbGV0IG51bVRpY2tzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRpY2tzIDwgNSB8fCAocGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0KSA8IDUwMCkge1xuICAgICAgICAgICAgdGhpcy5hcHBSZWYudGljaygpO1xuICAgICAgICAgICAgbnVtVGlja3MrKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBpZiAocmVjb3JkICYmIGlzUHJvZmlsZXJBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIHdpbi5jb25zb2xlLnByb2ZpbGVFbmQocHJvZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zUGVyVGljayA9IChlbmQgLSBzdGFydCkgLyBudW1UaWNrcztcbiAgICAgICAgd2luLmNvbnNvbGUubG9nKGByYW4gJHtudW1UaWNrc30gY2hhbmdlIGRldGVjdGlvbiBjeWNsZXNgKTtcbiAgICAgICAgd2luLmNvbnNvbGUubG9nKGAke21zUGVyVGljay50b0ZpeGVkKDIpfSBtcyBwZXIgY2hlY2tgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2VEZXRlY3Rpb25QZXJmUmVjb3JkKG1zUGVyVGljaywgbnVtVGlja3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiB3aW4ucGVyZm9ybWFuY2UgJiYgd2luLnBlcmZvcm1hbmNlLm5vdyA/IHdpbi5wZXJmb3JtYW5jZS5ub3coKSA6XG4gICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuXG5jb25zdCBQUk9GSUxFUl9HTE9CQUxfTkFNRSA9ICdwcm9maWxlcic7XG4vKipcbiAqIEVuYWJsZWQgQW5ndWxhciBkZWJ1ZyB0b29scyB0aGF0IGFyZSBhY2Nlc3NpYmxlIHZpYSB5b3VyIGJyb3dzZXInc1xuICogZGV2ZWxvcGVyIGNvbnNvbGUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogMS4gT3BlbiBkZXZlbG9wZXIgY29uc29sZSAoZS5nLiBpbiBDaHJvbWUgQ3RybCArIFNoaWZ0ICsgailcbiAqIDEuIFR5cGUgYG5nLmAgKHVzdWFsbHkgdGhlIGNvbnNvbGUgd2lsbCBzaG93IGF1dG8tY29tcGxldGUgc3VnZ2VzdGlvbilcbiAqIDEuIFRyeSB0aGUgY2hhbmdlIGRldGVjdGlvbiBwcm9maWxlciBgbmcucHJvZmlsZXIudGltZUNoYW5nZURldGVjdGlvbigpYFxuICogICAgdGhlbiBoaXQgRW50ZXIuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1Rvb2xzKHJlZikge1xuICAgIGV4cG9ydE5nVmFyKFBST0ZJTEVSX0dMT0JBTF9OQU1FLCBuZXcgQW5ndWxhclByb2ZpbGVyKHJlZikpO1xuICAgIHJldHVybiByZWY7XG59XG4vKipcbiAqIERpc2FibGVzIEFuZ3VsYXIgdG9vbHMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5mdW5jdGlvbiBkaXNhYmxlRGVidWdUb29scygpIHtcbiAgICBleHBvcnROZ1ZhcihQUk9GSUxFUl9HTE9CQUxfTkFNRSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dCkge1xuICAgIGNvbnN0IGVzY2FwZWRUZXh0ID0ge1xuICAgICAgICAnJic6ICcmYTsnLFxuICAgICAgICAnXCInOiAnJnE7JyxcbiAgICAgICAgJ1xcJyc6ICcmczsnLFxuICAgICAgICAnPCc6ICcmbDsnLFxuICAgICAgICAnPic6ICcmZzsnLFxuICAgIH07XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvWyZcIic8Pl0vZywgcyA9PiBlc2NhcGVkVGV4dFtzXSk7XG59XG5mdW5jdGlvbiB1bmVzY2FwZUh0bWwodGV4dCkge1xuICAgIGNvbnN0IHVuZXNjYXBlZFRleHQgPSB7XG4gICAgICAgICcmYTsnOiAnJicsXG4gICAgICAgICcmcTsnOiAnXCInLFxuICAgICAgICAnJnM7JzogJ1xcJycsXG4gICAgICAgICcmbDsnOiAnPCcsXG4gICAgICAgICcmZzsnOiAnPicsXG4gICAgfTtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8mW147XSs7L2csIHMgPT4gdW5lc2NhcGVkVGV4dFtzXSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGBTdGF0ZUtleTxUPmAgdGhhdCBjYW4gYmUgdXNlZCB0byBzdG9yZSB2YWx1ZSBvZiB0eXBlIFQgd2l0aCBgVHJhbnNmZXJTdGF0ZWAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IENPVU5URVJfS0VZID0gbWFrZVN0YXRlS2V5PG51bWJlcj4oJ2NvdW50ZXInKTtcbiAqIGxldCB2YWx1ZSA9IDEwO1xuICpcbiAqIHRyYW5zZmVyU3RhdGUuc2V0KENPVU5URVJfS0VZLCB2YWx1ZSk7XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmZ1bmN0aW9uIG1ha2VTdGF0ZUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5O1xufVxuLyoqXG4gKiBBIGtleSB2YWx1ZSBzdG9yZSB0aGF0IGlzIHRyYW5zZmVycmVkIGZyb20gdGhlIGFwcGxpY2F0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZSB0byB0aGUgYXBwbGljYXRpb25cbiAqIG9uIHRoZSBjbGllbnQgc2lkZS5cbiAqXG4gKiBUaGUgYFRyYW5zZmVyU3RhdGVgIGlzIGF2YWlsYWJsZSBhcyBhbiBpbmplY3RhYmxlIHRva2VuLlxuICogT24gdGhlIGNsaWVudCwganVzdCBpbmplY3QgdGhpcyB0b2tlbiB1c2luZyBESSBhbmQgdXNlIGl0LCBpdCB3aWxsIGJlIGxhemlseSBpbml0aWFsaXplZC5cbiAqIE9uIHRoZSBzZXJ2ZXIgaXQncyBhbHJlYWR5IGluY2x1ZGVkIGlmIGByZW5kZXJBcHBsaWNhdGlvbmAgZnVuY3Rpb24gaXMgdXNlZC4gT3RoZXJ3aXNlLCBpbXBvcnRcbiAqIHRoZSBgU2VydmVyVHJhbnNmZXJTdGF0ZU1vZHVsZWAgbW9kdWxlIHRvIG1ha2UgdGhlIGBUcmFuc2ZlclN0YXRlYCBhdmFpbGFibGUuXG4gKlxuICogVGhlIHZhbHVlcyBpbiB0aGUgc3RvcmUgYXJlIHNlcmlhbGl6ZWQvZGVzZXJpYWxpemVkIHVzaW5nIEpTT04uc3RyaW5naWZ5L0pTT04ucGFyc2UuIFNvIG9ubHlcbiAqIGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBudWxsIGFuZCBub24tY2xhc3Mgb2JqZWN0cyB3aWxsIGJlIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZCBpbiBhXG4gKiBub24tbG9zc3kgbWFubmVyLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgVHJhbnNmZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgICAgICAgdGhpcy5vblNlcmlhbGl6ZUNhbGxiYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLnN0b3JlID0gcmV0cmlldmVUcmFuc2ZlcnJlZFN0YXRlKGluamVjdChET0NVTUVOVCksIGluamVjdChBUFBfSUQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIGEga2V5LiBSZXR1cm4gYGRlZmF1bHRWYWx1ZWAgaWYga2V5IGlzIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmVba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpcy5zdG9yZVtrZXldIDogZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gYSBrZXkuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGtleSBmcm9tIHRoZSBzdG9yZS5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0b3JlW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3Qgd2hldGhlciBhIGtleSBleGlzdHMgaW4gdGhlIHN0b3JlLlxuICAgICAqL1xuICAgIGhhc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0YXRlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yZSkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHByb3ZpZGUgdGhlIHZhbHVlIGZvciBhIGtleSB3aGVuIGB0b0pzb25gIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBvblNlcmlhbGl6ZShrZXksIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub25TZXJpYWxpemVDYWxsYmFja3Nba2V5XSA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHN0b3JlIHRvIEpTT04uXG4gICAgICovXG4gICAgdG9Kc29uKCkge1xuICAgICAgICAvLyBDYWxsIHRoZSBvblNlcmlhbGl6ZSBjYWxsYmFja3MgYW5kIHB1dCB0aG9zZSB2YWx1ZXMgaW50byB0aGUgc3RvcmUuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMub25TZXJpYWxpemVDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU2VyaWFsaXplQ2FsbGJhY2tzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlW2tleV0gPSB0aGlzLm9uU2VyaWFsaXplQ2FsbGJhY2tzW2tleV0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeGNlcHRpb24gaW4gb25TZXJpYWxpemUgY2FsbGJhY2s6ICcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zdG9yZSk7XG4gICAgfVxufVxuVHJhbnNmZXJTdGF0ZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBUcmFuc2ZlclN0YXRlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuVHJhbnNmZXJTdGF0ZS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVHJhbnNmZXJTdGF0ZSwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFRyYW5zZmVyU3RhdGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0gfSk7XG5mdW5jdGlvbiByZXRyaWV2ZVRyYW5zZmVycmVkU3RhdGUoZG9jLCBhcHBJZCkge1xuICAgIC8vIExvY2F0ZSB0aGUgc2NyaXB0IHRhZyB3aXRoIHRoZSBKU09OIGRhdGEgdHJhbnNmZXJyZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgIC8vIFRoZSBpZCBvZiB0aGUgc2NyaXB0IHRhZyBpcyBzZXQgdG8gdGhlIEFuZ3VsYXIgYXBwSWQgKyAnc3RhdGUnLlxuICAgIGNvbnN0IHNjcmlwdCA9IGRvYy5nZXRFbGVtZW50QnlJZChhcHBJZCArICctc3RhdGUnKTtcbiAgICBsZXQgaW5pdGlhbFN0YXRlID0ge307XG4gICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQudGV4dENvbnRlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEF2b2lkIHVzaW5nIGFueSBoZXJlIGFzIGl0IHRyaWdnZXJzIGxpbnQgZXJyb3JzIGluIGdvb2dsZTMgKGFueSBpcyBub3QgYWxsb3dlZCkuXG4gICAgICAgICAgICBpbml0aWFsU3RhdGUgPSBKU09OLnBhcnNlKHVuZXNjYXBlSHRtbChzY3JpcHQudGV4dENvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFeGNlcHRpb24gd2hpbGUgcmVzdG9yaW5nIFRyYW5zZmVyU3RhdGUgZm9yIGFwcCAnICsgYXBwSWQsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsU3RhdGU7XG59XG4vKipcbiAqIE5nTW9kdWxlIHRvIGluc3RhbGwgb24gdGhlIGNsaWVudCBzaWRlIHdoaWxlIHVzaW5nIHRoZSBgVHJhbnNmZXJTdGF0ZWAgdG8gdHJhbnNmZXIgc3RhdGUgZnJvbVxuICogc2VydmVyIHRvIGNsaWVudC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKiBAZGVwcmVjYXRlZCBubyBsb25nZXIgbmVlZGVkLCB5b3UgY2FuIGluamVjdCB0aGUgYFRyYW5zZmVyU3RhdGVgIGluIGFuIGFwcCB3aXRob3V0IHByb3ZpZGluZ1xuICogICAgIHRoaXMgbW9kdWxlLlxuICovXG5jbGFzcyBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSB7XG59XG5Ccm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5Ccm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUgfSk7XG5Ccm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJvd3NlclRyYW5zZmVyU3RhdGVNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7fV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogUHJlZGljYXRlcyBmb3IgdXNlIHdpdGgge0BsaW5rIERlYnVnRWxlbWVudH0ncyBxdWVyeSBmdW5jdGlvbnMuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBCeSB7XG4gICAgLyoqXG4gICAgICogTWF0Y2ggYWxsIG5vZGVzLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfYWxsJ31cbiAgICAgKi9cbiAgICBzdGF0aWMgYWxsKCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggZWxlbWVudHMgYnkgdGhlIGdpdmVuIENTUyBzZWxlY3Rvci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBwbGF0Zm9ybS1icm93c2VyL2RvbS9kZWJ1Zy90cy9ieS9ieS50cyByZWdpb249J2J5X2Nzcyd9XG4gICAgICovXG4gICAgc3RhdGljIGNzcyhzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gKGRlYnVnRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50ICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGVsZW1lbnRNYXRjaGVzKGRlYnVnRWxlbWVudC5uYXRpdmVFbGVtZW50LCBzZWxlY3RvcikgOlxuICAgICAgICAgICAgICAgIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBub2RlcyB0aGF0IGhhdmUgdGhlIGdpdmVuIGRpcmVjdGl2ZSBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIHBsYXRmb3JtLWJyb3dzZXIvZG9tL2RlYnVnL3RzL2J5L2J5LnRzIHJlZ2lvbj0nYnlfZGlyZWN0aXZlJ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZGlyZWN0aXZlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChkZWJ1Z05vZGUpID0+IGRlYnVnTm9kZS5wcm92aWRlclRva2Vucy5pbmRleE9mKHR5cGUpICE9PSAtMTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhuLCBzZWxlY3Rvcikge1xuICAgIGlmICjJtWdldERPTSgpLmlzRWxlbWVudE5vZGUobikpIHtcbiAgICAgICAgcmV0dXJuIG4ubWF0Y2hlcyAmJiBuLm1hdGNoZXMoc2VsZWN0b3IpIHx8XG4gICAgICAgICAgICBuLm1zTWF0Y2hlc1NlbGVjdG9yICYmIG4ubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpIHx8XG4gICAgICAgICAgICBuLndlYmtpdE1hdGNoZXNTZWxlY3RvciAmJiBuLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0ZWQgSGFtbWVySlMgcmVjb2duaXplciBldmVudCBuYW1lcy5cbiAqL1xuY29uc3QgRVZFTlRfTkFNRVMgPSB7XG4gICAgLy8gcGFuXG4gICAgJ3Bhbic6IHRydWUsXG4gICAgJ3BhbnN0YXJ0JzogdHJ1ZSxcbiAgICAncGFubW92ZSc6IHRydWUsXG4gICAgJ3BhbmVuZCc6IHRydWUsXG4gICAgJ3BhbmNhbmNlbCc6IHRydWUsXG4gICAgJ3BhbmxlZnQnOiB0cnVlLFxuICAgICdwYW5yaWdodCc6IHRydWUsXG4gICAgJ3BhbnVwJzogdHJ1ZSxcbiAgICAncGFuZG93bic6IHRydWUsXG4gICAgLy8gcGluY2hcbiAgICAncGluY2gnOiB0cnVlLFxuICAgICdwaW5jaHN0YXJ0JzogdHJ1ZSxcbiAgICAncGluY2htb3ZlJzogdHJ1ZSxcbiAgICAncGluY2hlbmQnOiB0cnVlLFxuICAgICdwaW5jaGNhbmNlbCc6IHRydWUsXG4gICAgJ3BpbmNoaW4nOiB0cnVlLFxuICAgICdwaW5jaG91dCc6IHRydWUsXG4gICAgLy8gcHJlc3NcbiAgICAncHJlc3MnOiB0cnVlLFxuICAgICdwcmVzc3VwJzogdHJ1ZSxcbiAgICAvLyByb3RhdGVcbiAgICAncm90YXRlJzogdHJ1ZSxcbiAgICAncm90YXRlc3RhcnQnOiB0cnVlLFxuICAgICdyb3RhdGVtb3ZlJzogdHJ1ZSxcbiAgICAncm90YXRlZW5kJzogdHJ1ZSxcbiAgICAncm90YXRlY2FuY2VsJzogdHJ1ZSxcbiAgICAvLyBzd2lwZVxuICAgICdzd2lwZSc6IHRydWUsXG4gICAgJ3N3aXBlbGVmdCc6IHRydWUsXG4gICAgJ3N3aXBlcmlnaHQnOiB0cnVlLFxuICAgICdzd2lwZXVwJzogdHJ1ZSxcbiAgICAnc3dpcGVkb3duJzogdHJ1ZSxcbiAgICAvLyB0YXBcbiAgICAndGFwJzogdHJ1ZSxcbiAgICAnZG91YmxldGFwJzogdHJ1ZVxufTtcbi8qKlxuICogREkgdG9rZW4gZm9yIHByb3ZpZGluZyBbSGFtbWVySlNdKGh0dHBzOi8vaGFtbWVyanMuZ2l0aHViLmlvLykgc3VwcG9ydCB0byBBbmd1bGFyLlxuICogQHNlZSBgSGFtbWVyR2VzdHVyZUNvbmZpZ2BcbiAqXG4gKiBAbmdNb2R1bGUgSGFtbWVyTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IEhBTU1FUl9HRVNUVVJFX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignSGFtbWVyR2VzdHVyZUNvbmZpZycpO1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gdXNlZCB0byBwcm92aWRlIGEge0BsaW5rIEhhbW1lckxvYWRlcn0gdG8gQW5ndWxhci5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IEhBTU1FUl9MT0FERVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0hhbW1lckxvYWRlcicpO1xuLyoqXG4gKiBBbiBpbmplY3RhYmxlIFtIYW1tZXJKUyBNYW5hZ2VyXShodHRwczovL2hhbW1lcmpzLmdpdGh1Yi5pby9hcGkvI2hhbW1lcm1hbmFnZXIpXG4gKiBmb3IgZ2VzdHVyZSByZWNvZ25pdGlvbi4gQ29uZmlndXJlcyBzcGVjaWZpYyBldmVudCByZWNvZ25pdGlvbi5cbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgSGFtbWVyR2VzdHVyZUNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNldCBvZiBzdXBwb3J0ZWQgZXZlbnQgbmFtZXMgZm9yIGdlc3R1cmVzIHRvIGJlIHVzZWQgaW4gQW5ndWxhci5cbiAgICAgICAgICogQW5ndWxhciBzdXBwb3J0cyBhbGwgYnVpbHQtaW4gcmVjb2duaXplcnMsIGFzIGxpc3RlZCBpblxuICAgICAgICAgKiBbSGFtbWVySlMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9oYW1tZXJqcy5naXRodWIuaW8vKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGdlc3R1cmUgZXZlbnQgbmFtZXMgdG8gYSBzZXQgb2YgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICAgICAqIHRoYXQgc3BlY2lmeSBvdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgdmFsdWVzIGZvciBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUga2V5IGlzIGEgc3VwcG9ydGVkIGV2ZW50IG5hbWUgdG8gYmUgY29uZmlndXJlZCxcbiAgICAgICAgICogYW5kIHRoZSBvcHRpb25zIG9iamVjdCBjb250YWlucyBhIHNldCBvZiBwcm9wZXJ0aWVzLCB3aXRoIG92ZXJyaWRlIHZhbHVlc1xuICAgICAgICAgKiB0byBiZSBhcHBsaWVkIHRvIHRoZSBuYW1lZCByZWNvZ25pemVyIGV2ZW50LlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgdG8gZGlzYWJsZSByZWNvZ25pdGlvbiBvZiB0aGUgcm90YXRlIGV2ZW50LCBzcGVjaWZ5XG4gICAgICAgICAqICBge1wicm90YXRlXCI6IHtcImVuYWJsZVwiOiBmYWxzZX19YC5cbiAgICAgICAgICpcbiAgICAgICAgICogUHJvcGVydGllcyB0aGF0IGFyZSBub3QgcHJlc2VudCB0YWtlIHRoZSBIYW1tZXJKUyBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICogRm9yIGluZm9ybWF0aW9uIGFib3V0IHdoaWNoIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZCBmb3Igd2hpY2ggZXZlbnRzLFxuICAgICAgICAgKiBhbmQgdGhlaXIgYWxsb3dlZCBhbmQgZGVmYXVsdCB2YWx1ZXMsIHNlZVxuICAgICAgICAgKiBbSGFtbWVySlMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9oYW1tZXJqcy5naXRodWIuaW8vKS5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3ZlcnJpZGVzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbSGFtbWVySlMgTWFuYWdlcl0oaHR0cHM6Ly9oYW1tZXJqcy5naXRodWIuaW8vYXBpLyNoYW1tZXJtYW5hZ2VyKVxuICAgICAqIGFuZCBhdHRhY2hlcyBpdCB0byBhIGdpdmVuIEhUTUwgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCB0aGF0IHdpbGwgcmVjb2duaXplIGdlc3R1cmVzLlxuICAgICAqIEByZXR1cm5zIEEgSGFtbWVySlMgZXZlbnQtbWFuYWdlciBvYmplY3QuXG4gICAgICovXG4gICAgYnVpbGRIYW1tZXIoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBtYyA9IG5ldyBIYW1tZXIoZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgbWMuZ2V0KCdwaW5jaCcpLnNldCh7IGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgbWMuZ2V0KCdyb3RhdGUnKS5zZXQoeyBlbmFibGU6IHRydWUgfSk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIHRoaXMub3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBtYy5nZXQoZXZlbnROYW1lKS5zZXQodGhpcy5vdmVycmlkZXNbZXZlbnROYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1jO1xuICAgIH1cbn1cbkhhbW1lckdlc3R1cmVDb25maWcuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGFtbWVyR2VzdHVyZUNvbmZpZywgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkhhbW1lckdlc3R1cmVDb25maWcuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lckdlc3R1cmVDb25maWcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGFtbWVyR2VzdHVyZUNvbmZpZywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIEV2ZW50IHBsdWdpbiB0aGF0IGFkZHMgSGFtbWVyIHN1cHBvcnQgdG8gYW4gYXBwbGljYXRpb24uXG4gKlxuICogQG5nTW9kdWxlIEhhbW1lck1vZHVsZVxuICovXG5jbGFzcyBIYW1tZXJHZXN0dXJlc1BsdWdpbiBleHRlbmRzIEV2ZW50TWFuYWdlclBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoZG9jLCBfY29uZmlnLCBjb25zb2xlLCBsb2FkZXIpIHtcbiAgICAgICAgc3VwZXIoZG9jKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gX2NvbmZpZztcbiAgICAgICAgdGhpcy5jb25zb2xlID0gY29uc29sZTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgIHRoaXMuX2xvYWRlclByb21pc2UgPSBudWxsO1xuICAgIH1cbiAgICBzdXBwb3J0cyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFFVkVOVF9OQU1FUy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUudG9Mb3dlckNhc2UoKSkgJiYgIXRoaXMuaXNDdXN0b21FdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aW5kb3cuSGFtbWVyICYmICF0aGlzLmxvYWRlcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc29sZS53YXJuKGBUaGUgXCIke2V2ZW50TmFtZX1cIiBldmVudCBjYW5ub3QgYmUgYm91bmQgYmVjYXVzZSBIYW1tZXIuSlMgaXMgbm90IGAgK1xuICAgICAgICAgICAgICAgICAgICBgbG9hZGVkIGFuZCBubyBjdXN0b20gbG9hZGVyIGhhcyBiZWVuIHNwZWNpZmllZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgem9uZSA9IHRoaXMubWFuYWdlci5nZXRab25lKCk7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBJZiBIYW1tZXIgaXMgbm90IHByZXNlbnQgYnV0IGEgbG9hZGVyIGlzIHNwZWNpZmllZCwgd2UgZGVmZXIgYWRkaW5nIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAgICAvLyB1bnRpbCBIYW1tZXIgaXMgbG9hZGVkLlxuICAgICAgICBpZiAoIXdpbmRvdy5IYW1tZXIgJiYgdGhpcy5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlclByb21pc2UgPSB0aGlzLl9sb2FkZXJQcm9taXNlIHx8IHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5sb2FkZXIoKSk7XG4gICAgICAgICAgICAvLyBUaGlzIGBhZGRFdmVudExpc3RlbmVyYCBtZXRob2QgcmV0dXJucyBhIGZ1bmN0aW9uIHRvIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXIuXG4gICAgICAgICAgICAvLyBVbnRpbCBIYW1tZXIgaXMgbG9hZGVkLCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gbmVlZHMgdG8gKmNhbmNlbCogdGhlIHJlZ2lzdHJhdGlvbiByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gcmVtb3ZlIGFueXRoaW5nLlxuICAgICAgICAgICAgbGV0IGNhbmNlbFJlZ2lzdHJhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRlcmVnaXN0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsUmVnaXN0cmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB6b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHRoaXMuX2xvYWRlclByb21pc2VcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgSGFtbWVyIGlzbid0IGFjdHVhbGx5IGxvYWRlZCB3aGVuIHRoZSBjdXN0b20gbG9hZGVyIHJlc29sdmVzLCBnaXZlIHVwLlxuICAgICAgICAgICAgICAgIGlmICghd2luZG93LkhhbW1lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnNvbGUud2FybihgVGhlIGN1c3RvbSBIQU1NRVJfTE9BREVSIGNvbXBsZXRlZCwgYnV0IEhhbW1lci5KUyBpcyBub3QgcHJlc2VudC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsUmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IEhhbW1lciBpcyBsb2FkZWQgYW5kIHRoZSBsaXN0ZW5lciBpcyBiZWluZyBsb2FkZWQgZm9yIHJlYWwsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBjaGFuZ2VzIGZyb20gY2FuY2VsaW5nIHJlZ2lzdHJhdGlvbiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmFsLlxuICAgICAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zb2xlLndhcm4oYFRoZSBcIiR7ZXZlbnROYW1lfVwiIGV2ZW50IGNhbm5vdCBiZSBib3VuZCBiZWNhdXNlIHRoZSBjdXN0b20gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgSGFtbWVyLkpTIGxvYWRlciBmYWlsZWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXIgPSAoKSA9PiB7IH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0ICpleGVjdXRlcyogYGRlcmVnaXN0ZXJgIChhbmQgbm90IGBkZXJlZ2lzdGVyYCBpdHNlbGYpIHNvIHRoYXQgd2VcbiAgICAgICAgICAgIC8vIGNhbiBjaGFuZ2UgdGhlIGJlaGF2aW9yIG9mIGBkZXJlZ2lzdGVyYCBvbmNlIHRoZSBsaXN0ZW5lciBpcyBhZGRlZC4gVXNpbmcgYSBjbG9zdXJlIGluXG4gICAgICAgICAgICAvLyB0aGlzIHdheSBhbGxvd3MgdXMgdG8gYXZvaWQgYW55IGFkZGl0aW9uYWwgZGF0YSBzdHJ1Y3R1cmVzIHRvIHRyYWNrIGxpc3RlbmVyIHJlbW92YWwuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlcmVnaXN0ZXIoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgdGhlIG1hbmFnZXIgYmluZCBldmVudHMsIG11c3QgYmUgZG9uZSBvdXRzaWRlIG9mIGFuZ3VsYXJcbiAgICAgICAgICAgIGNvbnN0IG1jID0gdGhpcy5fY29uZmlnLmJ1aWxkSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnRPYmopIHtcbiAgICAgICAgICAgICAgICB6b25lLnJ1bkd1YXJkZWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGV2ZW50T2JqKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtYy5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbWMub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIC8vIGRlc3Ryb3kgbWMgdG8gcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBtYy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQ3VzdG9tRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKSA+IC0xO1xuICAgIH1cbn1cbkhhbW1lckdlc3R1cmVzUGx1Z2luLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lckdlc3R1cmVzUGx1Z2luLCBkZXBzOiBbeyB0b2tlbjogRE9DVU1FTlQgfSwgeyB0b2tlbjogSEFNTUVSX0dFU1RVUkVfQ09ORklHIH0sIHsgdG9rZW46IGkwLsm1Q29uc29sZSB9LCB7IHRva2VuOiBIQU1NRVJfTE9BREVSLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuSGFtbWVyR2VzdHVyZXNQbHVnaW4uybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lckdlc3R1cmVzUGx1Z2luIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lckdlc3R1cmVzUGx1Z2luLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBIYW1tZXJHZXN0dXJlQ29uZmlnLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtIQU1NRVJfR0VTVFVSRV9DT05GSUddXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMC7JtUNvbnNvbGUgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtIQU1NRVJfTE9BREVSXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuLyoqXG4gKiBBZGRzIHN1cHBvcnQgZm9yIEhhbW1lckpTLlxuICpcbiAqIEltcG9ydCB0aGlzIG1vZHVsZSBhdCB0aGUgcm9vdCBvZiB5b3VyIGFwcGxpY2F0aW9uIHNvIHRoYXQgQW5ndWxhciBjYW4gd29yayB3aXRoXG4gKiBIYW1tZXJKUyB0byBkZXRlY3QgZ2VzdHVyZSBldmVudHMuXG4gKlxuICogTm90ZSB0aGF0IGFwcGxpY2F0aW9ucyBzdGlsbCBuZWVkIHRvIGluY2x1ZGUgdGhlIEhhbW1lckpTIHNjcmlwdCBpdHNlbGYuIFRoaXMgbW9kdWxlXG4gKiBzaW1wbHkgc2V0cyB1cCB0aGUgY29vcmRpbmF0aW9uIGxheWVyIGJldHdlZW4gSGFtbWVySlMgYW5kIEFuZ3VsYXIncyBFdmVudE1hbmFnZXIuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBIYW1tZXJNb2R1bGUge1xufVxuSGFtbWVyTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lck1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5IYW1tZXJNb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuN1wiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhhbW1lck1vZHVsZSB9KTtcbkhhbW1lck1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGFtbWVyTW9kdWxlLCBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogRVZFTlRfTUFOQUdFUl9QTFVHSU5TLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVzUGx1Z2luLFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICBkZXBzOiBbRE9DVU1FTlQsIEhBTU1FUl9HRVNUVVJFX0NPTkZJRywgybVDb25zb2xlLCBbbmV3IE9wdGlvbmFsKCksIEhBTU1FUl9MT0FERVJdXVxuICAgICAgICB9LFxuICAgICAgICB7IHByb3ZpZGU6IEhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVDb25maWcsIGRlcHM6IFtdIH0sXG4gICAgXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBIYW1tZXJNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEVWRU5UX01BTkFHRVJfUExVR0lOUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VDbGFzczogSGFtbWVyR2VzdHVyZXNQbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW0RPQ1VNRU5ULCBIQU1NRVJfR0VTVFVSRV9DT05GSUcsIMm1Q29uc29sZSwgW25ldyBPcHRpb25hbCgpLCBIQU1NRVJfTE9BREVSXV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IEhhbW1lckdlc3R1cmVDb25maWcsIGRlcHM6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBEb21TYW5pdGl6ZXIgaGVscHMgcHJldmVudGluZyBDcm9zcyBTaXRlIFNjcmlwdGluZyBTZWN1cml0eSBidWdzIChYU1MpIGJ5IHNhbml0aXppbmdcbiAqIHZhbHVlcyB0byBiZSBzYWZlIHRvIHVzZSBpbiB0aGUgZGlmZmVyZW50IERPTSBjb250ZXh0cy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiBiaW5kaW5nIGEgVVJMIGluIGFuIGA8YSBbaHJlZl09XCJzb21lVmFsdWVcIj5gIGh5cGVybGluaywgYHNvbWVWYWx1ZWAgd2lsbCBiZVxuICogc2FuaXRpemVkIHNvIHRoYXQgYW4gYXR0YWNrZXIgY2Fubm90IGluamVjdCBlLmcuIGEgYGphdmFzY3JpcHQ6YCBVUkwgdGhhdCB3b3VsZCBleGVjdXRlIGNvZGUgb25cbiAqIHRoZSB3ZWJzaXRlLlxuICpcbiAqIEluIHNwZWNpZmljIHNpdHVhdGlvbnMsIGl0IG1pZ2h0IGJlIG5lY2Vzc2FyeSB0byBkaXNhYmxlIHNhbml0aXphdGlvbiwgZm9yIGV4YW1wbGUgaWYgdGhlXG4gKiBhcHBsaWNhdGlvbiBnZW51aW5lbHkgbmVlZHMgdG8gcHJvZHVjZSBhIGBqYXZhc2NyaXB0OmAgc3R5bGUgbGluayB3aXRoIGEgZHluYW1pYyB2YWx1ZSBpbiBpdC5cbiAqIFVzZXJzIGNhbiBieXBhc3Mgc2VjdXJpdHkgYnkgY29uc3RydWN0aW5nIGEgdmFsdWUgd2l0aCBvbmUgb2YgdGhlIGBieXBhc3NTZWN1cml0eVRydXN0Li4uYFxuICogbWV0aG9kcywgYW5kIHRoZW4gYmluZGluZyB0byB0aGF0IHZhbHVlIGZyb20gdGhlIHRlbXBsYXRlLlxuICpcbiAqIFRoZXNlIHNpdHVhdGlvbnMgc2hvdWxkIGJlIHZlcnkgcmFyZSwgYW5kIGV4dHJhb3JkaW5hcnkgY2FyZSBtdXN0IGJlIHRha2VuIHRvIGF2b2lkIGNyZWF0aW5nIGFcbiAqIENyb3NzIFNpdGUgU2NyaXB0aW5nIChYU1MpIHNlY3VyaXR5IGJ1ZyFcbiAqXG4gKiBXaGVuIHVzaW5nIGBieXBhc3NTZWN1cml0eVRydXN0Li4uYCwgbWFrZSBzdXJlIHRvIGNhbGwgdGhlIG1ldGhvZCBhcyBlYXJseSBhcyBwb3NzaWJsZSBhbmQgYXNcbiAqIGNsb3NlIGFzIHBvc3NpYmxlIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIHZhbHVlLCB0byBtYWtlIGl0IGVhc3kgdG8gdmVyaWZ5IG5vIHNlY3VyaXR5IGJ1ZyBpc1xuICogY3JlYXRlZCBieSBpdHMgdXNlLlxuICpcbiAqIEl0IGlzIG5vdCByZXF1aXJlZCAoYW5kIG5vdCByZWNvbW1lbmRlZCkgdG8gYnlwYXNzIHNlY3VyaXR5IGlmIHRoZSB2YWx1ZSBpcyBzYWZlLCBlLmcuIGEgVVJMIHRoYXRcbiAqIGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdXNwaWNpb3VzIHByb3RvY29sLCBvciBhbiBIVE1MIHNuaXBwZXQgdGhhdCBkb2VzIG5vdCBjb250YWluIGRhbmdlcm91c1xuICogY29kZS4gVGhlIHNhbml0aXplciBsZWF2ZXMgc2FmZSB2YWx1ZXMgaW50YWN0LlxuICpcbiAqIEBzZWN1cml0eSBDYWxsaW5nIGFueSBvZiB0aGUgYGJ5cGFzc1NlY3VyaXR5VHJ1c3QuLi5gIEFQSXMgZGlzYWJsZXMgQW5ndWxhcidzIGJ1aWx0LWluXG4gKiBzYW5pdGl6YXRpb24gZm9yIHRoZSB2YWx1ZSBwYXNzZWQgaW4uIENhcmVmdWxseSBjaGVjayBhbmQgYXVkaXQgYWxsIHZhbHVlcyBhbmQgY29kZSBwYXRocyBnb2luZ1xuICogaW50byB0aGlzIGNhbGwuIE1ha2Ugc3VyZSBhbnkgdXNlciBkYXRhIGlzIGFwcHJvcHJpYXRlbHkgZXNjYXBlZCBmb3IgdGhpcyBzZWN1cml0eSBjb250ZXh0LlxuICogRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlIFtTZWN1cml0eSBHdWlkZV0oaHR0cHM6Ly9nLmNvL25nL3NlY3VyaXR5KS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIERvbVNhbml0aXplciB7XG59XG5Eb21TYW5pdGl6ZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tU2FuaXRpemVyLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRG9tU2FuaXRpemVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21TYW5pdGl6ZXIsIHByb3ZpZGVkSW46ICdyb290JywgdXNlRXhpc3Rpbmc6IGkwLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRG9tU2FuaXRpemVySW1wbDsgfSkgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tU2FuaXRpemVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRG9tU2FuaXRpemVySW1wbCkgfV1cbiAgICAgICAgfV0gfSk7XG5mdW5jdGlvbiBkb21TYW5pdGl6ZXJJbXBsRmFjdG9yeShpbmplY3Rvcikge1xuICAgIHJldHVybiBuZXcgRG9tU2FuaXRpemVySW1wbChpbmplY3Rvci5nZXQoRE9DVU1FTlQpKTtcbn1cbmNsYXNzIERvbVNhbml0aXplckltcGwgZXh0ZW5kcyBEb21TYW5pdGl6ZXIge1xuICAgIGNvbnN0cnVjdG9yKF9kb2MpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZG9jID0gX2RvYztcbiAgICB9XG4gICAgc2FuaXRpemUoY3R4LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBzd2l0Y2ggKGN0eCkge1xuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuTk9ORTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgICAgIGlmICjJtWFsbG93U2FuaXRpemF0aW9uQnlwYXNzQW5kVGhyb3codmFsdWUsIFwiSFRNTFwiIC8qIEJ5cGFzc1R5cGUuSHRtbCAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIMm1dW53cmFwU2FmZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIMm1X3Nhbml0aXplSHRtbCh0aGlzLl9kb2MsIFN0cmluZyh2YWx1ZSkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgICAgICBpZiAoybVhbGxvd1Nhbml0aXphdGlvbkJ5cGFzc0FuZFRocm93KHZhbHVlLCBcIlN0eWxlXCIgLyogQnlwYXNzVHlwZS5TdHlsZSAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIMm1dW53cmFwU2FmZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuU0NSSVBUOlxuICAgICAgICAgICAgICAgIGlmICjJtWFsbG93U2FuaXRpemF0aW9uQnlwYXNzQW5kVGhyb3codmFsdWUsIFwiU2NyaXB0XCIgLyogQnlwYXNzVHlwZS5TY3JpcHQgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiDJtXVud3JhcFNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlIHZhbHVlIHVzZWQgaW4gYSBzY3JpcHQgY29udGV4dCcpO1xuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgICAgIGlmICjJtWFsbG93U2FuaXRpemF0aW9uQnlwYXNzQW5kVGhyb3codmFsdWUsIFwiVVJMXCIgLyogQnlwYXNzVHlwZS5VcmwgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiDJtXVud3JhcFNhZmVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiDJtV9zYW5pdGl6ZVVybChTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIGNhc2UgU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTDpcbiAgICAgICAgICAgICAgICBpZiAoybVhbGxvd1Nhbml0aXphdGlvbkJ5cGFzc0FuZFRocm93KHZhbHVlLCBcIlJlc291cmNlVVJMXCIgLyogQnlwYXNzVHlwZS5SZXNvdXJjZVVybCAqLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIMm1dW53cmFwU2FmZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bnNhZmUgdmFsdWUgdXNlZCBpbiBhIHJlc291cmNlIFVSTCBjb250ZXh0IChzZWUgJHvJtVhTU19TRUNVUklUWV9VUkx9KWApO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgU2VjdXJpdHlDb250ZXh0ICR7Y3R4fSAoc2VlICR7ybVYU1NfU0VDVVJJVFlfVVJMfSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBieXBhc3NTZWN1cml0eVRydXN0SHRtbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gybVieXBhc3NTYW5pdGl6YXRpb25UcnVzdEh0bWwodmFsdWUpO1xuICAgIH1cbiAgICBieXBhc3NTZWN1cml0eVRydXN0U3R5bGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIMm1YnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTdHlsZSh2YWx1ZSk7XG4gICAgfVxuICAgIGJ5cGFzc1NlY3VyaXR5VHJ1c3RTY3JpcHQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIMm1YnlwYXNzU2FuaXRpemF0aW9uVHJ1c3RTY3JpcHQodmFsdWUpO1xuICAgIH1cbiAgICBieXBhc3NTZWN1cml0eVRydXN0VXJsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiDJtWJ5cGFzc1Nhbml0aXphdGlvblRydXN0VXJsKHZhbHVlKTtcbiAgICB9XG4gICAgYnlwYXNzU2VjdXJpdHlUcnVzdFJlc291cmNlVXJsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiDJtWJ5cGFzc1Nhbml0aXphdGlvblRydXN0UmVzb3VyY2VVcmwodmFsdWUpO1xuICAgIH1cbn1cbkRvbVNhbml0aXplckltcGwuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tU2FuaXRpemVySW1wbCwgZGVwczogW3sgdG9rZW46IERPQ1VNRU5UIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5Eb21TYW5pdGl6ZXJJbXBsLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjdcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb21TYW5pdGl6ZXJJbXBsLCBwcm92aWRlZEluOiAncm9vdCcsIHVzZUZhY3Rvcnk6IGRvbVNhbml0aXplckltcGxGYWN0b3J5LCBkZXBzOiBbeyB0b2tlbjogSW5qZWN0b3IgfV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi43XCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9tU2FuaXRpemVySW1wbCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcsIHVzZUZhY3Rvcnk6IGRvbVNhbml0aXplckltcGxGYWN0b3J5LCBkZXBzOiBbSW5qZWN0b3JdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIHBsYXRmb3JtLWJyb3dzZXIgcGFja2FnZS5cbiAqL1xuLyoqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IFZFUlNJT04gPSBuZXcgVmVyc2lvbignMTUuMi43Jyk7XG5cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoaXMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cblxuLy8gVGhpcyBmaWxlIGlzIG5vdCB1c2VkIHRvIGJ1aWxkIHRoaXMgbW9kdWxlLiBJdCBpcyBvbmx5IHVzZWQgZHVyaW5nIGVkaXRpbmdcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBCcm93c2VyTW9kdWxlLCBCcm93c2VyVHJhbnNmZXJTdGF0ZU1vZHVsZSwgQnksIERvbVNhbml0aXplciwgRVZFTlRfTUFOQUdFUl9QTFVHSU5TLCBFdmVudE1hbmFnZXIsIEhBTU1FUl9HRVNUVVJFX0NPTkZJRywgSEFNTUVSX0xPQURFUiwgSGFtbWVyR2VzdHVyZUNvbmZpZywgSGFtbWVyTW9kdWxlLCBNZXRhLCBSRU1PVkVfU1RZTEVTX09OX0NPTVBPTkVOVF9ERVNUUk9ZLCBUaXRsZSwgVHJhbnNmZXJTdGF0ZSwgVkVSU0lPTiwgYm9vdHN0cmFwQXBwbGljYXRpb24sIGNyZWF0ZUFwcGxpY2F0aW9uLCBkaXNhYmxlRGVidWdUb29scywgZW5hYmxlRGVidWdUb29scywgbWFrZVN0YXRlS2V5LCBwbGF0Zm9ybUJyb3dzZXIsIHByb3ZpZGVQcm90cmFjdG9yVGVzdGluZ1N1cHBvcnQsIEJyb3dzZXJEb21BZGFwdGVyIGFzIMm1QnJvd3NlckRvbUFkYXB0ZXIsIEJyb3dzZXJHZXRUZXN0YWJpbGl0eSBhcyDJtUJyb3dzZXJHZXRUZXN0YWJpbGl0eSwgRG9tRXZlbnRzUGx1Z2luIGFzIMm1RG9tRXZlbnRzUGx1Z2luLCBEb21SZW5kZXJlckZhY3RvcnkyIGFzIMm1RG9tUmVuZGVyZXJGYWN0b3J5MiwgRG9tU2FuaXRpemVySW1wbCBhcyDJtURvbVNhbml0aXplckltcGwsIERvbVNoYXJlZFN0eWxlc0hvc3QgYXMgybVEb21TaGFyZWRTdHlsZXNIb3N0LCBIYW1tZXJHZXN0dXJlc1BsdWdpbiBhcyDJtUhhbW1lckdlc3R1cmVzUGx1Z2luLCBJTlRFUk5BTF9CUk9XU0VSX1BMQVRGT1JNX1BST1ZJREVSUyBhcyDJtUlOVEVSTkFMX0JST1dTRVJfUExBVEZPUk1fUFJPVklERVJTLCBLZXlFdmVudHNQbHVnaW4gYXMgybVLZXlFdmVudHNQbHVnaW4sIE5BTUVTUEFDRV9VUklTIGFzIMm1TkFNRVNQQUNFX1VSSVMsIFNoYXJlZFN0eWxlc0hvc3QgYXMgybVTaGFyZWRTdHlsZXNIb3N0LCBUUkFOU0lUSU9OX0lEIGFzIMm1VFJBTlNJVElPTl9JRCwgZXNjYXBlSHRtbCBhcyDJtWVzY2FwZUh0bWwsIGZsYXR0ZW5TdHlsZXMgYXMgybVmbGF0dGVuU3R5bGVzLCBpbml0RG9tQWRhcHRlciBhcyDJtWluaXREb21BZGFwdGVyLCBzaGltQ29udGVudEF0dHJpYnV0ZSBhcyDJtXNoaW1Db250ZW50QXR0cmlidXRlLCBzaGltSG9zdEF0dHJpYnV0ZSBhcyDJtXNoaW1Ib3N0QXR0cmlidXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS1icm93c2VyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/platform-browser/fesm2020/platform-browser.mjs\n");

/***/ })

}]);