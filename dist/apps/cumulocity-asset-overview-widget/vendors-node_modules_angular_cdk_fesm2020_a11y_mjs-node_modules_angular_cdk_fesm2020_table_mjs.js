"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_angular_cdk_fesm2020_a11y_mjs-node_modules_angular_cdk_fesm2020_table_mjs"],{

/***/ "./node_modules/@angular/cdk/fesm2020/a11y.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/a11y.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"A11yModule\": function() { return /* binding */ A11yModule; },\n/* harmony export */   \"ActiveDescendantKeyManager\": function() { return /* binding */ ActiveDescendantKeyManager; },\n/* harmony export */   \"AriaDescriber\": function() { return /* binding */ AriaDescriber; },\n/* harmony export */   \"CDK_DESCRIBEDBY_HOST_ATTRIBUTE\": function() { return /* binding */ CDK_DESCRIBEDBY_HOST_ATTRIBUTE; },\n/* harmony export */   \"CDK_DESCRIBEDBY_ID_PREFIX\": function() { return /* binding */ CDK_DESCRIBEDBY_ID_PREFIX; },\n/* harmony export */   \"CdkAriaLive\": function() { return /* binding */ CdkAriaLive; },\n/* harmony export */   \"CdkMonitorFocus\": function() { return /* binding */ CdkMonitorFocus; },\n/* harmony export */   \"CdkTrapFocus\": function() { return /* binding */ CdkTrapFocus; },\n/* harmony export */   \"ConfigurableFocusTrap\": function() { return /* binding */ ConfigurableFocusTrap; },\n/* harmony export */   \"ConfigurableFocusTrapFactory\": function() { return /* binding */ ConfigurableFocusTrapFactory; },\n/* harmony export */   \"EventListenerFocusTrapInertStrategy\": function() { return /* binding */ EventListenerFocusTrapInertStrategy; },\n/* harmony export */   \"FOCUS_MONITOR_DEFAULT_OPTIONS\": function() { return /* binding */ FOCUS_MONITOR_DEFAULT_OPTIONS; },\n/* harmony export */   \"FOCUS_TRAP_INERT_STRATEGY\": function() { return /* binding */ FOCUS_TRAP_INERT_STRATEGY; },\n/* harmony export */   \"FocusKeyManager\": function() { return /* binding */ FocusKeyManager; },\n/* harmony export */   \"FocusMonitor\": function() { return /* binding */ FocusMonitor; },\n/* harmony export */   \"FocusTrap\": function() { return /* binding */ FocusTrap; },\n/* harmony export */   \"FocusTrapFactory\": function() { return /* binding */ FocusTrapFactory; },\n/* harmony export */   \"HighContrastModeDetector\": function() { return /* binding */ HighContrastModeDetector; },\n/* harmony export */   \"INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS\": function() { return /* binding */ INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS; },\n/* harmony export */   \"INPUT_MODALITY_DETECTOR_OPTIONS\": function() { return /* binding */ INPUT_MODALITY_DETECTOR_OPTIONS; },\n/* harmony export */   \"InputModalityDetector\": function() { return /* binding */ InputModalityDetector; },\n/* harmony export */   \"InteractivityChecker\": function() { return /* binding */ InteractivityChecker; },\n/* harmony export */   \"IsFocusableConfig\": function() { return /* binding */ IsFocusableConfig; },\n/* harmony export */   \"LIVE_ANNOUNCER_DEFAULT_OPTIONS\": function() { return /* binding */ LIVE_ANNOUNCER_DEFAULT_OPTIONS; },\n/* harmony export */   \"LIVE_ANNOUNCER_ELEMENT_TOKEN\": function() { return /* binding */ LIVE_ANNOUNCER_ELEMENT_TOKEN; },\n/* harmony export */   \"LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY\": function() { return /* binding */ LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY; },\n/* harmony export */   \"ListKeyManager\": function() { return /* binding */ ListKeyManager; },\n/* harmony export */   \"LiveAnnouncer\": function() { return /* binding */ LiveAnnouncer; },\n/* harmony export */   \"MESSAGES_CONTAINER_ID\": function() { return /* binding */ MESSAGES_CONTAINER_ID; },\n/* harmony export */   \"isFakeMousedownFromScreenReader\": function() { return /* binding */ isFakeMousedownFromScreenReader; },\n/* harmony export */   \"isFakeTouchstartFromScreenReader\": function() { return /* binding */ isFakeTouchstartFromScreenReader; }\n/* harmony export */ });\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/fesm2020/platform.mjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/keycodes */ \"./node_modules/@angular/cdk/fesm2020/keycodes.mjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/observers */ \"./node_modules/@angular/cdk/fesm2020/observers.mjs\");\n/* harmony import */ var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/layout */ \"./node_modules/@angular/cdk/fesm2020/layout.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IDs are delimited by an empty space, as per the spec. */\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * ID used for the body container where all messages are appended.\n * @deprecated No longer being used. To be removed.\n * @breaking-change 14.0.0\n */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/**\n * ID prefix used for each created message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/**\n * Attribute given to each host element that is described by a message element.\n * @deprecated To be turned into a private variable.\n * @breaking-change 14.0.0\n */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/**\n * Utility that creates visually hidden elements with a message content. Useful for elements that\n * want to use aria-describedby to further describe themselves without adding additional visual\n * content.\n */\nclass AriaDescriber {\n    constructor(_document, \n    /**\n     * @deprecated To be turned into a required parameter.\n     * @breaking-change 14.0.0\n     */\n    _platform) {\n        this._platform = _platform;\n        /** Map of all registered message elements that have been placed into the document. */\n        this._messageRegistry = new Map();\n        /** Container for all registered messages. */\n        this._messagesContainer = null;\n        /** Unique ID for the service. */\n        this._id = `${nextId++}`;\n        this._document = _document;\n        this._id = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_core__WEBPACK_IMPORTED_MODULE_1__.APP_ID) + '-' + nextId++;\n    }\n    describe(hostElement, message, role) {\n        if (!this._canBeDescribed(hostElement, message)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (typeof message !== 'string') {\n            // We need to ensure that the element has an ID.\n            setMessageId(message, this._id);\n            this._messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n        }\n        else if (!this._messageRegistry.has(key)) {\n            this._createMessageElement(message, role);\n        }\n        if (!this._isElementDescribedByMessage(hostElement, key)) {\n            this._addMessageReference(hostElement, key);\n        }\n    }\n    removeDescription(hostElement, message, role) {\n        if (!message || !this._isElementNode(hostElement)) {\n            return;\n        }\n        const key = getKey(message, role);\n        if (this._isElementDescribedByMessage(hostElement, key)) {\n            this._removeMessageReference(hostElement, key);\n        }\n        // If the message is a string, it means that it's one that we created for the\n        // consumer so we can remove it safely, otherwise we should leave it in place.\n        if (typeof message === 'string') {\n            const registeredMessage = this._messageRegistry.get(key);\n            if (registeredMessage && registeredMessage.referenceCount === 0) {\n                this._deleteMessageElement(key);\n            }\n        }\n        if (this._messagesContainer?.childNodes.length === 0) {\n            this._messagesContainer.remove();\n            this._messagesContainer = null;\n        }\n    }\n    /** Unregisters all created message elements and removes the message container. */\n    ngOnDestroy() {\n        const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}=\"${this._id}\"]`);\n        for (let i = 0; i < describedElements.length; i++) {\n            this._removeCdkDescribedByReferenceIds(describedElements[i]);\n            describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        this._messagesContainer?.remove();\n        this._messagesContainer = null;\n        this._messageRegistry.clear();\n    }\n    /**\n     * Creates a new element in the visually hidden message container element with the message\n     * as its content and adds it to the message registry.\n     */\n    _createMessageElement(message, role) {\n        const messageElement = this._document.createElement('div');\n        setMessageId(messageElement, this._id);\n        messageElement.textContent = message;\n        if (role) {\n            messageElement.setAttribute('role', role);\n        }\n        this._createMessagesContainer();\n        this._messagesContainer.appendChild(messageElement);\n        this._messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n    }\n    /** Deletes the message element from the global messages container. */\n    _deleteMessageElement(key) {\n        this._messageRegistry.get(key)?.messageElement?.remove();\n        this._messageRegistry.delete(key);\n    }\n    /** Creates the global container for all aria-describedby messages. */\n    _createMessagesContainer() {\n        if (this._messagesContainer) {\n            return;\n        }\n        const containerClassName = 'cdk-describedby-message-container';\n        const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform=\"server\"]`);\n        for (let i = 0; i < serverContainers.length; i++) {\n            // When going from the server to the client, we may end up in a situation where there's\n            // already a container on the page, but we don't have a reference to it. Clear the\n            // old container so we don't get duplicates. Doing this, instead of emptying the previous\n            // container, should be slightly faster.\n            serverContainers[i].remove();\n        }\n        const messagesContainer = this._document.createElement('div');\n        // We add `visibility: hidden` in order to prevent text in this container from\n        // being searchable by the browser's Ctrl + F functionality.\n        // Screen-readers will still read the description for elements with aria-describedby even\n        // when the description element is not visible.\n        messagesContainer.style.visibility = 'hidden';\n        // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n        // the description element doesn't impact page layout.\n        messagesContainer.classList.add(containerClassName);\n        messagesContainer.classList.add('cdk-visually-hidden');\n        // @breaking-change 14.0.0 Remove null check for `_platform`.\n        if (this._platform && !this._platform.isBrowser) {\n            messagesContainer.setAttribute('platform', 'server');\n        }\n        this._document.body.appendChild(messagesContainer);\n        this._messagesContainer = messagesContainer;\n    }\n    /** Removes all cdk-describedby messages that are hosted through the element. */\n    _removeCdkDescribedByReferenceIds(element) {\n        // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n        const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby').filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n        element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n    }\n    /**\n     * Adds a message reference to the element using aria-describedby and increments the registered\n     * message's reference count.\n     */\n    _addMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        // Add the aria-describedby reference and set the\n        // describedby_host attribute to mark the element.\n        addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);\n        registeredMessage.referenceCount++;\n    }\n    /**\n     * Removes a message reference from the element using aria-describedby\n     * and decrements the registered message's reference count.\n     */\n    _removeMessageReference(element, key) {\n        const registeredMessage = this._messageRegistry.get(key);\n        registeredMessage.referenceCount--;\n        removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n        element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n    }\n    /** Returns true if the element has been described by the provided message ID. */\n    _isElementDescribedByMessage(element, key) {\n        const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n        const registeredMessage = this._messageRegistry.get(key);\n        const messageId = registeredMessage && registeredMessage.messageElement.id;\n        return !!messageId && referenceIds.indexOf(messageId) != -1;\n    }\n    /** Determines whether a message can be described on a particular element. */\n    _canBeDescribed(element, message) {\n        if (!this._isElementNode(element)) {\n            return false;\n        }\n        if (message && typeof message === 'object') {\n            // We'd have to make some assumptions about the description element's text, if the consumer\n            // passed in an element. Assume that if an element is passed in, the consumer has verified\n            // that it can be used as a description.\n            return true;\n        }\n        const trimmedMessage = message == null ? '' : `${message}`.trim();\n        const ariaLabel = element.getAttribute('aria-label');\n        // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n        // element, because screen readers will end up reading out the same text twice in a row.\n        return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;\n    }\n    /** Checks whether a node is an Element node. */\n    _isElementNode(element) {\n        return element.nodeType === this._document.ELEMENT_NODE;\n    }\n}\nAriaDescriber.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: AriaDescriber, deps: [{ token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nAriaDescriber.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: AriaDescriber, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: AriaDescriber, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }]; } });\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element, serviceId) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n        this._typeaheadSubscription = rxjs__WEBPACK_IMPORTED_MODULE_2__.Subscription.EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        this._homeAndEnd = false;\n        this._pageUpAndDown = { enabled: false, delta: 10 };\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.QueryList) {\n            this._itemChangesSubscription = _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n            this._items.length &&\n            this._items.some(item => typeof item.getLabel !== 'function')) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(letter => this._pressedLetters.push(letter)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.debounceTime)(debounceInterval), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.filter)(() => this._pressedLetters.length > 0), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(() => this._pressedLetters.join('')))\n            .subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    /** Cancels the current typeahead sequence. */\n    cancelTypeahead() {\n        this._pressedLetters = [];\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to activate every 10th, configured or first/last element in up/down direction\n     * respectively when the Page-Up or Page-Down key is pressed.\n     * @param enabled Whether pressing the Page-Up or Page-Down key activates the first/last item.\n     * @param delta Whether pressing the Home or End key activates the first/last item.\n     */\n    withPageUpDown(enabled = true, delta = 10) {\n        this._pageUpAndDown = { enabled, delta };\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.TAB:\n                this.tabOut.next();\n                return;\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.PAGE_UP:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex - this._pageUpAndDown.delta;\n                    this._setActiveItemByIndex(targetIndex > 0 ? targetIndex : 0, 1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            case _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.PAGE_DOWN:\n                if (this._pageUpAndDown.enabled && isModifierAllowed) {\n                    const targetIndex = this._activeItemIndex + this._pageUpAndDown.delta;\n                    const itemsLength = this._getItemsArray().length;\n                    this._setActiveItemByIndex(targetIndex < itemsLength ? targetIndex : itemsLength - 1, -1);\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || (0,_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.hasModifierKey)(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.A && keyCode <= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.Z) || (keyCode >= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.ZERO && keyCode <= _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap\n            ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /** Cleans up the key manager. */\n    destroy() {\n        this._typeaheadSubscription.unsubscribe();\n        this._itemChangesSubscription?.unsubscribe();\n        this._letterKeyStream.complete();\n        this.tabOut.complete();\n        this.change.complete();\n        this._pressedLetters = [];\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + delta * i + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.QueryList ? this._items.toArray() : this._items;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ActiveDescendantKeyManager extends ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass FocusKeyManager extends ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    constructor() {\n        /**\n         * Whether to count an element as focusable even if it is not currently visible.\n         */\n        this.ignoreVisibility = false;\n    }\n}\n// The InteractivityChecker leans heavily on the ally.js accessibility utilities.\n// Methods like `isTabbable` are only covering specific edge-cases for the browsers which are\n// supported.\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n */\nclass InteractivityChecker {\n    constructor(_platform) {\n        this._platform = _platform;\n    }\n    /**\n     * Gets whether an element is disabled.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is disabled.\n     */\n    isDisabled(element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    }\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     *\n     * @returns Whether the element is visible.\n     */\n    isVisible(element) {\n        return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n    }\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     *\n     * @param element Element to be checked.\n     * @returns Whether the element is tabbable.\n     */\n    isTabbable(element) {\n        // Nothing is tabbable on the server 😎\n        if (!this._platform.isBrowser) {\n            return false;\n        }\n        const frameElement = getFrameElement(getWindow(element));\n        if (frameElement) {\n            // Frame elements inherit their tabindex onto all child elements.\n            if (getTabIndexValue(frameElement) === -1) {\n                return false;\n            }\n            // Browsers disable tabbing to an element inside of an invisible frame.\n            if (!this.isVisible(frameElement)) {\n                return false;\n            }\n        }\n        let nodeName = element.nodeName.toLowerCase();\n        let tabIndexValue = getTabIndexValue(element);\n        if (element.hasAttribute('contenteditable')) {\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'iframe' || nodeName === 'object') {\n            // The frame or object's content may be tabbable depending on the content, but it's\n            // not possibly to reliably detect the content of the frames. We always consider such\n            // elements as non-tabbable.\n            return false;\n        }\n        // In iOS, the browser only considers some specific elements as tabbable.\n        if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n            return false;\n        }\n        if (nodeName === 'audio') {\n            // Audio elements without controls enabled are never tabbable, regardless\n            // of the tabindex attribute explicitly being set.\n            if (!element.hasAttribute('controls')) {\n                return false;\n            }\n            // Audio elements with controls are by default tabbable unless the\n            // tabindex attribute is set to `-1` explicitly.\n            return tabIndexValue !== -1;\n        }\n        if (nodeName === 'video') {\n            // For all video elements, if the tabindex attribute is set to `-1`, the video\n            // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n            // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n            // tabindex attribute is the source of truth here.\n            if (tabIndexValue === -1) {\n                return false;\n            }\n            // If the tabindex is explicitly set, and not `-1` (as per check before), the\n            // video element is always tabbable (regardless of whether it has controls or not).\n            if (tabIndexValue !== null) {\n                return true;\n            }\n            // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n            // has controls enabled. Firefox is special as videos are always tabbable regardless\n            // of whether there are controls or not.\n            return this._platform.FIREFOX || element.hasAttribute('controls');\n        }\n        return element.tabIndex >= 0;\n    }\n    /**\n     * Gets whether an element can be focused by the user.\n     *\n     * @param element Element to be checked.\n     * @param config The config object with options to customize this method's behavior\n     * @returns Whether the element is focusable.\n     */\n    isFocusable(element, config) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return (isPotentiallyFocusable(element) &&\n            !this.isDisabled(element) &&\n            (config?.ignoreVisibility || this.isVisible(element)));\n    }\n}\nInteractivityChecker.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InteractivityChecker, deps: [{ token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nInteractivityChecker.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InteractivityChecker, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InteractivityChecker, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }]; } });\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth ||\n        element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return (nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea');\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return (inputType === 'text' ||\n        inputType === 'password' ||\n        nodeName === 'select' ||\n        nodeName === 'textarea');\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return (isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element));\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return (node.ownerDocument && node.ownerDocument.defaultView) || window;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrap {\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            startAnchor.remove();\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            endAnchor.remove();\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady(options) {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` + `[cdkFocusRegion${bound}], ` + `[cdk-focus-${bound}]`);\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            for (let i = 0; i < markers.length; i++) {\n                // @breaking-change 8.0.0\n                if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                        `attribute will be removed in 8.0.0.`, markers[i]);\n                }\n                else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                    console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                        `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                        `will be removed in 8.0.0.`, markers[i]);\n                }\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length\n            ? markers[markers.length - 1]\n            : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement(options) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` + `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild?.focus(options);\n                return !!focusableChild;\n            }\n            redirectToElement.focus(options);\n            return true;\n        }\n        return this.focusFirstTabbableElement(options);\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement(options) {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus(options);\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        const children = root.children;\n        for (let i = 0; i < children.length; i++) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getFirstTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        const children = root.children;\n        for (let i = children.length - 1; i >= 0; i--) {\n            const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE\n                ? this._getLastTabbableElement(children[i])\n                : null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.take)(1)).subscribe(fn);\n        }\n    }\n}\n/**\n * Factory that allows easy instantiation of focus traps.\n * @deprecated Use `ConfigurableFocusTrapFactory` instead.\n * @breaking-change 11.0.0\n */\nclass FocusTrapFactory {\n    constructor(_checker, _ngZone, _document) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n    }\n    /**\n     * Creates a focus-trapped region around the given element.\n     * @param element The element around which focus will be trapped.\n     * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n     *     manually by the user.\n     * @returns The created focus trap instance.\n     */\n    create(element, deferCaptureElements = false) {\n        return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n    }\n}\nFocusTrapFactory.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapFactory, deps: [{ token: InteractivityChecker }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nFocusTrapFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapFactory, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapFactory, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: InteractivityChecker }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n/** Directive for trapping focus within a region. */\nclass CdkTrapFocus {\n    /** Whether the focus trap is active. */\n    get enabled() {\n        return this.focusTrap.enabled;\n    }\n    set enabled(value) {\n        this.focusTrap.enabled = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.coerceBooleanProperty)(value);\n    }\n    /**\n     * Whether the directive should automatically move focus into the trapped region upon\n     * initialization and return focus to the previous activeElement upon destruction.\n     */\n    get autoCapture() {\n        return this._autoCapture;\n    }\n    set autoCapture(value) {\n        this._autoCapture = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.coerceBooleanProperty)(value);\n    }\n    constructor(_elementRef, _focusTrapFactory, \n    /**\n     * @deprecated No longer being used. To be removed.\n     * @breaking-change 13.0.0\n     */\n    _document) {\n        this._elementRef = _elementRef;\n        this._focusTrapFactory = _focusTrapFactory;\n        /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n        this._previouslyFocusedElement = null;\n        this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n    }\n    ngOnDestroy() {\n        this.focusTrap.destroy();\n        // If we stored a previously focused element when using autoCapture, return focus to that\n        // element now that the trapped region is being destroyed.\n        if (this._previouslyFocusedElement) {\n            this._previouslyFocusedElement.focus();\n            this._previouslyFocusedElement = null;\n        }\n    }\n    ngAfterContentInit() {\n        this.focusTrap.attachAnchors();\n        if (this.autoCapture) {\n            this._captureFocus();\n        }\n    }\n    ngDoCheck() {\n        if (!this.focusTrap.hasAttached()) {\n            this.focusTrap.attachAnchors();\n        }\n    }\n    ngOnChanges(changes) {\n        const autoCaptureChange = changes['autoCapture'];\n        if (autoCaptureChange &&\n            !autoCaptureChange.firstChange &&\n            this.autoCapture &&\n            this.focusTrap.hasAttached()) {\n            this._captureFocus();\n        }\n    }\n    _captureFocus() {\n        this._previouslyFocusedElement = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getFocusedElementPierceShadowDom)();\n        this.focusTrap.focusInitialElementWhenReady();\n    }\n}\nCdkTrapFocus.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkTrapFocus, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { token: FocusTrapFactory }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Directive });\nCdkTrapFocus.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkTrapFocus, selector: \"[cdkTrapFocus]\", inputs: { enabled: [\"cdkTrapFocus\", \"enabled\"], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\"] }, exportAs: [\"cdkTrapFocus\"], usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkTrapFocus, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,\n            args: [{\n                    selector: '[cdkTrapFocus]',\n                    exportAs: 'cdkTrapFocus',\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { type: FocusTrapFactory }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; }, propDecorators: { enabled: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,\n                args: ['cdkTrapFocus']\n            }], autoCapture: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,\n                args: ['cdkTrapFocusAutoCapture']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends FocusTrap {\n    /** Whether the FocusTrap is enabled. */\n    get enabled() {\n        return this._enabled;\n    }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('FOCUS_TRAP_INERT_STRATEGY');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (target && !focusTrapRoot.contains(target) && !target.closest?.('div.cdk-overlay-pane')) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injectable that ensures only the most recently enabled FocusTrap is active. */\nclass FocusTrapManager {\n    constructor() {\n        // A stack of the FocusTraps on the page. Only the FocusTrap at the\n        // top of the stack is active.\n        this._focusTrapStack = [];\n    }\n    /**\n     * Disables the FocusTrap at the top of the stack, and then pushes\n     * the new FocusTrap onto the stack.\n     */\n    register(focusTrap) {\n        // Dedupe focusTraps that register multiple times.\n        this._focusTrapStack = this._focusTrapStack.filter(ft => ft !== focusTrap);\n        let stack = this._focusTrapStack;\n        if (stack.length) {\n            stack[stack.length - 1]._disable();\n        }\n        stack.push(focusTrap);\n        focusTrap._enable();\n    }\n    /**\n     * Removes the FocusTrap from the stack, and activates the\n     * FocusTrap that is the new top of the stack.\n     */\n    deregister(focusTrap) {\n        focusTrap._disable();\n        const stack = this._focusTrapStack;\n        const i = stack.indexOf(focusTrap);\n        if (i !== -1) {\n            stack.splice(i, 1);\n            if (stack.length) {\n                stack[stack.length - 1]._enable();\n            }\n        }\n    }\n}\nFocusTrapManager.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapManager, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nFocusTrapManager.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapManager, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusTrapManager, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Factory that allows easy instantiation of configurable focus traps. */\nclass ConfigurableFocusTrapFactory {\n    constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._focusTrapManager = _focusTrapManager;\n        this._document = _document;\n        // TODO split up the strategies into different modules, similar to DateAdapter.\n        this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n    }\n    create(element, config = { defer: false }) {\n        let configObject;\n        if (typeof config === 'boolean') {\n            configObject = { defer: config };\n        }\n        else {\n            configObject = config;\n        }\n        return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n    }\n}\nConfigurableFocusTrapFactory.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: ConfigurableFocusTrapFactory, deps: [{ token: InteractivityChecker }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: FocusTrapManager }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }, { token: FOCUS_TRAP_INERT_STRATEGY, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nConfigurableFocusTrapFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: ConfigurableFocusTrapFactory, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: ConfigurableFocusTrapFactory, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: InteractivityChecker }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: FocusTrapManager }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [FOCUS_TRAP_INERT_STRATEGY]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // Some screen readers will dispatch a fake `mousedown` event when pressing enter or space on\n    // a clickable element. We can distinguish these events when both `offsetX` and `offsetY` are\n    // zero or `event.buttons` is zero, depending on the browser:\n    // - `event.buttons` works on Firefox, but fails on Chrome.\n    // - `offsetX` and `offsetY` work on Chrome, but fail on Firefox.\n    // Note that there's an edge case where the user could click the 0x0 spot of the\n    // screen themselves, but that is unlikely to contain interactive elements.\n    return event.buttons === 0 || (event.offsetX === 0 && event.offsetY === 0);\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) || (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return (!!touch &&\n        touch.identifier === -1 &&\n        (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injectable options for the InputModalityDetector. These are shallowly merged with the default\n * options.\n */\nconst INPUT_MODALITY_DETECTOR_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('cdk-input-modality-detector-options');\n/**\n * Default options for the InputModalityDetector.\n *\n * Modifier keys are ignored by default (i.e. when pressed won't cause the service to detect\n * keyboard input modality) for two reasons:\n *\n * 1. Modifier keys are commonly used with mouse to perform actions such as 'right click' or 'open\n *    in new tab', and are thus less representative of actual keyboard interaction.\n * 2. VoiceOver triggers some keyboard events when linearly navigating with Control + Option (but\n *    confusingly not with Caps Lock). Thus, to have parity with other screen readers, we ignore\n *    these keys so as to not update the input modality.\n *\n * Note that we do not by default ignore the right Meta key on Safari because it has the same key\n * code as the ContextMenu key on other browsers. When we switch to using event.key, we can\n * distinguish between the two.\n */\nconst INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {\n    ignoreKeys: [_angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.ALT, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.CONTROL, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.MAC_META, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.META, _angular_cdk_keycodes__WEBPACK_IMPORTED_MODULE_5__.SHIFT],\n};\n/**\n * The amount of time needed to pass after a touchstart event in order for a subsequent mousedown\n * event to be attributed as mouse and not touch.\n *\n * This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n * that a value of around 650ms seems appropriate.\n */\nconst TOUCH_BUFFER_MS = 650;\n/**\n * Event listener options that enable capturing and also mark the listener as passive if the browser\n * supports it.\n */\nconst modalityEventListenerOptions = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.normalizePassiveListenerOptions)({\n    passive: true,\n    capture: true,\n});\n/**\n * Service that detects the user's input modality.\n *\n * This service does not update the input modality when a user navigates with a screen reader\n * (e.g. linear navigation with VoiceOver, object navigation / browse mode with NVDA, virtual PC\n * cursor mode with JAWS). This is in part due to technical limitations (i.e. keyboard events do not\n * fire as expected in these modes) but is also arguably the correct behavior. Navigating with a\n * screen reader is akin to visually scanning a page, and should not be interpreted as actual user\n * input interaction.\n *\n * When a user is not navigating but *interacting* with a screen reader, this service attempts to\n * update the input modality to keyboard, but in general this service's behavior is largely\n * undefined.\n */\nclass InputModalityDetector {\n    /** The most recently detected input modality. */\n    get mostRecentModality() {\n        return this._modality.value;\n    }\n    constructor(_platform, ngZone, document, options) {\n        this._platform = _platform;\n        /**\n         * The most recently detected input modality event target. Is null if no input modality has been\n         * detected or if the associated event target is null for some unknown reason.\n         */\n        this._mostRecentTarget = null;\n        /** The underlying BehaviorSubject that emits whenever an input modality is detected. */\n        this._modality = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);\n        /**\n         * The timestamp of the last touch input modality. Used to determine whether mousedown events\n         * should be attributed to mouse or touch.\n         */\n        this._lastTouchMs = 0;\n        /**\n         * Handles keydown events. Must be an arrow function in order to preserve the context when it gets\n         * bound.\n         */\n        this._onKeydown = (event) => {\n            // If this is one of the keys we should ignore, then ignore it and don't update the input\n            // modality to keyboard.\n            if (this._options?.ignoreKeys?.some(keyCode => keyCode === event.keyCode)) {\n                return;\n            }\n            this._modality.next('keyboard');\n            this._mostRecentTarget = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getEventTarget)(event);\n        };\n        /**\n         * Handles mousedown events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onMousedown = (event) => {\n            // Touches trigger both touch and mouse events, so we need to distinguish between mouse events\n            // that were triggered via mouse vs touch. To do so, check if the mouse event occurs closely\n            // after the previous touch event.\n            if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {\n                return;\n            }\n            // Fake mousedown events are fired by some screen readers when controls are activated by the\n            // screen reader. Attribute them to keyboard input modality.\n            this._modality.next(isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse');\n            this._mostRecentTarget = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getEventTarget)(event);\n        };\n        /**\n         * Handles touchstart events. Must be an arrow function in order to preserve the context when it\n         * gets bound.\n         */\n        this._onTouchstart = (event) => {\n            // Same scenario as mentioned in _onMousedown, but on touch screen devices, fake touchstart\n            // events are fired. Again, attribute to keyboard input modality.\n            if (isFakeTouchstartFromScreenReader(event)) {\n                this._modality.next('keyboard');\n                return;\n            }\n            // Store the timestamp of this touch event, as it's used to distinguish between mouse events\n            // triggered via mouse vs touch.\n            this._lastTouchMs = Date.now();\n            this._modality.next('touch');\n            this._mostRecentTarget = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getEventTarget)(event);\n        };\n        this._options = {\n            ...INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS,\n            ...options,\n        };\n        // Skip the first emission as it's null.\n        this.modalityDetected = this._modality.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.skip)(1));\n        this.modalityChanged = this.modalityDetected.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.distinctUntilChanged)());\n        // If we're not in a browser, this service should do nothing, as there's no relevant input\n        // modality to detect.\n        if (_platform.isBrowser) {\n            ngZone.runOutsideAngular(() => {\n                document.addEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n                document.addEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n                document.addEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n            });\n        }\n    }\n    ngOnDestroy() {\n        this._modality.complete();\n        if (this._platform.isBrowser) {\n            document.removeEventListener('keydown', this._onKeydown, modalityEventListenerOptions);\n            document.removeEventListener('mousedown', this._onMousedown, modalityEventListenerOptions);\n            document.removeEventListener('touchstart', this._onTouchstart, modalityEventListenerOptions);\n        }\n    }\n}\nInputModalityDetector.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InputModalityDetector, deps: [{ token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }, { token: INPUT_MODALITY_DETECTOR_OPTIONS, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nInputModalityDetector.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InputModalityDetector, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: InputModalityDetector, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: Document, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [INPUT_MODALITY_DETECTOR_OPTIONS]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet uniqueIds = 0;\nclass LiveAnnouncer {\n    constructor(elementToken, _ngZone, _document, _defaultOptions) {\n        this._ngZone = _ngZone;\n        this._defaultOptions = _defaultOptions;\n        // We inject the live element and document as `any` because the constructor signature cannot\n        // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n        // a class decorator causes TypeScript to preserve the constructor signature types.\n        this._document = _document;\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    announce(message, ...args) {\n        const defaultOptions = this._defaultOptions;\n        let politeness;\n        let duration;\n        if (args.length === 1 && typeof args[0] === 'number') {\n            duration = args[0];\n        }\n        else {\n            [politeness, duration] = args;\n        }\n        this.clear();\n        clearTimeout(this._previousTimeout);\n        if (!politeness) {\n            politeness =\n                defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : 'polite';\n        }\n        if (duration == null && defaultOptions) {\n            duration = defaultOptions.duration;\n        }\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        if (this._liveElement.id) {\n            this._exposeAnnouncerToModals(this._liveElement.id);\n        }\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        return this._ngZone.runOutsideAngular(() => {\n            if (!this._currentPromise) {\n                this._currentPromise = new Promise(resolve => (this._currentResolve = resolve));\n            }\n            clearTimeout(this._previousTimeout);\n            this._previousTimeout = setTimeout(() => {\n                this._liveElement.textContent = message;\n                if (typeof duration === 'number') {\n                    this._previousTimeout = setTimeout(() => this.clear(), duration);\n                }\n                this._currentResolve();\n                this._currentPromise = this._currentResolve = undefined;\n            }, 100);\n            return this._currentPromise;\n        });\n    }\n    /**\n     * Clears the current text from the announcer element. Can be used to prevent\n     * screen readers from reading the text out again while the user is going\n     * through the page landmarks.\n     */\n    clear() {\n        if (this._liveElement) {\n            this._liveElement.textContent = '';\n        }\n    }\n    ngOnDestroy() {\n        clearTimeout(this._previousTimeout);\n        this._liveElement?.remove();\n        this._liveElement = null;\n        this._currentResolve?.();\n        this._currentPromise = this._currentResolve = undefined;\n    }\n    _createLiveElement() {\n        const elementClass = 'cdk-live-announcer-element';\n        const previousElements = this._document.getElementsByClassName(elementClass);\n        const liveEl = this._document.createElement('div');\n        // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n        for (let i = 0; i < previousElements.length; i++) {\n            previousElements[i].remove();\n        }\n        liveEl.classList.add(elementClass);\n        liveEl.classList.add('cdk-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        liveEl.id = `cdk-live-announcer-${uniqueIds++}`;\n        this._document.body.appendChild(liveEl);\n        return liveEl;\n    }\n    /**\n     * Some browsers won't expose the accessibility node of the live announcer element if there is an\n     * `aria-modal` and the live announcer is outside of it. This method works around the issue by\n     * pointing the `aria-owns` of all modals to the live announcer element.\n     */\n    _exposeAnnouncerToModals(id) {\n        // Note that the selector here is limited to CDK overlays at the moment in order to reduce the\n        // section of the DOM we need to look through. This should cover all the cases we support, but\n        // the selector can be expanded if it turns out to be too narrow.\n        const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal=\"true\"]');\n        for (let i = 0; i < modals.length; i++) {\n            const modal = modals[i];\n            const ariaOwns = modal.getAttribute('aria-owns');\n            if (!ariaOwns) {\n                modal.setAttribute('aria-owns', id);\n            }\n            else if (ariaOwns.indexOf(id) === -1) {\n                modal.setAttribute('aria-owns', ariaOwns + ' ' + id);\n            }\n        }\n    }\n}\nLiveAnnouncer.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: LiveAnnouncer, deps: [{ token: LIVE_ANNOUNCER_ELEMENT_TOKEN, optional: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }, { token: LIVE_ANNOUNCER_DEFAULT_OPTIONS, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nLiveAnnouncer.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: LiveAnnouncer, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: LiveAnnouncer, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]\n                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]\n                }] }]; } });\n/**\n * A directive that works similarly to aria-live, but uses the LiveAnnouncer to ensure compatibility\n * with a wider range of browsers and screen readers.\n */\nclass CdkAriaLive {\n    /** The aria-live politeness level to use when announcing messages. */\n    get politeness() {\n        return this._politeness;\n    }\n    set politeness(value) {\n        this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n        if (this._politeness === 'off') {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n                this._subscription = null;\n            }\n        }\n        else if (!this._subscription) {\n            this._subscription = this._ngZone.runOutsideAngular(() => {\n                return this._contentObserver.observe(this._elementRef).subscribe(() => {\n                    // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                    const elementText = this._elementRef.nativeElement.textContent;\n                    // The `MutationObserver` fires also for attribute\n                    // changes which we don't want to announce.\n                    if (elementText !== this._previousAnnouncedText) {\n                        this._liveAnnouncer.announce(elementText, this._politeness, this.duration);\n                        this._previousAnnouncedText = elementText;\n                    }\n                });\n            });\n        }\n    }\n    constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n        this._elementRef = _elementRef;\n        this._liveAnnouncer = _liveAnnouncer;\n        this._contentObserver = _contentObserver;\n        this._ngZone = _ngZone;\n        this._politeness = 'polite';\n    }\n    ngOnDestroy() {\n        if (this._subscription) {\n            this._subscription.unsubscribe();\n        }\n    }\n}\nCdkAriaLive.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkAriaLive, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { token: LiveAnnouncer }, { token: _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__.ContentObserver }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Directive });\nCdkAriaLive.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkAriaLive, selector: \"[cdkAriaLive]\", inputs: { politeness: [\"cdkAriaLive\", \"politeness\"], duration: [\"cdkAriaLiveDuration\", \"duration\"] }, exportAs: [\"cdkAriaLive\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkAriaLive, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,\n            args: [{\n                    selector: '[cdkAriaLive]',\n                    exportAs: 'cdkAriaLive',\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { type: LiveAnnouncer }, { type: _angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__.ContentObserver }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }]; }, propDecorators: { politeness: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,\n                args: ['cdkAriaLive']\n            }], duration: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Input,\n                args: ['cdkAriaLiveDuration']\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.normalizePassiveListenerOptions)({\n    passive: true,\n    capture: true,\n});\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\nclass FocusMonitor {\n    constructor(_ngZone, _platform, _inputModalityDetector, \n    /** @breaking-change 11.0.0 make document required */\n    document, options) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        this._inputModalityDetector = _inputModalityDetector;\n        /** The focus origin that the next focus event is a result of. */\n        this._origin = null;\n        /** Whether the window has just been focused. */\n        this._windowFocused = false;\n        /**\n         * Whether the origin was determined via a touch interaction. Necessary as properly attributing\n         * focus events to touch interactions requires special logic.\n         */\n        this._originFromTouchInteraction = false;\n        /** Map of elements being monitored to their info. */\n        this._elementInfo = new Map();\n        /** The number of elements currently being monitored. */\n        this._monitoredElementCount = 0;\n        /**\n         * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n         * as well as the number of monitored elements that they contain. We have to treat focus/blur\n         * handlers differently from the rest of the events, because the browser won't emit events\n         * to the document when focus moves inside of a shadow root.\n         */\n        this._rootNodeFocusListenerCount = new Map();\n        /**\n         * Event listener for `focus` events on the window.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._windowFocusListener = () => {\n            // Make a note of when the window regains focus, so we can\n            // restore the origin info for the focused element.\n            this._windowFocused = true;\n            this._windowFocusTimeoutId = window.setTimeout(() => (this._windowFocused = false));\n        };\n        /** Subject for stopping our InputModalityDetector subscription. */\n        this._stopInputModalityDetector = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();\n        /**\n         * Event listener for `focus` and 'blur' events on the document.\n         * Needs to be an arrow function in order to preserve the context when it gets bound.\n         */\n        this._rootNodeFocusAndBlurListener = (event) => {\n            const target = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getEventTarget)(event);\n            // We need to walk up the ancestor chain in order to support `checkChildren`.\n            for (let element = target; element; element = element.parentElement) {\n                if (event.type === 'focus') {\n                    this._onFocus(event, element);\n                }\n                else {\n                    this._onBlur(event, element);\n                }\n            }\n        };\n        this._document = document;\n        this._detectionMode = options?.detectionMode || 0 /* FocusMonitorDetectionMode.IMMEDIATE */;\n    }\n    monitor(element, checkChildren = false) {\n        const nativeElement = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.coerceElement)(element);\n        // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n        if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n            return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.of)(null);\n        }\n        // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n        // the shadow root, rather than the `document`, because the browser won't emit focus events\n        // to the `document`, if focus is moving within the same shadow root.\n        const rootNode = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getShadowRoot)(nativeElement) || this._getDocument();\n        const cachedInfo = this._elementInfo.get(nativeElement);\n        // Check if we're already monitoring this element.\n        if (cachedInfo) {\n            if (checkChildren) {\n                // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                // robust solution.\n                cachedInfo.checkChildren = true;\n            }\n            return cachedInfo.subject;\n        }\n        // Create monitored element info.\n        const info = {\n            checkChildren: checkChildren,\n            subject: new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject(),\n            rootNode,\n        };\n        this._elementInfo.set(nativeElement, info);\n        this._registerGlobalListeners(info);\n        return info.subject;\n    }\n    stopMonitoring(element) {\n        const nativeElement = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.coerceElement)(element);\n        const elementInfo = this._elementInfo.get(nativeElement);\n        if (elementInfo) {\n            elementInfo.subject.complete();\n            this._setClasses(nativeElement);\n            this._elementInfo.delete(nativeElement);\n            this._removeGlobalListeners(elementInfo);\n        }\n    }\n    focusVia(element, origin, options) {\n        const nativeElement = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_6__.coerceElement)(element);\n        const focusedElement = this._getDocument().activeElement;\n        // If the element is focused already, calling `focus` again won't trigger the event listener\n        // which means that the focus classes won't be updated. If that's the case, update the classes\n        // directly without waiting for an event.\n        if (nativeElement === focusedElement) {\n            this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n        }\n        else {\n            this._setOrigin(origin);\n            // `focus` isn't available on the server\n            if (typeof nativeElement.focus === 'function') {\n                nativeElement.focus(options);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n    }\n    /** Access injected document if available or fallback to global document reference */\n    _getDocument() {\n        return this._document || document;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        const doc = this._getDocument();\n        return doc.defaultView || window;\n    }\n    _getFocusOrigin(focusEventTarget) {\n        if (this._origin) {\n            // If the origin was realized via a touch interaction, we need to perform additional checks\n            // to determine whether the focus origin should be attributed to touch or program.\n            if (this._originFromTouchInteraction) {\n                return this._shouldBeAttributedToTouch(focusEventTarget) ? 'touch' : 'program';\n            }\n            else {\n                return this._origin;\n            }\n        }\n        // If the window has just regained focus, we can restore the most recent origin from before the\n        // window blurred. Otherwise, we've reached the point where we can't identify the source of the\n        // focus. This typically means one of two things happened:\n        //\n        // 1) The element was programmatically focused, or\n        // 2) The element was focused via screen reader navigation (which generally doesn't fire\n        //    events).\n        //\n        // Because we can't distinguish between these two cases, we default to setting `program`.\n        if (this._windowFocused && this._lastFocusOrigin) {\n            return this._lastFocusOrigin;\n        }\n        // If the interaction is coming from an input label, we consider it a mouse interactions.\n        // This is a special case where focus moves on `click`, rather than `mousedown` which breaks\n        // our detection, because all our assumptions are for `mousedown`. We need to handle this\n        // special case, because it's very common for checkboxes and radio buttons.\n        if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {\n            return 'mouse';\n        }\n        return 'program';\n    }\n    /**\n     * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a\n     * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we\n     * handle a focus event following a touch interaction, we need to determine whether (1) the focus\n     * event was directly caused by the touch interaction or (2) the focus event was caused by a\n     * subsequent programmatic focus call triggered by the touch interaction.\n     * @param focusEventTarget The target of the focus event under examination.\n     */\n    _shouldBeAttributedToTouch(focusEventTarget) {\n        // Please note that this check is not perfect. Consider the following edge case:\n        //\n        // <div #parent tabindex=\"0\">\n        //   <div #child tabindex=\"0\" (click)=\"#parent.focus()\"></div>\n        // </div>\n        //\n        // Suppose there is a FocusMonitor in IMMEDIATE mode attached to #parent. When the user touches\n        // #child, #parent is programmatically focused. This code will attribute the focus to touch\n        // instead of program. This is a relatively minor edge-case that can be worked around by using\n        // focusVia(parent, 'program') to focus #parent.\n        return (this._detectionMode === 1 /* FocusMonitorDetectionMode.EVENTUAL */ ||\n            !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget));\n    }\n    /**\n     * Sets the focus classes on the element based on the given focus origin.\n     * @param element The element to update the classes on.\n     * @param origin The focus origin.\n     */\n    _setClasses(element, origin) {\n        element.classList.toggle('cdk-focused', !!origin);\n        element.classList.toggle('cdk-touch-focused', origin === 'touch');\n        element.classList.toggle('cdk-keyboard-focused', origin === 'keyboard');\n        element.classList.toggle('cdk-mouse-focused', origin === 'mouse');\n        element.classList.toggle('cdk-program-focused', origin === 'program');\n    }\n    /**\n     * Updates the focus origin. If we're using immediate detection mode, we schedule an async\n     * function to clear the origin at the end of a timeout. The duration of the timeout depends on\n     * the origin being set.\n     * @param origin The origin to set.\n     * @param isFromInteraction Whether we are setting the origin from an interaction event.\n     */\n    _setOrigin(origin, isFromInteraction = false) {\n        this._ngZone.runOutsideAngular(() => {\n            this._origin = origin;\n            this._originFromTouchInteraction = origin === 'touch' && isFromInteraction;\n            // If we're in IMMEDIATE mode, reset the origin at the next tick (or in `TOUCH_BUFFER_MS` ms\n            // for a touch event). We reset the origin at the next tick because Firefox focuses one tick\n            // after the interaction event. We wait `TOUCH_BUFFER_MS` ms before resetting the origin for\n            // a touch event because when a touch event is fired, the associated focus event isn't yet in\n            // the event queue. Before doing so, clear any pending timeouts.\n            if (this._detectionMode === 0 /* FocusMonitorDetectionMode.IMMEDIATE */) {\n                clearTimeout(this._originTimeoutId);\n                const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;\n                this._originTimeoutId = setTimeout(() => (this._origin = null), ms);\n            }\n        });\n    }\n    /**\n     * Handles focus events on a registered element.\n     * @param event The focus event.\n     * @param element The monitored element.\n     */\n    _onFocus(event, element) {\n        // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n        // focus event affecting the monitored element. If we want to use the origin of the first event\n        // instead we should check for the cdk-focused class here and return if the element already has\n        // it. (This only matters for elements that have includesChildren = true).\n        // If we are not counting child-element-focus as focused, make sure that the event target is the\n        // monitored element itself.\n        const elementInfo = this._elementInfo.get(element);\n        const focusEventTarget = (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__._getEventTarget)(event);\n        if (!elementInfo || (!elementInfo.checkChildren && element !== focusEventTarget)) {\n            return;\n        }\n        this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);\n    }\n    /**\n     * Handles blur events on a registered element.\n     * @param event The blur event.\n     * @param element The monitored element.\n     */\n    _onBlur(event, element) {\n        // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n        // order to focus another child of the monitored element.\n        const elementInfo = this._elementInfo.get(element);\n        if (!elementInfo ||\n            (elementInfo.checkChildren &&\n                event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n            return;\n        }\n        this._setClasses(element);\n        this._emitOrigin(elementInfo, null);\n    }\n    _emitOrigin(info, origin) {\n        if (info.subject.observers.length) {\n            this._ngZone.run(() => info.subject.next(origin));\n        }\n    }\n    _registerGlobalListeners(elementInfo) {\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        const rootNode = elementInfo.rootNode;\n        const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n        if (!rootNodeFocusListeners) {\n            this._ngZone.runOutsideAngular(() => {\n                rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n            });\n        }\n        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n        // Register global listeners when first element is monitored.\n        if (++this._monitoredElementCount === 1) {\n            // Note: we listen to events in the capture phase so we\n            // can detect them even if the user stops propagation.\n            this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                window.addEventListener('focus', this._windowFocusListener);\n            });\n            // The InputModalityDetector is also just a collection of global listeners.\n            this._inputModalityDetector.modalityDetected\n                .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.takeUntil)(this._stopInputModalityDetector))\n                .subscribe(modality => {\n                this._setOrigin(modality, true /* isFromInteraction */);\n            });\n        }\n    }\n    _removeGlobalListeners(elementInfo) {\n        const rootNode = elementInfo.rootNode;\n        if (this._rootNodeFocusListenerCount.has(rootNode)) {\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n            if (rootNodeFocusListeners > 1) {\n                this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n            }\n            else {\n                rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                this._rootNodeFocusListenerCount.delete(rootNode);\n            }\n        }\n        // Unregister global listeners when last element is unmonitored.\n        if (!--this._monitoredElementCount) {\n            const window = this._getWindow();\n            window.removeEventListener('focus', this._windowFocusListener);\n            // Equivalently, stop our InputModalityDetector subscription.\n            this._stopInputModalityDetector.next();\n            // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n            clearTimeout(this._windowFocusTimeoutId);\n            clearTimeout(this._originTimeoutId);\n        }\n    }\n    /** Updates all the state on an element once its focus origin has changed. */\n    _originChanged(element, origin, elementInfo) {\n        this._setClasses(element, origin);\n        this._emitOrigin(elementInfo, origin);\n        this._lastFocusOrigin = origin;\n    }\n    /**\n     * Collects the `MonitoredElementInfo` of a particular element and\n     * all of its ancestors that have enabled `checkChildren`.\n     * @param element Element from which to start the search.\n     */\n    _getClosestElementsInfo(element) {\n        const results = [];\n        this._elementInfo.forEach((info, currentElement) => {\n            if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                results.push([currentElement, info]);\n            }\n        });\n        return results;\n    }\n    /**\n     * Returns whether an interaction is likely to have come from the user clicking the `label` of\n     * an `input` or `textarea` in order to focus it.\n     * @param focusEventTarget Target currently receiving focus.\n     */\n    _isLastInteractionFromInputLabel(focusEventTarget) {\n        const { _mostRecentTarget: mostRecentTarget, mostRecentModality } = this._inputModalityDetector;\n        // If the last interaction used the mouse on an element contained by one of the labels\n        // of an `input`/`textarea` that is currently focused, it is very likely that the\n        // user redirected focus using the label.\n        if (mostRecentModality !== 'mouse' ||\n            !mostRecentTarget ||\n            mostRecentTarget === focusEventTarget ||\n            (focusEventTarget.nodeName !== 'INPUT' && focusEventTarget.nodeName !== 'TEXTAREA') ||\n            focusEventTarget.disabled) {\n            return false;\n        }\n        const labels = focusEventTarget.labels;\n        if (labels) {\n            for (let i = 0; i < labels.length; i++) {\n                if (labels[i].contains(mostRecentTarget)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\nFocusMonitor.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusMonitor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { token: InputModalityDetector }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT, optional: true }, { token: FOCUS_MONITOR_DEFAULT_OPTIONS, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nFocusMonitor.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusMonitor, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: FocusMonitor, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgZone }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { type: InputModalityDetector }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [FOCUS_MONITOR_DEFAULT_OPTIONS]\n                }] }]; } });\n/**\n * Directive that determines how a particular element was focused (via keyboard, mouse, touch, or\n * programmatically) and adds corresponding classes to the element.\n *\n * There are two variants of this directive:\n * 1) cdkMonitorElementFocus: does not consider an element to be focused if one of its children is\n *    focused.\n * 2) cdkMonitorSubtreeFocus: considers an element focused if it or any of its children are focused.\n */\nclass CdkMonitorFocus {\n    constructor(_elementRef, _focusMonitor) {\n        this._elementRef = _elementRef;\n        this._focusMonitor = _focusMonitor;\n        this._focusOrigin = null;\n        this.cdkFocusChange = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n    }\n    get focusOrigin() {\n        return this._focusOrigin;\n    }\n    ngAfterViewInit() {\n        const element = this._elementRef.nativeElement;\n        this._monitorSubscription = this._focusMonitor\n            .monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n            .subscribe(origin => {\n            this._focusOrigin = origin;\n            this.cdkFocusChange.emit(origin);\n        });\n    }\n    ngOnDestroy() {\n        this._focusMonitor.stopMonitoring(this._elementRef);\n        if (this._monitorSubscription) {\n            this._monitorSubscription.unsubscribe();\n        }\n    }\n}\nCdkMonitorFocus.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkMonitorFocus, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { token: FocusMonitor }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Directive });\nCdkMonitorFocus.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkMonitorFocus, selector: \"[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]\", outputs: { cdkFocusChange: \"cdkFocusChange\" }, exportAs: [\"cdkMonitorFocus\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: CdkMonitorFocus, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Directive,\n            args: [{\n                    selector: '[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]',\n                    exportAs: 'cdkMonitorFocus',\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ElementRef }, { type: FocusMonitor }]; }, propDecorators: { cdkFocusChange: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Output\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\n/**\n * Service to determine whether the browser is currently in a high-contrast-mode environment.\n *\n * Microsoft Windows supports an accessibility feature called \"High Contrast Mode\". This mode\n * changes the appearance of all applications, including web applications, to dramatically increase\n * contrast.\n *\n * IE, Edge, and Firefox currently support this mode. Chrome does not support Windows High Contrast\n * Mode. This service does not detect high-contrast mode as added by the Chrome \"High Contrast\"\n * browser extension.\n */\nclass HighContrastModeDetector {\n    constructor(_platform, document) {\n        this._platform = _platform;\n        this._document = document;\n        this._breakpointSubscription = (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_8__.BreakpointObserver)\n            .observe('(forced-colors: active)')\n            .subscribe(() => {\n            if (this._hasCheckedHighContrastMode) {\n                this._hasCheckedHighContrastMode = false;\n                this._applyBodyHighContrastModeCssClasses();\n            }\n        });\n    }\n    /** Gets the current high-contrast-mode for the page. */\n    getHighContrastMode() {\n        if (!this._platform.isBrowser) {\n            return 0 /* HighContrastMode.NONE */;\n        }\n        // Create a test element with an arbitrary background-color that is neither black nor\n        // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n        // appending the test element to the DOM does not affect layout by absolutely positioning it\n        const testElement = this._document.createElement('div');\n        testElement.style.backgroundColor = 'rgb(1,2,3)';\n        testElement.style.position = 'absolute';\n        this._document.body.appendChild(testElement);\n        // Get the computed style for the background color, collapsing spaces to normalize between\n        // browsers. Once we get this color, we no longer need the test element. Access the `window`\n        // via the document so we can fake it in tests. Note that we have extra null checks, because\n        // this logic will likely run during app bootstrap and throwing can break the entire app.\n        const documentWindow = this._document.defaultView || window;\n        const computedStyle = documentWindow && documentWindow.getComputedStyle\n            ? documentWindow.getComputedStyle(testElement)\n            : null;\n        const computedColor = ((computedStyle && computedStyle.backgroundColor) || '').replace(/ /g, '');\n        testElement.remove();\n        switch (computedColor) {\n            // Pre Windows 11 dark theme.\n            case 'rgb(0,0,0)':\n            // Windows 11 dark themes.\n            case 'rgb(45,50,54)':\n            case 'rgb(32,32,32)':\n                return 2 /* HighContrastMode.WHITE_ON_BLACK */;\n            // Pre Windows 11 light theme.\n            case 'rgb(255,255,255)':\n            // Windows 11 light theme.\n            case 'rgb(255,250,239)':\n                return 1 /* HighContrastMode.BLACK_ON_WHITE */;\n        }\n        return 0 /* HighContrastMode.NONE */;\n    }\n    ngOnDestroy() {\n        this._breakpointSubscription.unsubscribe();\n    }\n    /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n    _applyBodyHighContrastModeCssClasses() {\n        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {\n            const bodyClasses = this._document.body.classList;\n            bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            this._hasCheckedHighContrastMode = true;\n            const mode = this.getHighContrastMode();\n            if (mode === 1 /* HighContrastMode.BLACK_ON_WHITE */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);\n            }\n            else if (mode === 2 /* HighContrastMode.WHITE_ON_BLACK */) {\n                bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);\n            }\n        }\n    }\n}\nHighContrastModeDetector.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HighContrastModeDetector, deps: [{ token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nHighContrastModeDetector.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HighContrastModeDetector, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: HighContrastModeDetector, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_4__.Platform }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass A11yModule {\n    constructor(highContrastModeDetector) {\n        highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n    }\n}\nA11yModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: A11yModule, deps: [{ token: HighContrastModeDetector }], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].NgModule });\nA11yModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: A11yModule, declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus], imports: [_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__.ObserversModule], exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus] });\nA11yModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: A11yModule, imports: [_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__.ObserversModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: A11yModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,\n            args: [{\n                    imports: [_angular_cdk_observers__WEBPACK_IMPORTED_MODULE_7__.ObserversModule],\n                    declarations: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],\n                }]\n        }], ctorParameters: function () { return [{ type: HighContrastModeDetector }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=a11y.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2ExMXkubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9mZXNtMjAyMC9hMTF5Lm1qcz9kNjhkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaW5qZWN0LCBBUFBfSUQsIEluamVjdGFibGUsIEluamVjdCwgUXVlcnlMaXN0LCBEaXJlY3RpdmUsIElucHV0LCBJbmplY3Rpb25Ub2tlbiwgT3B0aW9uYWwsIEV2ZW50RW1pdHRlciwgT3V0cHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IF9nZXRGb2N1c2VkRWxlbWVudFBpZXJjZVNoYWRvd0RvbSwgbm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucywgX2dldEV2ZW50VGFyZ2V0LCBfZ2V0U2hhZG93Um9vdCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIEJlaGF2aW9yU3ViamVjdCwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGhhc01vZGlmaWVyS2V5LCBBLCBaLCBaRVJPLCBOSU5FLCBQQUdFX0RPV04sIFBBR0VfVVAsIEVORCwgSE9NRSwgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFVQX0FSUk9XLCBET1dOX0FSUk9XLCBUQUIsIEFMVCwgQ09OVFJPTCwgTUFDX01FVEEsIE1FVEEsIFNISUZUIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IHRhcCwgZGVib3VuY2VUaW1lLCBmaWx0ZXIsIG1hcCwgdGFrZSwgc2tpcCwgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSwgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgKiBhcyBpMSQxIGZyb20gJ0Bhbmd1bGFyL2Nkay9vYnNlcnZlcnMnO1xuaW1wb3J0IHsgT2JzZXJ2ZXJzTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XG5pbXBvcnQgeyBCcmVha3BvaW50T2JzZXJ2ZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvbGF5b3V0JztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogSURzIGFyZSBkZWxpbWl0ZWQgYnkgYW4gZW1wdHkgc3BhY2UsIGFzIHBlciB0aGUgc3BlYy4gKi9cbmNvbnN0IElEX0RFTElNSVRFUiA9ICcgJztcbi8qKlxuICogQWRkcyB0aGUgZ2l2ZW4gSUQgdG8gdGhlIHNwZWNpZmllZCBBUklBIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICogVXNlZCBmb3IgYXR0cmlidXRlcyBzdWNoIGFzIGFyaWEtbGFiZWxsZWRieSwgYXJpYS1vd25zLCBldGMuXG4gKi9cbmZ1bmN0aW9uIGFkZEFyaWFSZWZlcmVuY2VkSWQoZWwsIGF0dHIsIGlkKSB7XG4gICAgY29uc3QgaWRzID0gZ2V0QXJpYVJlZmVyZW5jZUlkcyhlbCwgYXR0cik7XG4gICAgaWYgKGlkcy5zb21lKGV4aXN0aW5nSWQgPT4gZXhpc3RpbmdJZC50cmltKCkgPT0gaWQudHJpbSgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlkcy5wdXNoKGlkLnRyaW0oKSk7XG4gICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIGlkcy5qb2luKElEX0RFTElNSVRFUikpO1xufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBJRCBmcm9tIHRoZSBzcGVjaWZpZWQgQVJJQSBhdHRyaWJ1dGUgb24gYW4gZWxlbWVudC5cbiAqIFVzZWQgZm9yIGF0dHJpYnV0ZXMgc3VjaCBhcyBhcmlhLWxhYmVsbGVkYnksIGFyaWEtb3ducywgZXRjLlxuICovXG5mdW5jdGlvbiByZW1vdmVBcmlhUmVmZXJlbmNlZElkKGVsLCBhdHRyLCBpZCkge1xuICAgIGNvbnN0IGlkcyA9IGdldEFyaWFSZWZlcmVuY2VJZHMoZWwsIGF0dHIpO1xuICAgIGNvbnN0IGZpbHRlcmVkSWRzID0gaWRzLmZpbHRlcih2YWwgPT4gdmFsICE9IGlkLnRyaW0oKSk7XG4gICAgaWYgKGZpbHRlcmVkSWRzLmxlbmd0aCkge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgZmlsdGVyZWRJZHMuam9pbihJRF9ERUxJTUlURVIpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGxpc3Qgb2YgSURzIHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIEFSSUEgYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQuXG4gKiBVc2VkIGZvciBhdHRyaWJ1dGVzIHN1Y2ggYXMgYXJpYS1sYWJlbGxlZGJ5LCBhcmlhLW93bnMsIGV0Yy5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJpYVJlZmVyZW5jZUlkcyhlbCwgYXR0cikge1xuICAgIC8vIEdldCBzdHJpbmcgYXJyYXkgb2YgYWxsIGluZGl2aWR1YWwgaWRzICh3aGl0ZXNwYWNlIGRlbGltaXRlZCkgaW4gdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgIHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKGF0dHIpIHx8ICcnKS5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIElEIHVzZWQgZm9yIHRoZSBib2R5IGNvbnRhaW5lciB3aGVyZSBhbGwgbWVzc2FnZXMgYXJlIGFwcGVuZGVkLlxuICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIGJlaW5nIHVzZWQuIFRvIGJlIHJlbW92ZWQuXG4gKiBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMFxuICovXG5jb25zdCBNRVNTQUdFU19DT05UQUlORVJfSUQgPSAnY2RrLWRlc2NyaWJlZGJ5LW1lc3NhZ2UtY29udGFpbmVyJztcbi8qKlxuICogSUQgcHJlZml4IHVzZWQgZm9yIGVhY2ggY3JlYXRlZCBtZXNzYWdlIGVsZW1lbnQuXG4gKiBAZGVwcmVjYXRlZCBUbyBiZSB0dXJuZWQgaW50byBhIHByaXZhdGUgdmFyaWFibGUuXG4gKiBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMFxuICovXG5jb25zdCBDREtfREVTQ1JJQkVEQllfSURfUFJFRklYID0gJ2Nkay1kZXNjcmliZWRieS1tZXNzYWdlJztcbi8qKlxuICogQXR0cmlidXRlIGdpdmVuIHRvIGVhY2ggaG9zdCBlbGVtZW50IHRoYXQgaXMgZGVzY3JpYmVkIGJ5IGEgbWVzc2FnZSBlbGVtZW50LlxuICogQGRlcHJlY2F0ZWQgVG8gYmUgdHVybmVkIGludG8gYSBwcml2YXRlIHZhcmlhYmxlLlxuICogQGJyZWFraW5nLWNoYW5nZSAxNC4wLjBcbiAqL1xuY29uc3QgQ0RLX0RFU0NSSUJFREJZX0hPU1RfQVRUUklCVVRFID0gJ2Nkay1kZXNjcmliZWRieS1ob3N0Jztcbi8qKiBHbG9iYWwgaW5jcmVtZW50YWwgaWRlbnRpZmllciBmb3IgZWFjaCByZWdpc3RlcmVkIG1lc3NhZ2UgZWxlbWVudC4gKi9cbmxldCBuZXh0SWQgPSAwO1xuLyoqXG4gKiBVdGlsaXR5IHRoYXQgY3JlYXRlcyB2aXN1YWxseSBoaWRkZW4gZWxlbWVudHMgd2l0aCBhIG1lc3NhZ2UgY29udGVudC4gVXNlZnVsIGZvciBlbGVtZW50cyB0aGF0XG4gKiB3YW50IHRvIHVzZSBhcmlhLWRlc2NyaWJlZGJ5IHRvIGZ1cnRoZXIgZGVzY3JpYmUgdGhlbXNlbHZlcyB3aXRob3V0IGFkZGluZyBhZGRpdGlvbmFsIHZpc3VhbFxuICogY29udGVudC5cbiAqL1xuY2xhc3MgQXJpYURlc2NyaWJlciB7XG4gICAgY29uc3RydWN0b3IoX2RvY3VtZW50LCBcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUbyBiZSB0dXJuZWQgaW50byBhIHJlcXVpcmVkIHBhcmFtZXRlci5cbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMFxuICAgICAqL1xuICAgIF9wbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgLyoqIE1hcCBvZiBhbGwgcmVnaXN0ZXJlZCBtZXNzYWdlIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHBsYWNlZCBpbnRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICAgICAgdGhpcy5fbWVzc2FnZVJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogQ29udGFpbmVyIGZvciBhbGwgcmVnaXN0ZXJlZCBtZXNzYWdlcy4gKi9cbiAgICAgICAgdGhpcy5fbWVzc2FnZXNDb250YWluZXIgPSBudWxsO1xuICAgICAgICAvKiogVW5pcXVlIElEIGZvciB0aGUgc2VydmljZS4gKi9cbiAgICAgICAgdGhpcy5faWQgPSBgJHtuZXh0SWQrK31gO1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICAgICAgdGhpcy5faWQgPSBpbmplY3QoQVBQX0lEKSArICctJyArIG5leHRJZCsrO1xuICAgIH1cbiAgICBkZXNjcmliZShob3N0RWxlbWVudCwgbWVzc2FnZSwgcm9sZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbkJlRGVzY3JpYmVkKGhvc3RFbGVtZW50LCBtZXNzYWdlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IGdldEtleShtZXNzYWdlLCByb2xlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgZWxlbWVudCBoYXMgYW4gSUQuXG4gICAgICAgICAgICBzZXRNZXNzYWdlSWQobWVzc2FnZSwgdGhpcy5faWQpO1xuICAgICAgICAgICAgdGhpcy5fbWVzc2FnZVJlZ2lzdHJ5LnNldChrZXksIHsgbWVzc2FnZUVsZW1lbnQ6IG1lc3NhZ2UsIHJlZmVyZW5jZUNvdW50OiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9tZXNzYWdlUmVnaXN0cnkuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU1lc3NhZ2VFbGVtZW50KG1lc3NhZ2UsIHJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faXNFbGVtZW50RGVzY3JpYmVkQnlNZXNzYWdlKGhvc3RFbGVtZW50LCBrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlUmVmZXJlbmNlKGhvc3RFbGVtZW50LCBrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZURlc2NyaXB0aW9uKGhvc3RFbGVtZW50LCBtZXNzYWdlLCByb2xlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSB8fCAhdGhpcy5faXNFbGVtZW50Tm9kZShob3N0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXkobWVzc2FnZSwgcm9sZSk7XG4gICAgICAgIGlmICh0aGlzLl9pc0VsZW1lbnREZXNjcmliZWRCeU1lc3NhZ2UoaG9zdEVsZW1lbnQsIGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZU1lc3NhZ2VSZWZlcmVuY2UoaG9zdEVsZW1lbnQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgaXMgYSBzdHJpbmcsIGl0IG1lYW5zIHRoYXQgaXQncyBvbmUgdGhhdCB3ZSBjcmVhdGVkIGZvciB0aGVcbiAgICAgICAgLy8gY29uc3VtZXIgc28gd2UgY2FuIHJlbW92ZSBpdCBzYWZlbHksIG90aGVyd2lzZSB3ZSBzaG91bGQgbGVhdmUgaXQgaW4gcGxhY2UuXG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRNZXNzYWdlID0gdGhpcy5fbWVzc2FnZVJlZ2lzdHJ5LmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHJlZ2lzdGVyZWRNZXNzYWdlICYmIHJlZ2lzdGVyZWRNZXNzYWdlLnJlZmVyZW5jZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsZXRlTWVzc2FnZUVsZW1lbnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZXNDb250YWluZXI/LmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlc0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VzQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogVW5yZWdpc3RlcnMgYWxsIGNyZWF0ZWQgbWVzc2FnZSBlbGVtZW50cyBhbmQgcmVtb3ZlcyB0aGUgbWVzc2FnZSBjb250YWluZXIuICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaWJlZEVsZW1lbnRzID0gdGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgWyR7Q0RLX0RFU0NSSUJFREJZX0hPU1RfQVRUUklCVVRFfT1cIiR7dGhpcy5faWR9XCJdYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3JpYmVkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNka0Rlc2NyaWJlZEJ5UmVmZXJlbmNlSWRzKGRlc2NyaWJlZEVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgIGRlc2NyaWJlZEVsZW1lbnRzW2ldLnJlbW92ZUF0dHJpYnV0ZShDREtfREVTQ1JJQkVEQllfSE9TVF9BVFRSSUJVVEUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzQ29udGFpbmVyPy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXNDb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXNzYWdlUmVnaXN0cnkuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBlbGVtZW50IGluIHRoZSB2aXN1YWxseSBoaWRkZW4gbWVzc2FnZSBjb250YWluZXIgZWxlbWVudCB3aXRoIHRoZSBtZXNzYWdlXG4gICAgICogYXMgaXRzIGNvbnRlbnQgYW5kIGFkZHMgaXQgdG8gdGhlIG1lc3NhZ2UgcmVnaXN0cnkuXG4gICAgICovXG4gICAgX2NyZWF0ZU1lc3NhZ2VFbGVtZW50KG1lc3NhZ2UsIHJvbGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2V0TWVzc2FnZUlkKG1lc3NhZ2VFbGVtZW50LCB0aGlzLl9pZCk7XG4gICAgICAgIG1lc3NhZ2VFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKHJvbGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsIHJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NyZWF0ZU1lc3NhZ2VzQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzQ29udGFpbmVyLmFwcGVuZENoaWxkKG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZVJlZ2lzdHJ5LnNldChnZXRLZXkobWVzc2FnZSwgcm9sZSksIHsgbWVzc2FnZUVsZW1lbnQsIHJlZmVyZW5jZUNvdW50OiAwIH0pO1xuICAgIH1cbiAgICAvKiogRGVsZXRlcyB0aGUgbWVzc2FnZSBlbGVtZW50IGZyb20gdGhlIGdsb2JhbCBtZXNzYWdlcyBjb250YWluZXIuICovXG4gICAgX2RlbGV0ZU1lc3NhZ2VFbGVtZW50KGtleSkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlUmVnaXN0cnkuZ2V0KGtleSk/Lm1lc3NhZ2VFbGVtZW50Py5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZVJlZ2lzdHJ5LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyB0aGUgZ2xvYmFsIGNvbnRhaW5lciBmb3IgYWxsIGFyaWEtZGVzY3JpYmVkYnkgbWVzc2FnZXMuICovXG4gICAgX2NyZWF0ZU1lc3NhZ2VzQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fbWVzc2FnZXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJDbGFzc05hbWUgPSAnY2RrLWRlc2NyaWJlZGJ5LW1lc3NhZ2UtY29udGFpbmVyJztcbiAgICAgICAgY29uc3Qgc2VydmVyQ29udGFpbmVycyA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYC4ke2NvbnRhaW5lckNsYXNzTmFtZX1bcGxhdGZvcm09XCJzZXJ2ZXJcIl1gKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXJ2ZXJDb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGdvaW5nIGZyb20gdGhlIHNlcnZlciB0byB0aGUgY2xpZW50LCB3ZSBtYXkgZW5kIHVwIGluIGEgc2l0dWF0aW9uIHdoZXJlIHRoZXJlJ3NcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBjb250YWluZXIgb24gdGhlIHBhZ2UsIGJ1dCB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIGl0LiBDbGVhciB0aGVcbiAgICAgICAgICAgIC8vIG9sZCBjb250YWluZXIgc28gd2UgZG9uJ3QgZ2V0IGR1cGxpY2F0ZXMuIERvaW5nIHRoaXMsIGluc3RlYWQgb2YgZW1wdHlpbmcgdGhlIHByZXZpb3VzXG4gICAgICAgICAgICAvLyBjb250YWluZXIsIHNob3VsZCBiZSBzbGlnaHRseSBmYXN0ZXIuXG4gICAgICAgICAgICBzZXJ2ZXJDb250YWluZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzQ29udGFpbmVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFdlIGFkZCBgdmlzaWJpbGl0eTogaGlkZGVuYCBpbiBvcmRlciB0byBwcmV2ZW50IHRleHQgaW4gdGhpcyBjb250YWluZXIgZnJvbVxuICAgICAgICAvLyBiZWluZyBzZWFyY2hhYmxlIGJ5IHRoZSBicm93c2VyJ3MgQ3RybCArIEYgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgLy8gU2NyZWVuLXJlYWRlcnMgd2lsbCBzdGlsbCByZWFkIHRoZSBkZXNjcmlwdGlvbiBmb3IgZWxlbWVudHMgd2l0aCBhcmlhLWRlc2NyaWJlZGJ5IGV2ZW5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGVzY3JpcHRpb24gZWxlbWVudCBpcyBub3QgdmlzaWJsZS5cbiAgICAgICAgbWVzc2FnZXNDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSB1c2UgYHZpc2liaWxpdHk6IGhpZGRlbmAsIHdlIHN0aWxsIGFwcGx5IGBjZGstdmlzdWFsbHktaGlkZGVuYCBzbyB0aGF0XG4gICAgICAgIC8vIHRoZSBkZXNjcmlwdGlvbiBlbGVtZW50IGRvZXNuJ3QgaW1wYWN0IHBhZ2UgbGF5b3V0LlxuICAgICAgICBtZXNzYWdlc0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgICAgIG1lc3NhZ2VzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Nkay12aXN1YWxseS1oaWRkZW4nKTtcbiAgICAgICAgLy8gQGJyZWFraW5nLWNoYW5nZSAxNC4wLjAgUmVtb3ZlIG51bGwgY2hlY2sgZm9yIGBfcGxhdGZvcm1gLlxuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0gJiYgIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgbWVzc2FnZXNDb250YWluZXIuc2V0QXR0cmlidXRlKCdwbGF0Zm9ybScsICdzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1lc3NhZ2VzQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXNDb250YWluZXIgPSBtZXNzYWdlc0NvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgYWxsIGNkay1kZXNjcmliZWRieSBtZXNzYWdlcyB0aGF0IGFyZSBob3N0ZWQgdGhyb3VnaCB0aGUgZWxlbWVudC4gKi9cbiAgICBfcmVtb3ZlQ2RrRGVzY3JpYmVkQnlSZWZlcmVuY2VJZHMoZWxlbWVudCkge1xuICAgICAgICAvLyBSZW1vdmUgYWxsIGFyaWEtZGVzY3JpYmVkYnkgcmVmZXJlbmNlIElEcyB0aGF0IGFyZSBwcmVmaXhlZCBieSBDREtfREVTQ1JJQkVEQllfSURfUFJFRklYXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmVmZXJlbmNlSWRzID0gZ2V0QXJpYVJlZmVyZW5jZUlkcyhlbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScpLmZpbHRlcihpZCA9PiBpZC5pbmRleE9mKENES19ERVNDUklCRURCWV9JRF9QUkVGSVgpICE9IDApO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIG9yaWdpbmFsUmVmZXJlbmNlSWRzLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtZXNzYWdlIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB1c2luZyBhcmlhLWRlc2NyaWJlZGJ5IGFuZCBpbmNyZW1lbnRzIHRoZSByZWdpc3RlcmVkXG4gICAgICogbWVzc2FnZSdzIHJlZmVyZW5jZSBjb3VudC5cbiAgICAgKi9cbiAgICBfYWRkTWVzc2FnZVJlZmVyZW5jZShlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJlZE1lc3NhZ2UgPSB0aGlzLl9tZXNzYWdlUmVnaXN0cnkuZ2V0KGtleSk7XG4gICAgICAgIC8vIEFkZCB0aGUgYXJpYS1kZXNjcmliZWRieSByZWZlcmVuY2UgYW5kIHNldCB0aGVcbiAgICAgICAgLy8gZGVzY3JpYmVkYnlfaG9zdCBhdHRyaWJ1dGUgdG8gbWFyayB0aGUgZWxlbWVudC5cbiAgICAgICAgYWRkQXJpYVJlZmVyZW5jZWRJZChlbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScsIHJlZ2lzdGVyZWRNZXNzYWdlLm1lc3NhZ2VFbGVtZW50LmlkKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoQ0RLX0RFU0NSSUJFREJZX0hPU1RfQVRUUklCVVRFLCB0aGlzLl9pZCk7XG4gICAgICAgIHJlZ2lzdGVyZWRNZXNzYWdlLnJlZmVyZW5jZUNvdW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBtZXNzYWdlIHJlZmVyZW5jZSBmcm9tIHRoZSBlbGVtZW50IHVzaW5nIGFyaWEtZGVzY3JpYmVkYnlcbiAgICAgKiBhbmQgZGVjcmVtZW50cyB0aGUgcmVnaXN0ZXJlZCBtZXNzYWdlJ3MgcmVmZXJlbmNlIGNvdW50LlxuICAgICAqL1xuICAgIF9yZW1vdmVNZXNzYWdlUmVmZXJlbmNlKGVsZW1lbnQsIGtleSkge1xuICAgICAgICBjb25zdCByZWdpc3RlcmVkTWVzc2FnZSA9IHRoaXMuX21lc3NhZ2VSZWdpc3RyeS5nZXQoa2V5KTtcbiAgICAgICAgcmVnaXN0ZXJlZE1lc3NhZ2UucmVmZXJlbmNlQ291bnQtLTtcbiAgICAgICAgcmVtb3ZlQXJpYVJlZmVyZW5jZWRJZChlbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScsIHJlZ2lzdGVyZWRNZXNzYWdlLm1lc3NhZ2VFbGVtZW50LmlkKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoQ0RLX0RFU0NSSUJFREJZX0hPU1RfQVRUUklCVVRFKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgYmVlbiBkZXNjcmliZWQgYnkgdGhlIHByb3ZpZGVkIG1lc3NhZ2UgSUQuICovXG4gICAgX2lzRWxlbWVudERlc2NyaWJlZEJ5TWVzc2FnZShlbGVtZW50LCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSWRzID0gZ2V0QXJpYVJlZmVyZW5jZUlkcyhlbGVtZW50LCAnYXJpYS1kZXNjcmliZWRieScpO1xuICAgICAgICBjb25zdCByZWdpc3RlcmVkTWVzc2FnZSA9IHRoaXMuX21lc3NhZ2VSZWdpc3RyeS5nZXQoa2V5KTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gcmVnaXN0ZXJlZE1lc3NhZ2UgJiYgcmVnaXN0ZXJlZE1lc3NhZ2UubWVzc2FnZUVsZW1lbnQuaWQ7XG4gICAgICAgIHJldHVybiAhIW1lc3NhZ2VJZCAmJiByZWZlcmVuY2VJZHMuaW5kZXhPZihtZXNzYWdlSWQpICE9IC0xO1xuICAgIH1cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbWVzc2FnZSBjYW4gYmUgZGVzY3JpYmVkIG9uIGEgcGFydGljdWxhciBlbGVtZW50LiAqL1xuICAgIF9jYW5CZURlc2NyaWJlZChlbGVtZW50LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNFbGVtZW50Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlICYmIHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gV2UnZCBoYXZlIHRvIG1ha2Ugc29tZSBhc3N1bXB0aW9ucyBhYm91dCB0aGUgZGVzY3JpcHRpb24gZWxlbWVudCdzIHRleHQsIGlmIHRoZSBjb25zdW1lclxuICAgICAgICAgICAgLy8gcGFzc2VkIGluIGFuIGVsZW1lbnQuIEFzc3VtZSB0aGF0IGlmIGFuIGVsZW1lbnQgaXMgcGFzc2VkIGluLCB0aGUgY29uc3VtZXIgaGFzIHZlcmlmaWVkXG4gICAgICAgICAgICAvLyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGEgZGVzY3JpcHRpb24uXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmltbWVkTWVzc2FnZSA9IG1lc3NhZ2UgPT0gbnVsbCA/ICcnIDogYCR7bWVzc2FnZX1gLnRyaW0oKTtcbiAgICAgICAgY29uc3QgYXJpYUxhYmVsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkbid0IHNldCBkZXNjcmlwdGlvbnMgaWYgdGhleSdyZSBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBgYXJpYS1sYWJlbGAgb2YgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQsIGJlY2F1c2Ugc2NyZWVuIHJlYWRlcnMgd2lsbCBlbmQgdXAgcmVhZGluZyBvdXQgdGhlIHNhbWUgdGV4dCB0d2ljZSBpbiBhIHJvdy5cbiAgICAgICAgcmV0dXJuIHRyaW1tZWRNZXNzYWdlID8gIWFyaWFMYWJlbCB8fCBhcmlhTGFiZWwudHJpbSgpICE9PSB0cmltbWVkTWVzc2FnZSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgYSBub2RlIGlzIGFuIEVsZW1lbnQgbm9kZS4gKi9cbiAgICBfaXNFbGVtZW50Tm9kZShlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVUeXBlID09PSB0aGlzLl9kb2N1bWVudC5FTEVNRU5UX05PREU7XG4gICAgfVxufVxuQXJpYURlc2NyaWJlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEFyaWFEZXNjcmliZXIsIGRlcHM6IFt7IHRva2VuOiBET0NVTUVOVCB9LCB7IHRva2VuOiBpMS5QbGF0Zm9ybSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuQXJpYURlc2NyaWJlci7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBcmlhRGVzY3JpYmVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBcmlhRGVzY3JpYmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMS5QbGF0Zm9ybSB9XTsgfSB9KTtcbi8qKiBHZXRzIGEga2V5IHRoYXQgY2FuIGJlIHVzZWQgdG8gbG9vayBtZXNzYWdlcyB1cCBpbiB0aGUgcmVnaXN0cnkuICovXG5mdW5jdGlvbiBnZXRLZXkobWVzc2FnZSwgcm9sZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyBgJHtyb2xlIHx8ICcnfS8ke21lc3NhZ2V9YCA6IG1lc3NhZ2U7XG59XG4vKiogQXNzaWducyBhIHVuaXF1ZSBJRCB0byBhbiBlbGVtZW50LCBpZiBpdCBkb2Vzbid0IGhhdmUgb25lIGFscmVhZHkuICovXG5mdW5jdGlvbiBzZXRNZXNzYWdlSWQoZWxlbWVudCwgc2VydmljZUlkKSB7XG4gICAgaWYgKCFlbGVtZW50LmlkKSB7XG4gICAgICAgIGVsZW1lbnQuaWQgPSBgJHtDREtfREVTQ1JJQkVEQllfSURfUFJFRklYfS0ke3NlcnZpY2VJZH0tJHtuZXh0SWQrK31gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBrZXlib2FyZCBldmVudHMgZm9yIHNlbGVjdGFibGUgbGlzdHMuIElmIHlvdSBwYXNzIGl0IGEgcXVlcnkgbGlzdFxuICogb2YgaXRlbXMsIGl0IHdpbGwgc2V0IHRoZSBhY3RpdmUgaXRlbSBjb3JyZWN0bHkgd2hlbiBhcnJvdyBldmVudHMgb2NjdXIuXG4gKi9cbmNsYXNzIExpc3RLZXlNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihfaXRlbXMpIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBfaXRlbXM7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sZXR0ZXJLZXlTdHJlYW0gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYWxsb3dlZE1vZGlmaWVyS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLl9ob21lQW5kRW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhZ2VVcEFuZERvd24gPSB7IGVuYWJsZWQ6IGZhbHNlLCBkZWx0YTogMTAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByZWRpY2F0ZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgYW4gaXRlbSBzaG91bGQgYmUgc2tpcHBlZFxuICAgICAgICAgKiBieSB0aGUga2V5IG1hbmFnZXIuIEJ5IGRlZmF1bHQsIGRpc2FibGVkIGl0ZW1zIGFyZSBza2lwcGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2tpcFByZWRpY2F0ZUZuID0gKGl0ZW0pID0+IGl0ZW0uZGlzYWJsZWQ7XG4gICAgICAgIC8vIEJ1ZmZlciBmb3IgdGhlIGxldHRlcnMgdGhhdCB0aGUgdXNlciBoYXMgcHJlc3NlZCB3aGVuIHRoZSB0eXBlYWhlYWQgb3B0aW9uIGlzIHR1cm5lZCBvbi5cbiAgICAgICAgdGhpcy5fcHJlc3NlZExldHRlcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSB0aGF0IGVtaXRzIGFueSB0aW1lIHRoZSBUQUIga2V5IGlzIHByZXNzZWQsIHNvIGNvbXBvbmVudHMgY2FuIHJlYWN0XG4gICAgICAgICAqIHdoZW4gZm9jdXMgaXMgc2hpZnRlZCBvZmYgb2YgdGhlIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhYk91dCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgYWN0aXZlIGl0ZW0gb2YgdGhlIGxpc3QgbWFuYWdlciBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8vIFdlIGFsbG93IGZvciB0aGUgaXRlbXMgdG8gYmUgYW4gYXJyYXkgYmVjYXVzZSwgaW4gc29tZSBjYXNlcywgdGhlIGNvbnN1bWVyIG1heVxuICAgICAgICAvLyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBRdWVyeUxpc3Qgb2YgdGhlIGl0ZW1zIHRoZXkgd2FudCB0byBtYW5hZ2UgKGUuZy4gd2hlbiB0aGVcbiAgICAgICAgLy8gaXRlbXMgYXJlbid0IGJlaW5nIGNvbGxlY3RlZCB2aWEgYFZpZXdDaGlsZHJlbmAgb3IgYENvbnRlbnRDaGlsZHJlbmApLlxuICAgICAgICBpZiAoX2l0ZW1zIGluc3RhbmNlb2YgUXVlcnlMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtQ2hhbmdlc1N1YnNjcmlwdGlvbiA9IF9pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgobmV3SXRlbXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtQXJyYXkgPSBuZXdJdGVtcy50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luZGV4ID0gaXRlbUFycmF5LmluZGV4T2YodGhpcy5fYWN0aXZlSXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbmRleCA+IC0xICYmIG5ld0luZGV4ICE9PSB0aGlzLl9hY3RpdmVJdGVtSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IG5ld0luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGljaCBpdGVtcyBzaG91bGQgYmUgc2tpcHBlZCBieSB0aGVcbiAgICAgKiBsaXN0IGtleSBtYW5hZ2VyLlxuICAgICAqIEBwYXJhbSBwcmVkaWNhdGUgRnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGl0ZW0gc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgc2tpcFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5fc2tpcFByZWRpY2F0ZUZuID0gcHJlZGljYXRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB3cmFwcGluZyBtb2RlLCB3aGljaCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFjdGl2ZSBpdGVtIHdpbGwgd3JhcCB0b1xuICAgICAqIHRoZSBvdGhlciBlbmQgb2YgbGlzdCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGl0ZW1zIGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHNob3VsZFdyYXAgV2hldGhlciB0aGUgbGlzdCBzaG91bGQgd3JhcCB3aGVuIHJlYWNoaW5nIHRoZSBlbmQuXG4gICAgICovXG4gICAgd2l0aFdyYXAoc2hvdWxkV3JhcCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fd3JhcCA9IHNob3VsZFdyYXA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHdoZXRoZXIgdGhlIGtleSBtYW5hZ2VyIHNob3VsZCBiZSBhYmxlIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiB2ZXJ0aWNhbGx5LlxuICAgICAqIEBwYXJhbSBlbmFibGVkIFdoZXRoZXIgdmVydGljYWwgc2VsZWN0aW9uIHNob3VsZCBiZSBlbmFibGVkLlxuICAgICAqL1xuICAgIHdpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKGVuYWJsZWQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRpY2FsID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGtleSBtYW5hZ2VyIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBob3Jpem9udGFsbHkuXG4gICAgICogUGFzc2luZyBpbiBgbnVsbGAgd2lsbCBkaXNhYmxlIGhvcml6b250YWwgbW92ZW1lbnQuXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiBEaXJlY3Rpb24gaW4gd2hpY2ggdGhlIHNlbGVjdGlvbiBjYW4gYmUgbW92ZWQuXG4gICAgICovXG4gICAgd2l0aEhvcml6b250YWxPcmllbnRhdGlvbihkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIGtleXMgd2hpY2ggYXJlIGFsbG93ZWQgdG8gYmUgaGVsZCBkb3duIGFuZCB3aG9zZSBkZWZhdWx0IGFjdGlvbnMgd2lsbCBiZSBwcmV2ZW50ZWRcbiAgICAgKiBhcyB0aGUgdXNlciBpcyBwcmVzc2luZyB0aGUgYXJyb3cga2V5cy4gRGVmYXVsdHMgdG8gbm90IGFsbG93aW5nIGFueSBtb2RpZmllciBrZXlzLlxuICAgICAqL1xuICAgIHdpdGhBbGxvd2VkTW9kaWZpZXJLZXlzKGtleXMpIHtcbiAgICAgICAgdGhpcy5fYWxsb3dlZE1vZGlmaWVyS2V5cyA9IGtleXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUdXJucyBvbiB0eXBlYWhlYWQgbW9kZSB3aGljaCBhbGxvd3MgdXNlcnMgdG8gc2V0IHRoZSBhY3RpdmUgaXRlbSBieSB0eXBpbmcuXG4gICAgICogQHBhcmFtIGRlYm91bmNlSW50ZXJ2YWwgVGltZSB0byB3YWl0IGFmdGVyIHRoZSBsYXN0IGtleXN0cm9rZSBiZWZvcmUgc2V0dGluZyB0aGUgYWN0aXZlIGl0ZW0uXG4gICAgICovXG4gICAgd2l0aFR5cGVBaGVhZChkZWJvdW5jZUludGVydmFsID0gMjAwKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSAmJlxuICAgICAgICAgICAgdGhpcy5faXRlbXMubGVuZ3RoICYmXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5zb21lKGl0ZW0gPT4gdHlwZW9mIGl0ZW0uZ2V0TGFiZWwgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTGlzdEtleU1hbmFnZXIgaXRlbXMgaW4gdHlwZWFoZWFkIG1vZGUgbXVzdCBpbXBsZW1lbnQgdGhlIGBnZXRMYWJlbGAgbWV0aG9kLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBEZWJvdW5jZSB0aGUgcHJlc3NlcyBvZiBub24tbmF2aWdhdGlvbmFsIGtleXMsIGNvbGxlY3QgdGhlIG9uZXMgdGhhdCBjb3JyZXNwb25kIHRvIGxldHRlcnNcbiAgICAgICAgLy8gYW5kIGNvbnZlcnQgdGhvc2UgbGV0dGVycyBiYWNrIGludG8gYSBzdHJpbmcuIEFmdGVyd2FyZHMgZmluZCB0aGUgZmlyc3QgaXRlbSB0aGF0IHN0YXJ0c1xuICAgICAgICAvLyB3aXRoIHRoYXQgc3RyaW5nIGFuZCBzZWxlY3QgaXQuXG4gICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbiA9IHRoaXMuX2xldHRlcktleVN0cmVhbVxuICAgICAgICAgICAgLnBpcGUodGFwKGxldHRlciA9PiB0aGlzLl9wcmVzc2VkTGV0dGVycy5wdXNoKGxldHRlcikpLCBkZWJvdW5jZVRpbWUoZGVib3VuY2VJbnRlcnZhbCksIGZpbHRlcigoKSA9PiB0aGlzLl9wcmVzc2VkTGV0dGVycy5sZW5ndGggPiAwKSwgbWFwKCgpID0+IHRoaXMuX3ByZXNzZWRMZXR0ZXJzLmpvaW4oJycpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoaW5wdXRTdHJpbmcgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FycmF5KCk7XG4gICAgICAgICAgICAvLyBTdGFydCBhdCAxIGJlY2F1c2Ugd2Ugd2FudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGl0ZW0gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIC8vIGZvbGxvd2luZyB0aGUgY3VycmVudCBhY3RpdmUgaXRlbS5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaXRlbXMubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgaSkgJSBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NraXBQcmVkaWNhdGVGbihpdGVtKSAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmdldExhYmVsKCkudG9VcHBlckNhc2UoKS50cmltKCkuaW5kZXhPZihpbnB1dFN0cmluZykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJlc3NlZExldHRlcnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQ2FuY2VscyB0aGUgY3VycmVudCB0eXBlYWhlYWQgc2VxdWVuY2UuICovXG4gICAgY2FuY2VsVHlwZWFoZWFkKCkge1xuICAgICAgICB0aGlzLl9wcmVzc2VkTGV0dGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlcyB0aGUga2V5IG1hbmFnZXIgdG8gYWN0aXZhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IGl0ZW1zXG4gICAgICogcmVzcGVjdGl2ZWx5IHdoZW4gdGhlIEhvbWUgb3IgRW5kIGtleSBpcyBwcmVzc2VkLlxuICAgICAqIEBwYXJhbSBlbmFibGVkIFdoZXRoZXIgcHJlc3NpbmcgdGhlIEhvbWUgb3IgRW5kIGtleSBhY3RpdmF0ZXMgdGhlIGZpcnN0L2xhc3QgaXRlbS5cbiAgICAgKi9cbiAgICB3aXRoSG9tZUFuZEVuZChlbmFibGVkID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9ob21lQW5kRW5kID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyZXMgdGhlIGtleSBtYW5hZ2VyIHRvIGFjdGl2YXRlIGV2ZXJ5IDEwdGgsIGNvbmZpZ3VyZWQgb3IgZmlyc3QvbGFzdCBlbGVtZW50IGluIHVwL2Rvd24gZGlyZWN0aW9uXG4gICAgICogcmVzcGVjdGl2ZWx5IHdoZW4gdGhlIFBhZ2UtVXAgb3IgUGFnZS1Eb3duIGtleSBpcyBwcmVzc2VkLlxuICAgICAqIEBwYXJhbSBlbmFibGVkIFdoZXRoZXIgcHJlc3NpbmcgdGhlIFBhZ2UtVXAgb3IgUGFnZS1Eb3duIGtleSBhY3RpdmF0ZXMgdGhlIGZpcnN0L2xhc3QgaXRlbS5cbiAgICAgKiBAcGFyYW0gZGVsdGEgV2hldGhlciBwcmVzc2luZyB0aGUgSG9tZSBvciBFbmQga2V5IGFjdGl2YXRlcyB0aGUgZmlyc3QvbGFzdCBpdGVtLlxuICAgICAqL1xuICAgIHdpdGhQYWdlVXBEb3duKGVuYWJsZWQgPSB0cnVlLCBkZWx0YSA9IDEwKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VVcEFuZERvd24gPSB7IGVuYWJsZWQsIGRlbHRhIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRBY3RpdmVJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBY3RpdmVJdGVtID0gdGhpcy5fYWN0aXZlSXRlbTtcbiAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVJdGVtKGl0ZW0pO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlSXRlbSAhPT0gcHJldmlvdXNBY3RpdmVJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZS5uZXh0KHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gZGVwZW5kaW5nIG9uIHRoZSBrZXkgZXZlbnQgcGFzc2VkIGluLlxuICAgICAqIEBwYXJhbSBldmVudCBLZXlib2FyZCBldmVudCB0byBiZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGljaCBlbGVtZW50IHNob3VsZCBiZSBhY3RpdmUuXG4gICAgICovXG4gICAgb25LZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgICBjb25zdCBtb2RpZmllcnMgPSBbJ2FsdEtleScsICdjdHJsS2V5JywgJ21ldGFLZXknLCAnc2hpZnRLZXknXTtcbiAgICAgICAgY29uc3QgaXNNb2RpZmllckFsbG93ZWQgPSBtb2RpZmllcnMuZXZlcnkobW9kaWZpZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICFldmVudFttb2RpZmllcl0gfHwgdGhpcy5fYWxsb3dlZE1vZGlmaWVyS2V5cy5pbmRleE9mKG1vZGlmaWVyKSA+IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFRBQjpcbiAgICAgICAgICAgICAgICB0aGlzLnRhYk91dC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92ZXJ0aWNhbCAmJiBpc01vZGlmaWVyQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5leHRJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ZlcnRpY2FsICYmIGlzTW9kaWZpZXJBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJldmlvdXNJdGVtQWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwgJiYgaXNNb2RpZmllckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9PT0gJ3J0bCcgPyB0aGlzLnNldFByZXZpb3VzSXRlbUFjdGl2ZSgpIDogdGhpcy5zZXROZXh0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwgJiYgaXNNb2RpZmllckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9PT0gJ3J0bCcgPyB0aGlzLnNldE5leHRJdGVtQWN0aXZlKCkgOiB0aGlzLnNldFByZXZpb3VzSXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvbWVBbmRFbmQgJiYgaXNNb2RpZmllckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hvbWVBbmRFbmQgJiYgaXNNb2RpZmllckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRMYXN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBBR0VfVVA6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhZ2VVcEFuZERvd24uZW5hYmxlZCAmJiBpc01vZGlmaWVyQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCAtIHRoaXMuX3BhZ2VVcEFuZERvd24uZGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KHRhcmdldEluZGV4ID4gMCA/IHRhcmdldEluZGV4IDogMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUEFHRV9ET1dOOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYWdlVXBBbmREb3duLmVuYWJsZWQgJiYgaXNNb2RpZmllckFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLl9hY3RpdmVJdGVtSW5kZXggKyB0aGlzLl9wYWdlVXBBbmREb3duLmRlbHRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtc0xlbmd0aCA9IHRoaXMuX2dldEl0ZW1zQXJyYXkoKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KHRhcmdldEluZGV4IDwgaXRlbXNMZW5ndGggPyB0YXJnZXRJbmRleCA6IGl0ZW1zTGVuZ3RoIC0gMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChpc01vZGlmaWVyQWxsb3dlZCB8fCBoYXNNb2RpZmllcktleShldmVudCwgJ3NoaWZ0S2V5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byB1c2UgdGhlIGBldmVudC5rZXlgIHdoaWNoIGFsc28gbWFwcyBpdCB0byB0aGUgdXNlcidzIGtleWJvYXJkIGxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbCBiYWNrIHRvIHJlc29sdmluZyBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyB2aWEgdGhlIGtleUNvZGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGV0dGVyS2V5U3RyZWFtLm5leHQoZXZlbnQua2V5LnRvTG9jYWxlVXBwZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChrZXlDb2RlID49IEEgJiYga2V5Q29kZSA8PSBaKSB8fCAoa2V5Q29kZSA+PSBaRVJPICYmIGtleUNvZGUgPD0gTklORSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xldHRlcktleVN0cmVhbS5uZXh0KFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5Q29kZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSByZXR1cm4gaGVyZSwgaW4gb3JkZXIgdG8gYXZvaWQgcHJldmVudGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiBub24tbmF2aWdhdGlvbmFsIGtleXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXNzZWRMZXR0ZXJzID0gW107XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIC8qKiBJbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtLiAqL1xuICAgIGdldCBhY3RpdmVJdGVtSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtSW5kZXg7XG4gICAgfVxuICAgIC8qKiBUaGUgYWN0aXZlIGl0ZW0uICovXG4gICAgZ2V0IGFjdGl2ZUl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVJdGVtO1xuICAgIH1cbiAgICAvKiogR2V0cyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0eXBpbmcgaW50byB0aGUgbWFuYWdlciB1c2luZyB0aGUgdHlwZWFoZWFkIGZlYXR1cmUuICovXG4gICAgaXNUeXBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVzc2VkTGV0dGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKiogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICBzZXRGaXJzdEl0ZW1BY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX3NldEFjdGl2ZUl0ZW1CeUluZGV4KDAsIDEpO1xuICAgIH1cbiAgICAvKiogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGxhc3QgZW5hYmxlZCBpdGVtIGluIHRoZSBsaXN0LiAqL1xuICAgIHNldExhc3RJdGVtQWN0aXZlKCkge1xuICAgICAgICB0aGlzLl9zZXRBY3RpdmVJdGVtQnlJbmRleCh0aGlzLl9pdGVtcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byB0aGUgbmV4dCBlbmFibGVkIGl0ZW0gaW4gdGhlIGxpc3QuICovXG4gICAgc2V0TmV4dEl0ZW1BY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA8IDAgPyB0aGlzLnNldEZpcnN0SXRlbUFjdGl2ZSgpIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoMSk7XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBhY3RpdmUgaXRlbSB0byBhIHByZXZpb3VzIGVuYWJsZWQgaXRlbSBpbiB0aGUgbGlzdC4gKi9cbiAgICBzZXRQcmV2aW91c0l0ZW1BY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA8IDAgJiYgdGhpcy5fd3JhcFxuICAgICAgICAgICAgPyB0aGlzLnNldExhc3RJdGVtQWN0aXZlKClcbiAgICAgICAgICAgIDogdGhpcy5fc2V0QWN0aXZlSXRlbUJ5RGVsdGEoLTEpO1xuICAgIH1cbiAgICB1cGRhdGVBY3RpdmVJdGVtKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbUFycmF5ID0gdGhpcy5fZ2V0SXRlbXNBcnJheSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyA/IGl0ZW0gOiBpdGVtQXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgY29uc3QgYWN0aXZlSXRlbSA9IGl0ZW1BcnJheVtpbmRleF07XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgY2hlY2sgZm9yIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYmVjYXVzZSBvdGhlciBmYWxzeSB2YWx1ZXMgYXJlIHZhbGlkLlxuICAgICAgICB0aGlzLl9hY3RpdmVJdGVtID0gYWN0aXZlSXRlbSA9PSBudWxsID8gbnVsbCA6IGFjdGl2ZUl0ZW07XG4gICAgICAgIHRoaXMuX2FjdGl2ZUl0ZW1JbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICAvKiogQ2xlYW5zIHVwIHRoZSBrZXkgbWFuYWdlci4gKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5faXRlbUNoYW5nZXNTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2xldHRlcktleVN0cmVhbS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnRhYk91dC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLmNoYW5nZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9wcmVzc2VkTGV0dGVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBhY3RpdmUgaXRlbSwgZ2l2ZW4gYSBsaXN0IG9mIGl0ZW1zIGFuZCB0aGUgZGVsdGEgYmV0d2VlbiB0aGVcbiAgICAgKiBjdXJyZW50bHkgYWN0aXZlIGl0ZW0gYW5kIHRoZSBuZXcgYWN0aXZlIGl0ZW0uIEl0IHdpbGwgY2FsY3VsYXRlIGRpZmZlcmVudGx5XG4gICAgICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgd3JhcCBtb2RlIGlzIHR1cm5lZCBvbi5cbiAgICAgKi9cbiAgICBfc2V0QWN0aXZlSXRlbUJ5RGVsdGEoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fd3JhcCA/IHRoaXMuX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEpIDogdGhpcy5fc2V0QWN0aXZlSW5EZWZhdWx0TW9kZShkZWx0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFjdGl2ZSBpdGVtIHByb3Blcmx5IGdpdmVuIFwid3JhcFwiIG1vZGUuIEluIG90aGVyIHdvcmRzLCBpdCB3aWxsIGNvbnRpbnVlIHRvIG1vdmVcbiAgICAgKiBkb3duIHRoZSBsaXN0IHVudGlsIGl0IGZpbmRzIGFuIGl0ZW0gdGhhdCBpcyBub3QgZGlzYWJsZWQsIGFuZCBpdCB3aWxsIHdyYXAgaWYgaXRcbiAgICAgKiBlbmNvdW50ZXJzIGVpdGhlciBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICovXG4gICAgX3NldEFjdGl2ZUluV3JhcE1vZGUoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtc0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9ICh0aGlzLl9hY3RpdmVJdGVtSW5kZXggKyBkZWx0YSAqIGkgKyBpdGVtcy5sZW5ndGgpICUgaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2tpcFByZWRpY2F0ZUZuKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gcHJvcGVybHkgZ2l2ZW4gdGhlIGRlZmF1bHQgbW9kZS4gSW4gb3RoZXIgd29yZHMsIGl0IHdpbGxcbiAgICAgKiBjb250aW51ZSB0byBtb3ZlIGRvd24gdGhlIGxpc3QgdW50aWwgaXQgZmluZHMgYW4gaXRlbSB0aGF0IGlzIG5vdCBkaXNhYmxlZC4gSWZcbiAgICAgKiBpdCBlbmNvdW50ZXJzIGVpdGhlciBlbmQgb2YgdGhlIGxpc3QsIGl0IHdpbGwgc3RvcCBhbmQgbm90IHdyYXAuXG4gICAgICovXG4gICAgX3NldEFjdGl2ZUluRGVmYXVsdE1vZGUoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fc2V0QWN0aXZlSXRlbUJ5SW5kZXgodGhpcy5fYWN0aXZlSXRlbUluZGV4ICsgZGVsdGEsIGRlbHRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYWN0aXZlIGl0ZW0gdG8gdGhlIGZpcnN0IGVuYWJsZWQgaXRlbSBzdGFydGluZyBhdCB0aGUgaW5kZXggc3BlY2lmaWVkLiBJZiB0aGVcbiAgICAgKiBpdGVtIGlzIGRpc2FibGVkLCBpdCB3aWxsIG1vdmUgaW4gdGhlIGZhbGxiYWNrRGVsdGEgZGlyZWN0aW9uIHVudGlsIGl0IGVpdGhlclxuICAgICAqIGZpbmRzIGFuIGVuYWJsZWQgaXRlbSBvciBlbmNvdW50ZXJzIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICovXG4gICAgX3NldEFjdGl2ZUl0ZW1CeUluZGV4KGluZGV4LCBmYWxsYmFja0RlbHRhKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXNBcnJheSgpO1xuICAgICAgICBpZiAoIWl0ZW1zW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLl9za2lwUHJlZGljYXRlRm4oaXRlbXNbaW5kZXhdKSkge1xuICAgICAgICAgICAgaW5kZXggKz0gZmFsbGJhY2tEZWx0YTtcbiAgICAgICAgICAgIGlmICghaXRlbXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSBpdGVtcyBhcyBhbiBhcnJheS4gKi9cbiAgICBfZ2V0SXRlbXNBcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zIGluc3RhbmNlb2YgUXVlcnlMaXN0ID8gdGhpcy5faXRlbXMudG9BcnJheSgpIDogdGhpcy5faXRlbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEFjdGl2ZURlc2NlbmRhbnRLZXlNYW5hZ2VyIGV4dGVuZHMgTGlzdEtleU1hbmFnZXIge1xuICAgIHNldEFjdGl2ZUl0ZW0oaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlSXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVJdGVtLnNldEluYWN0aXZlU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5zZXRBY3RpdmVTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBGb2N1c0tleU1hbmFnZXIgZXh0ZW5kcyBMaXN0S2V5TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX29yaWdpbiA9ICdwcm9ncmFtJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZm9jdXMgb3JpZ2luIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW4gdG8gdGhlIGl0ZW1zIGZvciBhbnkgc3Vic2VxdWVudCBgZm9jdXNgIGNhbGxzLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gRm9jdXMgb3JpZ2luIHRvIGJlIHVzZWQgd2hlbiBmb2N1c2luZyBpdGVtcy5cbiAgICAgKi9cbiAgICBzZXRGb2N1c09yaWdpbihvcmlnaW4pIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0QWN0aXZlSXRlbShpdGVtKSB7XG4gICAgICAgIHN1cGVyLnNldEFjdGl2ZUl0ZW0oaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSXRlbS5mb2N1cyh0aGlzLl9vcmlnaW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIGlzRm9jdXNhYmxlIG1ldGhvZC5cbiAqL1xuY2xhc3MgSXNGb2N1c2FibGVDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0byBjb3VudCBhbiBlbGVtZW50IGFzIGZvY3VzYWJsZSBldmVuIGlmIGl0IGlzIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWdub3JlVmlzaWJpbGl0eSA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIFRoZSBJbnRlcmFjdGl2aXR5Q2hlY2tlciBsZWFucyBoZWF2aWx5IG9uIHRoZSBhbGx5LmpzIGFjY2Vzc2liaWxpdHkgdXRpbGl0aWVzLlxuLy8gTWV0aG9kcyBsaWtlIGBpc1RhYmJhYmxlYCBhcmUgb25seSBjb3ZlcmluZyBzcGVjaWZpYyBlZGdlLWNhc2VzIGZvciB0aGUgYnJvd3NlcnMgd2hpY2ggYXJlXG4vLyBzdXBwb3J0ZWQuXG4vKipcbiAqIFV0aWxpdHkgZm9yIGNoZWNraW5nIHRoZSBpbnRlcmFjdGl2aXR5IG9mIGFuIGVsZW1lbnQsIHN1Y2ggYXMgd2hldGhlciBpcyBpcyBmb2N1c2FibGUgb3JcbiAqIHRhYmJhYmxlLlxuICovXG5jbGFzcyBJbnRlcmFjdGl2aXR5Q2hlY2tlciB7XG4gICAgY29uc3RydWN0b3IoX3BsYXRmb3JtKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gX3BsYXRmb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGlzRGlzYWJsZWQoZWxlbWVudCkge1xuICAgICAgICAvLyBUaGlzIGRvZXMgbm90IGNhcHR1cmUgc29tZSBjYXNlcywgc3VjaCBhcyBhIG5vbi1mb3JtIGNvbnRyb2wgd2l0aCBhIGRpc2FibGVkIGF0dHJpYnV0ZSBvclxuICAgICAgICAvLyBhIGZvcm0gY29udHJvbCBpbnNpZGUgb2YgYSBkaXNhYmxlZCBmb3JtLCBidXQgc2hvdWxkIGNhcHR1cmUgdGhlIG1vc3QgY29tbW9uIGNhc2VzLlxuICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHZpc2libGUgZm9yIHRoZSBwdXJwb3NlcyBvZiBpbnRlcmFjdGl2aXR5LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNhcHR1cmUgc3RhdGVzIGxpa2UgYGRpc3BsYXk6IG5vbmVgIGFuZCBgdmlzaWJpbGl0eTogaGlkZGVuYCwgYnV0IG5vdCB0aGluZ3MgbGlrZVxuICAgICAqIGJlaW5nIGNsaXBwZWQgYnkgYW4gYG92ZXJmbG93OiBoaWRkZW5gIHBhcmVudCBvciBiZWluZyBvdXRzaWRlIHRoZSB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc1Zpc2libGUoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaGFzR2VvbWV0cnkoZWxlbWVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS52aXNpYmlsaXR5ID09PSAndmlzaWJsZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGNhbiBiZSByZWFjaGVkIHZpYSBUYWIga2V5LlxuICAgICAqIEFzc3VtZXMgdGhhdCB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWQgd2l0aCBpc0ZvY3VzYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIHRhYmJhYmxlLlxuICAgICAqL1xuICAgIGlzVGFiYmFibGUoZWxlbWVudCkge1xuICAgICAgICAvLyBOb3RoaW5nIGlzIHRhYmJhYmxlIG9uIHRoZSBzZXJ2ZXIg8J+YjlxuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZyYW1lRWxlbWVudCA9IGdldEZyYW1lRWxlbWVudChnZXRXaW5kb3coZWxlbWVudCkpO1xuICAgICAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBGcmFtZSBlbGVtZW50cyBpbmhlcml0IHRoZWlyIHRhYmluZGV4IG9udG8gYWxsIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgICAgICAgaWYgKGdldFRhYkluZGV4VmFsdWUoZnJhbWVFbGVtZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCcm93c2VycyBkaXNhYmxlIHRhYmJpbmcgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgYW4gaW52aXNpYmxlIGZyYW1lLlxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZShmcmFtZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IHRhYkluZGV4VmFsdWUgPSBnZXRUYWJJbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFiSW5kZXhWYWx1ZSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnaWZyYW1lJyB8fCBub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmcmFtZSBvciBvYmplY3QncyBjb250ZW50IG1heSBiZSB0YWJiYWJsZSBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnQsIGJ1dCBpdCdzXG4gICAgICAgICAgICAvLyBub3QgcG9zc2libHkgdG8gcmVsaWFibHkgZGV0ZWN0IHRoZSBjb250ZW50IG9mIHRoZSBmcmFtZXMuIFdlIGFsd2F5cyBjb25zaWRlciBzdWNoXG4gICAgICAgICAgICAvLyBlbGVtZW50cyBhcyBub24tdGFiYmFibGUuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gaU9TLCB0aGUgYnJvd3NlciBvbmx5IGNvbnNpZGVycyBzb21lIHNwZWNpZmljIGVsZW1lbnRzIGFzIHRhYmJhYmxlLlxuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0uV0VCS0lUICYmIHRoaXMuX3BsYXRmb3JtLklPUyAmJiAhaXNQb3RlbnRpYWxseVRhYmJhYmxlSU9TKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICAvLyBBdWRpbyBlbGVtZW50cyB3aXRob3V0IGNvbnRyb2xzIGVuYWJsZWQgYXJlIG5ldmVyIHRhYmJhYmxlLCByZWdhcmRsZXNzXG4gICAgICAgICAgICAvLyBvZiB0aGUgdGFiaW5kZXggYXR0cmlidXRlIGV4cGxpY2l0bHkgYmVpbmcgc2V0LlxuICAgICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1ZGlvIGVsZW1lbnRzIHdpdGggY29udHJvbHMgYXJlIGJ5IGRlZmF1bHQgdGFiYmFibGUgdW5sZXNzIHRoZVxuICAgICAgICAgICAgLy8gdGFiaW5kZXggYXR0cmlidXRlIGlzIHNldCB0byBgLTFgIGV4cGxpY2l0bHkuXG4gICAgICAgICAgICByZXR1cm4gdGFiSW5kZXhWYWx1ZSAhPT0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAvLyBGb3IgYWxsIHZpZGVvIGVsZW1lbnRzLCBpZiB0aGUgdGFiaW5kZXggYXR0cmlidXRlIGlzIHNldCB0byBgLTFgLCB0aGUgdmlkZW9cbiAgICAgICAgICAgIC8vIGlzIG5vdCB0YWJiYWJsZS4gTm90ZTogV2UgY2Fubm90IHJlbHkgb24gdGhlIGRlZmF1bHQgYEhUTUxFbGVtZW50LnRhYkluZGV4YFxuICAgICAgICAgICAgLy8gcHJvcGVydHkgYXMgdGhhdCBvbmUgaXMgc2V0IHRvIGAtMWAgaW4gQ2hyb21lLCBFZGdlIGFuZCBTYWZhcmkgdjEzLjEuIFRoZVxuICAgICAgICAgICAgLy8gdGFiaW5kZXggYXR0cmlidXRlIGlzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggaGVyZS5cbiAgICAgICAgICAgIGlmICh0YWJJbmRleFZhbHVlID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSB0YWJpbmRleCBpcyBleHBsaWNpdGx5IHNldCwgYW5kIG5vdCBgLTFgIChhcyBwZXIgY2hlY2sgYmVmb3JlKSwgdGhlXG4gICAgICAgICAgICAvLyB2aWRlbyBlbGVtZW50IGlzIGFsd2F5cyB0YWJiYWJsZSAocmVnYXJkbGVzcyBvZiB3aGV0aGVyIGl0IGhhcyBjb250cm9scyBvciBub3QpLlxuICAgICAgICAgICAgaWYgKHRhYkluZGV4VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSAod2hlbiBubyBleHBsaWNpdCB0YWJpbmRleCBpcyBzZXQpLCBhIHZpZGVvIGlzIG9ubHkgdGFiYmFibGUgaWYgaXRcbiAgICAgICAgICAgIC8vIGhhcyBjb250cm9scyBlbmFibGVkLiBGaXJlZm94IGlzIHNwZWNpYWwgYXMgdmlkZW9zIGFyZSBhbHdheXMgdGFiYmFibGUgcmVnYXJkbGVzc1xuICAgICAgICAgICAgLy8gb2Ygd2hldGhlciB0aGVyZSBhcmUgY29udHJvbHMgb3Igbm90LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXRmb3JtLkZJUkVGT1ggfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQudGFiSW5kZXggPj0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgY29uZmlnIG9iamVjdCB3aXRoIG9wdGlvbnMgdG8gY3VzdG9taXplIHRoaXMgbWV0aG9kJ3MgYmVoYXZpb3JcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGZvY3VzYWJsZS5cbiAgICAgKi9cbiAgICBpc0ZvY3VzYWJsZShlbGVtZW50LCBjb25maWcpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjaGVja3MgaW4gb3JkZXIgb2YgbGVmdCB0byBtb3N0IGV4cGVuc2l2ZS5cbiAgICAgICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgICByZXR1cm4gKGlzUG90ZW50aWFsbHlGb2N1c2FibGUoZWxlbWVudCkgJiZcbiAgICAgICAgICAgICF0aGlzLmlzRGlzYWJsZWQoZWxlbWVudCkgJiZcbiAgICAgICAgICAgIChjb25maWc/Lmlnbm9yZVZpc2liaWxpdHkgfHwgdGhpcy5pc1Zpc2libGUoZWxlbWVudCkpKTtcbiAgICB9XG59XG5JbnRlcmFjdGl2aXR5Q2hlY2tlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEludGVyYWN0aXZpdHlDaGVja2VyLCBkZXBzOiBbeyB0b2tlbjogaTEuUGxhdGZvcm0gfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkludGVyYWN0aXZpdHlDaGVja2VyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEludGVyYWN0aXZpdHlDaGVja2VyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJbnRlcmFjdGl2aXR5Q2hlY2tlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMS5QbGF0Zm9ybSB9XTsgfSB9KTtcbi8qKlxuICogUmV0dXJucyB0aGUgZnJhbWUgZWxlbWVudCBmcm9tIGEgd2luZG93IG9iamVjdC4gU2luY2UgYnJvd3NlcnMgbGlrZSBNUyBFZGdlIHRocm93IGVycm9ycyBpZlxuICogdGhlIGZyYW1lRWxlbWVudCBwcm9wZXJ0eSBpcyBiZWluZyBhY2Nlc3NlZCBmcm9tIGEgZGlmZmVyZW50IGhvc3QgYWRkcmVzcywgdGhpcyBwcm9wZXJ0eVxuICogc2hvdWxkIGJlIGFjY2Vzc2VkIGNhcmVmdWxseS5cbiAqL1xuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbmRvdykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKiBDaGVja3Mgd2hldGhlciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgaGFzIGFueSBnZW9tZXRyeSAvIHJlY3RhbmdsZXMuICovXG5mdW5jdGlvbiBoYXNHZW9tZXRyeShlbGVtZW50KSB7XG4gICAgLy8gVXNlIGxvZ2ljIGZyb20galF1ZXJ5IHRvIGNoZWNrIGZvciBhbiBpbnZpc2libGUgZWxlbWVudC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2Nzcy9oaWRkZW5WaXNpYmxlU2VsZWN0b3JzLmpzI0wxMlxuICAgIHJldHVybiAhIShlbGVtZW50Lm9mZnNldFdpZHRoIHx8XG4gICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8XG4gICAgICAgICh0eXBlb2YgZWxlbWVudC5nZXRDbGllbnRSZWN0cyA9PT0gJ2Z1bmN0aW9uJyAmJiBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoKSk7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQncyAgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlRm9ybUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGxldCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gKG5vZGVOYW1lID09PSAnaW5wdXQnIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ2J1dHRvbicgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGA8aW5wdXQgdHlwZT1cImhpZGRlblwiPmAuICovXG5mdW5jdGlvbiBpc0hpZGRlbklucHV0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC50eXBlID09ICdoaWRkZW4nO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciB0aGF0IGhhcyBhbiBocmVmIGF0dHJpYnV0ZS4gKi9cbmZ1bmN0aW9uIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiBpbnB1dCBlbGVtZW50LiAqL1xuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2lucHV0Jztcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiBhbmNob3IgZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGlzQW5jaG9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSAnYSc7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaGFzIGEgdmFsaWQgdGFiaW5kZXguICovXG5mdW5jdGlvbiBoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IGVsZW1lbnQudGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIHJldHVybiAhISh0YWJJbmRleCAmJiAhaXNOYU4ocGFyc2VJbnQodGFiSW5kZXgsIDEwKSkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJzZWQgdGFiaW5kZXggZnJvbSB0aGUgZWxlbWVudCBhdHRyaWJ1dGVzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZVxuICogZXZhbHVhdGVkIHRhYmluZGV4IGZyb20gdGhlIGJyb3dzZXJzIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBnZXRUYWJJbmRleFZhbHVlKGVsZW1lbnQpIHtcbiAgICBpZiAoIWhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFNlZSBicm93c2VyIGlzc3VlIGluIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8ICcnLCAxMCk7XG4gICAgcmV0dXJuIGlzTmFOKHRhYkluZGV4KSA/IC0xIDogdGFiSW5kZXg7XG59XG4vKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBlbGVtZW50IGlzIHBvdGVudGlhbGx5IHRhYmJhYmxlIG9uIGlPUyAqL1xuZnVuY3Rpb24gaXNQb3RlbnRpYWxseVRhYmJhYmxlSU9TKGVsZW1lbnQpIHtcbiAgICBsZXQgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IGlucHV0VHlwZSA9IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZTtcbiAgICByZXR1cm4gKGlucHV0VHlwZSA9PT0gJ3RleHQnIHx8XG4gICAgICAgIGlucHV0VHlwZSA9PT0gJ3Bhc3N3b3JkJyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuLyoqXG4gKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBwb3RlbnRpYWxseSBmb2N1c2FibGUgd2l0aG91dCB0YWtpbmcgY3VycmVudCB2aXNpYmxlL2Rpc2FibGVkIHN0YXRlXG4gKiBpbnRvIGFjY291bnQuXG4gKi9cbmZ1bmN0aW9uIGlzUG90ZW50aWFsbHlGb2N1c2FibGUoZWxlbWVudCkge1xuICAgIC8vIElucHV0cyBhcmUgcG90ZW50aWFsbHkgZm9jdXNhYmxlICp1bmxlc3MqIHRoZXkncmUgdHlwZT1cImhpZGRlblwiLlxuICAgIGlmIChpc0hpZGRlbklucHV0KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChpc05hdGl2ZUZvcm1FbGVtZW50KGVsZW1lbnQpIHx8XG4gICAgICAgIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudCkgfHxcbiAgICAgICAgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpIHx8XG4gICAgICAgIGhhc1ZhbGlkVGFiSW5kZXgoZWxlbWVudCkpO1xufVxuLyoqIEdldHMgdGhlIHBhcmVudCB3aW5kb3cgb2YgYSBET00gbm9kZSB3aXRoIHJlZ2FyZHMgb2YgYmVpbmcgaW5zaWRlIG9mIGFuIGlmcmFtZS4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgLy8gb3duZXJEb2N1bWVudCBpcyBudWxsIGlmIGBub2RlYCBpdHNlbGYgKmlzKiBhIGRvY3VtZW50LlxuICAgIHJldHVybiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2xhc3MgdGhhdCBhbGxvd3MgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgY2xhc3MgY3VycmVudGx5IHVzZXMgYSByZWxhdGl2ZWx5IHNpbXBsZSBhcHByb2FjaCB0byBmb2N1cyB0cmFwcGluZy5cbiAqIEl0IGFzc3VtZXMgdGhhdCB0aGUgdGFiIG9yZGVyIGlzIHRoZSBzYW1lIGFzIERPTSBvcmRlciwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRydWUuXG4gKiBUaGluZ3MgbGlrZSBgdGFiSW5kZXggPiAwYCwgZmxleCBgb3JkZXJgLCBhbmQgc2hhZG93IHJvb3RzIGNhbiBjYXVzZSB0aGUgdHdvIHRvIGJlIG1pc2FsaWduZWQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGBDb25maWd1cmFibGVGb2N1c1RyYXBgIGluc3RlYWQuXG4gKiBAYnJlYWtpbmctY2hhbmdlIDExLjAuMFxuICovXG5jbGFzcyBGb2N1c1RyYXAge1xuICAgIC8qKiBXaGV0aGVyIHRoZSBmb2N1cyB0cmFwIGlzIGFjdGl2ZS4gKi9cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfVxuICAgIHNldCBlbmFibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0QW5jaG9yICYmIHRoaXMuX2VuZEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5fdG9nZ2xlQW5jaG9yVGFiSW5kZXgodmFsdWUsIHRoaXMuX3N0YXJ0QW5jaG9yKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuY2hvclRhYkluZGV4KHZhbHVlLCB0aGlzLl9lbmRBbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50LCBfY2hlY2tlciwgX25nWm9uZSwgX2RvY3VtZW50LCBkZWZlckFuY2hvcnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2NoZWNrZXIgPSBfY2hlY2tlcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2hhc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIC8vIEV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGFuY2hvcnMuIE5lZWQgdG8gYmUgcmVndWxhciBmdW5jdGlvbnMgc28gdGhhdCB3ZSBjYW4gdW5iaW5kIHRoZW0gbGF0ZXIuXG4gICAgICAgIHRoaXMuc3RhcnRBbmNob3JMaXN0ZW5lciA9ICgpID0+IHRoaXMuZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuZW5kQW5jaG9yTGlzdGVuZXIgPSAoKSA9PiB0aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGlmICghZGVmZXJBbmNob3JzKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEFuY2hvcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRGVzdHJveXMgdGhlIGZvY3VzIHRyYXAgYnkgY2xlYW5pbmcgdXAgdGhlIGFuY2hvcnMuICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRBbmNob3IgPSB0aGlzLl9zdGFydEFuY2hvcjtcbiAgICAgICAgY29uc3QgZW5kQW5jaG9yID0gdGhpcy5fZW5kQW5jaG9yO1xuICAgICAgICBpZiAoc3RhcnRBbmNob3IpIHtcbiAgICAgICAgICAgIHN0YXJ0QW5jaG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5zdGFydEFuY2hvckxpc3RlbmVyKTtcbiAgICAgICAgICAgIHN0YXJ0QW5jaG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRBbmNob3IpIHtcbiAgICAgICAgICAgIGVuZEFuY2hvci5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuZW5kQW5jaG9yTGlzdGVuZXIpO1xuICAgICAgICAgICAgZW5kQW5jaG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0QW5jaG9yID0gdGhpcy5fZW5kQW5jaG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGUgYW5jaG9ycyBpbnRvIHRoZSBET00uIFRoaXMgaXMgdXN1YWxseSBkb25lIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBjYW4gYmUgZGVmZXJyZWQgZm9yIGNhc2VzIGxpa2UgZGlyZWN0aXZlcyB3aXRoIGAqbmdJZmAuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZm9jdXMgdHJhcCBtYW5hZ2VkIHRvIGF0dGFjaCBzdWNjZXNzZnVsbHkuIFRoaXMgbWF5IG5vdCBiZSB0aGUgY2FzZVxuICAgICAqIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBpc24ndCBjdXJyZW50bHkgaW4gdGhlIERPTS5cbiAgICAgKi9cbiAgICBhdHRhY2hBbmNob3JzKCkge1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgb24gdGhlIGJyb3dzZXIsIHRoZXJlIGNhbiBiZSBubyBmb2N1cyB0byB0cmFwLlxuICAgICAgICBpZiAodGhpcy5faGFzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0QW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRBbmNob3IgPSB0aGlzLl9jcmVhdGVBbmNob3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEFuY2hvci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuc3RhcnRBbmNob3JMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VuZEFuY2hvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZEFuY2hvciA9IHRoaXMuX2NyZWF0ZUFuY2hvcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZEFuY2hvci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuZW5kQW5jaG9yTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9zdGFydEFuY2hvciwgdGhpcy5fZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX2VuZEFuY2hvciwgdGhpcy5fZWxlbWVudC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB0aGlzLl9oYXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0F0dGFjaGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIHpvbmUgdG8gc3RhYmlsaXplLCB0aGVuIGZvY3VzZXMgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgYm9vbGVhbiwgZGVwZW5kaW5nXG4gICAgICogb24gd2hldGhlciBmb2N1cyB3YXMgbW92ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlT25TdGFibGUoKCkgPT4gcmVzb2x2ZSh0aGlzLmZvY3VzSW5pdGlhbEVsZW1lbnQob3B0aW9ucykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzdGFiaWxpemUsIHRoZW4gZm9jdXNlc1xuICAgICAqIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybnMgUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgYm9vbGVhbiwgZGVwZW5kaW5nXG4gICAgICogb24gd2hldGhlciBmb2N1cyB3YXMgbW92ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnRXaGVuUmVhZHkob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlT25TdGFibGUoKCkgPT4gcmVzb2x2ZSh0aGlzLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQob3B0aW9ucykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgem9uZSB0byBzdGFiaWxpemUsIHRoZW4gZm9jdXNlc1xuICAgICAqIHRoZSBsYXN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggYSBib29sZWFuLCBkZXBlbmRpbmdcbiAgICAgKiBvbiB3aGV0aGVyIGZvY3VzIHdhcyBtb3ZlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50V2hlblJlYWR5KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZU9uU3RhYmxlKCgpID0+IHJlc29sdmUodGhpcy5mb2N1c0xhc3RUYWJiYWJsZUVsZW1lbnQob3B0aW9ucykpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3BlY2lmaWVkIGJvdW5kYXJ5IGVsZW1lbnQgb2YgdGhlIHRyYXBwZWQgcmVnaW9uLlxuICAgICAqIEBwYXJhbSBib3VuZCBUaGUgYm91bmRhcnkgdG8gZ2V0IChzdGFydCBvciBlbmQgb2YgdHJhcHBlZCByZWdpb24pLlxuICAgICAqIEByZXR1cm5zIFRoZSBib3VuZGFyeSBlbGVtZW50LlxuICAgICAqL1xuICAgIF9nZXRSZWdpb25Cb3VuZGFyeShib3VuZCkge1xuICAgICAgICAvLyBDb250YWlucyB0aGUgZGVwcmVjYXRlZCB2ZXJzaW9uIG9mIHNlbGVjdG9yLCBmb3IgdGVtcG9yYXJ5IGJhY2t3YXJkcyBjb21wYXJhYmlsaXR5LlxuICAgICAgICBjb25zdCBtYXJrZXJzID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbY2RrLWZvY3VzLXJlZ2lvbi0ke2JvdW5kfV0sIGAgKyBgW2Nka0ZvY3VzUmVnaW9uJHtib3VuZH1dLCBgICsgYFtjZGstZm9jdXMtJHtib3VuZH1dYCk7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgOC4wLjBcbiAgICAgICAgICAgICAgICBpZiAobWFya2Vyc1tpXS5oYXNBdHRyaWJ1dGUoYGNkay1mb2N1cy0ke2JvdW5kfWApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRm91bmQgdXNlIG9mIGRlcHJlY2F0ZWQgYXR0cmlidXRlICdjZGstZm9jdXMtJHtib3VuZH0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB1c2UgJ2Nka0ZvY3VzUmVnaW9uJHtib3VuZH0nIGluc3RlYWQuIFRoZSBkZXByZWNhdGVkIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgaW4gOC4wLjAuYCwgbWFya2Vyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmtlcnNbaV0uaGFzQXR0cmlidXRlKGBjZGstZm9jdXMtcmVnaW9uLSR7Ym91bmR9YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGb3VuZCB1c2Ugb2YgZGVwcmVjYXRlZCBhdHRyaWJ1dGUgJ2Nkay1mb2N1cy1yZWdpb24tJHtib3VuZH0nLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB1c2UgJ2Nka0ZvY3VzUmVnaW9uJHtib3VuZH0nIGluc3RlYWQuIFRoZSBkZXByZWNhdGVkIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB3aWxsIGJlIHJlbW92ZWQgaW4gOC4wLjAuYCwgbWFya2Vyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZCA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFya2Vycy5sZW5ndGggPyBtYXJrZXJzWzBdIDogdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtlcnMubGVuZ3RoXG4gICAgICAgICAgICA/IG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgOiB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb2N1c2VzIHRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIGZvY3VzZWQgd2hlbiB0aGUgZm9jdXMgdHJhcCBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIGZvY3VzIHdhcyBtb3ZlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgZm9jdXNJbml0aWFsRWxlbWVudChvcHRpb25zKSB7XG4gICAgICAgIC8vIENvbnRhaW5zIHRoZSBkZXByZWNhdGVkIHZlcnNpb24gb2Ygc2VsZWN0b3IsIGZvciB0ZW1wb3JhcnkgYmFja3dhcmRzIGNvbXBhcmFiaWxpdHkuXG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKGBbY2RrLWZvY3VzLWluaXRpYWxdLCBgICsgYFtjZGtGb2N1c0luaXRpYWxdYCk7XG4gICAgICAgIGlmIChyZWRpcmVjdFRvRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gQGJyZWFraW5nLWNoYW5nZSA4LjAuMFxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUb0VsZW1lbnQuaGFzQXR0cmlidXRlKGBjZGstZm9jdXMtaW5pdGlhbGApKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBGb3VuZCB1c2Ugb2YgZGVwcmVjYXRlZCBhdHRyaWJ1dGUgJ2Nkay1mb2N1cy1pbml0aWFsJywgYCArXG4gICAgICAgICAgICAgICAgICAgIGB1c2UgJ2Nka0ZvY3VzSW5pdGlhbCcgaW5zdGVhZC4gVGhlIGRlcHJlY2F0ZWQgYXR0cmlidXRlIGAgK1xuICAgICAgICAgICAgICAgICAgICBgd2lsbCBiZSByZW1vdmVkIGluIDguMC4wYCwgcmVkaXJlY3RUb0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2FybiB0aGUgY29uc3VtZXIgaWYgdGhlIGVsZW1lbnQgdGhleSd2ZSBwb2ludGVkIHRvXG4gICAgICAgICAgICAvLyBpc24ndCBmb2N1c2FibGUsIHdoZW4gbm90IGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgICAgICAgIGlmICgodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLl9jaGVja2VyLmlzRm9jdXNhYmxlKHJlZGlyZWN0VG9FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRWxlbWVudCBtYXRjaGluZyAnW2Nka0ZvY3VzSW5pdGlhbF0nIGlzIG5vdCBmb2N1c2FibGUuYCwgcmVkaXJlY3RUb0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGVja2VyLmlzRm9jdXNhYmxlKHJlZGlyZWN0VG9FbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZUNoaWxkID0gdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQocmVkaXJlY3RUb0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGZvY3VzYWJsZUNoaWxkPy5mb2N1cyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmb2N1c2FibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCB3aXRoaW4gdGhlIGZvY3VzIHRyYXAgcmVnaW9uLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgZm9jdXMgd2FzIG1vdmVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBmb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9nZXRSZWdpb25Cb3VuZGFyeSgnc3RhcnQnKTtcbiAgICAgICAgaWYgKHJlZGlyZWN0VG9FbGVtZW50KSB7XG4gICAgICAgICAgICByZWRpcmVjdFRvRWxlbWVudC5mb2N1cyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISFyZWRpcmVjdFRvRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uXG4gICAgICogQHJldHVybnMgV2hldGhlciBmb2N1cyB3YXMgbW92ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZ2V0UmVnaW9uQm91bmRhcnkoJ2VuZCcpO1xuICAgICAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXJlZGlyZWN0VG9FbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZm9jdXMgdHJhcCBoYXMgc3VjY2Vzc2Z1bGx5IGJlZW4gYXR0YWNoZWQuXG4gICAgICovXG4gICAgaGFzQXR0YWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNBdHRhY2hlZDtcbiAgICB9XG4gICAgLyoqIEdldCB0aGUgZmlyc3QgdGFiYmFibGUgZWxlbWVudCBmcm9tIGEgRE9NIHN1YnRyZWUgKGluY2x1c2l2ZSkuICovXG4gICAgX2dldEZpcnN0VGFiYmFibGVFbGVtZW50KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYmJhYmxlQ2hpbGQgPSBjaGlsZHJlbltpXS5ub2RlVHlwZSA9PT0gdGhpcy5fZG9jdW1lbnQuRUxFTUVOVF9OT0RFXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudChjaGlsZHJlbltpXSlcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJiYWJsZUNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBsYXN0IHRhYmJhYmxlIGVsZW1lbnQgZnJvbSBhIERPTSBzdWJ0cmVlIChpbmNsdXNpdmUpLiAqL1xuICAgIF9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgRE9NIG9yZGVyLlxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHJvb3QuY2hpbGRyZW47XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgdGFiYmFibGVDaGlsZCA9IGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSB0aGlzLl9kb2N1bWVudC5FTEVNRU5UX05PREVcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2dldExhc3RUYWJiYWJsZUVsZW1lbnQoY2hpbGRyZW5baV0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYW4gYW5jaG9yIGVsZW1lbnQuICovXG4gICAgX2NyZWF0ZUFuY2hvcigpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3RvZ2dsZUFuY2hvclRhYkluZGV4KHRoaXMuX2VuYWJsZWQsIGFuY2hvcik7XG4gICAgICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKCdjZGstZm9jdXMtdHJhcC1hbmNob3InKTtcbiAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBgdGFiaW5kZXhgIG9mIGFuIGFuY2hvciwgYmFzZWQgb24gdGhlIGVuYWJsZWQgc3RhdGUgb2YgdGhlIGZvY3VzIHRyYXAuXG4gICAgICogQHBhcmFtIGlzRW5hYmxlZCBXaGV0aGVyIHRoZSBmb2N1cyB0cmFwIGlzIGVuYWJsZWQuXG4gICAgICogQHBhcmFtIGFuY2hvciBBbmNob3Igb24gd2hpY2ggdG8gdG9nZ2xlIHRoZSB0YWJpbmRleC5cbiAgICAgKi9cbiAgICBfdG9nZ2xlQW5jaG9yVGFiSW5kZXgoaXNFbmFibGVkLCBhbmNob3IpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWJpbmRleCBjb21wbGV0ZWx5LCByYXRoZXIgdGhhbiBzZXR0aW5nIGl0IHRvIC0xLCBiZWNhdXNlIGlmIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGhhcyBhIHRhYmluZGV4LCB0aGUgdXNlciBtaWdodCBzdGlsbCBoaXQgaXQgd2hlbiBuYXZpZ2F0aW5nIHdpdGggdGhlIGFycm93IGtleXMuXG4gICAgICAgIGlzRW5hYmxlZCA/IGFuY2hvci5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKSA6IGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlYHRhYmluZGV4YCBvZiBib3RoIGFuY2hvcnMgdG8gZWl0aGVyIHRyYXAgVGFiIGZvY3VzIG9yIGFsbG93IGl0IHRvIGVzY2FwZS5cbiAgICAgKiBAcGFyYW0gZW5hYmxlZDogV2hldGhlciB0aGUgYW5jaG9ycyBzaG91bGQgdHJhcCBUYWIuXG4gICAgICovXG4gICAgdG9nZ2xlQW5jaG9ycyhlbmFibGVkKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGFydEFuY2hvciAmJiB0aGlzLl9lbmRBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuY2hvclRhYkluZGV4KGVuYWJsZWQsIHRoaXMuX3N0YXJ0QW5jaG9yKTtcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZUFuY2hvclRhYkluZGV4KGVuYWJsZWQsIHRoaXMuX2VuZEFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEV4ZWN1dGVzIGEgZnVuY3Rpb24gd2hlbiB0aGUgem9uZSBpcyBzdGFibGUuICovXG4gICAgX2V4ZWN1dGVPblN0YWJsZShmbikge1xuICAgICAgICBpZiAodGhpcy5fbmdab25lLmlzU3RhYmxlKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKGZuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRmFjdG9yeSB0aGF0IGFsbG93cyBlYXN5IGluc3RhbnRpYXRpb24gb2YgZm9jdXMgdHJhcHMuXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENvbmZpZ3VyYWJsZUZvY3VzVHJhcEZhY3RvcnlgIGluc3RlYWQuXG4gKiBAYnJlYWtpbmctY2hhbmdlIDExLjAuMFxuICovXG5jbGFzcyBGb2N1c1RyYXBGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihfY2hlY2tlciwgX25nWm9uZSwgX2RvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuX2NoZWNrZXIgPSBfY2hlY2tlcjtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmb2N1cy10cmFwcGVkIHJlZ2lvbiBhcm91bmQgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgYXJvdW5kIHdoaWNoIGZvY3VzIHdpbGwgYmUgdHJhcHBlZC5cbiAgICAgKiBAcGFyYW0gZGVmZXJDYXB0dXJlRWxlbWVudHMgRGVmZXJzIHRoZSBjcmVhdGlvbiBvZiBmb2N1cy1jYXB0dXJpbmcgZWxlbWVudHMgdG8gYmUgZG9uZVxuICAgICAqICAgICBtYW51YWxseSBieSB0aGUgdXNlci5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBmb2N1cyB0cmFwIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNyZWF0ZShlbGVtZW50LCBkZWZlckNhcHR1cmVFbGVtZW50cyA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKGVsZW1lbnQsIHRoaXMuX2NoZWNrZXIsIHRoaXMuX25nWm9uZSwgdGhpcy5fZG9jdW1lbnQsIGRlZmVyQ2FwdHVyZUVsZW1lbnRzKTtcbiAgICB9XG59XG5Gb2N1c1RyYXBGYWN0b3J5Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNUcmFwRmFjdG9yeSwgZGVwczogW3sgdG9rZW46IEludGVyYWN0aXZpdHlDaGVja2VyIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBET0NVTUVOVCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRm9jdXNUcmFwRmFjdG9yeS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb2N1c1RyYXBGYWN0b3J5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IEludGVyYWN0aXZpdHlDaGVja2VyIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcbi8qKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi4gKi9cbmNsYXNzIENka1RyYXBGb2N1cyB7XG4gICAgLyoqIFdoZXRoZXIgdGhlIGZvY3VzIHRyYXAgaXMgYWN0aXZlLiAqL1xuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb2N1c1RyYXAuZW5hYmxlZDtcbiAgICB9XG4gICAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuZW5hYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGRpcmVjdGl2ZSBzaG91bGQgYXV0b21hdGljYWxseSBtb3ZlIGZvY3VzIGludG8gdGhlIHRyYXBwZWQgcmVnaW9uIHVwb25cbiAgICAgKiBpbml0aWFsaXphdGlvbiBhbmQgcmV0dXJuIGZvY3VzIHRvIHRoZSBwcmV2aW91cyBhY3RpdmVFbGVtZW50IHVwb24gZGVzdHJ1Y3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGF1dG9DYXB0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b0NhcHR1cmU7XG4gICAgfVxuICAgIHNldCBhdXRvQ2FwdHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdXRvQ2FwdHVyZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmLCBfZm9jdXNUcmFwRmFjdG9yeSwgXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgTm8gbG9uZ2VyIGJlaW5nIHVzZWQuIFRvIGJlIHJlbW92ZWQuXG4gICAgICogQGJyZWFraW5nLWNoYW5nZSAxMy4wLjBcbiAgICAgKi9cbiAgICBfZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXBGYWN0b3J5ID0gX2ZvY3VzVHJhcEZhY3Rvcnk7XG4gICAgICAgIC8qKiBQcmV2aW91c2x5IGZvY3VzZWQgZWxlbWVudCB0byByZXN0b3JlIGZvY3VzIHRvIHVwb24gZGVzdHJveSB3aGVuIHVzaW5nIGF1dG9DYXB0dXJlLiAqL1xuICAgICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IHRoaXMuX2ZvY3VzVHJhcEZhY3RvcnkuY3JlYXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICAgIC8vIElmIHdlIHN0b3JlZCBhIHByZXZpb3VzbHkgZm9jdXNlZCBlbGVtZW50IHdoZW4gdXNpbmcgYXV0b0NhcHR1cmUsIHJldHVybiBmb2N1cyB0byB0aGF0XG4gICAgICAgIC8vIGVsZW1lbnQgbm93IHRoYXQgdGhlIHRyYXBwZWQgcmVnaW9uIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuYXR0YWNoQW5jaG9ycygpO1xuICAgICAgICBpZiAodGhpcy5hdXRvQ2FwdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FwdHVyZUZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9jdXNUcmFwLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmF0dGFjaEFuY2hvcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGF1dG9DYXB0dXJlQ2hhbmdlID0gY2hhbmdlc1snYXV0b0NhcHR1cmUnXTtcbiAgICAgICAgaWYgKGF1dG9DYXB0dXJlQ2hhbmdlICYmXG4gICAgICAgICAgICAhYXV0b0NhcHR1cmVDaGFuZ2UuZmlyc3RDaGFuZ2UgJiZcbiAgICAgICAgICAgIHRoaXMuYXV0b0NhcHR1cmUgJiZcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhcHR1cmVGb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jYXB0dXJlRm9jdXMoKSB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IF9nZXRGb2N1c2VkRWxlbWVudFBpZXJjZVNoYWRvd0RvbSgpO1xuICAgICAgICB0aGlzLmZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50V2hlblJlYWR5KCk7XG4gICAgfVxufVxuQ2RrVHJhcEZvY3VzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVHJhcEZvY3VzLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBGb2N1c1RyYXBGYWN0b3J5IH0sIHsgdG9rZW46IERPQ1VNRU5UIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka1RyYXBGb2N1cy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka1RyYXBGb2N1cywgc2VsZWN0b3I6IFwiW2Nka1RyYXBGb2N1c11cIiwgaW5wdXRzOiB7IGVuYWJsZWQ6IFtcImNka1RyYXBGb2N1c1wiLCBcImVuYWJsZWRcIl0sIGF1dG9DYXB0dXJlOiBbXCJjZGtUcmFwRm9jdXNBdXRvQ2FwdHVyZVwiLCBcImF1dG9DYXB0dXJlXCJdIH0sIGV4cG9ydEFzOiBbXCJjZGtUcmFwRm9jdXNcIl0sIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RyYXBGb2N1cywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nka1RyYXBGb2N1c10nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ2Nka1RyYXBGb2N1cycsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5FbGVtZW50UmVmIH0sIHsgdHlwZTogRm9jdXNUcmFwRmFjdG9yeSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IGVuYWJsZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydjZGtUcmFwRm9jdXMnXVxuICAgICAgICAgICAgfV0sIGF1dG9DYXB0dXJlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnY2RrVHJhcEZvY3VzQXV0b0NhcHR1cmUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENsYXNzIHRoYXQgYWxsb3dzIGZvciB0cmFwcGluZyBmb2N1cyB3aXRoaW4gYSBET00gZWxlbWVudC5cbiAqXG4gKiBUaGlzIGNsYXNzIHVzZXMgYSBzdHJhdGVneSBwYXR0ZXJuIHRoYXQgZGV0ZXJtaW5lcyBob3cgaXQgdHJhcHMgZm9jdXMuXG4gKiBTZWUgRm9jdXNUcmFwSW5lcnRTdHJhdGVneS5cbiAqL1xuY2xhc3MgQ29uZmlndXJhYmxlRm9jdXNUcmFwIGV4dGVuZHMgRm9jdXNUcmFwIHtcbiAgICAvKiogV2hldGhlciB0aGUgRm9jdXNUcmFwIGlzIGVuYWJsZWQuICovXG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH1cbiAgICBzZXQgZW5hYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c1RyYXBNYW5hZ2VyLnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwTWFuYWdlci5kZXJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50LCBfY2hlY2tlciwgX25nWm9uZSwgX2RvY3VtZW50LCBfZm9jdXNUcmFwTWFuYWdlciwgX2luZXJ0U3RyYXRlZ3ksIGNvbmZpZykge1xuICAgICAgICBzdXBlcihfZWxlbWVudCwgX2NoZWNrZXIsIF9uZ1pvbmUsIF9kb2N1bWVudCwgY29uZmlnLmRlZmVyKTtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwTWFuYWdlciA9IF9mb2N1c1RyYXBNYW5hZ2VyO1xuICAgICAgICB0aGlzLl9pbmVydFN0cmF0ZWd5ID0gX2luZXJ0U3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcE1hbmFnZXIucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKiBOb3RpZmllcyB0aGUgRm9jdXNUcmFwTWFuYWdlciB0aGF0IHRoaXMgRm9jdXNUcmFwIHdpbGwgYmUgZGVzdHJveWVkLiAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcE1hbmFnZXIuZGVyZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIE1hbmFnZWRGb2N1c1RyYXAuICovXG4gICAgX2VuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5faW5lcnRTdHJhdGVneS5wcmV2ZW50Rm9jdXModGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlQW5jaG9ycyh0cnVlKTtcbiAgICB9XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBNYW5hZ2VkRm9jdXNUcmFwLiAqL1xuICAgIF9kaXNhYmxlKCkge1xuICAgICAgICB0aGlzLl9pbmVydFN0cmF0ZWd5LmFsbG93Rm9jdXModGhpcyk7XG4gICAgICAgIHRoaXMudG9nZ2xlQW5jaG9ycyhmYWxzZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogVGhlIGluamVjdGlvbiB0b2tlbiB1c2VkIHRvIHNwZWNpZnkgdGhlIGluZXJ0IHN0cmF0ZWd5LiAqL1xuY29uc3QgRk9DVVNfVFJBUF9JTkVSVF9TVFJBVEVHWSA9IG5ldyBJbmplY3Rpb25Ub2tlbignRk9DVVNfVFJBUF9JTkVSVF9TVFJBVEVHWScpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogTGlnaHR3ZWlnaHQgRm9jdXNUcmFwSW5lcnRTdHJhdGVneSB0aGF0IGFkZHMgYSBkb2N1bWVudCBmb2N1cyBldmVudFxuICogbGlzdGVuZXIgdG8gcmVkaXJlY3QgZm9jdXMgYmFjayBpbnNpZGUgdGhlIEZvY3VzVHJhcC5cbiAqL1xuY2xhc3MgRXZlbnRMaXN0ZW5lckZvY3VzVHJhcEluZXJ0U3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKiogRm9jdXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyIHRoYXQga2VlcHMgZm9jdXMgaW5zaWRlIHRoZSBGb2N1c1RyYXAuICovXG4gICAgcHJldmVudEZvY3VzKGZvY3VzVHJhcCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUncyBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgZG9jdW1lbnRcbiAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVyKSB7XG4gICAgICAgICAgICBmb2N1c1RyYXAuX2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyID0gKGUpID0+IHRoaXMuX3RyYXBGb2N1cyhmb2N1c1RyYXAsIGUpO1xuICAgICAgICBmb2N1c1RyYXAuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBmb2N1c1RyYXAuX2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVyIGFkZGVkIGluIHByZXZlbnRGb2N1cy4gKi9cbiAgICBhbGxvd0ZvY3VzKGZvY3VzVHJhcCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9jdXNUcmFwLl9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2xpc3RlbmVyLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZvY3VzZXMgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIEZvY3VzVHJhcCBpZiB0aGUgZm9jdXMgZXZlbnQgdGFyZ2V0IHdhcyBvdXRzaWRlXG4gICAgICogdGhlIEZvY3VzVHJhcC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZXZlbnQgbGlzdGVuZXIgY2FsbGJhY2suIFRoZSBldmVudCBsaXN0ZW5lciBpcyBhZGRlZCBpbiBydW5PdXRzaWRlQW5ndWxhcixcbiAgICAgKiBzbyBhbGwgdGhpcyBjb2RlIHJ1bnMgb3V0c2lkZSBBbmd1bGFyIGFzIHdlbGwuXG4gICAgICovXG4gICAgX3RyYXBGb2N1cyhmb2N1c1RyYXAsIGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgZm9jdXNUcmFwUm9vdCA9IGZvY3VzVHJhcC5fZWxlbWVudDtcbiAgICAgICAgLy8gRG9uJ3QgcmVmb2N1cyBpZiB0YXJnZXQgd2FzIGluIGFuIG92ZXJsYXksIGJlY2F1c2UgdGhlIG92ZXJsYXkgbWlnaHQgYmUgYXNzb2NpYXRlZFxuICAgICAgICAvLyB3aXRoIGFuIGVsZW1lbnQgaW5zaWRlIHRoZSBGb2N1c1RyYXAsIGV4LiBtYXQtc2VsZWN0LlxuICAgICAgICBpZiAodGFyZ2V0ICYmICFmb2N1c1RyYXBSb290LmNvbnRhaW5zKHRhcmdldCkgJiYgIXRhcmdldC5jbG9zZXN0Py4oJ2Rpdi5jZGstb3ZlcmxheS1wYW5lJykpIHtcbiAgICAgICAgICAgIC8vIFNvbWUgbGVnYWN5IEZvY3VzVHJhcCB1c2FnZXMgaGF2ZSBsb2dpYyB0aGF0IGZvY3VzZXMgc29tZSBlbGVtZW50IG9uIHRoZSBwYWdlXG4gICAgICAgICAgICAvLyBqdXN0IGJlZm9yZSBGb2N1c1RyYXAgaXMgZGVzdHJveWVkLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdhaXRcbiAgICAgICAgICAgIC8vIHRvIGJlIHN1cmUgRm9jdXNUcmFwIGlzIHN0aWxsIGVuYWJsZWQgYmVmb3JlIHJlZm9jdXNpbmcuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIGZvY3VzIHdhc24ndCBwdXQgYmFjayBpbnRvIHRoZSBmb2N1cyB0cmFwIHdoaWxlIHRoZSB0aW1lb3V0IHdhcyBwZW5kaW5nLlxuICAgICAgICAgICAgICAgIGlmIChmb2N1c1RyYXAuZW5hYmxlZCAmJiAhZm9jdXNUcmFwUm9vdC5jb250YWlucyhmb2N1c1RyYXAuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzVHJhcC5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEluamVjdGFibGUgdGhhdCBlbnN1cmVzIG9ubHkgdGhlIG1vc3QgcmVjZW50bHkgZW5hYmxlZCBGb2N1c1RyYXAgaXMgYWN0aXZlLiAqL1xuY2xhc3MgRm9jdXNUcmFwTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIEEgc3RhY2sgb2YgdGhlIEZvY3VzVHJhcHMgb24gdGhlIHBhZ2UuIE9ubHkgdGhlIEZvY3VzVHJhcCBhdCB0aGVcbiAgICAgICAgLy8gdG9wIG9mIHRoZSBzdGFjayBpcyBhY3RpdmUuXG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcFN0YWNrID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBGb2N1c1RyYXAgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2ssIGFuZCB0aGVuIHB1c2hlc1xuICAgICAqIHRoZSBuZXcgRm9jdXNUcmFwIG9udG8gdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGZvY3VzVHJhcCkge1xuICAgICAgICAvLyBEZWR1cGUgZm9jdXNUcmFwcyB0aGF0IHJlZ2lzdGVyIG11bHRpcGxlIHRpbWVzLlxuICAgICAgICB0aGlzLl9mb2N1c1RyYXBTdGFjayA9IHRoaXMuX2ZvY3VzVHJhcFN0YWNrLmZpbHRlcihmdCA9PiBmdCAhPT0gZm9jdXNUcmFwKTtcbiAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5fZm9jdXNUcmFwU3RhY2s7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLl9kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChmb2N1c1RyYXApO1xuICAgICAgICBmb2N1c1RyYXAuX2VuYWJsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBGb2N1c1RyYXAgZnJvbSB0aGUgc3RhY2ssIGFuZCBhY3RpdmF0ZXMgdGhlXG4gICAgICogRm9jdXNUcmFwIHRoYXQgaXMgdGhlIG5ldyB0b3Agb2YgdGhlIHN0YWNrLlxuICAgICAqL1xuICAgIGRlcmVnaXN0ZXIoZm9jdXNUcmFwKSB7XG4gICAgICAgIGZvY3VzVHJhcC5fZGlzYWJsZSgpO1xuICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuX2ZvY3VzVHJhcFN0YWNrO1xuICAgICAgICBjb25zdCBpID0gc3RhY2suaW5kZXhPZihmb2N1c1RyYXApO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAxXS5fZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5Gb2N1c1RyYXBNYW5hZ2VyLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNUcmFwTWFuYWdlciwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkZvY3VzVHJhcE1hbmFnZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNUcmFwTWFuYWdlciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNUcmFwTWFuYWdlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEZhY3RvcnkgdGhhdCBhbGxvd3MgZWFzeSBpbnN0YW50aWF0aW9uIG9mIGNvbmZpZ3VyYWJsZSBmb2N1cyB0cmFwcy4gKi9cbmNsYXNzIENvbmZpZ3VyYWJsZUZvY3VzVHJhcEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKF9jaGVja2VyLCBfbmdab25lLCBfZm9jdXNUcmFwTWFuYWdlciwgX2RvY3VtZW50LCBfaW5lcnRTdHJhdGVneSkge1xuICAgICAgICB0aGlzLl9jaGVja2VyID0gX2NoZWNrZXI7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2ZvY3VzVHJhcE1hbmFnZXIgPSBfZm9jdXNUcmFwTWFuYWdlcjtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIC8vIFRPRE8gc3BsaXQgdXAgdGhlIHN0cmF0ZWdpZXMgaW50byBkaWZmZXJlbnQgbW9kdWxlcywgc2ltaWxhciB0byBEYXRlQWRhcHRlci5cbiAgICAgICAgdGhpcy5faW5lcnRTdHJhdGVneSA9IF9pbmVydFN0cmF0ZWd5IHx8IG5ldyBFdmVudExpc3RlbmVyRm9jdXNUcmFwSW5lcnRTdHJhdGVneSgpO1xuICAgIH1cbiAgICBjcmVhdGUoZWxlbWVudCwgY29uZmlnID0geyBkZWZlcjogZmFsc2UgfSkge1xuICAgICAgICBsZXQgY29uZmlnT2JqZWN0O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBjb25maWdPYmplY3QgPSB7IGRlZmVyOiBjb25maWcgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ09iamVjdCA9IGNvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENvbmZpZ3VyYWJsZUZvY3VzVHJhcChlbGVtZW50LCB0aGlzLl9jaGVja2VyLCB0aGlzLl9uZ1pvbmUsIHRoaXMuX2RvY3VtZW50LCB0aGlzLl9mb2N1c1RyYXBNYW5hZ2VyLCB0aGlzLl9pbmVydFN0cmF0ZWd5LCBjb25maWdPYmplY3QpO1xuICAgIH1cbn1cbkNvbmZpZ3VyYWJsZUZvY3VzVHJhcEZhY3RvcnkuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDb25maWd1cmFibGVGb2N1c1RyYXBGYWN0b3J5LCBkZXBzOiBbeyB0b2tlbjogSW50ZXJhY3Rpdml0eUNoZWNrZXIgfSwgeyB0b2tlbjogaTAuTmdab25lIH0sIHsgdG9rZW46IEZvY3VzVHJhcE1hbmFnZXIgfSwgeyB0b2tlbjogRE9DVU1FTlQgfSwgeyB0b2tlbjogRk9DVVNfVFJBUF9JTkVSVF9TVFJBVEVHWSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkNvbmZpZ3VyYWJsZUZvY3VzVHJhcEZhY3RvcnkuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ29uZmlndXJhYmxlRm9jdXNUcmFwRmFjdG9yeSwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ29uZmlndXJhYmxlRm9jdXNUcmFwRmFjdG9yeSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGUsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcm92aWRlZEluOiAncm9vdCcgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBJbnRlcmFjdGl2aXR5Q2hlY2tlciB9LCB7IHR5cGU6IGkwLk5nWm9uZSB9LCB7IHR5cGU6IEZvY3VzVHJhcE1hbmFnZXIgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRk9DVVNfVFJBUF9JTkVSVF9TVFJBVEVHWV1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogR2V0cyB3aGV0aGVyIGFuIGV2ZW50IGNvdWxkIGJlIGEgZmFrZWQgYG1vdXNlZG93bmAgZXZlbnQgZGlzcGF0Y2hlZCBieSBhIHNjcmVlbiByZWFkZXIuICovXG5mdW5jdGlvbiBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyKGV2ZW50KSB7XG4gICAgLy8gU29tZSBzY3JlZW4gcmVhZGVycyB3aWxsIGRpc3BhdGNoIGEgZmFrZSBgbW91c2Vkb3duYCBldmVudCB3aGVuIHByZXNzaW5nIGVudGVyIG9yIHNwYWNlIG9uXG4gICAgLy8gYSBjbGlja2FibGUgZWxlbWVudC4gV2UgY2FuIGRpc3Rpbmd1aXNoIHRoZXNlIGV2ZW50cyB3aGVuIGJvdGggYG9mZnNldFhgIGFuZCBgb2Zmc2V0WWAgYXJlXG4gICAgLy8gemVybyBvciBgZXZlbnQuYnV0dG9uc2AgaXMgemVybywgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyOlxuICAgIC8vIC0gYGV2ZW50LmJ1dHRvbnNgIHdvcmtzIG9uIEZpcmVmb3gsIGJ1dCBmYWlscyBvbiBDaHJvbWUuXG4gICAgLy8gLSBgb2Zmc2V0WGAgYW5kIGBvZmZzZXRZYCB3b3JrIG9uIENocm9tZSwgYnV0IGZhaWwgb24gRmlyZWZveC5cbiAgICAvLyBOb3RlIHRoYXQgdGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIHVzZXIgY291bGQgY2xpY2sgdGhlIDB4MCBzcG90IG9mIHRoZVxuICAgIC8vIHNjcmVlbiB0aGVtc2VsdmVzLCBidXQgdGhhdCBpcyB1bmxpa2VseSB0byBjb250YWluIGludGVyYWN0aXZlIGVsZW1lbnRzLlxuICAgIHJldHVybiBldmVudC5idXR0b25zID09PSAwIHx8IChldmVudC5vZmZzZXRYID09PSAwICYmIGV2ZW50Lm9mZnNldFkgPT09IDApO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBldmVudCBjb3VsZCBiZSBhIGZha2VkIGB0b3VjaHN0YXJ0YCBldmVudCBkaXNwYXRjaGVkIGJ5IGEgc2NyZWVuIHJlYWRlci4gKi9cbmZ1bmN0aW9uIGlzRmFrZVRvdWNoc3RhcnRGcm9tU2NyZWVuUmVhZGVyKGV2ZW50KSB7XG4gICAgY29uc3QgdG91Y2ggPSAoZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzWzBdKSB8fCAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgIC8vIEEgZmFrZSBgdG91Y2hzdGFydGAgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBhIHJlYWwgb25lIGJ5IGxvb2tpbmcgYXQgdGhlIGBpZGVudGlmaWVyYFxuICAgIC8vIHdoaWNoIGlzIHR5cGljYWxseSA+PSAwIG9uIGEgcmVhbCBkZXZpY2UgdmVyc3VzIC0xIGZyb20gYSBzY3JlZW4gcmVhZGVyLiBKdXN0IHRvIGJlIHNhZmUsXG4gICAgLy8gd2UgY2FuIGFsc28gbG9vayBhdCBgcmFkaXVzWGAgYW5kIGByYWRpdXNZYC4gVGhpcyBiZWhhdmlvciB3YXMgb2JzZXJ2ZWQgYWdhaW5zdCBhIFdpbmRvd3MgMTBcbiAgICAvLyBkZXZpY2Ugd2l0aCBhIHRvdWNoIHNjcmVlbiBydW5uaW5nIE5WREEgdjIwMjAuNCBhbmQgRmlyZWZveCA4NSBvciBDaHJvbWUgODguXG4gICAgcmV0dXJuICghIXRvdWNoICYmXG4gICAgICAgIHRvdWNoLmlkZW50aWZpZXIgPT09IC0xICYmXG4gICAgICAgICh0b3VjaC5yYWRpdXNYID09IG51bGwgfHwgdG91Y2gucmFkaXVzWCA9PT0gMSkgJiZcbiAgICAgICAgKHRvdWNoLnJhZGl1c1kgPT0gbnVsbCB8fCB0b3VjaC5yYWRpdXNZID09PSAxKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbmplY3RhYmxlIG9wdGlvbnMgZm9yIHRoZSBJbnB1dE1vZGFsaXR5RGV0ZWN0b3IuIFRoZXNlIGFyZSBzaGFsbG93bHkgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHRcbiAqIG9wdGlvbnMuXG4gKi9cbmNvbnN0IElOUFVUX01PREFMSVRZX0RFVEVDVE9SX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2Nkay1pbnB1dC1tb2RhbGl0eS1kZXRlY3Rvci1vcHRpb25zJyk7XG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIElucHV0TW9kYWxpdHlEZXRlY3Rvci5cbiAqXG4gKiBNb2RpZmllciBrZXlzIGFyZSBpZ25vcmVkIGJ5IGRlZmF1bHQgKGkuZS4gd2hlbiBwcmVzc2VkIHdvbid0IGNhdXNlIHRoZSBzZXJ2aWNlIHRvIGRldGVjdFxuICoga2V5Ym9hcmQgaW5wdXQgbW9kYWxpdHkpIGZvciB0d28gcmVhc29uczpcbiAqXG4gKiAxLiBNb2RpZmllciBrZXlzIGFyZSBjb21tb25seSB1c2VkIHdpdGggbW91c2UgdG8gcGVyZm9ybSBhY3Rpb25zIHN1Y2ggYXMgJ3JpZ2h0IGNsaWNrJyBvciAnb3BlblxuICogICAgaW4gbmV3IHRhYicsIGFuZCBhcmUgdGh1cyBsZXNzIHJlcHJlc2VudGF0aXZlIG9mIGFjdHVhbCBrZXlib2FyZCBpbnRlcmFjdGlvbi5cbiAqIDIuIFZvaWNlT3ZlciB0cmlnZ2VycyBzb21lIGtleWJvYXJkIGV2ZW50cyB3aGVuIGxpbmVhcmx5IG5hdmlnYXRpbmcgd2l0aCBDb250cm9sICsgT3B0aW9uIChidXRcbiAqICAgIGNvbmZ1c2luZ2x5IG5vdCB3aXRoIENhcHMgTG9jaykuIFRodXMsIHRvIGhhdmUgcGFyaXR5IHdpdGggb3RoZXIgc2NyZWVuIHJlYWRlcnMsIHdlIGlnbm9yZVxuICogICAgdGhlc2Uga2V5cyBzbyBhcyB0byBub3QgdXBkYXRlIHRoZSBpbnB1dCBtb2RhbGl0eS5cbiAqXG4gKiBOb3RlIHRoYXQgd2UgZG8gbm90IGJ5IGRlZmF1bHQgaWdub3JlIHRoZSByaWdodCBNZXRhIGtleSBvbiBTYWZhcmkgYmVjYXVzZSBpdCBoYXMgdGhlIHNhbWUga2V5XG4gKiBjb2RlIGFzIHRoZSBDb250ZXh0TWVudSBrZXkgb24gb3RoZXIgYnJvd3NlcnMuIFdoZW4gd2Ugc3dpdGNoIHRvIHVzaW5nIGV2ZW50LmtleSwgd2UgY2FuXG4gKiBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d28uXG4gKi9cbmNvbnN0IElOUFVUX01PREFMSVRZX0RFVEVDVE9SX0RFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBpZ25vcmVLZXlzOiBbQUxULCBDT05UUk9MLCBNQUNfTUVUQSwgTUVUQSwgU0hJRlRdLFxufTtcbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lIG5lZWRlZCB0byBwYXNzIGFmdGVyIGEgdG91Y2hzdGFydCBldmVudCBpbiBvcmRlciBmb3IgYSBzdWJzZXF1ZW50IG1vdXNlZG93blxuICogZXZlbnQgdG8gYmUgYXR0cmlidXRlZCBhcyBtb3VzZSBhbmQgbm90IHRvdWNoLlxuICpcbiAqIFRoaXMgaXMgdGhlIHZhbHVlIHVzZWQgYnkgQW5ndWxhckpTIE1hdGVyaWFsLiBUaHJvdWdoIHRyaWFsIGFuZCBlcnJvciAob24gaVBob25lIDZTKSB0aGV5IGZvdW5kXG4gKiB0aGF0IGEgdmFsdWUgb2YgYXJvdW5kIDY1MG1zIHNlZW1zIGFwcHJvcHJpYXRlLlxuICovXG5jb25zdCBUT1VDSF9CVUZGRVJfTVMgPSA2NTA7XG4vKipcbiAqIEV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgdGhhdCBlbmFibGUgY2FwdHVyaW5nIGFuZCBhbHNvIG1hcmsgdGhlIGxpc3RlbmVyIGFzIHBhc3NpdmUgaWYgdGhlIGJyb3dzZXJcbiAqIHN1cHBvcnRzIGl0LlxuICovXG5jb25zdCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zID0gbm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucyh7XG4gICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICBjYXB0dXJlOiB0cnVlLFxufSk7XG4vKipcbiAqIFNlcnZpY2UgdGhhdCBkZXRlY3RzIHRoZSB1c2VyJ3MgaW5wdXQgbW9kYWxpdHkuXG4gKlxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90IHVwZGF0ZSB0aGUgaW5wdXQgbW9kYWxpdHkgd2hlbiBhIHVzZXIgbmF2aWdhdGVzIHdpdGggYSBzY3JlZW4gcmVhZGVyXG4gKiAoZS5nLiBsaW5lYXIgbmF2aWdhdGlvbiB3aXRoIFZvaWNlT3Zlciwgb2JqZWN0IG5hdmlnYXRpb24gLyBicm93c2UgbW9kZSB3aXRoIE5WREEsIHZpcnR1YWwgUENcbiAqIGN1cnNvciBtb2RlIHdpdGggSkFXUykuIFRoaXMgaXMgaW4gcGFydCBkdWUgdG8gdGVjaG5pY2FsIGxpbWl0YXRpb25zIChpLmUuIGtleWJvYXJkIGV2ZW50cyBkbyBub3RcbiAqIGZpcmUgYXMgZXhwZWN0ZWQgaW4gdGhlc2UgbW9kZXMpIGJ1dCBpcyBhbHNvIGFyZ3VhYmx5IHRoZSBjb3JyZWN0IGJlaGF2aW9yLiBOYXZpZ2F0aW5nIHdpdGggYVxuICogc2NyZWVuIHJlYWRlciBpcyBha2luIHRvIHZpc3VhbGx5IHNjYW5uaW5nIGEgcGFnZSwgYW5kIHNob3VsZCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYWN0dWFsIHVzZXJcbiAqIGlucHV0IGludGVyYWN0aW9uLlxuICpcbiAqIFdoZW4gYSB1c2VyIGlzIG5vdCBuYXZpZ2F0aW5nIGJ1dCAqaW50ZXJhY3RpbmcqIHdpdGggYSBzY3JlZW4gcmVhZGVyLCB0aGlzIHNlcnZpY2UgYXR0ZW1wdHMgdG9cbiAqIHVwZGF0ZSB0aGUgaW5wdXQgbW9kYWxpdHkgdG8ga2V5Ym9hcmQsIGJ1dCBpbiBnZW5lcmFsIHRoaXMgc2VydmljZSdzIGJlaGF2aW9yIGlzIGxhcmdlbHlcbiAqIHVuZGVmaW5lZC5cbiAqL1xuY2xhc3MgSW5wdXRNb2RhbGl0eURldGVjdG9yIHtcbiAgICAvKiogVGhlIG1vc3QgcmVjZW50bHkgZGV0ZWN0ZWQgaW5wdXQgbW9kYWxpdHkuICovXG4gICAgZ2V0IG1vc3RSZWNlbnRNb2RhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGFsaXR5LnZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfcGxhdGZvcm0sIG5nWm9uZSwgZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9zdCByZWNlbnRseSBkZXRlY3RlZCBpbnB1dCBtb2RhbGl0eSBldmVudCB0YXJnZXQuIElzIG51bGwgaWYgbm8gaW5wdXQgbW9kYWxpdHkgaGFzIGJlZW5cbiAgICAgICAgICogZGV0ZWN0ZWQgb3IgaWYgdGhlIGFzc29jaWF0ZWQgZXZlbnQgdGFyZ2V0IGlzIG51bGwgZm9yIHNvbWUgdW5rbm93biByZWFzb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tb3N0UmVjZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSB1bmRlcmx5aW5nIEJlaGF2aW9yU3ViamVjdCB0aGF0IGVtaXRzIHdoZW5ldmVyIGFuIGlucHV0IG1vZGFsaXR5IGlzIGRldGVjdGVkLiAqL1xuICAgICAgICB0aGlzLl9tb2RhbGl0eSA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZXN0YW1wIG9mIHRoZSBsYXN0IHRvdWNoIGlucHV0IG1vZGFsaXR5LiBVc2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG1vdXNlZG93biBldmVudHNcbiAgICAgICAgICogc2hvdWxkIGJlIGF0dHJpYnV0ZWQgdG8gbW91c2Ugb3IgdG91Y2guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sYXN0VG91Y2hNcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzLiBNdXN0IGJlIGFuIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBjb250ZXh0IHdoZW4gaXQgZ2V0c1xuICAgICAgICAgKiBib3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uS2V5ZG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBvbmUgb2YgdGhlIGtleXMgd2Ugc2hvdWxkIGlnbm9yZSwgdGhlbiBpZ25vcmUgaXQgYW5kIGRvbid0IHVwZGF0ZSB0aGUgaW5wdXRcbiAgICAgICAgICAgIC8vIG1vZGFsaXR5IHRvIGtleWJvYXJkLlxuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnM/Lmlnbm9yZUtleXM/LnNvbWUoa2V5Q29kZSA9PiBrZXlDb2RlID09PSBldmVudC5rZXlDb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21vZGFsaXR5Lm5leHQoJ2tleWJvYXJkJyk7XG4gICAgICAgICAgICB0aGlzLl9tb3N0UmVjZW50VGFyZ2V0ID0gX2dldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgbW91c2Vkb3duIGV2ZW50cy4gTXVzdCBiZSBhbiBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgY29udGV4dCB3aGVuIGl0XG4gICAgICAgICAqIGdldHMgYm91bmQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbk1vdXNlZG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gVG91Y2hlcyB0cmlnZ2VyIGJvdGggdG91Y2ggYW5kIG1vdXNlIGV2ZW50cywgc28gd2UgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlIHRyaWdnZXJlZCB2aWEgbW91c2UgdnMgdG91Y2guIFRvIGRvIHNvLCBjaGVjayBpZiB0aGUgbW91c2UgZXZlbnQgb2NjdXJzIGNsb3NlbHlcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBwcmV2aW91cyB0b3VjaCBldmVudC5cbiAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5fbGFzdFRvdWNoTXMgPCBUT1VDSF9CVUZGRVJfTVMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWtlIG1vdXNlZG93biBldmVudHMgYXJlIGZpcmVkIGJ5IHNvbWUgc2NyZWVuIHJlYWRlcnMgd2hlbiBjb250cm9scyBhcmUgYWN0aXZhdGVkIGJ5IHRoZVxuICAgICAgICAgICAgLy8gc2NyZWVuIHJlYWRlci4gQXR0cmlidXRlIHRoZW0gdG8ga2V5Ym9hcmQgaW5wdXQgbW9kYWxpdHkuXG4gICAgICAgICAgICB0aGlzLl9tb2RhbGl0eS5uZXh0KGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpID8gJ2tleWJvYXJkJyA6ICdtb3VzZScpO1xuICAgICAgICAgICAgdGhpcy5fbW9zdFJlY2VudFRhcmdldCA9IF9nZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIHRvdWNoc3RhcnQgZXZlbnRzLiBNdXN0IGJlIGFuIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBjb250ZXh0IHdoZW4gaXRcbiAgICAgICAgICogZ2V0cyBib3VuZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gU2FtZSBzY2VuYXJpbyBhcyBtZW50aW9uZWQgaW4gX29uTW91c2Vkb3duLCBidXQgb24gdG91Y2ggc2NyZWVuIGRldmljZXMsIGZha2UgdG91Y2hzdGFydFxuICAgICAgICAgICAgLy8gZXZlbnRzIGFyZSBmaXJlZC4gQWdhaW4sIGF0dHJpYnV0ZSB0byBrZXlib2FyZCBpbnB1dCBtb2RhbGl0eS5cbiAgICAgICAgICAgIGlmIChpc0Zha2VUb3VjaHN0YXJ0RnJvbVNjcmVlblJlYWRlcihldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RhbGl0eS5uZXh0KCdrZXlib2FyZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB0aW1lc3RhbXAgb2YgdGhpcyB0b3VjaCBldmVudCwgYXMgaXQncyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gbW91c2UgZXZlbnRzXG4gICAgICAgICAgICAvLyB0cmlnZ2VyZWQgdmlhIG1vdXNlIHZzIHRvdWNoLlxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoTXMgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5fbW9kYWxpdHkubmV4dCgndG91Y2gnKTtcbiAgICAgICAgICAgIHRoaXMuX21vc3RSZWNlbnRUYXJnZXQgPSBfZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfREVGQVVMVF9PUFRJT05TLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2tpcCB0aGUgZmlyc3QgZW1pc3Npb24gYXMgaXQncyBudWxsLlxuICAgICAgICB0aGlzLm1vZGFsaXR5RGV0ZWN0ZWQgPSB0aGlzLl9tb2RhbGl0eS5waXBlKHNraXAoMSkpO1xuICAgICAgICB0aGlzLm1vZGFsaXR5Q2hhbmdlZCA9IHRoaXMubW9kYWxpdHlEZXRlY3RlZC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgaW4gYSBicm93c2VyLCB0aGlzIHNlcnZpY2Ugc2hvdWxkIGRvIG5vdGhpbmcsIGFzIHRoZXJlJ3Mgbm8gcmVsZXZhbnQgaW5wdXRcbiAgICAgICAgLy8gbW9kYWxpdHkgdG8gZGV0ZWN0LlxuICAgICAgICBpZiAoX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlkb3duLCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlZG93biwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hzdGFydCwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fbW9kYWxpdHkuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5ZG93biwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlZG93biwgbW9kYWxpdHlFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaHN0YXJ0LCBtb2RhbGl0eUV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbklucHV0TW9kYWxpdHlEZXRlY3Rvci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IElucHV0TW9kYWxpdHlEZXRlY3RvciwgZGVwczogW3sgdG9rZW46IGkxLlBsYXRmb3JtIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBET0NVTUVOVCB9LCB7IHRva2VuOiBJTlBVVF9NT0RBTElUWV9ERVRFQ1RPUl9PUFRJT05TLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuSW5wdXRNb2RhbGl0eURldGVjdG9yLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IElucHV0TW9kYWxpdHlEZXRlY3RvciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSW5wdXRNb2RhbGl0eURldGVjdG9yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkxLlBsYXRmb3JtIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogRG9jdW1lbnQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfT1BUSU9OU11cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdsaXZlQW5ub3VuY2VyRWxlbWVudCcsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTl9GQUNUT1JZLFxufSk7XG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZnVuY3Rpb24gTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTl9GQUNUT1JZKCkge1xuICAgIHJldHVybiBudWxsO1xufVxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgZGVmYXVsdCBvcHRpb25zIGZvciB0aGUgTGl2ZUFubm91bmNlci4gKi9cbmNvbnN0IExJVkVfQU5OT1VOQ0VSX0RFRkFVTFRfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignTElWRV9BTk5PVU5DRVJfREVGQVVMVF9PUFRJT05TJyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xubGV0IHVuaXF1ZUlkcyA9IDA7XG5jbGFzcyBMaXZlQW5ub3VuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50VG9rZW4sIF9uZ1pvbmUsIF9kb2N1bWVudCwgX2RlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZSA9IF9uZ1pvbmU7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRPcHRpb25zID0gX2RlZmF1bHRPcHRpb25zO1xuICAgICAgICAvLyBXZSBpbmplY3QgdGhlIGxpdmUgZWxlbWVudCBhbmQgZG9jdW1lbnQgYXMgYGFueWAgYmVjYXVzZSB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlIGNhbm5vdFxuICAgICAgICAvLyByZWZlcmVuY2UgYnJvd3NlciBnbG9iYWxzIChIVE1MRWxlbWVudCwgRG9jdW1lbnQpIG9uIG5vbi1icm93c2VyIGVudmlyb25tZW50cywgc2luY2UgaGF2aW5nXG4gICAgICAgIC8vIGEgY2xhc3MgZGVjb3JhdG9yIGNhdXNlcyBUeXBlU2NyaXB0IHRvIHByZXNlcnZlIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgdHlwZXMuXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgICAgICB0aGlzLl9saXZlRWxlbWVudCA9IGVsZW1lbnRUb2tlbiB8fCB0aGlzLl9jcmVhdGVMaXZlRWxlbWVudCgpO1xuICAgIH1cbiAgICBhbm5vdW5jZShtZXNzYWdlLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRPcHRpb25zID0gdGhpcy5fZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIGxldCBwb2xpdGVuZXNzO1xuICAgICAgICBsZXQgZHVyYXRpb247XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gYXJnc1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFtwb2xpdGVuZXNzLCBkdXJhdGlvbl0gPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByZXZpb3VzVGltZW91dCk7XG4gICAgICAgIGlmICghcG9saXRlbmVzcykge1xuICAgICAgICAgICAgcG9saXRlbmVzcyA9XG4gICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMgJiYgZGVmYXVsdE9wdGlvbnMucG9saXRlbmVzcyA/IGRlZmF1bHRPcHRpb25zLnBvbGl0ZW5lc3MgOiAncG9saXRlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCAmJiBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBkZWZhdWx0T3B0aW9ucy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBlbnN1cmUgY2hhbmdpbmcgdGhlIHBvbGl0ZW5lc3Mgd29ya3Mgb24gYWxsIGVudmlyb25tZW50cyB3ZSBzdXBwb3J0LlxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIHBvbGl0ZW5lc3MpO1xuICAgICAgICBpZiAodGhpcy5fbGl2ZUVsZW1lbnQuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cG9zZUFubm91bmNlclRvTW9kYWxzKHRoaXMuX2xpdmVFbGVtZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIDEwMG1zIHRpbWVvdXQgaXMgbmVjZXNzYXJ5IGZvciBzb21lIGJyb3dzZXIgKyBzY3JlZW4tcmVhZGVyIGNvbWJpbmF0aW9uczpcbiAgICAgICAgLy8gLSBCb3RoIEpBV1MgYW5kIE5WREEgb3ZlciBJRTExIHdpbGwgbm90IGFubm91bmNlIGFueXRoaW5nIHdpdGhvdXQgYSBub24temVybyB0aW1lb3V0LlxuICAgICAgICAvLyAtIFdpdGggQ2hyb21lIGFuZCBJRTExIHdpdGggTlZEQSBvciBKQVdTLCBhIHJlcGVhdGVkIChpZGVudGljYWwpIG1lc3NhZ2Ugd29uJ3QgYmUgcmVhZCBhXG4gICAgICAgIC8vICAgc2Vjb25kIHRpbWUgd2l0aG91dCBjbGVhcmluZyBhbmQgdGhlbiB1c2luZyBhIG5vbi16ZXJvIGRlbGF5LlxuICAgICAgICAvLyAodXNpbmcgSkFXUyAxNyBhdCB0aW1lIG9mIHRoaXMgd3JpdGluZykuXG4gICAgICAgIHJldHVybiB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiAodGhpcy5fY3VycmVudFJlc29sdmUgPSByZXNvbHZlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcHJldmlvdXNUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpdmVFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY2xlYXIoKSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50UmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gdGhpcy5fY3VycmVudFJlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQcm9taXNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHRleHQgZnJvbSB0aGUgYW5ub3VuY2VyIGVsZW1lbnQuIENhbiBiZSB1c2VkIHRvIHByZXZlbnRcbiAgICAgKiBzY3JlZW4gcmVhZGVycyBmcm9tIHJlYWRpbmcgdGhlIHRleHQgb3V0IGFnYWluIHdoaWxlIHRoZSB1c2VyIGlzIGdvaW5nXG4gICAgICogdGhyb3VnaCB0aGUgcGFnZSBsYW5kbWFya3MuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3ByZXZpb3VzVGltZW91dCk7XG4gICAgICAgIHRoaXMuX2xpdmVFbGVtZW50Py5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fbGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50UmVzb2x2ZT8uKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gdGhpcy5fY3VycmVudFJlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF9jcmVhdGVMaXZlRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudENsYXNzID0gJ2Nkay1saXZlLWFubm91bmNlci1lbGVtZW50JztcbiAgICAgICAgY29uc3QgcHJldmlvdXNFbGVtZW50cyA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbWVudENsYXNzKTtcbiAgICAgICAgY29uc3QgbGl2ZUVsID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgb2xkIGNvbnRhaW5lcnMuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGNvbWluZyBpbiBmcm9tIGEgc2VydmVyLXNpZGUtcmVuZGVyZWQgcGFnZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0VsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcmV2aW91c0VsZW1lbnRzW2ldLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxpdmVFbC5jbGFzc0xpc3QuYWRkKGVsZW1lbnRDbGFzcyk7XG4gICAgICAgIGxpdmVFbC5jbGFzc0xpc3QuYWRkKCdjZGstdmlzdWFsbHktaGlkZGVuJyk7XG4gICAgICAgIGxpdmVFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXRvbWljJywgJ3RydWUnKTtcbiAgICAgICAgbGl2ZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICBsaXZlRWwuaWQgPSBgY2RrLWxpdmUtYW5ub3VuY2VyLSR7dW5pcXVlSWRzKyt9YDtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaXZlRWwpO1xuICAgICAgICByZXR1cm4gbGl2ZUVsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTb21lIGJyb3dzZXJzIHdvbid0IGV4cG9zZSB0aGUgYWNjZXNzaWJpbGl0eSBub2RlIG9mIHRoZSBsaXZlIGFubm91bmNlciBlbGVtZW50IGlmIHRoZXJlIGlzIGFuXG4gICAgICogYGFyaWEtbW9kYWxgIGFuZCB0aGUgbGl2ZSBhbm5vdW5jZXIgaXMgb3V0c2lkZSBvZiBpdC4gVGhpcyBtZXRob2Qgd29ya3MgYXJvdW5kIHRoZSBpc3N1ZSBieVxuICAgICAqIHBvaW50aW5nIHRoZSBgYXJpYS1vd25zYCBvZiBhbGwgbW9kYWxzIHRvIHRoZSBsaXZlIGFubm91bmNlciBlbGVtZW50LlxuICAgICAqL1xuICAgIF9leHBvc2VBbm5vdW5jZXJUb01vZGFscyhpZCkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIHNlbGVjdG9yIGhlcmUgaXMgbGltaXRlZCB0byBDREsgb3ZlcmxheXMgYXQgdGhlIG1vbWVudCBpbiBvcmRlciB0byByZWR1Y2UgdGhlXG4gICAgICAgIC8vIHNlY3Rpb24gb2YgdGhlIERPTSB3ZSBuZWVkIHRvIGxvb2sgdGhyb3VnaC4gVGhpcyBzaG91bGQgY292ZXIgYWxsIHRoZSBjYXNlcyB3ZSBzdXBwb3J0LCBidXRcbiAgICAgICAgLy8gdGhlIHNlbGVjdG9yIGNhbiBiZSBleHBhbmRlZCBpZiBpdCB0dXJucyBvdXQgdG8gYmUgdG9vIG5hcnJvdy5cbiAgICAgICAgY29uc3QgbW9kYWxzID0gdGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYm9keSA+IC5jZGstb3ZlcmxheS1jb250YWluZXIgW2FyaWEtbW9kYWw9XCJ0cnVlXCJdJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RhbCA9IG1vZGFsc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGFyaWFPd25zID0gbW9kYWwuZ2V0QXR0cmlidXRlKCdhcmlhLW93bnMnKTtcbiAgICAgICAgICAgIGlmICghYXJpYU93bnMpIHtcbiAgICAgICAgICAgICAgICBtb2RhbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtb3ducycsIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyaWFPd25zLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG1vZGFsLnNldEF0dHJpYnV0ZSgnYXJpYS1vd25zJywgYXJpYU93bnMgKyAnICcgKyBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5MaXZlQW5ub3VuY2VyLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTGl2ZUFubm91bmNlciwgZGVwczogW3sgdG9rZW46IExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4sIG9wdGlvbmFsOiB0cnVlIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBET0NVTUVOVCB9LCB7IHRva2VuOiBMSVZFX0FOTk9VTkNFUl9ERUZBVUxUX09QVElPTlMsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5MaXZlQW5ub3VuY2VyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IExpdmVBbm5vdW5jZXIsIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IExpdmVBbm5vdW5jZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTl1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IGkwLk5nWm9uZSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtMSVZFX0FOTk9VTkNFUl9ERUZBVUxUX09QVElPTlNdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgd29ya3Mgc2ltaWxhcmx5IHRvIGFyaWEtbGl2ZSwgYnV0IHVzZXMgdGhlIExpdmVBbm5vdW5jZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHlcbiAqIHdpdGggYSB3aWRlciByYW5nZSBvZiBicm93c2VycyBhbmQgc2NyZWVuIHJlYWRlcnMuXG4gKi9cbmNsYXNzIENka0FyaWFMaXZlIHtcbiAgICAvKiogVGhlIGFyaWEtbGl2ZSBwb2xpdGVuZXNzIGxldmVsIHRvIHVzZSB3aGVuIGFubm91bmNpbmcgbWVzc2FnZXMuICovXG4gICAgZ2V0IHBvbGl0ZW5lc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2xpdGVuZXNzO1xuICAgIH1cbiAgICBzZXQgcG9saXRlbmVzcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wb2xpdGVuZXNzID0gdmFsdWUgPT09ICdvZmYnIHx8IHZhbHVlID09PSAnYXNzZXJ0aXZlJyA/IHZhbHVlIDogJ3BvbGl0ZSc7XG4gICAgICAgIGlmICh0aGlzLl9wb2xpdGVuZXNzID09PSAnb2ZmJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX3N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudE9ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudFJlZikuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIHVzZSB0ZXh0Q29udGVudCBoZXJlLCByYXRoZXIgdGhhbiBpbm5lclRleHQsIGluIG9yZGVyIHRvIGF2b2lkIGEgcmVmbG93LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50VGV4dCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGBNdXRhdGlvbk9ic2VydmVyYCBmaXJlcyBhbHNvIGZvciBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlcyB3aGljaCB3ZSBkb24ndCB3YW50IHRvIGFubm91bmNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgIT09IHRoaXMuX3ByZXZpb3VzQW5ub3VuY2VkVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGl2ZUFubm91bmNlci5hbm5vdW5jZShlbGVtZW50VGV4dCwgdGhpcy5fcG9saXRlbmVzcywgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0Fubm91bmNlZFRleHQgPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnRSZWYsIF9saXZlQW5ub3VuY2VyLCBfY29udGVudE9ic2VydmVyLCBfbmdab25lKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fbGl2ZUFubm91bmNlciA9IF9saXZlQW5ub3VuY2VyO1xuICAgICAgICB0aGlzLl9jb250ZW50T2JzZXJ2ZXIgPSBfY29udGVudE9ic2VydmVyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9wb2xpdGVuZXNzID0gJ3BvbGl0ZSc7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka0FyaWFMaXZlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrQXJpYUxpdmUsIGRlcHM6IFt7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IExpdmVBbm5vdW5jZXIgfSwgeyB0b2tlbjogaTEkMS5Db250ZW50T2JzZXJ2ZXIgfSwgeyB0b2tlbjogaTAuTmdab25lIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka0FyaWFMaXZlLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrQXJpYUxpdmUsIHNlbGVjdG9yOiBcIltjZGtBcmlhTGl2ZV1cIiwgaW5wdXRzOiB7IHBvbGl0ZW5lc3M6IFtcImNka0FyaWFMaXZlXCIsIFwicG9saXRlbmVzc1wiXSwgZHVyYXRpb246IFtcImNka0FyaWFMaXZlRHVyYXRpb25cIiwgXCJkdXJhdGlvblwiXSB9LCBleHBvcnRBczogW1wiY2RrQXJpYUxpdmVcIl0sIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0FyaWFMaXZlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrQXJpYUxpdmVdJyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdjZGtBcmlhTGl2ZScsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5FbGVtZW50UmVmIH0sIHsgdHlwZTogTGl2ZUFubm91bmNlciB9LCB7IHR5cGU6IGkxJDEuQ29udGVudE9ic2VydmVyIH0sIHsgdHlwZTogaTAuTmdab25lIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBwb2xpdGVuZXNzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnY2RrQXJpYUxpdmUnXVxuICAgICAgICAgICAgfV0sIGR1cmF0aW9uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnY2RrQXJpYUxpdmVEdXJhdGlvbiddXG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBJbmplY3Rpb25Ub2tlbiBmb3IgRm9jdXNNb25pdG9yT3B0aW9ucy4gKi9cbmNvbnN0IEZPQ1VTX01PTklUT1JfREVGQVVMVF9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdjZGstZm9jdXMtbW9uaXRvci1kZWZhdWx0LW9wdGlvbnMnKTtcbi8qKlxuICogRXZlbnQgbGlzdGVuZXIgb3B0aW9ucyB0aGF0IGVuYWJsZSBjYXB0dXJpbmcgYW5kIGFsc29cbiAqIG1hcmsgdGhlIGxpc3RlbmVyIGFzIHBhc3NpdmUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgaXQuXG4gKi9cbmNvbnN0IGNhcHR1cmVFdmVudExpc3RlbmVyT3B0aW9ucyA9IG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMoe1xuICAgIHBhc3NpdmU6IHRydWUsXG4gICAgY2FwdHVyZTogdHJ1ZSxcbn0pO1xuLyoqIE1vbml0b3JzIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHMgdG8gZGV0ZXJtaW5lIHRoZSBjYXVzZSBvZiBmb2N1cyBldmVudHMuICovXG5jbGFzcyBGb2N1c01vbml0b3Ige1xuICAgIGNvbnN0cnVjdG9yKF9uZ1pvbmUsIF9wbGF0Zm9ybSwgX2lucHV0TW9kYWxpdHlEZXRlY3RvciwgXG4gICAgLyoqIEBicmVha2luZy1jaGFuZ2UgMTEuMC4wIG1ha2UgZG9jdW1lbnQgcmVxdWlyZWQgKi9cbiAgICBkb2N1bWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5faW5wdXRNb2RhbGl0eURldGVjdG9yID0gX2lucHV0TW9kYWxpdHlEZXRlY3RvcjtcbiAgICAgICAgLyoqIFRoZSBmb2N1cyBvcmlnaW4gdGhhdCB0aGUgbmV4dCBmb2N1cyBldmVudCBpcyBhIHJlc3VsdCBvZi4gKi9cbiAgICAgICAgdGhpcy5fb3JpZ2luID0gbnVsbDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHdpbmRvdyBoYXMganVzdCBiZWVuIGZvY3VzZWQuICovXG4gICAgICAgIHRoaXMuX3dpbmRvd0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIG9yaWdpbiB3YXMgZGV0ZXJtaW5lZCB2aWEgYSB0b3VjaCBpbnRlcmFjdGlvbi4gTmVjZXNzYXJ5IGFzIHByb3Blcmx5IGF0dHJpYnV0aW5nXG4gICAgICAgICAqIGZvY3VzIGV2ZW50cyB0byB0b3VjaCBpbnRlcmFjdGlvbnMgcmVxdWlyZXMgc3BlY2lhbCBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29yaWdpbkZyb21Ub3VjaEludGVyYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8qKiBNYXAgb2YgZWxlbWVudHMgYmVpbmcgbW9uaXRvcmVkIHRvIHRoZWlyIGluZm8uICovXG4gICAgICAgIHRoaXMuX2VsZW1lbnRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBjdXJyZW50bHkgYmVpbmcgbW9uaXRvcmVkLiAqL1xuICAgICAgICB0aGlzLl9tb25pdG9yZWRFbGVtZW50Q291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIHJvb3Qgbm9kZXMgdG8gd2hpY2ggd2UndmUgY3VycmVudGx5IGJvdW5kIGEgZm9jdXMvYmx1ciBoYW5kbGVyLFxuICAgICAgICAgKiBhcyB3ZWxsIGFzIHRoZSBudW1iZXIgb2YgbW9uaXRvcmVkIGVsZW1lbnRzIHRoYXQgdGhleSBjb250YWluLiBXZSBoYXZlIHRvIHRyZWF0IGZvY3VzL2JsdXJcbiAgICAgICAgICogaGFuZGxlcnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgcmVzdCBvZiB0aGUgZXZlbnRzLCBiZWNhdXNlIHRoZSBicm93c2VyIHdvbid0IGVtaXQgZXZlbnRzXG4gICAgICAgICAqIHRvIHRoZSBkb2N1bWVudCB3aGVuIGZvY3VzIG1vdmVzIGluc2lkZSBvZiBhIHNoYWRvdyByb290LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm9vdE5vZGVGb2N1c0xpc3RlbmVyQ291bnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudCBsaXN0ZW5lciBmb3IgYGZvY3VzYCBldmVudHMgb24gdGhlIHdpbmRvdy5cbiAgICAgICAgICogTmVlZHMgdG8gYmUgYW4gYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGNvbnRleHQgd2hlbiBpdCBnZXRzIGJvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2luZG93Rm9jdXNMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2UgYSBub3RlIG9mIHdoZW4gdGhlIHdpbmRvdyByZWdhaW5zIGZvY3VzLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIG9yaWdpbiBpbmZvIGZvciB0aGUgZm9jdXNlZCBlbGVtZW50LlxuICAgICAgICAgICAgdGhpcy5fd2luZG93Rm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl93aW5kb3dGb2N1c1RpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+ICh0aGlzLl93aW5kb3dGb2N1c2VkID0gZmFsc2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIHN0b3BwaW5nIG91ciBJbnB1dE1vZGFsaXR5RGV0ZWN0b3Igc3Vic2NyaXB0aW9uLiAqL1xuICAgICAgICB0aGlzLl9zdG9wSW5wdXRNb2RhbGl0eURldGVjdG9yID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IGxpc3RlbmVyIGZvciBgZm9jdXNgIGFuZCAnYmx1cicgZXZlbnRzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICogTmVlZHMgdG8gYmUgYW4gYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGNvbnRleHQgd2hlbiBpdCBnZXRzIGJvdW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm9vdE5vZGVGb2N1c0FuZEJsdXJMaXN0ZW5lciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gX2dldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd2FsayB1cCB0aGUgYW5jZXN0b3IgY2hhaW4gaW4gb3JkZXIgdG8gc3VwcG9ydCBgY2hlY2tDaGlsZHJlbmAuXG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtZW50ID0gdGFyZ2V0OyBlbGVtZW50OyBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25Gb2N1cyhldmVudCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkJsdXIoZXZlbnQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5fZGV0ZWN0aW9uTW9kZSA9IG9wdGlvbnM/LmRldGVjdGlvbk1vZGUgfHwgMCAvKiBGb2N1c01vbml0b3JEZXRlY3Rpb25Nb2RlLklNTUVESUFURSAqLztcbiAgICB9XG4gICAgbW9uaXRvcihlbGVtZW50LCBjaGVja0NoaWxkcmVuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IGNvZXJjZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UncmUgbm90IG9uIHRoZSBicm93c2VyIHBsYXRmb3JtIG9yIHRoZSBwYXNzZWQgaW4gbm9kZSBpc24ndCBhbiBlbGVtZW50LlxuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3NlciB8fCBuYXRpdmVFbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgaW5zaWRlIHRoZSBzaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIGJpbmQgb3VyIGZvY3VzL2JsdXIgbGlzdGVuZXJzIHRvXG4gICAgICAgIC8vIHRoZSBzaGFkb3cgcm9vdCwgcmF0aGVyIHRoYW4gdGhlIGBkb2N1bWVudGAsIGJlY2F1c2UgdGhlIGJyb3dzZXIgd29uJ3QgZW1pdCBmb2N1cyBldmVudHNcbiAgICAgICAgLy8gdG8gdGhlIGBkb2N1bWVudGAsIGlmIGZvY3VzIGlzIG1vdmluZyB3aXRoaW4gdGhlIHNhbWUgc2hhZG93IHJvb3QuXG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gX2dldFNoYWRvd1Jvb3QobmF0aXZlRWxlbWVudCkgfHwgdGhpcy5fZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgY29uc3QgY2FjaGVkSW5mbyA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChuYXRpdmVFbGVtZW50KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgYWxyZWFkeSBtb25pdG9yaW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgaWYgKGNhY2hlZEluZm8pIHtcbiAgICAgICAgICAgIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhDT01QLTMxOCk6IHRoaXMgY2FuIGJlIHByb2JsZW1hdGljLCBiZWNhdXNlIGl0J2xsIHR1cm4gYWxsIG5vbi1jaGVja0NoaWxkcmVuXG4gICAgICAgICAgICAgICAgLy8gb2JzZXJ2ZXJzIGludG8gb25lcyB0aGF0IGJlaGF2ZSBhcyBpZiBgY2hlY2tDaGlsZHJlbmAgd2FzIHR1cm5lZCBvbi4gV2UgbmVlZCBhIG1vcmVcbiAgICAgICAgICAgICAgICAvLyByb2J1c3Qgc29sdXRpb24uXG4gICAgICAgICAgICAgICAgY2FjaGVkSW5mby5jaGVja0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRJbmZvLnN1YmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIG1vbml0b3JlZCBlbGVtZW50IGluZm8uXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgICBjaGVja0NoaWxkcmVuOiBjaGVja0NoaWxkcmVuLFxuICAgICAgICAgICAgc3ViamVjdDogbmV3IFN1YmplY3QoKSxcbiAgICAgICAgICAgIHJvb3ROb2RlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9lbGVtZW50SW5mby5zZXQobmF0aXZlRWxlbWVudCwgaW5mbyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyR2xvYmFsTGlzdGVuZXJzKGluZm8pO1xuICAgICAgICByZXR1cm4gaW5mby5zdWJqZWN0O1xuICAgIH1cbiAgICBzdG9wTW9uaXRvcmluZyhlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50SW5mbyA9IHRoaXMuX2VsZW1lbnRJbmZvLmdldChuYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnRJbmZvKSB7XG4gICAgICAgICAgICBlbGVtZW50SW5mby5zdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRDbGFzc2VzKG5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudEluZm8uZGVsZXRlKG5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlR2xvYmFsTGlzdGVuZXJzKGVsZW1lbnRJbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1c1ZpYShlbGVtZW50LCBvcmlnaW4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRWxlbWVudCA9IGNvZXJjZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGZvY3VzZWRFbGVtZW50ID0gdGhpcy5fZ2V0RG9jdW1lbnQoKS5hY3RpdmVFbGVtZW50O1xuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBmb2N1c2VkIGFscmVhZHksIGNhbGxpbmcgYGZvY3VzYCBhZ2FpbiB3b24ndCB0cmlnZ2VyIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSBmb2N1cyBjbGFzc2VzIHdvbid0IGJlIHVwZGF0ZWQuIElmIHRoYXQncyB0aGUgY2FzZSwgdXBkYXRlIHRoZSBjbGFzc2VzXG4gICAgICAgIC8vIGRpcmVjdGx5IHdpdGhvdXQgd2FpdGluZyBmb3IgYW4gZXZlbnQuXG4gICAgICAgIGlmIChuYXRpdmVFbGVtZW50ID09PSBmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0Q2xvc2VzdEVsZW1lbnRzSW5mbyhuYXRpdmVFbGVtZW50KS5mb3JFYWNoKChbY3VycmVudEVsZW1lbnQsIGluZm9dKSA9PiB0aGlzLl9vcmlnaW5DaGFuZ2VkKGN1cnJlbnRFbGVtZW50LCBvcmlnaW4sIGluZm8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE9yaWdpbihvcmlnaW4pO1xuICAgICAgICAgICAgLy8gYGZvY3VzYCBpc24ndCBhdmFpbGFibGUgb24gdGhlIHNlcnZlclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYXRpdmVFbGVtZW50LmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudC5mb2N1cyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEluZm8uZm9yRWFjaCgoX2luZm8sIGVsZW1lbnQpID0+IHRoaXMuc3RvcE1vbml0b3JpbmcoZWxlbWVudCkpO1xuICAgIH1cbiAgICAvKiogQWNjZXNzIGluamVjdGVkIGRvY3VtZW50IGlmIGF2YWlsYWJsZSBvciBmYWxsYmFjayB0byBnbG9iYWwgZG9jdW1lbnQgcmVmZXJlbmNlICovXG4gICAgX2dldERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKiBVc2UgZGVmYXVsdFZpZXcgb2YgaW5qZWN0ZWQgZG9jdW1lbnQgaWYgYXZhaWxhYmxlIG9yIGZhbGxiYWNrIHRvIGdsb2JhbCB3aW5kb3cgcmVmZXJlbmNlICovXG4gICAgX2dldFdpbmRvdygpIHtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5fZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgfVxuICAgIF9nZXRGb2N1c09yaWdpbihmb2N1c0V2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW4pIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcmlnaW4gd2FzIHJlYWxpemVkIHZpYSBhIHRvdWNoIGludGVyYWN0aW9uLCB3ZSBuZWVkIHRvIHBlcmZvcm0gYWRkaXRpb25hbCBjaGVja3NcbiAgICAgICAgICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBmb2N1cyBvcmlnaW4gc2hvdWxkIGJlIGF0dHJpYnV0ZWQgdG8gdG91Y2ggb3IgcHJvZ3JhbS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW5Gcm9tVG91Y2hJbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaG91bGRCZUF0dHJpYnV0ZWRUb1RvdWNoKGZvY3VzRXZlbnRUYXJnZXQpID8gJ3RvdWNoJyA6ICdwcm9ncmFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyBoYXMganVzdCByZWdhaW5lZCBmb2N1cywgd2UgY2FuIHJlc3RvcmUgdGhlIG1vc3QgcmVjZW50IG9yaWdpbiBmcm9tIGJlZm9yZSB0aGVcbiAgICAgICAgLy8gd2luZG93IGJsdXJyZWQuIE90aGVyd2lzZSwgd2UndmUgcmVhY2hlZCB0aGUgcG9pbnQgd2hlcmUgd2UgY2FuJ3QgaWRlbnRpZnkgdGhlIHNvdXJjZSBvZiB0aGVcbiAgICAgICAgLy8gZm9jdXMuIFRoaXMgdHlwaWNhbGx5IG1lYW5zIG9uZSBvZiB0d28gdGhpbmdzIGhhcHBlbmVkOlxuICAgICAgICAvL1xuICAgICAgICAvLyAxKSBUaGUgZWxlbWVudCB3YXMgcHJvZ3JhbW1hdGljYWxseSBmb2N1c2VkLCBvclxuICAgICAgICAvLyAyKSBUaGUgZWxlbWVudCB3YXMgZm9jdXNlZCB2aWEgc2NyZWVuIHJlYWRlciBuYXZpZ2F0aW9uICh3aGljaCBnZW5lcmFsbHkgZG9lc24ndCBmaXJlXG4gICAgICAgIC8vICAgIGV2ZW50cykuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJlY2F1c2Ugd2UgY2FuJ3QgZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGVzZSB0d28gY2FzZXMsIHdlIGRlZmF1bHQgdG8gc2V0dGluZyBgcHJvZ3JhbWAuXG4gICAgICAgIGlmICh0aGlzLl93aW5kb3dGb2N1c2VkICYmIHRoaXMuX2xhc3RGb2N1c09yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RGb2N1c09yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY29taW5nIGZyb20gYW4gaW5wdXQgbGFiZWwsIHdlIGNvbnNpZGVyIGl0IGEgbW91c2UgaW50ZXJhY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIGZvY3VzIG1vdmVzIG9uIGBjbGlja2AsIHJhdGhlciB0aGFuIGBtb3VzZWRvd25gIHdoaWNoIGJyZWFrc1xuICAgICAgICAvLyBvdXIgZGV0ZWN0aW9uLCBiZWNhdXNlIGFsbCBvdXIgYXNzdW1wdGlvbnMgYXJlIGZvciBgbW91c2Vkb3duYC4gV2UgbmVlZCB0byBoYW5kbGUgdGhpc1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2UsIGJlY2F1c2UgaXQncyB2ZXJ5IGNvbW1vbiBmb3IgY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucy5cbiAgICAgICAgaWYgKGZvY3VzRXZlbnRUYXJnZXQgJiYgdGhpcy5faXNMYXN0SW50ZXJhY3Rpb25Gcm9tSW5wdXRMYWJlbChmb2N1c0V2ZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb3VzZSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdwcm9ncmFtJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBmb2N1cyBldmVudCBzaG91bGQgYmUgYXR0cmlidXRlZCB0byB0b3VjaC4gUmVjYWxsIHRoYXQgaW4gSU1NRURJQVRFIG1vZGUsIGFcbiAgICAgKiB0b3VjaCBvcmlnaW4gaXNuJ3QgaW1tZWRpYXRlbHkgcmVzZXQgYXQgdGhlIG5leHQgdGljayAoc2VlIF9zZXRPcmlnaW4pLiBUaGlzIG1lYW5zIHRoYXQgd2hlbiB3ZVxuICAgICAqIGhhbmRsZSBhIGZvY3VzIGV2ZW50IGZvbGxvd2luZyBhIHRvdWNoIGludGVyYWN0aW9uLCB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyICgxKSB0aGUgZm9jdXNcbiAgICAgKiBldmVudCB3YXMgZGlyZWN0bHkgY2F1c2VkIGJ5IHRoZSB0b3VjaCBpbnRlcmFjdGlvbiBvciAoMikgdGhlIGZvY3VzIGV2ZW50IHdhcyBjYXVzZWQgYnkgYVxuICAgICAqIHN1YnNlcXVlbnQgcHJvZ3JhbW1hdGljIGZvY3VzIGNhbGwgdHJpZ2dlcmVkIGJ5IHRoZSB0b3VjaCBpbnRlcmFjdGlvbi5cbiAgICAgKiBAcGFyYW0gZm9jdXNFdmVudFRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBmb2N1cyBldmVudCB1bmRlciBleGFtaW5hdGlvbi5cbiAgICAgKi9cbiAgICBfc2hvdWxkQmVBdHRyaWJ1dGVkVG9Ub3VjaChmb2N1c0V2ZW50VGFyZ2V0KSB7XG4gICAgICAgIC8vIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBjaGVjayBpcyBub3QgcGVyZmVjdC4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBlZGdlIGNhc2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDxkaXYgI3BhcmVudCB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgLy8gICA8ZGl2ICNjaGlsZCB0YWJpbmRleD1cIjBcIiAoY2xpY2spPVwiI3BhcmVudC5mb2N1cygpXCI+PC9kaXY+XG4gICAgICAgIC8vIDwvZGl2PlxuICAgICAgICAvL1xuICAgICAgICAvLyBTdXBwb3NlIHRoZXJlIGlzIGEgRm9jdXNNb25pdG9yIGluIElNTUVESUFURSBtb2RlIGF0dGFjaGVkIHRvICNwYXJlbnQuIFdoZW4gdGhlIHVzZXIgdG91Y2hlc1xuICAgICAgICAvLyAjY2hpbGQsICNwYXJlbnQgaXMgcHJvZ3JhbW1hdGljYWxseSBmb2N1c2VkLiBUaGlzIGNvZGUgd2lsbCBhdHRyaWJ1dGUgdGhlIGZvY3VzIHRvIHRvdWNoXG4gICAgICAgIC8vIGluc3RlYWQgb2YgcHJvZ3JhbS4gVGhpcyBpcyBhIHJlbGF0aXZlbHkgbWlub3IgZWRnZS1jYXNlIHRoYXQgY2FuIGJlIHdvcmtlZCBhcm91bmQgYnkgdXNpbmdcbiAgICAgICAgLy8gZm9jdXNWaWEocGFyZW50LCAncHJvZ3JhbScpIHRvIGZvY3VzICNwYXJlbnQuXG4gICAgICAgIHJldHVybiAodGhpcy5fZGV0ZWN0aW9uTW9kZSA9PT0gMSAvKiBGb2N1c01vbml0b3JEZXRlY3Rpb25Nb2RlLkVWRU5UVUFMICovIHx8XG4gICAgICAgICAgICAhIWZvY3VzRXZlbnRUYXJnZXQ/LmNvbnRhaW5zKHRoaXMuX2lucHV0TW9kYWxpdHlEZXRlY3Rvci5fbW9zdFJlY2VudFRhcmdldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBmb2N1cyBjbGFzc2VzIG9uIHRoZSBlbGVtZW50IGJhc2VkIG9uIHRoZSBnaXZlbiBmb2N1cyBvcmlnaW4uXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gdXBkYXRlIHRoZSBjbGFzc2VzIG9uLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIGZvY3VzIG9yaWdpbi5cbiAgICAgKi9cbiAgICBfc2V0Q2xhc3NlcyhlbGVtZW50LCBvcmlnaW4pIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdjZGstZm9jdXNlZCcsICEhb3JpZ2luKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdjZGstdG91Y2gtZm9jdXNlZCcsIG9yaWdpbiA9PT0gJ3RvdWNoJyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZSgnY2RrLWtleWJvYXJkLWZvY3VzZWQnLCBvcmlnaW4gPT09ICdrZXlib2FyZCcpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ2Nkay1tb3VzZS1mb2N1c2VkJywgb3JpZ2luID09PSAnbW91c2UnKTtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdjZGstcHJvZ3JhbS1mb2N1c2VkJywgb3JpZ2luID09PSAncHJvZ3JhbScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmb2N1cyBvcmlnaW4uIElmIHdlJ3JlIHVzaW5nIGltbWVkaWF0ZSBkZXRlY3Rpb24gbW9kZSwgd2Ugc2NoZWR1bGUgYW4gYXN5bmNcbiAgICAgKiBmdW5jdGlvbiB0byBjbGVhciB0aGUgb3JpZ2luIGF0IHRoZSBlbmQgb2YgYSB0aW1lb3V0LiBUaGUgZHVyYXRpb24gb2YgdGhlIHRpbWVvdXQgZGVwZW5kcyBvblxuICAgICAqIHRoZSBvcmlnaW4gYmVpbmcgc2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW4gVGhlIG9yaWdpbiB0byBzZXQuXG4gICAgICogQHBhcmFtIGlzRnJvbUludGVyYWN0aW9uIFdoZXRoZXIgd2UgYXJlIHNldHRpbmcgdGhlIG9yaWdpbiBmcm9tIGFuIGludGVyYWN0aW9uIGV2ZW50LlxuICAgICAqL1xuICAgIF9zZXRPcmlnaW4ob3JpZ2luLCBpc0Zyb21JbnRlcmFjdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW47XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5Gcm9tVG91Y2hJbnRlcmFjdGlvbiA9IG9yaWdpbiA9PT0gJ3RvdWNoJyAmJiBpc0Zyb21JbnRlcmFjdGlvbjtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIElNTUVESUFURSBtb2RlLCByZXNldCB0aGUgb3JpZ2luIGF0IHRoZSBuZXh0IHRpY2sgKG9yIGluIGBUT1VDSF9CVUZGRVJfTVNgIG1zXG4gICAgICAgICAgICAvLyBmb3IgYSB0b3VjaCBldmVudCkuIFdlIHJlc2V0IHRoZSBvcmlnaW4gYXQgdGhlIG5leHQgdGljayBiZWNhdXNlIEZpcmVmb3ggZm9jdXNlcyBvbmUgdGlja1xuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGludGVyYWN0aW9uIGV2ZW50LiBXZSB3YWl0IGBUT1VDSF9CVUZGRVJfTVNgIG1zIGJlZm9yZSByZXNldHRpbmcgdGhlIG9yaWdpbiBmb3JcbiAgICAgICAgICAgIC8vIGEgdG91Y2ggZXZlbnQgYmVjYXVzZSB3aGVuIGEgdG91Y2ggZXZlbnQgaXMgZmlyZWQsIHRoZSBhc3NvY2lhdGVkIGZvY3VzIGV2ZW50IGlzbid0IHlldCBpblxuICAgICAgICAgICAgLy8gdGhlIGV2ZW50IHF1ZXVlLiBCZWZvcmUgZG9pbmcgc28sIGNsZWFyIGFueSBwZW5kaW5nIHRpbWVvdXRzLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2RldGVjdGlvbk1vZGUgPT09IDAgLyogRm9jdXNNb25pdG9yRGV0ZWN0aW9uTW9kZS5JTU1FRElBVEUgKi8pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3JpZ2luVGltZW91dElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtcyA9IHRoaXMuX29yaWdpbkZyb21Ub3VjaEludGVyYWN0aW9uID8gVE9VQ0hfQlVGRkVSX01TIDogMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+ICh0aGlzLl9vcmlnaW4gPSBudWxsKSwgbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBmb2N1cyBldmVudHMgb24gYSByZWdpc3RlcmVkIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBmb2N1cyBldmVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgbW9uaXRvcmVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgX29uRm9jdXMoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgLy8gTk9URShtbWFsZXJiYSk6IFdlIGN1cnJlbnRseSBzZXQgdGhlIGNsYXNzZXMgYmFzZWQgb24gdGhlIGZvY3VzIG9yaWdpbiBvZiB0aGUgbW9zdCByZWNlbnRcbiAgICAgICAgLy8gZm9jdXMgZXZlbnQgYWZmZWN0aW5nIHRoZSBtb25pdG9yZWQgZWxlbWVudC4gSWYgd2Ugd2FudCB0byB1c2UgdGhlIG9yaWdpbiBvZiB0aGUgZmlyc3QgZXZlbnRcbiAgICAgICAgLy8gaW5zdGVhZCB3ZSBzaG91bGQgY2hlY2sgZm9yIHRoZSBjZGstZm9jdXNlZCBjbGFzcyBoZXJlIGFuZCByZXR1cm4gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXNcbiAgICAgICAgLy8gaXQuIChUaGlzIG9ubHkgbWF0dGVycyBmb3IgZWxlbWVudHMgdGhhdCBoYXZlIGluY2x1ZGVzQ2hpbGRyZW4gPSB0cnVlKS5cbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBjb3VudGluZyBjaGlsZC1lbGVtZW50LWZvY3VzIGFzIGZvY3VzZWQsIG1ha2Ugc3VyZSB0aGF0IHRoZSBldmVudCB0YXJnZXQgaXMgdGhlXG4gICAgICAgIC8vIG1vbml0b3JlZCBlbGVtZW50IGl0c2VsZi5cbiAgICAgICAgY29uc3QgZWxlbWVudEluZm8gPSB0aGlzLl9lbGVtZW50SW5mby5nZXQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGZvY3VzRXZlbnRUYXJnZXQgPSBfZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRJbmZvIHx8ICghZWxlbWVudEluZm8uY2hlY2tDaGlsZHJlbiAmJiBlbGVtZW50ICE9PSBmb2N1c0V2ZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29yaWdpbkNoYW5nZWQoZWxlbWVudCwgdGhpcy5fZ2V0Rm9jdXNPcmlnaW4oZm9jdXNFdmVudFRhcmdldCksIGVsZW1lbnRJbmZvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBibHVyIGV2ZW50cyBvbiBhIHJlZ2lzdGVyZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGJsdXIgZXZlbnQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIG1vbml0b3JlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIF9vbkJsdXIoZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGNvdW50aW5nIGNoaWxkLWVsZW1lbnQtZm9jdXMgYXMgZm9jdXNlZCwgbWFrZSBzdXJlIHRoYXQgd2UgYXJlbid0IGp1c3QgYmx1cnJpbmcgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gZm9jdXMgYW5vdGhlciBjaGlsZCBvZiB0aGUgbW9uaXRvcmVkIGVsZW1lbnQuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRJbmZvID0gdGhpcy5fZWxlbWVudEluZm8uZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRJbmZvIHx8XG4gICAgICAgICAgICAoZWxlbWVudEluZm8uY2hlY2tDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnJlbGF0ZWRUYXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDbGFzc2VzKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9lbWl0T3JpZ2luKGVsZW1lbnRJbmZvLCBudWxsKTtcbiAgICB9XG4gICAgX2VtaXRPcmlnaW4oaW5mbywgb3JpZ2luKSB7XG4gICAgICAgIGlmIChpbmZvLnN1YmplY3Qub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiBpbmZvLnN1YmplY3QubmV4dChvcmlnaW4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVnaXN0ZXJHbG9iYWxMaXN0ZW5lcnMoZWxlbWVudEluZm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb290Tm9kZSA9IGVsZW1lbnRJbmZvLnJvb3ROb2RlO1xuICAgICAgICBjb25zdCByb290Tm9kZUZvY3VzTGlzdGVuZXJzID0gdGhpcy5fcm9vdE5vZGVGb2N1c0xpc3RlbmVyQ291bnQuZ2V0KHJvb3ROb2RlKSB8fCAwO1xuICAgICAgICBpZiAoIXJvb3ROb2RlRm9jdXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9yb290Tm9kZUZvY3VzQW5kQmx1ckxpc3RlbmVyLCBjYXB0dXJlRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9yb290Tm9kZUZvY3VzQW5kQmx1ckxpc3RlbmVyLCBjYXB0dXJlRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdE5vZGVGb2N1c0xpc3RlbmVyQ291bnQuc2V0KHJvb3ROb2RlLCByb290Tm9kZUZvY3VzTGlzdGVuZXJzICsgMSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lcnMgd2hlbiBmaXJzdCBlbGVtZW50IGlzIG1vbml0b3JlZC5cbiAgICAgICAgaWYgKCsrdGhpcy5fbW9uaXRvcmVkRWxlbWVudENvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBsaXN0ZW4gdG8gZXZlbnRzIGluIHRoZSBjYXB0dXJlIHBoYXNlIHNvIHdlXG4gICAgICAgICAgICAvLyBjYW4gZGV0ZWN0IHRoZW0gZXZlbiBpZiB0aGUgdXNlciBzdG9wcyBwcm9wYWdhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fd2luZG93Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBJbnB1dE1vZGFsaXR5RGV0ZWN0b3IgaXMgYWxzbyBqdXN0IGEgY29sbGVjdGlvbiBvZiBnbG9iYWwgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdGhpcy5faW5wdXRNb2RhbGl0eURldGVjdG9yLm1vZGFsaXR5RGV0ZWN0ZWRcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fc3RvcElucHV0TW9kYWxpdHlEZXRlY3RvcikpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShtb2RhbGl0eSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0T3JpZ2luKG1vZGFsaXR5LCB0cnVlIC8qIGlzRnJvbUludGVyYWN0aW9uICovKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1vdmVHbG9iYWxMaXN0ZW5lcnMoZWxlbWVudEluZm8pIHtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBlbGVtZW50SW5mby5yb290Tm9kZTtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3ROb2RlRm9jdXNMaXN0ZW5lckNvdW50Lmhhcyhyb290Tm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3ROb2RlRm9jdXNMaXN0ZW5lcnMgPSB0aGlzLl9yb290Tm9kZUZvY3VzTGlzdGVuZXJDb3VudC5nZXQocm9vdE5vZGUpO1xuICAgICAgICAgICAgaWYgKHJvb3ROb2RlRm9jdXNMaXN0ZW5lcnMgPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVGb2N1c0xpc3RlbmVyQ291bnQuc2V0KHJvb3ROb2RlLCByb290Tm9kZUZvY3VzTGlzdGVuZXJzIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX3Jvb3ROb2RlRm9jdXNBbmRCbHVyTGlzdGVuZXIsIGNhcHR1cmVFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX3Jvb3ROb2RlRm9jdXNBbmRCbHVyTGlzdGVuZXIsIGNhcHR1cmVFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdE5vZGVGb2N1c0xpc3RlbmVyQ291bnQuZGVsZXRlKHJvb3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVbnJlZ2lzdGVyIGdsb2JhbCBsaXN0ZW5lcnMgd2hlbiBsYXN0IGVsZW1lbnQgaXMgdW5tb25pdG9yZWQuXG4gICAgICAgIGlmICghLS10aGlzLl9tb25pdG9yZWRFbGVtZW50Q291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IHRoaXMuX2dldFdpbmRvdygpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fd2luZG93Rm9jdXNMaXN0ZW5lcik7XG4gICAgICAgICAgICAvLyBFcXVpdmFsZW50bHksIHN0b3Agb3VyIElucHV0TW9kYWxpdHlEZXRlY3RvciBzdWJzY3JpcHRpb24uXG4gICAgICAgICAgICB0aGlzLl9zdG9wSW5wdXRNb2RhbGl0eURldGVjdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRpbWVvdXRzIGZvciBhbGwgcG90ZW50aWFsbHkgcGVuZGluZyB0aW1lb3V0cyB0byBwcmV2ZW50IHRoZSBsZWFrcy5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl93aW5kb3dGb2N1c1RpbWVvdXRJZCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fb3JpZ2luVGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogVXBkYXRlcyBhbGwgdGhlIHN0YXRlIG9uIGFuIGVsZW1lbnQgb25jZSBpdHMgZm9jdXMgb3JpZ2luIGhhcyBjaGFuZ2VkLiAqL1xuICAgIF9vcmlnaW5DaGFuZ2VkKGVsZW1lbnQsIG9yaWdpbiwgZWxlbWVudEluZm8pIHtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3NlcyhlbGVtZW50LCBvcmlnaW4pO1xuICAgICAgICB0aGlzLl9lbWl0T3JpZ2luKGVsZW1lbnRJbmZvLCBvcmlnaW4pO1xuICAgICAgICB0aGlzLl9sYXN0Rm9jdXNPcmlnaW4gPSBvcmlnaW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHRoZSBgTW9uaXRvcmVkRWxlbWVudEluZm9gIG9mIGEgcGFydGljdWxhciBlbGVtZW50IGFuZFxuICAgICAqIGFsbCBvZiBpdHMgYW5jZXN0b3JzIHRoYXQgaGF2ZSBlbmFibGVkIGBjaGVja0NoaWxkcmVuYC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IGZyb20gd2hpY2ggdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAgICAgKi9cbiAgICBfZ2V0Q2xvc2VzdEVsZW1lbnRzSW5mbyhlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdGhpcy5fZWxlbWVudEluZm8uZm9yRWFjaCgoaW5mbywgY3VycmVudEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudCA9PT0gZWxlbWVudCB8fCAoaW5mby5jaGVja0NoaWxkcmVuICYmIGN1cnJlbnRFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChbY3VycmVudEVsZW1lbnQsIGluZm9dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYW4gaW50ZXJhY3Rpb24gaXMgbGlrZWx5IHRvIGhhdmUgY29tZSBmcm9tIHRoZSB1c2VyIGNsaWNraW5nIHRoZSBgbGFiZWxgIG9mXG4gICAgICogYW4gYGlucHV0YCBvciBgdGV4dGFyZWFgIGluIG9yZGVyIHRvIGZvY3VzIGl0LlxuICAgICAqIEBwYXJhbSBmb2N1c0V2ZW50VGFyZ2V0IFRhcmdldCBjdXJyZW50bHkgcmVjZWl2aW5nIGZvY3VzLlxuICAgICAqL1xuICAgIF9pc0xhc3RJbnRlcmFjdGlvbkZyb21JbnB1dExhYmVsKGZvY3VzRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBfbW9zdFJlY2VudFRhcmdldDogbW9zdFJlY2VudFRhcmdldCwgbW9zdFJlY2VudE1vZGFsaXR5IH0gPSB0aGlzLl9pbnB1dE1vZGFsaXR5RGV0ZWN0b3I7XG4gICAgICAgIC8vIElmIHRoZSBsYXN0IGludGVyYWN0aW9uIHVzZWQgdGhlIG1vdXNlIG9uIGFuIGVsZW1lbnQgY29udGFpbmVkIGJ5IG9uZSBvZiB0aGUgbGFiZWxzXG4gICAgICAgIC8vIG9mIGFuIGBpbnB1dGAvYHRleHRhcmVhYCB0aGF0IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBpdCBpcyB2ZXJ5IGxpa2VseSB0aGF0IHRoZVxuICAgICAgICAvLyB1c2VyIHJlZGlyZWN0ZWQgZm9jdXMgdXNpbmcgdGhlIGxhYmVsLlxuICAgICAgICBpZiAobW9zdFJlY2VudE1vZGFsaXR5ICE9PSAnbW91c2UnIHx8XG4gICAgICAgICAgICAhbW9zdFJlY2VudFRhcmdldCB8fFxuICAgICAgICAgICAgbW9zdFJlY2VudFRhcmdldCA9PT0gZm9jdXNFdmVudFRhcmdldCB8fFxuICAgICAgICAgICAgKGZvY3VzRXZlbnRUYXJnZXQubm9kZU5hbWUgIT09ICdJTlBVVCcgJiYgZm9jdXNFdmVudFRhcmdldC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykgfHxcbiAgICAgICAgICAgIGZvY3VzRXZlbnRUYXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYWJlbHMgPSBmb2N1c0V2ZW50VGFyZ2V0LmxhYmVscztcbiAgICAgICAgaWYgKGxhYmVscykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWxzW2ldLmNvbnRhaW5zKG1vc3RSZWNlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuRm9jdXNNb25pdG9yLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNNb25pdG9yLCBkZXBzOiBbeyB0b2tlbjogaTAuTmdab25lIH0sIHsgdG9rZW46IGkxLlBsYXRmb3JtIH0sIHsgdG9rZW46IElucHV0TW9kYWxpdHlEZXRlY3RvciB9LCB7IHRva2VuOiBET0NVTUVOVCwgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogRk9DVVNfTU9OSVRPUl9ERUZBVUxUX09QVElPTlMsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5Gb2N1c01vbml0b3IuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9jdXNNb25pdG9yLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb2N1c01vbml0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogaTEuUGxhdGZvcm0gfSwgeyB0eXBlOiBJbnB1dE1vZGFsaXR5RGV0ZWN0b3IgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0ZPQ1VTX01PTklUT1JfREVGQVVMVF9PUFRJT05TXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuLyoqXG4gKiBEaXJlY3RpdmUgdGhhdCBkZXRlcm1pbmVzIGhvdyBhIHBhcnRpY3VsYXIgZWxlbWVudCB3YXMgZm9jdXNlZCAodmlhIGtleWJvYXJkLCBtb3VzZSwgdG91Y2gsIG9yXG4gKiBwcm9ncmFtbWF0aWNhbGx5KSBhbmQgYWRkcyBjb3JyZXNwb25kaW5nIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogVGhlcmUgYXJlIHR3byB2YXJpYW50cyBvZiB0aGlzIGRpcmVjdGl2ZTpcbiAqIDEpIGNka01vbml0b3JFbGVtZW50Rm9jdXM6IGRvZXMgbm90IGNvbnNpZGVyIGFuIGVsZW1lbnQgdG8gYmUgZm9jdXNlZCBpZiBvbmUgb2YgaXRzIGNoaWxkcmVuIGlzXG4gKiAgICBmb2N1c2VkLlxuICogMikgY2RrTW9uaXRvclN1YnRyZWVGb2N1czogY29uc2lkZXJzIGFuIGVsZW1lbnQgZm9jdXNlZCBpZiBpdCBvciBhbnkgb2YgaXRzIGNoaWxkcmVuIGFyZSBmb2N1c2VkLlxuICovXG5jbGFzcyBDZGtNb25pdG9yRm9jdXMge1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50UmVmLCBfZm9jdXNNb25pdG9yKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yID0gX2ZvY3VzTW9uaXRvcjtcbiAgICAgICAgdGhpcy5fZm9jdXNPcmlnaW4gPSBudWxsO1xuICAgICAgICB0aGlzLmNka0ZvY3VzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgZm9jdXNPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c09yaWdpbjtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLl9tb25pdG9yU3Vic2NyaXB0aW9uID0gdGhpcy5fZm9jdXNNb25pdG9yXG4gICAgICAgICAgICAubW9uaXRvcihlbGVtZW50LCBlbGVtZW50Lm5vZGVUeXBlID09PSAxICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjZGtNb25pdG9yU3VidHJlZUZvY3VzJykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9yaWdpbiA9PiB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c09yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgIHRoaXMuY2RrRm9jdXNDaGFuZ2UuZW1pdChvcmlnaW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzTW9uaXRvci5zdG9wTW9uaXRvcmluZyh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgaWYgKHRoaXMuX21vbml0b3JTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX21vbml0b3JTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka01vbml0b3JGb2N1cy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka01vbml0b3JGb2N1cywgZGVwczogW3sgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogRm9jdXNNb25pdG9yIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka01vbml0b3JGb2N1cy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka01vbml0b3JGb2N1cywgc2VsZWN0b3I6IFwiW2Nka01vbml0b3JFbGVtZW50Rm9jdXNdLCBbY2RrTW9uaXRvclN1YnRyZWVGb2N1c11cIiwgb3V0cHV0czogeyBjZGtGb2N1c0NoYW5nZTogXCJjZGtGb2N1c0NoYW5nZVwiIH0sIGV4cG9ydEFzOiBbXCJjZGtNb25pdG9yRm9jdXNcIl0sIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka01vbml0b3JGb2N1cywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nka01vbml0b3JFbGVtZW50Rm9jdXNdLCBbY2RrTW9uaXRvclN1YnRyZWVGb2N1c10nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ2Nka01vbml0b3JGb2N1cycsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5FbGVtZW50UmVmIH0sIHsgdHlwZTogRm9jdXNNb25pdG9yIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBjZGtGb2N1c0NoYW5nZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIENTUyBjbGFzcyBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudCBib2R5IHdoZW4gaW4gYmxhY2stb24td2hpdGUgaGlnaC1jb250cmFzdCBtb2RlLiAqL1xuY29uc3QgQkxBQ0tfT05fV0hJVEVfQ1NTX0NMQVNTID0gJ2Nkay1oaWdoLWNvbnRyYXN0LWJsYWNrLW9uLXdoaXRlJztcbi8qKiBDU1MgY2xhc3MgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQgYm9keSB3aGVuIGluIHdoaXRlLW9uLWJsYWNrIGhpZ2gtY29udHJhc3QgbW9kZS4gKi9cbmNvbnN0IFdISVRFX09OX0JMQUNLX0NTU19DTEFTUyA9ICdjZGstaGlnaC1jb250cmFzdC13aGl0ZS1vbi1ibGFjayc7XG4vKiogQ1NTIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IGJvZHkgd2hlbiBpbiBoaWdoLWNvbnRyYXN0IG1vZGUuICovXG5jb25zdCBISUdIX0NPTlRSQVNUX01PREVfQUNUSVZFX0NTU19DTEFTUyA9ICdjZGstaGlnaC1jb250cmFzdC1hY3RpdmUnO1xuLyoqXG4gKiBTZXJ2aWNlIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBpbiBhIGhpZ2gtY29udHJhc3QtbW9kZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBNaWNyb3NvZnQgV2luZG93cyBzdXBwb3J0cyBhbiBhY2Nlc3NpYmlsaXR5IGZlYXR1cmUgY2FsbGVkIFwiSGlnaCBDb250cmFzdCBNb2RlXCIuIFRoaXMgbW9kZVxuICogY2hhbmdlcyB0aGUgYXBwZWFyYW5jZSBvZiBhbGwgYXBwbGljYXRpb25zLCBpbmNsdWRpbmcgd2ViIGFwcGxpY2F0aW9ucywgdG8gZHJhbWF0aWNhbGx5IGluY3JlYXNlXG4gKiBjb250cmFzdC5cbiAqXG4gKiBJRSwgRWRnZSwgYW5kIEZpcmVmb3ggY3VycmVudGx5IHN1cHBvcnQgdGhpcyBtb2RlLiBDaHJvbWUgZG9lcyBub3Qgc3VwcG9ydCBXaW5kb3dzIEhpZ2ggQ29udHJhc3RcbiAqIE1vZGUuIFRoaXMgc2VydmljZSBkb2VzIG5vdCBkZXRlY3QgaGlnaC1jb250cmFzdCBtb2RlIGFzIGFkZGVkIGJ5IHRoZSBDaHJvbWUgXCJIaWdoIENvbnRyYXN0XCJcbiAqIGJyb3dzZXIgZXh0ZW5zaW9uLlxuICovXG5jbGFzcyBIaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKF9wbGF0Zm9ybSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2JyZWFrcG9pbnRTdWJzY3JpcHRpb24gPSBpbmplY3QoQnJlYWtwb2ludE9ic2VydmVyKVxuICAgICAgICAgICAgLm9ic2VydmUoJyhmb3JjZWQtY29sb3JzOiBhY3RpdmUpJylcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0NoZWNrZWRIaWdoQ29udHJhc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzQ2hlY2tlZEhpZ2hDb250cmFzdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUJvZHlIaWdoQ29udHJhc3RNb2RlQ3NzQ2xhc3NlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgaGlnaC1jb250cmFzdC1tb2RlIGZvciB0aGUgcGFnZS4gKi9cbiAgICBnZXRIaWdoQ29udHJhc3RNb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogSGlnaENvbnRyYXN0TW9kZS5OT05FICovO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIHRlc3QgZWxlbWVudCB3aXRoIGFuIGFyYml0cmFyeSBiYWNrZ3JvdW5kLWNvbG9yIHRoYXQgaXMgbmVpdGhlciBibGFjayBub3JcbiAgICAgICAgLy8gd2hpdGU7IGhpZ2gtY29udHJhc3QgbW9kZSB3aWxsIGNvZXJjZSB0aGUgY29sb3IgdG8gZWl0aGVyIGJsYWNrIG9yIHdoaXRlLiBBbHNvIGVuc3VyZSB0aGF0XG4gICAgICAgIC8vIGFwcGVuZGluZyB0aGUgdGVzdCBlbGVtZW50IHRvIHRoZSBET00gZG9lcyBub3QgYWZmZWN0IGxheW91dCBieSBhYnNvbHV0ZWx5IHBvc2l0aW9uaW5nIGl0XG4gICAgICAgIGNvbnN0IHRlc3RFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRlc3RFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2IoMSwyLDMpJztcbiAgICAgICAgdGVzdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RFbGVtZW50KTtcbiAgICAgICAgLy8gR2V0IHRoZSBjb21wdXRlZCBzdHlsZSBmb3IgdGhlIGJhY2tncm91bmQgY29sb3IsIGNvbGxhcHNpbmcgc3BhY2VzIHRvIG5vcm1hbGl6ZSBiZXR3ZWVuXG4gICAgICAgIC8vIGJyb3dzZXJzLiBPbmNlIHdlIGdldCB0aGlzIGNvbG9yLCB3ZSBubyBsb25nZXIgbmVlZCB0aGUgdGVzdCBlbGVtZW50LiBBY2Nlc3MgdGhlIGB3aW5kb3dgXG4gICAgICAgIC8vIHZpYSB0aGUgZG9jdW1lbnQgc28gd2UgY2FuIGZha2UgaXQgaW4gdGVzdHMuIE5vdGUgdGhhdCB3ZSBoYXZlIGV4dHJhIG51bGwgY2hlY2tzLCBiZWNhdXNlXG4gICAgICAgIC8vIHRoaXMgbG9naWMgd2lsbCBsaWtlbHkgcnVuIGR1cmluZyBhcHAgYm9vdHN0cmFwIGFuZCB0aHJvd2luZyBjYW4gYnJlYWsgdGhlIGVudGlyZSBhcHAuXG4gICAgICAgIGNvbnN0IGRvY3VtZW50V2luZG93ID0gdGhpcy5fZG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZG9jdW1lbnRXaW5kb3cgJiYgZG9jdW1lbnRXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZVxuICAgICAgICAgICAgPyBkb2N1bWVudFdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRlc3RFbGVtZW50KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBjb21wdXRlZENvbG9yID0gKChjb21wdXRlZFN0eWxlICYmIGNvbXB1dGVkU3R5bGUuYmFja2dyb3VuZENvbG9yKSB8fCAnJykucmVwbGFjZSgvIC9nLCAnJyk7XG4gICAgICAgIHRlc3RFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzd2l0Y2ggKGNvbXB1dGVkQ29sb3IpIHtcbiAgICAgICAgICAgIC8vIFByZSBXaW5kb3dzIDExIGRhcmsgdGhlbWUuXG4gICAgICAgICAgICBjYXNlICdyZ2IoMCwwLDApJzpcbiAgICAgICAgICAgIC8vIFdpbmRvd3MgMTEgZGFyayB0aGVtZXMuXG4gICAgICAgICAgICBjYXNlICdyZ2IoNDUsNTAsNTQpJzpcbiAgICAgICAgICAgIGNhc2UgJ3JnYigzMiwzMiwzMiknOlxuICAgICAgICAgICAgICAgIHJldHVybiAyIC8qIEhpZ2hDb250cmFzdE1vZGUuV0hJVEVfT05fQkxBQ0sgKi87XG4gICAgICAgICAgICAvLyBQcmUgV2luZG93cyAxMSBsaWdodCB0aGVtZS5cbiAgICAgICAgICAgIGNhc2UgJ3JnYigyNTUsMjU1LDI1NSknOlxuICAgICAgICAgICAgLy8gV2luZG93cyAxMSBsaWdodCB0aGVtZS5cbiAgICAgICAgICAgIGNhc2UgJ3JnYigyNTUsMjUwLDIzOSknOlxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIEhpZ2hDb250cmFzdE1vZGUuQkxBQ0tfT05fV0hJVEUgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogSGlnaENvbnRyYXN0TW9kZS5OT05FICovO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fYnJlYWtwb2ludFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICAvKiogQXBwbGllcyBDU1MgY2xhc3NlcyBpbmRpY2F0aW5nIGhpZ2gtY29udHJhc3QgbW9kZSB0byBkb2N1bWVudCBib2R5IChicm93c2VyLW9ubHkpLiAqL1xuICAgIF9hcHBseUJvZHlIaWdoQ29udHJhc3RNb2RlQ3NzQ2xhc3NlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNDaGVja2VkSGlnaENvbnRyYXN0TW9kZSAmJiB0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIgJiYgdGhpcy5fZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgY29uc3QgYm9keUNsYXNzZXMgPSB0aGlzLl9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdDtcbiAgICAgICAgICAgIGJvZHlDbGFzc2VzLnJlbW92ZShISUdIX0NPTlRSQVNUX01PREVfQUNUSVZFX0NTU19DTEFTUywgQkxBQ0tfT05fV0hJVEVfQ1NTX0NMQVNTLCBXSElURV9PTl9CTEFDS19DU1NfQ0xBU1MpO1xuICAgICAgICAgICAgdGhpcy5faGFzQ2hlY2tlZEhpZ2hDb250cmFzdE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMuZ2V0SGlnaENvbnRyYXN0TW9kZSgpO1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IDEgLyogSGlnaENvbnRyYXN0TW9kZS5CTEFDS19PTl9XSElURSAqLykge1xuICAgICAgICAgICAgICAgIGJvZHlDbGFzc2VzLmFkZChISUdIX0NPTlRSQVNUX01PREVfQUNUSVZFX0NTU19DTEFTUywgQkxBQ0tfT05fV0hJVEVfQ1NTX0NMQVNTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IDIgLyogSGlnaENvbnRyYXN0TW9kZS5XSElURV9PTl9CTEFDSyAqLykge1xuICAgICAgICAgICAgICAgIGJvZHlDbGFzc2VzLmFkZChISUdIX0NPTlRSQVNUX01PREVfQUNUSVZFX0NTU19DTEFTUywgV0hJVEVfT05fQkxBQ0tfQ1NTX0NMQVNTKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbkhpZ2hDb250cmFzdE1vZGVEZXRlY3Rvci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEhpZ2hDb250cmFzdE1vZGVEZXRlY3RvciwgZGVwczogW3sgdG9rZW46IGkxLlBsYXRmb3JtIH0sIHsgdG9rZW46IERPQ1VNRU5UIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5IaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGlnaENvbnRyYXN0TW9kZURldGVjdG9yLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBIaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTEuUGxhdGZvcm0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RPQ1VNRU5UXVxuICAgICAgICAgICAgICAgIH1dIH1dOyB9IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmNsYXNzIEExMXlNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGhpZ2hDb250cmFzdE1vZGVEZXRlY3Rvcikge1xuICAgICAgICBoaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IuX2FwcGx5Qm9keUhpZ2hDb250cmFzdE1vZGVDc3NDbGFzc2VzKCk7XG4gICAgfVxufVxuQTExeU1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEExMXlNb2R1bGUsIGRlcHM6IFt7IHRva2VuOiBIaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5BMTF5TW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEExMXlNb2R1bGUsIGRlY2xhcmF0aW9uczogW0Nka0FyaWFMaXZlLCBDZGtUcmFwRm9jdXMsIENka01vbml0b3JGb2N1c10sIGltcG9ydHM6IFtPYnNlcnZlcnNNb2R1bGVdLCBleHBvcnRzOiBbQ2RrQXJpYUxpdmUsIENka1RyYXBGb2N1cywgQ2RrTW9uaXRvckZvY3VzXSB9KTtcbkExMXlNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQTExeU1vZHVsZSwgaW1wb3J0czogW09ic2VydmVyc01vZHVsZV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBMTF5TW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbT2JzZXJ2ZXJzTW9kdWxlXSxcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ2RrQXJpYUxpdmUsIENka1RyYXBGb2N1cywgQ2RrTW9uaXRvckZvY3VzXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0Nka0FyaWFMaXZlLCBDZGtUcmFwRm9jdXMsIENka01vbml0b3JGb2N1c10sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBIaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IgfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBMTF5TW9kdWxlLCBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlciwgQXJpYURlc2NyaWJlciwgQ0RLX0RFU0NSSUJFREJZX0hPU1RfQVRUUklCVVRFLCBDREtfREVTQ1JJQkVEQllfSURfUFJFRklYLCBDZGtBcmlhTGl2ZSwgQ2RrTW9uaXRvckZvY3VzLCBDZGtUcmFwRm9jdXMsIENvbmZpZ3VyYWJsZUZvY3VzVHJhcCwgQ29uZmlndXJhYmxlRm9jdXNUcmFwRmFjdG9yeSwgRXZlbnRMaXN0ZW5lckZvY3VzVHJhcEluZXJ0U3RyYXRlZ3ksIEZPQ1VTX01PTklUT1JfREVGQVVMVF9PUFRJT05TLCBGT0NVU19UUkFQX0lORVJUX1NUUkFURUdZLCBGb2N1c0tleU1hbmFnZXIsIEZvY3VzTW9uaXRvciwgRm9jdXNUcmFwLCBGb2N1c1RyYXBGYWN0b3J5LCBIaWdoQ29udHJhc3RNb2RlRGV0ZWN0b3IsIElOUFVUX01PREFMSVRZX0RFVEVDVE9SX0RFRkFVTFRfT1BUSU9OUywgSU5QVVRfTU9EQUxJVFlfREVURUNUT1JfT1BUSU9OUywgSW5wdXRNb2RhbGl0eURldGVjdG9yLCBJbnRlcmFjdGl2aXR5Q2hlY2tlciwgSXNGb2N1c2FibGVDb25maWcsIExJVkVfQU5OT1VOQ0VSX0RFRkFVTFRfT1BUSU9OUywgTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTiwgTElWRV9BTk5PVU5DRVJfRUxFTUVOVF9UT0tFTl9GQUNUT1JZLCBMaXN0S2V5TWFuYWdlciwgTGl2ZUFubm91bmNlciwgTUVTU0FHRVNfQ09OVEFJTkVSX0lELCBpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyLCBpc0Zha2VUb3VjaHN0YXJ0RnJvbVNjcmVlblJlYWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YTExeS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/a11y.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/bidi.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/bidi.mjs ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BidiModule\": function() { return /* binding */ BidiModule; },\n/* harmony export */   \"DIR_DOCUMENT\": function() { return /* binding */ DIR_DOCUMENT; },\n/* harmony export */   \"Dir\": function() { return /* binding */ Dir; },\n/* harmony export */   \"Directionality\": function() { return /* binding */ Directionality; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-browser because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\nconst DIR_DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Regex that matches locales with an RTL script. Taken from `goog.i18n.bidi.isRtlLanguage`. */\nconst RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;\n/** Resolves a string value to a specific direction. */\nfunction _resolveDirectionality(rawValue) {\n    const value = rawValue?.toLowerCase() || '';\n    if (value === 'auto' && typeof navigator !== 'undefined' && navigator?.language) {\n        return RTL_LOCALE_PATTERN.test(navigator.language) ? 'rtl' : 'ltr';\n    }\n    return value === 'rtl' ? 'rtl' : 'ltr';\n}\n/**\n * The directionality (LTR / RTL) context for the application (or a subtree of it).\n * Exposes the current direction and a stream of direction changes.\n */\nclass Directionality {\n    constructor(_document) {\n        /** The current 'ltr' or 'rtl' value. */\n        this.value = 'ltr';\n        /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        if (_document) {\n            const bodyDir = _document.body ? _document.body.dir : null;\n            const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n            this.value = _resolveDirectionality(bodyDir || htmlDir || 'ltr');\n        }\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDirectionality.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Directionality, deps: [{ token: DIR_DOCUMENT, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nDirectionality.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Directionality, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Directionality, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [DIR_DOCUMENT]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Directive to listen for changes of direction of part of the DOM.\n *\n * Provides itself as Directionality such that descendant directives only need to ever inject\n * Directionality to get the closest direction.\n */\nclass Dir {\n    constructor() {\n        /** Normalized direction that accounts for invalid/unsupported values. */\n        this._dir = 'ltr';\n        /** Whether the `value` has been set to its initial value. */\n        this._isInitialized = false;\n        /** Event emitted when the direction changes. */\n        this.change = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n    }\n    /** @docs-private */\n    get dir() {\n        return this._dir;\n    }\n    set dir(value) {\n        const previousValue = this._dir;\n        // Note: `_resolveDirectionality` resolves the language based on the browser's language,\n        // whereas the browser does it based on the content of the element. Since doing so based\n        // on the content can be expensive, for now we're doing the simpler matching.\n        this._dir = _resolveDirectionality(value);\n        this._rawDir = value;\n        if (previousValue !== this._dir && this._isInitialized) {\n            this.change.emit(this._dir);\n        }\n    }\n    /** Current layout direction of the element. */\n    get value() {\n        return this.dir;\n    }\n    /** Initialize once default value has been set. */\n    ngAfterContentInit() {\n        this._isInitialized = true;\n    }\n    ngOnDestroy() {\n        this.change.complete();\n    }\n}\nDir.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Dir, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nDir.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: Dir, selector: \"[dir]\", inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, host: { properties: { \"attr.dir\": \"_rawDir\" } }, providers: [{ provide: Directionality, useExisting: Dir }], exportAs: [\"dir\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Dir, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[dir]',\n                    providers: [{ provide: Directionality, useExisting: Dir }],\n                    host: { '[attr.dir]': '_rawDir' },\n                    exportAs: 'dir',\n                }]\n        }], propDecorators: { change: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,\n                args: ['dirChange']\n            }], dir: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass BidiModule {\n}\nBidiModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BidiModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nBidiModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BidiModule, declarations: [Dir], exports: [Dir] });\nBidiModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BidiModule });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BidiModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    exports: [Dir],\n                    declarations: [Dir],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=bidi.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2JpZGkubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZmVzbTIwMjAvYmlkaS5tanM/YjhhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpMCBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluamVjdGlvblRva2VuLCBpbmplY3QsIEV2ZW50RW1pdHRlciwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCwgRGlyZWN0aXZlLCBPdXRwdXQsIElucHV0LCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogSW5qZWN0aW9uIHRva2VuIHVzZWQgdG8gaW5qZWN0IHRoZSBkb2N1bWVudCBpbnRvIERpcmVjdGlvbmFsaXR5LlxuICogVGhpcyBpcyB1c2VkIHNvIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBmYWtlZCBpbiB0ZXN0cy5cbiAqXG4gKiBXZSBjYW4ndCB1c2UgdGhlIHJlYWwgZG9jdW1lbnQgaW4gdGVzdHMgYmVjYXVzZSBjaGFuZ2luZyB0aGUgcmVhbCBgZGlyYCBjYXVzZXMgZ2VvbWV0cnktYmFzZWRcbiAqIHRlc3RzIGluIFNhZmFyaSB0byBmYWlsLlxuICpcbiAqIFdlIGFsc28gY2FuJ3QgcmUtcHJvdmlkZSB0aGUgRE9DVU1FTlQgdG9rZW4gZnJvbSBwbGF0Zm9ybS1icm93c2VyIGJlY2F1c2UgdGhlIHVuaXQgdGVzdHNcbiAqIHRoZW1zZWx2ZXMgdXNlIHRoaW5ncyBsaWtlIGBxdWVyeVNlbGVjdG9yYCBpbiB0ZXN0IGNvZGUuXG4gKlxuICogVGhpcyB0b2tlbiBpcyBkZWZpbmVkIGluIGEgc2VwYXJhdGUgZmlsZSBmcm9tIERpcmVjdGlvbmFsaXR5IGFzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIyNTU5XG4gKlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jb25zdCBESVJfRE9DVU1FTlQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2Nkay1kaXItZG9jJywge1xuICAgIHByb3ZpZGVkSW46ICdyb290JyxcbiAgICBmYWN0b3J5OiBESVJfRE9DVU1FTlRfRkFDVE9SWSxcbn0pO1xuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmZ1bmN0aW9uIERJUl9ET0NVTUVOVF9GQUNUT1JZKCkge1xuICAgIHJldHVybiBpbmplY3QoRE9DVU1FTlQpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBSZWdleCB0aGF0IG1hdGNoZXMgbG9jYWxlcyB3aXRoIGFuIFJUTCBzY3JpcHQuIFRha2VuIGZyb20gYGdvb2cuaTE4bi5iaWRpLmlzUnRsTGFuZ3VhZ2VgLiAqL1xuY29uc3QgUlRMX0xPQ0FMRV9QQVRURVJOID0gL14oYXJ8Y2tifGR2fGhlfGl3fGZhfG5xb3xwc3xzZHx1Z3x1cnx5aXwuKlstX10oQWRsbXxBcmFifEhlYnJ8Tmtvb3xSb2hnfFRoYWEpKSg/IS4qWy1fXShMYXRufEN5cmwpKCR8LXxfKSkoJHwtfF8pL2k7XG4vKiogUmVzb2x2ZXMgYSBzdHJpbmcgdmFsdWUgdG8gYSBzcGVjaWZpYyBkaXJlY3Rpb24uICovXG5mdW5jdGlvbiBfcmVzb2x2ZURpcmVjdGlvbmFsaXR5KHJhd1ZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSByYXdWYWx1ZT8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgICBpZiAodmFsdWUgPT09ICdhdXRvJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3I/Lmxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiBSVExfTE9DQUxFX1BBVFRFUk4udGVzdChuYXZpZ2F0b3IubGFuZ3VhZ2UpID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG59XG4vKipcbiAqIFRoZSBkaXJlY3Rpb25hbGl0eSAoTFRSIC8gUlRMKSBjb250ZXh0IGZvciB0aGUgYXBwbGljYXRpb24gKG9yIGEgc3VidHJlZSBvZiBpdCkuXG4gKiBFeHBvc2VzIHRoZSBjdXJyZW50IGRpcmVjdGlvbiBhbmQgYSBzdHJlYW0gb2YgZGlyZWN0aW9uIGNoYW5nZXMuXG4gKi9cbmNsYXNzIERpcmVjdGlvbmFsaXR5IHtcbiAgICBjb25zdHJ1Y3RvcihfZG9jdW1lbnQpIHtcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50ICdsdHInIG9yICdydGwnIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gJ2x0cic7XG4gICAgICAgIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgJ2x0cicgLyAncnRsJyBzdGF0ZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLmNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgaWYgKF9kb2N1bWVudCkge1xuICAgICAgICAgICAgY29uc3QgYm9keURpciA9IF9kb2N1bWVudC5ib2R5ID8gX2RvY3VtZW50LmJvZHkuZGlyIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGh0bWxEaXIgPSBfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IF9yZXNvbHZlRGlyZWN0aW9uYWxpdHkoYm9keURpciB8fCBodG1sRGlyIHx8ICdsdHInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2UuY29tcGxldGUoKTtcbiAgICB9XG59XG5EaXJlY3Rpb25hbGl0eS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZXBzOiBbeyB0b2tlbjogRElSX0RPQ1VNRU5ULCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRGlyZWN0aW9uYWxpdHkuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRGlyZWN0aW9uYWxpdHksIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0RJUl9ET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIERpcmVjdGl2ZSB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgb2YgZGlyZWN0aW9uIG9mIHBhcnQgb2YgdGhlIERPTS5cbiAqXG4gKiBQcm92aWRlcyBpdHNlbGYgYXMgRGlyZWN0aW9uYWxpdHkgc3VjaCB0aGF0IGRlc2NlbmRhbnQgZGlyZWN0aXZlcyBvbmx5IG5lZWQgdG8gZXZlciBpbmplY3RcbiAqIERpcmVjdGlvbmFsaXR5IHRvIGdldCB0aGUgY2xvc2VzdCBkaXJlY3Rpb24uXG4gKi9cbmNsYXNzIERpciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKiBOb3JtYWxpemVkIGRpcmVjdGlvbiB0aGF0IGFjY291bnRzIGZvciBpbnZhbGlkL3Vuc3VwcG9ydGVkIHZhbHVlcy4gKi9cbiAgICAgICAgdGhpcy5fZGlyID0gJ2x0cic7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBgdmFsdWVgIGhhcyBiZWVuIHNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBkaXJlY3Rpb24gY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGRpcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcjtcbiAgICB9XG4gICAgc2V0IGRpcih2YWx1ZSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fZGlyO1xuICAgICAgICAvLyBOb3RlOiBgX3Jlc29sdmVEaXJlY3Rpb25hbGl0eWAgcmVzb2x2ZXMgdGhlIGxhbmd1YWdlIGJhc2VkIG9uIHRoZSBicm93c2VyJ3MgbGFuZ3VhZ2UsXG4gICAgICAgIC8vIHdoZXJlYXMgdGhlIGJyb3dzZXIgZG9lcyBpdCBiYXNlZCBvbiB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudC4gU2luY2UgZG9pbmcgc28gYmFzZWRcbiAgICAgICAgLy8gb24gdGhlIGNvbnRlbnQgY2FuIGJlIGV4cGVuc2l2ZSwgZm9yIG5vdyB3ZSdyZSBkb2luZyB0aGUgc2ltcGxlciBtYXRjaGluZy5cbiAgICAgICAgdGhpcy5fZGlyID0gX3Jlc29sdmVEaXJlY3Rpb25hbGl0eSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3Jhd0RpciA9IHZhbHVlO1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gdGhpcy5fZGlyICYmIHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlLmVtaXQodGhpcy5fZGlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ3VycmVudCBsYXlvdXQgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LiAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyO1xuICAgIH1cbiAgICAvKiogSW5pdGlhbGl6ZSBvbmNlIGRlZmF1bHQgdmFsdWUgaGFzIGJlZW4gc2V0LiAqL1xuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoYW5nZS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbkRpci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERpciwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuRGlyLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogRGlyLCBzZWxlY3RvcjogXCJbZGlyXVwiLCBpbnB1dHM6IHsgZGlyOiBcImRpclwiIH0sIG91dHB1dHM6IHsgY2hhbmdlOiBcImRpckNoYW5nZVwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIuZGlyXCI6IFwiX3Jhd0RpclwiIH0gfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEaXJlY3Rpb25hbGl0eSwgdXNlRXhpc3Rpbmc6IERpciB9XSwgZXhwb3J0QXM6IFtcImRpclwiXSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRGlyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbZGlyXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRGlyZWN0aW9uYWxpdHksIHVzZUV4aXN0aW5nOiBEaXIgfV0sXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLmRpcl0nOiAnX3Jhd0RpcicgfSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICdkaXInLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBjaGFuZ2U6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZGlyQ2hhbmdlJ11cbiAgICAgICAgICAgIH1dLCBkaXI6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgQmlkaU1vZHVsZSB7XG59XG5CaWRpTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQmlkaU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5CaWRpTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJpZGlNb2R1bGUsIGRlY2xhcmF0aW9uczogW0Rpcl0sIGV4cG9ydHM6IFtEaXJdIH0pO1xuQmlkaU1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCaWRpTW9kdWxlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQmlkaU1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0Rpcl0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0Rpcl0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBCaWRpTW9kdWxlLCBESVJfRE9DVU1FTlQsIERpciwgRGlyZWN0aW9uYWxpdHkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZGkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/bidi.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/coercion.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/coercion.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_isNumberValue\": function() { return /* binding */ _isNumberValue; },\n/* harmony export */   \"coerceArray\": function() { return /* binding */ coerceArray; },\n/* harmony export */   \"coerceBooleanProperty\": function() { return /* binding */ coerceBooleanProperty; },\n/* harmony export */   \"coerceCssPixelValue\": function() { return /* binding */ coerceCssPixelValue; },\n/* harmony export */   \"coerceElement\": function() { return /* binding */ coerceElement; },\n/* harmony export */   \"coerceNumberProperty\": function() { return /* binding */ coerceNumberProperty; },\n/* harmony export */   \"coerceStringArray\": function() { return /* binding */ coerceStringArray; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef ? elementOrRef.nativeElement : elementOrRef;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nfunction coerceStringArray(value, separator = /\\s+/) {\n    const result = [];\n    if (value != null) {\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\n        for (const sourceValue of sourceValues) {\n            const trimmedString = `${sourceValue}`.trim();\n            if (trimmedString) {\n                result.push(trimmedString);\n            }\n        }\n    }\n    return result;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n//# sourceMappingURL=coercion.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2NvZXJjaW9uLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL0Bhbmd1bGFyL2Nkay9mZXNtMjAyMC9jb2VyY2lvbi5tanM/ZjljNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIENvZXJjZXMgYSBkYXRhLWJvdW5kIHZhbHVlICh0eXBpY2FsbHkgYSBzdHJpbmcpIHRvIGEgYm9vbGVhbi4gKi9cbmZ1bmN0aW9uIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGAke3ZhbHVlfWAgIT09ICdmYWxzZSc7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUsIGZhbGxiYWNrVmFsdWUgPSAwKSB7XG4gICAgcmV0dXJuIF9pc051bWJlclZhbHVlKHZhbHVlKSA/IE51bWJlcih2YWx1ZSkgOiBmYWxsYmFja1ZhbHVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBjb25zaWRlcmVkIGEgbnVtYmVyLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaXNOdW1iZXJWYWx1ZSh2YWx1ZSkge1xuICAgIC8vIHBhcnNlRmxvYXQodmFsdWUpIGhhbmRsZXMgbW9zdCBvZiB0aGUgY2FzZXMgd2UncmUgaW50ZXJlc3RlZCBpbiAoaXQgdHJlYXRzIG51bGwsIGVtcHR5IHN0cmluZyxcbiAgICAvLyBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMgYXMgTmFOLCB3aGVyZSBOdW1iZXIganVzdCB1c2VzIDApIGJ1dCBpdCBjb25zaWRlcnMgdGhlIHN0cmluZ1xuICAgIC8vICcxMjNoZWxsbycgdG8gYmUgYSB2YWxpZCBudW1iZXIuIFRoZXJlZm9yZSB3ZSBhbHNvIGNoZWNrIGlmIE51bWJlcih2YWx1ZSkgaXMgTmFOLlxuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpICYmICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBjb2VyY2VBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogQ29lcmNlcyBhIHZhbHVlIHRvIGEgQ1NTIHBpeGVsIHZhbHVlLiAqL1xuZnVuY3Rpb24gY29lcmNlQ3NzUGl4ZWxWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IGAke3ZhbHVlfXB4YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENvZXJjZXMgYW4gRWxlbWVudFJlZiBvciBhbiBFbGVtZW50IGludG8gYW4gZWxlbWVudC5cbiAqIFVzZWZ1bCBmb3IgQVBJcyB0aGF0IGNhbiBhY2NlcHQgZWl0aGVyIGEgcmVmIG9yIHRoZSBuYXRpdmUgZWxlbWVudCBpdHNlbGYuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZUVsZW1lbnQoZWxlbWVudE9yUmVmKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRPclJlZiBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgPyBlbGVtZW50T3JSZWYubmF0aXZlRWxlbWVudCA6IGVsZW1lbnRPclJlZjtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENvZXJjZXMgYSB2YWx1ZSB0byBhbiBhcnJheSBvZiB0cmltbWVkIG5vbi1lbXB0eSBzdHJpbmdzLlxuICogQW55IGlucHV0IHRoYXQgaXMgbm90IGFuIGFycmF5LCBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCBiZSB0dXJuZWQgaW50byBhIHN0cmluZ1xuICogdmlhIGB0b1N0cmluZygpYCBhbmQgc3Vic2VxdWVudGx5IHNwbGl0IHdpdGggdGhlIGdpdmVuIHNlcGFyYXRvci5cbiAqIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgd2lsbCByZXN1bHQgaW4gYW4gZW1wdHkgYXJyYXkuXG4gKiBUaGlzIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyBvdXRjb21lczpcbiAqIC0gYG51bGxgIC0mZ3Q7IGBbXWBcbiAqIC0gYFtudWxsXWAgLSZndDsgYFtcIm51bGxcIl1gXG4gKiAtIGBbXCJhXCIsIFwiYiBcIiwgXCIgXCJdYCAtJmd0OyBgW1wiYVwiLCBcImJcIl1gXG4gKiAtIGBbMSwgWzIsIDNdXWAgLSZndDsgYFtcIjFcIiwgXCIyLDNcIl1gXG4gKiAtIGBbeyBhOiAwIH1dYCAtJmd0OyBgW1wiW29iamVjdCBPYmplY3RdXCJdYFxuICogLSBgeyBhOiAwIH1gIC0mZ3Q7IGBbXCJbb2JqZWN0XCIsIFwiT2JqZWN0XVwiXWBcbiAqXG4gKiBVc2VmdWwgZm9yIGRlZmluaW5nIENTUyBjbGFzc2VzIG9yIHRhYmxlIGNvbHVtbnMuXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHRvIGNvZXJjZSBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3NcbiAqIEBwYXJhbSBzZXBhcmF0b3Igc3BsaXQtc2VwYXJhdG9yIGlmIHZhbHVlIGlzbid0IGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVN0cmluZ0FycmF5KHZhbHVlLCBzZXBhcmF0b3IgPSAvXFxzKy8pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogYCR7dmFsdWV9YC5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZVZhbHVlIG9mIHNvdXJjZVZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFN0cmluZyA9IGAke3NvdXJjZVZhbHVlfWAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKHRyaW1tZWRTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0cmltbWVkU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbmV4cG9ydCB7IF9pc051bWJlclZhbHVlLCBjb2VyY2VBcnJheSwgY29lcmNlQm9vbGVhblByb3BlcnR5LCBjb2VyY2VDc3NQaXhlbFZhbHVlLCBjb2VyY2VFbGVtZW50LCBjb2VyY2VOdW1iZXJQcm9wZXJ0eSwgY29lcmNlU3RyaW5nQXJyYXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjaW9uLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/coercion.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/collections.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/collections.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ArrayDataSource\": function() { return /* binding */ ArrayDataSource; },\n/* harmony export */   \"DataSource\": function() { return /* binding */ DataSource; },\n/* harmony export */   \"SelectionModel\": function() { return /* binding */ SelectionModel; },\n/* harmony export */   \"UniqueSelectionDispatcher\": function() { return /* binding */ UniqueSelectionDispatcher; },\n/* harmony export */   \"_DisposeViewRepeaterStrategy\": function() { return /* binding */ _DisposeViewRepeaterStrategy; },\n/* harmony export */   \"_RecycleViewRepeaterStrategy\": function() { return /* binding */ _RecycleViewRepeaterStrategy; },\n/* harmony export */   \"_VIEW_REPEATER_STRATEGY\": function() { return /* binding */ _VIEW_REPEATER_STRATEGY; },\n/* harmony export */   \"getMultipleValuesInSingleSelectionError\": function() { return /* binding */ getMultipleValuesInSingleSelectionError; },\n/* harmony export */   \"isDataSource\": function() { return /* binding */ isDataSource; }\n/* harmony export */ });\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource. We also can't use `isObservable`\n    // here, because of some internal apps.\n    return value && typeof value.connect === 'function' && !(value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__.ConnectableObservable);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.isObservable)(this._data) ? this._data : (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(this._data);\n    }\n    disconnect() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = 1 /* _ViewRepeaterOperation.INSERTED */;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = 3 /* _ViewRepeaterOperation.REMOVED */;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = 2 /* _ViewRepeaterOperation.MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view?.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() { }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? 1 /* _ViewRepeaterOperation.INSERTED */ : 0 /* _ViewRepeaterOperation.REPLACED */;\n            }\n            else if (currentIndex == null) {\n                // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = 3 /* _ViewRepeaterOperation.REMOVED */;\n            }\n            else {\n                // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = 2 /* _ViewRepeaterOperation.MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view?.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass SelectionModel {\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true, compareWith) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        this.compareWith = compareWith;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new rxjs__WEBPACK_IMPORTED_MODULE_0__.Subject();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /**\n     * Selects a value or an array of values.\n     * @param values The values to select\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Deselects a value or an array of values.\n     * @param values The values to deselect\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Sets the selected values\n     * @param values The new selected values\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    setSelection(...values) {\n        this._verifyValueAssignment(values);\n        const oldValues = this.selected;\n        const newSelectedSet = new Set(values);\n        values.forEach(value => this._markSelected(value));\n        oldValues\n            .filter(value => !newSelectedSet.has(value))\n            .forEach(value => this._unmarkSelected(value));\n        const changed = this._hasQueuedChanges();\n        this._emitChangeEvent();\n        return changed;\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     * @param value The value to toggle\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    toggle(value) {\n        return this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     * @param flushEvent Whether to flush the changes in an event.\n     *   If false, the changes to the selection will be flushed along with the next event.\n     * @return Whether the selection changed as a result of this call\n     * @breaking-change 16.0.0 make return type boolean\n     */\n    clear(flushEvent = true) {\n        this._unmarkAll();\n        const changed = this._hasQueuedChanges();\n        if (flushEvent) {\n            this._emitChangeEvent();\n        }\n        return changed;\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(this._getConcreteValue(value));\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit,\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        value = this._getConcreteValue(value);\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            if (!this.isSelected(value)) {\n                this._selection.add(value);\n            }\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        value = this._getConcreteValue(value);\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n    /** Whether there are queued up change to be emitted. */\n    _hasQueuedChanges() {\n        return !!(this._deselectedToEmit.length || this._selectedToEmit.length);\n    }\n    /** Returns a value that is comparable to inputValue by applying compareWith function, returns the same inputValue otherwise. */\n    _getConcreteValue(inputValue) {\n        if (!this.compareWith) {\n            return inputValue;\n        }\n        else {\n            for (let selectedValue of this._selection) {\n                if (this.compareWith(inputValue, selectedValue)) {\n                    return selectedValue;\n                }\n            }\n            return inputValue;\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nclass UniqueSelectionDispatcher {\n    constructor() {\n        this._listeners = [];\n    }\n    /**\n     * Notify other items that selection for the given name has been set.\n     * @param id ID of the item.\n     * @param name Name of the item.\n     */\n    notify(id, name) {\n        for (let listener of this._listeners) {\n            listener(id, name);\n        }\n    }\n    /**\n     * Listen for future changes to item selection.\n     * @return Function used to deregister listener\n     */\n    listen(listener) {\n        this._listeners.push(listener);\n        return () => {\n            this._listeners = this._listeners.filter((registered) => {\n                return listener !== registered;\n            });\n        };\n    }\n    ngOnDestroy() {\n        this._listeners = [];\n    }\n}\nUniqueSelectionDispatcher.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: UniqueSelectionDispatcher, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵFactoryTarget\"].Injectable });\nUniqueSelectionDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: UniqueSelectionDispatcher, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_1__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_1___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_1__, 2))), type: UniqueSelectionDispatcher, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('_ViewRepeater');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=collections.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2NvbGxlY3Rpb25zLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZmVzbTIwMjAvY29sbGVjdGlvbnMubWpzP2NlZGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBpc09ic2VydmFibGUsIG9mLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgKiBhcyBpMCBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgRGF0YVNvdXJjZSB7XG59XG4vKiogQ2hlY2tzIHdoZXRoZXIgYW4gb2JqZWN0IGlzIGEgZGF0YSBzb3VyY2UuICovXG5mdW5jdGlvbiBpc0RhdGFTb3VyY2UodmFsdWUpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYSBEYXRhU291cmNlIGJ5IG9ic2VydmluZyBpZiBpdCBoYXMgYSBjb25uZWN0IGZ1bmN0aW9uLiBDYW5ub3RcbiAgICAvLyBiZSBjaGVja2VkIGFzIGFuIGBpbnN0YW5jZW9mIERhdGFTb3VyY2VgIHNpbmNlIHBlb3BsZSBjb3VsZCBjcmVhdGUgdGhlaXIgb3duIHNvdXJjZXNcbiAgICAvLyB0aGF0IG1hdGNoIHRoZSBpbnRlcmZhY2UsIGJ1dCBkb24ndCBleHRlbmQgRGF0YVNvdXJjZS4gV2UgYWxzbyBjYW4ndCB1c2UgYGlzT2JzZXJ2YWJsZWBcbiAgICAvLyBoZXJlLCBiZWNhdXNlIG9mIHNvbWUgaW50ZXJuYWwgYXBwcy5cbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmNvbm5lY3QgPT09ICdmdW5jdGlvbicgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIERhdGFTb3VyY2Ugd3JhcHBlciBmb3IgYSBuYXRpdmUgYXJyYXkuICovXG5jbGFzcyBBcnJheURhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcihfZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9kYXRhID0gX2RhdGE7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBpc09ic2VydmFibGUodGhpcy5fZGF0YSkgPyB0aGlzLl9kYXRhIDogb2YodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7IH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBBIHJlcGVhdGVyIHRoYXQgZGVzdHJveXMgdmlld3Mgd2hlbiB0aGV5IGFyZSByZW1vdmVkIGZyb20gYVxuICoge0BsaW5rIFZpZXdDb250YWluZXJSZWZ9LiBXaGVuIG5ldyBpdGVtcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgY29udGFpbmVyLFxuICogdGhlIHJlcGVhdGVyIHdpbGwgYWx3YXlzIGNvbnN0cnVjdCBhIG5ldyBlbWJlZGRlZCB2aWV3IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgZm9yIHRoZSBlbWJlZGRlZCB2aWV3J3MgJGltcGxpY2l0IHByb3BlcnR5LlxuICogQHRlbXBsYXRlIFIgVGhlIHR5cGUgZm9yIHRoZSBpdGVtIGluIGVhY2ggSXRlcmFibGVEaWZmZXIgY2hhbmdlIHJlY29yZC5cbiAqIEB0ZW1wbGF0ZSBDIFRoZSB0eXBlIGZvciB0aGUgY29udGV4dCBwYXNzZWQgdG8gZWFjaCBlbWJlZGRlZCB2aWV3LlxuICovXG5jbGFzcyBfRGlzcG9zZVZpZXdSZXBlYXRlclN0cmF0ZWd5IHtcbiAgICBhcHBseUNoYW5nZXMoY2hhbmdlcywgdmlld0NvbnRhaW5lclJlZiwgaXRlbUNvbnRleHRGYWN0b3J5LCBpdGVtVmFsdWVSZXNvbHZlciwgaXRlbVZpZXdDaGFuZ2VkKSB7XG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbigocmVjb3JkLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRDb250ZXh0ID0gaXRlbUNvbnRleHRGYWN0b3J5KHJlY29yZCwgYWRqdXN0ZWRQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIHZpZXcgPSB2aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhpbnNlcnRDb250ZXh0LnRlbXBsYXRlUmVmLCBpbnNlcnRDb250ZXh0LmNvbnRleHQsIGluc2VydENvbnRleHQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IDEgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5JTlNFUlRFRCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmlld0NvbnRhaW5lclJlZi5yZW1vdmUoYWRqdXN0ZWRQcmV2aW91c0luZGV4KTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSAzIC8qIF9WaWV3UmVwZWF0ZXJPcGVyYXRpb24uUkVNT1ZFRCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZpZXcgPSB2aWV3Q29udGFpbmVyUmVmLmdldChhZGp1c3RlZFByZXZpb3VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXJSZWYubW92ZSh2aWV3LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IDIgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5NT1ZFRCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtVmlld0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtVmlld0NoYW5nZWQoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB2aWV3Py5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRldGFjaCgpIHsgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQSByZXBlYXRlciB0aGF0IGNhY2hlcyB2aWV3cyB3aGVuIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSBhXG4gKiB7QGxpbmsgVmlld0NvbnRhaW5lclJlZn0uIFdoZW4gbmV3IGl0ZW1zIGFyZSBpbnNlcnRlZCBpbnRvIHRoZSBjb250YWluZXIsXG4gKiB0aGUgcmVwZWF0ZXIgd2lsbCByZXVzZSBvbmUgb2YgdGhlIGNhY2hlZCB2aWV3cyBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3XG4gKiBlbWJlZGRlZCB2aWV3LiBSZWN5Y2xpbmcgY2FjaGVkIHZpZXdzIHJlZHVjZXMgdGhlIHF1YW50aXR5IG9mIGV4cGVuc2l2ZSBET01cbiAqIGluc2VydHMuXG4gKlxuICogQHRlbXBsYXRlIFQgVGhlIHR5cGUgZm9yIHRoZSBlbWJlZGRlZCB2aWV3J3MgJGltcGxpY2l0IHByb3BlcnR5LlxuICogQHRlbXBsYXRlIFIgVGhlIHR5cGUgZm9yIHRoZSBpdGVtIGluIGVhY2ggSXRlcmFibGVEaWZmZXIgY2hhbmdlIHJlY29yZC5cbiAqIEB0ZW1wbGF0ZSBDIFRoZSB0eXBlIGZvciB0aGUgY29udGV4dCBwYXNzZWQgdG8gZWFjaCBlbWJlZGRlZCB2aWV3LlxuICovXG5jbGFzcyBfUmVjeWNsZVZpZXdSZXBlYXRlclN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBjYWNoZSB1c2VkIHRvIHN0b3JlIHVudXNlZCB2aWV3cy5cbiAgICAgICAgICogU2V0dGluZyB0aGUgY2FjaGUgc2l6ZSB0byBgMGAgd2lsbCBkaXNhYmxlIGNhY2hpbmcuIERlZmF1bHRzIHRvIDIwIHZpZXdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52aWV3Q2FjaGVTaXplID0gMjA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaWV3IGNhY2hlIHRoYXQgc3RvcmVzIGVtYmVkZGVkIHZpZXcgaW5zdGFuY2VzIHRoYXQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgc3RhbXBlZCBvdXQsXG4gICAgICAgICAqIGJ1dCBkb24ndCBhcmUgbm90IGN1cnJlbnRseSByZW5kZXJlZC4gVGhlIHZpZXcgcmVwZWF0ZXIgd2lsbCByZXVzZSB0aGVzZSB2aWV3cyByYXRoZXIgdGhhblxuICAgICAgICAgKiBjcmVhdGluZyBicmFuZCBuZXcgb25lcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETyhtaWNoYWVsamFtZXNwYXJzb25zKSBJbnZlc3RpZ2F0ZSB3aGV0aGVyIHVzaW5nIGEgbGlua2VkIGxpc3Qgd291bGQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3ZpZXdDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKiogQXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NLiAqL1xuICAgIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCB2aWV3Q29udGFpbmVyUmVmLCBpdGVtQ29udGV4dEZhY3RvcnksIGl0ZW1WYWx1ZVJlc29sdmVyLCBpdGVtVmlld0NoYW5nZWQpIHtcbiAgICAgICAgLy8gUmVhcnJhbmdlIHRoZSB2aWV3cyB0byBwdXQgdGhlbSBpbiB0aGUgcmlnaHQgbG9jYXRpb24uXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaE9wZXJhdGlvbigocmVjb3JkLCBhZGp1c3RlZFByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHZpZXc7XG4gICAgICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKHJlY29yZC5wcmV2aW91c0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBJdGVtIGFkZGVkLlxuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdBcmdzRmFjdG9yeSA9ICgpID0+IGl0ZW1Db250ZXh0RmFjdG9yeShyZWNvcmQsIGFkanVzdGVkUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5faW5zZXJ0Vmlldyh2aWV3QXJnc0ZhY3RvcnksIGN1cnJlbnRJbmRleCwgdmlld0NvbnRhaW5lclJlZiwgaXRlbVZhbHVlUmVzb2x2ZXIocmVjb3JkKSk7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uID0gdmlldyA/IDEgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5JTlNFUlRFRCAqLyA6IDAgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5SRVBMQUNFRCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gSXRlbSByZW1vdmVkLlxuICAgICAgICAgICAgICAgIHRoaXMuX2RldGFjaEFuZENhY2hlVmlldyhhZGp1c3RlZFByZXZpb3VzSW5kZXgsIHZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IDMgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5SRU1PVkVEICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSXRlbSBtb3ZlZC5cbiAgICAgICAgICAgICAgICB2aWV3ID0gdGhpcy5fbW92ZVZpZXcoYWRqdXN0ZWRQcmV2aW91c0luZGV4LCBjdXJyZW50SW5kZXgsIHZpZXdDb250YWluZXJSZWYsIGl0ZW1WYWx1ZVJlc29sdmVyKHJlY29yZCkpO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IDIgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5NT1ZFRCAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtVmlld0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtVmlld0NoYW5nZWQoe1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB2aWV3Py5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHRoaXMuX3ZpZXdDYWNoZSkge1xuICAgICAgICAgICAgdmlldy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld0NhY2hlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSB2aWV3IGZvciBhIG5ldyBpdGVtLCBlaXRoZXIgZnJvbSB0aGUgY2FjaGUgb3IgYnkgY3JlYXRpbmcgYSBuZXdcbiAgICAgKiBvbmUuIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGl0ZW0gd2FzIGluc2VydGVkIGludG8gYSBjYWNoZWQgdmlldy5cbiAgICAgKi9cbiAgICBfaW5zZXJ0Vmlldyh2aWV3QXJnc0ZhY3RvcnksIGN1cnJlbnRJbmRleCwgdmlld0NvbnRhaW5lclJlZiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkVmlldyA9IHRoaXMuX2luc2VydFZpZXdGcm9tQ2FjaGUoY3VycmVudEluZGV4LCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgaWYgKGNhY2hlZFZpZXcpIHtcbiAgICAgICAgICAgIGNhY2hlZFZpZXcuY29udGV4dC4kaW1wbGljaXQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgdmlld0FyZ3MgPSB2aWV3QXJnc0ZhY3RvcnkoKTtcbiAgICAgICAgcmV0dXJuIHZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHZpZXdBcmdzLnRlbXBsYXRlUmVmLCB2aWV3QXJncy5jb250ZXh0LCB2aWV3QXJncy5pbmRleCk7XG4gICAgfVxuICAgIC8qKiBEZXRhY2hlcyB0aGUgdmlldyBhdCB0aGUgZ2l2ZW4gaW5kZXggYW5kIGluc2VydHMgaW50byB0aGUgdmlldyBjYWNoZS4gKi9cbiAgICBfZGV0YWNoQW5kQ2FjaGVWaWV3KGluZGV4LCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIGNvbnN0IGRldGFjaGVkVmlldyA9IHZpZXdDb250YWluZXJSZWYuZGV0YWNoKGluZGV4KTtcbiAgICAgICAgdGhpcy5fbWF5YmVDYWNoZVZpZXcoZGV0YWNoZWRWaWV3LCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgLyoqIE1vdmVzIHZpZXcgYXQgdGhlIHByZXZpb3VzIGluZGV4IHRvIHRoZSBjdXJyZW50IGluZGV4LiAqL1xuICAgIF9tb3ZlVmlldyhhZGp1c3RlZFByZXZpb3VzSW5kZXgsIGN1cnJlbnRJbmRleCwgdmlld0NvbnRhaW5lclJlZiwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHZpZXdDb250YWluZXJSZWYuZ2V0KGFkanVzdGVkUHJldmlvdXNJbmRleCk7XG4gICAgICAgIHZpZXdDb250YWluZXJSZWYubW92ZSh2aWV3LCBjdXJyZW50SW5kZXgpO1xuICAgICAgICB2aWV3LmNvbnRleHQuJGltcGxpY2l0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2aWV3O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGUgZ2l2ZW4gZGV0YWNoZWQgdmlldy4gSWYgdGhlIGNhY2hlIGlzIGZ1bGwsIHRoZSB2aWV3IHdpbGwgYmVcbiAgICAgKiBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgX21heWJlQ2FjaGVWaWV3KHZpZXcsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdDYWNoZS5sZW5ndGggPCB0aGlzLnZpZXdDYWNoZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDYWNoZS5wdXNoKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2aWV3Q29udGFpbmVyUmVmLmluZGV4T2Yodmlldyk7XG4gICAgICAgICAgICAvLyBUaGUgaG9zdCBjb21wb25lbnQgY291bGQgcmVtb3ZlIHZpZXdzIGZyb20gdGhlIGNvbnRhaW5lciBvdXRzaWRlIG9mXG4gICAgICAgICAgICAvLyB0aGUgdmlldyByZXBlYXRlci4gSXQncyB1bmxpa2VseSB0aGlzIHdpbGwgb2NjdXIsIGJ1dCBqdXN0IGluIGNhc2UsXG4gICAgICAgICAgICAvLyBkZXN0cm95IHRoZSB2aWV3IG9uIGl0cyBvd24sIG90aGVyd2lzZSBkZXN0cm95IGl0IHRocm91Z2ggdGhlXG4gICAgICAgICAgICAvLyBjb250YWluZXIgdG8gZW5zdXJlIHRoYXQgYWxsIHRoZSByZWZlcmVuY2VzIGFyZSByZW1vdmVkLlxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlld0NvbnRhaW5lclJlZi5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBJbnNlcnRzIGEgcmVjeWNsZWQgdmlldyBmcm9tIHRoZSBjYWNoZSBhdCB0aGUgZ2l2ZW4gaW5kZXguICovXG4gICAgX2luc2VydFZpZXdGcm9tQ2FjaGUoaW5kZXgsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkVmlldyA9IHRoaXMuX3ZpZXdDYWNoZS5wb3AoKTtcbiAgICAgICAgaWYgKGNhY2hlZFZpZXcpIHtcbiAgICAgICAgICAgIHZpZXdDb250YWluZXJSZWYuaW5zZXJ0KGNhY2hlZFZpZXcsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkVmlldyB8fCBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENsYXNzIHRvIGJlIHVzZWQgdG8gcG93ZXIgc2VsZWN0aW5nIG9uZSBvciBtb3JlIG9wdGlvbnMgZnJvbSBhIGxpc3QuXG4gKi9cbmNsYXNzIFNlbGVjdGlvbk1vZGVsIHtcbiAgICAvKiogU2VsZWN0ZWQgdmFsdWVzLiAqL1xuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBBcnJheS5mcm9tKHRoaXMuX3NlbGVjdGlvbi52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfbXVsdGlwbGUgPSBmYWxzZSwgaW5pdGlhbGx5U2VsZWN0ZWRWYWx1ZXMsIF9lbWl0Q2hhbmdlcyA9IHRydWUsIGNvbXBhcmVXaXRoKSB7XG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gX211bHRpcGxlO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlcyA9IF9lbWl0Q2hhbmdlcztcbiAgICAgICAgdGhpcy5jb21wYXJlV2l0aCA9IGNvbXBhcmVXaXRoO1xuICAgICAgICAvKiogQ3VycmVudGx5LXNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbmV3IFNldCgpO1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2VsZWN0ZWQgb3B0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBlbWl0dGVkIGJ5IHRoZSBjaGFuZ2UgZXZlbnQuICovXG4gICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBzZWxlY3RlZCBvcHRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIGVtaXR0ZWQgYnkgdGhlIGNoYW5nZSBldmVudC4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuICovXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIGlmIChpbml0aWFsbHlTZWxlY3RlZFZhbHVlcyAmJiBpbml0aWFsbHlTZWxlY3RlZFZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChfbXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsbHlTZWxlY3RlZFZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHRoaXMuX21hcmtTZWxlY3RlZCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFya1NlbGVjdGVkKGluaXRpYWxseVNlbGVjdGVkVmFsdWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBhcnJheSBpbiBvcmRlciB0byBhdm9pZCBmaXJpbmcgdGhlIGNoYW5nZSBldmVudCBmb3IgcHJlc2VsZWN0ZWQgdmFsdWVzLlxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRUb0VtaXQubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgdmFsdWUgb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBzZWxlY3RcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgY2FsbFxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgMTYuMC4wIG1ha2UgcmV0dXJuIHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHNlbGVjdCguLi52YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5VmFsdWVBc3NpZ25tZW50KHZhbHVlcyk7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHRoaXMuX21hcmtTZWxlY3RlZCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFzUXVldWVkQ2hhbmdlcygpO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBhIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZGVzZWxlY3RcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgY2FsbFxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgMTYuMC4wIG1ha2UgcmV0dXJuIHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIGRlc2VsZWN0KC4uLnZhbHVlcykge1xuICAgICAgICB0aGlzLl92ZXJpZnlWYWx1ZUFzc2lnbm1lbnQodmFsdWVzKTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4gdGhpcy5fdW5tYXJrU2VsZWN0ZWQodmFsdWUpKTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhc1F1ZXVlZENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZWxlY3RlZCB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzIFRoZSBuZXcgc2VsZWN0ZWQgdmFsdWVzXG4gICAgICogQHJldHVybiBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGNhbGxcbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIDE2LjAuMCBtYWtlIHJldHVybiB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb24oLi4udmFsdWVzKSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeVZhbHVlQXNzaWdubWVudCh2YWx1ZXMpO1xuICAgICAgICBjb25zdCBvbGRWYWx1ZXMgPSB0aGlzLnNlbGVjdGVkO1xuICAgICAgICBjb25zdCBuZXdTZWxlY3RlZFNldCA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4gdGhpcy5fbWFya1NlbGVjdGVkKHZhbHVlKSk7XG4gICAgICAgIG9sZFZhbHVlc1xuICAgICAgICAgICAgLmZpbHRlcih2YWx1ZSA9PiAhbmV3U2VsZWN0ZWRTZXQuaGFzKHZhbHVlKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKHZhbHVlID0+IHRoaXMuX3VubWFya1NlbGVjdGVkKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYXNRdWV1ZWRDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhIHZhbHVlIGJldHdlZW4gc2VsZWN0ZWQgYW5kIGRlc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byB0b2dnbGVcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VkIGFzIGEgcmVzdWx0IG9mIHRoaXMgY2FsbFxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgMTYuMC4wIG1ha2UgcmV0dXJuIHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIHRvZ2dsZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NlbGVjdGVkKHZhbHVlKSA/IHRoaXMuZGVzZWxlY3QodmFsdWUpIDogdGhpcy5zZWxlY3QodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG9mIHRoZSBzZWxlY3RlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIGZsdXNoRXZlbnQgV2hldGhlciB0byBmbHVzaCB0aGUgY2hhbmdlcyBpbiBhbiBldmVudC5cbiAgICAgKiAgIElmIGZhbHNlLCB0aGUgY2hhbmdlcyB0byB0aGUgc2VsZWN0aW9uIHdpbGwgYmUgZmx1c2hlZCBhbG9uZyB3aXRoIHRoZSBuZXh0IGV2ZW50LlxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGUgc2VsZWN0aW9uIGNoYW5nZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBjYWxsXG4gICAgICogQGJyZWFraW5nLWNoYW5nZSAxNi4wLjAgbWFrZSByZXR1cm4gdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgY2xlYXIoZmx1c2hFdmVudCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fdW5tYXJrQWxsKCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYXNRdWV1ZWRDaGFuZ2VzKCk7XG4gICAgICAgIGlmIChmbHVzaEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgdmFsdWUgaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgaXNTZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyh0aGlzLl9nZXRDb25jcmV0ZVZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgbW9kZWwgZG9lcyBub3QgaGF2ZSBhIHZhbHVlLlxuICAgICAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb24uc2l6ZSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtb2RlbCBoYXMgYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBoYXNWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIHNlbGVjdGVkIHZhbHVlcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzb3J0KHByZWRpY2F0ZSkge1xuICAgICAgICBpZiAodGhpcy5fbXVsdGlwbGUgJiYgdGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQuc29ydChwcmVkaWNhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgd2hldGhlciBtdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzTXVsdGlwbGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tdWx0aXBsZTtcbiAgICB9XG4gICAgLyoqIEVtaXRzIGEgY2hhbmdlIGV2ZW50IGFuZCBjbGVhcnMgdGhlIHJlY29yZHMgb2Ygc2VsZWN0ZWQgYW5kIGRlc2VsZWN0ZWQgdmFsdWVzLiAqL1xuICAgIF9lbWl0Q2hhbmdlRXZlbnQoKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBzZWxlY3RlZCB2YWx1ZXMgc28gdGhleSBjYW4gYmUgcmUtY2FjaGVkLlxuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFRvRW1pdC5sZW5ndGggfHwgdGhpcy5fZGVzZWxlY3RlZFRvRW1pdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZC5uZXh0KHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgYWRkZWQ6IHRoaXMuX3NlbGVjdGVkVG9FbWl0LFxuICAgICAgICAgICAgICAgIHJlbW92ZWQ6IHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkVG9FbWl0ID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFNlbGVjdHMgYSB2YWx1ZS4gKi9cbiAgICBfbWFya1NlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0Q29uY3JldGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFya0FsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZFRvRW1pdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRGVzZWxlY3RzIGEgdmFsdWUuICovXG4gICAgX3VubWFya1NlbGVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0Q29uY3JldGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24uZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENsZWFycyBvdXQgdGhlIHNlbGVjdGVkIHZhbHVlcy4gKi9cbiAgICBfdW5tYXJrQWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Rpb24uZm9yRWFjaCh2YWx1ZSA9PiB0aGlzLl91bm1hcmtTZWxlY3RlZCh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIHRoZSB2YWx1ZSBhc3NpZ25tZW50IGFuZCB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBhcnJheSBpc1xuICAgICAqIGluY2x1ZGluZyBtdWx0aXBsZSB2YWx1ZXMgd2hpbGUgdGhlIHNlbGVjdGlvbiBtb2RlbCBpcyBub3Qgc3VwcG9ydGluZyBtdWx0aXBsZSB2YWx1ZXMuXG4gICAgICovXG4gICAgX3ZlcmlmeVZhbHVlQXNzaWdubWVudCh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAxICYmICF0aGlzLl9tdWx0aXBsZSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TXVsdGlwbGVWYWx1ZXNJblNpbmdsZVNlbGVjdGlvbkVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFdoZXRoZXIgdGhlcmUgYXJlIHF1ZXVlZCB1cCBjaGFuZ2UgdG8gYmUgZW1pdHRlZC4gKi9cbiAgICBfaGFzUXVldWVkQ2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2Rlc2VsZWN0ZWRUb0VtaXQubGVuZ3RoIHx8IHRoaXMuX3NlbGVjdGVkVG9FbWl0Lmxlbmd0aCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBpcyBjb21wYXJhYmxlIHRvIGlucHV0VmFsdWUgYnkgYXBwbHlpbmcgY29tcGFyZVdpdGggZnVuY3Rpb24sIHJldHVybnMgdGhlIHNhbWUgaW5wdXRWYWx1ZSBvdGhlcndpc2UuICovXG4gICAgX2dldENvbmNyZXRlVmFsdWUoaW5wdXRWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGFyZVdpdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VsZWN0ZWRWYWx1ZSBvZiB0aGlzLl9zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wYXJlV2l0aChpbnB1dFZhbHVlLCBzZWxlY3RlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0aGF0IHJlcG9ydHMgdGhhdCBtdWx0aXBsZSB2YWx1ZXMgYXJlIHBhc3NlZCBpbnRvIGEgc2VsZWN0aW9uIG1vZGVsXG4gKiB3aXRoIGEgc2luZ2xlIHZhbHVlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRNdWx0aXBsZVZhbHVlc0luU2luZ2xlU2VsZWN0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIEVycm9yKCdDYW5ub3QgcGFzcyBtdWx0aXBsZSB2YWx1ZXMgaW50byBTZWxlY3Rpb25Nb2RlbCB3aXRoIHNpbmdsZS12YWx1ZSBtb2RlLicpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2xhc3MgdG8gY29vcmRpbmF0ZSB1bmlxdWUgc2VsZWN0aW9uIGJhc2VkIG9uIG5hbWUuXG4gKiBJbnRlbmRlZCB0byBiZSBjb25zdW1lZCBhcyBhbiBBbmd1bGFyIHNlcnZpY2UuXG4gKiBUaGlzIHNlcnZpY2UgaXMgbmVlZGVkIGJlY2F1c2UgbmF0aXZlIHJhZGlvIGNoYW5nZSBldmVudHMgYXJlIG9ubHkgZmlyZWQgb24gdGhlIGl0ZW0gY3VycmVudGx5XG4gKiBiZWluZyBzZWxlY3RlZCwgYW5kIHdlIHN0aWxsIG5lZWQgdG8gdW5jaGVjayB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLlxuICpcbiAqIFRoaXMgc2VydmljZSBkb2VzIG5vdCAqc3RvcmUqIGFueSBJRHMgYW5kIG5hbWVzIGJlY2F1c2UgdGhleSBtYXkgY2hhbmdlIGF0IGFueSB0aW1lLCBzbyBpdCBpc1xuICogbGVzcyBlcnJvci1wcm9uZSBpZiB0aGV5IGFyZSBzaW1wbHkgcGFzc2VkIHRocm91Z2ggd2hlbiB0aGUgZXZlbnRzIG9jY3VyLlxuICovXG5jbGFzcyBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSBvdGhlciBpdGVtcyB0aGF0IHNlbGVjdGlvbiBmb3IgdGhlIGdpdmVuIG5hbWUgaGFzIGJlZW4gc2V0LlxuICAgICAqIEBwYXJhbSBpZCBJRCBvZiB0aGUgaXRlbS5cbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBpdGVtLlxuICAgICAqL1xuICAgIG5vdGlmeShpZCwgbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGlkLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGZ1dHVyZSBjaGFuZ2VzIHRvIGl0ZW0gc2VsZWN0aW9uLlxuICAgICAqIEByZXR1cm4gRnVuY3Rpb24gdXNlZCB0byBkZXJlZ2lzdGVyIGxpc3RlbmVyXG4gICAgICovXG4gICAgbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoKHJlZ2lzdGVyZWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIgIT09IHJlZ2lzdGVyZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbn1cblVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlci7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBJbmplY3Rpb24gdG9rZW4gZm9yIHtAbGluayBfVmlld1JlcGVhdGVyfS4gVGhpcyB0b2tlbiBpcyBmb3IgdXNlIGJ5IEFuZ3VsYXIgTWF0ZXJpYWwgb25seS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY29uc3QgX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1kgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ19WaWV3UmVwZWF0ZXInKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEFycmF5RGF0YVNvdXJjZSwgRGF0YVNvdXJjZSwgU2VsZWN0aW9uTW9kZWwsIFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIsIF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3ksIF9SZWN5Y2xlVmlld1JlcGVhdGVyU3RyYXRlZ3ksIF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCBnZXRNdWx0aXBsZVZhbHVlc0luU2luZ2xlU2VsZWN0aW9uRXJyb3IsIGlzRGF0YVNvdXJjZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/collections.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/keycodes.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/keycodes.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"A\": function() { return /* binding */ A; },\n/* harmony export */   \"ALT\": function() { return /* binding */ ALT; },\n/* harmony export */   \"APOSTROPHE\": function() { return /* binding */ APOSTROPHE; },\n/* harmony export */   \"AT_SIGN\": function() { return /* binding */ AT_SIGN; },\n/* harmony export */   \"B\": function() { return /* binding */ B; },\n/* harmony export */   \"BACKSLASH\": function() { return /* binding */ BACKSLASH; },\n/* harmony export */   \"BACKSPACE\": function() { return /* binding */ BACKSPACE; },\n/* harmony export */   \"C\": function() { return /* binding */ C; },\n/* harmony export */   \"CAPS_LOCK\": function() { return /* binding */ CAPS_LOCK; },\n/* harmony export */   \"CLOSE_SQUARE_BRACKET\": function() { return /* binding */ CLOSE_SQUARE_BRACKET; },\n/* harmony export */   \"COMMA\": function() { return /* binding */ COMMA; },\n/* harmony export */   \"CONTEXT_MENU\": function() { return /* binding */ CONTEXT_MENU; },\n/* harmony export */   \"CONTROL\": function() { return /* binding */ CONTROL; },\n/* harmony export */   \"D\": function() { return /* binding */ D; },\n/* harmony export */   \"DASH\": function() { return /* binding */ DASH; },\n/* harmony export */   \"DELETE\": function() { return /* binding */ DELETE; },\n/* harmony export */   \"DOWN_ARROW\": function() { return /* binding */ DOWN_ARROW; },\n/* harmony export */   \"E\": function() { return /* binding */ E; },\n/* harmony export */   \"EIGHT\": function() { return /* binding */ EIGHT; },\n/* harmony export */   \"END\": function() { return /* binding */ END; },\n/* harmony export */   \"ENTER\": function() { return /* binding */ ENTER; },\n/* harmony export */   \"EQUALS\": function() { return /* binding */ EQUALS; },\n/* harmony export */   \"ESCAPE\": function() { return /* binding */ ESCAPE; },\n/* harmony export */   \"F\": function() { return /* binding */ F; },\n/* harmony export */   \"F1\": function() { return /* binding */ F1; },\n/* harmony export */   \"F10\": function() { return /* binding */ F10; },\n/* harmony export */   \"F11\": function() { return /* binding */ F11; },\n/* harmony export */   \"F12\": function() { return /* binding */ F12; },\n/* harmony export */   \"F2\": function() { return /* binding */ F2; },\n/* harmony export */   \"F3\": function() { return /* binding */ F3; },\n/* harmony export */   \"F4\": function() { return /* binding */ F4; },\n/* harmony export */   \"F5\": function() { return /* binding */ F5; },\n/* harmony export */   \"F6\": function() { return /* binding */ F6; },\n/* harmony export */   \"F7\": function() { return /* binding */ F7; },\n/* harmony export */   \"F8\": function() { return /* binding */ F8; },\n/* harmony export */   \"F9\": function() { return /* binding */ F9; },\n/* harmony export */   \"FF_EQUALS\": function() { return /* binding */ FF_EQUALS; },\n/* harmony export */   \"FF_MINUS\": function() { return /* binding */ FF_MINUS; },\n/* harmony export */   \"FF_MUTE\": function() { return /* binding */ FF_MUTE; },\n/* harmony export */   \"FF_SEMICOLON\": function() { return /* binding */ FF_SEMICOLON; },\n/* harmony export */   \"FF_VOLUME_DOWN\": function() { return /* binding */ FF_VOLUME_DOWN; },\n/* harmony export */   \"FF_VOLUME_UP\": function() { return /* binding */ FF_VOLUME_UP; },\n/* harmony export */   \"FIRST_MEDIA\": function() { return /* binding */ FIRST_MEDIA; },\n/* harmony export */   \"FIVE\": function() { return /* binding */ FIVE; },\n/* harmony export */   \"FOUR\": function() { return /* binding */ FOUR; },\n/* harmony export */   \"G\": function() { return /* binding */ G; },\n/* harmony export */   \"H\": function() { return /* binding */ H; },\n/* harmony export */   \"HOME\": function() { return /* binding */ HOME; },\n/* harmony export */   \"I\": function() { return /* binding */ I; },\n/* harmony export */   \"INSERT\": function() { return /* binding */ INSERT; },\n/* harmony export */   \"J\": function() { return /* binding */ J; },\n/* harmony export */   \"K\": function() { return /* binding */ K; },\n/* harmony export */   \"L\": function() { return /* binding */ L; },\n/* harmony export */   \"LAST_MEDIA\": function() { return /* binding */ LAST_MEDIA; },\n/* harmony export */   \"LEFT_ARROW\": function() { return /* binding */ LEFT_ARROW; },\n/* harmony export */   \"M\": function() { return /* binding */ M; },\n/* harmony export */   \"MAC_ENTER\": function() { return /* binding */ MAC_ENTER; },\n/* harmony export */   \"MAC_META\": function() { return /* binding */ MAC_META; },\n/* harmony export */   \"MAC_WK_CMD_LEFT\": function() { return /* binding */ MAC_WK_CMD_LEFT; },\n/* harmony export */   \"MAC_WK_CMD_RIGHT\": function() { return /* binding */ MAC_WK_CMD_RIGHT; },\n/* harmony export */   \"META\": function() { return /* binding */ META; },\n/* harmony export */   \"MUTE\": function() { return /* binding */ MUTE; },\n/* harmony export */   \"N\": function() { return /* binding */ N; },\n/* harmony export */   \"NINE\": function() { return /* binding */ NINE; },\n/* harmony export */   \"NUMPAD_DIVIDE\": function() { return /* binding */ NUMPAD_DIVIDE; },\n/* harmony export */   \"NUMPAD_EIGHT\": function() { return /* binding */ NUMPAD_EIGHT; },\n/* harmony export */   \"NUMPAD_FIVE\": function() { return /* binding */ NUMPAD_FIVE; },\n/* harmony export */   \"NUMPAD_FOUR\": function() { return /* binding */ NUMPAD_FOUR; },\n/* harmony export */   \"NUMPAD_MINUS\": function() { return /* binding */ NUMPAD_MINUS; },\n/* harmony export */   \"NUMPAD_MULTIPLY\": function() { return /* binding */ NUMPAD_MULTIPLY; },\n/* harmony export */   \"NUMPAD_NINE\": function() { return /* binding */ NUMPAD_NINE; },\n/* harmony export */   \"NUMPAD_ONE\": function() { return /* binding */ NUMPAD_ONE; },\n/* harmony export */   \"NUMPAD_PERIOD\": function() { return /* binding */ NUMPAD_PERIOD; },\n/* harmony export */   \"NUMPAD_PLUS\": function() { return /* binding */ NUMPAD_PLUS; },\n/* harmony export */   \"NUMPAD_SEVEN\": function() { return /* binding */ NUMPAD_SEVEN; },\n/* harmony export */   \"NUMPAD_SIX\": function() { return /* binding */ NUMPAD_SIX; },\n/* harmony export */   \"NUMPAD_THREE\": function() { return /* binding */ NUMPAD_THREE; },\n/* harmony export */   \"NUMPAD_TWO\": function() { return /* binding */ NUMPAD_TWO; },\n/* harmony export */   \"NUMPAD_ZERO\": function() { return /* binding */ NUMPAD_ZERO; },\n/* harmony export */   \"NUM_CENTER\": function() { return /* binding */ NUM_CENTER; },\n/* harmony export */   \"NUM_LOCK\": function() { return /* binding */ NUM_LOCK; },\n/* harmony export */   \"O\": function() { return /* binding */ O; },\n/* harmony export */   \"ONE\": function() { return /* binding */ ONE; },\n/* harmony export */   \"OPEN_SQUARE_BRACKET\": function() { return /* binding */ OPEN_SQUARE_BRACKET; },\n/* harmony export */   \"P\": function() { return /* binding */ P; },\n/* harmony export */   \"PAGE_DOWN\": function() { return /* binding */ PAGE_DOWN; },\n/* harmony export */   \"PAGE_UP\": function() { return /* binding */ PAGE_UP; },\n/* harmony export */   \"PAUSE\": function() { return /* binding */ PAUSE; },\n/* harmony export */   \"PERIOD\": function() { return /* binding */ PERIOD; },\n/* harmony export */   \"PLUS_SIGN\": function() { return /* binding */ PLUS_SIGN; },\n/* harmony export */   \"PRINT_SCREEN\": function() { return /* binding */ PRINT_SCREEN; },\n/* harmony export */   \"Q\": function() { return /* binding */ Q; },\n/* harmony export */   \"QUESTION_MARK\": function() { return /* binding */ QUESTION_MARK; },\n/* harmony export */   \"R\": function() { return /* binding */ R; },\n/* harmony export */   \"RIGHT_ARROW\": function() { return /* binding */ RIGHT_ARROW; },\n/* harmony export */   \"S\": function() { return /* binding */ S; },\n/* harmony export */   \"SCROLL_LOCK\": function() { return /* binding */ SCROLL_LOCK; },\n/* harmony export */   \"SEMICOLON\": function() { return /* binding */ SEMICOLON; },\n/* harmony export */   \"SEVEN\": function() { return /* binding */ SEVEN; },\n/* harmony export */   \"SHIFT\": function() { return /* binding */ SHIFT; },\n/* harmony export */   \"SINGLE_QUOTE\": function() { return /* binding */ SINGLE_QUOTE; },\n/* harmony export */   \"SIX\": function() { return /* binding */ SIX; },\n/* harmony export */   \"SLASH\": function() { return /* binding */ SLASH; },\n/* harmony export */   \"SPACE\": function() { return /* binding */ SPACE; },\n/* harmony export */   \"T\": function() { return /* binding */ T; },\n/* harmony export */   \"TAB\": function() { return /* binding */ TAB; },\n/* harmony export */   \"THREE\": function() { return /* binding */ THREE; },\n/* harmony export */   \"TILDE\": function() { return /* binding */ TILDE; },\n/* harmony export */   \"TWO\": function() { return /* binding */ TWO; },\n/* harmony export */   \"U\": function() { return /* binding */ U; },\n/* harmony export */   \"UP_ARROW\": function() { return /* binding */ UP_ARROW; },\n/* harmony export */   \"V\": function() { return /* binding */ V; },\n/* harmony export */   \"VOLUME_DOWN\": function() { return /* binding */ VOLUME_DOWN; },\n/* harmony export */   \"VOLUME_UP\": function() { return /* binding */ VOLUME_UP; },\n/* harmony export */   \"W\": function() { return /* binding */ W; },\n/* harmony export */   \"X\": function() { return /* binding */ X; },\n/* harmony export */   \"Y\": function() { return /* binding */ Y; },\n/* harmony export */   \"Z\": function() { return /* binding */ Z; },\n/* harmony export */   \"ZERO\": function() { return /* binding */ ZERO; },\n/* harmony export */   \"hasModifierKey\": function() { return /* binding */ hasModifierKey; }\n/* harmony export */ });\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst PERIOD = 190;\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=keycodes.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2tleWNvZGVzLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2tleWNvZGVzLm1qcz82Y2FjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgTUFDX0VOVEVSID0gMztcbmNvbnN0IEJBQ0tTUEFDRSA9IDg7XG5jb25zdCBUQUIgPSA5O1xuY29uc3QgTlVNX0NFTlRFUiA9IDEyO1xuY29uc3QgRU5URVIgPSAxMztcbmNvbnN0IFNISUZUID0gMTY7XG5jb25zdCBDT05UUk9MID0gMTc7XG5jb25zdCBBTFQgPSAxODtcbmNvbnN0IFBBVVNFID0gMTk7XG5jb25zdCBDQVBTX0xPQ0sgPSAyMDtcbmNvbnN0IEVTQ0FQRSA9IDI3O1xuY29uc3QgU1BBQ0UgPSAzMjtcbmNvbnN0IFBBR0VfVVAgPSAzMztcbmNvbnN0IFBBR0VfRE9XTiA9IDM0O1xuY29uc3QgRU5EID0gMzU7XG5jb25zdCBIT01FID0gMzY7XG5jb25zdCBMRUZUX0FSUk9XID0gMzc7XG5jb25zdCBVUF9BUlJPVyA9IDM4O1xuY29uc3QgUklHSFRfQVJST1cgPSAzOTtcbmNvbnN0IERPV05fQVJST1cgPSA0MDtcbmNvbnN0IFBMVVNfU0lHTiA9IDQzO1xuY29uc3QgUFJJTlRfU0NSRUVOID0gNDQ7XG5jb25zdCBJTlNFUlQgPSA0NTtcbmNvbnN0IERFTEVURSA9IDQ2O1xuY29uc3QgWkVSTyA9IDQ4O1xuY29uc3QgT05FID0gNDk7XG5jb25zdCBUV08gPSA1MDtcbmNvbnN0IFRIUkVFID0gNTE7XG5jb25zdCBGT1VSID0gNTI7XG5jb25zdCBGSVZFID0gNTM7XG5jb25zdCBTSVggPSA1NDtcbmNvbnN0IFNFVkVOID0gNTU7XG5jb25zdCBFSUdIVCA9IDU2O1xuY29uc3QgTklORSA9IDU3O1xuY29uc3QgRkZfU0VNSUNPTE9OID0gNTk7IC8vIEZpcmVmb3ggKEdlY2tvKSBmaXJlcyB0aGlzIGZvciBzZW1pY29sb24gaW5zdGVhZCBvZiAxODZcbmNvbnN0IEZGX0VRVUFMUyA9IDYxOyAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgdGhpcyBmb3IgZXF1YWxzIGluc3RlYWQgb2YgMTg3XG5jb25zdCBRVUVTVElPTl9NQVJLID0gNjM7XG5jb25zdCBBVF9TSUdOID0gNjQ7XG5jb25zdCBBID0gNjU7XG5jb25zdCBCID0gNjY7XG5jb25zdCBDID0gNjc7XG5jb25zdCBEID0gNjg7XG5jb25zdCBFID0gNjk7XG5jb25zdCBGID0gNzA7XG5jb25zdCBHID0gNzE7XG5jb25zdCBIID0gNzI7XG5jb25zdCBJID0gNzM7XG5jb25zdCBKID0gNzQ7XG5jb25zdCBLID0gNzU7XG5jb25zdCBMID0gNzY7XG5jb25zdCBNID0gNzc7XG5jb25zdCBOID0gNzg7XG5jb25zdCBPID0gNzk7XG5jb25zdCBQID0gODA7XG5jb25zdCBRID0gODE7XG5jb25zdCBSID0gODI7XG5jb25zdCBTID0gODM7XG5jb25zdCBUID0gODQ7XG5jb25zdCBVID0gODU7XG5jb25zdCBWID0gODY7XG5jb25zdCBXID0gODc7XG5jb25zdCBYID0gODg7XG5jb25zdCBZID0gODk7XG5jb25zdCBaID0gOTA7XG5jb25zdCBNRVRBID0gOTE7IC8vIFdJTl9LRVlfTEVGVFxuY29uc3QgTUFDX1dLX0NNRF9MRUZUID0gOTE7XG5jb25zdCBNQUNfV0tfQ01EX1JJR0hUID0gOTM7XG5jb25zdCBDT05URVhUX01FTlUgPSA5MztcbmNvbnN0IE5VTVBBRF9aRVJPID0gOTY7XG5jb25zdCBOVU1QQURfT05FID0gOTc7XG5jb25zdCBOVU1QQURfVFdPID0gOTg7XG5jb25zdCBOVU1QQURfVEhSRUUgPSA5OTtcbmNvbnN0IE5VTVBBRF9GT1VSID0gMTAwO1xuY29uc3QgTlVNUEFEX0ZJVkUgPSAxMDE7XG5jb25zdCBOVU1QQURfU0lYID0gMTAyO1xuY29uc3QgTlVNUEFEX1NFVkVOID0gMTAzO1xuY29uc3QgTlVNUEFEX0VJR0hUID0gMTA0O1xuY29uc3QgTlVNUEFEX05JTkUgPSAxMDU7XG5jb25zdCBOVU1QQURfTVVMVElQTFkgPSAxMDY7XG5jb25zdCBOVU1QQURfUExVUyA9IDEwNztcbmNvbnN0IE5VTVBBRF9NSU5VUyA9IDEwOTtcbmNvbnN0IE5VTVBBRF9QRVJJT0QgPSAxMTA7XG5jb25zdCBOVU1QQURfRElWSURFID0gMTExO1xuY29uc3QgRjEgPSAxMTI7XG5jb25zdCBGMiA9IDExMztcbmNvbnN0IEYzID0gMTE0O1xuY29uc3QgRjQgPSAxMTU7XG5jb25zdCBGNSA9IDExNjtcbmNvbnN0IEY2ID0gMTE3O1xuY29uc3QgRjcgPSAxMTg7XG5jb25zdCBGOCA9IDExOTtcbmNvbnN0IEY5ID0gMTIwO1xuY29uc3QgRjEwID0gMTIxO1xuY29uc3QgRjExID0gMTIyO1xuY29uc3QgRjEyID0gMTIzO1xuY29uc3QgTlVNX0xPQ0sgPSAxNDQ7XG5jb25zdCBTQ1JPTExfTE9DSyA9IDE0NTtcbmNvbnN0IEZJUlNUX01FRElBID0gMTY2O1xuY29uc3QgRkZfTUlOVVMgPSAxNzM7XG5jb25zdCBNVVRFID0gMTczOyAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgMTgxIGZvciBNVVRFXG5jb25zdCBWT0xVTUVfRE9XTiA9IDE3NDsgLy8gRmlyZWZveCAoR2Vja28pIGZpcmVzIDE4MiBmb3IgVk9MVU1FX0RPV05cbmNvbnN0IFZPTFVNRV9VUCA9IDE3NTsgLy8gRmlyZWZveCAoR2Vja28pIGZpcmVzIDE4MyBmb3IgVk9MVU1FX1VQXG5jb25zdCBGRl9NVVRFID0gMTgxO1xuY29uc3QgRkZfVk9MVU1FX0RPV04gPSAxODI7XG5jb25zdCBMQVNUX01FRElBID0gMTgzO1xuY29uc3QgRkZfVk9MVU1FX1VQID0gMTgzO1xuY29uc3QgU0VNSUNPTE9OID0gMTg2OyAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgNTkgZm9yIFNFTUlDT0xPTlxuY29uc3QgRVFVQUxTID0gMTg3OyAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgNjEgZm9yIEVRVUFMU1xuY29uc3QgQ09NTUEgPSAxODg7XG5jb25zdCBEQVNIID0gMTg5OyAvLyBGaXJlZm94IChHZWNrbykgZmlyZXMgMTczIGZvciBEQVNIL01JTlVTXG5jb25zdCBQRVJJT0QgPSAxOTA7XG5jb25zdCBTTEFTSCA9IDE5MTtcbmNvbnN0IEFQT1NUUk9QSEUgPSAxOTI7XG5jb25zdCBUSUxERSA9IDE5MjtcbmNvbnN0IE9QRU5fU1FVQVJFX0JSQUNLRVQgPSAyMTk7XG5jb25zdCBCQUNLU0xBU0ggPSAyMjA7XG5jb25zdCBDTE9TRV9TUVVBUkVfQlJBQ0tFVCA9IDIyMTtcbmNvbnN0IFNJTkdMRV9RVU9URSA9IDIyMjtcbmNvbnN0IE1BQ19NRVRBID0gMjI0O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBtb2RpZmllciBrZXkgaXMgcHJlc3NlZC5cbiAqIEBwYXJhbSBldmVudCBFdmVudCB0byBiZSBjaGVja2VkLlxuICovXG5mdW5jdGlvbiBoYXNNb2RpZmllcktleShldmVudCwgLi4ubW9kaWZpZXJzKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5zb21lKG1vZGlmaWVyID0+IGV2ZW50W21vZGlmaWVyXSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQSwgQUxULCBBUE9TVFJPUEhFLCBBVF9TSUdOLCBCLCBCQUNLU0xBU0gsIEJBQ0tTUEFDRSwgQywgQ0FQU19MT0NLLCBDTE9TRV9TUVVBUkVfQlJBQ0tFVCwgQ09NTUEsIENPTlRFWFRfTUVOVSwgQ09OVFJPTCwgRCwgREFTSCwgREVMRVRFLCBET1dOX0FSUk9XLCBFLCBFSUdIVCwgRU5ELCBFTlRFUiwgRVFVQUxTLCBFU0NBUEUsIEYsIEYxLCBGMTAsIEYxMSwgRjEyLCBGMiwgRjMsIEY0LCBGNSwgRjYsIEY3LCBGOCwgRjksIEZGX0VRVUFMUywgRkZfTUlOVVMsIEZGX01VVEUsIEZGX1NFTUlDT0xPTiwgRkZfVk9MVU1FX0RPV04sIEZGX1ZPTFVNRV9VUCwgRklSU1RfTUVESUEsIEZJVkUsIEZPVVIsIEcsIEgsIEhPTUUsIEksIElOU0VSVCwgSiwgSywgTCwgTEFTVF9NRURJQSwgTEVGVF9BUlJPVywgTSwgTUFDX0VOVEVSLCBNQUNfTUVUQSwgTUFDX1dLX0NNRF9MRUZULCBNQUNfV0tfQ01EX1JJR0hULCBNRVRBLCBNVVRFLCBOLCBOSU5FLCBOVU1QQURfRElWSURFLCBOVU1QQURfRUlHSFQsIE5VTVBBRF9GSVZFLCBOVU1QQURfRk9VUiwgTlVNUEFEX01JTlVTLCBOVU1QQURfTVVMVElQTFksIE5VTVBBRF9OSU5FLCBOVU1QQURfT05FLCBOVU1QQURfUEVSSU9ELCBOVU1QQURfUExVUywgTlVNUEFEX1NFVkVOLCBOVU1QQURfU0lYLCBOVU1QQURfVEhSRUUsIE5VTVBBRF9UV08sIE5VTVBBRF9aRVJPLCBOVU1fQ0VOVEVSLCBOVU1fTE9DSywgTywgT05FLCBPUEVOX1NRVUFSRV9CUkFDS0VULCBQLCBQQUdFX0RPV04sIFBBR0VfVVAsIFBBVVNFLCBQRVJJT0QsIFBMVVNfU0lHTiwgUFJJTlRfU0NSRUVOLCBRLCBRVUVTVElPTl9NQVJLLCBSLCBSSUdIVF9BUlJPVywgUywgU0NST0xMX0xPQ0ssIFNFTUlDT0xPTiwgU0VWRU4sIFNISUZULCBTSU5HTEVfUVVPVEUsIFNJWCwgU0xBU0gsIFNQQUNFLCBULCBUQUIsIFRIUkVFLCBUSUxERSwgVFdPLCBVLCBVUF9BUlJPVywgViwgVk9MVU1FX0RPV04sIFZPTFVNRV9VUCwgVywgWCwgWSwgWiwgWkVSTywgaGFzTW9kaWZpZXJLZXkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleWNvZGVzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/keycodes.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/layout.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/layout.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BreakpointObserver\": function() { return /* binding */ BreakpointObserver; },\n/* harmony export */   \"Breakpoints\": function() { return /* binding */ Breakpoints; },\n/* harmony export */   \"LayoutModule\": function() { return /* binding */ LayoutModule; },\n/* harmony export */   \"MediaMatcher\": function() { return /* binding */ MediaMatcher; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/fesm2020/platform.mjs\");\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass LayoutModule {\n}\nLayoutModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: LayoutModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nLayoutModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: LayoutModule });\nLayoutModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: LayoutModule });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: LayoutModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{}]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility = new Set();\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode;\n/** A utility for calling matchMedia queries. */\nclass MediaMatcher {\n    constructor(_platform) {\n        this._platform = _platform;\n        this._matchMedia =\n            this._platform.isBrowser && window.matchMedia\n                ? // matchMedia is bound to the window scope intentionally as it is an illegal invocation to\n                    // call it from a different scope.\n                    window.matchMedia.bind(window)\n                : noopMatchMedia;\n    }\n    /**\n     * Evaluates the given media query and returns the native MediaQueryList from which results\n     * can be retrieved.\n     * Confirms the layout engine will trigger for the selector query provided and returns the\n     * MediaQueryList for the query provided.\n     */\n    matchMedia(query) {\n        if (this._platform.WEBKIT || this._platform.BLINK) {\n            createEmptyStyleRule(query);\n        }\n        return this._matchMedia(query);\n    }\n}\nMediaMatcher.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MediaMatcher, deps: [{ token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__.Platform }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nMediaMatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MediaMatcher, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MediaMatcher, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_3__.Platform }]; } });\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query) {\n    if (mediaQueriesForWebkitCompatibility.has(query)) {\n        return;\n    }\n    try {\n        if (!mediaQueryStyleNode) {\n            mediaQueryStyleNode = document.createElement('style');\n            mediaQueryStyleNode.setAttribute('type', 'text/css');\n            document.head.appendChild(mediaQueryStyleNode);\n        }\n        if (mediaQueryStyleNode.sheet) {\n            mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n            mediaQueriesForWebkitCompatibility.add(query);\n        }\n    }\n    catch (e) {\n        console.error(e);\n    }\n}\n/** No-op matchMedia replacement for non-browser platforms. */\nfunction noopMatchMedia(query) {\n    // Use `as any` here to avoid adding additional necessary properties for\n    // the noop matcher.\n    return {\n        matches: query === 'all' || query === '',\n        media: query,\n        addListener: () => { },\n        removeListener: () => { },\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Utility for checking the matching state of @media queries. */\nclass BreakpointObserver {\n    constructor(_mediaMatcher, _zone) {\n        this._mediaMatcher = _mediaMatcher;\n        this._zone = _zone;\n        /**  A map of all media queries currently being listened for. */\n        this._queries = new Map();\n        /** A subject for all other observables to takeUntil based on. */\n        this._destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n    }\n    /** Completes the active subject, signalling to all other observables to complete. */\n    ngOnDestroy() {\n        this._destroySubject.next();\n        this._destroySubject.complete();\n    }\n    /**\n     * Whether one or more media queries match the current viewport size.\n     * @param value One or more media queries to check.\n     * @returns Whether any of the media queries match.\n     */\n    isMatched(value) {\n        const queries = splitQueries((0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceArray)(value));\n        return queries.some(mediaQuery => this._registerQuery(mediaQuery).mql.matches);\n    }\n    /**\n     * Gets an observable of results for the given queries that will emit new results for any changes\n     * in matching of the given queries.\n     * @param value One or more media queries to check.\n     * @returns A stream of matches for the given queries.\n     */\n    observe(value) {\n        const queries = splitQueries((0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceArray)(value));\n        const observables = queries.map(query => this._registerQuery(query).observable);\n        let stateObservable = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.combineLatest)(observables);\n        // Emit the first state immediately, and then debounce the subsequent emissions.\n        stateObservable = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.concat)(stateObservable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.take)(1)), stateObservable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.skip)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.debounceTime)(0)));\n        return stateObservable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(breakpointStates => {\n            const response = {\n                matches: false,\n                breakpoints: {},\n            };\n            breakpointStates.forEach(({ matches, query }) => {\n                response.matches = response.matches || matches;\n                response.breakpoints[query] = matches;\n            });\n            return response;\n        }));\n    }\n    /** Registers a specific query to be listened for. */\n    _registerQuery(query) {\n        // Only set up a new MediaQueryList if it is not already being listened for.\n        if (this._queries.has(query)) {\n            return this._queries.get(query);\n        }\n        const mql = this._mediaMatcher.matchMedia(query);\n        // Create callback for match changes and add it is as a listener.\n        const queryObservable = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => {\n            // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed\n            // back into the zone because matchMedia is only included in Zone.js by loading the\n            // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not\n            // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js\n            // patches it.\n            const handler = (e) => this._zone.run(() => observer.next(e));\n            mql.addListener(handler);\n            return () => {\n                mql.removeListener(handler);\n            };\n        }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.startWith)(mql), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(({ matches }) => ({ query, matches })), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._destroySubject));\n        // Add the MediaQueryList to the set of queries.\n        const output = { observable: queryObservable, mql };\n        this._queries.set(query, output);\n        return output;\n    }\n}\nBreakpointObserver.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BreakpointObserver, deps: [{ token: MediaMatcher }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nBreakpointObserver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BreakpointObserver, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BreakpointObserver, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: MediaMatcher }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }]; } });\n/**\n * Split each query string into separate query strings if two queries are provided as comma\n * separated.\n */\nfunction splitQueries(queries) {\n    return queries\n        .map(query => query.split(','))\n        .reduce((a1, a2) => a1.concat(a2))\n        .map(query => query.trim());\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// PascalCase is being used as Breakpoints is used like an enum.\n// tslint:disable-next-line:variable-name\nconst Breakpoints = {\n    XSmall: '(max-width: 599.98px)',\n    Small: '(min-width: 600px) and (max-width: 959.98px)',\n    Medium: '(min-width: 960px) and (max-width: 1279.98px)',\n    Large: '(min-width: 1280px) and (max-width: 1919.98px)',\n    XLarge: '(min-width: 1920px)',\n    Handset: '(max-width: 599.98px) and (orientation: portrait), ' +\n        '(max-width: 959.98px) and (orientation: landscape)',\n    Tablet: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), ' +\n        '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',\n    Web: '(min-width: 840px) and (orientation: portrait), ' +\n        '(min-width: 1280px) and (orientation: landscape)',\n    HandsetPortrait: '(max-width: 599.98px) and (orientation: portrait)',\n    TabletPortrait: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)',\n    WebPortrait: '(min-width: 840px) and (orientation: portrait)',\n    HandsetLandscape: '(max-width: 959.98px) and (orientation: landscape)',\n    TabletLandscape: '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',\n    WebLandscape: '(min-width: 1280px) and (orientation: landscape)',\n};\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=layout.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL2xheW91dC5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZmVzbTIwMjAvbGF5b3V0Lm1qcz80ZWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdNb2R1bGUsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNvZXJjZUFycmF5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IFN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIGNvbmNhdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZSwgc2tpcCwgZGVib3VuY2VUaW1lLCBtYXAsIHN0YXJ0V2l0aCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jbGFzcyBMYXlvdXRNb2R1bGUge1xufVxuTGF5b3V0TW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTGF5b3V0TW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkxheW91dE1vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBMYXlvdXRNb2R1bGUgfSk7XG5MYXlvdXRNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTGF5b3V0TW9kdWxlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTGF5b3V0TW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe31dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBHbG9iYWwgcmVnaXN0cnkgZm9yIGFsbCBkeW5hbWljYWxseS1jcmVhdGVkLCBpbmplY3RlZCBtZWRpYSBxdWVyaWVzLiAqL1xuY29uc3QgbWVkaWFRdWVyaWVzRm9yV2Via2l0Q29tcGF0aWJpbGl0eSA9IG5ldyBTZXQoKTtcbi8qKiBTdHlsZSB0YWcgdGhhdCBob2xkcyBhbGwgb2YgdGhlIGR5bmFtaWNhbGx5LWNyZWF0ZWQgbWVkaWEgcXVlcmllcy4gKi9cbmxldCBtZWRpYVF1ZXJ5U3R5bGVOb2RlO1xuLyoqIEEgdXRpbGl0eSBmb3IgY2FsbGluZyBtYXRjaE1lZGlhIHF1ZXJpZXMuICovXG5jbGFzcyBNZWRpYU1hdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKF9wbGF0Zm9ybSkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5fbWF0Y2hNZWRpYSA9XG4gICAgICAgICAgICB0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIgJiYgd2luZG93Lm1hdGNoTWVkaWFcbiAgICAgICAgICAgICAgICA/IC8vIG1hdGNoTWVkaWEgaXMgYm91bmQgdG8gdGhlIHdpbmRvdyBzY29wZSBpbnRlbnRpb25hbGx5IGFzIGl0IGlzIGFuIGlsbGVnYWwgaW52b2NhdGlvbiB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGl0IGZyb20gYSBkaWZmZXJlbnQgc2NvcGUuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhLmJpbmQod2luZG93KVxuICAgICAgICAgICAgICAgIDogbm9vcE1hdGNoTWVkaWE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gbWVkaWEgcXVlcnkgYW5kIHJldHVybnMgdGhlIG5hdGl2ZSBNZWRpYVF1ZXJ5TGlzdCBmcm9tIHdoaWNoIHJlc3VsdHNcbiAgICAgKiBjYW4gYmUgcmV0cmlldmVkLlxuICAgICAqIENvbmZpcm1zIHRoZSBsYXlvdXQgZW5naW5lIHdpbGwgdHJpZ2dlciBmb3IgdGhlIHNlbGVjdG9yIHF1ZXJ5IHByb3ZpZGVkIGFuZCByZXR1cm5zIHRoZVxuICAgICAqIE1lZGlhUXVlcnlMaXN0IGZvciB0aGUgcXVlcnkgcHJvdmlkZWQuXG4gICAgICovXG4gICAgbWF0Y2hNZWRpYShxdWVyeSkge1xuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0uV0VCS0lUIHx8IHRoaXMuX3BsYXRmb3JtLkJMSU5LKSB7XG4gICAgICAgICAgICBjcmVhdGVFbXB0eVN0eWxlUnVsZShxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGNoTWVkaWEocXVlcnkpO1xuICAgIH1cbn1cbk1lZGlhTWF0Y2hlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1lZGlhTWF0Y2hlciwgZGVwczogW3sgdG9rZW46IGkxLlBsYXRmb3JtIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5NZWRpYU1hdGNoZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWVkaWFNYXRjaGVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNZWRpYU1hdGNoZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTEuUGxhdGZvcm0gfV07IH0gfSk7XG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgc3R5bGVzaGVldCB0aGF0IGlzIHVzZWQgdG8gd29yayBhcm91bmQgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgcmVsYXRlZCB0b1xuICogYG1hdGNoTWVkaWFgLiBBdCB0aGUgdGltZSBvZiB3cml0aW5nLCBpdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gKiAxLiBPbiBXZWJLaXQgYnJvd3NlcnMsIGEgbWVkaWEgcXVlcnkgaGFzIHRvIGhhdmUgYXQgbGVhc3Qgb25lIHJ1bGUgaW4gb3JkZXIgZm9yIGBtYXRjaE1lZGlhYFxuICogdG8gZmlyZS4gV2Ugd29yayBhcm91bmQgaXQgYnkgZGVjbGFyaW5nIGEgZHVtbXkgc3R5bGVzaGVldCB3aXRoIGEgYEBtZWRpYWAgZGVjbGFyYXRpb24uXG4gKiAyLiBJbiBzb21lIGNhc2VzIEJsaW5rIGJyb3dzZXJzIHdpbGwgc3RvcCBmaXJpbmcgdGhlIGBtYXRjaE1lZGlhYCBsaXN0ZW5lciBpZiBub25lIG9mIHRoZSBydWxlc1xuICogaW5zaWRlIHRoZSBgQG1lZGlhYCBtYXRjaCBleGlzdGluZyBlbGVtZW50cyBvbiB0aGUgcGFnZS4gV2Ugd29yayBhcm91bmQgaXQgYnkgaGF2aW5nIG9uZSBydWxlXG4gKiB0YXJnZXRpbmcgdGhlIGBib2R5YC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzIzNTQ2LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVN0eWxlUnVsZShxdWVyeSkge1xuICAgIGlmIChtZWRpYVF1ZXJpZXNGb3JXZWJraXRDb21wYXRpYmlsaXR5LmhhcyhxdWVyeSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAoIW1lZGlhUXVlcnlTdHlsZU5vZGUpIHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnlTdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgbWVkaWFRdWVyeVN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWVkaWFRdWVyeVN0eWxlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhUXVlcnlTdHlsZU5vZGUuc2hlZXQpIHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnlTdHlsZU5vZGUuc2hlZXQuaW5zZXJ0UnVsZShgQG1lZGlhICR7cXVlcnl9IHtib2R5eyB9fWAsIDApO1xuICAgICAgICAgICAgbWVkaWFRdWVyaWVzRm9yV2Via2l0Q29tcGF0aWJpbGl0eS5hZGQocXVlcnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxufVxuLyoqIE5vLW9wIG1hdGNoTWVkaWEgcmVwbGFjZW1lbnQgZm9yIG5vbi1icm93c2VyIHBsYXRmb3Jtcy4gKi9cbmZ1bmN0aW9uIG5vb3BNYXRjaE1lZGlhKHF1ZXJ5KSB7XG4gICAgLy8gVXNlIGBhcyBhbnlgIGhlcmUgdG8gYXZvaWQgYWRkaW5nIGFkZGl0aW9uYWwgbmVjZXNzYXJ5IHByb3BlcnRpZXMgZm9yXG4gICAgLy8gdGhlIG5vb3AgbWF0Y2hlci5cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBxdWVyeSA9PT0gJ2FsbCcgfHwgcXVlcnkgPT09ICcnLFxuICAgICAgICBtZWRpYTogcXVlcnksXG4gICAgICAgIGFkZExpc3RlbmVyOiAoKSA9PiB7IH0sXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyOiAoKSA9PiB7IH0sXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogVXRpbGl0eSBmb3IgY2hlY2tpbmcgdGhlIG1hdGNoaW5nIHN0YXRlIG9mIEBtZWRpYSBxdWVyaWVzLiAqL1xuY2xhc3MgQnJlYWtwb2ludE9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihfbWVkaWFNYXRjaGVyLCBfem9uZSkge1xuICAgICAgICB0aGlzLl9tZWRpYU1hdGNoZXIgPSBfbWVkaWFNYXRjaGVyO1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIC8qKiAgQSBtYXAgb2YgYWxsIG1lZGlhIHF1ZXJpZXMgY3VycmVudGx5IGJlaW5nIGxpc3RlbmVkIGZvci4gKi9cbiAgICAgICAgdGhpcy5fcXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEEgc3ViamVjdCBmb3IgYWxsIG90aGVyIG9ic2VydmFibGVzIHRvIHRha2VVbnRpbCBiYXNlZCBvbi4gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveVN1YmplY3QgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKiogQ29tcGxldGVzIHRoZSBhY3RpdmUgc3ViamVjdCwgc2lnbmFsbGluZyB0byBhbGwgb3RoZXIgb2JzZXJ2YWJsZXMgdG8gY29tcGxldGUuICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lTdWJqZWN0Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVN1YmplY3QuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvbmUgb3IgbW9yZSBtZWRpYSBxdWVyaWVzIG1hdGNoIHRoZSBjdXJyZW50IHZpZXdwb3J0IHNpemUuXG4gICAgICogQHBhcmFtIHZhbHVlIE9uZSBvciBtb3JlIG1lZGlhIHF1ZXJpZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgV2hldGhlciBhbnkgb2YgdGhlIG1lZGlhIHF1ZXJpZXMgbWF0Y2guXG4gICAgICovXG4gICAgaXNNYXRjaGVkKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBzcGxpdFF1ZXJpZXMoY29lcmNlQXJyYXkodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJpZXMuc29tZShtZWRpYVF1ZXJ5ID0+IHRoaXMuX3JlZ2lzdGVyUXVlcnkobWVkaWFRdWVyeSkubXFsLm1hdGNoZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFuIG9ic2VydmFibGUgb2YgcmVzdWx0cyBmb3IgdGhlIGdpdmVuIHF1ZXJpZXMgdGhhdCB3aWxsIGVtaXQgbmV3IHJlc3VsdHMgZm9yIGFueSBjaGFuZ2VzXG4gICAgICogaW4gbWF0Y2hpbmcgb2YgdGhlIGdpdmVuIHF1ZXJpZXMuXG4gICAgICogQHBhcmFtIHZhbHVlIE9uZSBvciBtb3JlIG1lZGlhIHF1ZXJpZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMgQSBzdHJlYW0gb2YgbWF0Y2hlcyBmb3IgdGhlIGdpdmVuIHF1ZXJpZXMuXG4gICAgICovXG4gICAgb2JzZXJ2ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gc3BsaXRRdWVyaWVzKGNvZXJjZUFycmF5KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gcXVlcmllcy5tYXAocXVlcnkgPT4gdGhpcy5fcmVnaXN0ZXJRdWVyeShxdWVyeSkub2JzZXJ2YWJsZSk7XG4gICAgICAgIGxldCBzdGF0ZU9ic2VydmFibGUgPSBjb21iaW5lTGF0ZXN0KG9ic2VydmFibGVzKTtcbiAgICAgICAgLy8gRW1pdCB0aGUgZmlyc3Qgc3RhdGUgaW1tZWRpYXRlbHksIGFuZCB0aGVuIGRlYm91bmNlIHRoZSBzdWJzZXF1ZW50IGVtaXNzaW9ucy5cbiAgICAgICAgc3RhdGVPYnNlcnZhYmxlID0gY29uY2F0KHN0YXRlT2JzZXJ2YWJsZS5waXBlKHRha2UoMSkpLCBzdGF0ZU9ic2VydmFibGUucGlwZShza2lwKDEpLCBkZWJvdW5jZVRpbWUoMCkpKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlT2JzZXJ2YWJsZS5waXBlKG1hcChicmVha3BvaW50U3RhdGVzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIG1hdGNoZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGJyZWFrcG9pbnRzOiB7fSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVha3BvaW50U3RhdGVzLmZvckVhY2goKHsgbWF0Y2hlcywgcXVlcnkgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1hdGNoZXMgPSByZXNwb25zZS5tYXRjaGVzIHx8IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYnJlYWtwb2ludHNbcXVlcnldID0gbWF0Y2hlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlcnMgYSBzcGVjaWZpYyBxdWVyeSB0byBiZSBsaXN0ZW5lZCBmb3IuICovXG4gICAgX3JlZ2lzdGVyUXVlcnkocXVlcnkpIHtcbiAgICAgICAgLy8gT25seSBzZXQgdXAgYSBuZXcgTWVkaWFRdWVyeUxpc3QgaWYgaXQgaXMgbm90IGFscmVhZHkgYmVpbmcgbGlzdGVuZWQgZm9yLlxuICAgICAgICBpZiAodGhpcy5fcXVlcmllcy5oYXMocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcXVlcmllcy5nZXQocXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1xbCA9IHRoaXMuX21lZGlhTWF0Y2hlci5tYXRjaE1lZGlhKHF1ZXJ5KTtcbiAgICAgICAgLy8gQ3JlYXRlIGNhbGxiYWNrIGZvciBtYXRjaCBjaGFuZ2VzIGFuZCBhZGQgaXQgaXMgYXMgYSBsaXN0ZW5lci5cbiAgICAgICAgY29uc3QgcXVlcnlPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAvLyBMaXN0ZW5lciBjYWxsYmFjayBtZXRob2RzIGFyZSB3cmFwcGVkIHRvIGJlIHBsYWNlZCBiYWNrIGluIG5nWm9uZS4gQ2FsbGJhY2tzIG11c3QgYmUgcGxhY2VkXG4gICAgICAgICAgICAvLyBiYWNrIGludG8gdGhlIHpvbmUgYmVjYXVzZSBtYXRjaE1lZGlhIGlzIG9ubHkgaW5jbHVkZWQgaW4gWm9uZS5qcyBieSBsb2FkaW5nIHRoZVxuICAgICAgICAgICAgLy8gd2ViYXBpcy1tZWRpYS1xdWVyeS5qcyBmaWxlIGFsb25nc2lkZSB0aGUgem9uZS5qcyBmaWxlLiAgQWRkaXRpb25hbGx5LCBzb21lIGJyb3dzZXJzIGRvIG5vdFxuICAgICAgICAgICAgLy8gaGF2ZSBNZWRpYVF1ZXJ5TGlzdCBpbmhlcml0IGZyb20gRXZlbnRUYXJnZXQsIHdoaWNoIGNhdXNlcyBpbmNvbnNpc3RlbmNpZXMgaW4gaG93IFpvbmUuanNcbiAgICAgICAgICAgIC8vIHBhdGNoZXMgaXQuXG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gKGUpID0+IHRoaXMuX3pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoZSkpO1xuICAgICAgICAgICAgbXFsLmFkZExpc3RlbmVyKGhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtcWwucmVtb3ZlTGlzdGVuZXIoaGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5waXBlKHN0YXJ0V2l0aChtcWwpLCBtYXAoKHsgbWF0Y2hlcyB9KSA9PiAoeyBxdWVyeSwgbWF0Y2hlcyB9KSksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95U3ViamVjdCkpO1xuICAgICAgICAvLyBBZGQgdGhlIE1lZGlhUXVlcnlMaXN0IHRvIHRoZSBzZXQgb2YgcXVlcmllcy5cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0geyBvYnNlcnZhYmxlOiBxdWVyeU9ic2VydmFibGUsIG1xbCB9O1xuICAgICAgICB0aGlzLl9xdWVyaWVzLnNldChxdWVyeSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG5CcmVha3BvaW50T2JzZXJ2ZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcmVha3BvaW50T2JzZXJ2ZXIsIGRlcHM6IFt7IHRva2VuOiBNZWRpYU1hdGNoZXIgfSwgeyB0b2tlbjogaTAuTmdab25lIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5CcmVha3BvaW50T2JzZXJ2ZXIuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQnJlYWtwb2ludE9ic2VydmVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCcmVha3BvaW50T2JzZXJ2ZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogTWVkaWFNYXRjaGVyIH0sIHsgdHlwZTogaTAuTmdab25lIH1dOyB9IH0pO1xuLyoqXG4gKiBTcGxpdCBlYWNoIHF1ZXJ5IHN0cmluZyBpbnRvIHNlcGFyYXRlIHF1ZXJ5IHN0cmluZ3MgaWYgdHdvIHF1ZXJpZXMgYXJlIHByb3ZpZGVkIGFzIGNvbW1hXG4gKiBzZXBhcmF0ZWQuXG4gKi9cbmZ1bmN0aW9uIHNwbGl0UXVlcmllcyhxdWVyaWVzKSB7XG4gICAgcmV0dXJuIHF1ZXJpZXNcbiAgICAgICAgLm1hcChxdWVyeSA9PiBxdWVyeS5zcGxpdCgnLCcpKVxuICAgICAgICAucmVkdWNlKChhMSwgYTIpID0+IGExLmNvbmNhdChhMikpXG4gICAgICAgIC5tYXAocXVlcnkgPT4gcXVlcnkudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBQYXNjYWxDYXNlIGlzIGJlaW5nIHVzZWQgYXMgQnJlYWtwb2ludHMgaXMgdXNlZCBsaWtlIGFuIGVudW0uXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZVxuY29uc3QgQnJlYWtwb2ludHMgPSB7XG4gICAgWFNtYWxsOiAnKG1heC13aWR0aDogNTk5Ljk4cHgpJyxcbiAgICBTbWFsbDogJyhtaW4td2lkdGg6IDYwMHB4KSBhbmQgKG1heC13aWR0aDogOTU5Ljk4cHgpJyxcbiAgICBNZWRpdW06ICcobWluLXdpZHRoOiA5NjBweCkgYW5kIChtYXgtd2lkdGg6IDEyNzkuOThweCknLFxuICAgIExhcmdlOiAnKG1pbi13aWR0aDogMTI4MHB4KSBhbmQgKG1heC13aWR0aDogMTkxOS45OHB4KScsXG4gICAgWExhcmdlOiAnKG1pbi13aWR0aDogMTkyMHB4KScsXG4gICAgSGFuZHNldDogJyhtYXgtd2lkdGg6IDU5OS45OHB4KSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCksICcgK1xuICAgICAgICAnKG1heC13aWR0aDogOTU5Ljk4cHgpIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAgIFRhYmxldDogJyhtaW4td2lkdGg6IDYwMHB4KSBhbmQgKG1heC13aWR0aDogODM5Ljk4cHgpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSwgJyArXG4gICAgICAgICcobWluLXdpZHRoOiA5NjBweCkgYW5kIChtYXgtd2lkdGg6IDEyNzkuOThweCkgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gICAgV2ViOiAnKG1pbi13aWR0aDogODQwcHgpIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KSwgJyArXG4gICAgICAgICcobWluLXdpZHRoOiAxMjgwcHgpIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAgIEhhbmRzZXRQb3J0cmFpdDogJyhtYXgtd2lkdGg6IDU5OS45OHB4KSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICAgIFRhYmxldFBvcnRyYWl0OiAnKG1pbi13aWR0aDogNjAwcHgpIGFuZCAobWF4LXdpZHRoOiA4MzkuOThweCkgYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgICBXZWJQb3J0cmFpdDogJyhtaW4td2lkdGg6IDg0MHB4KSBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICAgIEhhbmRzZXRMYW5kc2NhcGU6ICcobWF4LXdpZHRoOiA5NTkuOThweCkgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gICAgVGFibGV0TGFuZHNjYXBlOiAnKG1pbi13aWR0aDogOTYwcHgpIGFuZCAobWF4LXdpZHRoOiAxMjc5Ljk4cHgpIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAgIFdlYkxhbmRzY2FwZTogJyhtaW4td2lkdGg6IDEyODBweCkgYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQnJlYWtwb2ludE9ic2VydmVyLCBCcmVha3BvaW50cywgTGF5b3V0TW9kdWxlLCBNZWRpYU1hdGNoZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/layout.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/observers.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/observers.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CdkObserveContent\": function() { return /* binding */ CdkObserveContent; },\n/* harmony export */   \"ContentObserver\": function() { return /* binding */ ContentObserver; },\n/* harmony export */   \"MutationObserverFactory\": function() { return /* binding */ MutationObserverFactory; },\n/* harmony export */   \"ObserversModule\": function() { return /* binding */ ObserversModule; }\n/* harmony export */ });\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\nclass MutationObserverFactory {\n    create(callback) {\n        return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n    }\n}\nMutationObserverFactory.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MutationObserverFactory, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nMutationObserverFactory.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MutationObserverFactory, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MutationObserverFactory, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n/** An injectable service that allows watching elements for changes to their content. */\nclass ContentObserver {\n    constructor(_mutationObserverFactory) {\n        this._mutationObserverFactory = _mutationObserverFactory;\n        /** Keeps track of the existing MutationObservers so they can be reused. */\n        this._observedElements = new Map();\n    }\n    ngOnDestroy() {\n        this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    observe(elementOrRef) {\n        const element = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceElement)(elementOrRef);\n        return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => {\n            const stream = this._observeElement(element);\n            const subscription = stream.subscribe(observer);\n            return () => {\n                subscription.unsubscribe();\n                this._unobserveElement(element);\n            };\n        });\n    }\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    _observeElement(element) {\n        if (!this._observedElements.has(element)) {\n            const stream = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n            const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n            if (observer) {\n                observer.observe(element, {\n                    characterData: true,\n                    childList: true,\n                    subtree: true,\n                });\n            }\n            this._observedElements.set(element, { observer, stream, count: 1 });\n        }\n        else {\n            this._observedElements.get(element).count++;\n        }\n        return this._observedElements.get(element).stream;\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    _unobserveElement(element) {\n        if (this._observedElements.has(element)) {\n            this._observedElements.get(element).count--;\n            if (!this._observedElements.get(element).count) {\n                this._cleanupObserver(element);\n            }\n        }\n    }\n    /** Clean up the underlying MutationObserver for the specified element. */\n    _cleanupObserver(element) {\n        if (this._observedElements.has(element)) {\n            const { observer, stream } = this._observedElements.get(element);\n            if (observer) {\n                observer.disconnect();\n            }\n            stream.complete();\n            this._observedElements.delete(element);\n        }\n    }\n}\nContentObserver.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ContentObserver, deps: [{ token: MutationObserverFactory }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nContentObserver.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ContentObserver, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ContentObserver, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: MutationObserverFactory }]; } });\n/**\n * Directive that triggers a callback whenever the content of\n * its associated element has changed.\n */\nclass CdkObserveContent {\n    /**\n     * Whether observing content is disabled. This option can be used\n     * to disconnect the underlying MutationObserver until it is needed.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(value) {\n        this._disabled = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceBooleanProperty)(value);\n        this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n    /** Debounce interval for emitting the changes. */\n    get debounce() {\n        return this._debounce;\n    }\n    set debounce(value) {\n        this._debounce = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceNumberProperty)(value);\n        this._subscribe();\n    }\n    constructor(_contentObserver, _elementRef, _ngZone) {\n        this._contentObserver = _contentObserver;\n        this._elementRef = _elementRef;\n        this._ngZone = _ngZone;\n        /** Event emitted for each change in the element's content. */\n        this.event = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n        this._disabled = false;\n        this._currentSubscription = null;\n    }\n    ngAfterContentInit() {\n        if (!this._currentSubscription && !this.disabled) {\n            this._subscribe();\n        }\n    }\n    ngOnDestroy() {\n        this._unsubscribe();\n    }\n    _subscribe() {\n        this._unsubscribe();\n        const stream = this._contentObserver.observe(this._elementRef);\n        // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n        // Consider brining it back inside the zone next time we're making breaking changes.\n        // Bringing it back inside can cause things like infinite change detection loops and changed\n        // after checked errors if people's code isn't handling it properly.\n        this._ngZone.runOutsideAngular(() => {\n            this._currentSubscription = (this.debounce ? stream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.debounceTime)(this.debounce)) : stream).subscribe(this.event);\n        });\n    }\n    _unsubscribe() {\n        this._currentSubscription?.unsubscribe();\n    }\n}\nCdkObserveContent.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkObserveContent, deps: [{ token: ContentObserver }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkObserveContent.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkObserveContent, selector: \"[cdkObserveContent]\", inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkObserveContent, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[cdkObserveContent]',\n                    exportAs: 'cdkObserveContent',\n                }]\n        }], ctorParameters: function () { return [{ type: ContentObserver }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }]; }, propDecorators: { event: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,\n                args: ['cdkObserveContent']\n            }], disabled: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,\n                args: ['cdkObserveContentDisabled']\n            }], debounce: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\nclass ObserversModule {\n}\nObserversModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ObserversModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nObserversModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ObserversModule, declarations: [CdkObserveContent], exports: [CdkObserveContent] });\nObserversModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ObserversModule, providers: [MutationObserverFactory] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ObserversModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    exports: [CdkObserveContent],\n                    declarations: [CdkObserveContent],\n                    providers: [MutationObserverFactory],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=observers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL29ic2VydmVycy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL29ic2VydmVycy5tanM/ZjFhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb2VyY2VFbGVtZW50LCBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgRXZlbnRFbWl0dGVyLCBEaXJlY3RpdmUsIE91dHB1dCwgSW5wdXQsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBGYWN0b3J5IHRoYXQgY3JlYXRlcyBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIGFuZCBhbGxvd3MgdXMgdG8gc3R1YiBpdCBvdXQgaW4gdW5pdCB0ZXN0cy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgTXV0YXRpb25PYnNlcnZlckZhY3Rvcnkge1xuICAgIGNyZWF0ZShjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB9XG59XG5NdXRhdGlvbk9ic2VydmVyRmFjdG9yeS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5LCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuTXV0YXRpb25PYnNlcnZlckZhY3RvcnkuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTXV0YXRpb25PYnNlcnZlckZhY3RvcnksIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcbi8qKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdGhhdCBhbGxvd3Mgd2F0Y2hpbmcgZWxlbWVudHMgZm9yIGNoYW5nZXMgdG8gdGhlaXIgY29udGVudC4gKi9cbmNsYXNzIENvbnRlbnRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5ID0gX211dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5O1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGV4aXN0aW5nIE11dGF0aW9uT2JzZXJ2ZXJzIHNvIHRoZXkgY2FuIGJlIHJldXNlZC4gKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZWRFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVkRWxlbWVudHMuZm9yRWFjaCgoXywgZWxlbWVudCkgPT4gdGhpcy5fY2xlYW51cE9ic2VydmVyKGVsZW1lbnQpKTtcbiAgICB9XG4gICAgb2JzZXJ2ZShlbGVtZW50T3JSZWYpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGNvZXJjZUVsZW1lbnQoZWxlbWVudE9yUmVmKTtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb2JzZXJ2ZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdHJlYW0uc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5vYnNlcnZlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnNlcnZlcyB0aGUgZ2l2ZW4gZWxlbWVudCBieSB1c2luZyB0aGUgZXhpc3RpbmcgTXV0YXRpb25PYnNlcnZlciBpZiBhdmFpbGFibGUsIG9yIGNyZWF0aW5nIGFcbiAgICAgKiBuZXcgb25lIGlmIG5vdC5cbiAgICAgKi9cbiAgICBfb2JzZXJ2ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX29ic2VydmVkRWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyRmFjdG9yeS5jcmVhdGUobXV0YXRpb25zID0+IHN0cmVhbS5uZXh0KG11dGF0aW9ucykpO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVkRWxlbWVudHMuc2V0KGVsZW1lbnQsIHsgb2JzZXJ2ZXIsIHN0cmVhbSwgY291bnQ6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlZEVsZW1lbnRzLmdldChlbGVtZW50KS5jb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlZEVsZW1lbnRzLmdldChlbGVtZW50KS5zdHJlYW07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuLW9ic2VydmVzIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBjbGVhbnMgdXAgdGhlIHVuZGVybHlpbmcgTXV0YXRpb25PYnNlcnZlciBpZiBub2JvZHkgZWxzZSBpc1xuICAgICAqIG9ic2VydmluZyB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgX3Vub2JzZXJ2ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2ZWRFbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpLmNvdW50LS07XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29ic2VydmVkRWxlbWVudHMuZ2V0KGVsZW1lbnQpLmNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cE9ic2VydmVyKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDbGVhbiB1cCB0aGUgdW5kZXJseWluZyBNdXRhdGlvbk9ic2VydmVyIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuICovXG4gICAgX2NsZWFudXBPYnNlcnZlcihlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9vYnNlcnZlZEVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICAgICAgY29uc3QgeyBvYnNlcnZlciwgc3RyZWFtIH0gPSB0aGlzLl9vYnNlcnZlZEVsZW1lbnRzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbS5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZWRFbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Db250ZW50T2JzZXJ2ZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDb250ZW50T2JzZXJ2ZXIsIGRlcHM6IFt7IHRva2VuOiBNdXRhdGlvbk9ic2VydmVyRmFjdG9yeSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuQ29udGVudE9ic2VydmVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENvbnRlbnRPYnNlcnZlciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ29udGVudE9ic2VydmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IE11dGF0aW9uT2JzZXJ2ZXJGYWN0b3J5IH1dOyB9IH0pO1xuLyoqXG4gKiBEaXJlY3RpdmUgdGhhdCB0cmlnZ2VycyBhIGNhbGxiYWNrIHdoZW5ldmVyIHRoZSBjb250ZW50IG9mXG4gKiBpdHMgYXNzb2NpYXRlZCBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5jbGFzcyBDZGtPYnNlcnZlQ29udGVudCB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBvYnNlcnZpbmcgY29udGVudCBpcyBkaXNhYmxlZC4gVGhpcyBvcHRpb24gY2FuIGJlIHVzZWRcbiAgICAgKiB0byBkaXNjb25uZWN0IHRoZSB1bmRlcmx5aW5nIE11dGF0aW9uT2JzZXJ2ZXIgdW50aWwgaXQgaXMgbmVlZGVkLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA/IHRoaXMuX3Vuc3Vic2NyaWJlKCkgOiB0aGlzLl9zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgLyoqIERlYm91bmNlIGludGVydmFsIGZvciBlbWl0dGluZyB0aGUgY2hhbmdlcy4gKi9cbiAgICBnZXQgZGVib3VuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJvdW5jZTtcbiAgICB9XG4gICAgc2V0IGRlYm91bmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlYm91bmNlID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoX2NvbnRlbnRPYnNlcnZlciwgX2VsZW1lbnRSZWYsIF9uZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudE9ic2VydmVyID0gX2NvbnRlbnRPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCBmb3IgZWFjaCBjaGFuZ2UgaW4gdGhlIGVsZW1lbnQncyBjb250ZW50LiAqL1xuICAgICAgICB0aGlzLmV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50U3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRTdWJzY3JpcHRpb24gJiYgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBfc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9jb250ZW50T2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50UmVmKTtcbiAgICAgICAgLy8gVE9ETyhtbWFsZXJiYSk6IFdlIHNob3VsZG4ndCBiZSBlbWl0dGluZyBvbiB0aGlzIEBPdXRwdXQoKSBvdXRzaWRlIHRoZSB6b25lLlxuICAgICAgICAvLyBDb25zaWRlciBicmluaW5nIGl0IGJhY2sgaW5zaWRlIHRoZSB6b25lIG5leHQgdGltZSB3ZSdyZSBtYWtpbmcgYnJlYWtpbmcgY2hhbmdlcy5cbiAgICAgICAgLy8gQnJpbmdpbmcgaXQgYmFjayBpbnNpZGUgY2FuIGNhdXNlIHRoaW5ncyBsaWtlIGluZmluaXRlIGNoYW5nZSBkZXRlY3Rpb24gbG9vcHMgYW5kIGNoYW5nZWRcbiAgICAgICAgLy8gYWZ0ZXIgY2hlY2tlZCBlcnJvcnMgaWYgcGVvcGxlJ3MgY29kZSBpc24ndCBoYW5kbGluZyBpdCBwcm9wZXJseS5cbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdWJzY3JpcHRpb24gPSAodGhpcy5kZWJvdW5jZSA/IHN0cmVhbS5waXBlKGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlKSkgOiBzdHJlYW0pLnN1YnNjcmliZSh0aGlzLmV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF91bnN1YnNjcmliZSgpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59XG5DZGtPYnNlcnZlQ29udGVudC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka09ic2VydmVDb250ZW50LCBkZXBzOiBbeyB0b2tlbjogQ29udGVudE9ic2VydmVyIH0sIHsgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogaTAuTmdab25lIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka09ic2VydmVDb250ZW50Lsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrT2JzZXJ2ZUNvbnRlbnQsIHNlbGVjdG9yOiBcIltjZGtPYnNlcnZlQ29udGVudF1cIiwgaW5wdXRzOiB7IGRpc2FibGVkOiBbXCJjZGtPYnNlcnZlQ29udGVudERpc2FibGVkXCIsIFwiZGlzYWJsZWRcIl0sIGRlYm91bmNlOiBcImRlYm91bmNlXCIgfSwgb3V0cHV0czogeyBldmVudDogXCJjZGtPYnNlcnZlQ29udGVudFwiIH0sIGV4cG9ydEFzOiBbXCJjZGtPYnNlcnZlQ29udGVudFwiXSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrT2JzZXJ2ZUNvbnRlbnQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtPYnNlcnZlQ29udGVudF0nLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ2Nka09ic2VydmVDb250ZW50JyxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IENvbnRlbnRPYnNlcnZlciB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMC5OZ1pvbmUgfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IGV2ZW50OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Nka09ic2VydmVDb250ZW50J11cbiAgICAgICAgICAgIH1dLCBkaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Nka09ic2VydmVDb250ZW50RGlzYWJsZWQnXVxuICAgICAgICAgICAgfV0sIGRlYm91bmNlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuY2xhc3MgT2JzZXJ2ZXJzTW9kdWxlIHtcbn1cbk9ic2VydmVyc01vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE9ic2VydmVyc01vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5PYnNlcnZlcnNNb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogT2JzZXJ2ZXJzTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtDZGtPYnNlcnZlQ29udGVudF0sIGV4cG9ydHM6IFtDZGtPYnNlcnZlQ29udGVudF0gfSk7XG5PYnNlcnZlcnNNb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogT2JzZXJ2ZXJzTW9kdWxlLCBwcm92aWRlcnM6IFtNdXRhdGlvbk9ic2VydmVyRmFjdG9yeV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBPYnNlcnZlcnNNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtDZGtPYnNlcnZlQ29udGVudF0sXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW0Nka09ic2VydmVDb250ZW50XSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTXV0YXRpb25PYnNlcnZlckZhY3RvcnldLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQ2RrT2JzZXJ2ZUNvbnRlbnQsIENvbnRlbnRPYnNlcnZlciwgTXV0YXRpb25PYnNlcnZlckZhY3RvcnksIE9ic2VydmVyc01vZHVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXJzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/observers.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/platform.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/platform.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Platform\": function() { return /* binding */ Platform; },\n/* harmony export */   \"PlatformModule\": function() { return /* binding */ PlatformModule; },\n/* harmony export */   \"_getEventTarget\": function() { return /* binding */ _getEventTarget; },\n/* harmony export */   \"_getFocusedElementPierceShadowDom\": function() { return /* binding */ _getFocusedElementPierceShadowDom; },\n/* harmony export */   \"_getShadowRoot\": function() { return /* binding */ _getShadowRoot; },\n/* harmony export */   \"_isTestEnvironment\": function() { return /* binding */ _isTestEnvironment; },\n/* harmony export */   \"_supportsShadowDom\": function() { return /* binding */ _supportsShadowDom; },\n/* harmony export */   \"getRtlScrollAxisType\": function() { return /* binding */ getRtlScrollAxisType; },\n/* harmony export */   \"getSupportedInputTypes\": function() { return /* binding */ getSupportedInputTypes; },\n/* harmony export */   \"normalizePassiveListenerOptions\": function() { return /* binding */ normalizePassiveListenerOptions; },\n/* harmony export */   \"supportsPassiveEventListeners\": function() { return /* binding */ supportsPassiveEventListeners; },\n/* harmony export */   \"supportsScrollBehavior\": function() { return /* binding */ supportsScrollBehavior; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;\n}\ncatch {\n    hasV8BreakIterator = false;\n}\n/**\n * Service to detect the current platform by comparing the userAgent strings and\n * checking browser-specific global properties.\n */\nclass Platform {\n    constructor(_platformId) {\n        this._platformId = _platformId;\n        // We want to use the Angular platform check because if the Document is shimmed\n        // without the navigator, the following checks will fail. This is preferred because\n        // sometimes the Document may be shimmed without the user's knowledge or intention\n        /** Whether the Angular application is being rendered in the browser. */\n        this.isBrowser = this._platformId\n            ? (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this._platformId)\n            : typeof document === 'object' && !!document;\n        /** Whether the current browser is Microsoft Edge. */\n        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n        /** Whether the current rendering engine is Microsoft Trident. */\n        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n        // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n        /** Whether the current rendering engine is Blink. */\n        this.BLINK = this.isBrowser &&\n            !!(window.chrome || hasV8BreakIterator) &&\n            typeof CSS !== 'undefined' &&\n            !this.EDGE &&\n            !this.TRIDENT;\n        // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n        // ensure that Webkit runs standalone and is not used as another engine's base.\n        /** Whether the current rendering engine is WebKit. */\n        this.WEBKIT = this.isBrowser &&\n            /AppleWebKit/i.test(navigator.userAgent) &&\n            !this.BLINK &&\n            !this.EDGE &&\n            !this.TRIDENT;\n        /** Whether the current platform is Apple iOS. */\n        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n        // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n        // them self as Gecko-like browsers and modify the userAgent's according to that.\n        // Since we only cover one explicit Firefox case, we can simply check for Firefox\n        // instead of having an unstable check for Gecko.\n        /** Whether the current browser is Firefox. */\n        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n        /** Whether the current platform is Android. */\n        // Trident on mobile adds the android platform to the userAgent to trick detections.\n        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n        // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n        // Safari browser should also use Webkit as its layout engine.\n        /** Whether the current browser is Safari. */\n        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n    }\n}\nPlatform.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Platform, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nPlatform.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Platform, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Platform, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: Object, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass PlatformModule {\n}\nPlatformModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlatformModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nPlatformModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlatformModule });\nPlatformModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlatformModule });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlatformModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{}]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => (supportsPassiveEvents = true),\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return 0 /* RtlScrollAxisType.NORMAL */;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = 0 /* RtlScrollAxisType.NORMAL */;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? 1 /* RtlScrollAxisType.NEGATED */ : 2 /* RtlScrollAxisType.INVERTED */;\n        }\n        scrollContainer.remove();\n    }\n    return rtlScrollAxisType;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * Gets the currently-focused element on the page while\n * also piercing through Shadow DOM boundaries.\n */\nfunction _getFocusedElementPierceShadowDom() {\n    let activeElement = typeof document !== 'undefined' && document\n        ? document.activeElement\n        : null;\n    while (activeElement && activeElement.shadowRoot) {\n        const newActiveElement = activeElement.shadowRoot.activeElement;\n        if (newActiveElement === activeElement) {\n            break;\n        }\n        else {\n            activeElement = newActiveElement;\n        }\n    }\n    return activeElement;\n}\n/** Gets the target of an event while accounting for Shadow DOM. */\nfunction _getEventTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets whether the code is currently running in a test environment. */\nfunction _isTestEnvironment() {\n    // We can't use `declare const` because it causes conflicts inside Google with the real typings\n    // for these symbols and we can't read them off the global object, because they don't appear to\n    // be attached there for some runners like Jest.\n    // (see: https://github.com/angular/components/issues/23365#issuecomment-938146643)\n    return (\n    // @ts-ignore\n    (typeof __karma__ !== 'undefined' && !!__karma__) ||\n        // @ts-ignore\n        (typeof jasmine !== 'undefined' && !!jasmine) ||\n        // @ts-ignore\n        (typeof jest !== 'undefined' && !!jest) ||\n        // @ts-ignore\n        (typeof Mocha !== 'undefined' && !!Mocha));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=platform.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL3BsYXRmb3JtLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL3BsYXRmb3JtLm1qcz80YmRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdGFibGUsIEluamVjdCwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vLyBXaGV0aGVyIHRoZSBjdXJyZW50IHBsYXRmb3JtIHN1cHBvcnRzIHRoZSBWOCBCcmVhayBJdGVyYXRvci4gVGhlIFY4IGNoZWNrXG4vLyBpcyBuZWNlc3NhcnkgdG8gZGV0ZWN0IGFsbCBCbGluayBiYXNlZCBicm93c2Vycy5cbmxldCBoYXNWOEJyZWFrSXRlcmF0b3I7XG4vLyBXZSBuZWVkIGEgdHJ5L2NhdGNoIGFyb3VuZCB0aGUgcmVmZXJlbmNlIHRvIGBJbnRsYCwgYmVjYXVzZSBhY2Nlc3NpbmcgaXQgaW4gc29tZSBjYXNlcyBjYW5cbi8vIGNhdXNlIElFIHRvIHRocm93LiBUaGVzZSBjYXNlcyBhcmUgdGllZCB0byBwYXJ0aWN1bGFyIHZlcnNpb25zIG9mIFdpbmRvd3MgYW5kIGNhbiBoYXBwZW4gaWZcbi8vIHRoZSBjb25zdW1lciBpcyBwcm92aWRpbmcgYSBwb2x5ZmlsbGVkIGBNYXBgLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L0NoYWtyYUNvcmUvaXNzdWVzLzMxODlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzE1Njg3XG50cnkge1xuICAgIGhhc1Y4QnJlYWtJdGVyYXRvciA9IHR5cGVvZiBJbnRsICE9PSAndW5kZWZpbmVkJyAmJiBJbnRsLnY4QnJlYWtJdGVyYXRvcjtcbn1cbmNhdGNoIHtcbiAgICBoYXNWOEJyZWFrSXRlcmF0b3IgPSBmYWxzZTtcbn1cbi8qKlxuICogU2VydmljZSB0byBkZXRlY3QgdGhlIGN1cnJlbnQgcGxhdGZvcm0gYnkgY29tcGFyaW5nIHRoZSB1c2VyQWdlbnQgc3RyaW5ncyBhbmRcbiAqIGNoZWNraW5nIGJyb3dzZXItc3BlY2lmaWMgZ2xvYmFsIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIFBsYXRmb3JtIHtcbiAgICBjb25zdHJ1Y3RvcihfcGxhdGZvcm1JZCkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybUlkID0gX3BsYXRmb3JtSWQ7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gdXNlIHRoZSBBbmd1bGFyIHBsYXRmb3JtIGNoZWNrIGJlY2F1c2UgaWYgdGhlIERvY3VtZW50IGlzIHNoaW1tZWRcbiAgICAgICAgLy8gd2l0aG91dCB0aGUgbmF2aWdhdG9yLCB0aGUgZm9sbG93aW5nIGNoZWNrcyB3aWxsIGZhaWwuIFRoaXMgaXMgcHJlZmVycmVkIGJlY2F1c2VcbiAgICAgICAgLy8gc29tZXRpbWVzIHRoZSBEb2N1bWVudCBtYXkgYmUgc2hpbW1lZCB3aXRob3V0IHRoZSB1c2VyJ3Mga25vd2xlZGdlIG9yIGludGVudGlvblxuICAgICAgICAvKiogV2hldGhlciB0aGUgQW5ndWxhciBhcHBsaWNhdGlvbiBpcyBiZWluZyByZW5kZXJlZCBpbiB0aGUgYnJvd3Nlci4gKi9cbiAgICAgICAgdGhpcy5pc0Jyb3dzZXIgPSB0aGlzLl9wbGF0Zm9ybUlkXG4gICAgICAgICAgICA/IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtSWQpXG4gICAgICAgICAgICA6IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCcgJiYgISFkb2N1bWVudDtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBpcyBNaWNyb3NvZnQgRWRnZS4gKi9cbiAgICAgICAgdGhpcy5FREdFID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhlZGdlKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IHJlbmRlcmluZyBlbmdpbmUgaXMgTWljcm9zb2Z0IFRyaWRlbnQuICovXG4gICAgICAgIHRoaXMuVFJJREVOVCA9IHRoaXMuaXNCcm93c2VyICYmIC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICAgIC8vIEVkZ2VIVE1MIGFuZCBUcmlkZW50IG1vY2sgQmxpbmsgc3BlY2lmaWMgdGhpbmdzIGFuZCBuZWVkIHRvIGJlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay5cbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIGN1cnJlbnQgcmVuZGVyaW5nIGVuZ2luZSBpcyBCbGluay4gKi9cbiAgICAgICAgdGhpcy5CTElOSyA9IHRoaXMuaXNCcm93c2VyICYmXG4gICAgICAgICAgICAhISh3aW5kb3cuY2hyb21lIHx8IGhhc1Y4QnJlYWtJdGVyYXRvcikgJiZcbiAgICAgICAgICAgIHR5cGVvZiBDU1MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAhdGhpcy5FREdFICYmXG4gICAgICAgICAgICAhdGhpcy5UUklERU5UO1xuICAgICAgICAvLyBXZWJraXQgaXMgcGFydCBvZiB0aGUgdXNlckFnZW50IGluIEVkZ2VIVE1MLCBCbGluayBhbmQgVHJpZGVudC4gVGhlcmVmb3JlIHdlIG5lZWQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgV2Via2l0IHJ1bnMgc3RhbmRhbG9uZSBhbmQgaXMgbm90IHVzZWQgYXMgYW5vdGhlciBlbmdpbmUncyBiYXNlLlxuICAgICAgICAvKiogV2hldGhlciB0aGUgY3VycmVudCByZW5kZXJpbmcgZW5naW5lIGlzIFdlYktpdC4gKi9cbiAgICAgICAgdGhpcy5XRUJLSVQgPSB0aGlzLmlzQnJvd3NlciAmJlxuICAgICAgICAgICAgL0FwcGxlV2ViS2l0L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAgICAgIXRoaXMuQkxJTksgJiZcbiAgICAgICAgICAgICF0aGlzLkVER0UgJiZcbiAgICAgICAgICAgICF0aGlzLlRSSURFTlQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IHBsYXRmb3JtIGlzIEFwcGxlIGlPUy4gKi9cbiAgICAgICAgdGhpcy5JT1MgPSB0aGlzLmlzQnJvd3NlciAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhKCdNU1N0cmVhbScgaW4gd2luZG93KTtcbiAgICAgICAgLy8gSXQncyBkaWZmaWN1bHQgdG8gZGV0ZWN0IHRoZSBwbGFpbiBHZWNrbyBlbmdpbmUsIGJlY2F1c2UgbW9zdCBvZiB0aGUgYnJvd3NlcnMgaWRlbnRpZnlcbiAgICAgICAgLy8gdGhlbSBzZWxmIGFzIEdlY2tvLWxpa2UgYnJvd3NlcnMgYW5kIG1vZGlmeSB0aGUgdXNlckFnZW50J3MgYWNjb3JkaW5nIHRvIHRoYXQuXG4gICAgICAgIC8vIFNpbmNlIHdlIG9ubHkgY292ZXIgb25lIGV4cGxpY2l0IEZpcmVmb3ggY2FzZSwgd2UgY2FuIHNpbXBseSBjaGVjayBmb3IgRmlyZWZveFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBhbiB1bnN0YWJsZSBjaGVjayBmb3IgR2Vja28uXG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgRmlyZWZveC4gKi9cbiAgICAgICAgdGhpcy5GSVJFRk9YID0gdGhpcy5pc0Jyb3dzZXIgJiYgLyhmaXJlZm94fG1pbmVmaWVsZCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgY3VycmVudCBwbGF0Zm9ybSBpcyBBbmRyb2lkLiAqL1xuICAgICAgICAvLyBUcmlkZW50IG9uIG1vYmlsZSBhZGRzIHRoZSBhbmRyb2lkIHBsYXRmb3JtIHRvIHRoZSB1c2VyQWdlbnQgdG8gdHJpY2sgZGV0ZWN0aW9ucy5cbiAgICAgICAgdGhpcy5BTkRST0lEID0gdGhpcy5pc0Jyb3dzZXIgJiYgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF0aGlzLlRSSURFTlQ7XG4gICAgICAgIC8vIFNhZmFyaSBicm93c2VycyB3aWxsIGluY2x1ZGUgdGhlIFNhZmFyaSBrZXl3b3JkIGluIHRoZWlyIHVzZXJBZ2VudC4gU29tZSBicm93c2VycyBtYXkgZmFrZVxuICAgICAgICAvLyB0aGlzIGFuZCBqdXN0IHBsYWNlIHRoZSBTYWZhcmkga2V5d29yZCBpbiB0aGUgdXNlckFnZW50LiBUbyBiZSBtb3JlIHNhZmUgYWJvdXQgU2FmYXJpIGV2ZXJ5XG4gICAgICAgIC8vIFNhZmFyaSBicm93c2VyIHNob3VsZCBhbHNvIHVzZSBXZWJraXQgYXMgaXRzIGxheW91dCBlbmdpbmUuXG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgU2FmYXJpLiAqL1xuICAgICAgICB0aGlzLlNBRkFSSSA9IHRoaXMuaXNCcm93c2VyICYmIC9zYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmIHRoaXMuV0VCS0lUO1xuICAgIH1cbn1cblBsYXRmb3JtLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhdGZvcm0sIGRlcHM6IFt7IHRva2VuOiBQTEFURk9STV9JRCB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuUGxhdGZvcm0uybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhdGZvcm0sIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBsYXRmb3JtLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IE9iamVjdCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbUExBVEZPUk1fSURdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgUGxhdGZvcm1Nb2R1bGUge1xufVxuUGxhdGZvcm1Nb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGF0Zm9ybU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5QbGF0Zm9ybU1vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGF0Zm9ybU1vZHVsZSB9KTtcblBsYXRmb3JtTW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBsYXRmb3JtTW9kdWxlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhdGZvcm1Nb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7fV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIENhY2hlZCByZXN1bHQgU2V0IG9mIGlucHV0IHR5cGVzIHN1cHBvcnQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci4gKi9cbmxldCBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuLyoqIFR5cGVzIG9mIGA8aW5wdXQ+YCB0aGF0ICptaWdodCogYmUgc3VwcG9ydGVkLiAqL1xuY29uc3QgY2FuZGlkYXRlSW5wdXRUeXBlcyA9IFtcbiAgICAvLyBgY29sb3JgIG11c3QgY29tZSBmaXJzdC4gQ2hyb21lIDU2IHNob3dzIGEgd2FybmluZyBpZiB3ZSBjaGFuZ2UgdGhlIHR5cGUgdG8gYGNvbG9yYCBhZnRlclxuICAgIC8vIGZpcnN0IGNoYW5naW5nIGl0IHRvIHNvbWV0aGluZyBlbHNlOlxuICAgIC8vIFRoZSBzcGVjaWZpZWQgdmFsdWUgXCJcIiBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSByZXF1aXJlZCBmb3JtYXQuXG4gICAgLy8gVGhlIGZvcm1hdCBpcyBcIiNycmdnYmJcIiB3aGVyZSByciwgZ2csIGJiIGFyZSB0d28tZGlnaXQgaGV4YWRlY2ltYWwgbnVtYmVycy5cbiAgICAnY29sb3InLFxuICAgICdidXR0b24nLFxuICAgICdjaGVja2JveCcsXG4gICAgJ2RhdGUnLFxuICAgICdkYXRldGltZS1sb2NhbCcsXG4gICAgJ2VtYWlsJyxcbiAgICAnZmlsZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2ltYWdlJyxcbiAgICAnbW9udGgnLFxuICAgICdudW1iZXInLFxuICAgICdwYXNzd29yZCcsXG4gICAgJ3JhZGlvJyxcbiAgICAncmFuZ2UnLFxuICAgICdyZXNldCcsXG4gICAgJ3NlYXJjaCcsXG4gICAgJ3N1Ym1pdCcsXG4gICAgJ3RlbCcsXG4gICAgJ3RleHQnLFxuICAgICd0aW1lJyxcbiAgICAndXJsJyxcbiAgICAnd2VlaycsXG5dO1xuLyoqIEByZXR1cm5zIFRoZSBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkSW5wdXRUeXBlcygpIHtcbiAgICAvLyBSZXN1bHQgaXMgY2FjaGVkLlxuICAgIGlmIChzdXBwb3J0ZWRJbnB1dFR5cGVzKSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuICAgIH1cbiAgICAvLyBXZSBjYW4ndCBjaGVjayBpZiBhbiBpbnB1dCB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgdW50aWwgd2UncmUgb24gdGhlIGJyb3dzZXIsIHNvIHNheSB0aGF0XG4gICAgLy8gZXZlcnl0aGluZyBpcyBzdXBwb3J0ZWQgd2hlbiBub3Qgb24gdGhlIGJyb3dzZXIuIFdlIGRvbid0IHVzZSBgUGxhdGZvcm1gIGhlcmUgc2luY2UgaXQnc1xuICAgIC8vIGp1c3QgYSBoZWxwZXIgZnVuY3Rpb24gYW5kIGNhbid0IGluamVjdCBpdC5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAnb2JqZWN0JyB8fCAhZG9jdW1lbnQpIHtcbiAgICAgICAgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IG5ldyBTZXQoY2FuZGlkYXRlSW5wdXRUeXBlcyk7XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xuICAgIH1cbiAgICBsZXQgZmVhdHVyZVRlc3RJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IG5ldyBTZXQoY2FuZGlkYXRlSW5wdXRUeXBlcy5maWx0ZXIodmFsdWUgPT4ge1xuICAgICAgICBmZWF0dXJlVGVzdElucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVUZXN0SW5wdXQudHlwZSA9PT0gdmFsdWU7XG4gICAgfSkpO1xuICAgIHJldHVybiBzdXBwb3J0ZWRJbnB1dFR5cGVzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBDYWNoZWQgcmVzdWx0IG9mIHdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZUV2ZW50cztcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHVzZXIncyBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZFxuICovXG5mdW5jdGlvbiBzdXBwb3J0c1Bhc3NpdmVFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAoc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IChzdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSB0cnVlKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZUV2ZW50cyA9IHN1cHBvcnRzUGFzc2l2ZUV2ZW50cyB8fCBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlRXZlbnRzO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIGFuIGBBZGRFdmVudExpc3RlbmVyYCBvYmplY3QgdG8gc29tZXRoaW5nIHRoYXQgY2FuIGJlIHBhc3NlZFxuICogdG8gYGFkZEV2ZW50TGlzdGVuZXJgIG9uIGFueSBicm93c2VyLCBubyBtYXR0ZXIgd2hldGhlciBpdCBzdXBwb3J0cyB0aGVcbiAqIGBvcHRpb25zYCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0gb3B0aW9ucyBPYmplY3QgdG8gYmUgbm9ybWFsaXplZC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUGFzc2l2ZUxpc3RlbmVyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZUV2ZW50TGlzdGVuZXJzKCkgPyBvcHRpb25zIDogISFvcHRpb25zLmNhcHR1cmU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIENhY2hlZCByZXN1bHQgb2YgdGhlIHdheSB0aGUgYnJvd3NlciBoYW5kbGVzIHRoZSBob3Jpem9udGFsIHNjcm9sbCBheGlzIGluIFJUTCBtb2RlLiAqL1xubGV0IHJ0bFNjcm9sbEF4aXNUeXBlO1xuLyoqIENhY2hlZCByZXN1bHQgb2YgdGhlIGNoZWNrIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgc2Nyb2xsIGJlaGF2aW9ycy4gKi9cbmxldCBzY3JvbGxCZWhhdmlvclN1cHBvcnRlZDtcbi8qKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHNjcm9sbCBiZWhhdmlvcnMuICovXG5mdW5jdGlvbiBzdXBwb3J0c1Njcm9sbEJlaGF2aW9yKCkge1xuICAgIGlmIChzY3JvbGxCZWhhdmlvclN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCBpbiB0aGUgYnJvd3NlciwgaXQgY2FuJ3QgYmUgc3VwcG9ydGVkLiBBbHNvIGNoZWNrIGZvciBgRWxlbWVudGAsIGJlY2F1c2VcbiAgICAgICAgLy8gc29tZSBwcm9qZWN0cyBzdHViIG91dCB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgZHVyaW5nIFNTUiB3aGljaCBjYW4gdGhyb3cgdXMgb2ZmLlxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAnb2JqZWN0JyB8fCAhZG9jdW1lbnQgfHwgdHlwZW9mIEVsZW1lbnQgIT09ICdmdW5jdGlvbicgfHwgIUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNjcm9sbEJlaGF2aW9yU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gc2Nyb2xsQmVoYXZpb3JTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgY2FuIGhhdmUgYSBgc2Nyb2xsQmVoYXZpb3JgIHN0eWxlLCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGl0J3Mgc3VwcG9ydGVkLlxuICAgICAgICBpZiAoJ3Njcm9sbEJlaGF2aW9yJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgICAgIHNjcm9sbEJlaGF2aW9yU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSAzIHBvc3NpYmlsaXRpZXM6IGBzY3JvbGxUb2AgaXNuJ3Qgc3VwcG9ydGVkIGF0IGFsbCwgaXQnc1xuICAgICAgICAgICAgLy8gc3VwcG9ydGVkIGJ1dCBpdCBkb2Vzbid0IGhhbmRsZSBzY3JvbGwgYmVoYXZpb3IsIG9yIGl0IGhhcyBiZWVuIHBvbHlmaWxsZWQuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxUb0Z1bmN0aW9uID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG87XG4gICAgICAgICAgICBpZiAoc2Nyb2xsVG9GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBkZXRlY3QgaWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIHBvbHlmaWxsZWQgYnkgY2FsbGluZyBgdG9TdHJpbmdgIG9uIGl0LiBOYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbnMgYXJlIG9iZnVzY2F0ZWQgdXNpbmcgYFtuYXRpdmUgY29kZV1gLCB3aGVyZWFzIGlmIGl0IHdhcyBvdmVyd3JpdHRlbiB3ZSdkIGdldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgZnVuY3Rpb24gc291cmNlLiBWaWEgaHR0cHM6Ly9kYXZpZHdhbHNoLm5hbWUvZGV0ZWN0LW5hdGl2ZS1mdW5jdGlvbi4gQ29uc2lkZXJcbiAgICAgICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9ucyBhcyBzdXBwb3J0aW5nIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgICAgICAgICAgICBzY3JvbGxCZWhhdmlvclN1cHBvcnRlZCA9ICEvXFx7XFxzKlxcW25hdGl2ZSBjb2RlXFxdXFxzKlxcfS8udGVzdChzY3JvbGxUb0Z1bmN0aW9uLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsQmVoYXZpb3JTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Nyb2xsQmVoYXZpb3JTdXBwb3J0ZWQ7XG59XG4vKipcbiAqIENoZWNrcyB0aGUgdHlwZSBvZiBSVEwgc2Nyb2xsIGF4aXMgdXNlZCBieSB0aGlzIGJyb3dzZXIuIEFzIG9mIHRpbWUgb2Ygd3JpdGluZywgQ2hyb21lIGlzIE5PUk1BTCxcbiAqIEZpcmVmb3ggJiBTYWZhcmkgYXJlIE5FR0FURUQsIGFuZCBJRSAmIEVkZ2UgYXJlIElOVkVSVEVELlxuICovXG5mdW5jdGlvbiBnZXRSdGxTY3JvbGxBeGlzVHlwZSgpIHtcbiAgICAvLyBXZSBjYW4ndCBjaGVjayB1bmxlc3Mgd2UncmUgb24gdGhlIGJyb3dzZXIuIEp1c3QgYXNzdW1lICdub3JtYWwnIGlmIHdlJ3JlIG5vdC5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAnb2JqZWN0JyB8fCAhZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIDAgLyogUnRsU2Nyb2xsQXhpc1R5cGUuTk9STUFMICovO1xuICAgIH1cbiAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT0gbnVsbCkge1xuICAgICAgICAvLyBDcmVhdGUgYSAxcHggd2lkZSBzY3JvbGxpbmcgY29udGFpbmVyIGFuZCBhIDJweCB3aWRlIGNvbnRlbnQgZWxlbWVudC5cbiAgICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gc2Nyb2xsQ29udGFpbmVyLnN0eWxlO1xuICAgICAgICBzY3JvbGxDb250YWluZXIuZGlyID0gJ3J0bCc7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICBjb250YWluZXJTdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBjb250ZW50U3R5bGUgPSBjb250ZW50LnN0eWxlO1xuICAgICAgICBjb250ZW50U3R5bGUud2lkdGggPSAnMnB4JztcbiAgICAgICAgY29udGVudFN0eWxlLmhlaWdodCA9ICcxcHgnO1xuICAgICAgICBzY3JvbGxDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgICAgcnRsU2Nyb2xsQXhpc1R5cGUgPSAwIC8qIFJ0bFNjcm9sbEF4aXNUeXBlLk5PUk1BTCAqLztcbiAgICAgICAgLy8gVGhlIHZpZXdwb3J0IHN0YXJ0cyBzY3JvbGxlZCBhbGwgdGhlIHdheSB0byB0aGUgcmlnaHQgaW4gUlRMIG1vZGUuIElmIHdlIGFyZSBpbiBhIE5PUk1BTFxuICAgICAgICAvLyBicm93c2VyIHRoaXMgd291bGQgbWVhbiB0aGF0IHRoZSBzY3JvbGxMZWZ0IHNob3VsZCBiZSAxLiBJZiBpdCdzIHplcm8gaW5zdGVhZCB3ZSBrbm93IHdlJ3JlXG4gICAgICAgIC8vIGRlYWxpbmcgd2l0aCBvbmUgb2YgdGhlIG90aGVyIHR3byB0eXBlcyBvZiBicm93c2Vycy5cbiAgICAgICAgaWYgKHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJbiBhIE5FR0FURUQgYnJvd3NlciB0aGUgc2Nyb2xsTGVmdCBpcyBhbHdheXMgc29tZXdoZXJlIGluIFstbWF4U2Nyb2xsQW1vdW50LCAwXS4gRm9yIGFuXG4gICAgICAgICAgICAvLyBJTlZFUlRFRCBicm93c2VyIGl0IGlzIGFsd2F5cyBzb21ld2hlcmUgaW4gWzAsIG1heFNjcm9sbEFtb3VudF0uIFdlIGNhbiBkZXRlcm1pbmUgd2hpY2ggYnlcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdG8gdGhlIHNjcm9sbExlZnQgdG8gMS4gVGhpcyBpcyBwYXN0IHRoZSBtYXggZm9yIGEgTkVHQVRFRCBicm93c2VyLCBzbyBpdCB3aWxsXG4gICAgICAgICAgICAvLyByZXR1cm4gMCB3aGVuIHdlIHJlYWQgaXQgYWdhaW4uXG4gICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA9IDE7XG4gICAgICAgICAgICBydGxTY3JvbGxBeGlzVHlwZSA9XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPT09IDAgPyAxIC8qIFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQgKi8gOiAyIC8qIFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEICovO1xuICAgICAgICB9XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ0bFNjcm9sbEF4aXNUeXBlO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmxldCBzaGFkb3dEb21Jc1N1cHBvcnRlZDtcbi8qKiBDaGVja3Mgd2hldGhlciB0aGUgdXNlcidzIGJyb3dzZXIgc3VwcG9ydCBTaGFkb3cgRE9NLiAqL1xuZnVuY3Rpb24gX3N1cHBvcnRzU2hhZG93RG9tKCkge1xuICAgIGlmIChzaGFkb3dEb21Jc1N1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQuaGVhZCA6IG51bGw7XG4gICAgICAgIHNoYWRvd0RvbUlzU3VwcG9ydGVkID0gISEoaGVhZCAmJiAoaGVhZC5jcmVhdGVTaGFkb3dSb290IHx8IGhlYWQuYXR0YWNoU2hhZG93KSk7XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3dEb21Jc1N1cHBvcnRlZDtcbn1cbi8qKiBHZXRzIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50LCBpZiBzdXBwb3J0ZWQgYW5kIHRoZSBlbGVtZW50IGlzIGluc2lkZSB0aGUgU2hhZG93IERPTS4gKi9cbmZ1bmN0aW9uIF9nZXRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICBpZiAoX3N1cHBvcnRzU2hhZG93RG9tKCkpIHtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlID8gZWxlbWVudC5nZXRSb290Tm9kZSgpIDogbnVsbDtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgc2hvdWxkIGJlIGNhdWdodCBieSBgX3N1cHBvcnRzU2hhZG93RG9tYCwgYnV0IHNvbWVcbiAgICAgICAgLy8gdGVhbXMgaGF2ZSBiZWVuIGFibGUgdG8gaGl0IHRoaXMgY29kZSBwYXRoIG9uIHVuc3VwcG9ydGVkIGJyb3dzZXJzLlxuICAgICAgICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgIT09ICd1bmRlZmluZWQnICYmIFNoYWRvd1Jvb3QgJiYgcm9vdE5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnRseS1mb2N1c2VkIGVsZW1lbnQgb24gdGhlIHBhZ2Ugd2hpbGVcbiAqIGFsc28gcGllcmNpbmcgdGhyb3VnaCBTaGFkb3cgRE9NIGJvdW5kYXJpZXMuXG4gKi9cbmZ1bmN0aW9uIF9nZXRGb2N1c2VkRWxlbWVudFBpZXJjZVNoYWRvd0RvbSgpIHtcbiAgICBsZXQgYWN0aXZlRWxlbWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRcbiAgICAgICAgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICAgIDogbnVsbDtcbiAgICB3aGlsZSAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgY29uc3QgbmV3QWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAobmV3QWN0aXZlRWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gbmV3QWN0aXZlRWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbi8qKiBHZXRzIHRoZSB0YXJnZXQgb2YgYW4gZXZlbnQgd2hpbGUgYWNjb3VudGluZyBmb3IgU2hhZG93IERPTS4gKi9cbmZ1bmN0aW9uIF9nZXRFdmVudFRhcmdldChldmVudCkge1xuICAgIC8vIElmIGFuIGV2ZW50IGlzIGJvdW5kIG91dHNpZGUgdGhlIFNoYWRvdyBET00sIHRoZSBgZXZlbnQudGFyZ2V0YCB3aWxsXG4gICAgLy8gcG9pbnQgdG8gdGhlIHNoYWRvdyByb290IHNvIHdlIGhhdmUgdG8gdXNlIGBjb21wb3NlZFBhdGhgIGluc3RlYWQuXG4gICAgcmV0dXJuIChldmVudC5jb21wb3NlZFBhdGggPyBldmVudC5jb21wb3NlZFBhdGgoKVswXSA6IGV2ZW50LnRhcmdldCk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEdldHMgd2hldGhlciB0aGUgY29kZSBpcyBjdXJyZW50bHkgcnVubmluZyBpbiBhIHRlc3QgZW52aXJvbm1lbnQuICovXG5mdW5jdGlvbiBfaXNUZXN0RW52aXJvbm1lbnQoKSB7XG4gICAgLy8gV2UgY2FuJ3QgdXNlIGBkZWNsYXJlIGNvbnN0YCBiZWNhdXNlIGl0IGNhdXNlcyBjb25mbGljdHMgaW5zaWRlIEdvb2dsZSB3aXRoIHRoZSByZWFsIHR5cGluZ3NcbiAgICAvLyBmb3IgdGhlc2Ugc3ltYm9scyBhbmQgd2UgY2FuJ3QgcmVhZCB0aGVtIG9mZiB0aGUgZ2xvYmFsIG9iamVjdCwgYmVjYXVzZSB0aGV5IGRvbid0IGFwcGVhciB0b1xuICAgIC8vIGJlIGF0dGFjaGVkIHRoZXJlIGZvciBzb21lIHJ1bm5lcnMgbGlrZSBKZXN0LlxuICAgIC8vIChzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzIzMzY1I2lzc3VlY29tbWVudC05MzgxNDY2NDMpXG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgKHR5cGVvZiBfX2thcm1hX18gIT09ICd1bmRlZmluZWQnICYmICEhX19rYXJtYV9fKSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICh0eXBlb2YgamFzbWluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgISFqYXNtaW5lKSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICh0eXBlb2YgamVzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFqZXN0KSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICh0eXBlb2YgTW9jaGEgIT09ICd1bmRlZmluZWQnICYmICEhTW9jaGEpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IFBsYXRmb3JtLCBQbGF0Zm9ybU1vZHVsZSwgX2dldEV2ZW50VGFyZ2V0LCBfZ2V0Rm9jdXNlZEVsZW1lbnRQaWVyY2VTaGFkb3dEb20sIF9nZXRTaGFkb3dSb290LCBfaXNUZXN0RW52aXJvbm1lbnQsIF9zdXBwb3J0c1NoYWRvd0RvbSwgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUsIGdldFN1cHBvcnRlZElucHV0VHlwZXMsIG5vcm1hbGl6ZVBhc3NpdmVMaXN0ZW5lck9wdGlvbnMsIHN1cHBvcnRzUGFzc2l2ZUV2ZW50TGlzdGVuZXJzLCBzdXBwb3J0c1Njcm9sbEJlaGF2aW9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/platform.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/scrolling.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/scrolling.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CdkFixedSizeVirtualScroll\": function() { return /* binding */ CdkFixedSizeVirtualScroll; },\n/* harmony export */   \"CdkScrollable\": function() { return /* binding */ CdkScrollable; },\n/* harmony export */   \"CdkScrollableModule\": function() { return /* binding */ CdkScrollableModule; },\n/* harmony export */   \"CdkVirtualForOf\": function() { return /* binding */ CdkVirtualForOf; },\n/* harmony export */   \"CdkVirtualScrollViewport\": function() { return /* binding */ CdkVirtualScrollViewport; },\n/* harmony export */   \"CdkVirtualScrollable\": function() { return /* binding */ CdkVirtualScrollable; },\n/* harmony export */   \"CdkVirtualScrollableElement\": function() { return /* binding */ CdkVirtualScrollableElement; },\n/* harmony export */   \"CdkVirtualScrollableWindow\": function() { return /* binding */ CdkVirtualScrollableWindow; },\n/* harmony export */   \"DEFAULT_RESIZE_TIME\": function() { return /* binding */ DEFAULT_RESIZE_TIME; },\n/* harmony export */   \"DEFAULT_SCROLL_TIME\": function() { return /* binding */ DEFAULT_SCROLL_TIME; },\n/* harmony export */   \"FixedSizeVirtualScrollStrategy\": function() { return /* binding */ FixedSizeVirtualScrollStrategy; },\n/* harmony export */   \"ScrollDispatcher\": function() { return /* binding */ ScrollDispatcher; },\n/* harmony export */   \"ScrollingModule\": function() { return /* binding */ ScrollingModule; },\n/* harmony export */   \"VIRTUAL_SCROLLABLE\": function() { return /* binding */ VIRTUAL_SCROLLABLE; },\n/* harmony export */   \"VIRTUAL_SCROLL_STRATEGY\": function() { return /* binding */ VIRTUAL_SCROLL_STRATEGY; },\n/* harmony export */   \"ViewportRuler\": function() { return /* binding */ ViewportRuler; },\n/* harmony export */   \"_fixedSizeVirtualScrollStrategyFactory\": function() { return /* binding */ _fixedSizeVirtualScrollStrategyFactory; }\n/* harmony export */ });\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/fesm2020/platform.mjs\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/bidi */ \"./node_modules/@angular/cdk/fesm2020/bidi.mjs\");\n/* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/collections */ \"./node_modules/@angular/cdk/fesm2020/collections.mjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the virtual scrolling strategy. */\nconst VIRTUAL_SCROLL_STRATEGY = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('VIRTUAL_SCROLL_STRATEGY');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.distinctUntilChanged)());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() {\n        /* no-op */\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() {\n        /* no-op */\n    }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\n/** A virtual scroll strategy that supports fixed-size items. */\nclass CdkFixedSizeVirtualScroll {\n    constructor() {\n        this._itemSize = 20;\n        this._minBufferPx = 100;\n        this._maxBufferPx = 200;\n        /** The scroll strategy used by this directive. */\n        this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n    /** The size of the items in the list (in pixels). */\n    get itemSize() {\n        return this._itemSize;\n    }\n    set itemSize(value) {\n        this._itemSize = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);\n    }\n    /**\n     * The minimum amount of buffer rendered beyond the viewport (in pixels).\n     * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n     */\n    get minBufferPx() {\n        return this._minBufferPx;\n    }\n    set minBufferPx(value) {\n        this._minBufferPx = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);\n    }\n    /**\n     * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n     */\n    get maxBufferPx() {\n        return this._maxBufferPx;\n    }\n    set maxBufferPx(value) {\n        this._maxBufferPx = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(value);\n    }\n    ngOnChanges() {\n        this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n    }\n}\nCdkFixedSizeVirtualScroll.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkFixedSizeVirtualScroll, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkFixedSizeVirtualScroll.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkFixedSizeVirtualScroll, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[itemSize]\", inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, providers: [\n        {\n            provide: VIRTUAL_SCROLL_STRATEGY,\n            useFactory: _fixedSizeVirtualScrollStrategyFactory,\n            deps: [(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CdkFixedSizeVirtualScroll)],\n        },\n    ], usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkFixedSizeVirtualScroll, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[itemSize]',\n                    standalone: true,\n                    providers: [\n                        {\n                            provide: VIRTUAL_SCROLL_STRATEGY,\n                            useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                            deps: [(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CdkFixedSizeVirtualScroll)],\n                        },\n                    ],\n                }]\n        }], propDecorators: { itemSize: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], minBufferPx: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], maxBufferPx: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\nclass ScrollDispatcher {\n    constructor(_ngZone, _platform, document) {\n        this._ngZone = _ngZone;\n        this._platform = _platform;\n        /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n        this._scrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** Keeps track of the global `scroll` and `resize` subscriptions. */\n        this._globalSubscription = null;\n        /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n        this._scrolledCount = 0;\n        /**\n         * Map of all the scrollable references that are registered with the service and their\n         * scroll event subscriptions.\n         */\n        this.scrollContainers = new Map();\n        this._document = document;\n    }\n    /**\n     * Registers a scrollable instance with the service and listens for its scrolled events. When the\n     * scrollable is scrolled, the service emits the event to its scrolled observable.\n     * @param scrollable Scrollable instance to be registered.\n     */\n    register(scrollable) {\n        if (!this.scrollContainers.has(scrollable)) {\n            this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));\n        }\n    }\n    /**\n     * De-registers a Scrollable reference and unsubscribes from its scroll event observable.\n     * @param scrollable Scrollable instance to be deregistered.\n     */\n    deregister(scrollable) {\n        const scrollableReference = this.scrollContainers.get(scrollable);\n        if (scrollableReference) {\n            scrollableReference.unsubscribe();\n            this.scrollContainers.delete(scrollable);\n        }\n    }\n    /**\n     * Returns an observable that emits an event whenever any of the registered Scrollable\n     * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n     * to override the default \"throttle\" time.\n     *\n     * **Note:** in order to avoid hitting change detection for every scroll event,\n     * all of the events emitted from this stream will be run outside the Angular zone.\n     * If you need to update any data bindings as a result of a scroll event, you have\n     * to run the callback using `NgZone.run`.\n     */\n    scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n        if (!this._platform.isBrowser) {\n            return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)();\n        }\n        return new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => {\n            if (!this._globalSubscription) {\n                this._addGlobalListener();\n            }\n            // In the case of a 0ms delay, use an observable without auditTime\n            // since it does add a perceptible delay in processing overhead.\n            const subscription = auditTimeInMs > 0\n                ? this._scrolled.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(auditTimeInMs)).subscribe(observer)\n                : this._scrolled.subscribe(observer);\n            this._scrolledCount++;\n            return () => {\n                subscription.unsubscribe();\n                this._scrolledCount--;\n                if (!this._scrolledCount) {\n                    this._removeGlobalListener();\n                }\n            };\n        });\n    }\n    ngOnDestroy() {\n        this._removeGlobalListener();\n        this.scrollContainers.forEach((_, container) => this.deregister(container));\n        this._scrolled.complete();\n    }\n    /**\n     * Returns an observable that emits whenever any of the\n     * scrollable ancestors of an element are scrolled.\n     * @param elementOrElementRef Element whose ancestors to listen for.\n     * @param auditTimeInMs Time to throttle the scroll events.\n     */\n    ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n        const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n        return this.scrolled(auditTimeInMs).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.filter)(target => {\n            return !target || ancestors.indexOf(target) > -1;\n        }));\n    }\n    /** Returns all registered Scrollables that contain the provided element. */\n    getAncestorScrollContainers(elementOrElementRef) {\n        const scrollingContainers = [];\n        this.scrollContainers.forEach((_subscription, scrollable) => {\n            if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                scrollingContainers.push(scrollable);\n            }\n        });\n        return scrollingContainers;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Returns true if the element is contained within the provided Scrollable. */\n    _scrollableContainsElement(scrollable, elementOrElementRef) {\n        let element = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceElement)(elementOrElementRef);\n        let scrollableElement = scrollable.getElementRef().nativeElement;\n        // Traverse through the element parents until we reach null, checking if any of the elements\n        // are the scrollable's element.\n        do {\n            if (element == scrollableElement) {\n                return true;\n            }\n        } while ((element = element.parentElement));\n        return false;\n    }\n    /** Sets up the global scroll listeners. */\n    _addGlobalListener() {\n        this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n            const window = this._getWindow();\n            return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window.document, 'scroll').subscribe(() => this._scrolled.next());\n        });\n    }\n    /** Cleans up the global scroll listener. */\n    _removeGlobalListener() {\n        if (this._globalSubscription) {\n            this._globalSubscription.unsubscribe();\n            this._globalSubscription = null;\n        }\n    }\n}\nScrollDispatcher.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollDispatcher, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nScrollDispatcher.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollDispatcher, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollDispatcher, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Sends an event when the directive's element is scrolled. Registers itself with the\n * ScrollDispatcher service to include itself as part of its collection of scrolling events that it\n * can be listened to through the service.\n */\nclass CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        this.elementRef = elementRef;\n        this.scrollDispatcher = scrollDispatcher;\n        this.ngZone = ngZone;\n        this.dir = dir;\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        this._elementScrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => this.ngZone.runOutsideAngular(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(this.elementRef.nativeElement, 'scroll')\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._destroyed))\n            .subscribe(observer)));\n    }\n    ngOnInit() {\n        this.scrollDispatcher.register(this);\n    }\n    ngOnDestroy() {\n        this.scrollDispatcher.deregister(this);\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    /** Returns observable that emits when a scroll event is fired on the host element. */\n    elementScrolled() {\n        return this._elementScrolled;\n    }\n    /** Gets the ElementRef for the viewport. */\n    getElementRef() {\n        return this.elementRef;\n    }\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param options specified the offsets to scroll to.\n     */\n    scrollTo(options) {\n        const el = this.elementRef.nativeElement;\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        // Rewrite start & end offsets as right or left offsets.\n        if (options.left == null) {\n            options.left = isRtl ? options.end : options.start;\n        }\n        if (options.right == null) {\n            options.right = isRtl ? options.start : options.end;\n        }\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n            options.top =\n                el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() != 0 /* RtlScrollAxisType.NORMAL */) {\n            if (options.left != null) {\n                options.right =\n                    el.scrollWidth - el.clientWidth - options.left;\n            }\n            if ((0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 2 /* RtlScrollAxisType.INVERTED */) {\n                options.left = options.right;\n            }\n            else if ((0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 1 /* RtlScrollAxisType.NEGATED */) {\n                options.left = options.right ? -options.right : options.right;\n            }\n        }\n        else {\n            if (options.right != null) {\n                options.left =\n                    el.scrollWidth - el.clientWidth - options.right;\n            }\n        }\n        this._applyScrollToOptions(options);\n    }\n    _applyScrollToOptions(options) {\n        const el = this.elementRef.nativeElement;\n        if ((0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.supportsScrollBehavior)()) {\n            el.scrollTo(options);\n        }\n        else {\n            if (options.top != null) {\n                el.scrollTop = options.top;\n            }\n            if (options.left != null) {\n                el.scrollLeft = options.left;\n            }\n        }\n    }\n    /**\n     * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n     * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n     * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param from The edge to measure from.\n     */\n    measureScrollOffset(from) {\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const el = this.elementRef.nativeElement;\n        if (from == 'top') {\n            return el.scrollTop;\n        }\n        if (from == 'bottom') {\n            return el.scrollHeight - el.clientHeight - el.scrollTop;\n        }\n        // Rewrite start & end as left or right offsets.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        if (from == 'start') {\n            from = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            from = isRtl ? LEFT : RIGHT;\n        }\n        if (isRtl && (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 2 /* RtlScrollAxisType.INVERTED */) {\n            // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n            else {\n                return el.scrollLeft;\n            }\n        }\n        else if (isRtl && (0,_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.getRtlScrollAxisType)() == 1 /* RtlScrollAxisType.NEGATED */) {\n            // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n            // 0 when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft + el.scrollWidth - el.clientWidth;\n            }\n            else {\n                return -el.scrollLeft;\n            }\n        }\n        else {\n            // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n            // (scrollWidth - clientWidth) when scrolled all the way right.\n            if (from == LEFT) {\n                return el.scrollLeft;\n            }\n            else {\n                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n            }\n        }\n    }\n}\nCdkScrollable.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollable, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: ScrollDispatcher }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkScrollable.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkScrollable, isStandalone: true, selector: \"[cdk-scrollable], [cdkScrollable]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollable, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[cdk-scrollable], [cdkScrollable]',\n                    standalone: true,\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: ScrollDispatcher }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * @docs-private\n */\nclass ViewportRuler {\n    constructor(_platform, ngZone, document) {\n        this._platform = _platform;\n        /** Stream of viewport change events. */\n        this._change = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** Event listener that will be used to handle the viewport change events. */\n        this._changeListener = (event) => {\n            this._change.next(event);\n        };\n        this._document = document;\n        ngZone.runOutsideAngular(() => {\n            if (_platform.isBrowser) {\n                const window = this._getWindow();\n                // Note that bind the events ourselves, rather than going through something like RxJS's\n                // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                window.addEventListener('resize', this._changeListener);\n                window.addEventListener('orientationchange', this._changeListener);\n            }\n            // Clear the cached position so that the viewport is re-measured next time it is required.\n            // We don't need to keep track of the subscription, because it is completed on destroy.\n            this.change().subscribe(() => (this._viewportSize = null));\n        });\n    }\n    ngOnDestroy() {\n        if (this._platform.isBrowser) {\n            const window = this._getWindow();\n            window.removeEventListener('resize', this._changeListener);\n            window.removeEventListener('orientationchange', this._changeListener);\n        }\n        this._change.complete();\n    }\n    /** Returns the viewport's width and height. */\n    getViewportSize() {\n        if (!this._viewportSize) {\n            this._updateViewportSize();\n        }\n        const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n        // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n        if (!this._platform.isBrowser) {\n            this._viewportSize = null;\n        }\n        return output;\n    }\n    /** Gets a ClientRect for the viewport's bounds. */\n    getViewportRect() {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        const scrollPosition = this.getViewportScrollPosition();\n        const { width, height } = this.getViewportSize();\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height,\n            width,\n        };\n    }\n    /** Gets the (top, left) scroll position of the viewport. */\n    getViewportScrollPosition() {\n        // While we can get a reference to the fake document\n        // during SSR, it doesn't have getBoundingClientRect.\n        if (!this._platform.isBrowser) {\n            return { top: 0, left: 0 };\n        }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        const document = this._document;\n        const window = this._getWindow();\n        const documentElement = document.documentElement;\n        const documentRect = documentElement.getBoundingClientRect();\n        const top = -documentRect.top ||\n            document.body.scrollTop ||\n            window.scrollY ||\n            documentElement.scrollTop ||\n            0;\n        const left = -documentRect.left ||\n            document.body.scrollLeft ||\n            window.scrollX ||\n            documentElement.scrollLeft ||\n            0;\n        return { top, left };\n    }\n    /**\n     * Returns a stream that emits whenever the size of the viewport changes.\n     * This stream emits outside of the Angular zone.\n     * @param throttleTime Time in milliseconds to throttle the stream.\n     */\n    change(throttleTime = DEFAULT_RESIZE_TIME) {\n        return throttleTime > 0 ? this._change.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(throttleTime)) : this._change;\n    }\n    /** Use defaultView of injected document if available or fallback to global window reference */\n    _getWindow() {\n        return this._document.defaultView || window;\n    }\n    /** Updates the cached viewport size. */\n    _updateViewportSize() {\n        const window = this._getWindow();\n        this._viewportSize = this._platform.isBrowser\n            ? { width: window.innerWidth, height: window.innerHeight }\n            : { width: 0, height: 0 };\n    }\n}\nViewportRuler.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ViewportRuler, deps: [{ token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nViewportRuler.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ViewportRuler, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ViewportRuler, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.DOCUMENT]\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst VIRTUAL_SCROLLABLE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('VIRTUAL_SCROLLABLE');\n/**\n * Extending the {@link CdkScrollable} to be used as scrolling container for virtual scrolling.\n */\nclass CdkVirtualScrollable extends CdkScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    /**\n     * Measure the viewport size for the provided orientation.\n     *\n     * @param orientation The orientation to measure the size from.\n     */\n    measureViewportSize(orientation) {\n        const viewportEl = this.elementRef.nativeElement;\n        return orientation === 'horizontal' ? viewportEl.clientWidth : viewportEl.clientHeight;\n    }\n}\nCdkVirtualScrollable.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollable, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: ScrollDispatcher }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkVirtualScrollable.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkVirtualScrollable, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollable, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: ScrollDispatcher }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? rxjs__WEBPACK_IMPORTED_MODULE_1__.animationFrameScheduler : rxjs__WEBPACK_IMPORTED_MODULE_1__.asapScheduler;\n/** A viewport that virtualizes its scrolling with the help of `CdkVirtualForOf`. */\nclass CdkVirtualScrollViewport extends CdkVirtualScrollable {\n    /** The direction the viewport scrolls. */\n    get orientation() {\n        return this._orientation;\n    }\n    set orientation(orientation) {\n        if (this._orientation !== orientation) {\n            this._orientation = orientation;\n            this._calculateSpacerSize();\n        }\n    }\n    /**\n     * Whether rendered items should persist in the DOM after scrolling out of view. By default, items\n     * will be removed.\n     */\n    get appendOnly() {\n        return this._appendOnly;\n    }\n    set appendOnly(value) {\n        this._appendOnly = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceBooleanProperty)(value);\n    }\n    constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n        this.elementRef = elementRef;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._scrollStrategy = _scrollStrategy;\n        this.scrollable = scrollable;\n        this._platform = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_5__.Platform);\n        /** Emits when the viewport is detached from a CdkVirtualForOf. */\n        this._detachedSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** Emits when the rendered range changes. */\n        this._renderedRangeSubject = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        this._orientation = 'vertical';\n        this._appendOnly = false;\n        // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n        // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n        // depending on how the strategy calculates the scrolled index, it may come at a cost to\n        // performance.\n        /** Emits when the index of the first element visible in the viewport changes. */\n        this.scrolledIndexChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n        /** A stream that emits whenever the rendered range changes. */\n        this.renderedRangeStream = this._renderedRangeSubject;\n        /**\n         * The total size of all content (in pixels), including content that is not currently rendered.\n         */\n        this._totalContentSize = 0;\n        /** A string representing the `style.width` property value to be used for the spacer element. */\n        this._totalContentWidth = '';\n        /** A string representing the `style.height` property value to be used for the spacer element. */\n        this._totalContentHeight = '';\n        /** The currently rendered range of indices. */\n        this._renderedRange = { start: 0, end: 0 };\n        /** The length of the data bound to this viewport (in number of items). */\n        this._dataLength = 0;\n        /** The size of the viewport (in pixels). */\n        this._viewportSize = 0;\n        /** The last rendered content offset that was set. */\n        this._renderedContentOffset = 0;\n        /**\n         * Whether the last rendered content offset was to the end of the content (and therefore needs to\n         * be rewritten as an offset to the start of the content).\n         */\n        this._renderedContentOffsetNeedsRewrite = false;\n        /** Whether there is a pending change detection cycle. */\n        this._isChangeDetectionPending = false;\n        /** A list of functions to run after the next change detection cycle. */\n        this._runAfterChangeDetection = [];\n        /** Subscription to changes in the viewport size. */\n        this._viewportChanges = rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;\n        if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n        }\n        this._viewportChanges = viewportRuler.change().subscribe(() => {\n            this.checkViewportSize();\n        });\n        if (!this.scrollable) {\n            // No scrollable is provided, so the virtual-scroll-viewport needs to become a scrollable\n            this.elementRef.nativeElement.classList.add('cdk-virtual-scrollable');\n            this.scrollable = this;\n        }\n    }\n    ngOnInit() {\n        // Scrolling depends on the element dimensions which we can't get during SSR.\n        if (!this._platform.isBrowser) {\n            return;\n        }\n        if (this.scrollable === this) {\n            super.ngOnInit();\n        }\n        // It's still too early to measure the viewport at this point. Deferring with a promise allows\n        // the Viewport to be rendered with the correct size before we measure. We run this outside the\n        // zone to avoid causing more change detection cycles. We handle the change detection loop\n        // ourselves instead.\n        this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n            this._measureViewportSize();\n            this._scrollStrategy.attach(this);\n            this.scrollable\n                .elementScrolled()\n                .pipe(\n            // Start off with a fake scroll event so we properly detect our initial position.\n            (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.startWith)(null), \n            // Collect multiple events into one until the next animation frame. This way if\n            // there are multiple scroll events in the same frame we only need to recheck\n            // our layout once.\n            (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.auditTime)(0, SCROLL_SCHEDULER))\n                .subscribe(() => this._scrollStrategy.onContentScrolled());\n            this._markChangeDetectionNeeded();\n        }));\n    }\n    ngOnDestroy() {\n        this.detach();\n        this._scrollStrategy.detach();\n        // Complete all subjects\n        this._renderedRangeSubject.complete();\n        this._detachedSubject.complete();\n        this._viewportChanges.unsubscribe();\n        super.ngOnDestroy();\n    }\n    /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n    attach(forOf) {\n        if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CdkVirtualScrollViewport is already attached.');\n        }\n        // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n        // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n        // change detection loop ourselves.\n        this.ngZone.runOutsideAngular(() => {\n            this._forOf = forOf;\n            this._forOf.dataStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._detachedSubject)).subscribe(data => {\n                const newLength = data.length;\n                if (newLength !== this._dataLength) {\n                    this._dataLength = newLength;\n                    this._scrollStrategy.onDataLengthChanged();\n                }\n                this._doChangeDetection();\n            });\n        });\n    }\n    /** Detaches the current `CdkVirtualForOf`. */\n    detach() {\n        this._forOf = null;\n        this._detachedSubject.next();\n    }\n    /** Gets the length of the data bound to this viewport (in number of items). */\n    getDataLength() {\n        return this._dataLength;\n    }\n    /** Gets the size of the viewport (in pixels). */\n    getViewportSize() {\n        return this._viewportSize;\n    }\n    // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n    // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n    // setting it to something else, but its error prone and should probably be split into\n    // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n    /** Get the current rendered range of items. */\n    getRenderedRange() {\n        return this._renderedRange;\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n    /**\n     * Sets the total size of all content (in pixels), including content that is not currently\n     * rendered.\n     */\n    setTotalContentSize(size) {\n        if (this._totalContentSize !== size) {\n            this._totalContentSize = size;\n            this._calculateSpacerSize();\n            this._markChangeDetectionNeeded();\n        }\n    }\n    /** Sets the currently rendered range of indices. */\n    setRenderedRange(range) {\n        if (!rangesEqual(this._renderedRange, range)) {\n            if (this.appendOnly) {\n                range = { start: 0, end: Math.max(this._renderedRange.end, range.end) };\n            }\n            this._renderedRangeSubject.next((this._renderedRange = range));\n            this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n        }\n    }\n    /**\n     * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n     */\n    getOffsetToRenderedContentStart() {\n        return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n    }\n    /**\n     * Sets the offset from the start of the viewport to either the start or end of the rendered data\n     * (in pixels).\n     */\n    setRenderedContentOffset(offset, to = 'to-start') {\n        // In appendOnly, we always start from the top\n        offset = this.appendOnly && to === 'to-start' ? 0 : offset;\n        // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n        // in the negative direction.\n        const isRtl = this.dir && this.dir.value == 'rtl';\n        const isHorizontal = this.orientation == 'horizontal';\n        const axis = isHorizontal ? 'X' : 'Y';\n        const axisDirection = isHorizontal && isRtl ? -1 : 1;\n        let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n        this._renderedContentOffset = offset;\n        if (to === 'to-end') {\n            transform += ` translate${axis}(-100%)`;\n            // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n            // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n            // expand upward).\n            this._renderedContentOffsetNeedsRewrite = true;\n        }\n        if (this._renderedContentTransform != transform) {\n            // We know this value is safe because we parse `offset` with `Number()` before passing it\n            // into the string.\n            this._renderedContentTransform = transform;\n            this._markChangeDetectionNeeded(() => {\n                if (this._renderedContentOffsetNeedsRewrite) {\n                    this._renderedContentOffset -= this.measureRenderedContentSize();\n                    this._renderedContentOffsetNeedsRewrite = false;\n                    this.setRenderedContentOffset(this._renderedContentOffset);\n                }\n                else {\n                    this._scrollStrategy.onRenderedOffsetChanged();\n                }\n            });\n        }\n    }\n    /**\n     * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n     * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n     * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n     * @param offset The offset to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToOffset(offset, behavior = 'auto') {\n        const options = { behavior };\n        if (this.orientation === 'horizontal') {\n            options.start = offset;\n        }\n        else {\n            options.top = offset;\n        }\n        this.scrollable.scrollTo(options);\n    }\n    /**\n     * Scrolls to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n     */\n    scrollToIndex(index, behavior = 'auto') {\n        this._scrollStrategy.scrollToIndex(index, behavior);\n    }\n    /**\n     * Gets the current scroll offset from the start of the scrollable (in pixels).\n     * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n     *     in horizontal mode.\n     */\n    measureScrollOffset(from) {\n        // This is to break the call cycle\n        let measureScrollOffset;\n        if (this.scrollable == this) {\n            measureScrollOffset = (_from) => super.measureScrollOffset(_from);\n        }\n        else {\n            measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);\n        }\n        return Math.max(0, measureScrollOffset(from ?? (this.orientation === 'horizontal' ? 'start' : 'top')) -\n            this.measureViewportOffset());\n    }\n    /**\n     * Measures the offset of the viewport from the scrolling container\n     * @param from The edge to measure from.\n     */\n    measureViewportOffset(from) {\n        let fromRect;\n        const LEFT = 'left';\n        const RIGHT = 'right';\n        const isRtl = this.dir?.value == 'rtl';\n        if (from == 'start') {\n            fromRect = isRtl ? RIGHT : LEFT;\n        }\n        else if (from == 'end') {\n            fromRect = isRtl ? LEFT : RIGHT;\n        }\n        else if (from) {\n            fromRect = from;\n        }\n        else {\n            fromRect = this.orientation === 'horizontal' ? 'left' : 'top';\n        }\n        const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);\n        const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];\n        return viewportClientRect - scrollerClientRect;\n    }\n    /** Measure the combined size of all of the rendered items. */\n    measureRenderedContentSize() {\n        const contentEl = this._contentWrapper.nativeElement;\n        return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n    }\n    /**\n     * Measure the total combined size of the given range. Throws if the range includes items that are\n     * not rendered.\n     */\n    measureRangeSize(range) {\n        if (!this._forOf) {\n            return 0;\n        }\n        return this._forOf.measureRangeSize(range, this.orientation);\n    }\n    /** Update the viewport dimensions and re-render. */\n    checkViewportSize() {\n        // TODO: Cleanup later when add logic for handling content resize\n        this._measureViewportSize();\n        this._scrollStrategy.onDataLengthChanged();\n    }\n    /** Measure the viewport size. */\n    _measureViewportSize() {\n        this._viewportSize = this.scrollable.measureViewportSize(this.orientation);\n    }\n    /** Queue up change detection to run. */\n    _markChangeDetectionNeeded(runAfter) {\n        if (runAfter) {\n            this._runAfterChangeDetection.push(runAfter);\n        }\n        // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n        // properties sequentially we only have to run `_doChangeDetection` once at the end.\n        if (!this._isChangeDetectionPending) {\n            this._isChangeDetectionPending = true;\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._doChangeDetection();\n            }));\n        }\n    }\n    /** Run change detection. */\n    _doChangeDetection() {\n        this._isChangeDetectionPending = false;\n        // Apply the content transform. The transform can't be set via an Angular binding because\n        // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n        // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n        // the `Number` function first to coerce it to a numeric value.\n        this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n        // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n        // from the root, since the repeated items are content projected in. Calling `detectChanges`\n        // instead does not properly check the projected content.\n        this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n        const runAfterChangeDetection = this._runAfterChangeDetection;\n        this._runAfterChangeDetection = [];\n        for (const fn of runAfterChangeDetection) {\n            fn();\n        }\n    }\n    /** Calculates the `style.width` and `style.height` for the spacer element. */\n    _calculateSpacerSize() {\n        this._totalContentHeight =\n            this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n        this._totalContentWidth =\n            this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n    }\n}\nCdkVirtualScrollViewport.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollViewport, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: VIRTUAL_SCROLL_STRATEGY, optional: true }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }, { token: ScrollDispatcher }, { token: ViewportRuler }, { token: VIRTUAL_SCROLLABLE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Component });\nCdkVirtualScrollViewport.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkVirtualScrollViewport, isStandalone: true, selector: \"cdk-virtual-scroll-viewport\", inputs: { orientation: \"orientation\", appendOnly: \"appendOnly\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, host: { properties: { \"class.cdk-virtual-scroll-orientation-horizontal\": \"orientation === \\\"horizontal\\\"\", \"class.cdk-virtual-scroll-orientation-vertical\": \"orientation !== \\\"horizontal\\\"\" }, classAttribute: \"cdk-virtual-scroll-viewport\" }, providers: [\n        {\n            provide: CdkScrollable,\n            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n            deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n        },\n    ], viewQueries: [{ propertyName: \"_contentWrapper\", first: true, predicate: [\"contentWrapper\"], descendants: true, static: true }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollViewport, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,\n            args: [{ selector: 'cdk-virtual-scroll-viewport', host: {\n                        'class': 'cdk-virtual-scroll-viewport',\n                        '[class.cdk-virtual-scroll-orientation-horizontal]': 'orientation === \"horizontal\"',\n                        '[class.cdk-virtual-scroll-orientation-vertical]': 'orientation !== \"horizontal\"',\n                    }, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush, standalone: true, providers: [\n                        {\n                            provide: CdkScrollable,\n                            useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,\n                            deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport],\n                        },\n                    ], template: \"<!--\\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\\n  position.\\n-->\\n<div #contentWrapper class=\\\"cdk-virtual-scroll-content-wrapper\\\">\\n  <ng-content></ng-content>\\n</div>\\n<!--\\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\\n  so that the scrollbar captures the size of the entire data set.\\n-->\\n<div class=\\\"cdk-virtual-scroll-spacer\\\"\\n     [style.width]=\\\"_totalContentWidth\\\" [style.height]=\\\"_totalContentHeight\\\"></div>\\n\", styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}\"] }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [VIRTUAL_SCROLL_STRATEGY]\n                }] }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }, { type: ScrollDispatcher }, { type: ViewportRuler }, { type: CdkVirtualScrollable, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [VIRTUAL_SCROLLABLE]\n                }] }]; }, propDecorators: { orientation: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], appendOnly: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], scrolledIndexChange: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output\n            }], _contentWrapper: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,\n                args: ['contentWrapper', { static: true }]\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\n/**\n * A directive similar to `ngForOf` to be used for rendering data inside a virtual scrolling\n * container.\n */\nclass CdkVirtualForOf {\n    /** The DataSource to display. */\n    get cdkVirtualForOf() {\n        return this._cdkVirtualForOf;\n    }\n    set cdkVirtualForOf(value) {\n        this._cdkVirtualForOf = value;\n        if ((0,_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__.isDataSource)(value)) {\n            this._dataSourceChanges.next(value);\n        }\n        else {\n            // If value is an an NgIterable, convert it to an array.\n            this._dataSourceChanges.next(new _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__.ArrayDataSource((0,rxjs__WEBPACK_IMPORTED_MODULE_1__.isObservable)(value) ? value : Array.from(value || [])));\n        }\n    }\n    /**\n     * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n     * the item and produces a value to be used as the item's identity when tracking changes.\n     */\n    get cdkVirtualForTrackBy() {\n        return this._cdkVirtualForTrackBy;\n    }\n    set cdkVirtualForTrackBy(fn) {\n        this._needsUpdate = true;\n        this._cdkVirtualForTrackBy = fn\n            ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item)\n            : undefined;\n    }\n    /** The template used to stamp out new elements. */\n    set cdkVirtualForTemplate(value) {\n        if (value) {\n            this._needsUpdate = true;\n            this._template = value;\n        }\n    }\n    /**\n     * The size of the cache used to store templates that are not being used for re-use later.\n     * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n     */\n    get cdkVirtualForTemplateCacheSize() {\n        return this._viewRepeater.viewCacheSize;\n    }\n    set cdkVirtualForTemplateCacheSize(size) {\n        this._viewRepeater.viewCacheSize = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_4__.coerceNumberProperty)(size);\n    }\n    constructor(\n    /** The view container to add items to. */\n    _viewContainerRef, \n    /** The template to use when stamping out new items. */\n    _template, \n    /** The set of available differs. */\n    _differs, \n    /** The strategy used to render items in the virtual scroll viewport. */\n    _viewRepeater, \n    /** The virtual scrolling viewport that these items are being rendered in. */\n    _viewport, ngZone) {\n        this._viewContainerRef = _viewContainerRef;\n        this._template = _template;\n        this._differs = _differs;\n        this._viewRepeater = _viewRepeater;\n        this._viewport = _viewport;\n        /** Emits when the rendered view of the data changes. */\n        this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** Subject that emits when a new DataSource instance is given. */\n        this._dataSourceChanges = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        /** Emits whenever the data in the current DataSource changes. */\n        this.dataStream = this._dataSourceChanges.pipe(\n        // Start off with null `DataSource`.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.startWith)(null), \n        // Bundle up the previous and current data sources so we can work with both.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.pairwise)(), \n        // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n        // new one, passing back a stream of data changes which we run through `switchMap` to give\n        // us a data stream that emits the latest data from whatever the current `DataSource` is.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.switchMap)(([prev, cur]) => this._changeDataSource(prev, cur)), \n        // Replay the last emitted data when someone subscribes.\n        (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.shareReplay)(1));\n        /** The differ used to calculate changes to the data. */\n        this._differ = null;\n        /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n        this._needsUpdate = false;\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();\n        this.dataStream.subscribe(data => {\n            this._data = data;\n            this._onRenderedDataChange();\n        });\n        this._viewport.renderedRangeStream.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._destroyed)).subscribe(range => {\n            this._renderedRange = range;\n            if (this.viewChange.observers.length) {\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n            }\n            this._onRenderedDataChange();\n        });\n        this._viewport.attach(this);\n    }\n    /**\n     * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n     * in the specified range. Throws an error if the range includes items that are not currently\n     * rendered.\n     */\n    measureRangeSize(range, orientation) {\n        if (range.start >= range.end) {\n            return 0;\n        }\n        if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error(`Error: attempted to measure an item that isn't rendered.`);\n        }\n        // The index into the list of rendered views for the first item in the range.\n        const renderedStartIndex = range.start - this._renderedRange.start;\n        // The length of the range we're measuring.\n        const rangeLen = range.end - range.start;\n        // Loop over all the views, find the first and land node and compute the size by subtracting\n        // the top of the first node from the bottom of the last one.\n        let firstNode;\n        let lastNode;\n        // Find the first node by starting from the beginning and going forwards.\n        for (let i = 0; i < rangeLen; i++) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                firstNode = lastNode = view.rootNodes[0];\n                break;\n            }\n        }\n        // Find the last node by starting from the end and going backwards.\n        for (let i = rangeLen - 1; i > -1; i--) {\n            const view = this._viewContainerRef.get(i + renderedStartIndex);\n            if (view && view.rootNodes.length) {\n                lastNode = view.rootNodes[view.rootNodes.length - 1];\n                break;\n            }\n        }\n        return firstNode && lastNode\n            ? getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode)\n            : 0;\n    }\n    ngDoCheck() {\n        if (this._differ && this._needsUpdate) {\n            // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n            // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n            // changing (need to do this diff).\n            const changes = this._differ.diff(this._renderedItems);\n            if (!changes) {\n                this._updateContext();\n            }\n            else {\n                this._applyChanges(changes);\n            }\n            this._needsUpdate = false;\n        }\n    }\n    ngOnDestroy() {\n        this._viewport.detach();\n        this._dataSourceChanges.next(undefined);\n        this._dataSourceChanges.complete();\n        this.viewChange.complete();\n        this._destroyed.next();\n        this._destroyed.complete();\n        this._viewRepeater.detach();\n    }\n    /** React to scroll state changes in the viewport. */\n    _onRenderedDataChange() {\n        if (!this._renderedRange) {\n            return;\n        }\n        this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n        if (!this._differ) {\n            // Use a wrapper function for the `trackBy` so any new values are\n            // picked up automatically without having to recreate the differ.\n            this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n            });\n        }\n        this._needsUpdate = true;\n    }\n    /** Swap out one `DataSource` for another. */\n    _changeDataSource(oldDs, newDs) {\n        if (oldDs) {\n            oldDs.disconnect(this);\n        }\n        this._needsUpdate = true;\n        return newDs ? newDs.connect(this) : (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)();\n    }\n    /** Update the `CdkVirtualForOfContext` for all views. */\n    _updateContext() {\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n            view.detectChanges();\n        }\n    }\n    /** Apply changes to the DOM. */\n    _applyChanges(changes) {\n        this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), record => record.item);\n        // Update $implicit for any items that had an identity change.\n        changes.forEachIdentityChange((record) => {\n            const view = this._viewContainerRef.get(record.currentIndex);\n            view.context.$implicit = record.item;\n        });\n        // Update the context variables on all items.\n        const count = this._data.length;\n        let i = this._viewContainerRef.length;\n        while (i--) {\n            const view = this._viewContainerRef.get(i);\n            view.context.index = this._renderedRange.start + i;\n            view.context.count = count;\n            this._updateComputedContextProperties(view.context);\n        }\n    }\n    /** Update the computed properties on the `CdkVirtualForOfContext`. */\n    _updateComputedContextProperties(context) {\n        context.first = context.index === 0;\n        context.last = context.index === context.count - 1;\n        context.even = context.index % 2 === 0;\n        context.odd = !context.even;\n    }\n    _getEmbeddedViewArgs(record, index) {\n        // Note that it's important that we insert the item directly at the proper index,\n        // rather than inserting it and the moving it in place, because if there's a directive\n        // on the same node that injects the `ViewContainerRef`, Angular will insert another\n        // comment node which can throw off the move when it's being repeated for all items.\n        return {\n            templateRef: this._template,\n            context: {\n                $implicit: record.item,\n                // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                cdkVirtualForOf: this._cdkVirtualForOf,\n                index: -1,\n                count: -1,\n                first: false,\n                last: false,\n                odd: false,\n                even: false,\n            },\n            index,\n        };\n    }\n}\nCdkVirtualForOf.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualForOf, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers }, { token: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY }, { token: CdkVirtualScrollViewport, skipSelf: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkVirtualForOf.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkVirtualForOf, isStandalone: true, selector: \"[cdkVirtualFor][cdkVirtualForOf]\", inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._RecycleViewRepeaterStrategy }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualForOf, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[cdkVirtualFor][cdkVirtualForOf]',\n                    providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._RecycleViewRepeaterStrategy }],\n                    standalone: true,\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.IterableDiffers }, { type: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._RecycleViewRepeaterStrategy, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,\n                    args: [_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_7__._VIEW_REPEATER_STRATEGY]\n                }] }, { type: CdkVirtualScrollViewport, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf\n                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }]; }, propDecorators: { cdkVirtualForOf: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], cdkVirtualForTrackBy: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], cdkVirtualForTemplate: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }], cdkVirtualForTemplateCacheSize: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides a virtual scrollable for the element it is attached to.\n */\nclass CdkVirtualScrollableElement extends CdkVirtualScrollable {\n    constructor(elementRef, scrollDispatcher, ngZone, dir) {\n        super(elementRef, scrollDispatcher, ngZone, dir);\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return (this.getElementRef().nativeElement.getBoundingClientRect()[from] -\n            this.measureScrollOffset(from));\n    }\n}\nCdkVirtualScrollableElement.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollableElement, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: ScrollDispatcher }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkVirtualScrollableElement.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkVirtualScrollableElement, isStandalone: true, selector: \"[cdkVirtualScrollingElement]\", host: { classAttribute: \"cdk-virtual-scrollable\" }, providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollableElement, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: '[cdkVirtualScrollingElement]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableElement }],\n                    standalone: true,\n                    host: {\n                        'class': 'cdk-virtual-scrollable',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: ScrollDispatcher }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Provides as virtual scrollable for the global / window scrollbar.\n */\nclass CdkVirtualScrollableWindow extends CdkVirtualScrollable {\n    constructor(scrollDispatcher, ngZone, dir) {\n        super(new _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);\n        this._elementScrolled = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => this.ngZone.runOutsideAngular(() => (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(document, 'scroll').pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.takeUntil)(this._destroyed)).subscribe(observer)));\n    }\n    measureBoundingClientRectWithScrollOffset(from) {\n        return this.getElementRef().nativeElement.getBoundingClientRect()[from];\n    }\n}\nCdkVirtualScrollableWindow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollableWindow, deps: [{ token: ScrollDispatcher }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Directive });\nCdkVirtualScrollableWindow.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkVirtualScrollableWindow, isStandalone: true, selector: \"cdk-virtual-scroll-viewport[scrollWindow]\", providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkVirtualScrollableWindow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,\n            args: [{\n                    selector: 'cdk-virtual-scroll-viewport[scrollWindow]',\n                    providers: [{ provide: VIRTUAL_SCROLLABLE, useExisting: CdkVirtualScrollableWindow }],\n                    standalone: true,\n                }]\n        }], ctorParameters: function () { return [{ type: ScrollDispatcher }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional\n                }] }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass CdkScrollableModule {\n}\nCdkScrollableModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollableModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nCdkScrollableModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollableModule, imports: [CdkScrollable], exports: [CdkScrollable] });\nCdkScrollableModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollableModule });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CdkScrollableModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    exports: [CdkScrollable],\n                    imports: [CdkScrollable],\n                }]\n        }] });\n/**\n * @docs-primary-export\n */\nclass ScrollingModule {\n}\nScrollingModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollingModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].NgModule });\nScrollingModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollingModule, imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, CdkScrollableModule, CdkVirtualScrollViewport,\n        CdkFixedSizeVirtualScroll,\n        CdkVirtualForOf,\n        CdkVirtualScrollableWindow,\n        CdkVirtualScrollableElement], exports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll,\n        CdkVirtualForOf,\n        CdkVirtualScrollViewport,\n        CdkVirtualScrollableWindow,\n        CdkVirtualScrollableElement] });\nScrollingModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollingModule, imports: [_angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule,\n        CdkScrollableModule,\n        CdkVirtualScrollViewport, _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule, CdkScrollableModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollingModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,\n            args: [{\n                    imports: [\n                        _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule,\n                        CdkScrollableModule,\n                        CdkVirtualScrollViewport,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                    exports: [\n                        _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.BidiModule,\n                        CdkScrollableModule,\n                        CdkFixedSizeVirtualScroll,\n                        CdkVirtualForOf,\n                        CdkVirtualScrollViewport,\n                        CdkVirtualScrollableWindow,\n                        CdkVirtualScrollableElement,\n                    ],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=scrolling.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL3Njcm9sbGluZy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZmVzbTIwMjAvc2Nyb2xsaW5nLm1qcz8zYjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvZXJjZU51bWJlclByb3BlcnR5LCBjb2VyY2VFbGVtZW50LCBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiwgZm9yd2FyZFJlZiwgRGlyZWN0aXZlLCBJbnB1dCwgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCwgaW5qZWN0LCBDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9uLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgT3V0cHV0LCBWaWV3Q2hpbGQsIFNraXBTZWxmLCBFbGVtZW50UmVmLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgb2YsIE9ic2VydmFibGUsIGZyb21FdmVudCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIGFzYXBTY2hlZHVsZXIsIFN1YnNjcmlwdGlvbiwgaXNPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgYXVkaXRUaW1lLCBmaWx0ZXIsIHRha2VVbnRpbCwgc3RhcnRXaXRoLCBwYWlyd2lzZSwgc3dpdGNoTWFwLCBzaGFyZVJlcGxheSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCAqIGFzIGkxIGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBnZXRSdGxTY3JvbGxBeGlzVHlwZSwgc3VwcG9ydHNTY3JvbGxCZWhhdmlvciwgUGxhdGZvcm0gfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0ICogYXMgaTIgZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgQmlkaU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCAqIGFzIGkyJDEgZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IGlzRGF0YVNvdXJjZSwgQXJyYXlEYXRhU291cmNlLCBfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgX1JlY3ljbGVWaWV3UmVwZWF0ZXJTdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIFRoZSBpbmplY3Rpb24gdG9rZW4gdXNlZCB0byBzcGVjaWZ5IHRoZSB2aXJ0dWFsIHNjcm9sbGluZyBzdHJhdGVneS4gKi9cbmNvbnN0IFZJUlRVQUxfU0NST0xMX1NUUkFURUdZID0gbmV3IEluamVjdGlvblRva2VuKCdWSVJUVUFMX1NDUk9MTF9TVFJBVEVHWScpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKiBWaXJ0dWFsIHNjcm9sbGluZyBzdHJhdGVneSBmb3IgbGlzdHMgd2l0aCBpdGVtcyBvZiBrbm93biBmaXhlZCBzaXplLiAqL1xuY2xhc3MgRml4ZWRTaXplVmlydHVhbFNjcm9sbFN0cmF0ZWd5IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaXRlbVNpemUgVGhlIHNpemUgb2YgdGhlIGl0ZW1zIGluIHRoZSB2aXJ0dWFsbHkgc2Nyb2xsaW5nIGxpc3QuXG4gICAgICogQHBhcmFtIG1pbkJ1ZmZlclB4IFRoZSBtaW5pbXVtIGFtb3VudCBvZiBidWZmZXIgKGluIHBpeGVscykgYmVmb3JlIG5lZWRpbmcgdG8gcmVuZGVyIG1vcmVcbiAgICAgKiBAcGFyYW0gbWF4QnVmZmVyUHggVGhlIGFtb3VudCBvZiBidWZmZXIgKGluIHBpeGVscykgdG8gcmVuZGVyIHdoZW4gcmVuZGVyaW5nIG1vcmUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaXRlbVNpemUsIG1pbkJ1ZmZlclB4LCBtYXhCdWZmZXJQeCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxlZEluZGV4Q2hhbmdlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kuICovXG4gICAgICAgIHRoaXMuc2Nyb2xsZWRJbmRleENoYW5nZSA9IHRoaXMuX3Njcm9sbGVkSW5kZXhDaGFuZ2UucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgICAgICAgLyoqIFRoZSBhdHRhY2hlZCB2aWV3cG9ydC4gKi9cbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgICAgICB0aGlzLl9taW5CdWZmZXJQeCA9IG1pbkJ1ZmZlclB4O1xuICAgICAgICB0aGlzLl9tYXhCdWZmZXJQeCA9IG1heEJ1ZmZlclB4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGlzIHNjcm9sbCBzdHJhdGVneSB0byBhIHZpZXdwb3J0LlxuICAgICAqIEBwYXJhbSB2aWV3cG9ydCBUaGUgdmlld3BvcnQgdG8gYXR0YWNoIHRoaXMgc3RyYXRlZ3kgdG8uXG4gICAgICovXG4gICAgYXR0YWNoKHZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRvdGFsQ29udGVudFNpemUoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRSYW5nZSgpO1xuICAgIH1cbiAgICAvKiogRGV0YWNoZXMgdGhpcyBzY3JvbGwgc3RyYXRlZ3kgZnJvbSB0aGUgY3VycmVudGx5IGF0dGFjaGVkIHZpZXdwb3J0LiAqL1xuICAgIGRldGFjaCgpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWRJbmRleENoYW5nZS5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgaXRlbSBzaXplIGFuZCBidWZmZXIgc2l6ZS5cbiAgICAgKiBAcGFyYW0gaXRlbVNpemUgVGhlIHNpemUgb2YgdGhlIGl0ZW1zIGluIHRoZSB2aXJ0dWFsbHkgc2Nyb2xsaW5nIGxpc3QuXG4gICAgICogQHBhcmFtIG1pbkJ1ZmZlclB4IFRoZSBtaW5pbXVtIGFtb3VudCBvZiBidWZmZXIgKGluIHBpeGVscykgYmVmb3JlIG5lZWRpbmcgdG8gcmVuZGVyIG1vcmVcbiAgICAgKiBAcGFyYW0gbWF4QnVmZmVyUHggVGhlIGFtb3VudCBvZiBidWZmZXIgKGluIHBpeGVscykgdG8gcmVuZGVyIHdoZW4gcmVuZGVyaW5nIG1vcmUuXG4gICAgICovXG4gICAgdXBkYXRlSXRlbUFuZEJ1ZmZlclNpemUoaXRlbVNpemUsIG1pbkJ1ZmZlclB4LCBtYXhCdWZmZXJQeCkge1xuICAgICAgICBpZiAobWF4QnVmZmVyUHggPCBtaW5CdWZmZXJQeCAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NESyB2aXJ0dWFsIHNjcm9sbDogbWF4QnVmZmVyUHggbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gbWluQnVmZmVyUHgnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgICAgICB0aGlzLl9taW5CdWZmZXJQeCA9IG1pbkJ1ZmZlclB4O1xuICAgICAgICB0aGlzLl9tYXhCdWZmZXJQeCA9IG1heEJ1ZmZlclB4O1xuICAgICAgICB0aGlzLl91cGRhdGVUb3RhbENvbnRlbnRTaXplKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kuICovXG4gICAgb25Db250ZW50U2Nyb2xsZWQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kuICovXG4gICAgb25EYXRhTGVuZ3RoQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlVG90YWxDb250ZW50U2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVSZW5kZXJlZFJhbmdlKCk7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgVmlydHVhbFNjcm9sbFN0cmF0ZWd5LiAqL1xuICAgIG9uQ29udGVudFJlbmRlcmVkKCkge1xuICAgICAgICAvKiBuby1vcCAqL1xuICAgIH1cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIFZpcnR1YWxTY3JvbGxTdHJhdGVneS4gKi9cbiAgICBvblJlbmRlcmVkT2Zmc2V0Q2hhbmdlZCgpIHtcbiAgICAgICAgLyogbm8tb3AgKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBvZmZzZXQgZm9yIHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKiBAcGFyYW0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHNjcm9sbCB0by5cbiAgICAgKiBAcGFyYW0gYmVoYXZpb3IgVGhlIFNjcm9sbEJlaGF2aW9yIHRvIHVzZSB3aGVuIHNjcm9sbGluZy5cbiAgICAgKi9cbiAgICBzY3JvbGxUb0luZGV4KGluZGV4LCBiZWhhdmlvcikge1xuICAgICAgICBpZiAodGhpcy5fdmlld3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LnNjcm9sbFRvT2Zmc2V0KGluZGV4ICogdGhpcy5faXRlbVNpemUsIGJlaGF2aW9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSB2aWV3cG9ydCdzIHRvdGFsIGNvbnRlbnQgc2l6ZS4gKi9cbiAgICBfdXBkYXRlVG90YWxDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0LnNldFRvdGFsQ29udGVudFNpemUodGhpcy5fdmlld3BvcnQuZ2V0RGF0YUxlbmd0aCgpICogdGhpcy5faXRlbVNpemUpO1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSB2aWV3cG9ydCdzIHJlbmRlcmVkIHJhbmdlLiAqL1xuICAgIF91cGRhdGVSZW5kZXJlZFJhbmdlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyZWRSYW5nZSA9IHRoaXMuX3ZpZXdwb3J0LmdldFJlbmRlcmVkUmFuZ2UoKTtcbiAgICAgICAgY29uc3QgbmV3UmFuZ2UgPSB7IHN0YXJ0OiByZW5kZXJlZFJhbmdlLnN0YXJ0LCBlbmQ6IHJlbmRlcmVkUmFuZ2UuZW5kIH07XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0U2l6ZSA9IHRoaXMuX3ZpZXdwb3J0LmdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gdGhpcy5fdmlld3BvcnQuZ2V0RGF0YUxlbmd0aCgpO1xuICAgICAgICBsZXQgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5fdmlld3BvcnQubWVhc3VyZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAvLyBQcmV2ZW50IE5hTiBhcyByZXN1bHQgd2hlbiBkaXZpZGluZyBieSB6ZXJvLlxuICAgICAgICBsZXQgZmlyc3RWaXNpYmxlSW5kZXggPSB0aGlzLl9pdGVtU2l6ZSA+IDAgPyBzY3JvbGxPZmZzZXQgLyB0aGlzLl9pdGVtU2l6ZSA6IDA7XG4gICAgICAgIC8vIElmIHVzZXIgc2Nyb2xscyB0byB0aGUgYm90dG9tIG9mIHRoZSBsaXN0IGFuZCBkYXRhIGNoYW5nZXMgdG8gYSBzbWFsbGVyIGxpc3RcbiAgICAgICAgaWYgKG5ld1JhbmdlLmVuZCA+IGRhdGFMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlIGZpcnN0IHZpc2libGUgaW5kZXggYmFzZWQgb24gbmV3IGRhdGEgbGVuZ3RoIGFuZCB2aWV3cG9ydCBzaXplLlxuICAgICAgICAgICAgY29uc3QgbWF4VmlzaWJsZUl0ZW1zID0gTWF0aC5jZWlsKHZpZXdwb3J0U2l6ZSAvIHRoaXMuX2l0ZW1TaXplKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Zpc2libGVJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGZpcnN0VmlzaWJsZUluZGV4LCBkYXRhTGVuZ3RoIC0gbWF4VmlzaWJsZUl0ZW1zKSk7XG4gICAgICAgICAgICAvLyBJZiBmaXJzdCB2aXNpYmxlIGluZGV4IGNoYW5nZWQgd2UgbXVzdCB1cGRhdGUgc2Nyb2xsIG9mZnNldCB0byBoYW5kbGUgc3RhcnQvZW5kIGJ1ZmZlcnNcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgcmFuZ2UgbXVzdCBhbHNvIGJlIGFkanVzdGVkIHRvIGNvdmVyIHRoZSBuZXcgcG9zaXRpb24gKGJvdHRvbSBvZiBuZXcgbGlzdCkuXG4gICAgICAgICAgICBpZiAoZmlyc3RWaXNpYmxlSW5kZXggIT0gbmV3VmlzaWJsZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RWaXNpYmxlSW5kZXggPSBuZXdWaXNpYmxlSW5kZXg7XG4gICAgICAgICAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gbmV3VmlzaWJsZUluZGV4ICogdGhpcy5faXRlbVNpemU7XG4gICAgICAgICAgICAgICAgbmV3UmFuZ2Uuc3RhcnQgPSBNYXRoLmZsb29yKGZpcnN0VmlzaWJsZUluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JhbmdlLmVuZCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGRhdGFMZW5ndGgsIG5ld1JhbmdlLnN0YXJ0ICsgbWF4VmlzaWJsZUl0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRCdWZmZXIgPSBzY3JvbGxPZmZzZXQgLSBuZXdSYW5nZS5zdGFydCAqIHRoaXMuX2l0ZW1TaXplO1xuICAgICAgICBpZiAoc3RhcnRCdWZmZXIgPCB0aGlzLl9taW5CdWZmZXJQeCAmJiBuZXdSYW5nZS5zdGFydCAhPSAwKSB7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRTdGFydCA9IE1hdGguY2VpbCgodGhpcy5fbWF4QnVmZmVyUHggLSBzdGFydEJ1ZmZlcikgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zdGFydCA9IE1hdGgubWF4KDAsIG5ld1JhbmdlLnN0YXJ0IC0gZXhwYW5kU3RhcnQpO1xuICAgICAgICAgICAgbmV3UmFuZ2UuZW5kID0gTWF0aC5taW4oZGF0YUxlbmd0aCwgTWF0aC5jZWlsKGZpcnN0VmlzaWJsZUluZGV4ICsgKHZpZXdwb3J0U2l6ZSArIHRoaXMuX21pbkJ1ZmZlclB4KSAvIHRoaXMuX2l0ZW1TaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbmRCdWZmZXIgPSBuZXdSYW5nZS5lbmQgKiB0aGlzLl9pdGVtU2l6ZSAtIChzY3JvbGxPZmZzZXQgKyB2aWV3cG9ydFNpemUpO1xuICAgICAgICAgICAgaWYgKGVuZEJ1ZmZlciA8IHRoaXMuX21pbkJ1ZmZlclB4ICYmIG5ld1JhbmdlLmVuZCAhPSBkYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwYW5kRW5kID0gTWF0aC5jZWlsKCh0aGlzLl9tYXhCdWZmZXJQeCAtIGVuZEJ1ZmZlcikgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEVuZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2UuZW5kID0gTWF0aC5taW4oZGF0YUxlbmd0aCwgbmV3UmFuZ2UuZW5kICsgZXhwYW5kRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2Uuc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKGZpcnN0VmlzaWJsZUluZGV4IC0gdGhpcy5fbWluQnVmZmVyUHggLyB0aGlzLl9pdGVtU2l6ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3cG9ydC5zZXRSZW5kZXJlZFJhbmdlKG5ld1JhbmdlKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQuc2V0UmVuZGVyZWRDb250ZW50T2Zmc2V0KHRoaXMuX2l0ZW1TaXplICogbmV3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB0aGlzLl9zY3JvbGxlZEluZGV4Q2hhbmdlLm5leHQoTWF0aC5mbG9vcihmaXJzdFZpc2libGVJbmRleCkpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdmlkZXIgZmFjdG9yeSBmb3IgYEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAgdGhhdCBzaW1wbHkgZXh0cmFjdHMgdGhlIGFscmVhZHkgY3JlYXRlZFxuICogYEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAgZnJvbSB0aGUgZ2l2ZW4gZGlyZWN0aXZlLlxuICogQHBhcmFtIGZpeGVkU2l6ZURpciBUaGUgaW5zdGFuY2Ugb2YgYENka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxgIHRvIGV4dHJhY3QgdGhlXG4gKiAgICAgYEZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneWAgZnJvbS5cbiAqL1xuZnVuY3Rpb24gX2ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneUZhY3RvcnkoZml4ZWRTaXplRGlyKSB7XG4gICAgcmV0dXJuIGZpeGVkU2l6ZURpci5fc2Nyb2xsU3RyYXRlZ3k7XG59XG4vKiogQSB2aXJ0dWFsIHNjcm9sbCBzdHJhdGVneSB0aGF0IHN1cHBvcnRzIGZpeGVkLXNpemUgaXRlbXMuICovXG5jbGFzcyBDZGtGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXRlbVNpemUgPSAyMDtcbiAgICAgICAgdGhpcy5fbWluQnVmZmVyUHggPSAxMDA7XG4gICAgICAgIHRoaXMuX21heEJ1ZmZlclB4ID0gMjAwO1xuICAgICAgICAvKiogVGhlIHNjcm9sbCBzdHJhdGVneSB1c2VkIGJ5IHRoaXMgZGlyZWN0aXZlLiAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneSA9IG5ldyBGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3kodGhpcy5pdGVtU2l6ZSwgdGhpcy5taW5CdWZmZXJQeCwgdGhpcy5tYXhCdWZmZXJQeCk7XG4gICAgfVxuICAgIC8qKiBUaGUgc2l6ZSBvZiB0aGUgaXRlbXMgaW4gdGhlIGxpc3QgKGluIHBpeGVscykuICovXG4gICAgZ2V0IGl0ZW1TaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbVNpemU7XG4gICAgfVxuICAgIHNldCBpdGVtU2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gYW1vdW50IG9mIGJ1ZmZlciByZW5kZXJlZCBiZXlvbmQgdGhlIHZpZXdwb3J0IChpbiBwaXhlbHMpLlxuICAgICAqIElmIHRoZSBhbW91bnQgb2YgYnVmZmVyIGRpcHMgYmVsb3cgdGhpcyBudW1iZXIsIG1vcmUgaXRlbXMgd2lsbCBiZSByZW5kZXJlZC4gRGVmYXVsdHMgdG8gMTAwcHguXG4gICAgICovXG4gICAgZ2V0IG1pbkJ1ZmZlclB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluQnVmZmVyUHg7XG4gICAgfVxuICAgIHNldCBtaW5CdWZmZXJQeCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9taW5CdWZmZXJQeCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBwaXhlbHMgd29ydGggb2YgYnVmZmVyIHRvIHJlbmRlciBmb3Igd2hlbiByZW5kZXJpbmcgbmV3IGl0ZW1zLiBEZWZhdWx0cyB0byAyMDBweC5cbiAgICAgKi9cbiAgICBnZXQgbWF4QnVmZmVyUHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhCdWZmZXJQeDtcbiAgICB9XG4gICAgc2V0IG1heEJ1ZmZlclB4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21heEJ1ZmZlclB4ID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kudXBkYXRlSXRlbUFuZEJ1ZmZlclNpemUodGhpcy5pdGVtU2l6ZSwgdGhpcy5taW5CdWZmZXJQeCwgdGhpcy5tYXhCdWZmZXJQeCk7XG4gICAgfVxufVxuQ2RrRml4ZWRTaXplVmlydHVhbFNjcm9sbC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGwsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGwuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsLCBpc1N0YW5kYWxvbmU6IHRydWUsIHNlbGVjdG9yOiBcImNkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydFtpdGVtU2l6ZV1cIiwgaW5wdXRzOiB7IGl0ZW1TaXplOiBcIml0ZW1TaXplXCIsIG1pbkJ1ZmZlclB4OiBcIm1pbkJ1ZmZlclB4XCIsIG1heEJ1ZmZlclB4OiBcIm1heEJ1ZmZlclB4XCIgfSwgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFZJUlRVQUxfU0NST0xMX1NUUkFURUdZLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogX2ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneUZhY3RvcnksXG4gICAgICAgICAgICBkZXBzOiBbZm9yd2FyZFJlZigoKSA9PiBDZGtGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsKV0sXG4gICAgICAgIH0sXG4gICAgXSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrRml4ZWRTaXplVmlydHVhbFNjcm9sbCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0W2l0ZW1TaXplXScsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFZJUlRVQUxfU0NST0xMX1NUUkFURUdZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IF9maXhlZFNpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3lGYWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHM6IFtmb3J3YXJkUmVmKCgpID0+IENka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGwpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IGl0ZW1TaXplOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgbWluQnVmZmVyUHg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBtYXhCdWZmZXJQeDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsaW5nIGV2ZW50cyBieSBkZWZhdWx0LiAqL1xuY29uc3QgREVGQVVMVF9TQ1JPTExfVElNRSA9IDIwO1xuLyoqXG4gKiBTZXJ2aWNlIGNvbnRhaW5lZCBhbGwgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlIHJlZmVyZW5jZXMgYW5kIGVtaXRzIGFuIGV2ZW50IHdoZW4gYW55IG9uZSBvZiB0aGVcbiAqIFNjcm9sbGFibGUgcmVmZXJlbmNlcyBlbWl0IGEgc2Nyb2xsZWQgZXZlbnQuXG4gKi9cbmNsYXNzIFNjcm9sbERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKF9uZ1pvbmUsIF9wbGF0Zm9ybSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fbmdab25lID0gX25nWm9uZTtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIC8qKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhhdCBhIHJlZ2lzdGVyZWQgc2Nyb2xsYWJsZSByZWZlcmVuY2UgZWxlbWVudCBoYXMgYmVlbiBzY3JvbGxlZC4gKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAvKiogS2VlcHMgdHJhY2sgb2YgdGhlIGdsb2JhbCBgc2Nyb2xsYCBhbmQgYHJlc2l6ZWAgc3Vic2NyaXB0aW9ucy4gKi9cbiAgICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBhbW91bnQgb2Ygc3Vic2NyaXB0aW9ucyB0byBgc2Nyb2xsZWRgLiBVc2VkIGZvciBjbGVhbmluZyB1cCBhZnRlcndhcmRzLiAqL1xuICAgICAgICB0aGlzLl9zY3JvbGxlZENvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcCBvZiBhbGwgdGhlIHNjcm9sbGFibGUgcmVmZXJlbmNlcyB0aGF0IGFyZSByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2UgYW5kIHRoZWlyXG4gICAgICAgICAqIHNjcm9sbCBldmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBzY3JvbGxhYmxlIGluc3RhbmNlIHdpdGggdGhlIHNlcnZpY2UgYW5kIGxpc3RlbnMgZm9yIGl0cyBzY3JvbGxlZCBldmVudHMuIFdoZW4gdGhlXG4gICAgICogc2Nyb2xsYWJsZSBpcyBzY3JvbGxlZCwgdGhlIHNlcnZpY2UgZW1pdHMgdGhlIGV2ZW50IHRvIGl0cyBzY3JvbGxlZCBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSBzY3JvbGxhYmxlIFNjcm9sbGFibGUgaW5zdGFuY2UgdG8gYmUgcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICByZWdpc3RlcihzY3JvbGxhYmxlKSB7XG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxDb250YWluZXJzLmhhcyhzY3JvbGxhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXJzLnNldChzY3JvbGxhYmxlLCBzY3JvbGxhYmxlLmVsZW1lbnRTY3JvbGxlZCgpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zY3JvbGxlZC5uZXh0KHNjcm9sbGFibGUpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGUtcmVnaXN0ZXJzIGEgU2Nyb2xsYWJsZSByZWZlcmVuY2UgYW5kIHVuc3Vic2NyaWJlcyBmcm9tIGl0cyBzY3JvbGwgZXZlbnQgb2JzZXJ2YWJsZS5cbiAgICAgKiBAcGFyYW0gc2Nyb2xsYWJsZSBTY3JvbGxhYmxlIGluc3RhbmNlIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAgICAgKi9cbiAgICBkZXJlZ2lzdGVyKHNjcm9sbGFibGUpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVJlZmVyZW5jZSA9IHRoaXMuc2Nyb2xsQ29udGFpbmVycy5nZXQoc2Nyb2xsYWJsZSk7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBzY3JvbGxhYmxlUmVmZXJlbmNlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lcnMuZGVsZXRlKHNjcm9sbGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGV2ZW50IHdoZW5ldmVyIGFueSBvZiB0aGUgcmVnaXN0ZXJlZCBTY3JvbGxhYmxlXG4gICAgICogcmVmZXJlbmNlcyAob3Igd2luZG93LCBkb2N1bWVudCwgb3IgYm9keSkgZmlyZSBhIHNjcm9sbGVkIGV2ZW50LiBDYW4gcHJvdmlkZSBhIHRpbWUgaW4gbXNcbiAgICAgKiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBcInRocm90dGxlXCIgdGltZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBpbiBvcmRlciB0byBhdm9pZCBoaXR0aW5nIGNoYW5nZSBkZXRlY3Rpb24gZm9yIGV2ZXJ5IHNjcm9sbCBldmVudCxcbiAgICAgKiBhbGwgb2YgdGhlIGV2ZW50cyBlbWl0dGVkIGZyb20gdGhpcyBzdHJlYW0gd2lsbCBiZSBydW4gb3V0c2lkZSB0aGUgQW5ndWxhciB6b25lLlxuICAgICAqIElmIHlvdSBuZWVkIHRvIHVwZGF0ZSBhbnkgZGF0YSBiaW5kaW5ncyBhcyBhIHJlc3VsdCBvZiBhIHNjcm9sbCBldmVudCwgeW91IGhhdmVcbiAgICAgKiB0byBydW4gdGhlIGNhbGxiYWNrIHVzaW5nIGBOZ1pvbmUucnVuYC5cbiAgICAgKi9cbiAgICBzY3JvbGxlZChhdWRpdFRpbWVJbk1zID0gREVGQVVMVF9TQ1JPTExfVElNRSkge1xuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIG9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9nbG9iYWxTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRHbG9iYWxMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSAwbXMgZGVsYXksIHVzZSBhbiBvYnNlcnZhYmxlIHdpdGhvdXQgYXVkaXRUaW1lXG4gICAgICAgICAgICAvLyBzaW5jZSBpdCBkb2VzIGFkZCBhIHBlcmNlcHRpYmxlIGRlbGF5IGluIHByb2Nlc3Npbmcgb3ZlcmhlYWQuXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhdWRpdFRpbWVJbk1zID4gMFxuICAgICAgICAgICAgICAgID8gdGhpcy5fc2Nyb2xsZWQucGlwZShhdWRpdFRpbWUoYXVkaXRUaW1lSW5NcykpLnN1YnNjcmliZShvYnNlcnZlcilcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3Njcm9sbGVkLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxlZENvdW50Kys7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbGVkQ291bnQtLTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbGVkQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlR2xvYmFsTGlzdGVuZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUdsb2JhbExpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVycy5mb3JFYWNoKChfLCBjb250YWluZXIpID0+IHRoaXMuZGVyZWdpc3Rlcihjb250YWluZXIpKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsZWQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbmV2ZXIgYW55IG9mIHRoZVxuICAgICAqIHNjcm9sbGFibGUgYW5jZXN0b3JzIG9mIGFuIGVsZW1lbnQgYXJlIHNjcm9sbGVkLlxuICAgICAqIEBwYXJhbSBlbGVtZW50T3JFbGVtZW50UmVmIEVsZW1lbnQgd2hvc2UgYW5jZXN0b3JzIHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIGF1ZGl0VGltZUluTXMgVGltZSB0byB0aHJvdHRsZSB0aGUgc2Nyb2xsIGV2ZW50cy5cbiAgICAgKi9cbiAgICBhbmNlc3RvclNjcm9sbGVkKGVsZW1lbnRPckVsZW1lbnRSZWYsIGF1ZGl0VGltZUluTXMpIHtcbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gdGhpcy5nZXRBbmNlc3RvclNjcm9sbENvbnRhaW5lcnMoZWxlbWVudE9yRWxlbWVudFJlZik7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbGVkKGF1ZGl0VGltZUluTXMpLnBpcGUoZmlsdGVyKHRhcmdldCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIXRhcmdldCB8fCBhbmNlc3RvcnMuaW5kZXhPZih0YXJnZXQpID4gLTE7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIHJlZ2lzdGVyZWQgU2Nyb2xsYWJsZXMgdGhhdCBjb250YWluIHRoZSBwcm92aWRlZCBlbGVtZW50LiAqL1xuICAgIGdldEFuY2VzdG9yU2Nyb2xsQ29udGFpbmVycyhlbGVtZW50T3JFbGVtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGluZ0NvbnRhaW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXJzLmZvckVhY2goKF9zdWJzY3JpcHRpb24sIHNjcm9sbGFibGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY3JvbGxhYmxlQ29udGFpbnNFbGVtZW50KHNjcm9sbGFibGUsIGVsZW1lbnRPckVsZW1lbnRSZWYpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsaW5nQ29udGFpbmVycy5wdXNoKHNjcm9sbGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbGluZ0NvbnRhaW5lcnM7XG4gICAgfVxuICAgIC8qKiBVc2UgZGVmYXVsdFZpZXcgb2YgaW5qZWN0ZWQgZG9jdW1lbnQgaWYgYXZhaWxhYmxlIG9yIGZhbGxiYWNrIHRvIGdsb2JhbCB3aW5kb3cgcmVmZXJlbmNlICovXG4gICAgX2dldFdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBTY3JvbGxhYmxlLiAqL1xuICAgIF9zY3JvbGxhYmxlQ29udGFpbnNFbGVtZW50KHNjcm9sbGFibGUsIGVsZW1lbnRPckVsZW1lbnRSZWYpIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBjb2VyY2VFbGVtZW50KGVsZW1lbnRPckVsZW1lbnRSZWYpO1xuICAgICAgICBsZXQgc2Nyb2xsYWJsZUVsZW1lbnQgPSBzY3JvbGxhYmxlLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBUcmF2ZXJzZSB0aHJvdWdoIHRoZSBlbGVtZW50IHBhcmVudHMgdW50aWwgd2UgcmVhY2ggbnVsbCwgY2hlY2tpbmcgaWYgYW55IG9mIHRoZSBlbGVtZW50c1xuICAgICAgICAvLyBhcmUgdGhlIHNjcm9sbGFibGUncyBlbGVtZW50LlxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCA9PSBzY3JvbGxhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBTZXRzIHVwIHRoZSBnbG9iYWwgc2Nyb2xsIGxpc3RlbmVycy4gKi9cbiAgICBfYWRkR2xvYmFsTGlzdGVuZXIoKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbiA9IHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLl9nZXRXaW5kb3coKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tRXZlbnQod2luZG93LmRvY3VtZW50LCAnc2Nyb2xsJykuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3Njcm9sbGVkLm5leHQoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQ2xlYW5zIHVwIHRoZSBnbG9iYWwgc2Nyb2xsIGxpc3RlbmVyLiAqL1xuICAgIF9yZW1vdmVHbG9iYWxMaXN0ZW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dsb2JhbFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuU2Nyb2xsRGlzcGF0Y2hlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIGRlcHM6IFt7IHRva2VuOiBpMC5OZ1pvbmUgfSwgeyB0b2tlbjogaTEuUGxhdGZvcm0gfSwgeyB0b2tlbjogRE9DVU1FTlQsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5TY3JvbGxEaXNwYXRjaGVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIHByb3ZpZGVkSW46ICdyb290JyB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNjcm9sbERpc3BhdGNoZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogaTEuUGxhdGZvcm0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFNlbmRzIGFuIGV2ZW50IHdoZW4gdGhlIGRpcmVjdGl2ZSdzIGVsZW1lbnQgaXMgc2Nyb2xsZWQuIFJlZ2lzdGVycyBpdHNlbGYgd2l0aCB0aGVcbiAqIFNjcm9sbERpc3BhdGNoZXIgc2VydmljZSB0byBpbmNsdWRlIGl0c2VsZiBhcyBwYXJ0IG9mIGl0cyBjb2xsZWN0aW9uIG9mIHNjcm9sbGluZyBldmVudHMgdGhhdCBpdFxuICogY2FuIGJlIGxpc3RlbmVkIHRvIHRocm91Z2ggdGhlIHNlcnZpY2UuXG4gKi9cbmNsYXNzIENka1Njcm9sbGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWYsIHNjcm9sbERpc3BhdGNoZXIsIG5nWm9uZSwgZGlyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzcGF0Y2hlciA9IHNjcm9sbERpc3BhdGNoZXI7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFNjcm9sbGVkID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBmcm9tRXZlbnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdzY3JvbGwnKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9ic2VydmVyKSkpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxEaXNwYXRjaGVyLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxEaXNwYXRjaGVyLmRlcmVnaXN0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hlbiBhIHNjcm9sbCBldmVudCBpcyBmaXJlZCBvbiB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICAgIGVsZW1lbnRTY3JvbGxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRTY3JvbGxlZDtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIEVsZW1lbnRSZWYgZm9yIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBnZXRFbGVtZW50UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy4gVGhpcyBpcyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUb1xuICAgICAqIG1ldGhvZCwgc2luY2UgYnJvd3NlcnMgYXJlIG5vdCBjb25zaXN0ZW50IGFib3V0IHdoYXQgc2Nyb2xsTGVmdCBtZWFucyBpbiBSVEwuIEZvciB0aGlzIG1ldGhvZFxuICAgICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcbiAgICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxuICAgICAqIGluIGFuIFJUTCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHNwZWNpZmllZCB0aGUgb2Zmc2V0cyB0byBzY3JvbGwgdG8uXG4gICAgICovXG4gICAgc2Nyb2xsVG8ob3B0aW9ucykge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBpc1J0bCA9IHRoaXMuZGlyICYmIHRoaXMuZGlyLnZhbHVlID09ICdydGwnO1xuICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IGlzUnRsID8gb3B0aW9ucy5lbmQgOiBvcHRpb25zLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmlnaHQgPSBpc1J0bCA/IG9wdGlvbnMuc3RhcnQgOiBvcHRpb25zLmVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cbiAgICAgICAgaWYgKG9wdGlvbnMuYm90dG9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9wID1cbiAgICAgICAgICAgICAgICBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBvcHRpb25zLmJvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXdyaXRlIHRoZSByaWdodCBvZmZzZXQgYXMgYSBsZWZ0IG9mZnNldC5cbiAgICAgICAgaWYgKGlzUnRsICYmIGdldFJ0bFNjcm9sbEF4aXNUeXBlKCkgIT0gMCAvKiBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwgKi8pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmlnaHQgPVxuICAgICAgICAgICAgICAgICAgICBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFJ0bFNjcm9sbEF4aXNUeXBlKCkgPT0gMiAvKiBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCAqLykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChnZXRSdGxTY3JvbGxBeGlzVHlwZSgpID09IDEgLyogUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCAqLykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQgPyAtb3B0aW9ucy5yaWdodCA6IG9wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sZWZ0ID1cbiAgICAgICAgICAgICAgICAgICAgZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwbHlTY3JvbGxUb09wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICAgIF9hcHBseVNjcm9sbFRvT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgICAgIGVsLnNjcm9sbFRvKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9wICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbC5zY3JvbGxUb3AgPSBvcHRpb25zLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVsLnNjcm9sbExlZnQgPSBvcHRpb25zLmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgdGhlIHNjcm9sbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHNwZWNpZmllZCBlZGdlIG9mIHRoZSB2aWV3cG9ydC4gVGhpcyBtZXRob2QgY2FuIGJlXG4gICAgICogdXNlZCBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNoZWNraW5nIHNjcm9sbExlZnQgb3Igc2Nyb2xsVG9wLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnRcbiAgICAgKiBhYm91dCB3aGF0IHNjcm9sbExlZnQgbWVhbnMgaW4gUlRMLiBUaGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGFyZSBub3JtYWxpemVkIHN1Y2ggdGhhdFxuICAgICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcbiAgICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxuICAgICAqIGluIGFuIFJUTCBjb250ZXh0LlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBlZGdlIHRvIG1lYXN1cmUgZnJvbS5cbiAgICAgKi9cbiAgICBtZWFzdXJlU2Nyb2xsT2Zmc2V0KGZyb20pIHtcbiAgICAgICAgY29uc3QgTEVGVCA9ICdsZWZ0JztcbiAgICAgICAgY29uc3QgUklHSFQgPSAncmlnaHQnO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoZnJvbSA9PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJvbSA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIGVsLnNjcm9sbEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCAtIGVsLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIGFzIGxlZnQgb3IgcmlnaHQgb2Zmc2V0cy5cbiAgICAgICAgY29uc3QgaXNSdGwgPSB0aGlzLmRpciAmJiB0aGlzLmRpci52YWx1ZSA9PSAncnRsJztcbiAgICAgICAgaWYgKGZyb20gPT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgZnJvbSA9IGlzUnRsID8gUklHSFQgOiBMRUZUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb20gPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIGZyb20gPSBpc1J0bCA/IExFRlQgOiBSSUdIVDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwgJiYgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKSA9PSAyIC8qIFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEICovKSB7XG4gICAgICAgICAgICAvLyBGb3IgSU5WRVJURUQsIHNjcm9sbExlZnQgaXMgKHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGgpIHdoZW4gc2Nyb2xsZWQgYWxsIHRoZSB3YXkgbGVmdCBhbmRcbiAgICAgICAgICAgIC8vIDAgd2hlbiBzY3JvbGxlZCBhbGwgdGhlIHdheSByaWdodC5cbiAgICAgICAgICAgIGlmIChmcm9tID09IExFRlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIGVsLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1J0bCAmJiBnZXRSdGxTY3JvbGxBeGlzVHlwZSgpID09IDEgLyogUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCAqLykge1xuICAgICAgICAgICAgLy8gRm9yIE5FR0FURUQsIHNjcm9sbExlZnQgaXMgLShzY3JvbGxXaWR0aCAtIGNsaWVudFdpZHRoKSB3aGVuIHNjcm9sbGVkIGFsbCB0aGUgd2F5IGxlZnQgYW5kXG4gICAgICAgICAgICAvLyAwIHdoZW4gc2Nyb2xsZWQgYWxsIHRoZSB3YXkgcmlnaHQuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PSBMRUZUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLnNjcm9sbExlZnQgKyBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC1lbC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIE5PUk1BTCwgYXMgd2VsbCBhcyBub24tUlRMIGNvbnRleHRzLCBzY3JvbGxMZWZ0IGlzIDAgd2hlbiBzY3JvbGxlZCBhbGwgdGhlIHdheSBsZWZ0IGFuZFxuICAgICAgICAgICAgLy8gKHNjcm9sbFdpZHRoIC0gY2xpZW50V2lkdGgpIHdoZW4gc2Nyb2xsZWQgYWxsIHRoZSB3YXkgcmlnaHQuXG4gICAgICAgICAgICBpZiAoZnJvbSA9PSBMRUZUKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIGVsLnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5DZGtTY3JvbGxhYmxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrU2Nyb2xsYWJsZSwgZGVwczogW3sgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogU2Nyb2xsRGlzcGF0Y2hlciB9LCB7IHRva2VuOiBpMC5OZ1pvbmUgfSwgeyB0b2tlbjogaTIuRGlyZWN0aW9uYWxpdHksIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka1Njcm9sbGFibGUuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtTY3JvbGxhYmxlLCBpc1N0YW5kYWxvbmU6IHRydWUsIHNlbGVjdG9yOiBcIltjZGstc2Nyb2xsYWJsZV0sIFtjZGtTY3JvbGxhYmxlXVwiLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtTY3JvbGxhYmxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrLXNjcm9sbGFibGVdLCBbY2RrU2Nyb2xsYWJsZV0nLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIgfSwgeyB0eXBlOiBpMC5OZ1pvbmUgfSwgeyB0eXBlOiBpMi5EaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogVGltZSBpbiBtcyB0byB0aHJvdHRsZSB0aGUgcmVzaXplIGV2ZW50cyBieSBkZWZhdWx0LiAqL1xuY29uc3QgREVGQVVMVF9SRVNJWkVfVElNRSA9IDIwO1xuLyoqXG4gKiBTaW1wbGUgdXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgYm91bmRzIG9mIHRoZSBicm93c2VyIHZpZXdwb3J0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jbGFzcyBWaWV3cG9ydFJ1bGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfcGxhdGZvcm0sIG5nWm9uZSwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBfcGxhdGZvcm07XG4gICAgICAgIC8qKiBTdHJlYW0gb2Ygdmlld3BvcnQgY2hhbmdlIGV2ZW50cy4gKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqIEV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGhhbmRsZSB0aGUgdmlld3BvcnQgY2hhbmdlIGV2ZW50cy4gKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlTGlzdGVuZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChfcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGJpbmQgdGhlIGV2ZW50cyBvdXJzZWx2ZXMsIHJhdGhlciB0aGFuIGdvaW5nIHRocm91Z2ggc29tZXRoaW5nIGxpa2UgUnhKUydzXG4gICAgICAgICAgICAgICAgLy8gYGZyb21FdmVudGAgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoYXQgdGhleSdyZSBib3VuZCBvdXRzaWRlIG9mIHRoZSBOZ1pvbmUuXG4gICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2NoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FjaGVkIHBvc2l0aW9uIHNvIHRoYXQgdGhlIHZpZXdwb3J0IGlzIHJlLW1lYXN1cmVkIG5leHQgdGltZSBpdCBpcyByZXF1aXJlZC5cbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3Vic2NyaXB0aW9uLCBiZWNhdXNlIGl0IGlzIGNvbXBsZXRlZCBvbiBkZXN0cm95LlxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoKS5zdWJzY3JpYmUoKCkgPT4gKHRoaXMuX3ZpZXdwb3J0U2l6ZSA9IG51bGwpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLl9nZXRXaW5kb3coKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9jaGFuZ2VMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRoZSB2aWV3cG9ydCdzIHdpZHRoIGFuZCBoZWlnaHQuICovXG4gICAgZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmlld3BvcnRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0geyB3aWR0aDogdGhpcy5fdmlld3BvcnRTaXplLndpZHRoLCBoZWlnaHQ6IHRoaXMuX3ZpZXdwb3J0U2l6ZS5oZWlnaHQgfTtcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IG9uIGEgYnJvd3NlciwgZG9uJ3QgY2FjaGUgdGhlIHNpemUgc2luY2UgaXQnbGwgYmUgbW9ja2VkIG91dCBhbnl3YXkuXG4gICAgICAgIGlmICghdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydFNpemUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKiBHZXRzIGEgQ2xpZW50UmVjdCBmb3IgdGhlIHZpZXdwb3J0J3MgYm91bmRzLiAqL1xuICAgIGdldFZpZXdwb3J0UmVjdCgpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBkb2N1bWVudCBlbGVtZW50J3MgYm91bmRpbmcgcmVjdCByYXRoZXIgdGhhbiB0aGUgd2luZG93IHNjcm9sbCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIChlLmcuIHBhZ2VZT2Zmc2V0LCBzY3JvbGxZKSBkdWUgdG8gaW4gaXNzdWUgaW4gQ2hyb21lIGFuZCBJRSB3aGVyZSB3aW5kb3cgc2Nyb2xsXG4gICAgICAgIC8vIHByb3BlcnRpZXMgYW5kIGNsaWVudCBjb29yZGluYXRlcyAoYm91bmRpbmdDbGllbnRSZWN0LCBjbGllbnRYL1ksIGV0Yy4pIGFyZSBpbiBkaWZmZXJlbnRcbiAgICAgICAgLy8gY29uY2VwdHVhbCB2aWV3cG9ydHMuIFVuZGVyIG1vc3QgY2lyY3Vtc3RhbmNlcyB0aGVzZSB2aWV3cG9ydHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCB0aGV5XG4gICAgICAgIC8vIGNhbiBkaXNhZ3JlZSB3aGVuIHRoZSBwYWdlIGlzIHBpbmNoLXpvb21lZCAob24gZGV2aWNlcyB0aGF0IHN1cHBvcnQgdG91Y2gpLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDg5MjA2I2M0XG4gICAgICAgIC8vIFdlIHVzZSB0aGUgZG9jdW1lbnRFbGVtZW50IGluc3RlYWQgb2YgdGhlIGJvZHkgYmVjYXVzZSwgYnkgZGVmYXVsdCAod2l0aG91dCBhIGNzcyByZXNldClcbiAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGdpdmUgdGhlIGRvY3VtZW50IGJvZHkgYW4gOHB4IG1hcmdpbiwgd2hpY2ggaXMgbm90IGluY2x1ZGVkIGluXG4gICAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLlxuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuZ2V0Vmlld3BvcnRTaXplKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHNjcm9sbFBvc2l0aW9uLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICBib3R0b206IHNjcm9sbFBvc2l0aW9uLnRvcCArIGhlaWdodCxcbiAgICAgICAgICAgIHJpZ2h0OiBzY3JvbGxQb3NpdGlvbi5sZWZ0ICsgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlICh0b3AsIGxlZnQpIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnQuICovXG4gICAgZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgLy8gV2hpbGUgd2UgY2FuIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgZmFrZSBkb2N1bWVudFxuICAgICAgICAvLyBkdXJpbmcgU1NSLCBpdCBkb2Vzbid0IGhhdmUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LlxuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRvcC1sZWZ0LWNvcm5lciBvZiB0aGUgdmlld3BvcnQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAvLyBib2R5LCBub3JtYWxseSBqdXN0IChzY3JvbGxMZWZ0LCBzY3JvbGxUb3ApLiBIb3dldmVyLCBDaHJvbWUgYW5kIEZpcmVmb3ggZGlzYWdyZWUgYWJvdXRcbiAgICAgICAgLy8gd2hldGhlciBgZG9jdW1lbnQuYm9keWAgb3IgYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgaXMgdGhlIHNjcm9sbGVkIGVsZW1lbnQsIHNvIHJlYWRpbmdcbiAgICAgICAgLy8gYHNjcm9sbFRvcGAgYW5kIGBzY3JvbGxMZWZ0YCBpcyBpbmNvbnNpc3RlbnQuIEhvd2V2ZXIsIHVzaW5nIHRoZSBib3VuZGluZyByZWN0IG9mXG4gICAgICAgIC8vIGBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRgIHdvcmtzIGNvbnNpc3RlbnRseSwgd2hlcmUgdGhlIGB0b3BgIGFuZCBgbGVmdGAgdmFsdWVzIHdpbGxcbiAgICAgICAgLy8gZXF1YWwgbmVnYXRpdmUgdGhlIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudDtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gdGhpcy5fZ2V0V2luZG93KCk7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRSZWN0ID0gZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0b3AgPSAtZG9jdW1lbnRSZWN0LnRvcCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHxcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxZIHx8XG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8XG4gICAgICAgICAgICAwO1xuICAgICAgICBjb25zdCBsZWZ0ID0gLWRvY3VtZW50UmVjdC5sZWZ0IHx8XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHxcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxYIHx8XG4gICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fFxuICAgICAgICAgICAgMDtcbiAgICAgICAgcmV0dXJuIHsgdG9wLCBsZWZ0IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gdGhhdCBlbWl0cyB3aGVuZXZlciB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgY2hhbmdlcy5cbiAgICAgKiBUaGlzIHN0cmVhbSBlbWl0cyBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICogQHBhcmFtIHRocm90dGxlVGltZSBUaW1lIGluIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGNoYW5nZSh0aHJvdHRsZVRpbWUgPSBERUZBVUxUX1JFU0laRV9USU1FKSB7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZVRpbWUgPiAwID8gdGhpcy5fY2hhbmdlLnBpcGUoYXVkaXRUaW1lKHRocm90dGxlVGltZSkpIDogdGhpcy5fY2hhbmdlO1xuICAgIH1cbiAgICAvKiogVXNlIGRlZmF1bHRWaWV3IG9mIGluamVjdGVkIGRvY3VtZW50IGlmIGF2YWlsYWJsZSBvciBmYWxsYmFjayB0byBnbG9iYWwgd2luZG93IHJlZmVyZW5jZSAqL1xuICAgIF9nZXRXaW5kb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgfVxuICAgIC8qKiBVcGRhdGVzIHRoZSBjYWNoZWQgdmlld3BvcnQgc2l6ZS4gKi9cbiAgICBfdXBkYXRlVmlld3BvcnRTaXplKCkge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSB0aGlzLl9nZXRXaW5kb3coKTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTaXplID0gdGhpcy5fcGxhdGZvcm0uaXNCcm93c2VyXG4gICAgICAgICAgICA/IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9XG4gICAgICAgICAgICA6IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbn1cblZpZXdwb3J0UnVsZXIuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBWaWV3cG9ydFJ1bGVyLCBkZXBzOiBbeyB0b2tlbjogaTEuUGxhdGZvcm0gfSwgeyB0b2tlbjogaTAuTmdab25lIH0sIHsgdG9rZW46IERPQ1VNRU5ULCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuVmlld3BvcnRSdWxlci7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBWaWV3cG9ydFJ1bGVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBWaWV3cG9ydFJ1bGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkxLlBsYXRmb3JtIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbRE9DVU1FTlRdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY29uc3QgVklSVFVBTF9TQ1JPTExBQkxFID0gbmV3IEluamVjdGlvblRva2VuKCdWSVJUVUFMX1NDUk9MTEFCTEUnKTtcbi8qKlxuICogRXh0ZW5kaW5nIHRoZSB7QGxpbmsgQ2RrU2Nyb2xsYWJsZX0gdG8gYmUgdXNlZCBhcyBzY3JvbGxpbmcgY29udGFpbmVyIGZvciB2aXJ0dWFsIHNjcm9sbGluZy5cbiAqL1xuY2xhc3MgQ2RrVmlydHVhbFNjcm9sbGFibGUgZXh0ZW5kcyBDZGtTY3JvbGxhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcikge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgdGhlIHZpZXdwb3J0IHNpemUgZm9yIHRoZSBwcm92aWRlZCBvcmllbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmllbnRhdGlvbiBUaGUgb3JpZW50YXRpb24gdG8gbWVhc3VyZSB0aGUgc2l6ZSBmcm9tLlxuICAgICAqL1xuICAgIG1lYXN1cmVWaWV3cG9ydFNpemUob3JpZW50YXRpb24pIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnRFbCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICByZXR1cm4gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IHZpZXdwb3J0RWwuY2xpZW50V2lkdGggOiB2aWV3cG9ydEVsLmNsaWVudEhlaWdodDtcbiAgICB9XG59XG5DZGtWaXJ0dWFsU2Nyb2xsYWJsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1ZpcnR1YWxTY3JvbGxhYmxlLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBpMi5EaXJlY3Rpb25hbGl0eSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrVmlydHVhbFNjcm9sbGFibGUuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtWaXJ0dWFsU2Nyb2xsYWJsZSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtWaXJ0dWFsU2Nyb2xsYWJsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogaTIuRGlyZWN0aW9uYWxpdHksIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gcmFuZ2VzIGFyZSBlcXVhbC4gKi9cbmZ1bmN0aW9uIHJhbmdlc0VxdWFsKHIxLCByMikge1xuICAgIHJldHVybiByMS5zdGFydCA9PSByMi5zdGFydCAmJiByMS5lbmQgPT0gcjIuZW5kO1xufVxuLyoqXG4gKiBTY2hlZHVsZXIgdG8gYmUgdXNlZCBmb3Igc2Nyb2xsIGV2ZW50cy4gTmVlZHMgdG8gZmFsbCBiYWNrIHRvXG4gKiBzb21ldGhpbmcgdGhhdCBkb2Vzbid0IHJlbHkgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG9uIGVudmlyb25tZW50c1xuICogdGhhdCBkb24ndCBzdXBwb3J0IGl0IChlLmcuIHNlcnZlci1zaWRlIHJlbmRlcmluZykuXG4gKi9cbmNvbnN0IFNDUk9MTF9TQ0hFRFVMRVIgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAndW5kZWZpbmVkJyA/IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyIDogYXNhcFNjaGVkdWxlcjtcbi8qKiBBIHZpZXdwb3J0IHRoYXQgdmlydHVhbGl6ZXMgaXRzIHNjcm9sbGluZyB3aXRoIHRoZSBoZWxwIG9mIGBDZGtWaXJ0dWFsRm9yT2ZgLiAqL1xuY2xhc3MgQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0IGV4dGVuZHMgQ2RrVmlydHVhbFNjcm9sbGFibGUge1xuICAgIC8qKiBUaGUgZGlyZWN0aW9uIHRoZSB2aWV3cG9ydCBzY3JvbGxzLiAqL1xuICAgIGdldCBvcmllbnRhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICAgIH1cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uICE9PSBvcmllbnRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVNwYWNlclNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlbmRlcmVkIGl0ZW1zIHNob3VsZCBwZXJzaXN0IGluIHRoZSBET00gYWZ0ZXIgc2Nyb2xsaW5nIG91dCBvZiB2aWV3LiBCeSBkZWZhdWx0LCBpdGVtc1xuICAgICAqIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBnZXQgYXBwZW5kT25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZE9ubHk7XG4gICAgfVxuICAgIHNldCBhcHBlbmRPbmx5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FwcGVuZE9ubHkgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIG5nWm9uZSwgX3Njcm9sbFN0cmF0ZWd5LCBkaXIsIHNjcm9sbERpc3BhdGNoZXIsIHZpZXdwb3J0UnVsZXIsIHNjcm9sbGFibGUpIHtcbiAgICAgICAgc3VwZXIoZWxlbWVudFJlZiwgc2Nyb2xsRGlzcGF0Y2hlciwgbmdab25lLCBkaXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kgPSBfc2Nyb2xsU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSA9IHNjcm9sbGFibGU7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gaW5qZWN0KFBsYXRmb3JtKTtcbiAgICAgICAgLyoqIEVtaXRzIHdoZW4gdGhlIHZpZXdwb3J0IGlzIGRldGFjaGVkIGZyb20gYSBDZGtWaXJ0dWFsRm9yT2YuICovXG4gICAgICAgIHRoaXMuX2RldGFjaGVkU3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKiBFbWl0cyB3aGVuIHRoZSByZW5kZXJlZCByYW5nZSBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLl9yZW5kZXJlZFJhbmdlU3ViamVjdCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuX29yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgdGhpcy5fYXBwZW5kT25seSA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlOiB3ZSBkb24ndCB1c2UgdGhlIHR5cGljYWwgRXZlbnRFbWl0dGVyIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIHN1YnNjcmliZSB0byB0aGUgc2Nyb2xsXG4gICAgICAgIC8vIHN0cmF0ZWd5IGxhemlseSAoaS5lLiBvbmx5IGlmIHRoZSB1c2VyIGlzIGFjdHVhbGx5IGxpc3RlbmluZyB0byB0aGUgZXZlbnRzKS4gV2UgZG8gdGhpcyBiZWNhdXNlXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiBob3cgdGhlIHN0cmF0ZWd5IGNhbGN1bGF0ZXMgdGhlIHNjcm9sbGVkIGluZGV4LCBpdCBtYXkgY29tZSBhdCBhIGNvc3QgdG9cbiAgICAgICAgLy8gcGVyZm9ybWFuY2UuXG4gICAgICAgIC8qKiBFbWl0cyB3aGVuIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZWxlbWVudCB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydCBjaGFuZ2VzLiAqL1xuICAgICAgICB0aGlzLnNjcm9sbGVkSW5kZXhDaGFuZ2UgPSBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHRoaXMuX3Njcm9sbFN0cmF0ZWd5LnNjcm9sbGVkSW5kZXhDaGFuZ2Uuc3Vic2NyaWJlKGluZGV4ID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5uZ1pvbmUucnVuKCgpID0+IG9ic2VydmVyLm5leHQoaW5kZXgpKSkpKTtcbiAgICAgICAgLyoqIEEgc3RyZWFtIHRoYXQgZW1pdHMgd2hlbmV2ZXIgdGhlIHJlbmRlcmVkIHJhbmdlIGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMucmVuZGVyZWRSYW5nZVN0cmVhbSA9IHRoaXMuX3JlbmRlcmVkUmFuZ2VTdWJqZWN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRvdGFsIHNpemUgb2YgYWxsIGNvbnRlbnQgKGluIHBpeGVscyksIGluY2x1ZGluZyBjb250ZW50IHRoYXQgaXMgbm90IGN1cnJlbnRseSByZW5kZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RvdGFsQ29udGVudFNpemUgPSAwO1xuICAgICAgICAvKiogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBgc3R5bGUud2lkdGhgIHByb3BlcnR5IHZhbHVlIHRvIGJlIHVzZWQgZm9yIHRoZSBzcGFjZXIgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5fdG90YWxDb250ZW50V2lkdGggPSAnJztcbiAgICAgICAgLyoqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYHN0eWxlLmhlaWdodGAgcHJvcGVydHkgdmFsdWUgdG8gYmUgdXNlZCBmb3IgdGhlIHNwYWNlciBlbGVtZW50LiAqL1xuICAgICAgICB0aGlzLl90b3RhbENvbnRlbnRIZWlnaHQgPSAnJztcbiAgICAgICAgLyoqIFRoZSBjdXJyZW50bHkgcmVuZGVyZWQgcmFuZ2Ugb2YgaW5kaWNlcy4gKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZSA9IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICAgICAgICAvKiogVGhlIGxlbmd0aCBvZiB0aGUgZGF0YSBib3VuZCB0byB0aGlzIHZpZXdwb3J0IChpbiBudW1iZXIgb2YgaXRlbXMpLiAqL1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgLyoqIFRoZSBzaXplIG9mIHRoZSB2aWV3cG9ydCAoaW4gcGl4ZWxzKS4gKi9cbiAgICAgICAgdGhpcy5fdmlld3BvcnRTaXplID0gMDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHJlbmRlcmVkIGNvbnRlbnQgb2Zmc2V0IHRoYXQgd2FzIHNldC4gKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGxhc3QgcmVuZGVyZWQgY29udGVudCBvZmZzZXQgd2FzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQgKGFuZCB0aGVyZWZvcmUgbmVlZHMgdG9cbiAgICAgICAgICogYmUgcmV3cml0dGVuIGFzIGFuIG9mZnNldCB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0TmVlZHNSZXdyaXRlID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZXJlIGlzIGEgcGVuZGluZyBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLiAqL1xuICAgICAgICB0aGlzLl9pc0NoYW5nZURldGVjdGlvblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqIEEgbGlzdCBvZiBmdW5jdGlvbnMgdG8gcnVuIGFmdGVyIHRoZSBuZXh0IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUuICovXG4gICAgICAgIHRoaXMuX3J1bkFmdGVyQ2hhbmdlRGV0ZWN0aW9uID0gW107XG4gICAgICAgIC8qKiBTdWJzY3JpcHRpb24gdG8gY2hhbmdlcyBpbiB0aGUgdmlld3BvcnQgc2l6ZS4gKi9cbiAgICAgICAgdGhpcy5fdmlld3BvcnRDaGFuZ2VzID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICBpZiAoIV9zY3JvbGxTdHJhdGVneSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Vycm9yOiBjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnQgcmVxdWlyZXMgdGhlIFwiaXRlbVNpemVcIiBwcm9wZXJ0eSB0byBiZSBzZXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlld3BvcnRDaGFuZ2VzID0gdmlld3BvcnRSdWxlci5jaGFuZ2UoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgIC8vIE5vIHNjcm9sbGFibGUgaXMgcHJvdmlkZWQsIHNvIHRoZSB2aXJ0dWFsLXNjcm9sbC12aWV3cG9ydCBuZWVkcyB0byBiZWNvbWUgYSBzY3JvbGxhYmxlXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjZGstdmlydHVhbC1zY3JvbGxhYmxlJyk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGFibGUgPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICAvLyBTY3JvbGxpbmcgZGVwZW5kcyBvbiB0aGUgZWxlbWVudCBkaW1lbnNpb25zIHdoaWNoIHdlIGNhbid0IGdldCBkdXJpbmcgU1NSLlxuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbGFibGUgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQncyBzdGlsbCB0b28gZWFybHkgdG8gbWVhc3VyZSB0aGUgdmlld3BvcnQgYXQgdGhpcyBwb2ludC4gRGVmZXJyaW5nIHdpdGggYSBwcm9taXNlIGFsbG93c1xuICAgICAgICAvLyB0aGUgVmlld3BvcnQgdG8gYmUgcmVuZGVyZWQgd2l0aCB0aGUgY29ycmVjdCBzaXplIGJlZm9yZSB3ZSBtZWFzdXJlLiBXZSBydW4gdGhpcyBvdXRzaWRlIHRoZVxuICAgICAgICAvLyB6b25lIHRvIGF2b2lkIGNhdXNpbmcgbW9yZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlcy4gV2UgaGFuZGxlIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3BcbiAgICAgICAgLy8gb3Vyc2VsdmVzIGluc3RlYWQuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbWVhc3VyZVZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kuYXR0YWNoKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxhYmxlXG4gICAgICAgICAgICAgICAgLmVsZW1lbnRTY3JvbGxlZCgpXG4gICAgICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAvLyBTdGFydCBvZmYgd2l0aCBhIGZha2Ugc2Nyb2xsIGV2ZW50IHNvIHdlIHByb3Blcmx5IGRldGVjdCBvdXIgaW5pdGlhbCBwb3NpdGlvbi5cbiAgICAgICAgICAgIHN0YXJ0V2l0aChudWxsKSwgXG4gICAgICAgICAgICAvLyBDb2xsZWN0IG11bHRpcGxlIGV2ZW50cyBpbnRvIG9uZSB1bnRpbCB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuIFRoaXMgd2F5IGlmXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbXVsdGlwbGUgc2Nyb2xsIGV2ZW50cyBpbiB0aGUgc2FtZSBmcmFtZSB3ZSBvbmx5IG5lZWQgdG8gcmVjaGVja1xuICAgICAgICAgICAgLy8gb3VyIGxheW91dCBvbmNlLlxuICAgICAgICAgICAgYXVkaXRUaW1lKDAsIFNDUk9MTF9TQ0hFRFVMRVIpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fc2Nyb2xsU3RyYXRlZ3kub25Db250ZW50U2Nyb2xsZWQoKSk7XG4gICAgICAgICAgICB0aGlzLl9tYXJrQ2hhbmdlRGV0ZWN0aW9uTmVlZGVkKCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5LmRldGFjaCgpO1xuICAgICAgICAvLyBDb21wbGV0ZSBhbGwgc3ViamVjdHNcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZVN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fZGV0YWNoZWRTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0Q2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgIH1cbiAgICAvKiogQXR0YWNoZXMgYSBgQ2RrVmlydHVhbFNjcm9sbFJlcGVhdGVyYCB0byB0aGlzIHZpZXdwb3J0LiAqL1xuICAgIGF0dGFjaChmb3JPZikge1xuICAgICAgICBpZiAodGhpcy5fZm9yT2YgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQgaXMgYWxyZWFkeSBhdHRhY2hlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGRhdGEgc3RyZWFtIG9mIHRoZSBDZGtWaXJ0dWFsRm9yT2YgdG8ga2VlcCB0cmFjayBvZiB3aGVuIHRoZSBkYXRhIGxlbmd0aFxuICAgICAgICAvLyBjaGFuZ2VzLiBSdW4gb3V0c2lkZSB0aGUgem9uZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGNoYW5nZSBkZXRlY3Rpb24sIHNpbmNlIHdlJ3JlIG1hbmFnaW5nIHRoZVxuICAgICAgICAvLyBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3Agb3Vyc2VsdmVzLlxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9mb3JPZiA9IGZvck9mO1xuICAgICAgICAgICAgdGhpcy5fZm9yT2YuZGF0YVN0cmVhbS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXRhY2hlZFN1YmplY3QpKS5zdWJzY3JpYmUoZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCAhPT0gdGhpcy5fZGF0YUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gbmV3TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS5vbkRhdGFMZW5ndGhDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RvQ2hhbmdlRGV0ZWN0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBEZXRhY2hlcyB0aGUgY3VycmVudCBgQ2RrVmlydHVhbEZvck9mYC4gKi9cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuX2Zvck9mID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGV0YWNoZWRTdWJqZWN0Lm5leHQoKTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YSBib3VuZCB0byB0aGlzIHZpZXdwb3J0IChpbiBudW1iZXIgb2YgaXRlbXMpLiAqL1xuICAgIGdldERhdGFMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhTGVuZ3RoO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgdmlld3BvcnQgKGluIHBpeGVscykuICovXG4gICAgZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTaXplO1xuICAgIH1cbiAgICAvLyBUT0RPKG1tYWxlcmJhKTogVGhpcyBpcyB0ZWNobmljYWxseSBvdXQgb2Ygc3luYyB3aXRoIHdoYXQncyByZWFsbHkgcmVuZGVyZWQgdW50aWwgYSByZW5kZXJcbiAgICAvLyBjeWNsZSBoYXBwZW5zLiBJJ20gYmVpbmcgY2FyZWZ1bCB0byBvbmx5IGNhbGwgaXQgYWZ0ZXIgdGhlIHJlbmRlciBjeWNsZSBpcyBjb21wbGV0ZSBhbmQgYmVmb3JlXG4gICAgLy8gc2V0dGluZyBpdCB0byBzb21ldGhpbmcgZWxzZSwgYnV0IGl0cyBlcnJvciBwcm9uZSBhbmQgc2hvdWxkIHByb2JhYmx5IGJlIHNwbGl0IGludG9cbiAgICAvLyBgcGVuZGluZ1JhbmdlYCBhbmQgYHJlbmRlcmVkUmFuZ2VgLCB0aGUgbGF0dGVyIHJlZmxlY3Rpbmcgd2hhdHMgYWN0dWFsbHkgaW4gdGhlIERPTS5cbiAgICAvKiogR2V0IHRoZSBjdXJyZW50IHJlbmRlcmVkIHJhbmdlIG9mIGl0ZW1zLiAqL1xuICAgIGdldFJlbmRlcmVkUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZFJhbmdlO1xuICAgIH1cbiAgICBtZWFzdXJlQm91bmRpbmdDbGllbnRSZWN0V2l0aFNjcm9sbE9mZnNldChmcm9tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2Zyb21dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0b3RhbCBzaXplIG9mIGFsbCBjb250ZW50IChpbiBwaXhlbHMpLCBpbmNsdWRpbmcgY29udGVudCB0aGF0IGlzIG5vdCBjdXJyZW50bHlcbiAgICAgKiByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBzZXRUb3RhbENvbnRlbnRTaXplKHNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsQ29udGVudFNpemUgIT09IHNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsQ29udGVudFNpemUgPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlU3BhY2VyU2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5fbWFya0NoYW5nZURldGVjdGlvbk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTZXRzIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgcmFuZ2Ugb2YgaW5kaWNlcy4gKi9cbiAgICBzZXRSZW5kZXJlZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2VzRXF1YWwodGhpcy5fcmVuZGVyZWRSYW5nZSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcHBlbmRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7IHN0YXJ0OiAwLCBlbmQ6IE1hdGgubWF4KHRoaXMuX3JlbmRlcmVkUmFuZ2UuZW5kLCByYW5nZS5lbmQpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZFJhbmdlU3ViamVjdC5uZXh0KCh0aGlzLl9yZW5kZXJlZFJhbmdlID0gcmFuZ2UpKTtcbiAgICAgICAgICAgIHRoaXMuX21hcmtDaGFuZ2VEZXRlY3Rpb25OZWVkZWQoKCkgPT4gdGhpcy5fc2Nyb2xsU3RyYXRlZ3kub25Db250ZW50UmVuZGVyZWQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB2aWV3cG9ydCB0byB0aGUgc3RhcnQgb2YgdGhlIHJlbmRlcmVkIGRhdGEgKGluIHBpeGVscykuXG4gICAgICovXG4gICAgZ2V0T2Zmc2V0VG9SZW5kZXJlZENvbnRlbnRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkQ29udGVudE9mZnNldE5lZWRzUmV3cml0ZSA/IG51bGwgOiB0aGlzLl9yZW5kZXJlZENvbnRlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgdmlld3BvcnQgdG8gZWl0aGVyIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHJlbmRlcmVkIGRhdGFcbiAgICAgKiAoaW4gcGl4ZWxzKS5cbiAgICAgKi9cbiAgICBzZXRSZW5kZXJlZENvbnRlbnRPZmZzZXQob2Zmc2V0LCB0byA9ICd0by1zdGFydCcpIHtcbiAgICAgICAgLy8gSW4gYXBwZW5kT25seSwgd2UgYWx3YXlzIHN0YXJ0IGZyb20gdGhlIHRvcFxuICAgICAgICBvZmZzZXQgPSB0aGlzLmFwcGVuZE9ubHkgJiYgdG8gPT09ICd0by1zdGFydCcgPyAwIDogb2Zmc2V0O1xuICAgICAgICAvLyBGb3IgYSBob3Jpem9udGFsIHZpZXdwb3J0IGluIGEgcmlnaHQtdG8tbGVmdCBsYW5ndWFnZSB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSBhbG9uZyB0aGUgeC1heGlzXG4gICAgICAgIC8vIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24uXG4gICAgICAgIGNvbnN0IGlzUnRsID0gdGhpcy5kaXIgJiYgdGhpcy5kaXIudmFsdWUgPT0gJ3J0bCc7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMub3JpZW50YXRpb24gPT0gJ2hvcml6b250YWwnO1xuICAgICAgICBjb25zdCBheGlzID0gaXNIb3Jpem9udGFsID8gJ1gnIDogJ1knO1xuICAgICAgICBjb25zdCBheGlzRGlyZWN0aW9uID0gaXNIb3Jpem9udGFsICYmIGlzUnRsID8gLTEgOiAxO1xuICAgICAgICBsZXQgdHJhbnNmb3JtID0gYHRyYW5zbGF0ZSR7YXhpc30oJHtOdW1iZXIoYXhpc0RpcmVjdGlvbiAqIG9mZnNldCl9cHgpYDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBpZiAodG8gPT09ICd0by1lbmQnKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYCB0cmFuc2xhdGUke2F4aXN9KC0xMDAlKWA7XG4gICAgICAgICAgICAvLyBUaGUgdmlld3BvcnQgc2hvdWxkIHJld3JpdGUgdGhpcyBhcyBhIGB0by1zdGFydGAgb2Zmc2V0IG9uIHRoZSBuZXh0IHJlbmRlciBjeWNsZS4gT3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB3aWxsIGFwcGVhciB0byBleHBhbmQgaW4gdGhlIHdyb25nIGRpcmVjdGlvbiAoZS5nLiBgbWF0LWV4cGFuc2lvbi1wYW5lbGAgd291bGRcbiAgICAgICAgICAgIC8vIGV4cGFuZCB1cHdhcmQpLlxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0TmVlZHNSZXdyaXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZWRDb250ZW50VHJhbnNmb3JtICE9IHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gV2Uga25vdyB0aGlzIHZhbHVlIGlzIHNhZmUgYmVjYXVzZSB3ZSBwYXJzZSBgb2Zmc2V0YCB3aXRoIGBOdW1iZXIoKWAgYmVmb3JlIHBhc3NpbmcgaXRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIHN0cmluZy5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkQ29udGVudFRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgIHRoaXMuX21hcmtDaGFuZ2VEZXRlY3Rpb25OZWVkZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlZENvbnRlbnRPZmZzZXROZWVkc1Jld3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0IC09IHRoaXMubWVhc3VyZVJlbmRlcmVkQ29udGVudFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRDb250ZW50T2Zmc2V0TmVlZHNSZXdyaXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyZWRDb250ZW50T2Zmc2V0KHRoaXMuX3JlbmRlcmVkQ29udGVudE9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxTdHJhdGVneS5vblJlbmRlcmVkT2Zmc2V0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgdG8gdGhlIGdpdmVuIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgdmlld3BvcnQuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBpcyBub3QgYWx3YXlzXG4gICAgICogdGhlIHNhbWUgYXMgc2V0dGluZyBgc2Nyb2xsVG9wYCBvciBgc2Nyb2xsTGVmdGAuIEluIGEgaG9yaXpvbnRhbCB2aWV3cG9ydCB3aXRoIHJpZ2h0LXRvLWxlZnRcbiAgICAgKiBkaXJlY3Rpb24sIHRoaXMgd291bGQgYmUgdGhlIGVxdWl2YWxlbnQgb2Ygc2V0dGluZyBhIGZpY3Rpb25hbCBgc2Nyb2xsUmlnaHRgIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBzY3JvbGwgdG8uXG4gICAgICogQHBhcmFtIGJlaGF2aW9yIFRoZSBTY3JvbGxCZWhhdmlvciB0byB1c2Ugd2hlbiBzY3JvbGxpbmcuIERlZmF1bHQgaXMgYmVoYXZpb3IgaXMgYGF1dG9gLlxuICAgICAqL1xuICAgIHNjcm9sbFRvT2Zmc2V0KG9mZnNldCwgYmVoYXZpb3IgPSAnYXV0bycpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYmVoYXZpb3IgfTtcbiAgICAgICAgaWYgKHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGFydCA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMudG9wID0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZS5zY3JvbGxUbyhvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byB0aGUgb2Zmc2V0IGZvciB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byBzY3JvbGwgdG8uXG4gICAgICogQHBhcmFtIGJlaGF2aW9yIFRoZSBTY3JvbGxCZWhhdmlvciB0byB1c2Ugd2hlbiBzY3JvbGxpbmcuIERlZmF1bHQgaXMgYmVoYXZpb3IgaXMgYGF1dG9gLlxuICAgICAqL1xuICAgIHNjcm9sbFRvSW5kZXgoaW5kZXgsIGJlaGF2aW9yID0gJ2F1dG8nKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5LnNjcm9sbFRvSW5kZXgoaW5kZXgsIGJlaGF2aW9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzY3JvbGwgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBzY3JvbGxhYmxlIChpbiBwaXhlbHMpLlxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBlZGdlIHRvIG1lYXN1cmUgdGhlIG9mZnNldCBmcm9tLiBEZWZhdWx0cyB0byAndG9wJyBpbiB2ZXJ0aWNhbCBtb2RlIGFuZCAnc3RhcnQnXG4gICAgICogICAgIGluIGhvcml6b250YWwgbW9kZS5cbiAgICAgKi9cbiAgICBtZWFzdXJlU2Nyb2xsT2Zmc2V0KGZyb20pIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0byBicmVhayB0aGUgY2FsbCBjeWNsZVxuICAgICAgICBsZXQgbWVhc3VyZVNjcm9sbE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsYWJsZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICBtZWFzdXJlU2Nyb2xsT2Zmc2V0ID0gKF9mcm9tKSA9PiBzdXBlci5tZWFzdXJlU2Nyb2xsT2Zmc2V0KF9mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lYXN1cmVTY3JvbGxPZmZzZXQgPSAoX2Zyb20pID0+IHRoaXMuc2Nyb2xsYWJsZS5tZWFzdXJlU2Nyb2xsT2Zmc2V0KF9mcm9tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgbWVhc3VyZVNjcm9sbE9mZnNldChmcm9tID8/ICh0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnc3RhcnQnIDogJ3RvcCcpKSAtXG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVWaWV3cG9ydE9mZnNldCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgdGhlIG9mZnNldCBvZiB0aGUgdmlld3BvcnQgZnJvbSB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSBmcm9tIFRoZSBlZGdlIHRvIG1lYXN1cmUgZnJvbS5cbiAgICAgKi9cbiAgICBtZWFzdXJlVmlld3BvcnRPZmZzZXQoZnJvbSkge1xuICAgICAgICBsZXQgZnJvbVJlY3Q7XG4gICAgICAgIGNvbnN0IExFRlQgPSAnbGVmdCc7XG4gICAgICAgIGNvbnN0IFJJR0hUID0gJ3JpZ2h0JztcbiAgICAgICAgY29uc3QgaXNSdGwgPSB0aGlzLmRpcj8udmFsdWUgPT0gJ3J0bCc7XG4gICAgICAgIGlmIChmcm9tID09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIGZyb21SZWN0ID0gaXNSdGwgPyBSSUdIVCA6IExFRlQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnJvbSA9PSAnZW5kJykge1xuICAgICAgICAgICAgZnJvbVJlY3QgPSBpc1J0bCA/IExFRlQgOiBSSUdIVDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tKSB7XG4gICAgICAgICAgICBmcm9tUmVjdCA9IGZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcm9tUmVjdCA9IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbGVyQ2xpZW50UmVjdCA9IHRoaXMuc2Nyb2xsYWJsZS5tZWFzdXJlQm91bmRpbmdDbGllbnRSZWN0V2l0aFNjcm9sbE9mZnNldChmcm9tUmVjdCk7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0Q2xpZW50UmVjdCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2Zyb21SZWN0XTtcbiAgICAgICAgcmV0dXJuIHZpZXdwb3J0Q2xpZW50UmVjdCAtIHNjcm9sbGVyQ2xpZW50UmVjdDtcbiAgICB9XG4gICAgLyoqIE1lYXN1cmUgdGhlIGNvbWJpbmVkIHNpemUgb2YgYWxsIG9mIHRoZSByZW5kZXJlZCBpdGVtcy4gKi9cbiAgICBtZWFzdXJlUmVuZGVyZWRDb250ZW50U2l6ZSgpIHtcbiAgICAgICAgY29uc3QgY29udGVudEVsID0gdGhpcy5fY29udGVudFdyYXBwZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IGNvbnRlbnRFbC5vZmZzZXRXaWR0aCA6IGNvbnRlbnRFbC5vZmZzZXRIZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgdGhlIHRvdGFsIGNvbWJpbmVkIHNpemUgb2YgdGhlIGdpdmVuIHJhbmdlLiBUaHJvd3MgaWYgdGhlIHJhbmdlIGluY2x1ZGVzIGl0ZW1zIHRoYXQgYXJlXG4gICAgICogbm90IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIG1lYXN1cmVSYW5nZVNpemUocmFuZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb3JPZikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvck9mLm1lYXN1cmVSYW5nZVNpemUocmFuZ2UsIHRoaXMub3JpZW50YXRpb24pO1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zIGFuZCByZS1yZW5kZXIuICovXG4gICAgY2hlY2tWaWV3cG9ydFNpemUoKSB7XG4gICAgICAgIC8vIFRPRE86IENsZWFudXAgbGF0ZXIgd2hlbiBhZGQgbG9naWMgZm9yIGhhbmRsaW5nIGNvbnRlbnQgcmVzaXplXG4gICAgICAgIHRoaXMuX21lYXN1cmVWaWV3cG9ydFNpemUoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3kub25EYXRhTGVuZ3RoQ2hhbmdlZCgpO1xuICAgIH1cbiAgICAvKiogTWVhc3VyZSB0aGUgdmlld3BvcnQgc2l6ZS4gKi9cbiAgICBfbWVhc3VyZVZpZXdwb3J0U2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTaXplID0gdGhpcy5zY3JvbGxhYmxlLm1lYXN1cmVWaWV3cG9ydFNpemUodGhpcy5vcmllbnRhdGlvbik7XG4gICAgfVxuICAgIC8qKiBRdWV1ZSB1cCBjaGFuZ2UgZGV0ZWN0aW9uIHRvIHJ1bi4gKi9cbiAgICBfbWFya0NoYW5nZURldGVjdGlvbk5lZWRlZChydW5BZnRlcikge1xuICAgICAgICBpZiAocnVuQWZ0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3J1bkFmdGVyQ2hhbmdlRGV0ZWN0aW9uLnB1c2gocnVuQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBhIFByb21pc2UgdG8gYmF0Y2ggdG9nZXRoZXIgY2FsbHMgdG8gYF9kb0NoYW5nZURldGVjdGlvbmAuIFRoaXMgd2F5IGlmIHdlIHNldCBhIGJ1bmNoIG9mXG4gICAgICAgIC8vIHByb3BlcnRpZXMgc2VxdWVudGlhbGx5IHdlIG9ubHkgaGF2ZSB0byBydW4gYF9kb0NoYW5nZURldGVjdGlvbmAgb25jZSBhdCB0aGUgZW5kLlxuICAgICAgICBpZiAoIXRoaXMuX2lzQ2hhbmdlRGV0ZWN0aW9uUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5faXNDaGFuZ2VEZXRlY3Rpb25QZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvQ2hhbmdlRGV0ZWN0aW9uKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJ1biBjaGFuZ2UgZGV0ZWN0aW9uLiAqL1xuICAgIF9kb0NoYW5nZURldGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5faXNDaGFuZ2VEZXRlY3Rpb25QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIEFwcGx5IHRoZSBjb250ZW50IHRyYW5zZm9ybS4gVGhlIHRyYW5zZm9ybSBjYW4ndCBiZSBzZXQgdmlhIGFuIEFuZ3VsYXIgYmluZGluZyBiZWNhdXNlXG4gICAgICAgIC8vIGJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZSBpcyBiYW5uZWQgaW4gR29vZ2xlLiBIb3dldmVyIHRoZSB2YWx1ZSBpcyBzYWZlLCBpdCdzIGNvbXBvc2VkIG9mXG4gICAgICAgIC8vIHN0cmluZyBsaXRlcmFscywgYSB2YXJpYWJsZSB0aGF0IGNhbiBvbmx5IGJlICdYJyBvciAnWScsIGFuZCB1c2VyIGlucHV0IHRoYXQgaXMgcnVuIHRocm91Z2hcbiAgICAgICAgLy8gdGhlIGBOdW1iZXJgIGZ1bmN0aW9uIGZpcnN0IHRvIGNvZXJjZSBpdCB0byBhIG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHRoaXMuX2NvbnRlbnRXcmFwcGVyLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5fcmVuZGVyZWRDb250ZW50VHJhbnNmb3JtO1xuICAgICAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIEFuZ3VsYXIgYmluZGluZ3MuIE5vdGU6IFdlIG11c3QgY2FsbCBgbWFya0ZvckNoZWNrYCB0byBydW4gY2hhbmdlIGRldGVjdGlvblxuICAgICAgICAvLyBmcm9tIHRoZSByb290LCBzaW5jZSB0aGUgcmVwZWF0ZWQgaXRlbXMgYXJlIGNvbnRlbnQgcHJvamVjdGVkIGluLiBDYWxsaW5nIGBkZXRlY3RDaGFuZ2VzYFxuICAgICAgICAvLyBpbnN0ZWFkIGRvZXMgbm90IHByb3Blcmx5IGNoZWNrIHRoZSBwcm9qZWN0ZWQgY29udGVudC5cbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKTtcbiAgICAgICAgY29uc3QgcnVuQWZ0ZXJDaGFuZ2VEZXRlY3Rpb24gPSB0aGlzLl9ydW5BZnRlckNoYW5nZURldGVjdGlvbjtcbiAgICAgICAgdGhpcy5fcnVuQWZ0ZXJDaGFuZ2VEZXRlY3Rpb24gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBydW5BZnRlckNoYW5nZURldGVjdGlvbikge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgYHN0eWxlLndpZHRoYCBhbmQgYHN0eWxlLmhlaWdodGAgZm9yIHRoZSBzcGFjZXIgZWxlbWVudC4gKi9cbiAgICBfY2FsY3VsYXRlU3BhY2VyU2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fdG90YWxDb250ZW50SGVpZ2h0ID1cbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICcnIDogYCR7dGhpcy5fdG90YWxDb250ZW50U2l6ZX1weGA7XG4gICAgICAgIHRoaXMuX3RvdGFsQ29udGVudFdpZHRoID1cbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IGAke3RoaXMuX3RvdGFsQ29udGVudFNpemV9cHhgIDogJyc7XG4gICAgfVxufVxuQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0LCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMC5DaGFuZ2VEZXRlY3RvclJlZiB9LCB7IHRva2VuOiBpMC5OZ1pvbmUgfSwgeyB0b2tlbjogVklSVFVBTF9TQ1JPTExfU1RSQVRFR1ksIG9wdGlvbmFsOiB0cnVlIH0sIHsgdG9rZW46IGkyLkRpcmVjdGlvbmFsaXR5LCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdG9rZW46IFZpZXdwb3J0UnVsZXIgfSwgeyB0b2tlbjogVklSVFVBTF9TQ1JPTExBQkxFLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5Db21wb25lbnQgfSk7XG5DZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQuybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIGlzU3RhbmRhbG9uZTogdHJ1ZSwgc2VsZWN0b3I6IFwiY2RrLXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0XCIsIGlucHV0czogeyBvcmllbnRhdGlvbjogXCJvcmllbnRhdGlvblwiLCBhcHBlbmRPbmx5OiBcImFwcGVuZE9ubHlcIiB9LCBvdXRwdXRzOiB7IHNjcm9sbGVkSW5kZXhDaGFuZ2U6IFwic2Nyb2xsZWRJbmRleENoYW5nZVwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImNsYXNzLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCI6IFwib3JpZW50YXRpb24gPT09IFxcXCJob3Jpem9udGFsXFxcIlwiLCBcImNsYXNzLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiOiBcIm9yaWVudGF0aW9uICE9PSBcXFwiaG9yaXpvbnRhbFxcXCJcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnRcIiB9LCBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogQ2RrU2Nyb2xsYWJsZSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6ICh2aXJ0dWFsU2Nyb2xsYWJsZSwgdmlld3BvcnQpID0+IHZpcnR1YWxTY3JvbGxhYmxlIHx8IHZpZXdwb3J0LFxuICAgICAgICAgICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChWSVJUVUFMX1NDUk9MTEFCTEUpXSwgQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0XSxcbiAgICAgICAgfSxcbiAgICBdLCB2aWV3UXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcIl9jb250ZW50V3JhcHBlclwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBbXCJjb250ZW50V3JhcHBlclwiXSwgZGVzY2VuZGFudHM6IHRydWUsIHN0YXRpYzogdHJ1ZSB9XSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBcIjwhLS1cXG4gIFdyYXAgdGhlIHJlbmRlcmVkIGNvbnRlbnQgaW4gYW4gZWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCB0byBvZmZzZXQgaXQgYmFzZWQgb24gdGhlIHNjcm9sbFxcbiAgcG9zaXRpb24uXFxuLS0+XFxuPGRpdiAjY29udGVudFdyYXBwZXIgY2xhc3M9XFxcImNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXJcXFwiPlxcbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbjwvZGl2PlxcbjwhLS1cXG4gIFNwYWNlciB1c2VkIHRvIGZvcmNlIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIHRvIHRoZSBjb3JyZWN0IHNpemUgZm9yIHRoZSAqdG90YWwqIG51bWJlciBvZiBpdGVtc1xcbiAgc28gdGhhdCB0aGUgc2Nyb2xsYmFyIGNhcHR1cmVzIHRoZSBzaXplIG9mIHRoZSBlbnRpcmUgZGF0YSBzZXQuXFxuLS0+XFxuPGRpdiBjbGFzcz1cXFwiY2RrLXZpcnR1YWwtc2Nyb2xsLXNwYWNlclxcXCJcXG4gICAgIFtzdHlsZS53aWR0aF09XFxcIl90b3RhbENvbnRlbnRXaWR0aFxcXCIgW3N0eWxlLmhlaWdodF09XFxcIl90b3RhbENvbnRlbnRIZWlnaHRcXFwiPjwvZGl2PlxcblwiLCBzdHlsZXM6IFtcImNkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zZm9ybTp0cmFuc2xhdGVaKDApfS5jZGstdmlydHVhbC1zY3JvbGxhYmxle292ZXJmbG93OmF1dG87d2lsbC1jaGFuZ2U6c2Nyb2xsLXBvc2l0aW9uO2NvbnRhaW46c3RyaWN0Oy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNofS5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtjb250YWluOmNvbnRlbnR9W2Rpcj1ydGxdIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVye3JpZ2h0OjA7bGVmdDphdXRvfS5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24taG9yaXpvbnRhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcnttaW4taGVpZ2h0OjEwMCV9LmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPmRsOm5vdChbY2RrVmlydHVhbEZvcl0pLC5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24taG9yaXpvbnRhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcj5vbDpub3QoW2Nka1ZpcnR1YWxGb3JdKSwuY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLWhvcml6b250YWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXI+dGFibGU6bm90KFtjZGtWaXJ0dWFsRm9yXSksLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPnVsOm5vdChbY2RrVmlydHVhbEZvcl0pe3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MDttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXJpZ2h0LXdpZHRoOjA7b3V0bGluZTpub25lfS5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24tdmVydGljYWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXJ7bWluLXdpZHRoOjEwMCV9LmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi12ZXJ0aWNhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcj5kbDpub3QoW2Nka1ZpcnR1YWxGb3JdKSwuY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLXZlcnRpY2FsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPm9sOm5vdChbY2RrVmlydHVhbEZvcl0pLC5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24tdmVydGljYWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXI+dGFibGU6bm90KFtjZGtWaXJ0dWFsRm9yXSksLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi12ZXJ0aWNhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcj51bDpub3QoW2Nka1ZpcnR1YWxGb3JdKXtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7bWFyZ2luLXRvcDowO21hcmdpbi1ib3R0b206MDtib3JkZXItdG9wLXdpZHRoOjA7Ym9yZGVyLWJvdHRvbS13aWR0aDowO291dGxpbmU6bm9uZX0uY2RrLXZpcnR1YWwtc2Nyb2xsLXNwYWNlcntoZWlnaHQ6MXB4O3RyYW5zZm9ybS1vcmlnaW46MCAwO2ZsZXg6MCAwIGF1dG99W2Rpcj1ydGxdIC5jZGstdmlydHVhbC1zY3JvbGwtc3BhY2Vye3RyYW5zZm9ybS1vcmlnaW46MTAwJSAwfVwiXSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsIGVuY2Fwc3VsYXRpb246IGkwLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ2Nkay12aXJ0dWFsLXNjcm9sbC12aWV3cG9ydCcsIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1tjbGFzcy5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24taG9yaXpvbnRhbF0nOiAnb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MuY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLXZlcnRpY2FsXSc6ICdvcmllbnRhdGlvbiAhPT0gXCJob3Jpem9udGFsXCInLFxuICAgICAgICAgICAgICAgICAgICB9LCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCwgc3RhbmRhbG9uZTogdHJ1ZSwgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ2RrU2Nyb2xsYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiAodmlydHVhbFNjcm9sbGFibGUsIHZpZXdwb3J0KSA9PiB2aXJ0dWFsU2Nyb2xsYWJsZSB8fCB2aWV3cG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgSW5qZWN0KFZJUlRVQUxfU0NST0xMQUJMRSldLCBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSwgdGVtcGxhdGU6IFwiPCEtLVxcbiAgV3JhcCB0aGUgcmVuZGVyZWQgY29udGVudCBpbiBhbiBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIG9mZnNldCBpdCBiYXNlZCBvbiB0aGUgc2Nyb2xsXFxuICBwb3NpdGlvbi5cXG4tLT5cXG48ZGl2ICNjb250ZW50V3JhcHBlciBjbGFzcz1cXFwiY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlclxcXCI+XFxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuPC9kaXY+XFxuPCEtLVxcbiAgU3BhY2VyIHVzZWQgdG8gZm9yY2UgdGhlIHNjcm9sbGluZyBjb250YWluZXIgdG8gdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgdGhlICp0b3RhbCogbnVtYmVyIG9mIGl0ZW1zXFxuICBzbyB0aGF0IHRoZSBzY3JvbGxiYXIgY2FwdHVyZXMgdGhlIHNpemUgb2YgdGhlIGVudGlyZSBkYXRhIHNldC5cXG4tLT5cXG48ZGl2IGNsYXNzPVxcXCJjZGstdmlydHVhbC1zY3JvbGwtc3BhY2VyXFxcIlxcbiAgICAgW3N0eWxlLndpZHRoXT1cXFwiX3RvdGFsQ29udGVudFdpZHRoXFxcIiBbc3R5bGUuaGVpZ2h0XT1cXFwiX3RvdGFsQ29udGVudEhlaWdodFxcXCI+PC9kaXY+XFxuXCIsIHN0eWxlczogW1wiY2RrLXZpcnR1YWwtc2Nyb2xsLXZpZXdwb3J0e2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9LmNkay12aXJ0dWFsLXNjcm9sbGFibGV7b3ZlcmZsb3c6YXV0bzt3aWxsLWNoYW5nZTpzY3JvbGwtcG9zaXRpb247Y29udGFpbjpzdHJpY3Q7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2h9LmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXJ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO2NvbnRhaW46Y29udGVudH1bZGlyPXJ0bF0gLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXJ7cmlnaHQ6MDtsZWZ0OmF1dG99LmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVye21pbi1oZWlnaHQ6MTAwJX0uY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLWhvcml6b250YWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXI+ZGw6bm90KFtjZGtWaXJ0dWFsRm9yXSksLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPm9sOm5vdChbY2RrVmlydHVhbEZvcl0pLC5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24taG9yaXpvbnRhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcj50YWJsZTpub3QoW2Nka1ZpcnR1YWxGb3JdKSwuY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLWhvcml6b250YWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXI+dWw6bm90KFtjZGtWaXJ0dWFsRm9yXSl7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowO21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjA7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItcmlnaHQtd2lkdGg6MDtvdXRsaW5lOm5vbmV9LmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi12ZXJ0aWNhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcnttaW4td2lkdGg6MTAwJX0uY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLXZlcnRpY2FsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPmRsOm5vdChbY2RrVmlydHVhbEZvcl0pLC5jZGstdmlydHVhbC1zY3JvbGwtb3JpZW50YXRpb24tdmVydGljYWwgLmNkay12aXJ0dWFsLXNjcm9sbC1jb250ZW50LXdyYXBwZXI+b2w6bm90KFtjZGtWaXJ0dWFsRm9yXSksLmNkay12aXJ0dWFsLXNjcm9sbC1vcmllbnRhdGlvbi12ZXJ0aWNhbCAuY2RrLXZpcnR1YWwtc2Nyb2xsLWNvbnRlbnQtd3JhcHBlcj50YWJsZTpub3QoW2Nka1ZpcnR1YWxGb3JdKSwuY2RrLXZpcnR1YWwtc2Nyb2xsLW9yaWVudGF0aW9uLXZlcnRpY2FsIC5jZGstdmlydHVhbC1zY3JvbGwtY29udGVudC13cmFwcGVyPnVsOm5vdChbY2RrVmlydHVhbEZvcl0pe3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MDttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTowO2JvcmRlci10b3Atd2lkdGg6MDtib3JkZXItYm90dG9tLXdpZHRoOjA7b3V0bGluZTpub25lfS5jZGstdmlydHVhbC1zY3JvbGwtc3BhY2Vye2hlaWdodDoxcHg7dHJhbnNmb3JtLW9yaWdpbjowIDA7ZmxleDowIDAgYXV0b31bZGlyPXJ0bF0gLmNkay12aXJ0dWFsLXNjcm9sbC1zcGFjZXJ7dHJhbnNmb3JtLW9yaWdpbjoxMDAlIDB9XCJdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IGkwLkNoYW5nZURldGVjdG9yUmVmIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbVklSVFVBTF9TQ1JPTExfU1RSQVRFR1ldXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMi5EaXJlY3Rpb25hbGl0eSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IFNjcm9sbERpc3BhdGNoZXIgfSwgeyB0eXBlOiBWaWV3cG9ydFJ1bGVyIH0sIHsgdHlwZTogQ2RrVmlydHVhbFNjcm9sbGFibGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtWSVJUVUFMX1NDUk9MTEFCTEVdXG4gICAgICAgICAgICAgICAgfV0gfV07IH0sIHByb3BEZWNvcmF0b3JzOiB7IG9yaWVudGF0aW9uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgYXBwZW5kT25seTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNjcm9sbGVkSW5kZXhDaGFuZ2U6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0XG4gICAgICAgICAgICB9XSwgX2NvbnRlbnRXcmFwcGVyOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFZpZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2NvbnRlbnRXcmFwcGVyJywgeyBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqIEhlbHBlciB0byBleHRyYWN0IHRoZSBvZmZzZXQgb2YgYSBET00gTm9kZSBpbiBhIGNlcnRhaW4gZGlyZWN0aW9uLiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0KG9yaWVudGF0aW9uLCBkaXJlY3Rpb24sIG5vZGUpIHtcbiAgICBjb25zdCBlbCA9IG5vZGU7XG4gICAgaWYgKCFlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSAnc3RhcnQnID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ3N0YXJ0JyA/IHJlY3QudG9wIDogcmVjdC5ib3R0b207XG59XG4vKipcbiAqIEEgZGlyZWN0aXZlIHNpbWlsYXIgdG8gYG5nRm9yT2ZgIHRvIGJlIHVzZWQgZm9yIHJlbmRlcmluZyBkYXRhIGluc2lkZSBhIHZpcnR1YWwgc2Nyb2xsaW5nXG4gKiBjb250YWluZXIuXG4gKi9cbmNsYXNzIENka1ZpcnR1YWxGb3JPZiB7XG4gICAgLyoqIFRoZSBEYXRhU291cmNlIHRvIGRpc3BsYXkuICovXG4gICAgZ2V0IGNka1ZpcnR1YWxGb3JPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nka1ZpcnR1YWxGb3JPZjtcbiAgICB9XG4gICAgc2V0IGNka1ZpcnR1YWxGb3JPZih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jZGtWaXJ0dWFsRm9yT2YgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGlzRGF0YVNvdXJjZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2VDaGFuZ2VzLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdmFsdWUgaXMgYW4gYW4gTmdJdGVyYWJsZSwgY29udmVydCBpdCB0byBhbiBhcnJheS5cbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2VDaGFuZ2VzLm5leHQobmV3IEFycmF5RGF0YVNvdXJjZShpc09ic2VydmFibGUodmFsdWUpID8gdmFsdWUgOiBBcnJheS5mcm9tKHZhbHVlIHx8IFtdKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgVHJhY2tCeUZ1bmN0aW9uYCB0byB1c2UgZm9yIHRyYWNraW5nIGNoYW5nZXMuIFRoZSBgVHJhY2tCeUZ1bmN0aW9uYCB0YWtlcyB0aGUgaW5kZXggYW5kXG4gICAgICogdGhlIGl0ZW0gYW5kIHByb2R1Y2VzIGEgdmFsdWUgdG8gYmUgdXNlZCBhcyB0aGUgaXRlbSdzIGlkZW50aXR5IHdoZW4gdHJhY2tpbmcgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBnZXQgY2RrVmlydHVhbEZvclRyYWNrQnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jZGtWaXJ0dWFsRm9yVHJhY2tCeTtcbiAgICB9XG4gICAgc2V0IGNka1ZpcnR1YWxGb3JUcmFja0J5KGZuKSB7XG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2RrVmlydHVhbEZvclRyYWNrQnkgPSBmblxuICAgICAgICAgICAgPyAoaW5kZXgsIGl0ZW0pID0+IGZuKGluZGV4ICsgKHRoaXMuX3JlbmRlcmVkUmFuZ2UgPyB0aGlzLl9yZW5kZXJlZFJhbmdlLnN0YXJ0IDogMCksIGl0ZW0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIFRoZSB0ZW1wbGF0ZSB1c2VkIHRvIHN0YW1wIG91dCBuZXcgZWxlbWVudHMuICovXG4gICAgc2V0IGNka1ZpcnR1YWxGb3JUZW1wbGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNpemUgb2YgdGhlIGNhY2hlIHVzZWQgdG8gc3RvcmUgdGVtcGxhdGVzIHRoYXQgYXJlIG5vdCBiZWluZyB1c2VkIGZvciByZS11c2UgbGF0ZXIuXG4gICAgICogU2V0dGluZyB0aGUgY2FjaGUgc2l6ZSB0byBgMGAgd2lsbCBkaXNhYmxlIGNhY2hpbmcuIERlZmF1bHRzIHRvIDIwIHRlbXBsYXRlcy5cbiAgICAgKi9cbiAgICBnZXQgY2RrVmlydHVhbEZvclRlbXBsYXRlQ2FjaGVTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld1JlcGVhdGVyLnZpZXdDYWNoZVNpemU7XG4gICAgfVxuICAgIHNldCBjZGtWaXJ0dWFsRm9yVGVtcGxhdGVDYWNoZVNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLl92aWV3UmVwZWF0ZXIudmlld0NhY2hlU2l6ZSA9IGNvZXJjZU51bWJlclByb3BlcnR5KHNpemUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogVGhlIHZpZXcgY29udGFpbmVyIHRvIGFkZCBpdGVtcyB0by4gKi9cbiAgICBfdmlld0NvbnRhaW5lclJlZiwgXG4gICAgLyoqIFRoZSB0ZW1wbGF0ZSB0byB1c2Ugd2hlbiBzdGFtcGluZyBvdXQgbmV3IGl0ZW1zLiAqL1xuICAgIF90ZW1wbGF0ZSwgXG4gICAgLyoqIFRoZSBzZXQgb2YgYXZhaWxhYmxlIGRpZmZlcnMuICovXG4gICAgX2RpZmZlcnMsIFxuICAgIC8qKiBUaGUgc3RyYXRlZ3kgdXNlZCB0byByZW5kZXIgaXRlbXMgaW4gdGhlIHZpcnR1YWwgc2Nyb2xsIHZpZXdwb3J0LiAqL1xuICAgIF92aWV3UmVwZWF0ZXIsIFxuICAgIC8qKiBUaGUgdmlydHVhbCBzY3JvbGxpbmcgdmlld3BvcnQgdGhhdCB0aGVzZSBpdGVtcyBhcmUgYmVpbmcgcmVuZGVyZWQgaW4uICovXG4gICAgX3ZpZXdwb3J0LCBuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZiA9IF92aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZSA9IF90ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICB0aGlzLl92aWV3UmVwZWF0ZXIgPSBfdmlld1JlcGVhdGVyO1xuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IF92aWV3cG9ydDtcbiAgICAgICAgLyoqIEVtaXRzIHdoZW4gdGhlIHJlbmRlcmVkIHZpZXcgb2YgdGhlIGRhdGEgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy52aWV3Q2hhbmdlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqIFN1YmplY3QgdGhhdCBlbWl0cyB3aGVuIGEgbmV3IERhdGFTb3VyY2UgaW5zdGFuY2UgaXMgZ2l2ZW4uICovXG4gICAgICAgIHRoaXMuX2RhdGFTb3VyY2VDaGFuZ2VzID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqIEVtaXRzIHdoZW5ldmVyIHRoZSBkYXRhIGluIHRoZSBjdXJyZW50IERhdGFTb3VyY2UgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5kYXRhU3RyZWFtID0gdGhpcy5fZGF0YVNvdXJjZUNoYW5nZXMucGlwZShcbiAgICAgICAgLy8gU3RhcnQgb2ZmIHdpdGggbnVsbCBgRGF0YVNvdXJjZWAuXG4gICAgICAgIHN0YXJ0V2l0aChudWxsKSwgXG4gICAgICAgIC8vIEJ1bmRsZSB1cCB0aGUgcHJldmlvdXMgYW5kIGN1cnJlbnQgZGF0YSBzb3VyY2VzIHNvIHdlIGNhbiB3b3JrIHdpdGggYm90aC5cbiAgICAgICAgcGFpcndpc2UoKSwgXG4gICAgICAgIC8vIFVzZSBgX2NoYW5nZURhdGFTb3VyY2VgIHRvIGRpc2Nvbm5lY3QgZnJvbSB0aGUgcHJldmlvdXMgZGF0YSBzb3VyY2UgYW5kIGNvbm5lY3QgdG8gdGhlXG4gICAgICAgIC8vIG5ldyBvbmUsIHBhc3NpbmcgYmFjayBhIHN0cmVhbSBvZiBkYXRhIGNoYW5nZXMgd2hpY2ggd2UgcnVuIHRocm91Z2ggYHN3aXRjaE1hcGAgdG8gZ2l2ZVxuICAgICAgICAvLyB1cyBhIGRhdGEgc3RyZWFtIHRoYXQgZW1pdHMgdGhlIGxhdGVzdCBkYXRhIGZyb20gd2hhdGV2ZXIgdGhlIGN1cnJlbnQgYERhdGFTb3VyY2VgIGlzLlxuICAgICAgICBzd2l0Y2hNYXAoKFtwcmV2LCBjdXJdKSA9PiB0aGlzLl9jaGFuZ2VEYXRhU291cmNlKHByZXYsIGN1cikpLCBcbiAgICAgICAgLy8gUmVwbGF5IHRoZSBsYXN0IGVtaXR0ZWQgZGF0YSB3aGVuIHNvbWVvbmUgc3Vic2NyaWJlcy5cbiAgICAgICAgc2hhcmVSZXBsYXkoMSkpO1xuICAgICAgICAvKiogVGhlIGRpZmZlciB1c2VkIHRvIGNhbGN1bGF0ZSBjaGFuZ2VzIHRvIHRoZSBkYXRhLiAqL1xuICAgICAgICB0aGlzLl9kaWZmZXIgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgcmVuZGVyZWQgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCBkdXJpbmcgdGhlIG5leHQgbmdEb0NoZWNrIGN5Y2xlLiAqL1xuICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmRhdGFTdHJlYW0uc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLl9vblJlbmRlcmVkRGF0YUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQucmVuZGVyZWRSYW5nZVN0cmVhbS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUocmFuZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZWRSYW5nZSA9IHJhbmdlO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld0NoYW5nZS5vYnNlcnZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbmdab25lLnJ1bigoKSA9PiB0aGlzLnZpZXdDaGFuZ2UubmV4dCh0aGlzLl9yZW5kZXJlZFJhbmdlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vblJlbmRlcmVkRGF0YUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnQuYXR0YWNoKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlcyB0aGUgY29tYmluZWQgc2l6ZSAod2lkdGggZm9yIGhvcml6b250YWwgb3JpZW50YXRpb24sIGhlaWdodCBmb3IgdmVydGljYWwpIG9mIGFsbCBpdGVtc1xuICAgICAqIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UuIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcmFuZ2UgaW5jbHVkZXMgaXRlbXMgdGhhdCBhcmUgbm90IGN1cnJlbnRseVxuICAgICAqIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIG1lYXN1cmVSYW5nZVNpemUocmFuZ2UsIG9yaWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydCA+PSByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocmFuZ2Uuc3RhcnQgPCB0aGlzLl9yZW5kZXJlZFJhbmdlLnN0YXJ0IHx8IHJhbmdlLmVuZCA+IHRoaXMuX3JlbmRlcmVkUmFuZ2UuZW5kKSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvcjogYXR0ZW1wdGVkIHRvIG1lYXN1cmUgYW4gaXRlbSB0aGF0IGlzbid0IHJlbmRlcmVkLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBpbmRleCBpbnRvIHRoZSBsaXN0IG9mIHJlbmRlcmVkIHZpZXdzIGZvciB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcmFuZ2UuXG4gICAgICAgIGNvbnN0IHJlbmRlcmVkU3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0IC0gdGhpcy5fcmVuZGVyZWRSYW5nZS5zdGFydDtcbiAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiB0aGUgcmFuZ2Ugd2UncmUgbWVhc3VyaW5nLlxuICAgICAgICBjb25zdCByYW5nZUxlbiA9IHJhbmdlLmVuZCAtIHJhbmdlLnN0YXJ0O1xuICAgICAgICAvLyBMb29wIG92ZXIgYWxsIHRoZSB2aWV3cywgZmluZCB0aGUgZmlyc3QgYW5kIGxhbmQgbm9kZSBhbmQgY29tcHV0ZSB0aGUgc2l6ZSBieSBzdWJ0cmFjdGluZ1xuICAgICAgICAvLyB0aGUgdG9wIG9mIHRoZSBmaXJzdCBub2RlIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgbGFzdCBvbmUuXG4gICAgICAgIGxldCBmaXJzdE5vZGU7XG4gICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3Qgbm9kZSBieSBzdGFydGluZyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGdvaW5nIGZvcndhcmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmdldChpICsgcmVuZGVyZWRTdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmICh2aWV3ICYmIHZpZXcucm9vdE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZSA9IGxhc3ROb2RlID0gdmlldy5yb290Tm9kZXNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCBub2RlIGJ5IHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBhbmQgZ29pbmcgYmFja3dhcmRzLlxuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VMZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuZ2V0KGkgKyByZW5kZXJlZFN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKHZpZXcgJiYgdmlldy5yb290Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUgPSB2aWV3LnJvb3ROb2Rlc1t2aWV3LnJvb3ROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlyc3ROb2RlICYmIGxhc3ROb2RlXG4gICAgICAgICAgICA/IGdldE9mZnNldChvcmllbnRhdGlvbiwgJ2VuZCcsIGxhc3ROb2RlKSAtIGdldE9mZnNldChvcmllbnRhdGlvbiwgJ3N0YXJ0JywgZmlyc3ROb2RlKVxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBuZ0RvQ2hlY2soKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaWZmZXIgJiYgdGhpcy5fbmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8obW1hbGVyYmEpOiBXZSBzaG91bGQgZGlmZmVyZW50aWF0ZSBuZWVkcyB1cGRhdGUgZHVlIHRvIHNjcm9sbGluZyBhbmQgYSBuZXcgcG9ydGlvbiBvZlxuICAgICAgICAgICAgLy8gdGhpcyBsaXN0IGJlaW5nIHJlbmRlcmVkIChjYW4gdXNlIHNpbXBsZXIgYWxnb3JpdGhtKSB2cyBuZWVkcyB1cGRhdGUgZHVlIHRvIGRhdGEgYWN0dWFsbHlcbiAgICAgICAgICAgIC8vIGNoYW5naW5nIChuZWVkIHRvIGRvIHRoaXMgZGlmZikuXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fcmVuZGVyZWRJdGVtcyk7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb250ZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl92aWV3cG9ydC5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZUNoYW5nZXMubmV4dCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLl9kYXRhU291cmNlQ2hhbmdlcy5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2UuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLm5leHQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMuX3ZpZXdSZXBlYXRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgLyoqIFJlYWN0IHRvIHNjcm9sbCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSB2aWV3cG9ydC4gKi9cbiAgICBfb25SZW5kZXJlZERhdGFDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQsIHRoaXMuX3JlbmRlcmVkUmFuZ2UuZW5kKTtcbiAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgIC8vIFVzZSBhIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHRoZSBgdHJhY2tCeWAgc28gYW55IG5ldyB2YWx1ZXMgYXJlXG4gICAgICAgICAgICAvLyBwaWNrZWQgdXAgYXV0b21hdGljYWxseSB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGUgZGlmZmVyLlxuICAgICAgICAgICAgdGhpcy5fZGlmZmVyID0gdGhpcy5fZGlmZmVycy5maW5kKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmNyZWF0ZSgoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jZGtWaXJ0dWFsRm9yVHJhY2tCeSA/IHRoaXMuY2RrVmlydHVhbEZvclRyYWNrQnkoaW5kZXgsIGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIFN3YXAgb3V0IG9uZSBgRGF0YVNvdXJjZWAgZm9yIGFub3RoZXIuICovXG4gICAgX2NoYW5nZURhdGFTb3VyY2Uob2xkRHMsIG5ld0RzKSB7XG4gICAgICAgIGlmIChvbGREcykge1xuICAgICAgICAgICAgb2xkRHMuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXdEcyA/IG5ld0RzLmNvbm5lY3QodGhpcykgOiBvZigpO1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSBgQ2RrVmlydHVhbEZvck9mQ29udGV4dGAgZm9yIGFsbCB2aWV3cy4gKi9cbiAgICBfdXBkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuZ2V0KGkpO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LmluZGV4ID0gdGhpcy5fcmVuZGVyZWRSYW5nZS5zdGFydCArIGk7XG4gICAgICAgICAgICB2aWV3LmNvbnRleHQuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbXB1dGVkQ29udGV4dFByb3BlcnRpZXModmlldy5jb250ZXh0KTtcbiAgICAgICAgICAgIHZpZXcuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBBcHBseSBjaGFuZ2VzIHRvIHRoZSBET00uICovXG4gICAgX2FwcGx5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdSZXBlYXRlci5hcHBseUNoYW5nZXMoY2hhbmdlcywgdGhpcy5fdmlld0NvbnRhaW5lclJlZiwgKHJlY29yZCwgX2FkanVzdGVkUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KSA9PiB0aGlzLl9nZXRFbWJlZGRlZFZpZXdBcmdzKHJlY29yZCwgY3VycmVudEluZGV4KSwgcmVjb3JkID0+IHJlY29yZC5pdGVtKTtcbiAgICAgICAgLy8gVXBkYXRlICRpbXBsaWNpdCBmb3IgYW55IGl0ZW1zIHRoYXQgaGFkIGFuIGlkZW50aXR5IGNoYW5nZS5cbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoSWRlbnRpdHlDaGFuZ2UoKHJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuZ2V0KHJlY29yZC5jdXJyZW50SW5kZXgpO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LiRpbXBsaWNpdCA9IHJlY29yZC5pdGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZXh0IHZhcmlhYmxlcyBvbiBhbGwgaXRlbXMuXG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZGF0YS5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmdldChpKTtcbiAgICAgICAgICAgIHZpZXcuY29udGV4dC5pbmRleCA9IHRoaXMuX3JlbmRlcmVkUmFuZ2Uuc3RhcnQgKyBpO1xuICAgICAgICAgICAgdmlldy5jb250ZXh0LmNvdW50ID0gY291bnQ7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb21wdXRlZENvbnRleHRQcm9wZXJ0aWVzKHZpZXcuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFVwZGF0ZSB0aGUgY29tcHV0ZWQgcHJvcGVydGllcyBvbiB0aGUgYENka1ZpcnR1YWxGb3JPZkNvbnRleHRgLiAqL1xuICAgIF91cGRhdGVDb21wdXRlZENvbnRleHRQcm9wZXJ0aWVzKGNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dC5maXJzdCA9IGNvbnRleHQuaW5kZXggPT09IDA7XG4gICAgICAgIGNvbnRleHQubGFzdCA9IGNvbnRleHQuaW5kZXggPT09IGNvbnRleHQuY291bnQgLSAxO1xuICAgICAgICBjb250ZXh0LmV2ZW4gPSBjb250ZXh0LmluZGV4ICUgMiA9PT0gMDtcbiAgICAgICAgY29udGV4dC5vZGQgPSAhY29udGV4dC5ldmVuO1xuICAgIH1cbiAgICBfZ2V0RW1iZWRkZWRWaWV3QXJncyhyZWNvcmQsIGluZGV4KSB7XG4gICAgICAgIC8vIE5vdGUgdGhhdCBpdCdzIGltcG9ydGFudCB0aGF0IHdlIGluc2VydCB0aGUgaXRlbSBkaXJlY3RseSBhdCB0aGUgcHJvcGVyIGluZGV4LFxuICAgICAgICAvLyByYXRoZXIgdGhhbiBpbnNlcnRpbmcgaXQgYW5kIHRoZSBtb3ZpbmcgaXQgaW4gcGxhY2UsIGJlY2F1c2UgaWYgdGhlcmUncyBhIGRpcmVjdGl2ZVxuICAgICAgICAvLyBvbiB0aGUgc2FtZSBub2RlIHRoYXQgaW5qZWN0cyB0aGUgYFZpZXdDb250YWluZXJSZWZgLCBBbmd1bGFyIHdpbGwgaW5zZXJ0IGFub3RoZXJcbiAgICAgICAgLy8gY29tbWVudCBub2RlIHdoaWNoIGNhbiB0aHJvdyBvZmYgdGhlIG1vdmUgd2hlbiBpdCdzIGJlaW5nIHJlcGVhdGVkIGZvciBhbGwgaXRlbXMuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVJlZjogdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgJGltcGxpY2l0OiByZWNvcmQuaXRlbSxcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGd1YXJhbnRlZWQgdGhhdCB0aGUgaXRlcmFibGUgaXMgbm90IFwidW5kZWZpbmVkXCIgb3IgXCJudWxsXCIgYmVjYXVzZSB3ZSBvbmx5XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdmlld3MgZm9yIGVsZW1lbnRzIGlmIHRoZSBcImNka1ZpcnR1YWxGb3JPZlwiIGl0ZXJhYmxlIGhhcyBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICBjZGtWaXJ0dWFsRm9yT2Y6IHRoaXMuX2Nka1ZpcnR1YWxGb3JPZixcbiAgICAgICAgICAgICAgICBpbmRleDogLTEsXG4gICAgICAgICAgICAgICAgY291bnQ6IC0xLFxuICAgICAgICAgICAgICAgIGZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYXN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBvZGQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGV2ZW46IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICB9O1xuICAgIH1cbn1cbkNka1ZpcnR1YWxGb3JPZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1ZpcnR1YWxGb3JPZiwgZGVwczogW3sgdG9rZW46IGkwLlZpZXdDb250YWluZXJSZWYgfSwgeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfSwgeyB0b2tlbjogaTAuSXRlcmFibGVEaWZmZXJzIH0sIHsgdG9rZW46IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZIH0sIHsgdG9rZW46IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogaTAuTmdab25lIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka1ZpcnR1YWxGb3JPZi7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka1ZpcnR1YWxGb3JPZiwgaXNTdGFuZGFsb25lOiB0cnVlLCBzZWxlY3RvcjogXCJbY2RrVmlydHVhbEZvcl1bY2RrVmlydHVhbEZvck9mXVwiLCBpbnB1dHM6IHsgY2RrVmlydHVhbEZvck9mOiBcImNka1ZpcnR1YWxGb3JPZlwiLCBjZGtWaXJ0dWFsRm9yVHJhY2tCeTogXCJjZGtWaXJ0dWFsRm9yVHJhY2tCeVwiLCBjZGtWaXJ0dWFsRm9yVGVtcGxhdGU6IFwiY2RrVmlydHVhbEZvclRlbXBsYXRlXCIsIGNka1ZpcnR1YWxGb3JUZW1wbGF0ZUNhY2hlU2l6ZTogXCJjZGtWaXJ0dWFsRm9yVGVtcGxhdGVDYWNoZVNpemVcIiB9LCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCB1c2VDbGFzczogX1JlY3ljbGVWaWV3UmVwZWF0ZXJTdHJhdGVneSB9XSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVmlydHVhbEZvck9mLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrVmlydHVhbEZvcl1bY2RrVmlydHVhbEZvck9mXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1ksIHVzZUNsYXNzOiBfUmVjeWNsZVZpZXdSZXBlYXRlclN0cmF0ZWd5IH1dLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVmlld0NvbnRhaW5lclJlZiB9LCB7IHR5cGU6IGkwLlRlbXBsYXRlUmVmIH0sIHsgdHlwZTogaTAuSXRlcmFibGVEaWZmZXJzIH0sIHsgdHlwZTogaTIkMS5fUmVjeWNsZVZpZXdSZXBlYXRlclN0cmF0ZWd5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtfVklFV19SRVBFQVRFUl9TVFJBVEVHWV1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IGkwLk5nWm9uZSB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgY2RrVmlydHVhbEZvck9mOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgY2RrVmlydHVhbEZvclRyYWNrQnk6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBjZGtWaXJ0dWFsRm9yVGVtcGxhdGU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBjZGtWaXJ0dWFsRm9yVGVtcGxhdGVDYWNoZVNpemU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhIHZpcnR1YWwgc2Nyb2xsYWJsZSBmb3IgdGhlIGVsZW1lbnQgaXQgaXMgYXR0YWNoZWQgdG8uXG4gKi9cbmNsYXNzIENka1ZpcnR1YWxTY3JvbGxhYmxlRWxlbWVudCBleHRlbmRzIENka1ZpcnR1YWxTY3JvbGxhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmLCBzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcikge1xuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcik7XG4gICAgfVxuICAgIG1lYXN1cmVCb3VuZGluZ0NsaWVudFJlY3RXaXRoU2Nyb2xsT2Zmc2V0KGZyb20pIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2Zyb21dIC1cbiAgICAgICAgICAgIHRoaXMubWVhc3VyZVNjcm9sbE9mZnNldChmcm9tKSk7XG4gICAgfVxufVxuQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50LCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBpMi5EaXJlY3Rpb25hbGl0eSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50Lsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50LCBpc1N0YW5kYWxvbmU6IHRydWUsIHNlbGVjdG9yOiBcIltjZGtWaXJ0dWFsU2Nyb2xsaW5nRWxlbWVudF1cIiwgaG9zdDogeyBjbGFzc0F0dHJpYnV0ZTogXCJjZGstdmlydHVhbC1zY3JvbGxhYmxlXCIgfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBWSVJUVUFMX1NDUk9MTEFCTEUsIHVzZUV4aXN0aW5nOiBDZGtWaXJ0dWFsU2Nyb2xsYWJsZUVsZW1lbnQgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrVmlydHVhbFNjcm9sbGluZ0VsZW1lbnRdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBWSVJUVUFMX1NDUk9MTEFCTEUsIHVzZUV4aXN0aW5nOiBDZGtWaXJ0dWFsU2Nyb2xsYWJsZUVsZW1lbnQgfV0sXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstdmlydHVhbC1zY3JvbGxhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogaTIuRGlyZWN0aW9uYWxpdHksIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBQcm92aWRlcyBhcyB2aXJ0dWFsIHNjcm9sbGFibGUgZm9yIHRoZSBnbG9iYWwgLyB3aW5kb3cgc2Nyb2xsYmFyLlxuICovXG5jbGFzcyBDZGtWaXJ0dWFsU2Nyb2xsYWJsZVdpbmRvdyBleHRlbmRzIENka1ZpcnR1YWxTY3JvbGxhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcikge1xuICAgICAgICBzdXBlcihuZXcgRWxlbWVudFJlZihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLCBzY3JvbGxEaXNwYXRjaGVyLCBuZ1pvbmUsIGRpcik7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTY3JvbGxlZCA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcikgPT4gdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gZnJvbUV2ZW50KGRvY3VtZW50LCAnc2Nyb2xsJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKG9ic2VydmVyKSkpO1xuICAgIH1cbiAgICBtZWFzdXJlQm91bmRpbmdDbGllbnRSZWN0V2l0aFNjcm9sbE9mZnNldChmcm9tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnRSZWYoKS5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2Zyb21dO1xuICAgIH1cbn1cbkNka1ZpcnR1YWxTY3JvbGxhYmxlV2luZG93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVmlydHVhbFNjcm9sbGFibGVXaW5kb3csIGRlcHM6IFt7IHRva2VuOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdG9rZW46IGkwLk5nWm9uZSB9LCB7IHRva2VuOiBpMi5EaXJlY3Rpb25hbGl0eSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrVmlydHVhbFNjcm9sbGFibGVXaW5kb3cuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtWaXJ0dWFsU2Nyb2xsYWJsZVdpbmRvdywgaXNTdGFuZGFsb25lOiB0cnVlLCBzZWxlY3RvcjogXCJjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnRbc2Nyb2xsV2luZG93XVwiLCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFZJUlRVQUxfU0NST0xMQUJMRSwgdXNlRXhpc3Rpbmc6IENka1ZpcnR1YWxTY3JvbGxhYmxlV2luZG93IH1dLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1ZpcnR1YWxTY3JvbGxhYmxlV2luZG93LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstdmlydHVhbC1zY3JvbGwtdmlld3BvcnRbc2Nyb2xsV2luZG93XScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogVklSVFVBTF9TQ1JPTExBQkxFLCB1c2VFeGlzdGluZzogQ2RrVmlydHVhbFNjcm9sbGFibGVXaW5kb3cgfV0sXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBTY3JvbGxEaXNwYXRjaGVyIH0sIHsgdHlwZTogaTAuTmdab25lIH0sIHsgdHlwZTogaTIuRGlyZWN0aW9uYWxpdHksIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuY2xhc3MgQ2RrU2Nyb2xsYWJsZU1vZHVsZSB7XG59XG5DZGtTY3JvbGxhYmxlTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrU2Nyb2xsYWJsZU1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5DZGtTY3JvbGxhYmxlTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1Njcm9sbGFibGVNb2R1bGUsIGltcG9ydHM6IFtDZGtTY3JvbGxhYmxlXSwgZXhwb3J0czogW0Nka1Njcm9sbGFibGVdIH0pO1xuQ2RrU2Nyb2xsYWJsZU1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtTY3JvbGxhYmxlTW9kdWxlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrU2Nyb2xsYWJsZU1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0Nka1Njcm9sbGFibGVdLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbQ2RrU2Nyb2xsYWJsZV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIEBkb2NzLXByaW1hcnktZXhwb3J0XG4gKi9cbmNsYXNzIFNjcm9sbGluZ01vZHVsZSB7XG59XG5TY3JvbGxpbmdNb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBTY3JvbGxpbmdNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pO1xuU2Nyb2xsaW5nTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNjcm9sbGluZ01vZHVsZSwgaW1wb3J0czogW0JpZGlNb2R1bGUsIENka1Njcm9sbGFibGVNb2R1bGUsIENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCxcbiAgICAgICAgQ2RrRml4ZWRTaXplVmlydHVhbFNjcm9sbCxcbiAgICAgICAgQ2RrVmlydHVhbEZvck9mLFxuICAgICAgICBDZGtWaXJ0dWFsU2Nyb2xsYWJsZVdpbmRvdyxcbiAgICAgICAgQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50XSwgZXhwb3J0czogW0JpZGlNb2R1bGUsIENka1Njcm9sbGFibGVNb2R1bGUsIENka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGwsXG4gICAgICAgIENka1ZpcnR1YWxGb3JPZixcbiAgICAgICAgQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0LFxuICAgICAgICBDZGtWaXJ0dWFsU2Nyb2xsYWJsZVdpbmRvdyxcbiAgICAgICAgQ2RrVmlydHVhbFNjcm9sbGFibGVFbGVtZW50XSB9KTtcblNjcm9sbGluZ01vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBTY3JvbGxpbmdNb2R1bGUsIGltcG9ydHM6IFtCaWRpTW9kdWxlLFxuICAgICAgICBDZGtTY3JvbGxhYmxlTW9kdWxlLFxuICAgICAgICBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIEJpZGlNb2R1bGUsIENka1Njcm9sbGFibGVNb2R1bGVdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2Nyb2xsaW5nTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBCaWRpTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2RrU2Nyb2xsYWJsZU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENka1ZpcnR1YWxTY3JvbGxWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIENka0ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBDZGtWaXJ0dWFsRm9yT2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBDZGtWaXJ0dWFsU2Nyb2xsYWJsZVdpbmRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIENka1ZpcnR1YWxTY3JvbGxhYmxlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgQmlkaU1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIENka1Njcm9sbGFibGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBDZGtGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsLFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2RrVmlydHVhbEZvck9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2RrVmlydHVhbFNjcm9sbFZpZXdwb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQ2RrVmlydHVhbFNjcm9sbGFibGVXaW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBDZGtWaXJ0dWFsU2Nyb2xsYWJsZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQ2RrRml4ZWRTaXplVmlydHVhbFNjcm9sbCwgQ2RrU2Nyb2xsYWJsZSwgQ2RrU2Nyb2xsYWJsZU1vZHVsZSwgQ2RrVmlydHVhbEZvck9mLCBDZGtWaXJ0dWFsU2Nyb2xsVmlld3BvcnQsIENka1ZpcnR1YWxTY3JvbGxhYmxlLCBDZGtWaXJ0dWFsU2Nyb2xsYWJsZUVsZW1lbnQsIENka1ZpcnR1YWxTY3JvbGxhYmxlV2luZG93LCBERUZBVUxUX1JFU0laRV9USU1FLCBERUZBVUxUX1NDUk9MTF9USU1FLCBGaXhlZFNpemVWaXJ0dWFsU2Nyb2xsU3RyYXRlZ3ksIFNjcm9sbERpc3BhdGNoZXIsIFNjcm9sbGluZ01vZHVsZSwgVklSVFVBTF9TQ1JPTExBQkxFLCBWSVJUVUFMX1NDUk9MTF9TVFJBVEVHWSwgVmlld3BvcnRSdWxlciwgX2ZpeGVkU2l6ZVZpcnR1YWxTY3JvbGxTdHJhdGVneUZhY3RvcnkgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbGluZy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/scrolling.mjs\n");

/***/ }),

/***/ "./node_modules/@angular/cdk/fesm2020/table.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@angular/cdk/fesm2020/table.mjs ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BaseCdkCell\": function() { return /* binding */ BaseCdkCell; },\n/* harmony export */   \"BaseRowDef\": function() { return /* binding */ BaseRowDef; },\n/* harmony export */   \"CDK_ROW_TEMPLATE\": function() { return /* binding */ CDK_ROW_TEMPLATE; },\n/* harmony export */   \"CDK_TABLE\": function() { return /* binding */ CDK_TABLE; },\n/* harmony export */   \"CDK_TABLE_TEMPLATE\": function() { return /* binding */ CDK_TABLE_TEMPLATE; },\n/* harmony export */   \"CdkCell\": function() { return /* binding */ CdkCell; },\n/* harmony export */   \"CdkCellDef\": function() { return /* binding */ CdkCellDef; },\n/* harmony export */   \"CdkCellOutlet\": function() { return /* binding */ CdkCellOutlet; },\n/* harmony export */   \"CdkColumnDef\": function() { return /* binding */ CdkColumnDef; },\n/* harmony export */   \"CdkFooterCell\": function() { return /* binding */ CdkFooterCell; },\n/* harmony export */   \"CdkFooterCellDef\": function() { return /* binding */ CdkFooterCellDef; },\n/* harmony export */   \"CdkFooterRow\": function() { return /* binding */ CdkFooterRow; },\n/* harmony export */   \"CdkFooterRowDef\": function() { return /* binding */ CdkFooterRowDef; },\n/* harmony export */   \"CdkHeaderCell\": function() { return /* binding */ CdkHeaderCell; },\n/* harmony export */   \"CdkHeaderCellDef\": function() { return /* binding */ CdkHeaderCellDef; },\n/* harmony export */   \"CdkHeaderRow\": function() { return /* binding */ CdkHeaderRow; },\n/* harmony export */   \"CdkHeaderRowDef\": function() { return /* binding */ CdkHeaderRowDef; },\n/* harmony export */   \"CdkNoDataRow\": function() { return /* binding */ CdkNoDataRow; },\n/* harmony export */   \"CdkRecycleRows\": function() { return /* binding */ CdkRecycleRows; },\n/* harmony export */   \"CdkRow\": function() { return /* binding */ CdkRow; },\n/* harmony export */   \"CdkRowDef\": function() { return /* binding */ CdkRowDef; },\n/* harmony export */   \"CdkTable\": function() { return /* binding */ CdkTable; },\n/* harmony export */   \"CdkTableModule\": function() { return /* binding */ CdkTableModule; },\n/* harmony export */   \"CdkTextColumn\": function() { return /* binding */ CdkTextColumn; },\n/* harmony export */   \"DataRowOutlet\": function() { return /* binding */ DataRowOutlet; },\n/* harmony export */   \"DataSource\": function() { return /* reexport safe */ _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__.DataSource; },\n/* harmony export */   \"FooterRowOutlet\": function() { return /* binding */ FooterRowOutlet; },\n/* harmony export */   \"HeaderRowOutlet\": function() { return /* binding */ HeaderRowOutlet; },\n/* harmony export */   \"NoDataRowOutlet\": function() { return /* binding */ NoDataRowOutlet; },\n/* harmony export */   \"STICKY_DIRECTIONS\": function() { return /* binding */ STICKY_DIRECTIONS; },\n/* harmony export */   \"STICKY_POSITIONING_LISTENER\": function() { return /* binding */ STICKY_POSITIONING_LISTENER; },\n/* harmony export */   \"StickyStyler\": function() { return /* binding */ StickyStyler; },\n/* harmony export */   \"TEXT_COLUMN_OPTIONS\": function() { return /* binding */ TEXT_COLUMN_OPTIONS; },\n/* harmony export */   \"_COALESCED_STYLE_SCHEDULER\": function() { return /* binding */ _COALESCED_STYLE_SCHEDULER; },\n/* harmony export */   \"_CoalescedStyleScheduler\": function() { return /* binding */ _CoalescedStyleScheduler; },\n/* harmony export */   \"_Schedule\": function() { return /* binding */ _Schedule; },\n/* harmony export */   \"mixinHasStickyInput\": function() { return /* binding */ mixinHasStickyInput; }\n/* harmony export */ });\n/* harmony import */ var _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @angular/cdk/bidi */ \"./node_modules/@angular/cdk/fesm2020/bidi.mjs\");\n/* harmony import */ var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @angular/cdk/coercion */ \"./node_modules/@angular/cdk/fesm2020/coercion.mjs\");\n/* harmony import */ var _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/cdk/collections */ \"./node_modules/@angular/cdk/fesm2020/collections.mjs\");\n/* harmony import */ var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/cdk/platform */ \"./node_modules/@angular/cdk/fesm2020/platform.mjs\");\n/* harmony import */ var _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/cdk/scrolling */ \"./node_modules/@angular/cdk/fesm2020/scrolling.mjs\");\n/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ \"webpack/sharing/consume/default/@angular/common/@angular/common\");\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs */ \"webpack/sharing/consume/default/rxjs/rxjs\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Mixin to provide a directive with a function that checks if the sticky input has been\n * changed since the last time the function was called. Essentially adds a dirty-check to the\n * sticky value.\n * @docs-private\n */\nfunction mixinHasStickyInput(base) {\n    return class extends base {\n        /** Whether sticky positioning should be applied. */\n        get sticky() {\n            return this._sticky;\n        }\n        set sticky(v) {\n            const prevValue = this._sticky;\n            this._sticky = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);\n            this._hasStickyChanged = prevValue !== this._sticky;\n        }\n        /** Whether the sticky value has changed since this was last called. */\n        hasStickyChanged() {\n            const hasStickyChanged = this._hasStickyChanged;\n            this._hasStickyChanged = false;\n            return hasStickyChanged;\n        }\n        /** Resets the dirty check for cases where the sticky state has been used without checking. */\n        resetStickyChanged() {\n            this._hasStickyChanged = false;\n        }\n        constructor(...args) {\n            super(...args);\n            this._sticky = false;\n            /** Whether the sticky input has changed since it was last checked. */\n            this._hasStickyChanged = false;\n        }\n    };\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to provide a table to some of the sub-components without causing a circular dependency.\n * @docs-private\n */\nconst CDK_TABLE = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('CDK_TABLE');\n/** Injection token that can be used to specify the text column options. */\nconst TEXT_COLUMN_OPTIONS = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('text-column-options');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Cell definition for a CDK table.\n * Captures the template of a column's data row cell as well as cell-specific properties.\n */\nclass CdkCellDef {\n    constructor(/** @docs-private */ template) {\n        this.template = template;\n    }\n}\nCdkCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCellDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkCellDef, selector: \"[cdkCellDef]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[cdkCellDef]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }]; } });\n/**\n * Header cell definition for a CDK table.\n * Captures the template of a column's header cell and as well as cell-specific properties.\n */\nclass CdkHeaderCellDef {\n    constructor(/** @docs-private */ template) {\n        this.template = template;\n    }\n}\nCdkHeaderCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderCellDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkHeaderCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkHeaderCellDef, selector: \"[cdkHeaderCellDef]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[cdkHeaderCellDef]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }]; } });\n/**\n * Footer cell definition for a CDK table.\n * Captures the template of a column's footer cell and as well as cell-specific properties.\n */\nclass CdkFooterCellDef {\n    constructor(/** @docs-private */ template) {\n        this.template = template;\n    }\n}\nCdkFooterCellDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterCellDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkFooterCellDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkFooterCellDef, selector: \"[cdkFooterCellDef]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterCellDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[cdkFooterCellDef]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }]; } });\n// Boilerplate for applying mixins to CdkColumnDef.\n/** @docs-private */\nclass CdkColumnDefBase {\n}\nconst _CdkColumnDefBase = mixinHasStickyInput(CdkColumnDefBase);\n/**\n * Column definition for the CDK table.\n * Defines a set of cells available for a table column.\n */\nclass CdkColumnDef extends _CdkColumnDefBase {\n    /** Unique name for this column. */\n    get name() {\n        return this._name;\n    }\n    set name(name) {\n        this._setNameInput(name);\n    }\n    /**\n     * Whether this column should be sticky positioned on the end of the row. Should make sure\n     * that it mimics the `CanStick` mixin such that `_hasStickyChanged` is set to true if the value\n     * has been changed.\n     */\n    get stickyEnd() {\n        return this._stickyEnd;\n    }\n    set stickyEnd(v) {\n        const prevValue = this._stickyEnd;\n        this._stickyEnd = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);\n        this._hasStickyChanged = prevValue !== this._stickyEnd;\n    }\n    constructor(_table) {\n        super();\n        this._table = _table;\n        this._stickyEnd = false;\n    }\n    /**\n     * Overridable method that sets the css classes that will be added to every cell in this\n     * column.\n     * In the future, columnCssClassName will change from type string[] to string and this\n     * will set a single string value.\n     * @docs-private\n     */\n    _updateColumnCssClassName() {\n        this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`];\n    }\n    /**\n     * This has been extracted to a util because of TS 4 and VE.\n     * View Engine doesn't support property rename inheritance.\n     * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n     * @docs-private\n     */\n    _setNameInput(value) {\n        // If the directive is set without a name (updated programmatically), then this setter will\n        // trigger with an empty string and should not overwrite the programmatically set value.\n        if (value) {\n            this._name = value;\n            this.cssClassFriendlyName = value.replace(/[^a-z0-9_-]/gi, '-');\n            this._updateColumnCssClassName();\n        }\n    }\n}\nCdkColumnDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkColumnDef, deps: [{ token: CDK_TABLE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkColumnDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkColumnDef, selector: \"[cdkColumnDef]\", inputs: { sticky: \"sticky\", name: [\"cdkColumnDef\", \"name\"], stickyEnd: \"stickyEnd\" }, providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }], queries: [{ propertyName: \"cell\", first: true, predicate: CdkCellDef, descendants: true }, { propertyName: \"headerCell\", first: true, predicate: CdkHeaderCellDef, descendants: true }, { propertyName: \"footerCell\", first: true, predicate: CdkFooterCellDef, descendants: true }], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkColumnDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: '[cdkColumnDef]',\n                    inputs: ['sticky'],\n                    providers: [{ provide: 'MAT_SORT_HEADER_COLUMN_DEF', useExisting: CdkColumnDef }],\n                }]\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [CDK_TABLE]\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }]; }, propDecorators: { name: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,\n                args: ['cdkColumnDef']\n            }], stickyEnd: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input,\n                args: ['stickyEnd']\n            }], cell: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChild,\n                args: [CdkCellDef]\n            }], headerCell: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChild,\n                args: [CdkHeaderCellDef]\n            }], footerCell: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChild,\n                args: [CdkFooterCellDef]\n            }] } });\n/** Base class for the cells. Adds a CSS classname that identifies the column it renders in. */\nclass BaseCdkCell {\n    constructor(columnDef, elementRef) {\n        elementRef.nativeElement.classList.add(...columnDef._columnCssClassName);\n    }\n}\n/** Header cell template container that adds the right classes and role. */\nclass CdkHeaderCell extends BaseCdkCell {\n    constructor(columnDef, elementRef) {\n        super(columnDef, elementRef);\n    }\n}\nCdkHeaderCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderCell, deps: [{ token: CdkColumnDef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkHeaderCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkHeaderCell, selector: \"cdk-header-cell, th[cdk-header-cell]\", host: { attributes: { \"role\": \"columnheader\" }, classAttribute: \"cdk-header-cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: 'cdk-header-cell, th[cdk-header-cell]',\n                    host: {\n                        'class': 'cdk-header-cell',\n                        'role': 'columnheader',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: CdkColumnDef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/** Footer cell template container that adds the right classes and role. */\nclass CdkFooterCell extends BaseCdkCell {\n    constructor(columnDef, elementRef) {\n        super(columnDef, elementRef);\n        if (columnDef._table?._elementRef.nativeElement.nodeType === 1) {\n            const tableRole = columnDef._table._elementRef.nativeElement.getAttribute('role');\n            const role = tableRole === 'grid' || tableRole === 'treegrid' ? 'gridcell' : 'cell';\n            elementRef.nativeElement.setAttribute('role', role);\n        }\n    }\n}\nCdkFooterCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterCell, deps: [{ token: CdkColumnDef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkFooterCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkFooterCell, selector: \"cdk-footer-cell, td[cdk-footer-cell]\", host: { classAttribute: \"cdk-footer-cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: 'cdk-footer-cell, td[cdk-footer-cell]',\n                    host: {\n                        'class': 'cdk-footer-cell',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: CdkColumnDef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/** Cell template container that adds the right classes and role. */\nclass CdkCell extends BaseCdkCell {\n    constructor(columnDef, elementRef) {\n        super(columnDef, elementRef);\n        if (columnDef._table?._elementRef.nativeElement.nodeType === 1) {\n            const tableRole = columnDef._table._elementRef.nativeElement.getAttribute('role');\n            const role = tableRole === 'grid' || tableRole === 'treegrid' ? 'gridcell' : 'cell';\n            elementRef.nativeElement.setAttribute('role', role);\n        }\n    }\n}\nCdkCell.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCell, deps: [{ token: CdkColumnDef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkCell.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkCell, selector: \"cdk-cell, td[cdk-cell]\", host: { classAttribute: \"cdk-cell\" }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCell, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: 'cdk-cell, td[cdk-cell]',\n                    host: {\n                        'class': 'cdk-cell',\n                    },\n                }]\n        }], ctorParameters: function () { return [{ type: CdkColumnDef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @docs-private\n */\nclass _Schedule {\n    constructor() {\n        this.tasks = [];\n        this.endTasks = [];\n    }\n}\n/** Injection token used to provide a coalesced style scheduler. */\nconst _COALESCED_STYLE_SCHEDULER = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('_COALESCED_STYLE_SCHEDULER');\n/**\n * Allows grouping up CSSDom mutations after the current execution context.\n * This can significantly improve performance when separate consecutive functions are\n * reading from the CSSDom and then mutating it.\n *\n * @docs-private\n */\nclass _CoalescedStyleScheduler {\n    constructor(_ngZone) {\n        this._ngZone = _ngZone;\n        this._currentSchedule = null;\n        this._destroyed = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();\n    }\n    /**\n     * Schedules the specified task to run at the end of the current VM turn.\n     */\n    schedule(task) {\n        this._createScheduleIfNeeded();\n        this._currentSchedule.tasks.push(task);\n    }\n    /**\n     * Schedules the specified task to run after other scheduled tasks at the end of the current\n     * VM turn.\n     */\n    scheduleEnd(task) {\n        this._createScheduleIfNeeded();\n        this._currentSchedule.endTasks.push(task);\n    }\n    /** Prevent any further tasks from running. */\n    ngOnDestroy() {\n        this._destroyed.next();\n        this._destroyed.complete();\n    }\n    _createScheduleIfNeeded() {\n        if (this._currentSchedule) {\n            return;\n        }\n        this._currentSchedule = new _Schedule();\n        this._getScheduleObservable()\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._destroyed))\n            .subscribe(() => {\n            while (this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length) {\n                const schedule = this._currentSchedule;\n                // Capture new tasks scheduled by the current set of tasks.\n                this._currentSchedule = new _Schedule();\n                for (const task of schedule.tasks) {\n                    task();\n                }\n                for (const task of schedule.endTasks) {\n                    task();\n                }\n            }\n            this._currentSchedule = null;\n        });\n    }\n    _getScheduleObservable() {\n        // Use onStable when in the context of an ongoing change detection cycle so that we\n        // do not accidentally trigger additional cycles.\n        return this._ngZone.isStable\n            ? (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.from)(Promise.resolve(undefined))\n            : this._ngZone.onStable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.take)(1));\n    }\n}\n_CoalescedStyleScheduler.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: _CoalescedStyleScheduler, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Injectable });\n_CoalescedStyleScheduler.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: _CoalescedStyleScheduler });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: _CoalescedStyleScheduler, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Injectable\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The row template that can be used by the mat-table. Should not be used outside of the\n * material library.\n */\nconst CDK_ROW_TEMPLATE = `<ng-container cdkCellOutlet></ng-container>`;\n/**\n * Base class for the CdkHeaderRowDef and CdkRowDef that handles checking their columns inputs\n * for changes and notifying the table.\n */\nclass BaseRowDef {\n    constructor(\n    /** @docs-private */ template, _differs) {\n        this.template = template;\n        this._differs = _differs;\n    }\n    ngOnChanges(changes) {\n        // Create a new columns differ if one does not yet exist. Initialize it based on initial value\n        // of the columns property or an empty array if none is provided.\n        if (!this._columnsDiffer) {\n            const columns = (changes['columns'] && changes['columns'].currentValue) || [];\n            this._columnsDiffer = this._differs.find(columns).create();\n            this._columnsDiffer.diff(columns);\n        }\n    }\n    /**\n     * Returns the difference between the current columns and the columns from the last diff, or null\n     * if there is no difference.\n     */\n    getColumnsDiff() {\n        return this._columnsDiffer.diff(this.columns);\n    }\n    /** Gets this row def's relevant cell template from the provided column def. */\n    extractCellTemplate(column) {\n        if (this instanceof CdkHeaderRowDef) {\n            return column.headerCell.template;\n        }\n        if (this instanceof CdkFooterRowDef) {\n            return column.footerCell.template;\n        }\n        else {\n            return column.cell.template;\n        }\n    }\n}\nBaseRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: BaseRowDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nBaseRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: BaseRowDef, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: BaseRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }]; } });\n// Boilerplate for applying mixins to CdkHeaderRowDef.\n/** @docs-private */\nclass CdkHeaderRowDefBase extends BaseRowDef {\n}\nconst _CdkHeaderRowDefBase = mixinHasStickyInput(CdkHeaderRowDefBase);\n/**\n * Header row definition for the CDK table.\n * Captures the header row's template and other header properties such as the columns to display.\n */\nclass CdkHeaderRowDef extends _CdkHeaderRowDefBase {\n    constructor(template, _differs, _table) {\n        super(template, _differs);\n        this._table = _table;\n    }\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\n    ngOnChanges(changes) {\n        super.ngOnChanges(changes);\n    }\n}\nCdkHeaderRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderRowDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { token: CDK_TABLE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkHeaderRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkHeaderRowDef, selector: \"[cdkHeaderRowDef]\", inputs: { columns: [\"cdkHeaderRowDef\", \"columns\"], sticky: [\"cdkHeaderRowDefSticky\", \"sticky\"] }, usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: '[cdkHeaderRowDef]',\n                    inputs: ['columns: cdkHeaderRowDef', 'sticky: cdkHeaderRowDefSticky'],\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [CDK_TABLE]\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }]; } });\n// Boilerplate for applying mixins to CdkFooterRowDef.\n/** @docs-private */\nclass CdkFooterRowDefBase extends BaseRowDef {\n}\nconst _CdkFooterRowDefBase = mixinHasStickyInput(CdkFooterRowDefBase);\n/**\n * Footer row definition for the CDK table.\n * Captures the footer row's template and other footer properties such as the columns to display.\n */\nclass CdkFooterRowDef extends _CdkFooterRowDefBase {\n    constructor(template, _differs, _table) {\n        super(template, _differs);\n        this._table = _table;\n    }\n    // Prerender fails to recognize that ngOnChanges in a part of this class through inheritance.\n    // Explicitly define it so that the method is called as part of the Angular lifecycle.\n    ngOnChanges(changes) {\n        super.ngOnChanges(changes);\n    }\n}\nCdkFooterRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterRowDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { token: CDK_TABLE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkFooterRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkFooterRowDef, selector: \"[cdkFooterRowDef]\", inputs: { columns: [\"cdkFooterRowDef\", \"columns\"], sticky: [\"cdkFooterRowDefSticky\", \"sticky\"] }, usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: '[cdkFooterRowDef]',\n                    inputs: ['columns: cdkFooterRowDef', 'sticky: cdkFooterRowDefSticky'],\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [CDK_TABLE]\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }]; } });\n/**\n * Data row definition for the CDK table.\n * Captures the header row's template and other row properties such as the columns to display and\n * a when predicate that describes when this row should be used.\n */\nclass CdkRowDef extends BaseRowDef {\n    // TODO(andrewseguin): Add an input for providing a switch function to determine\n    //   if this template should be used.\n    constructor(template, _differs, _table) {\n        super(template, _differs);\n        this._table = _table;\n    }\n}\nCdkRowDef.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRowDef, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { token: CDK_TABLE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkRowDef.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkRowDef, selector: \"[cdkRowDef]\", inputs: { columns: [\"cdkRowDefColumns\", \"columns\"], when: [\"cdkRowDefWhen\", \"when\"] }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRowDef, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: '[cdkRowDef]',\n                    inputs: ['columns: cdkRowDefColumns', 'when: cdkRowDefWhen'],\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [CDK_TABLE]\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }]; } });\n/**\n * Outlet for rendering cells inside of a row or header row.\n * @docs-private\n */\nclass CdkCellOutlet {\n    constructor(_viewContainer) {\n        this._viewContainer = _viewContainer;\n        CdkCellOutlet.mostRecentCellOutlet = this;\n    }\n    ngOnDestroy() {\n        // If this was the last outlet being rendered in the view, remove the reference\n        // from the static property after it has been destroyed to avoid leaking memory.\n        if (CdkCellOutlet.mostRecentCellOutlet === this) {\n            CdkCellOutlet.mostRecentCellOutlet = null;\n        }\n    }\n}\n/**\n * Static property containing the latest constructed instance of this class.\n * Used by the CDK table when each CdkHeaderRow and CdkRow component is created using\n * createEmbeddedView. After one of these components are created, this property will provide\n * a handle to provide that component's cells and context. After init, the CdkCellOutlet will\n * construct the cells with the provided context.\n */\nCdkCellOutlet.mostRecentCellOutlet = null;\nCdkCellOutlet.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCellOutlet, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkCellOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkCellOutlet, selector: \"[cdkCellOutlet]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkCellOutlet, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[cdkCellOutlet]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }]; } });\n/** Header template container that contains the cell outlet. Adds the right class and role. */\nclass CdkHeaderRow {\n}\nCdkHeaderRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderRow, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Component });\nCdkHeaderRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkHeaderRow, selector: \"cdk-header-row, tr[cdk-header-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"cdk-header-row\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkHeaderRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,\n            args: [{\n                    selector: 'cdk-header-row, tr[cdk-header-row]',\n                    template: CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'cdk-header-row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None,\n                }]\n        }] });\n/** Footer template container that contains the cell outlet. Adds the right class and role. */\nclass CdkFooterRow {\n}\nCdkFooterRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterRow, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Component });\nCdkFooterRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkFooterRow, selector: \"cdk-footer-row, tr[cdk-footer-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"cdk-footer-row\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkFooterRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,\n            args: [{\n                    selector: 'cdk-footer-row, tr[cdk-footer-row]',\n                    template: CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'cdk-footer-row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None,\n                }]\n        }] });\n/** Data row template container that contains the cell outlet. Adds the right class and role. */\nclass CdkRow {\n}\nCdkRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRow, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Component });\nCdkRow.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkRow, selector: \"cdk-row, tr[cdk-row]\", host: { attributes: { \"role\": \"row\" }, classAttribute: \"cdk-row\" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), template: \"<ng-container cdkCellOutlet></ng-container>\", isInline: true, dependencies: [{ kind: \"directive\", type: CdkCellOutlet, selector: \"[cdkCellOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,\n            args: [{\n                    selector: 'cdk-row, tr[cdk-row]',\n                    template: CDK_ROW_TEMPLATE,\n                    host: {\n                        'class': 'cdk-row',\n                        'role': 'row',\n                    },\n                    // See note on CdkTable for explanation on why this uses the default change detection strategy.\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None,\n                }]\n        }] });\n/** Row that can be used to display a message when no data is shown in the table. */\nclass CdkNoDataRow {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n        this._contentClassName = 'cdk-no-data-row';\n    }\n}\nCdkNoDataRow.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkNoDataRow, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkNoDataRow.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkNoDataRow, selector: \"ng-template[cdkNoDataRow]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkNoDataRow, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: 'ng-template[cdkNoDataRow]',\n                }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.TemplateRef }]; } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * List of all possible directions that can be used for sticky positioning.\n * @docs-private\n */\nconst STICKY_DIRECTIONS = ['top', 'bottom', 'left', 'right'];\n/**\n * Applies and removes sticky positioning styles to the `CdkTable` rows and columns cells.\n * @docs-private\n */\nclass StickyStyler {\n    /**\n     * @param _isNativeHtmlTable Whether the sticky logic should be based on a table\n     *     that uses the native `<table>` element.\n     * @param _stickCellCss The CSS class that will be applied to every row/cell that has\n     *     sticky positioning applied.\n     * @param direction The directionality context of the table (ltr/rtl); affects column positioning\n     *     by reversing left/right positions.\n     * @param _isBrowser Whether the table is currently being rendered on the server or the client.\n     * @param _needsPositionStickyOnElement Whether we need to specify position: sticky on cells\n     *     using inline styles. If false, it is assumed that position: sticky is included in\n     *     the component stylesheet for _stickCellCss.\n     * @param _positionListener A listener that is notified of changes to sticky rows/columns\n     *     and their dimensions.\n     */\n    constructor(_isNativeHtmlTable, _stickCellCss, direction, _coalescedStyleScheduler, _isBrowser = true, _needsPositionStickyOnElement = true, _positionListener) {\n        this._isNativeHtmlTable = _isNativeHtmlTable;\n        this._stickCellCss = _stickCellCss;\n        this.direction = direction;\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\n        this._isBrowser = _isBrowser;\n        this._needsPositionStickyOnElement = _needsPositionStickyOnElement;\n        this._positionListener = _positionListener;\n        this._cachedCellWidths = [];\n        this._borderCellCss = {\n            'top': `${_stickCellCss}-border-elem-top`,\n            'bottom': `${_stickCellCss}-border-elem-bottom`,\n            'left': `${_stickCellCss}-border-elem-left`,\n            'right': `${_stickCellCss}-border-elem-right`,\n        };\n    }\n    /**\n     * Clears the sticky positioning styles from the row and its cells by resetting the `position`\n     * style, setting the zIndex to 0, and unsetting each provided sticky direction.\n     * @param rows The list of rows that should be cleared from sticking in the provided directions\n     * @param stickyDirections The directions that should no longer be set as sticky on the rows.\n     */\n    clearStickyPositioning(rows, stickyDirections) {\n        const elementsToClear = [];\n        for (const row of rows) {\n            // If the row isn't an element (e.g. if it's an `ng-container`),\n            // it won't have inline styles or `children` so we skip it.\n            if (row.nodeType !== row.ELEMENT_NODE) {\n                continue;\n            }\n            elementsToClear.push(row);\n            for (let i = 0; i < row.children.length; i++) {\n                elementsToClear.push(row.children[i]);\n            }\n        }\n        // Coalesce with sticky row/column updates (and potentially other changes like column resize).\n        this._coalescedStyleScheduler.schedule(() => {\n            for (const element of elementsToClear) {\n                this._removeStickyStyle(element, stickyDirections);\n            }\n        });\n    }\n    /**\n     * Applies sticky left and right positions to the cells of each row according to the sticky\n     * states of the rendered column definitions.\n     * @param rows The rows that should have its set of cells stuck according to the sticky states.\n     * @param stickyStartStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the start of the row.\n     * @param stickyEndStates A list of boolean states where each state represents whether the cell\n     *     in this index position should be stuck to the end of the row.\n     * @param recalculateCellWidths Whether the sticky styler should recalculate the width of each\n     *     column cell. If `false` cached widths will be used instead.\n     */\n    updateStickyColumns(rows, stickyStartStates, stickyEndStates, recalculateCellWidths = true) {\n        if (!rows.length ||\n            !this._isBrowser ||\n            !(stickyStartStates.some(state => state) || stickyEndStates.some(state => state))) {\n            if (this._positionListener) {\n                this._positionListener.stickyColumnsUpdated({ sizes: [] });\n                this._positionListener.stickyEndColumnsUpdated({ sizes: [] });\n            }\n            return;\n        }\n        const firstRow = rows[0];\n        const numCells = firstRow.children.length;\n        const cellWidths = this._getCellWidths(firstRow, recalculateCellWidths);\n        const startPositions = this._getStickyStartColumnPositions(cellWidths, stickyStartStates);\n        const endPositions = this._getStickyEndColumnPositions(cellWidths, stickyEndStates);\n        const lastStickyStart = stickyStartStates.lastIndexOf(true);\n        const firstStickyEnd = stickyEndStates.indexOf(true);\n        // Coalesce with sticky row updates (and potentially other changes like column resize).\n        this._coalescedStyleScheduler.schedule(() => {\n            const isRtl = this.direction === 'rtl';\n            const start = isRtl ? 'right' : 'left';\n            const end = isRtl ? 'left' : 'right';\n            for (const row of rows) {\n                for (let i = 0; i < numCells; i++) {\n                    const cell = row.children[i];\n                    if (stickyStartStates[i]) {\n                        this._addStickyStyle(cell, start, startPositions[i], i === lastStickyStart);\n                    }\n                    if (stickyEndStates[i]) {\n                        this._addStickyStyle(cell, end, endPositions[i], i === firstStickyEnd);\n                    }\n                }\n            }\n            if (this._positionListener) {\n                this._positionListener.stickyColumnsUpdated({\n                    sizes: lastStickyStart === -1\n                        ? []\n                        : cellWidths\n                            .slice(0, lastStickyStart + 1)\n                            .map((width, index) => (stickyStartStates[index] ? width : null)),\n                });\n                this._positionListener.stickyEndColumnsUpdated({\n                    sizes: firstStickyEnd === -1\n                        ? []\n                        : cellWidths\n                            .slice(firstStickyEnd)\n                            .map((width, index) => (stickyEndStates[index + firstStickyEnd] ? width : null))\n                            .reverse(),\n                });\n            }\n        });\n    }\n    /**\n     * Applies sticky positioning to the row's cells if using the native table layout, and to the\n     * row itself otherwise.\n     * @param rowsToStick The list of rows that should be stuck according to their corresponding\n     *     sticky state and to the provided top or bottom position.\n     * @param stickyStates A list of boolean states where each state represents whether the row\n     *     should be stuck in the particular top or bottom position.\n     * @param position The position direction in which the row should be stuck if that row should be\n     *     sticky.\n     *\n     */\n    stickRows(rowsToStick, stickyStates, position) {\n        // Since we can't measure the rows on the server, we can't stick the rows properly.\n        if (!this._isBrowser) {\n            return;\n        }\n        // If positioning the rows to the bottom, reverse their order when evaluating the sticky\n        // position such that the last row stuck will be \"bottom: 0px\" and so on. Note that the\n        // sticky states need to be reversed as well.\n        const rows = position === 'bottom' ? rowsToStick.slice().reverse() : rowsToStick;\n        const states = position === 'bottom' ? stickyStates.slice().reverse() : stickyStates;\n        // Measure row heights all at once before adding sticky styles to reduce layout thrashing.\n        const stickyOffsets = [];\n        const stickyCellHeights = [];\n        const elementsToStick = [];\n        for (let rowIndex = 0, stickyOffset = 0; rowIndex < rows.length; rowIndex++) {\n            if (!states[rowIndex]) {\n                continue;\n            }\n            stickyOffsets[rowIndex] = stickyOffset;\n            const row = rows[rowIndex];\n            elementsToStick[rowIndex] = this._isNativeHtmlTable\n                ? Array.from(row.children)\n                : [row];\n            const height = row.getBoundingClientRect().height;\n            stickyOffset += height;\n            stickyCellHeights[rowIndex] = height;\n        }\n        const borderedRowIndex = states.lastIndexOf(true);\n        // Coalesce with other sticky row updates (top/bottom), sticky columns updates\n        // (and potentially other changes like column resize).\n        this._coalescedStyleScheduler.schedule(() => {\n            for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n                if (!states[rowIndex]) {\n                    continue;\n                }\n                const offset = stickyOffsets[rowIndex];\n                const isBorderedRowIndex = rowIndex === borderedRowIndex;\n                for (const element of elementsToStick[rowIndex]) {\n                    this._addStickyStyle(element, position, offset, isBorderedRowIndex);\n                }\n            }\n            if (position === 'top') {\n                this._positionListener?.stickyHeaderRowsUpdated({\n                    sizes: stickyCellHeights,\n                    offsets: stickyOffsets,\n                    elements: elementsToStick,\n                });\n            }\n            else {\n                this._positionListener?.stickyFooterRowsUpdated({\n                    sizes: stickyCellHeights,\n                    offsets: stickyOffsets,\n                    elements: elementsToStick,\n                });\n            }\n        });\n    }\n    /**\n     * When using the native table in Safari, sticky footer cells do not stick. The only way to stick\n     * footer rows is to apply sticky styling to the tfoot container. This should only be done if\n     * all footer rows are sticky. If not all footer rows are sticky, remove sticky positioning from\n     * the tfoot element.\n     */\n    updateStickyFooterContainer(tableElement, stickyStates) {\n        if (!this._isNativeHtmlTable) {\n            return;\n        }\n        const tfoot = tableElement.querySelector('tfoot');\n        // Coalesce with other sticky updates (and potentially other changes like column resize).\n        this._coalescedStyleScheduler.schedule(() => {\n            if (stickyStates.some(state => !state)) {\n                this._removeStickyStyle(tfoot, ['bottom']);\n            }\n            else {\n                this._addStickyStyle(tfoot, 'bottom', 0, false);\n            }\n        });\n    }\n    /**\n     * Removes the sticky style on the element by removing the sticky cell CSS class, re-evaluating\n     * the zIndex, removing each of the provided sticky directions, and removing the\n     * sticky position if there are no more directions.\n     */\n    _removeStickyStyle(element, stickyDirections) {\n        for (const dir of stickyDirections) {\n            element.style[dir] = '';\n            element.classList.remove(this._borderCellCss[dir]);\n        }\n        // If the element no longer has any more sticky directions, remove sticky positioning and\n        // the sticky CSS class.\n        // Short-circuit checking element.style[dir] for stickyDirections as they\n        // were already removed above.\n        const hasDirection = STICKY_DIRECTIONS.some(dir => stickyDirections.indexOf(dir) === -1 && element.style[dir]);\n        if (hasDirection) {\n            element.style.zIndex = this._getCalculatedZIndex(element);\n        }\n        else {\n            // When not hasDirection, _getCalculatedZIndex will always return ''.\n            element.style.zIndex = '';\n            if (this._needsPositionStickyOnElement) {\n                element.style.position = '';\n            }\n            element.classList.remove(this._stickCellCss);\n        }\n    }\n    /**\n     * Adds the sticky styling to the element by adding the sticky style class, changing position\n     * to be sticky (and -webkit-sticky), setting the appropriate zIndex, and adding a sticky\n     * direction and value.\n     */\n    _addStickyStyle(element, dir, dirValue, isBorderElement) {\n        element.classList.add(this._stickCellCss);\n        if (isBorderElement) {\n            element.classList.add(this._borderCellCss[dir]);\n        }\n        element.style[dir] = `${dirValue}px`;\n        element.style.zIndex = this._getCalculatedZIndex(element);\n        if (this._needsPositionStickyOnElement) {\n            element.style.cssText += 'position: -webkit-sticky; position: sticky; ';\n        }\n    }\n    /**\n     * Calculate what the z-index should be for the element, depending on what directions (top,\n     * bottom, left, right) have been set. It should be true that elements with a top direction\n     * should have the highest index since these are elements like a table header. If any of those\n     * elements are also sticky in another direction, then they should appear above other elements\n     * that are only sticky top (e.g. a sticky column on a sticky header). Bottom-sticky elements\n     * (e.g. footer rows) should then be next in the ordering such that they are below the header\n     * but above any non-sticky elements. Finally, left/right sticky elements (e.g. sticky columns)\n     * should minimally increment so that they are above non-sticky elements but below top and bottom\n     * elements.\n     */\n    _getCalculatedZIndex(element) {\n        const zIndexIncrements = {\n            top: 100,\n            bottom: 10,\n            left: 1,\n            right: 1,\n        };\n        let zIndex = 0;\n        // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n        // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n        // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n        for (const dir of STICKY_DIRECTIONS) {\n            if (element.style[dir]) {\n                zIndex += zIndexIncrements[dir];\n            }\n        }\n        return zIndex ? `${zIndex}` : '';\n    }\n    /** Gets the widths for each cell in the provided row. */\n    _getCellWidths(row, recalculateCellWidths = true) {\n        if (!recalculateCellWidths && this._cachedCellWidths.length) {\n            return this._cachedCellWidths;\n        }\n        const cellWidths = [];\n        const firstRowCells = row.children;\n        for (let i = 0; i < firstRowCells.length; i++) {\n            let cell = firstRowCells[i];\n            cellWidths.push(cell.getBoundingClientRect().width);\n        }\n        this._cachedCellWidths = cellWidths;\n        return cellWidths;\n    }\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyStartColumnPositions(widths, stickyStates) {\n        const positions = [];\n        let nextPosition = 0;\n        for (let i = 0; i < widths.length; i++) {\n            if (stickyStates[i]) {\n                positions[i] = nextPosition;\n                nextPosition += widths[i];\n            }\n        }\n        return positions;\n    }\n    /**\n     * Determines the left and right positions of each sticky column cell, which will be the\n     * accumulation of all sticky column cell widths to the left and right, respectively.\n     * Non-sticky cells do not need to have a value set since their positions will not be applied.\n     */\n    _getStickyEndColumnPositions(widths, stickyStates) {\n        const positions = [];\n        let nextPosition = 0;\n        for (let i = widths.length; i > 0; i--) {\n            if (stickyStates[i]) {\n                positions[i] = nextPosition;\n                nextPosition += widths[i];\n            }\n        }\n        return positions;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error to be thrown when attempting to find an nonexistent column.\n * @param id Id whose lookup failed.\n * @docs-private\n */\nfunction getTableUnknownColumnError(id) {\n    return Error(`Could not find column with id \"${id}\".`);\n}\n/**\n * Returns an error to be thrown when two column definitions have the same name.\n * @docs-private\n */\nfunction getTableDuplicateColumnNameError(name) {\n    return Error(`Duplicate column definition name provided: \"${name}\".`);\n}\n/**\n * Returns an error to be thrown when there are multiple rows that are missing a when function.\n * @docs-private\n */\nfunction getTableMultipleDefaultRowDefsError() {\n    return Error(`There can only be one default row without a when predicate function.`);\n}\n/**\n * Returns an error to be thrown when there are no matching row defs for a particular set of data.\n * @docs-private\n */\nfunction getTableMissingMatchingRowDefError(data) {\n    return Error(`Could not find a matching row definition for the` +\n        `provided row data: ${JSON.stringify(data)}`);\n}\n/**\n * Returns an error to be thrown when there is no row definitions present in the content.\n * @docs-private\n */\nfunction getTableMissingRowDefsError() {\n    return Error('Missing definitions for header, footer, and row; ' +\n        'cannot determine which columns should be rendered.');\n}\n/**\n * Returns an error to be thrown when the data source does not match the compatible types.\n * @docs-private\n */\nfunction getTableUnknownDataSourceError() {\n    return Error(`Provided data source did not match an array, Observable, or DataSource`);\n}\n/**\n * Returns an error to be thrown when the text column cannot find a parent table to inject.\n * @docs-private\n */\nfunction getTableTextColumnMissingParentTableError() {\n    return Error(`Text column could not find a parent table for registration.`);\n}\n/**\n * Returns an error to be thrown when a table text column doesn't have a name.\n * @docs-private\n */\nfunction getTableTextColumnMissingNameError() {\n    return Error(`Table text column must have a name.`);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the StickyPositioningListener. */\nconst STICKY_POSITIONING_LISTENER = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.InjectionToken('CDK_SPL');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Enables the recycle view repeater strategy, which reduces rendering latency. Not compatible with\n * tables that animate rows.\n */\nclass CdkRecycleRows {\n}\nCdkRecycleRows.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRecycleRows, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nCdkRecycleRows.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkRecycleRows, selector: \"cdk-table[recycleRows], table[cdk-table][recycleRows]\", providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._RecycleViewRepeaterStrategy }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkRecycleRows, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{\n                    selector: 'cdk-table[recycleRows], table[cdk-table][recycleRows]',\n                    providers: [{ provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._RecycleViewRepeaterStrategy }],\n                }]\n        }] });\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert data rows.\n * @docs-private\n */\nclass DataRowOutlet {\n    constructor(viewContainer, elementRef) {\n        this.viewContainer = viewContainer;\n        this.elementRef = elementRef;\n    }\n}\nDataRowOutlet.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: DataRowOutlet, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nDataRowOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: DataRowOutlet, selector: \"[rowOutlet]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: DataRowOutlet, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[rowOutlet]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert the header.\n * @docs-private\n */\nclass HeaderRowOutlet {\n    constructor(viewContainer, elementRef) {\n        this.viewContainer = viewContainer;\n        this.elementRef = elementRef;\n    }\n}\nHeaderRowOutlet.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: HeaderRowOutlet, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nHeaderRowOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: HeaderRowOutlet, selector: \"[headerRowOutlet]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: HeaderRowOutlet, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[headerRowOutlet]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/**\n * Provides a handle for the table to grab the view container's ng-container to insert the footer.\n * @docs-private\n */\nclass FooterRowOutlet {\n    constructor(viewContainer, elementRef) {\n        this.viewContainer = viewContainer;\n        this.elementRef = elementRef;\n    }\n}\nFooterRowOutlet.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: FooterRowOutlet, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nFooterRowOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: FooterRowOutlet, selector: \"[footerRowOutlet]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: FooterRowOutlet, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[footerRowOutlet]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/**\n * Provides a handle for the table to grab the view\n * container's ng-container to insert the no data row.\n * @docs-private\n */\nclass NoDataRowOutlet {\n    constructor(viewContainer, elementRef) {\n        this.viewContainer = viewContainer;\n        this.elementRef = elementRef;\n    }\n}\nNoDataRowOutlet.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: NoDataRowOutlet, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Directive });\nNoDataRowOutlet.ɵdir = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareDirective\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: NoDataRowOutlet, selector: \"[noDataRowOutlet]\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))) });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: NoDataRowOutlet, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Directive,\n            args: [{ selector: '[noDataRowOutlet]' }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewContainerRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }]; } });\n/**\n * The table template that can be used by the mat-table. Should not be used outside of the\n * material library.\n * @docs-private\n */\nconst CDK_TABLE_TEMPLATE = \n// Note that according to MDN, the `caption` element has to be projected as the **first**\n// element in the table. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption\n`\n  <ng-content select=\"caption\"></ng-content>\n  <ng-content select=\"colgroup, col\"></ng-content>\n  <ng-container headerRowOutlet></ng-container>\n  <ng-container rowOutlet></ng-container>\n  <ng-container noDataRowOutlet></ng-container>\n  <ng-container footerRowOutlet></ng-container>\n`;\n/**\n * Class used to conveniently type the embedded view ref for rows with a context.\n * @docs-private\n */\nclass RowViewRef extends _angular_core__WEBPACK_IMPORTED_MODULE_2__.EmbeddedViewRef {\n}\n/**\n * A data table that can render a header row, data rows, and a footer row.\n * Uses the dataSource input to determine the data to be rendered. The data can be provided either\n * as a data array, an Observable stream that emits the data array to render, or a DataSource with a\n * connect function that will return an Observable stream that emits the data array to render.\n */\nclass CdkTable {\n    /**\n     * Tracking function that will be used to check the differences in data changes. Used similarly\n     * to `ngFor` `trackBy` function. Optimize row operations by identifying a row based on its data\n     * relative to the function to know if a row should be added/removed/moved.\n     * Accepts a function that takes two parameters, `index` and `item`.\n     */\n    get trackBy() {\n        return this._trackByFn;\n    }\n    set trackBy(fn) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && fn != null && typeof fn !== 'function') {\n            console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}.`);\n        }\n        this._trackByFn = fn;\n    }\n    /**\n     * The table's source of data, which can be provided in three ways (in order of complexity):\n     *   - Simple data array (each object represents one table row)\n     *   - Stream that emits a data array each time the array changes\n     *   - `DataSource` object that implements the connect/disconnect interface.\n     *\n     * If a data array is provided, the table must be notified when the array's objects are\n     * added, removed, or moved. This can be done by calling the `renderRows()` function which will\n     * render the diff since the last table render. If the data array reference is changed, the table\n     * will automatically trigger an update to the rows.\n     *\n     * When providing an Observable stream, the table will trigger an update automatically when the\n     * stream emits a new array of data.\n     *\n     * Finally, when providing a `DataSource` object, the table will use the Observable stream\n     * provided by the connect function and trigger updates when that stream emits new data array\n     * values. During the table's ngOnDestroy or when the data source is removed from the table, the\n     * table will call the DataSource's `disconnect` function (may be useful for cleaning up any\n     * subscriptions registered during the connect process).\n     */\n    get dataSource() {\n        return this._dataSource;\n    }\n    set dataSource(dataSource) {\n        if (this._dataSource !== dataSource) {\n            this._switchDataSource(dataSource);\n        }\n    }\n    /**\n     * Whether to allow multiple rows per data object by evaluating which rows evaluate their 'when'\n     * predicate to true. If `multiTemplateDataRows` is false, which is the default value, then each\n     * dataobject will render the first row that evaluates its when predicate to true, in the order\n     * defined in the table, or otherwise the default row which does not have a when predicate.\n     */\n    get multiTemplateDataRows() {\n        return this._multiTemplateDataRows;\n    }\n    set multiTemplateDataRows(v) {\n        this._multiTemplateDataRows = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);\n        // In Ivy if this value is set via a static attribute (e.g. <table multiTemplateDataRows>),\n        // this setter will be invoked before the row outlet has been defined hence the null check.\n        if (this._rowOutlet && this._rowOutlet.viewContainer.length) {\n            this._forceRenderDataRows();\n            this.updateStickyColumnStyles();\n        }\n    }\n    /**\n     * Whether to use a fixed table layout. Enabling this option will enforce consistent column widths\n     * and optimize rendering sticky styles for native tables. No-op for flex tables.\n     */\n    get fixedLayout() {\n        return this._fixedLayout;\n    }\n    set fixedLayout(v) {\n        this._fixedLayout = (0,_angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_5__.coerceBooleanProperty)(v);\n        // Toggling `fixedLayout` may change column widths. Sticky column styles should be recalculated.\n        this._forceRecalculateCellWidths = true;\n        this._stickyColumnStylesNeedReset = true;\n    }\n    constructor(_differs, _changeDetectorRef, _elementRef, role, _dir, _document, _platform, _viewRepeater, _coalescedStyleScheduler, _viewportRuler, \n    /**\n     * @deprecated `_stickyPositioningListener` parameter to become required.\n     * @breaking-change 13.0.0\n     */\n    _stickyPositioningListener, \n    /**\n     * @deprecated `_ngZone` parameter to become required.\n     * @breaking-change 14.0.0\n     */\n    _ngZone) {\n        this._differs = _differs;\n        this._changeDetectorRef = _changeDetectorRef;\n        this._elementRef = _elementRef;\n        this._dir = _dir;\n        this._platform = _platform;\n        this._viewRepeater = _viewRepeater;\n        this._coalescedStyleScheduler = _coalescedStyleScheduler;\n        this._viewportRuler = _viewportRuler;\n        this._stickyPositioningListener = _stickyPositioningListener;\n        this._ngZone = _ngZone;\n        /** Subject that emits when the component has been destroyed. */\n        this._onDestroy = new rxjs__WEBPACK_IMPORTED_MODULE_3__.Subject();\n        /**\n         * Map of all the user's defined columns (header, data, and footer cell template) identified by\n         * name. Collection populated by the column definitions gathered by `ContentChildren` as well as\n         * any custom column definitions added to `_customColumnDefs`.\n         */\n        this._columnDefsByName = new Map();\n        /**\n         * Column definitions that were defined outside of the direct content children of the table.\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n         * column definitions as *its* content child.\n         */\n        this._customColumnDefs = new Set();\n        /**\n         * Data row definitions that were defined outside of the direct content children of the table.\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n         * built-in data rows as *its* content child.\n         */\n        this._customRowDefs = new Set();\n        /**\n         * Header row definitions that were defined outside of the direct content children of the table.\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has\n         * built-in header rows as *its* content child.\n         */\n        this._customHeaderRowDefs = new Set();\n        /**\n         * Footer row definitions that were defined outside of the direct content children of the table.\n         * These will be defined when, e.g., creating a wrapper around the cdkTable that has a\n         * built-in footer row as *its* content child.\n         */\n        this._customFooterRowDefs = new Set();\n        /**\n         * Whether the header row definition has been changed. Triggers an update to the header row after\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\n         */\n        this._headerRowDefChanged = true;\n        /**\n         * Whether the footer row definition has been changed. Triggers an update to the footer row after\n         * content is checked. Initialized as true so that the table renders the initial set of rows.\n         */\n        this._footerRowDefChanged = true;\n        /**\n         * Whether the sticky column styles need to be updated. Set to `true` when the visible columns\n         * change.\n         */\n        this._stickyColumnStylesNeedReset = true;\n        /**\n         * Whether the sticky styler should recalculate cell widths when applying sticky styles. If\n         * `false`, cached values will be used instead. This is only applicable to tables with\n         * {@link fixedLayout} enabled. For other tables, cell widths will always be recalculated.\n         */\n        this._forceRecalculateCellWidths = true;\n        /**\n         * Cache of the latest rendered `RenderRow` objects as a map for easy retrieval when constructing\n         * a new list of `RenderRow` objects for rendering rows. Since the new list is constructed with\n         * the cached `RenderRow` objects when possible, the row identity is preserved when the data\n         * and row template matches, which allows the `IterableDiffer` to check rows by reference\n         * and understand which rows are added/moved/removed.\n         *\n         * Implemented as a map of maps where the first key is the `data: T` object and the second is the\n         * `CdkRowDef<T>` object. With the two keys, the cache points to a `RenderRow<T>` object that\n         * contains an array of created pairs. The array is necessary to handle cases where the data\n         * array contains multiple duplicate data objects and each instantiated `RenderRow` must be\n         * stored.\n         */\n        this._cachedRenderRowsMap = new Map();\n        /**\n         * CSS class added to any row or cell that has sticky positioning applied. May be overridden by\n         * table subclasses.\n         */\n        this.stickyCssClass = 'cdk-table-sticky';\n        /**\n         * Whether to manually add position: sticky to all sticky cell elements. Not needed if\n         * the position is set in a selector associated with the value of stickyCssClass. May be\n         * overridden by table subclasses\n         */\n        this.needsPositionStickyOnElement = true;\n        /** Whether the no data row is currently showing anything. */\n        this._isShowingNoDataRow = false;\n        this._multiTemplateDataRows = false;\n        this._fixedLayout = false;\n        /**\n         * Emits when the table completes rendering a set of data rows based on the latest data from the\n         * data source, even if the set of rows is empty.\n         */\n        this.contentChanged = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();\n        // TODO(andrewseguin): Remove max value as the end index\n        //   and instead calculate the view on init and scroll.\n        /**\n         * Stream containing the latest information on what rows are being displayed on screen.\n         * Can be used by the data source to as a heuristic of what data should be provided.\n         *\n         * @docs-private\n         */\n        this.viewChange = new rxjs__WEBPACK_IMPORTED_MODULE_3__.BehaviorSubject({\n            start: 0,\n            end: Number.MAX_VALUE,\n        });\n        if (!role) {\n            this._elementRef.nativeElement.setAttribute('role', 'table');\n        }\n        this._document = _document;\n        this._isNativeHtmlTable = this._elementRef.nativeElement.nodeName === 'TABLE';\n    }\n    ngOnInit() {\n        this._setupStickyStyler();\n        if (this._isNativeHtmlTable) {\n            this._applyNativeTableSections();\n        }\n        // Set up the trackBy function so that it uses the `RenderRow` as its identity by default. If\n        // the user has provided a custom trackBy, return the result of that function as evaluated\n        // with the values of the `RenderRow`'s data and index.\n        this._dataDiffer = this._differs.find([]).create((_i, dataRow) => {\n            return this.trackBy ? this.trackBy(dataRow.dataIndex, dataRow.data) : dataRow;\n        });\n        this._viewportRuler\n            .change()\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy))\n            .subscribe(() => {\n            this._forceRecalculateCellWidths = true;\n        });\n    }\n    ngAfterContentChecked() {\n        // Cache the row and column definitions gathered by ContentChildren and programmatic injection.\n        this._cacheRowDefs();\n        this._cacheColumnDefs();\n        // Make sure that the user has at least added header, footer, or data row def.\n        if (!this._headerRowDefs.length &&\n            !this._footerRowDefs.length &&\n            !this._rowDefs.length &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTableMissingRowDefsError();\n        }\n        // Render updates if the list of columns have been changed for the header, row, or footer defs.\n        const columnsChanged = this._renderUpdatedColumns();\n        const rowDefsChanged = columnsChanged || this._headerRowDefChanged || this._footerRowDefChanged;\n        // Ensure sticky column styles are reset if set to `true` elsewhere.\n        this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || rowDefsChanged;\n        this._forceRecalculateCellWidths = rowDefsChanged;\n        // If the header row definition has been changed, trigger a render to the header row.\n        if (this._headerRowDefChanged) {\n            this._forceRenderHeaderRows();\n            this._headerRowDefChanged = false;\n        }\n        // If the footer row definition has been changed, trigger a render to the footer row.\n        if (this._footerRowDefChanged) {\n            this._forceRenderFooterRows();\n            this._footerRowDefChanged = false;\n        }\n        // If there is a data source and row definitions, connect to the data source unless a\n        // connection has already been made.\n        if (this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription) {\n            this._observeRenderChanges();\n        }\n        else if (this._stickyColumnStylesNeedReset) {\n            // In the above case, _observeRenderChanges will result in updateStickyColumnStyles being\n            // called when it row data arrives. Otherwise, we need to call it proactively.\n            this.updateStickyColumnStyles();\n        }\n        this._checkStickyStates();\n    }\n    ngOnDestroy() {\n        [\n            this._rowOutlet.viewContainer,\n            this._headerRowOutlet.viewContainer,\n            this._footerRowOutlet.viewContainer,\n            this._cachedRenderRowsMap,\n            this._customColumnDefs,\n            this._customRowDefs,\n            this._customHeaderRowDefs,\n            this._customFooterRowDefs,\n            this._columnDefsByName,\n        ].forEach(def => {\n            def.clear();\n        });\n        this._headerRowDefs = [];\n        this._footerRowDefs = [];\n        this._defaultRowDef = null;\n        this._onDestroy.next();\n        this._onDestroy.complete();\n        if ((0,_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__.isDataSource)(this.dataSource)) {\n            this.dataSource.disconnect(this);\n        }\n    }\n    /**\n     * Renders rows based on the table's latest set of data, which was either provided directly as an\n     * input or retrieved through an Observable stream (directly or from a DataSource).\n     * Checks for differences in the data since the last diff to perform only the necessary\n     * changes (add/remove/move rows).\n     *\n     * If the table's data source is a DataSource or Observable, this will be invoked automatically\n     * each time the provided Observable stream emits a new data array. Otherwise if your data is\n     * an array, this function will need to be called to render any changes.\n     */\n    renderRows() {\n        this._renderRows = this._getAllRenderRows();\n        const changes = this._dataDiffer.diff(this._renderRows);\n        if (!changes) {\n            this._updateNoDataRow();\n            this.contentChanged.next();\n            return;\n        }\n        const viewContainer = this._rowOutlet.viewContainer;\n        this._viewRepeater.applyChanges(changes, viewContainer, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record.item, currentIndex), record => record.item.data, (change) => {\n            if (change.operation === 1 /* _ViewRepeaterOperation.INSERTED */ && change.context) {\n                this._renderCellTemplateForItem(change.record.item.rowDef, change.context);\n            }\n        });\n        // Update the meta context of a row's context data (index, count, first, last, ...)\n        this._updateRowIndexContext();\n        // Update rows that did not get added/removed/moved but may have had their identity changed,\n        // e.g. if trackBy matched data on some property but the actual data reference changed.\n        changes.forEachIdentityChange((record) => {\n            const rowView = viewContainer.get(record.currentIndex);\n            rowView.context.$implicit = record.item.data;\n        });\n        this._updateNoDataRow();\n        // Allow the new row data to render before measuring it.\n        // @breaking-change 14.0.0 Remove undefined check once _ngZone is required.\n        if (this._ngZone && _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone.isInAngularZone()) {\n            this._ngZone.onStable.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.take)(1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy)).subscribe(() => {\n                this.updateStickyColumnStyles();\n            });\n        }\n        else {\n            this.updateStickyColumnStyles();\n        }\n        this.contentChanged.next();\n    }\n    /** Adds a column definition that was not included as part of the content children. */\n    addColumnDef(columnDef) {\n        this._customColumnDefs.add(columnDef);\n    }\n    /** Removes a column definition that was not included as part of the content children. */\n    removeColumnDef(columnDef) {\n        this._customColumnDefs.delete(columnDef);\n    }\n    /** Adds a row definition that was not included as part of the content children. */\n    addRowDef(rowDef) {\n        this._customRowDefs.add(rowDef);\n    }\n    /** Removes a row definition that was not included as part of the content children. */\n    removeRowDef(rowDef) {\n        this._customRowDefs.delete(rowDef);\n    }\n    /** Adds a header row definition that was not included as part of the content children. */\n    addHeaderRowDef(headerRowDef) {\n        this._customHeaderRowDefs.add(headerRowDef);\n        this._headerRowDefChanged = true;\n    }\n    /** Removes a header row definition that was not included as part of the content children. */\n    removeHeaderRowDef(headerRowDef) {\n        this._customHeaderRowDefs.delete(headerRowDef);\n        this._headerRowDefChanged = true;\n    }\n    /** Adds a footer row definition that was not included as part of the content children. */\n    addFooterRowDef(footerRowDef) {\n        this._customFooterRowDefs.add(footerRowDef);\n        this._footerRowDefChanged = true;\n    }\n    /** Removes a footer row definition that was not included as part of the content children. */\n    removeFooterRowDef(footerRowDef) {\n        this._customFooterRowDefs.delete(footerRowDef);\n        this._footerRowDefChanged = true;\n    }\n    /** Sets a no data row definition that was not included as a part of the content children. */\n    setNoDataRow(noDataRow) {\n        this._customNoDataRow = noDataRow;\n    }\n    /**\n     * Updates the header sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the top. Then, evaluating which cells need to be stuck to the top. This is\n     * automatically called when the header row changes its displayed set of columns, or if its\n     * sticky input changes. May be called manually for cases where the cell content changes outside\n     * of these events.\n     */\n    updateStickyHeaderRowStyles() {\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\n        const tableElement = this._elementRef.nativeElement;\n        // Hide the thead element if there are no header rows. This is necessary to satisfy\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\n        // required child `row`.\n        const thead = tableElement.querySelector('thead');\n        if (thead) {\n            thead.style.display = headerRows.length ? '' : 'none';\n        }\n        const stickyStates = this._headerRowDefs.map(def => def.sticky);\n        this._stickyStyler.clearStickyPositioning(headerRows, ['top']);\n        this._stickyStyler.stickRows(headerRows, stickyStates, 'top');\n        // Reset the dirty state of the sticky input change since it has been used.\n        this._headerRowDefs.forEach(def => def.resetStickyChanged());\n    }\n    /**\n     * Updates the footer sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the bottom. Then, evaluating which cells need to be stuck to the bottom. This is\n     * automatically called when the footer row changes its displayed set of columns, or if its\n     * sticky input changes. May be called manually for cases where the cell content changes outside\n     * of these events.\n     */\n    updateStickyFooterRowStyles() {\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\n        const tableElement = this._elementRef.nativeElement;\n        // Hide the tfoot element if there are no footer rows. This is necessary to satisfy\n        // overzealous a11y checkers that fail because the `rowgroup` element does not contain\n        // required child `row`.\n        const tfoot = tableElement.querySelector('tfoot');\n        if (tfoot) {\n            tfoot.style.display = footerRows.length ? '' : 'none';\n        }\n        const stickyStates = this._footerRowDefs.map(def => def.sticky);\n        this._stickyStyler.clearStickyPositioning(footerRows, ['bottom']);\n        this._stickyStyler.stickRows(footerRows, stickyStates, 'bottom');\n        this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, stickyStates);\n        // Reset the dirty state of the sticky input change since it has been used.\n        this._footerRowDefs.forEach(def => def.resetStickyChanged());\n    }\n    /**\n     * Updates the column sticky styles. First resets all applied styles with respect to the cells\n     * sticking to the left and right. Then sticky styles are added for the left and right according\n     * to the column definitions for each cell in each row. This is automatically called when\n     * the data source provides a new set of data or when a column definition changes its sticky\n     * input. May be called manually for cases where the cell content changes outside of these events.\n     */\n    updateStickyColumnStyles() {\n        const headerRows = this._getRenderedRows(this._headerRowOutlet);\n        const dataRows = this._getRenderedRows(this._rowOutlet);\n        const footerRows = this._getRenderedRows(this._footerRowOutlet);\n        // For tables not using a fixed layout, the column widths may change when new rows are rendered.\n        // In a table using a fixed layout, row content won't affect column width, so sticky styles\n        // don't need to be cleared unless either the sticky column config changes or one of the row\n        // defs change.\n        if ((this._isNativeHtmlTable && !this._fixedLayout) || this._stickyColumnStylesNeedReset) {\n            // Clear the left and right positioning from all columns in the table across all rows since\n            // sticky columns span across all table sections (header, data, footer)\n            this._stickyStyler.clearStickyPositioning([...headerRows, ...dataRows, ...footerRows], ['left', 'right']);\n            this._stickyColumnStylesNeedReset = false;\n        }\n        // Update the sticky styles for each header row depending on the def's sticky state\n        headerRows.forEach((headerRow, i) => {\n            this._addStickyColumnStyles([headerRow], this._headerRowDefs[i]);\n        });\n        // Update the sticky styles for each data row depending on its def's sticky state\n        this._rowDefs.forEach(rowDef => {\n            // Collect all the rows rendered with this row definition.\n            const rows = [];\n            for (let i = 0; i < dataRows.length; i++) {\n                if (this._renderRows[i].rowDef === rowDef) {\n                    rows.push(dataRows[i]);\n                }\n            }\n            this._addStickyColumnStyles(rows, rowDef);\n        });\n        // Update the sticky styles for each footer row depending on the def's sticky state\n        footerRows.forEach((footerRow, i) => {\n            this._addStickyColumnStyles([footerRow], this._footerRowDefs[i]);\n        });\n        // Reset the dirty state of the sticky input change since it has been used.\n        Array.from(this._columnDefsByName.values()).forEach(def => def.resetStickyChanged());\n    }\n    /**\n     * Get the list of RenderRow objects to render according to the current list of data and defined\n     * row definitions. If the previous list already contained a particular pair, it should be reused\n     * so that the differ equates their references.\n     */\n    _getAllRenderRows() {\n        const renderRows = [];\n        // Store the cache and create a new one. Any re-used RenderRow objects will be moved into the\n        // new cache while unused ones can be picked up by garbage collection.\n        const prevCachedRenderRows = this._cachedRenderRowsMap;\n        this._cachedRenderRowsMap = new Map();\n        // For each data object, get the list of rows that should be rendered, represented by the\n        // respective `RenderRow` object which is the pair of `data` and `CdkRowDef`.\n        for (let i = 0; i < this._data.length; i++) {\n            let data = this._data[i];\n            const renderRowsForData = this._getRenderRowsForData(data, i, prevCachedRenderRows.get(data));\n            if (!this._cachedRenderRowsMap.has(data)) {\n                this._cachedRenderRowsMap.set(data, new WeakMap());\n            }\n            for (let j = 0; j < renderRowsForData.length; j++) {\n                let renderRow = renderRowsForData[j];\n                const cache = this._cachedRenderRowsMap.get(renderRow.data);\n                if (cache.has(renderRow.rowDef)) {\n                    cache.get(renderRow.rowDef).push(renderRow);\n                }\n                else {\n                    cache.set(renderRow.rowDef, [renderRow]);\n                }\n                renderRows.push(renderRow);\n            }\n        }\n        return renderRows;\n    }\n    /**\n     * Gets a list of `RenderRow<T>` for the provided data object and any `CdkRowDef` objects that\n     * should be rendered for this data. Reuses the cached RenderRow objects if they match the same\n     * `(T, CdkRowDef)` pair.\n     */\n    _getRenderRowsForData(data, dataIndex, cache) {\n        const rowDefs = this._getRowDefs(data, dataIndex);\n        return rowDefs.map(rowDef => {\n            const cachedRenderRows = cache && cache.has(rowDef) ? cache.get(rowDef) : [];\n            if (cachedRenderRows.length) {\n                const dataRow = cachedRenderRows.shift();\n                dataRow.dataIndex = dataIndex;\n                return dataRow;\n            }\n            else {\n                return { data, rowDef, dataIndex };\n            }\n        });\n    }\n    /** Update the map containing the content's column definitions. */\n    _cacheColumnDefs() {\n        this._columnDefsByName.clear();\n        const columnDefs = mergeArrayAndSet(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs);\n        columnDefs.forEach(columnDef => {\n            if (this._columnDefsByName.has(columnDef.name) &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableDuplicateColumnNameError(columnDef.name);\n            }\n            this._columnDefsByName.set(columnDef.name, columnDef);\n        });\n    }\n    /** Update the list of all available row definitions that can be used. */\n    _cacheRowDefs() {\n        this._headerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs);\n        this._footerRowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs);\n        this._rowDefs = mergeArrayAndSet(this._getOwnDefs(this._contentRowDefs), this._customRowDefs);\n        // After all row definitions are determined, find the row definition to be considered default.\n        const defaultRowDefs = this._rowDefs.filter(def => !def.when);\n        if (!this.multiTemplateDataRows &&\n            defaultRowDefs.length > 1 &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTableMultipleDefaultRowDefsError();\n        }\n        this._defaultRowDef = defaultRowDefs[0];\n    }\n    /**\n     * Check if the header, data, or footer rows have changed what columns they want to display or\n     * whether the sticky states have changed for the header or footer. If there is a diff, then\n     * re-render that section.\n     */\n    _renderUpdatedColumns() {\n        const columnsDiffReducer = (acc, def) => acc || !!def.getColumnsDiff();\n        // Force re-render data rows if the list of column definitions have changed.\n        const dataColumnsChanged = this._rowDefs.reduce(columnsDiffReducer, false);\n        if (dataColumnsChanged) {\n            this._forceRenderDataRows();\n        }\n        // Force re-render header/footer rows if the list of column definitions have changed.\n        const headerColumnsChanged = this._headerRowDefs.reduce(columnsDiffReducer, false);\n        if (headerColumnsChanged) {\n            this._forceRenderHeaderRows();\n        }\n        const footerColumnsChanged = this._footerRowDefs.reduce(columnsDiffReducer, false);\n        if (footerColumnsChanged) {\n            this._forceRenderFooterRows();\n        }\n        return dataColumnsChanged || headerColumnsChanged || footerColumnsChanged;\n    }\n    /**\n     * Switch to the provided data source by resetting the data and unsubscribing from the current\n     * render change subscription if one exists. If the data source is null, interpret this by\n     * clearing the row outlet. Otherwise start listening for new data.\n     */\n    _switchDataSource(dataSource) {\n        this._data = [];\n        if ((0,_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__.isDataSource)(this.dataSource)) {\n            this.dataSource.disconnect(this);\n        }\n        // Stop listening for data from the previous data source.\n        if (this._renderChangeSubscription) {\n            this._renderChangeSubscription.unsubscribe();\n            this._renderChangeSubscription = null;\n        }\n        if (!dataSource) {\n            if (this._dataDiffer) {\n                this._dataDiffer.diff([]);\n            }\n            this._rowOutlet.viewContainer.clear();\n        }\n        this._dataSource = dataSource;\n    }\n    /** Set up a subscription for the data provided by the data source. */\n    _observeRenderChanges() {\n        // If no data source has been set, there is nothing to observe for changes.\n        if (!this.dataSource) {\n            return;\n        }\n        let dataStream;\n        if ((0,_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__.isDataSource)(this.dataSource)) {\n            dataStream = this.dataSource.connect(this);\n        }\n        else if ((0,rxjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(this.dataSource)) {\n            dataStream = this.dataSource;\n        }\n        else if (Array.isArray(this.dataSource)) {\n            dataStream = (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.of)(this.dataSource);\n        }\n        if (dataStream === undefined && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTableUnknownDataSourceError();\n        }\n        this._renderChangeSubscription = dataStream\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy))\n            .subscribe(data => {\n            this._data = data || [];\n            this.renderRows();\n        });\n    }\n    /**\n     * Clears any existing content in the header row outlet and creates a new embedded view\n     * in the outlet using the header row definition.\n     */\n    _forceRenderHeaderRows() {\n        // Clear the header row outlet if any content exists.\n        if (this._headerRowOutlet.viewContainer.length > 0) {\n            this._headerRowOutlet.viewContainer.clear();\n        }\n        this._headerRowDefs.forEach((def, i) => this._renderRow(this._headerRowOutlet, def, i));\n        this.updateStickyHeaderRowStyles();\n    }\n    /**\n     * Clears any existing content in the footer row outlet and creates a new embedded view\n     * in the outlet using the footer row definition.\n     */\n    _forceRenderFooterRows() {\n        // Clear the footer row outlet if any content exists.\n        if (this._footerRowOutlet.viewContainer.length > 0) {\n            this._footerRowOutlet.viewContainer.clear();\n        }\n        this._footerRowDefs.forEach((def, i) => this._renderRow(this._footerRowOutlet, def, i));\n        this.updateStickyFooterRowStyles();\n    }\n    /** Adds the sticky column styles for the rows according to the columns' stick states. */\n    _addStickyColumnStyles(rows, rowDef) {\n        const columnDefs = Array.from(rowDef.columns || []).map(columnName => {\n            const columnDef = this._columnDefsByName.get(columnName);\n            if (!columnDef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableUnknownColumnError(columnName);\n            }\n            return columnDef;\n        });\n        const stickyStartStates = columnDefs.map(columnDef => columnDef.sticky);\n        const stickyEndStates = columnDefs.map(columnDef => columnDef.stickyEnd);\n        this._stickyStyler.updateStickyColumns(rows, stickyStartStates, stickyEndStates, !this._fixedLayout || this._forceRecalculateCellWidths);\n    }\n    /** Gets the list of rows that have been rendered in the row outlet. */\n    _getRenderedRows(rowOutlet) {\n        const renderedRows = [];\n        for (let i = 0; i < rowOutlet.viewContainer.length; i++) {\n            const viewRef = rowOutlet.viewContainer.get(i);\n            renderedRows.push(viewRef.rootNodes[0]);\n        }\n        return renderedRows;\n    }\n    /**\n     * Get the matching row definitions that should be used for this row data. If there is only\n     * one row definition, it is returned. Otherwise, find the row definitions that has a when\n     * predicate that returns true with the data. If none return true, return the default row\n     * definition.\n     */\n    _getRowDefs(data, dataIndex) {\n        if (this._rowDefs.length == 1) {\n            return [this._rowDefs[0]];\n        }\n        let rowDefs = [];\n        if (this.multiTemplateDataRows) {\n            rowDefs = this._rowDefs.filter(def => !def.when || def.when(dataIndex, data));\n        }\n        else {\n            let rowDef = this._rowDefs.find(def => def.when && def.when(dataIndex, data)) || this._defaultRowDef;\n            if (rowDef) {\n                rowDefs.push(rowDef);\n            }\n        }\n        if (!rowDefs.length && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTableMissingMatchingRowDefError(data);\n        }\n        return rowDefs;\n    }\n    _getEmbeddedViewArgs(renderRow, index) {\n        const rowDef = renderRow.rowDef;\n        const context = { $implicit: renderRow.data };\n        return {\n            templateRef: rowDef.template,\n            context,\n            index,\n        };\n    }\n    /**\n     * Creates a new row template in the outlet and fills it with the set of cell templates.\n     * Optionally takes a context to provide to the row and cells, as well as an optional index\n     * of where to place the new row template in the outlet.\n     */\n    _renderRow(outlet, rowDef, index, context = {}) {\n        // TODO(andrewseguin): enforce that one outlet was instantiated from createEmbeddedView\n        const view = outlet.viewContainer.createEmbeddedView(rowDef.template, context, index);\n        this._renderCellTemplateForItem(rowDef, context);\n        return view;\n    }\n    _renderCellTemplateForItem(rowDef, context) {\n        for (let cellTemplate of this._getCellTemplates(rowDef)) {\n            if (CdkCellOutlet.mostRecentCellOutlet) {\n                CdkCellOutlet.mostRecentCellOutlet._viewContainer.createEmbeddedView(cellTemplate, context);\n            }\n        }\n        this._changeDetectorRef.markForCheck();\n    }\n    /**\n     * Updates the index-related context for each row to reflect any changes in the index of the rows,\n     * e.g. first/last/even/odd.\n     */\n    _updateRowIndexContext() {\n        const viewContainer = this._rowOutlet.viewContainer;\n        for (let renderIndex = 0, count = viewContainer.length; renderIndex < count; renderIndex++) {\n            const viewRef = viewContainer.get(renderIndex);\n            const context = viewRef.context;\n            context.count = count;\n            context.first = renderIndex === 0;\n            context.last = renderIndex === count - 1;\n            context.even = renderIndex % 2 === 0;\n            context.odd = !context.even;\n            if (this.multiTemplateDataRows) {\n                context.dataIndex = this._renderRows[renderIndex].dataIndex;\n                context.renderIndex = renderIndex;\n            }\n            else {\n                context.index = this._renderRows[renderIndex].dataIndex;\n            }\n        }\n    }\n    /** Gets the column definitions for the provided row def. */\n    _getCellTemplates(rowDef) {\n        if (!rowDef || !rowDef.columns) {\n            return [];\n        }\n        return Array.from(rowDef.columns, columnId => {\n            const column = this._columnDefsByName.get(columnId);\n            if (!column && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getTableUnknownColumnError(columnId);\n            }\n            return rowDef.extractCellTemplate(column);\n        });\n    }\n    /** Adds native table sections (e.g. tbody) and moves the row outlets into them. */\n    _applyNativeTableSections() {\n        const documentFragment = this._document.createDocumentFragment();\n        const sections = [\n            { tag: 'thead', outlets: [this._headerRowOutlet] },\n            { tag: 'tbody', outlets: [this._rowOutlet, this._noDataRowOutlet] },\n            { tag: 'tfoot', outlets: [this._footerRowOutlet] },\n        ];\n        for (const section of sections) {\n            const element = this._document.createElement(section.tag);\n            element.setAttribute('role', 'rowgroup');\n            for (const outlet of section.outlets) {\n                element.appendChild(outlet.elementRef.nativeElement);\n            }\n            documentFragment.appendChild(element);\n        }\n        // Use a DocumentFragment so we don't hit the DOM on each iteration.\n        this._elementRef.nativeElement.appendChild(documentFragment);\n    }\n    /**\n     * Forces a re-render of the data rows. Should be called in cases where there has been an input\n     * change that affects the evaluation of which rows should be rendered, e.g. toggling\n     * `multiTemplateDataRows` or adding/removing row definitions.\n     */\n    _forceRenderDataRows() {\n        this._dataDiffer.diff([]);\n        this._rowOutlet.viewContainer.clear();\n        this.renderRows();\n    }\n    /**\n     * Checks if there has been a change in sticky states since last check and applies the correct\n     * sticky styles. Since checking resets the \"dirty\" state, this should only be performed once\n     * during a change detection and after the inputs are settled (after content check).\n     */\n    _checkStickyStates() {\n        const stickyCheckReducer = (acc, d) => {\n            return acc || d.hasStickyChanged();\n        };\n        // Note that the check needs to occur for every definition since it notifies the definition\n        // that it can reset its dirty state. Using another operator like `some` may short-circuit\n        // remaining definitions and leave them in an unchecked state.\n        if (this._headerRowDefs.reduce(stickyCheckReducer, false)) {\n            this.updateStickyHeaderRowStyles();\n        }\n        if (this._footerRowDefs.reduce(stickyCheckReducer, false)) {\n            this.updateStickyFooterRowStyles();\n        }\n        if (Array.from(this._columnDefsByName.values()).reduce(stickyCheckReducer, false)) {\n            this._stickyColumnStylesNeedReset = true;\n            this.updateStickyColumnStyles();\n        }\n    }\n    /**\n     * Creates the sticky styler that will be used for sticky rows and columns. Listens\n     * for directionality changes and provides the latest direction to the styler. Re-applies column\n     * stickiness when directionality changes.\n     */\n    _setupStickyStyler() {\n        const direction = this._dir ? this._dir.value : 'ltr';\n        this._stickyStyler = new StickyStyler(this._isNativeHtmlTable, this.stickyCssClass, direction, this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener);\n        (this._dir ? this._dir.change : (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.of)())\n            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.takeUntil)(this._onDestroy))\n            .subscribe(value => {\n            this._stickyStyler.direction = value;\n            this.updateStickyColumnStyles();\n        });\n    }\n    /** Filters definitions that belong to this table from a QueryList. */\n    _getOwnDefs(items) {\n        return items.filter(item => !item._table || item._table === this);\n    }\n    /** Creates or removes the no data row, depending on whether any data is being shown. */\n    _updateNoDataRow() {\n        const noDataRow = this._customNoDataRow || this._noDataRow;\n        if (!noDataRow) {\n            return;\n        }\n        const shouldShow = this._rowOutlet.viewContainer.length === 0;\n        if (shouldShow === this._isShowingNoDataRow) {\n            return;\n        }\n        const container = this._noDataRowOutlet.viewContainer;\n        if (shouldShow) {\n            const view = container.createEmbeddedView(noDataRow.templateRef);\n            const rootNode = view.rootNodes[0];\n            // Only add the attributes if we have a single root node since it's hard\n            // to figure out which one to add it to when there are multiple.\n            if (view.rootNodes.length === 1 && rootNode?.nodeType === this._document.ELEMENT_NODE) {\n                rootNode.setAttribute('role', 'row');\n                rootNode.classList.add(noDataRow._contentClassName);\n            }\n        }\n        else {\n            container.clear();\n        }\n        this._isShowingNoDataRow = shouldShow;\n    }\n}\nCdkTable.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTable, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }, { token: 'role', attribute: true }, { token: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, optional: true }, { token: _angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT }, { token: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform }, { token: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY }, { token: _COALESCED_STYLE_SCHEDULER }, { token: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ViewportRuler }, { token: STICKY_POSITIONING_LISTENER, optional: true, skipSelf: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Component });\nCdkTable.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkTable, selector: \"cdk-table, table[cdk-table]\", inputs: { trackBy: \"trackBy\", dataSource: \"dataSource\", multiTemplateDataRows: \"multiTemplateDataRows\", fixedLayout: \"fixedLayout\" }, outputs: { contentChanged: \"contentChanged\" }, host: { properties: { \"class.cdk-table-fixed-layout\": \"fixedLayout\" }, classAttribute: \"cdk-table\" }, providers: [\n        { provide: CDK_TABLE, useExisting: CdkTable },\n        { provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._DisposeViewRepeaterStrategy },\n        { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\n        // Prevent nested tables from seeing this table's StickyPositioningListener.\n        { provide: STICKY_POSITIONING_LISTENER, useValue: null },\n    ], queries: [{ propertyName: \"_noDataRow\", first: true, predicate: CdkNoDataRow, descendants: true }, { propertyName: \"_contentColumnDefs\", predicate: CdkColumnDef, descendants: true }, { propertyName: \"_contentRowDefs\", predicate: CdkRowDef, descendants: true }, { propertyName: \"_contentHeaderRowDefs\", predicate: CdkHeaderRowDef, descendants: true }, { propertyName: \"_contentFooterRowDefs\", predicate: CdkFooterRowDef, descendants: true }], viewQueries: [{ propertyName: \"_rowOutlet\", first: true, predicate: DataRowOutlet, descendants: true, static: true }, { propertyName: \"_headerRowOutlet\", first: true, predicate: HeaderRowOutlet, descendants: true, static: true }, { propertyName: \"_footerRowOutlet\", first: true, predicate: FooterRowOutlet, descendants: true, static: true }, { propertyName: \"_noDataRowOutlet\", first: true, predicate: NoDataRowOutlet, descendants: true, static: true }], exportAs: [\"cdkTable\"], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), template: \"\\n  <ng-content select=\\\"caption\\\"></ng-content>\\n  <ng-content select=\\\"colgroup, col\\\"></ng-content>\\n  <ng-container headerRowOutlet></ng-container>\\n  <ng-container rowOutlet></ng-container>\\n  <ng-container noDataRowOutlet></ng-container>\\n  <ng-container footerRowOutlet></ng-container>\\n\", isInline: true, styles: [\".cdk-table-fixed-layout{table-layout:fixed}\"], dependencies: [{ kind: \"directive\", type: DataRowOutlet, selector: \"[rowOutlet]\" }, { kind: \"directive\", type: HeaderRowOutlet, selector: \"[headerRowOutlet]\" }, { kind: \"directive\", type: FooterRowOutlet, selector: \"[footerRowOutlet]\" }, { kind: \"directive\", type: NoDataRowOutlet, selector: \"[noDataRowOutlet]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTable, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,\n            args: [{ selector: 'cdk-table, table[cdk-table]', exportAs: 'cdkTable', template: CDK_TABLE_TEMPLATE, host: {\n                        'class': 'cdk-table',\n                        '[class.cdk-table-fixed-layout]': 'fixedLayout',\n                    }, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None, changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, providers: [\n                        { provide: CDK_TABLE, useExisting: CdkTable },\n                        { provide: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY, useClass: _angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._DisposeViewRepeaterStrategy },\n                        { provide: _COALESCED_STYLE_SCHEDULER, useClass: _CoalescedStyleScheduler },\n                        // Prevent nested tables from seeing this table's StickyPositioningListener.\n                        { provide: STICKY_POSITIONING_LISTENER, useValue: null },\n                    ], styles: [\".cdk-table-fixed-layout{table-layout:fixed}\"] }]\n        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.IterableDiffers }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectorRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Attribute,\n                    args: ['role']\n                }] }, { type: _angular_cdk_bidi__WEBPACK_IMPORTED_MODULE_6__.Directionality, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.DOCUMENT]\n                }] }, { type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_7__.Platform }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [_angular_cdk_collections__WEBPACK_IMPORTED_MODULE_0__._VIEW_REPEATER_STRATEGY]\n                }] }, { type: _CoalescedStyleScheduler, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [_COALESCED_STYLE_SCHEDULER]\n                }] }, { type: _angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ViewportRuler }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.SkipSelf\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [STICKY_POSITIONING_LISTENER]\n                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgZone, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }]; }, propDecorators: { trackBy: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], dataSource: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], multiTemplateDataRows: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], fixedLayout: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], contentChanged: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output\n            }], _rowOutlet: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [DataRowOutlet, { static: true }]\n            }], _headerRowOutlet: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [HeaderRowOutlet, { static: true }]\n            }], _footerRowOutlet: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [FooterRowOutlet, { static: true }]\n            }], _noDataRowOutlet: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [NoDataRowOutlet, { static: true }]\n            }], _contentColumnDefs: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChildren,\n                args: [CdkColumnDef, { descendants: true }]\n            }], _contentRowDefs: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChildren,\n                args: [CdkRowDef, { descendants: true }]\n            }], _contentHeaderRowDefs: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChildren,\n                args: [CdkHeaderRowDef, {\n                        descendants: true,\n                    }]\n            }], _contentFooterRowDefs: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChildren,\n                args: [CdkFooterRowDef, {\n                        descendants: true,\n                    }]\n            }], _noDataRow: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ContentChild,\n                args: [CdkNoDataRow]\n            }] } });\n/** Utility function that gets a merged list of the entries in an array and values of a Set. */\nfunction mergeArrayAndSet(array, set) {\n    return array.concat(Array.from(set));\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Column that simply shows text content for the header and row cells. Assumes that the table\n * is using the native table implementation (`<table>`).\n *\n * By default, the name of this column will be the header text and data property accessor.\n * The header text can be overridden with the `headerText` input. Cell values can be overridden with\n * the `dataAccessor` input. Change the text justification to the start or end using the `justify`\n * input.\n */\nclass CdkTextColumn {\n    /** Column name that should be used to reference this column. */\n    get name() {\n        return this._name;\n    }\n    set name(name) {\n        this._name = name;\n        // With Ivy, inputs can be initialized before static query results are\n        // available. In that case, we defer the synchronization until \"ngOnInit\" fires.\n        this._syncColumnDefName();\n    }\n    constructor(\n    // `CdkTextColumn` is always requiring a table, but we just assert it manually\n    // for better error reporting.\n    // tslint:disable-next-line: lightweight-tokens\n    _table, _options) {\n        this._table = _table;\n        this._options = _options;\n        /** Alignment of the cell values. */\n        this.justify = 'start';\n        this._options = _options || {};\n    }\n    ngOnInit() {\n        this._syncColumnDefName();\n        if (this.headerText === undefined) {\n            this.headerText = this._createDefaultHeaderText();\n        }\n        if (!this.dataAccessor) {\n            this.dataAccessor =\n                this._options.defaultDataAccessor || ((data, name) => data[name]);\n        }\n        if (this._table) {\n            // Provide the cell and headerCell directly to the table with the static `ViewChild` query,\n            // since the columnDef will not pick up its content by the time the table finishes checking\n            // its content and initializing the rows.\n            this.columnDef.cell = this.cell;\n            this.columnDef.headerCell = this.headerCell;\n            this._table.addColumnDef(this.columnDef);\n        }\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throw getTableTextColumnMissingParentTableError();\n        }\n    }\n    ngOnDestroy() {\n        if (this._table) {\n            this._table.removeColumnDef(this.columnDef);\n        }\n    }\n    /**\n     * Creates a default header text. Use the options' header text transformation function if one\n     * has been provided. Otherwise simply capitalize the column name.\n     */\n    _createDefaultHeaderText() {\n        const name = this.name;\n        if (!name && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getTableTextColumnMissingNameError();\n        }\n        if (this._options && this._options.defaultHeaderTextTransform) {\n            return this._options.defaultHeaderTextTransform(name);\n        }\n        return name[0].toUpperCase() + name.slice(1);\n    }\n    /** Synchronizes the column definition name with the text column name. */\n    _syncColumnDefName() {\n        if (this.columnDef) {\n            this.columnDef.name = this.name;\n        }\n    }\n}\nCdkTextColumn.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTextColumn, deps: [{ token: CdkTable, optional: true }, { token: TEXT_COLUMN_OPTIONS, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].Component });\nCdkTextColumn.ɵcmp = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareComponent\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", type: CdkTextColumn, selector: \"cdk-text-column\", inputs: { name: \"name\", headerText: \"headerText\", dataAccessor: \"dataAccessor\", justify: \"justify\" }, viewQueries: [{ propertyName: \"columnDef\", first: true, predicate: CdkColumnDef, descendants: true, static: true }, { propertyName: \"cell\", first: true, predicate: CdkCellDef, descendants: true, static: true }, { propertyName: \"headerCell\", first: true, predicate: CdkHeaderCellDef, descendants: true, static: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), template: `\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  `, isInline: true, dependencies: [{ kind: \"directive\", type: CdkCellDef, selector: \"[cdkCellDef]\" }, { kind: \"directive\", type: CdkHeaderCellDef, selector: \"[cdkHeaderCellDef]\" }, { kind: \"directive\", type: CdkColumnDef, selector: \"[cdkColumnDef]\", inputs: [\"sticky\", \"cdkColumnDef\", \"stickyEnd\"] }, { kind: \"directive\", type: CdkCell, selector: \"cdk-cell, td[cdk-cell]\" }, { kind: \"directive\", type: CdkHeaderCell, selector: \"cdk-header-cell, th[cdk-header-cell]\" }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default, encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTextColumn, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,\n            args: [{\n                    selector: 'cdk-text-column',\n                    template: `\n    <ng-container cdkColumnDef>\n      <th cdk-header-cell *cdkHeaderCellDef [style.text-align]=\"justify\">\n        {{headerText}}\n      </th>\n      <td cdk-cell *cdkCellDef=\"let data\" [style.text-align]=\"justify\">\n        {{dataAccessor(data, name)}}\n      </td>\n    </ng-container>\n  `,\n                    encapsulation: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewEncapsulation.None,\n                    // Change detection is intentionally not set to OnPush. This component's template will be provided\n                    // to the table to be inserted into its view. This is problematic when change detection runs since\n                    // the bindings in this template will be evaluated _after_ the table's view is evaluated, which\n                    // mean's the template in the table's view will not have the updated value (and in fact will cause\n                    // an ExpressionChangedAfterItHasBeenCheckedError).\n                    // tslint:disable-next-line:validate-decorators\n                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ChangeDetectionStrategy.Default,\n                }]\n        }], ctorParameters: function () { return [{ type: CdkTable, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }] }, { type: undefined, decorators: [{\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Optional\n                }, {\n                    type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,\n                    args: [TEXT_COLUMN_OPTIONS]\n                }] }]; }, propDecorators: { name: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], headerText: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], dataAccessor: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], justify: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input\n            }], columnDef: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [CdkColumnDef, { static: true }]\n            }], cell: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [CdkCellDef, { static: true }]\n            }], headerCell: [{\n                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ViewChild,\n                args: [CdkHeaderCellDef, { static: true }]\n            }] } });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EXPORTED_DECLARATIONS = [\n    CdkTable,\n    CdkRowDef,\n    CdkCellDef,\n    CdkCellOutlet,\n    CdkHeaderCellDef,\n    CdkFooterCellDef,\n    CdkColumnDef,\n    CdkCell,\n    CdkRow,\n    CdkHeaderCell,\n    CdkFooterCell,\n    CdkHeaderRow,\n    CdkHeaderRowDef,\n    CdkFooterRow,\n    CdkFooterRowDef,\n    DataRowOutlet,\n    HeaderRowOutlet,\n    FooterRowOutlet,\n    CdkTextColumn,\n    CdkNoDataRow,\n    CdkRecycleRows,\n    NoDataRowOutlet,\n];\nclass CdkTableModule {\n}\nCdkTableModule.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTableModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵFactoryTarget\"].NgModule });\nCdkTableModule.ɵmod = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareNgModule\"]({ minVersion: \"14.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTableModule, declarations: [CdkTable,\n        CdkRowDef,\n        CdkCellDef,\n        CdkCellOutlet,\n        CdkHeaderCellDef,\n        CdkFooterCellDef,\n        CdkColumnDef,\n        CdkCell,\n        CdkRow,\n        CdkHeaderCell,\n        CdkFooterCell,\n        CdkHeaderRow,\n        CdkHeaderRowDef,\n        CdkFooterRow,\n        CdkFooterRowDef,\n        DataRowOutlet,\n        HeaderRowOutlet,\n        FooterRowOutlet,\n        CdkTextColumn,\n        CdkNoDataRow,\n        CdkRecycleRows,\n        NoDataRowOutlet], imports: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ScrollingModule], exports: [CdkTable,\n        CdkRowDef,\n        CdkCellDef,\n        CdkCellOutlet,\n        CdkHeaderCellDef,\n        CdkFooterCellDef,\n        CdkColumnDef,\n        CdkCell,\n        CdkRow,\n        CdkHeaderCell,\n        CdkFooterCell,\n        CdkHeaderRow,\n        CdkHeaderRowDef,\n        CdkFooterRow,\n        CdkFooterRowDef,\n        DataRowOutlet,\n        HeaderRowOutlet,\n        FooterRowOutlet,\n        CdkTextColumn,\n        CdkNoDataRow,\n        CdkRecycleRows,\n        NoDataRowOutlet] });\nCdkTableModule.ɵinj = _angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareInjector\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTableModule, imports: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ScrollingModule] });\n_angular_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"15.2.0-rc.0\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_2__, 2))), type: CdkTableModule, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.NgModule,\n            args: [{\n                    exports: EXPORTED_DECLARATIONS,\n                    declarations: EXPORTED_DECLARATIONS,\n                    imports: [_angular_cdk_scrolling__WEBPACK_IMPORTED_MODULE_8__.ScrollingModule],\n                }]\n        }] });\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=table.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY2RrL2Zlc20yMDIwL3RhYmxlLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jdW11bG9jaXR5LWFzc2V0LW92ZXJ2aWV3LXdpZGdldC8uL25vZGVfbW9kdWxlcy9AYW5ndWxhci9jZGsvZmVzbTIwMjAvdGFibGUubWpzP2RmYzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCBfUmVjeWNsZVZpZXdSZXBlYXRlclN0cmF0ZWd5LCBpc0RhdGFTb3VyY2UsIF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jZGsvY29sbGVjdGlvbnMnO1xuZXhwb3J0IHsgRGF0YVNvdXJjZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2xsZWN0aW9ucyc7XG5pbXBvcnQgKiBhcyBpMiBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0ICogYXMgaTMgZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBTY3JvbGxpbmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIERpcmVjdGl2ZSwgSW5qZWN0LCBPcHRpb25hbCwgSW5wdXQsIENvbnRlbnRDaGlsZCwgSW5qZWN0YWJsZSwgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgVmlld0VuY2Fwc3VsYXRpb24sIEVtYmVkZGVkVmlld1JlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIEF0dHJpYnV0ZSwgU2tpcFNlbGYsIE91dHB1dCwgVmlld0NoaWxkLCBDb250ZW50Q2hpbGRyZW4sIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBmcm9tLCBCZWhhdmlvclN1YmplY3QsIGlzT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIE1peGluIHRvIHByb3ZpZGUgYSBkaXJlY3RpdmUgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBzdGlja3kgaW5wdXQgaGFzIGJlZW5cbiAqIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZnVuY3Rpb24gd2FzIGNhbGxlZC4gRXNzZW50aWFsbHkgYWRkcyBhIGRpcnR5LWNoZWNrIHRvIHRoZVxuICogc3RpY2t5IHZhbHVlLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtaXhpbkhhc1N0aWNreUlucHV0KGJhc2UpIHtcbiAgICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBiYXNlIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgc3RpY2t5IHBvc2l0aW9uaW5nIHNob3VsZCBiZSBhcHBsaWVkLiAqL1xuICAgICAgICBnZXQgc3RpY2t5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0aWNreTtcbiAgICAgICAgfVxuICAgICAgICBzZXQgc3RpY2t5KHYpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHRoaXMuX3N0aWNreTtcbiAgICAgICAgICAgIHRoaXMuX3N0aWNreSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1N0aWNreUNoYW5nZWQgPSBwcmV2VmFsdWUgIT09IHRoaXMuX3N0aWNreTtcbiAgICAgICAgfVxuICAgICAgICAvKiogV2hldGhlciB0aGUgc3RpY2t5IHZhbHVlIGhhcyBjaGFuZ2VkIHNpbmNlIHRoaXMgd2FzIGxhc3QgY2FsbGVkLiAqL1xuICAgICAgICBoYXNTdGlja3lDaGFuZ2VkKCkge1xuICAgICAgICAgICAgY29uc3QgaGFzU3RpY2t5Q2hhbmdlZCA9IHRoaXMuX2hhc1N0aWNreUNoYW5nZWQ7XG4gICAgICAgICAgICB0aGlzLl9oYXNTdGlja3lDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaGFzU3RpY2t5Q2hhbmdlZDtcbiAgICAgICAgfVxuICAgICAgICAvKiogUmVzZXRzIHRoZSBkaXJ0eSBjaGVjayBmb3IgY2FzZXMgd2hlcmUgdGhlIHN0aWNreSBzdGF0ZSBoYXMgYmVlbiB1c2VkIHdpdGhvdXQgY2hlY2tpbmcuICovXG4gICAgICAgIHJlc2V0U3RpY2t5Q2hhbmdlZCgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc1N0aWNreUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX3N0aWNreSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHN0aWNreSBpbnB1dCBoYXMgY2hhbmdlZCBzaW5jZSBpdCB3YXMgbGFzdCBjaGVja2VkLiAqL1xuICAgICAgICAgICAgdGhpcy5faGFzU3RpY2t5Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFVzZWQgdG8gcHJvdmlkZSBhIHRhYmxlIHRvIHNvbWUgb2YgdGhlIHN1Yi1jb21wb25lbnRzIHdpdGhvdXQgY2F1c2luZyBhIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmNvbnN0IENES19UQUJMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbignQ0RLX1RBQkxFJyk7XG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgdGV4dCBjb2x1bW4gb3B0aW9ucy4gKi9cbmNvbnN0IFRFWFRfQ09MVU1OX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ3RleHQtY29sdW1uLW9wdGlvbnMnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIENlbGwgZGVmaW5pdGlvbiBmb3IgYSBDREsgdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBkYXRhIHJvdyBjZWxsIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBDZGtDZWxsRGVmIHtcbiAgICBjb25zdHJ1Y3RvcigvKiogQGRvY3MtcHJpdmF0ZSAqLyB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxufVxuQ2RrQ2VsbERlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0NlbGxEZWYsIGRlcHM6IFt7IHRva2VuOiBpMC5UZW1wbGF0ZVJlZiB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5DZGtDZWxsRGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrQ2VsbERlZiwgc2VsZWN0b3I6IFwiW2Nka0NlbGxEZWZdXCIsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0NlbGxEZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ1tjZGtDZWxsRGVmXScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5UZW1wbGF0ZVJlZiB9XTsgfSB9KTtcbi8qKlxuICogSGVhZGVyIGNlbGwgZGVmaW5pdGlvbiBmb3IgYSBDREsgdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBoZWFkZXIgY2VsbCBhbmQgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIENka0hlYWRlckNlbGxEZWYge1xuICAgIGNvbnN0cnVjdG9yKC8qKiBAZG9jcy1wcml2YXRlICovIHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG59XG5DZGtIZWFkZXJDZWxsRGVmLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrSGVhZGVyQ2VsbERlZiwgZGVwczogW3sgdG9rZW46IGkwLlRlbXBsYXRlUmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka0hlYWRlckNlbGxEZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtIZWFkZXJDZWxsRGVmLCBzZWxlY3RvcjogXCJbY2RrSGVhZGVyQ2VsbERlZl1cIiwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrSGVhZGVyQ2VsbERlZiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Nka0hlYWRlckNlbGxEZWZdJyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLlRlbXBsYXRlUmVmIH1dOyB9IH0pO1xuLyoqXG4gKiBGb290ZXIgY2VsbCBkZWZpbml0aW9uIGZvciBhIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGZvb3RlciBjZWxsIGFuZCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgQ2RrRm9vdGVyQ2VsbERlZiB7XG4gICAgY29uc3RydWN0b3IoLyoqIEBkb2NzLXByaXZhdGUgKi8gdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbn1cbkNka0Zvb3RlckNlbGxEZWYuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtGb290ZXJDZWxsRGVmLCBkZXBzOiBbeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrRm9vdGVyQ2VsbERlZi7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka0Zvb3RlckNlbGxEZWYsIHNlbGVjdG9yOiBcIltjZGtGb290ZXJDZWxsRGVmXVwiLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtGb290ZXJDZWxsRGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbY2RrRm9vdGVyQ2VsbERlZl0nIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVGVtcGxhdGVSZWYgfV07IH0gfSk7XG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIENka0NvbHVtbkRlZi5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5jbGFzcyBDZGtDb2x1bW5EZWZCYXNlIHtcbn1cbmNvbnN0IF9DZGtDb2x1bW5EZWZCYXNlID0gbWl4aW5IYXNTdGlja3lJbnB1dChDZGtDb2x1bW5EZWZCYXNlKTtcbi8qKlxuICogQ29sdW1uIGRlZmluaXRpb24gZm9yIHRoZSBDREsgdGFibGUuXG4gKiBEZWZpbmVzIGEgc2V0IG9mIGNlbGxzIGF2YWlsYWJsZSBmb3IgYSB0YWJsZSBjb2x1bW4uXG4gKi9cbmNsYXNzIENka0NvbHVtbkRlZiBleHRlbmRzIF9DZGtDb2x1bW5EZWZCYXNlIHtcbiAgICAvKiogVW5pcXVlIG5hbWUgZm9yIHRoaXMgY29sdW1uLiAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgc2V0IG5hbWUobmFtZSkge1xuICAgICAgICB0aGlzLl9zZXROYW1lSW5wdXQobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBjb2x1bW4gc2hvdWxkIGJlIHN0aWNreSBwb3NpdGlvbmVkIG9uIHRoZSBlbmQgb2YgdGhlIHJvdy4gU2hvdWxkIG1ha2Ugc3VyZVxuICAgICAqIHRoYXQgaXQgbWltaWNzIHRoZSBgQ2FuU3RpY2tgIG1peGluIHN1Y2ggdGhhdCBgX2hhc1N0aWNreUNoYW5nZWRgIGlzIHNldCB0byB0cnVlIGlmIHRoZSB2YWx1ZVxuICAgICAqIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICovXG4gICAgZ2V0IHN0aWNreUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0aWNreUVuZDtcbiAgICB9XG4gICAgc2V0IHN0aWNreUVuZCh2KSB7XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHRoaXMuX3N0aWNreUVuZDtcbiAgICAgICAgdGhpcy5fc3RpY2t5RW5kID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpO1xuICAgICAgICB0aGlzLl9oYXNTdGlja3lDaGFuZ2VkID0gcHJldlZhbHVlICE9PSB0aGlzLl9zdGlja3lFbmQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF90YWJsZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90YWJsZSA9IF90YWJsZTtcbiAgICAgICAgdGhpcy5fc3RpY2t5RW5kID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IHNldHMgdGhlIGNzcyBjbGFzc2VzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byBldmVyeSBjZWxsIGluIHRoaXNcbiAgICAgKiBjb2x1bW4uXG4gICAgICogSW4gdGhlIGZ1dHVyZSwgY29sdW1uQ3NzQ2xhc3NOYW1lIHdpbGwgY2hhbmdlIGZyb20gdHlwZSBzdHJpbmdbXSB0byBzdHJpbmcgYW5kIHRoaXNcbiAgICAgKiB3aWxsIHNldCBhIHNpbmdsZSBzdHJpbmcgdmFsdWUuXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqL1xuICAgIF91cGRhdGVDb2x1bW5Dc3NDbGFzc05hbWUoKSB7XG4gICAgICAgIHRoaXMuX2NvbHVtbkNzc0NsYXNzTmFtZSA9IFtgY2RrLWNvbHVtbi0ke3RoaXMuY3NzQ2xhc3NGcmllbmRseU5hbWV9YF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaGFzIGJlZW4gZXh0cmFjdGVkIHRvIGEgdXRpbCBiZWNhdXNlIG9mIFRTIDQgYW5kIFZFLlxuICAgICAqIFZpZXcgRW5naW5lIGRvZXNuJ3Qgc3VwcG9ydCBwcm9wZXJ0eSByZW5hbWUgaW5oZXJpdGFuY2UuXG4gICAgICogVFMgNC4wIGRvZXNuJ3QgYWxsb3cgcHJvcGVydGllcyB0byBvdmVycmlkZSBhY2Nlc3NvcnMgb3IgdmljZS12ZXJzYS5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgX3NldE5hbWVJbnB1dCh2YWx1ZSkge1xuICAgICAgICAvLyBJZiB0aGUgZGlyZWN0aXZlIGlzIHNldCB3aXRob3V0IGEgbmFtZSAodXBkYXRlZCBwcm9ncmFtbWF0aWNhbGx5KSwgdGhlbiB0aGlzIHNldHRlciB3aWxsXG4gICAgICAgIC8vIHRyaWdnZXIgd2l0aCBhbiBlbXB0eSBzdHJpbmcgYW5kIHNob3VsZCBub3Qgb3ZlcndyaXRlIHRoZSBwcm9ncmFtbWF0aWNhbGx5IHNldCB2YWx1ZS5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNzc0NsYXNzRnJpZW5kbHlOYW1lID0gdmFsdWUucmVwbGFjZSgvW15hLXowLTlfLV0vZ2ksICctJyk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb2x1bW5Dc3NDbGFzc05hbWUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka0NvbHVtbkRlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0NvbHVtbkRlZiwgZGVwczogW3sgdG9rZW46IENES19UQUJMRSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrQ29sdW1uRGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrQ29sdW1uRGVmLCBzZWxlY3RvcjogXCJbY2RrQ29sdW1uRGVmXVwiLCBpbnB1dHM6IHsgc3RpY2t5OiBcInN0aWNreVwiLCBuYW1lOiBbXCJjZGtDb2x1bW5EZWZcIiwgXCJuYW1lXCJdLCBzdGlja3lFbmQ6IFwic3RpY2t5RW5kXCIgfSwgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiAnTUFUX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYnLCB1c2VFeGlzdGluZzogQ2RrQ29sdW1uRGVmIH1dLCBxdWVyaWVzOiBbeyBwcm9wZXJ0eU5hbWU6IFwiY2VsbFwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBDZGtDZWxsRGVmLCBkZXNjZW5kYW50czogdHJ1ZSB9LCB7IHByb3BlcnR5TmFtZTogXCJoZWFkZXJDZWxsXCIsIGZpcnN0OiB0cnVlLCBwcmVkaWNhdGU6IENka0hlYWRlckNlbGxEZWYsIGRlc2NlbmRhbnRzOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcImZvb3RlckNlbGxcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogQ2RrRm9vdGVyQ2VsbERlZiwgZGVzY2VuZGFudHM6IHRydWUgfV0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrQ29sdW1uRGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbY2RrQ29sdW1uRGVmXScsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogWydzdGlja3knXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiAnTUFUX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYnLCB1c2VFeGlzdGluZzogQ2RrQ29sdW1uRGVmIH1dLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtDREtfVEFCTEVdXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH1dIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnY2RrQ29sdW1uRGVmJ11cbiAgICAgICAgICAgIH1dLCBzdGlja3lFbmQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydzdGlja3lFbmQnXVxuICAgICAgICAgICAgfV0sIGNlbGw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29udGVudENoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtDZGtDZWxsRGVmXVxuICAgICAgICAgICAgfV0sIGhlYWRlckNlbGw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29udGVudENoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtDZGtIZWFkZXJDZWxsRGVmXVxuICAgICAgICAgICAgfV0sIGZvb3RlckNlbGw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29udGVudENoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtDZGtGb290ZXJDZWxsRGVmXVxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKiBCYXNlIGNsYXNzIGZvciB0aGUgY2VsbHMuIEFkZHMgYSBDU1MgY2xhc3NuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGUgY29sdW1uIGl0IHJlbmRlcnMgaW4uICovXG5jbGFzcyBCYXNlQ2RrQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNvbHVtbkRlZi5fY29sdW1uQ3NzQ2xhc3NOYW1lKTtcbiAgICB9XG59XG4vKiogSGVhZGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbmNsYXNzIENka0hlYWRlckNlbGwgZXh0ZW5kcyBCYXNlQ2RrQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgfVxufVxuQ2RrSGVhZGVyQ2VsbC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0hlYWRlckNlbGwsIGRlcHM6IFt7IHRva2VuOiBDZGtDb2x1bW5EZWYgfSwgeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5DZGtIZWFkZXJDZWxsLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrSGVhZGVyQ2VsbCwgc2VsZWN0b3I6IFwiY2RrLWhlYWRlci1jZWxsLCB0aFtjZGstaGVhZGVyLWNlbGxdXCIsIGhvc3Q6IHsgYXR0cmlidXRlczogeyBcInJvbGVcIjogXCJjb2x1bW5oZWFkZXJcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJjZGstaGVhZGVyLWNlbGxcIiB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0hlYWRlckNlbGwsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1oZWFkZXItY2VsbCwgdGhbY2RrLWhlYWRlci1jZWxsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstaGVhZGVyLWNlbGwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAnY29sdW1uaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IENka0NvbHVtbkRlZiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfV07IH0gfSk7XG4vKiogRm9vdGVyIGNlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbmNsYXNzIENka0Zvb3RlckNlbGwgZXh0ZW5kcyBCYXNlQ2RrQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGlmIChjb2x1bW5EZWYuX3RhYmxlPy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZVJvbGUgPSBjb2x1bW5EZWYuX3RhYmxlLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgICAgICBjb25zdCByb2xlID0gdGFibGVSb2xlID09PSAnZ3JpZCcgfHwgdGFibGVSb2xlID09PSAndHJlZWdyaWQnID8gJ2dyaWRjZWxsJyA6ICdjZWxsJztcbiAgICAgICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCByb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka0Zvb3RlckNlbGwuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtGb290ZXJDZWxsLCBkZXBzOiBbeyB0b2tlbjogQ2RrQ29sdW1uRGVmIH0sIHsgdG9rZW46IGkwLkVsZW1lbnRSZWYgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrRm9vdGVyQ2VsbC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka0Zvb3RlckNlbGwsIHNlbGVjdG9yOiBcImNkay1mb290ZXItY2VsbCwgdGRbY2RrLWZvb3Rlci1jZWxsXVwiLCBob3N0OiB7IGNsYXNzQXR0cmlidXRlOiBcImNkay1mb290ZXItY2VsbFwiIH0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrRm9vdGVyQ2VsbCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWZvb3Rlci1jZWxsLCB0ZFtjZGstZm9vdGVyLWNlbGxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay1mb290ZXItY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBDZGtDb2x1bW5EZWYgfSwgeyB0eXBlOiBpMC5FbGVtZW50UmVmIH1dOyB9IH0pO1xuLyoqIENlbGwgdGVtcGxhdGUgY29udGFpbmVyIHRoYXQgYWRkcyB0aGUgcmlnaHQgY2xhc3NlcyBhbmQgcm9sZS4gKi9cbmNsYXNzIENka0NlbGwgZXh0ZW5kcyBCYXNlQ2RrQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGlmIChjb2x1bW5EZWYuX3RhYmxlPy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZVJvbGUgPSBjb2x1bW5EZWYuX3RhYmxlLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJyk7XG4gICAgICAgICAgICBjb25zdCByb2xlID0gdGFibGVSb2xlID09PSAnZ3JpZCcgfHwgdGFibGVSb2xlID09PSAndHJlZWdyaWQnID8gJ2dyaWRjZWxsJyA6ICdjZWxsJztcbiAgICAgICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCByb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka0NlbGwuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtDZWxsLCBkZXBzOiBbeyB0b2tlbjogQ2RrQ29sdW1uRGVmIH0sIHsgdG9rZW46IGkwLkVsZW1lbnRSZWYgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrQ2VsbC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka0NlbGwsIHNlbGVjdG9yOiBcImNkay1jZWxsLCB0ZFtjZGstY2VsbF1cIiwgaG9zdDogeyBjbGFzc0F0dHJpYnV0ZTogXCJjZGstY2VsbFwiIH0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrQ2VsbCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnY2RrLWNlbGwsIHRkW2Nkay1jZWxsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstY2VsbCcsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBDZGtDb2x1bW5EZWYgfSwgeyB0eXBlOiBpMC5FbGVtZW50UmVmIH1dOyB9IH0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8qKlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jbGFzcyBfU2NoZWR1bGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRhc2tzID0gW107XG4gICAgICAgIHRoaXMuZW5kVGFza3MgPSBbXTtcbiAgICB9XG59XG4vKiogSW5qZWN0aW9uIHRva2VuIHVzZWQgdG8gcHJvdmlkZSBhIGNvYWxlc2NlZCBzdHlsZSBzY2hlZHVsZXIuICovXG5jb25zdCBfQ09BTEVTQ0VEX1NUWUxFX1NDSEVEVUxFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVInKTtcbi8qKlxuICogQWxsb3dzIGdyb3VwaW5nIHVwIENTU0RvbSBtdXRhdGlvbnMgYWZ0ZXIgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBUaGlzIGNhbiBzaWduaWZpY2FudGx5IGltcHJvdmUgcGVyZm9ybWFuY2Ugd2hlbiBzZXBhcmF0ZSBjb25zZWN1dGl2ZSBmdW5jdGlvbnMgYXJlXG4gKiByZWFkaW5nIGZyb20gdGhlIENTU0RvbSBhbmQgdGhlbiBtdXRhdGluZyBpdC5cbiAqXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmNsYXNzIF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciB7XG4gICAgY29uc3RydWN0b3IoX25nWm9uZSkge1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICB0aGlzLl9jdXJyZW50U2NoZWR1bGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhlIHNwZWNpZmllZCB0YXNrIHRvIHJ1biBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IFZNIHR1cm4uXG4gICAgICovXG4gICAgc2NoZWR1bGUodGFzaykge1xuICAgICAgICB0aGlzLl9jcmVhdGVTY2hlZHVsZUlmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTY2hlZHVsZS50YXNrcy5wdXNoKHRhc2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhlIHNwZWNpZmllZCB0YXNrIHRvIHJ1biBhZnRlciBvdGhlciBzY2hlZHVsZWQgdGFza3MgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudFxuICAgICAqIFZNIHR1cm4uXG4gICAgICovXG4gICAgc2NoZWR1bGVFbmQodGFzaykge1xuICAgICAgICB0aGlzLl9jcmVhdGVTY2hlZHVsZUlmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTY2hlZHVsZS5lbmRUYXNrcy5wdXNoKHRhc2spO1xuICAgIH1cbiAgICAvKiogUHJldmVudCBhbnkgZnVydGhlciB0YXNrcyBmcm9tIHJ1bm5pbmcuICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBfY3JlYXRlU2NoZWR1bGVJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTY2hlZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTY2hlZHVsZSA9IG5ldyBfU2NoZWR1bGUoKTtcbiAgICAgICAgdGhpcy5fZ2V0U2NoZWR1bGVPYnNlcnZhYmxlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fY3VycmVudFNjaGVkdWxlLnRhc2tzLmxlbmd0aCB8fCB0aGlzLl9jdXJyZW50U2NoZWR1bGUuZW5kVGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGUgPSB0aGlzLl9jdXJyZW50U2NoZWR1bGU7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBuZXcgdGFza3Mgc2NoZWR1bGVkIGJ5IHRoZSBjdXJyZW50IHNldCBvZiB0YXNrcy5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U2NoZWR1bGUgPSBuZXcgX1NjaGVkdWxlKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHNjaGVkdWxlLnRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0YXNrIG9mIHNjaGVkdWxlLmVuZFRhc2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U2NoZWR1bGUgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFNjaGVkdWxlT2JzZXJ2YWJsZSgpIHtcbiAgICAgICAgLy8gVXNlIG9uU3RhYmxlIHdoZW4gaW4gdGhlIGNvbnRleHQgb2YgYW4gb25nb2luZyBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlIHNvIHRoYXQgd2VcbiAgICAgICAgLy8gZG8gbm90IGFjY2lkZW50YWxseSB0cmlnZ2VyIGFkZGl0aW9uYWwgY3ljbGVzLlxuICAgICAgICByZXR1cm4gdGhpcy5fbmdab25lLmlzU3RhYmxlXG4gICAgICAgICAgICA/IGZyb20oUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCkpXG4gICAgICAgICAgICA6IHRoaXMuX25nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSkpO1xuICAgIH1cbn1cbl9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlci7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgZGVwczogW3sgdG9rZW46IGkwLk5nWm9uZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuX0NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5OZ1pvbmUgfV07IH0gfSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBUaGUgcm93IHRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgYnkgdGhlIG1hdC10YWJsZS4gU2hvdWxkIG5vdCBiZSB1c2VkIG91dHNpZGUgb2YgdGhlXG4gKiBtYXRlcmlhbCBsaWJyYXJ5LlxuICovXG5jb25zdCBDREtfUk9XX1RFTVBMQVRFID0gYDxuZy1jb250YWluZXIgY2RrQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5gO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0aGUgQ2RrSGVhZGVyUm93RGVmIGFuZCBDZGtSb3dEZWYgdGhhdCBoYW5kbGVzIGNoZWNraW5nIHRoZWlyIGNvbHVtbnMgaW5wdXRzXG4gKiBmb3IgY2hhbmdlcyBhbmQgbm90aWZ5aW5nIHRoZSB0YWJsZS5cbiAqL1xuY2xhc3MgQmFzZVJvd0RlZiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi8gdGVtcGxhdGUsIF9kaWZmZXJzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb2x1bW5zIGRpZmZlciBpZiBvbmUgZG9lcyBub3QgeWV0IGV4aXN0LiBJbml0aWFsaXplIGl0IGJhc2VkIG9uIGluaXRpYWwgdmFsdWVcbiAgICAgICAgLy8gb2YgdGhlIGNvbHVtbnMgcHJvcGVydHkgb3IgYW4gZW1wdHkgYXJyYXkgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgICAgaWYgKCF0aGlzLl9jb2x1bW5zRGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gKGNoYW5nZXNbJ2NvbHVtbnMnXSAmJiBjaGFuZ2VzWydjb2x1bW5zJ10uY3VycmVudFZhbHVlKSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbHVtbnNEaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQoY29sdW1ucykuY3JlYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5zRGlmZmVyLmRpZmYoY29sdW1ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjdXJyZW50IGNvbHVtbnMgYW5kIHRoZSBjb2x1bW5zIGZyb20gdGhlIGxhc3QgZGlmZiwgb3IgbnVsbFxuICAgICAqIGlmIHRoZXJlIGlzIG5vIGRpZmZlcmVuY2UuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uc0RpZmYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zRGlmZmVyLmRpZmYodGhpcy5jb2x1bW5zKTtcbiAgICB9XG4gICAgLyoqIEdldHMgdGhpcyByb3cgZGVmJ3MgcmVsZXZhbnQgY2VsbCB0ZW1wbGF0ZSBmcm9tIHRoZSBwcm92aWRlZCBjb2x1bW4gZGVmLiAqL1xuICAgIGV4dHJhY3RDZWxsVGVtcGxhdGUoY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQ2RrSGVhZGVyUm93RGVmKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sdW1uLmhlYWRlckNlbGwudGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDZGtGb290ZXJSb3dEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZm9vdGVyQ2VsbC50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uY2VsbC50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkJhc2VSb3dEZWYuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCYXNlUm93RGVmLCBkZXBzOiBbeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfSwgeyB0b2tlbjogaTAuSXRlcmFibGVEaWZmZXJzIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkJhc2VSb3dEZWYuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBCYXNlUm93RGVmLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBCYXNlUm93RGVmLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVGVtcGxhdGVSZWYgfSwgeyB0eXBlOiBpMC5JdGVyYWJsZURpZmZlcnMgfV07IH0gfSk7XG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIENka0hlYWRlclJvd0RlZi5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5jbGFzcyBDZGtIZWFkZXJSb3dEZWZCYXNlIGV4dGVuZHMgQmFzZVJvd0RlZiB7XG59XG5jb25zdCBfQ2RrSGVhZGVyUm93RGVmQmFzZSA9IG1peGluSGFzU3RpY2t5SW5wdXQoQ2RrSGVhZGVyUm93RGVmQmFzZSk7XG4vKipcbiAqIEhlYWRlciByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBoZWFkZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIGhlYWRlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xuY2xhc3MgQ2RrSGVhZGVyUm93RGVmIGV4dGVuZHMgX0Nka0hlYWRlclJvd0RlZkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBfZGlmZmVycywgX3RhYmxlKSB7XG4gICAgICAgIHN1cGVyKHRlbXBsYXRlLCBfZGlmZmVycyk7XG4gICAgICAgIHRoaXMuX3RhYmxlID0gX3RhYmxlO1xuICAgIH1cbiAgICAvLyBQcmVyZW5kZXIgZmFpbHMgdG8gcmVjb2duaXplIHRoYXQgbmdPbkNoYW5nZXMgaW4gYSBwYXJ0IG9mIHRoaXMgY2xhc3MgdGhyb3VnaCBpbmhlcml0YW5jZS5cbiAgICAvLyBFeHBsaWNpdGx5IGRlZmluZSBpdCBzbyB0aGF0IHRoZSBtZXRob2QgaXMgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIEFuZ3VsYXIgbGlmZWN5Y2xlLlxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfVxufVxuQ2RrSGVhZGVyUm93RGVmLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrSGVhZGVyUm93RGVmLCBkZXBzOiBbeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfSwgeyB0b2tlbjogaTAuSXRlcmFibGVEaWZmZXJzIH0sIHsgdG9rZW46IENES19UQUJMRSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrSGVhZGVyUm93RGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrSGVhZGVyUm93RGVmLCBzZWxlY3RvcjogXCJbY2RrSGVhZGVyUm93RGVmXVwiLCBpbnB1dHM6IHsgY29sdW1uczogW1wiY2RrSGVhZGVyUm93RGVmXCIsIFwiY29sdW1uc1wiXSwgc3RpY2t5OiBbXCJjZGtIZWFkZXJSb3dEZWZTdGlja3lcIiwgXCJzdGlja3lcIl0gfSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtIZWFkZXJSb3dEZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtIZWFkZXJSb3dEZWZdJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbHVtbnM6IGNka0hlYWRlclJvd0RlZicsICdzdGlja3k6IGNka0hlYWRlclJvd0RlZlN0aWNreSddLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVGVtcGxhdGVSZWYgfSwgeyB0eXBlOiBpMC5JdGVyYWJsZURpZmZlcnMgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0NES19UQUJMRV1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG4vLyBCb2lsZXJwbGF0ZSBmb3IgYXBwbHlpbmcgbWl4aW5zIHRvIENka0Zvb3RlclJvd0RlZi5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5jbGFzcyBDZGtGb290ZXJSb3dEZWZCYXNlIGV4dGVuZHMgQmFzZVJvd0RlZiB7XG59XG5jb25zdCBfQ2RrRm9vdGVyUm93RGVmQmFzZSA9IG1peGluSGFzU3RpY2t5SW5wdXQoQ2RrRm9vdGVyUm93RGVmQmFzZSk7XG4vKipcbiAqIEZvb3RlciByb3cgZGVmaW5pdGlvbiBmb3IgdGhlIENESyB0YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBmb290ZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIGZvb3RlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xuY2xhc3MgQ2RrRm9vdGVyUm93RGVmIGV4dGVuZHMgX0Nka0Zvb3RlclJvd0RlZkJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBfZGlmZmVycywgX3RhYmxlKSB7XG4gICAgICAgIHN1cGVyKHRlbXBsYXRlLCBfZGlmZmVycyk7XG4gICAgICAgIHRoaXMuX3RhYmxlID0gX3RhYmxlO1xuICAgIH1cbiAgICAvLyBQcmVyZW5kZXIgZmFpbHMgdG8gcmVjb2duaXplIHRoYXQgbmdPbkNoYW5nZXMgaW4gYSBwYXJ0IG9mIHRoaXMgY2xhc3MgdGhyb3VnaCBpbmhlcml0YW5jZS5cbiAgICAvLyBFeHBsaWNpdGx5IGRlZmluZSBpdCBzbyB0aGF0IHRoZSBtZXRob2QgaXMgY2FsbGVkIGFzIHBhcnQgb2YgdGhlIEFuZ3VsYXIgbGlmZWN5Y2xlLlxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfVxufVxuQ2RrRm9vdGVyUm93RGVmLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrRm9vdGVyUm93RGVmLCBkZXBzOiBbeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfSwgeyB0b2tlbjogaTAuSXRlcmFibGVEaWZmZXJzIH0sIHsgdG9rZW46IENES19UQUJMRSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrRm9vdGVyUm93RGVmLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrRm9vdGVyUm93RGVmLCBzZWxlY3RvcjogXCJbY2RrRm9vdGVyUm93RGVmXVwiLCBpbnB1dHM6IHsgY29sdW1uczogW1wiY2RrRm9vdGVyUm93RGVmXCIsIFwiY29sdW1uc1wiXSwgc3RpY2t5OiBbXCJjZGtGb290ZXJSb3dEZWZTdGlja3lcIiwgXCJzdGlja3lcIl0gfSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtGb290ZXJSb3dEZWYsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tjZGtGb290ZXJSb3dEZWZdJyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBbJ2NvbHVtbnM6IGNka0Zvb3RlclJvd0RlZicsICdzdGlja3k6IGNka0Zvb3RlclJvd0RlZlN0aWNreSddLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuVGVtcGxhdGVSZWYgfSwgeyB0eXBlOiBpMC5JdGVyYWJsZURpZmZlcnMgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0NES19UQUJMRV1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfV0gfV07IH0gfSk7XG4vKipcbiAqIERhdGEgcm93IGRlZmluaXRpb24gZm9yIHRoZSBDREsgdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgaGVhZGVyIHJvdydzIHRlbXBsYXRlIGFuZCBvdGhlciByb3cgcHJvcGVydGllcyBzdWNoIGFzIHRoZSBjb2x1bW5zIHRvIGRpc3BsYXkgYW5kXG4gKiBhIHdoZW4gcHJlZGljYXRlIHRoYXQgZGVzY3JpYmVzIHdoZW4gdGhpcyByb3cgc2hvdWxkIGJlIHVzZWQuXG4gKi9cbmNsYXNzIENka1Jvd0RlZiBleHRlbmRzIEJhc2VSb3dEZWYge1xuICAgIC8vIFRPRE8oYW5kcmV3c2VndWluKTogQWRkIGFuIGlucHV0IGZvciBwcm92aWRpbmcgYSBzd2l0Y2ggZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gICAgLy8gICBpZiB0aGlzIHRlbXBsYXRlIHNob3VsZCBiZSB1c2VkLlxuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBfZGlmZmVycywgX3RhYmxlKSB7XG4gICAgICAgIHN1cGVyKHRlbXBsYXRlLCBfZGlmZmVycyk7XG4gICAgICAgIHRoaXMuX3RhYmxlID0gX3RhYmxlO1xuICAgIH1cbn1cbkNka1Jvd0RlZi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1Jvd0RlZiwgZGVwczogW3sgdG9rZW46IGkwLlRlbXBsYXRlUmVmIH0sIHsgdG9rZW46IGkwLkl0ZXJhYmxlRGlmZmVycyB9LCB7IHRva2VuOiBDREtfVEFCTEUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkNka1Jvd0RlZi7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka1Jvd0RlZiwgc2VsZWN0b3I6IFwiW2Nka1Jvd0RlZl1cIiwgaW5wdXRzOiB7IGNvbHVtbnM6IFtcImNka1Jvd0RlZkNvbHVtbnNcIiwgXCJjb2x1bW5zXCJdLCB3aGVuOiBbXCJjZGtSb3dEZWZXaGVuXCIsIFwid2hlblwiXSB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1Jvd0RlZiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nka1Jvd0RlZl0nLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dHM6IFsnY29sdW1uczogY2RrUm93RGVmQ29sdW1ucycsICd3aGVuOiBjZGtSb3dEZWZXaGVuJ10sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5UZW1wbGF0ZVJlZiB9LCB7IHR5cGU6IGkwLkl0ZXJhYmxlRGlmZmVycyB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0RLX1RBQkxFXVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9XSB9XTsgfSB9KTtcbi8qKlxuICogT3V0bGV0IGZvciByZW5kZXJpbmcgY2VsbHMgaW5zaWRlIG9mIGEgcm93IG9yIGhlYWRlciByb3cuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmNsYXNzIENka0NlbGxPdXRsZXQge1xuICAgIGNvbnN0cnVjdG9yKF92aWV3Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIgPSBfdmlld0NvbnRhaW5lcjtcbiAgICAgICAgQ2RrQ2VsbE91dGxldC5tb3N0UmVjZW50Q2VsbE91dGxldCA9IHRoaXM7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBvdXRsZXQgYmVpbmcgcmVuZGVyZWQgaW4gdGhlIHZpZXcsIHJlbW92ZSB0aGUgcmVmZXJlbmNlXG4gICAgICAgIC8vIGZyb20gdGhlIHN0YXRpYyBwcm9wZXJ0eSBhZnRlciBpdCBoYXMgYmVlbiBkZXN0cm95ZWQgdG8gYXZvaWQgbGVha2luZyBtZW1vcnkuXG4gICAgICAgIGlmIChDZGtDZWxsT3V0bGV0Lm1vc3RSZWNlbnRDZWxsT3V0bGV0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBDZGtDZWxsT3V0bGV0Lm1vc3RSZWNlbnRDZWxsT3V0bGV0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogU3RhdGljIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBjb25zdHJ1Y3RlZCBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICogVXNlZCBieSB0aGUgQ0RLIHRhYmxlIHdoZW4gZWFjaCBDZGtIZWFkZXJSb3cgYW5kIENka1JvdyBjb21wb25lbnQgaXMgY3JlYXRlZCB1c2luZ1xuICogY3JlYXRlRW1iZWRkZWRWaWV3LiBBZnRlciBvbmUgb2YgdGhlc2UgY29tcG9uZW50cyBhcmUgY3JlYXRlZCwgdGhpcyBwcm9wZXJ0eSB3aWxsIHByb3ZpZGVcbiAqIGEgaGFuZGxlIHRvIHByb3ZpZGUgdGhhdCBjb21wb25lbnQncyBjZWxscyBhbmQgY29udGV4dC4gQWZ0ZXIgaW5pdCwgdGhlIENka0NlbGxPdXRsZXQgd2lsbFxuICogY29uc3RydWN0IHRoZSBjZWxscyB3aXRoIHRoZSBwcm92aWRlZCBjb250ZXh0LlxuICovXG5DZGtDZWxsT3V0bGV0Lm1vc3RSZWNlbnRDZWxsT3V0bGV0ID0gbnVsbDtcbkNka0NlbGxPdXRsZXQuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtDZWxsT3V0bGV0LCBkZXBzOiBbeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5DZGtDZWxsT3V0bGV0Lsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrQ2VsbE91dGxldCwgc2VsZWN0b3I6IFwiW2Nka0NlbGxPdXRsZXRdXCIsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0NlbGxPdXRsZXQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ1tjZGtDZWxsT3V0bGV0XScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH1dOyB9IH0pO1xuLyoqIEhlYWRlciB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLiAqL1xuY2xhc3MgQ2RrSGVhZGVyUm93IHtcbn1cbkNka0hlYWRlclJvdy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka0hlYWRlclJvdywgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuQ2RrSGVhZGVyUm93Lsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrSGVhZGVyUm93LCBzZWxlY3RvcjogXCJjZGstaGVhZGVyLXJvdywgdHJbY2RrLWhlYWRlci1yb3ddXCIsIGhvc3Q6IHsgYXR0cmlidXRlczogeyBcInJvbGVcIjogXCJyb3dcIiB9LCBjbGFzc0F0dHJpYnV0ZTogXCJjZGstaGVhZGVyLXJvd1wiIH0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IFwiPG5nLWNvbnRhaW5lciBjZGtDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPlwiLCBpc0lubGluZTogdHJ1ZSwgZGVwZW5kZW5jaWVzOiBbeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBDZGtDZWxsT3V0bGV0LCBzZWxlY3RvcjogXCJbY2RrQ2VsbE91dGxldF1cIiB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrSGVhZGVyUm93LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstaGVhZGVyLXJvdywgdHJbY2RrLWhlYWRlci1yb3ddJyxcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IENES19ST1dfVEVNUExBVEUsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6ICdjZGstaGVhZGVyLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgbm90ZSBvbiBDZGtUYWJsZSBmb3IgZXhwbGFuYXRpb24gb24gd2h5IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCBjaGFuZ2UgZGV0ZWN0aW9uIHN0cmF0ZWd5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFsaWRhdGUtZGVjb3JhdG9yc1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKiogRm9vdGVyIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuICovXG5jbGFzcyBDZGtGb290ZXJSb3cge1xufVxuQ2RrRm9vdGVyUm93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrRm9vdGVyUm93LCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5Db21wb25lbnQgfSk7XG5DZGtGb290ZXJSb3cuybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtGb290ZXJSb3csIHNlbGVjdG9yOiBcImNkay1mb290ZXItcm93LCB0cltjZGstZm9vdGVyLXJvd11cIiwgaG9zdDogeyBhdHRyaWJ1dGVzOiB7IFwicm9sZVwiOiBcInJvd1wiIH0sIGNsYXNzQXR0cmlidXRlOiBcImNkay1mb290ZXItcm93XCIgfSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogXCI8bmctY29udGFpbmVyIGNka0NlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+XCIsIGlzSW5saW5lOiB0cnVlLCBkZXBlbmRlbmNpZXM6IFt7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IENka0NlbGxPdXRsZXQsIHNlbGVjdG9yOiBcIltjZGtDZWxsT3V0bGV0XVwiIH1dLCBjaGFuZ2VEZXRlY3Rpb246IGkwLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsIGVuY2Fwc3VsYXRpb246IGkwLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtGb290ZXJSb3csIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay1mb290ZXItcm93LCB0cltjZGstZm9vdGVyLXJvd10nLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogQ0RLX1JPV19URU1QTEFURSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzJzogJ2Nkay1mb290ZXItcm93JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBub3RlIG9uIENka1RhYmxlIGZvciBleHBsYW5hdGlvbiBvbiB3aHkgdGhpcyB1c2VzIHRoZSBkZWZhdWx0IGNoYW5nZSBkZXRlY3Rpb24gc3RyYXRlZ3kuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YWxpZGF0ZS1kZWNvcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcbi8qKiBEYXRhIHJvdyB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLiAqL1xuY2xhc3MgQ2RrUm93IHtcbn1cbkNka1Jvdy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1JvdywgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuQ2RrUm93Lsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrUm93LCBzZWxlY3RvcjogXCJjZGstcm93LCB0cltjZGstcm93XVwiLCBob3N0OiB7IGF0dHJpYnV0ZXM6IHsgXCJyb2xlXCI6IFwicm93XCIgfSwgY2xhc3NBdHRyaWJ1dGU6IFwiY2RrLXJvd1wiIH0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IFwiPG5nLWNvbnRhaW5lciBjZGtDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPlwiLCBpc0lubGluZTogdHJ1ZSwgZGVwZW5kZW5jaWVzOiBbeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBDZGtDZWxsT3V0bGV0LCBzZWxlY3RvcjogXCJbY2RrQ2VsbE91dGxldF1cIiB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrUm93LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdjZGstcm93LCB0cltjZGstcm93XScsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBDREtfUk9XX1RFTVBMQVRFLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnY2RrLXJvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICdyb3cnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgbm90ZSBvbiBDZGtUYWJsZSBmb3IgZXhwbGFuYXRpb24gb24gd2h5IHRoaXMgdXNlcyB0aGUgZGVmYXVsdCBjaGFuZ2UgZGV0ZWN0aW9uIHN0cmF0ZWd5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFsaWRhdGUtZGVjb3JhdG9yc1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKiogUm93IHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhIG1lc3NhZ2Ugd2hlbiBubyBkYXRhIGlzIHNob3duIGluIHRoZSB0YWJsZS4gKi9cbmNsYXNzIENka05vRGF0YVJvdyB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgICAgICB0aGlzLl9jb250ZW50Q2xhc3NOYW1lID0gJ2Nkay1uby1kYXRhLXJvdyc7XG4gICAgfVxufVxuQ2RrTm9EYXRhUm93Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrTm9EYXRhUm93LCBkZXBzOiBbeyB0b2tlbjogaTAuVGVtcGxhdGVSZWYgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pO1xuQ2RrTm9EYXRhUm93Lsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrTm9EYXRhUm93LCBzZWxlY3RvcjogXCJuZy10ZW1wbGF0ZVtjZGtOb0RhdGFSb3ddXCIsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka05vRGF0YVJvdywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbY2RrTm9EYXRhUm93XScsXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5UZW1wbGF0ZVJlZiB9XTsgfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIExpc3Qgb2YgYWxsIHBvc3NpYmxlIGRpcmVjdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3Igc3RpY2t5IHBvc2l0aW9uaW5nLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jb25zdCBTVElDS1lfRElSRUNUSU9OUyA9IFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG4vKipcbiAqIEFwcGxpZXMgYW5kIHJlbW92ZXMgc3RpY2t5IHBvc2l0aW9uaW5nIHN0eWxlcyB0byB0aGUgYENka1RhYmxlYCByb3dzIGFuZCBjb2x1bW5zIGNlbGxzLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jbGFzcyBTdGlja3lTdHlsZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBfaXNOYXRpdmVIdG1sVGFibGUgV2hldGhlciB0aGUgc3RpY2t5IGxvZ2ljIHNob3VsZCBiZSBiYXNlZCBvbiBhIHRhYmxlXG4gICAgICogICAgIHRoYXQgdXNlcyB0aGUgbmF0aXZlIGA8dGFibGU+YCBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBfc3RpY2tDZWxsQ3NzIFRoZSBDU1MgY2xhc3MgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gZXZlcnkgcm93L2NlbGwgdGhhdCBoYXNcbiAgICAgKiAgICAgc3RpY2t5IHBvc2l0aW9uaW5nIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uYWxpdHkgY29udGV4dCBvZiB0aGUgdGFibGUgKGx0ci9ydGwpOyBhZmZlY3RzIGNvbHVtbiBwb3NpdGlvbmluZ1xuICAgICAqICAgICBieSByZXZlcnNpbmcgbGVmdC9yaWdodCBwb3NpdGlvbnMuXG4gICAgICogQHBhcmFtIF9pc0Jyb3dzZXIgV2hldGhlciB0aGUgdGFibGUgaXMgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgb3IgdGhlIGNsaWVudC5cbiAgICAgKiBAcGFyYW0gX25lZWRzUG9zaXRpb25TdGlja3lPbkVsZW1lbnQgV2hldGhlciB3ZSBuZWVkIHRvIHNwZWNpZnkgcG9zaXRpb246IHN0aWNreSBvbiBjZWxsc1xuICAgICAqICAgICB1c2luZyBpbmxpbmUgc3R5bGVzLiBJZiBmYWxzZSwgaXQgaXMgYXNzdW1lZCB0aGF0IHBvc2l0aW9uOiBzdGlja3kgaXMgaW5jbHVkZWQgaW5cbiAgICAgKiAgICAgdGhlIGNvbXBvbmVudCBzdHlsZXNoZWV0IGZvciBfc3RpY2tDZWxsQ3NzLlxuICAgICAqIEBwYXJhbSBfcG9zaXRpb25MaXN0ZW5lciBBIGxpc3RlbmVyIHRoYXQgaXMgbm90aWZpZWQgb2YgY2hhbmdlcyB0byBzdGlja3kgcm93cy9jb2x1bW5zXG4gICAgICogICAgIGFuZCB0aGVpciBkaW1lbnNpb25zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKF9pc05hdGl2ZUh0bWxUYWJsZSwgX3N0aWNrQ2VsbENzcywgZGlyZWN0aW9uLCBfY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIsIF9pc0Jyb3dzZXIgPSB0cnVlLCBfbmVlZHNQb3NpdGlvblN0aWNreU9uRWxlbWVudCA9IHRydWUsIF9wb3NpdGlvbkxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlID0gX2lzTmF0aXZlSHRtbFRhYmxlO1xuICAgICAgICB0aGlzLl9zdGlja0NlbGxDc3MgPSBfc3RpY2tDZWxsQ3NzO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgPSBfY29hbGVzY2VkU3R5bGVTY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzQnJvd3NlciA9IF9pc0Jyb3dzZXI7XG4gICAgICAgIHRoaXMuX25lZWRzUG9zaXRpb25TdGlja3lPbkVsZW1lbnQgPSBfbmVlZHNQb3NpdGlvblN0aWNreU9uRWxlbWVudDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb25MaXN0ZW5lciA9IF9wb3NpdGlvbkxpc3RlbmVyO1xuICAgICAgICB0aGlzLl9jYWNoZWRDZWxsV2lkdGhzID0gW107XG4gICAgICAgIHRoaXMuX2JvcmRlckNlbGxDc3MgPSB7XG4gICAgICAgICAgICAndG9wJzogYCR7X3N0aWNrQ2VsbENzc30tYm9yZGVyLWVsZW0tdG9wYCxcbiAgICAgICAgICAgICdib3R0b20nOiBgJHtfc3RpY2tDZWxsQ3NzfS1ib3JkZXItZWxlbS1ib3R0b21gLFxuICAgICAgICAgICAgJ2xlZnQnOiBgJHtfc3RpY2tDZWxsQ3NzfS1ib3JkZXItZWxlbS1sZWZ0YCxcbiAgICAgICAgICAgICdyaWdodCc6IGAke19zdGlja0NlbGxDc3N9LWJvcmRlci1lbGVtLXJpZ2h0YCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzdGlja3kgcG9zaXRpb25pbmcgc3R5bGVzIGZyb20gdGhlIHJvdyBhbmQgaXRzIGNlbGxzIGJ5IHJlc2V0dGluZyB0aGUgYHBvc2l0aW9uYFxuICAgICAqIHN0eWxlLCBzZXR0aW5nIHRoZSB6SW5kZXggdG8gMCwgYW5kIHVuc2V0dGluZyBlYWNoIHByb3ZpZGVkIHN0aWNreSBkaXJlY3Rpb24uXG4gICAgICogQHBhcmFtIHJvd3MgVGhlIGxpc3Qgb2Ygcm93cyB0aGF0IHNob3VsZCBiZSBjbGVhcmVkIGZyb20gc3RpY2tpbmcgaW4gdGhlIHByb3ZpZGVkIGRpcmVjdGlvbnNcbiAgICAgKiBAcGFyYW0gc3RpY2t5RGlyZWN0aW9ucyBUaGUgZGlyZWN0aW9ucyB0aGF0IHNob3VsZCBubyBsb25nZXIgYmUgc2V0IGFzIHN0aWNreSBvbiB0aGUgcm93cy5cbiAgICAgKi9cbiAgICBjbGVhclN0aWNreVBvc2l0aW9uaW5nKHJvd3MsIHN0aWNreURpcmVjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb0NsZWFyID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSByb3cgaXNuJ3QgYW4gZWxlbWVudCAoZS5nLiBpZiBpdCdzIGFuIGBuZy1jb250YWluZXJgKSxcbiAgICAgICAgICAgIC8vIGl0IHdvbid0IGhhdmUgaW5saW5lIHN0eWxlcyBvciBgY2hpbGRyZW5gIHNvIHdlIHNraXAgaXQuXG4gICAgICAgICAgICBpZiAocm93Lm5vZGVUeXBlICE9PSByb3cuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50c1RvQ2xlYXIucHVzaChyb3cpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3cuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1RvQ2xlYXIucHVzaChyb3cuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvYWxlc2NlIHdpdGggc3RpY2t5IHJvdy9jb2x1bW4gdXBkYXRlcyAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGNoYW5nZXMgbGlrZSBjb2x1bW4gcmVzaXplKS5cbiAgICAgICAgdGhpcy5fY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzVG9DbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreVN0eWxlKGVsZW1lbnQsIHN0aWNreURpcmVjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBzdGlja3kgbGVmdCBhbmQgcmlnaHQgcG9zaXRpb25zIHRvIHRoZSBjZWxscyBvZiBlYWNoIHJvdyBhY2NvcmRpbmcgdG8gdGhlIHN0aWNreVxuICAgICAqIHN0YXRlcyBvZiB0aGUgcmVuZGVyZWQgY29sdW1uIGRlZmluaXRpb25zLlxuICAgICAqIEBwYXJhbSByb3dzIFRoZSByb3dzIHRoYXQgc2hvdWxkIGhhdmUgaXRzIHNldCBvZiBjZWxscyBzdHVjayBhY2NvcmRpbmcgdG8gdGhlIHN0aWNreSBzdGF0ZXMuXG4gICAgICogQHBhcmFtIHN0aWNreVN0YXJ0U3RhdGVzIEEgbGlzdCBvZiBib29sZWFuIHN0YXRlcyB3aGVyZSBlYWNoIHN0YXRlIHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2VsbFxuICAgICAqICAgICBpbiB0aGlzIGluZGV4IHBvc2l0aW9uIHNob3VsZCBiZSBzdHVjayB0byB0aGUgc3RhcnQgb2YgdGhlIHJvdy5cbiAgICAgKiBAcGFyYW0gc3RpY2t5RW5kU3RhdGVzIEEgbGlzdCBvZiBib29sZWFuIHN0YXRlcyB3aGVyZSBlYWNoIHN0YXRlIHJlcHJlc2VudHMgd2hldGhlciB0aGUgY2VsbFxuICAgICAqICAgICBpbiB0aGlzIGluZGV4IHBvc2l0aW9uIHNob3VsZCBiZSBzdHVjayB0byB0aGUgZW5kIG9mIHRoZSByb3cuXG4gICAgICogQHBhcmFtIHJlY2FsY3VsYXRlQ2VsbFdpZHRocyBXaGV0aGVyIHRoZSBzdGlja3kgc3R5bGVyIHNob3VsZCByZWNhbGN1bGF0ZSB0aGUgd2lkdGggb2YgZWFjaFxuICAgICAqICAgICBjb2x1bW4gY2VsbC4gSWYgYGZhbHNlYCBjYWNoZWQgd2lkdGhzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHVwZGF0ZVN0aWNreUNvbHVtbnMocm93cywgc3RpY2t5U3RhcnRTdGF0ZXMsIHN0aWNreUVuZFN0YXRlcywgcmVjYWxjdWxhdGVDZWxsV2lkdGhzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXJvd3MubGVuZ3RoIHx8XG4gICAgICAgICAgICAhdGhpcy5faXNCcm93c2VyIHx8XG4gICAgICAgICAgICAhKHN0aWNreVN0YXJ0U3RhdGVzLnNvbWUoc3RhdGUgPT4gc3RhdGUpIHx8IHN0aWNreUVuZFN0YXRlcy5zb21lKHN0YXRlID0+IHN0YXRlKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25MaXN0ZW5lci5zdGlja3lDb2x1bW5zVXBkYXRlZCh7IHNpemVzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkxpc3RlbmVyLnN0aWNreUVuZENvbHVtbnNVcGRhdGVkKHsgc2l6ZXM6IFtdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0Um93ID0gcm93c1swXTtcbiAgICAgICAgY29uc3QgbnVtQ2VsbHMgPSBmaXJzdFJvdy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNlbGxXaWR0aHMgPSB0aGlzLl9nZXRDZWxsV2lkdGhzKGZpcnN0Um93LCByZWNhbGN1bGF0ZUNlbGxXaWR0aHMpO1xuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9ucyA9IHRoaXMuX2dldFN0aWNreVN0YXJ0Q29sdW1uUG9zaXRpb25zKGNlbGxXaWR0aHMsIHN0aWNreVN0YXJ0U3RhdGVzKTtcbiAgICAgICAgY29uc3QgZW5kUG9zaXRpb25zID0gdGhpcy5fZ2V0U3RpY2t5RW5kQ29sdW1uUG9zaXRpb25zKGNlbGxXaWR0aHMsIHN0aWNreUVuZFN0YXRlcyk7XG4gICAgICAgIGNvbnN0IGxhc3RTdGlja3lTdGFydCA9IHN0aWNreVN0YXJ0U3RhdGVzLmxhc3RJbmRleE9mKHRydWUpO1xuICAgICAgICBjb25zdCBmaXJzdFN0aWNreUVuZCA9IHN0aWNreUVuZFN0YXRlcy5pbmRleE9mKHRydWUpO1xuICAgICAgICAvLyBDb2FsZXNjZSB3aXRoIHN0aWNreSByb3cgdXBkYXRlcyAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGNoYW5nZXMgbGlrZSBjb2x1bW4gcmVzaXplKS5cbiAgICAgICAgdGhpcy5fY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNSdGwgPSB0aGlzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGlzUnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNlbGxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHJvdy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0aWNreVN0YXJ0U3RhdGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRTdGlja3lTdHlsZShjZWxsLCBzdGFydCwgc3RhcnRQb3NpdGlvbnNbaV0sIGkgPT09IGxhc3RTdGlja3lTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0aWNreUVuZFN0YXRlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkU3RpY2t5U3R5bGUoY2VsbCwgZW5kLCBlbmRQb3NpdGlvbnNbaV0sIGkgPT09IGZpcnN0U3RpY2t5RW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wb3NpdGlvbkxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25MaXN0ZW5lci5zdGlja3lDb2x1bW5zVXBkYXRlZCh7XG4gICAgICAgICAgICAgICAgICAgIHNpemVzOiBsYXN0U3RpY2t5U3RhcnQgPT09IC0xXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNlbGxXaWR0aHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgbGFzdFN0aWNreVN0YXJ0ICsgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh3aWR0aCwgaW5kZXgpID0+IChzdGlja3lTdGFydFN0YXRlc1tpbmRleF0gPyB3aWR0aCA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkxpc3RlbmVyLnN0aWNreUVuZENvbHVtbnNVcGRhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZXM6IGZpcnN0U3RpY2t5RW5kID09PSAtMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjZWxsV2lkdGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGZpcnN0U3RpY2t5RW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHdpZHRoLCBpbmRleCkgPT4gKHN0aWNreUVuZFN0YXRlc1tpbmRleCArIGZpcnN0U3RpY2t5RW5kXSA/IHdpZHRoIDogbnVsbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc3RpY2t5IHBvc2l0aW9uaW5nIHRvIHRoZSByb3cncyBjZWxscyBpZiB1c2luZyB0aGUgbmF0aXZlIHRhYmxlIGxheW91dCwgYW5kIHRvIHRoZVxuICAgICAqIHJvdyBpdHNlbGYgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSByb3dzVG9TdGljayBUaGUgbGlzdCBvZiByb3dzIHRoYXQgc2hvdWxkIGJlIHN0dWNrIGFjY29yZGluZyB0byB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAgICogICAgIHN0aWNreSBzdGF0ZSBhbmQgdG8gdGhlIHByb3ZpZGVkIHRvcCBvciBib3R0b20gcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHN0aWNreVN0YXRlcyBBIGxpc3Qgb2YgYm9vbGVhbiBzdGF0ZXMgd2hlcmUgZWFjaCBzdGF0ZSByZXByZXNlbnRzIHdoZXRoZXIgdGhlIHJvd1xuICAgICAqICAgICBzaG91bGQgYmUgc3R1Y2sgaW4gdGhlIHBhcnRpY3VsYXIgdG9wIG9yIGJvdHRvbSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgcm93IHNob3VsZCBiZSBzdHVjayBpZiB0aGF0IHJvdyBzaG91bGQgYmVcbiAgICAgKiAgICAgc3RpY2t5LlxuICAgICAqXG4gICAgICovXG4gICAgc3RpY2tSb3dzKHJvd3NUb1N0aWNrLCBzdGlja3lTdGF0ZXMsIHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGNhbid0IG1lYXN1cmUgdGhlIHJvd3Mgb24gdGhlIHNlcnZlciwgd2UgY2FuJ3Qgc3RpY2sgdGhlIHJvd3MgcHJvcGVybHkuXG4gICAgICAgIGlmICghdGhpcy5faXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcG9zaXRpb25pbmcgdGhlIHJvd3MgdG8gdGhlIGJvdHRvbSwgcmV2ZXJzZSB0aGVpciBvcmRlciB3aGVuIGV2YWx1YXRpbmcgdGhlIHN0aWNreVxuICAgICAgICAvLyBwb3NpdGlvbiBzdWNoIHRoYXQgdGhlIGxhc3Qgcm93IHN0dWNrIHdpbGwgYmUgXCJib3R0b206IDBweFwiIGFuZCBzbyBvbi4gTm90ZSB0aGF0IHRoZVxuICAgICAgICAvLyBzdGlja3kgc3RhdGVzIG5lZWQgdG8gYmUgcmV2ZXJzZWQgYXMgd2VsbC5cbiAgICAgICAgY29uc3Qgcm93cyA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IHJvd3NUb1N0aWNrLnNsaWNlKCkucmV2ZXJzZSgpIDogcm93c1RvU3RpY2s7XG4gICAgICAgIGNvbnN0IHN0YXRlcyA9IHBvc2l0aW9uID09PSAnYm90dG9tJyA/IHN0aWNreVN0YXRlcy5zbGljZSgpLnJldmVyc2UoKSA6IHN0aWNreVN0YXRlcztcbiAgICAgICAgLy8gTWVhc3VyZSByb3cgaGVpZ2h0cyBhbGwgYXQgb25jZSBiZWZvcmUgYWRkaW5nIHN0aWNreSBzdHlsZXMgdG8gcmVkdWNlIGxheW91dCB0aHJhc2hpbmcuXG4gICAgICAgIGNvbnN0IHN0aWNreU9mZnNldHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RpY2t5Q2VsbEhlaWdodHMgPSBbXTtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb1N0aWNrID0gW107XG4gICAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gMCwgc3RpY2t5T2Zmc2V0ID0gMDsgcm93SW5kZXggPCByb3dzLmxlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFzdGF0ZXNbcm93SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGlja3lPZmZzZXRzW3Jvd0luZGV4XSA9IHN0aWNreU9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xuICAgICAgICAgICAgZWxlbWVudHNUb1N0aWNrW3Jvd0luZGV4XSA9IHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlXG4gICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKHJvdy5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICA6IFtyb3ddO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gcm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIHN0aWNreU9mZnNldCArPSBoZWlnaHQ7XG4gICAgICAgICAgICBzdGlja3lDZWxsSGVpZ2h0c1tyb3dJbmRleF0gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9yZGVyZWRSb3dJbmRleCA9IHN0YXRlcy5sYXN0SW5kZXhPZih0cnVlKTtcbiAgICAgICAgLy8gQ29hbGVzY2Ugd2l0aCBvdGhlciBzdGlja3kgcm93IHVwZGF0ZXMgKHRvcC9ib3R0b20pLCBzdGlja3kgY29sdW1ucyB1cGRhdGVzXG4gICAgICAgIC8vIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgY2hhbmdlcyBsaWtlIGNvbHVtbiByZXNpemUpLlxuICAgICAgICB0aGlzLl9jb2FsZXNjZWRTdHlsZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93cy5sZW5ndGg7IHJvd0luZGV4KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlc1tyb3dJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHN0aWNreU9mZnNldHNbcm93SW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQm9yZGVyZWRSb3dJbmRleCA9IHJvd0luZGV4ID09PSBib3JkZXJlZFJvd0luZGV4O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50c1RvU3RpY2tbcm93SW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN0aWNreVN0eWxlKGVsZW1lbnQsIHBvc2l0aW9uLCBvZmZzZXQsIGlzQm9yZGVyZWRSb3dJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uTGlzdGVuZXI/LnN0aWNreUhlYWRlclJvd3NVcGRhdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZXM6IHN0aWNreUNlbGxIZWlnaHRzLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRzOiBzdGlja3lPZmZzZXRzLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNUb1N0aWNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25MaXN0ZW5lcj8uc3RpY2t5Rm9vdGVyUm93c1VwZGF0ZWQoe1xuICAgICAgICAgICAgICAgICAgICBzaXplczogc3RpY2t5Q2VsbEhlaWdodHMsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldHM6IHN0aWNreU9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1RvU3RpY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBuYXRpdmUgdGFibGUgaW4gU2FmYXJpLCBzdGlja3kgZm9vdGVyIGNlbGxzIGRvIG5vdCBzdGljay4gVGhlIG9ubHkgd2F5IHRvIHN0aWNrXG4gICAgICogZm9vdGVyIHJvd3MgaXMgdG8gYXBwbHkgc3RpY2t5IHN0eWxpbmcgdG8gdGhlIHRmb290IGNvbnRhaW5lci4gVGhpcyBzaG91bGQgb25seSBiZSBkb25lIGlmXG4gICAgICogYWxsIGZvb3RlciByb3dzIGFyZSBzdGlja3kuIElmIG5vdCBhbGwgZm9vdGVyIHJvd3MgYXJlIHN0aWNreSwgcmVtb3ZlIHN0aWNreSBwb3NpdGlvbmluZyBmcm9tXG4gICAgICogdGhlIHRmb290IGVsZW1lbnQuXG4gICAgICovXG4gICAgdXBkYXRlU3RpY2t5Rm9vdGVyQ29udGFpbmVyKHRhYmxlRWxlbWVudCwgc3RpY2t5U3RhdGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNOYXRpdmVIdG1sVGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0Zm9vdCA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Zm9vdCcpO1xuICAgICAgICAvLyBDb2FsZXNjZSB3aXRoIG90aGVyIHN0aWNreSB1cGRhdGVzIChhbmQgcG90ZW50aWFsbHkgb3RoZXIgY2hhbmdlcyBsaWtlIGNvbHVtbiByZXNpemUpLlxuICAgICAgICB0aGlzLl9jb2FsZXNjZWRTdHlsZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RpY2t5U3RhdGVzLnNvbWUoc3RhdGUgPT4gIXN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreVN0eWxlKHRmb290LCBbJ2JvdHRvbSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN0aWNreVN0eWxlKHRmb290LCAnYm90dG9tJywgMCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgc3RpY2t5IHN0eWxlIG9uIHRoZSBlbGVtZW50IGJ5IHJlbW92aW5nIHRoZSBzdGlja3kgY2VsbCBDU1MgY2xhc3MsIHJlLWV2YWx1YXRpbmdcbiAgICAgKiB0aGUgekluZGV4LCByZW1vdmluZyBlYWNoIG9mIHRoZSBwcm92aWRlZCBzdGlja3kgZGlyZWN0aW9ucywgYW5kIHJlbW92aW5nIHRoZVxuICAgICAqIHN0aWNreSBwb3NpdGlvbiBpZiB0aGVyZSBhcmUgbm8gbW9yZSBkaXJlY3Rpb25zLlxuICAgICAqL1xuICAgIF9yZW1vdmVTdGlja3lTdHlsZShlbGVtZW50LCBzdGlja3lEaXJlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIHN0aWNreURpcmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbZGlyXSA9ICcnO1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2JvcmRlckNlbGxDc3NbZGlyXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBhbnkgbW9yZSBzdGlja3kgZGlyZWN0aW9ucywgcmVtb3ZlIHN0aWNreSBwb3NpdGlvbmluZyBhbmRcbiAgICAgICAgLy8gdGhlIHN0aWNreSBDU1MgY2xhc3MuXG4gICAgICAgIC8vIFNob3J0LWNpcmN1aXQgY2hlY2tpbmcgZWxlbWVudC5zdHlsZVtkaXJdIGZvciBzdGlja3lEaXJlY3Rpb25zIGFzIHRoZXlcbiAgICAgICAgLy8gd2VyZSBhbHJlYWR5IHJlbW92ZWQgYWJvdmUuXG4gICAgICAgIGNvbnN0IGhhc0RpcmVjdGlvbiA9IFNUSUNLWV9ESVJFQ1RJT05TLnNvbWUoZGlyID0+IHN0aWNreURpcmVjdGlvbnMuaW5kZXhPZihkaXIpID09PSAtMSAmJiBlbGVtZW50LnN0eWxlW2Rpcl0pO1xuICAgICAgICBpZiAoaGFzRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnpJbmRleCA9IHRoaXMuX2dldENhbGN1bGF0ZWRaSW5kZXgoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXaGVuIG5vdCBoYXNEaXJlY3Rpb24sIF9nZXRDYWxjdWxhdGVkWkluZGV4IHdpbGwgYWx3YXlzIHJldHVybiAnJy5cbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuekluZGV4ID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNQb3NpdGlvblN0aWNreU9uRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9zdGlja0NlbGxDc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHN0aWNreSBzdHlsaW5nIHRvIHRoZSBlbGVtZW50IGJ5IGFkZGluZyB0aGUgc3RpY2t5IHN0eWxlIGNsYXNzLCBjaGFuZ2luZyBwb3NpdGlvblxuICAgICAqIHRvIGJlIHN0aWNreSAoYW5kIC13ZWJraXQtc3RpY2t5KSwgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUgekluZGV4LCBhbmQgYWRkaW5nIGEgc3RpY2t5XG4gICAgICogZGlyZWN0aW9uIGFuZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBfYWRkU3RpY2t5U3R5bGUoZWxlbWVudCwgZGlyLCBkaXJWYWx1ZSwgaXNCb3JkZXJFbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLl9zdGlja0NlbGxDc3MpO1xuICAgICAgICBpZiAoaXNCb3JkZXJFbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fYm9yZGVyQ2VsbENzc1tkaXJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnN0eWxlW2Rpcl0gPSBgJHtkaXJWYWx1ZX1weGA7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuekluZGV4ID0gdGhpcy5fZ2V0Q2FsY3VsYXRlZFpJbmRleChlbGVtZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzUG9zaXRpb25TdGlja3lPbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCArPSAncG9zaXRpb246IC13ZWJraXQtc3RpY2t5OyBwb3NpdGlvbjogc3RpY2t5OyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB3aGF0IHRoZSB6LWluZGV4IHNob3VsZCBiZSBmb3IgdGhlIGVsZW1lbnQsIGRlcGVuZGluZyBvbiB3aGF0IGRpcmVjdGlvbnMgKHRvcCxcbiAgICAgKiBib3R0b20sIGxlZnQsIHJpZ2h0KSBoYXZlIGJlZW4gc2V0LiBJdCBzaG91bGQgYmUgdHJ1ZSB0aGF0IGVsZW1lbnRzIHdpdGggYSB0b3AgZGlyZWN0aW9uXG4gICAgICogc2hvdWxkIGhhdmUgdGhlIGhpZ2hlc3QgaW5kZXggc2luY2UgdGhlc2UgYXJlIGVsZW1lbnRzIGxpa2UgYSB0YWJsZSBoZWFkZXIuIElmIGFueSBvZiB0aG9zZVxuICAgICAqIGVsZW1lbnRzIGFyZSBhbHNvIHN0aWNreSBpbiBhbm90aGVyIGRpcmVjdGlvbiwgdGhlbiB0aGV5IHNob3VsZCBhcHBlYXIgYWJvdmUgb3RoZXIgZWxlbWVudHNcbiAgICAgKiB0aGF0IGFyZSBvbmx5IHN0aWNreSB0b3AgKGUuZy4gYSBzdGlja3kgY29sdW1uIG9uIGEgc3RpY2t5IGhlYWRlcikuIEJvdHRvbS1zdGlja3kgZWxlbWVudHNcbiAgICAgKiAoZS5nLiBmb290ZXIgcm93cykgc2hvdWxkIHRoZW4gYmUgbmV4dCBpbiB0aGUgb3JkZXJpbmcgc3VjaCB0aGF0IHRoZXkgYXJlIGJlbG93IHRoZSBoZWFkZXJcbiAgICAgKiBidXQgYWJvdmUgYW55IG5vbi1zdGlja3kgZWxlbWVudHMuIEZpbmFsbHksIGxlZnQvcmlnaHQgc3RpY2t5IGVsZW1lbnRzIChlLmcuIHN0aWNreSBjb2x1bW5zKVxuICAgICAqIHNob3VsZCBtaW5pbWFsbHkgaW5jcmVtZW50IHNvIHRoYXQgdGhleSBhcmUgYWJvdmUgbm9uLXN0aWNreSBlbGVtZW50cyBidXQgYmVsb3cgdG9wIGFuZCBib3R0b21cbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBfZ2V0Q2FsY3VsYXRlZFpJbmRleChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHpJbmRleEluY3JlbWVudHMgPSB7XG4gICAgICAgICAgICB0b3A6IDEwMCxcbiAgICAgICAgICAgIGJvdHRvbTogMTAsXG4gICAgICAgICAgICBsZWZ0OiAxLFxuICAgICAgICAgICAgcmlnaHQ6IDEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCB6SW5kZXggPSAwO1xuICAgICAgICAvLyBVc2UgYEl0ZXJhYmxlYCBpbnN0ZWFkIG9mIGBBcnJheWAgYmVjYXVzZSBUeXBlU2NyaXB0LCBhcyBvZiAzLjYuMyxcbiAgICAgICAgLy8gbG9zZXMgdGhlIGFycmF5IGdlbmVyaWMgdHlwZSBpbiB0aGUgYGZvciBvZmAuIEJ1dCB3ZSAqYWxzbyogaGF2ZSB0byB1c2UgYEFycmF5YCBiZWNhdXNlXG4gICAgICAgIC8vIHR5cGVzY3JpcHQgd29uJ3QgaXRlcmF0ZSBvdmVyIGFuIGBJdGVyYWJsZWAgdW5sZXNzIHlvdSBjb21waWxlIHdpdGggYC0tZG93bmxldmVsSXRlcmF0aW9uYFxuICAgICAgICBmb3IgKGNvbnN0IGRpciBvZiBTVElDS1lfRElSRUNUSU9OUykge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGVbZGlyXSkge1xuICAgICAgICAgICAgICAgIHpJbmRleCArPSB6SW5kZXhJbmNyZW1lbnRzW2Rpcl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHpJbmRleCA/IGAke3pJbmRleH1gIDogJyc7XG4gICAgfVxuICAgIC8qKiBHZXRzIHRoZSB3aWR0aHMgZm9yIGVhY2ggY2VsbCBpbiB0aGUgcHJvdmlkZWQgcm93LiAqL1xuICAgIF9nZXRDZWxsV2lkdGhzKHJvdywgcmVjYWxjdWxhdGVDZWxsV2lkdGhzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXJlY2FsY3VsYXRlQ2VsbFdpZHRocyAmJiB0aGlzLl9jYWNoZWRDZWxsV2lkdGhzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZENlbGxXaWR0aHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VsbFdpZHRocyA9IFtdO1xuICAgICAgICBjb25zdCBmaXJzdFJvd0NlbGxzID0gcm93LmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0Um93Q2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gZmlyc3RSb3dDZWxsc1tpXTtcbiAgICAgICAgICAgIGNlbGxXaWR0aHMucHVzaChjZWxsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWNoZWRDZWxsV2lkdGhzID0gY2VsbFdpZHRocztcbiAgICAgICAgcmV0dXJuIGNlbGxXaWR0aHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9ucyBvZiBlYWNoIHN0aWNreSBjb2x1bW4gY2VsbCwgd2hpY2ggd2lsbCBiZSB0aGVcbiAgICAgKiBhY2N1bXVsYXRpb24gb2YgYWxsIHN0aWNreSBjb2x1bW4gY2VsbCB3aWR0aHMgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0LCByZXNwZWN0aXZlbHkuXG4gICAgICogTm9uLXN0aWNreSBjZWxscyBkbyBub3QgbmVlZCB0byBoYXZlIGEgdmFsdWUgc2V0IHNpbmNlIHRoZWlyIHBvc2l0aW9ucyB3aWxsIG5vdCBiZSBhcHBsaWVkLlxuICAgICAqL1xuICAgIF9nZXRTdGlja3lTdGFydENvbHVtblBvc2l0aW9ucyh3aWR0aHMsIHN0aWNreVN0YXRlcykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc3RpY2t5U3RhdGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2ldID0gbmV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiArPSB3aWR0aHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbGVmdCBhbmQgcmlnaHQgcG9zaXRpb25zIG9mIGVhY2ggc3RpY2t5IGNvbHVtbiBjZWxsLCB3aGljaCB3aWxsIGJlIHRoZVxuICAgICAqIGFjY3VtdWxhdGlvbiBvZiBhbGwgc3RpY2t5IGNvbHVtbiBjZWxsIHdpZHRocyB0byB0aGUgbGVmdCBhbmQgcmlnaHQsIHJlc3BlY3RpdmVseS5cbiAgICAgKiBOb24tc3RpY2t5IGNlbGxzIGRvIG5vdCBuZWVkIHRvIGhhdmUgYSB2YWx1ZSBzZXQgc2luY2UgdGhlaXIgcG9zaXRpb25zIHdpbGwgbm90IGJlIGFwcGxpZWQuXG4gICAgICovXG4gICAgX2dldFN0aWNreUVuZENvbHVtblBvc2l0aW9ucyh3aWR0aHMsIHN0aWNreVN0YXRlcykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB3aWR0aHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoc3RpY2t5U3RhdGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2ldID0gbmV4dFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiArPSB3aWR0aHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gZmluZCBhbiBub25leGlzdGVudCBjb2x1bW4uXG4gKiBAcGFyYW0gaWQgSWQgd2hvc2UgbG9va3VwIGZhaWxlZC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VGFibGVVbmtub3duQ29sdW1uRXJyb3IoaWQpIHtcbiAgICByZXR1cm4gRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNvbHVtbiB3aXRoIGlkIFwiJHtpZH1cIi5gKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0d28gY29sdW1uIGRlZmluaXRpb25zIGhhdmUgdGhlIHNhbWUgbmFtZS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VGFibGVEdXBsaWNhdGVDb2x1bW5OYW1lRXJyb3IobmFtZSkge1xuICAgIHJldHVybiBFcnJvcihgRHVwbGljYXRlIGNvbHVtbiBkZWZpbml0aW9uIG5hbWUgcHJvdmlkZWQ6IFwiJHtuYW1lfVwiLmApO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGVycm9yIHRvIGJlIHRocm93biB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSByb3dzIHRoYXQgYXJlIG1pc3NpbmcgYSB3aGVuIGZ1bmN0aW9uLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUYWJsZU11bHRpcGxlRGVmYXVsdFJvd0RlZnNFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoYFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBkZWZhdWx0IHJvdyB3aXRob3V0IGEgd2hlbiBwcmVkaWNhdGUgZnVuY3Rpb24uYCk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gdGhlcmUgYXJlIG5vIG1hdGNoaW5nIHJvdyBkZWZzIGZvciBhIHBhcnRpY3VsYXIgc2V0IG9mIGRhdGEuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRhYmxlTWlzc2luZ01hdGNoaW5nUm93RGVmRXJyb3IoZGF0YSkge1xuICAgIHJldHVybiBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyByb3cgZGVmaW5pdGlvbiBmb3IgdGhlYCArXG4gICAgICAgIGBwcm92aWRlZCByb3cgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGVyZSBpcyBubyByb3cgZGVmaW5pdGlvbnMgcHJlc2VudCBpbiB0aGUgY29udGVudC5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0VGFibGVNaXNzaW5nUm93RGVmc0Vycm9yKCkge1xuICAgIHJldHVybiBFcnJvcignTWlzc2luZyBkZWZpbml0aW9ucyBmb3IgaGVhZGVyLCBmb290ZXIsIGFuZCByb3c7ICcgK1xuICAgICAgICAnY2Fubm90IGRldGVybWluZSB3aGljaCBjb2x1bW5zIHNob3VsZCBiZSByZW5kZXJlZC4nKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgZGF0YSBzb3VyY2UgZG9lcyBub3QgbWF0Y2ggdGhlIGNvbXBhdGlibGUgdHlwZXMuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFRhYmxlVW5rbm93bkRhdGFTb3VyY2VFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoYFByb3ZpZGVkIGRhdGEgc291cmNlIGRpZCBub3QgbWF0Y2ggYW4gYXJyYXksIE9ic2VydmFibGUsIG9yIERhdGFTb3VyY2VgKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBlcnJvciB0byBiZSB0aHJvd24gd2hlbiB0aGUgdGV4dCBjb2x1bW4gY2Fubm90IGZpbmQgYSBwYXJlbnQgdGFibGUgdG8gaW5qZWN0LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUYWJsZVRleHRDb2x1bW5NaXNzaW5nUGFyZW50VGFibGVFcnJvcigpIHtcbiAgICByZXR1cm4gRXJyb3IoYFRleHQgY29sdW1uIGNvdWxkIG5vdCBmaW5kIGEgcGFyZW50IHRhYmxlIGZvciByZWdpc3RyYXRpb24uYCk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIHdoZW4gYSB0YWJsZSB0ZXh0IGNvbHVtbiBkb2Vzbid0IGhhdmUgYSBuYW1lLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUYWJsZVRleHRDb2x1bW5NaXNzaW5nTmFtZUVycm9yKCkge1xuICAgIHJldHVybiBFcnJvcihgVGFibGUgdGV4dCBjb2x1bW4gbXVzdCBoYXZlIGEgbmFtZS5gKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKiogVGhlIGluamVjdGlvbiB0b2tlbiB1c2VkIHRvIHNwZWNpZnkgdGhlIFN0aWNreVBvc2l0aW9uaW5nTGlzdGVuZXIuICovXG5jb25zdCBTVElDS1lfUE9TSVRJT05JTkdfTElTVEVORVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0NES19TUEwnKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIEVuYWJsZXMgdGhlIHJlY3ljbGUgdmlldyByZXBlYXRlciBzdHJhdGVneSwgd2hpY2ggcmVkdWNlcyByZW5kZXJpbmcgbGF0ZW5jeS4gTm90IGNvbXBhdGlibGUgd2l0aFxuICogdGFibGVzIHRoYXQgYW5pbWF0ZSByb3dzLlxuICovXG5jbGFzcyBDZGtSZWN5Y2xlUm93cyB7XG59XG5DZGtSZWN5Y2xlUm93cy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1JlY3ljbGVSb3dzLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5DZGtSZWN5Y2xlUm93cy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IENka1JlY3ljbGVSb3dzLCBzZWxlY3RvcjogXCJjZGstdGFibGVbcmVjeWNsZVJvd3NdLCB0YWJsZVtjZGstdGFibGVdW3JlY3ljbGVSb3dzXVwiLCBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IF9WSUVXX1JFUEVBVEVSX1NUUkFURUdZLCB1c2VDbGFzczogX1JlY3ljbGVWaWV3UmVwZWF0ZXJTdHJhdGVneSB9XSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrUmVjeWNsZVJvd3MsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay10YWJsZVtyZWN5Y2xlUm93c10sIHRhYmxlW2Nkay10YWJsZV1bcmVjeWNsZVJvd3NdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgdXNlQ2xhc3M6IF9SZWN5Y2xlVmlld1JlcGVhdGVyU3RyYXRlZ3kgfV0sXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG4vKipcbiAqIFByb3ZpZGVzIGEgaGFuZGxlIGZvciB0aGUgdGFibGUgdG8gZ3JhYiB0aGUgdmlldyBjb250YWluZXIncyBuZy1jb250YWluZXIgdG8gaW5zZXJ0IGRhdGEgcm93cy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgRGF0YVJvd091dGxldCB7XG4gICAgY29uc3RydWN0b3Iodmlld0NvbnRhaW5lciwgZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXIgPSB2aWV3Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgIH1cbn1cbkRhdGFSb3dPdXRsZXQuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEYXRhUm93T3V0bGV0LCBkZXBzOiBbeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkRhdGFSb3dPdXRsZXQuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBEYXRhUm93T3V0bGV0LCBzZWxlY3RvcjogXCJbcm93T3V0bGV0XVwiLCBuZ0ltcG9ydDogaTAgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEYXRhUm93T3V0bGV0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbcm93T3V0bGV0XScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdHlwZTogaTAuRWxlbWVudFJlZiB9XTsgfSB9KTtcbi8qKlxuICogUHJvdmlkZXMgYSBoYW5kbGUgZm9yIHRoZSB0YWJsZSB0byBncmFiIHRoZSB2aWV3IGNvbnRhaW5lcidzIG5nLWNvbnRhaW5lciB0byBpbnNlcnQgdGhlIGhlYWRlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgSGVhZGVyUm93T3V0bGV0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxufVxuSGVhZGVyUm93T3V0bGV0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGVhZGVyUm93T3V0bGV0LCBkZXBzOiBbeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkhlYWRlclJvd091dGxldC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IEhlYWRlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2hlYWRlclJvd091dGxldF1cIiwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSGVhZGVyUm93T3V0bGV0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbaGVhZGVyUm93T3V0bGV0XScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdHlwZTogaTAuRWxlbWVudFJlZiB9XTsgfSB9KTtcbi8qKlxuICogUHJvdmlkZXMgYSBoYW5kbGUgZm9yIHRoZSB0YWJsZSB0byBncmFiIHRoZSB2aWV3IGNvbnRhaW5lcidzIG5nLWNvbnRhaW5lciB0byBpbnNlcnQgdGhlIGZvb3Rlci5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgRm9vdGVyUm93T3V0bGV0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxufVxuRm9vdGVyUm93T3V0bGV0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9vdGVyUm93T3V0bGV0LCBkZXBzOiBbeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbkZvb3RlclJvd091dGxldC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IEZvb3RlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2Zvb3RlclJvd091dGxldF1cIiwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9vdGVyUm93T3V0bGV0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9vdGVyUm93T3V0bGV0XScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdHlwZTogaTAuRWxlbWVudFJlZiB9XTsgfSB9KTtcbi8qKlxuICogUHJvdmlkZXMgYSBoYW5kbGUgZm9yIHRoZSB0YWJsZSB0byBncmFiIHRoZSB2aWV3XG4gKiBjb250YWluZXIncyBuZy1jb250YWluZXIgdG8gaW5zZXJ0IHRoZSBubyBkYXRhIHJvdy5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuY2xhc3MgTm9EYXRhUm93T3V0bGV0IHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3Q29udGFpbmVyLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lciA9IHZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxufVxuTm9EYXRhUm93T3V0bGV0Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9EYXRhUm93T3V0bGV0LCBkZXBzOiBbeyB0b2tlbjogaTAuVmlld0NvbnRhaW5lclJlZiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcbk5vRGF0YVJvd091dGxldC7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIHR5cGU6IE5vRGF0YVJvd091dGxldCwgc2VsZWN0b3I6IFwiW25vRGF0YVJvd091dGxldF1cIiwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9EYXRhUm93T3V0bGV0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbbm9EYXRhUm93T3V0bGV0XScgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5WaWV3Q29udGFpbmVyUmVmIH0sIHsgdHlwZTogaTAuRWxlbWVudFJlZiB9XTsgfSB9KTtcbi8qKlxuICogVGhlIHRhYmxlIHRlbXBsYXRlIHRoYXQgY2FuIGJlIHVzZWQgYnkgdGhlIG1hdC10YWJsZS4gU2hvdWxkIG5vdCBiZSB1c2VkIG91dHNpZGUgb2YgdGhlXG4gKiBtYXRlcmlhbCBsaWJyYXJ5LlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5jb25zdCBDREtfVEFCTEVfVEVNUExBVEUgPSBcbi8vIE5vdGUgdGhhdCBhY2NvcmRpbmcgdG8gTUROLCB0aGUgYGNhcHRpb25gIGVsZW1lbnQgaGFzIHRvIGJlIHByb2plY3RlZCBhcyB0aGUgKipmaXJzdCoqXG4vLyBlbGVtZW50IGluIHRoZSB0YWJsZS4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9jYXB0aW9uXG5gXG4gIDxuZy1jb250ZW50IHNlbGVjdD1cImNhcHRpb25cIj48L25nLWNvbnRlbnQ+XG4gIDxuZy1jb250ZW50IHNlbGVjdD1cImNvbGdyb3VwLCBjb2xcIj48L25nLWNvbnRlbnQ+XG4gIDxuZy1jb250YWluZXIgaGVhZGVyUm93T3V0bGV0PjwvbmctY29udGFpbmVyPlxuICA8bmctY29udGFpbmVyIHJvd091dGxldD48L25nLWNvbnRhaW5lcj5cbiAgPG5nLWNvbnRhaW5lciBub0RhdGFSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgZm9vdGVyUm93T3V0bGV0PjwvbmctY29udGFpbmVyPlxuYDtcbi8qKlxuICogQ2xhc3MgdXNlZCB0byBjb252ZW5pZW50bHkgdHlwZSB0aGUgZW1iZWRkZWQgdmlldyByZWYgZm9yIHJvd3Mgd2l0aCBhIGNvbnRleHQuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmNsYXNzIFJvd1ZpZXdSZWYgZXh0ZW5kcyBFbWJlZGRlZFZpZXdSZWYge1xufVxuLyoqXG4gKiBBIGRhdGEgdGFibGUgdGhhdCBjYW4gcmVuZGVyIGEgaGVhZGVyIHJvdywgZGF0YSByb3dzLCBhbmQgYSBmb290ZXIgcm93LlxuICogVXNlcyB0aGUgZGF0YVNvdXJjZSBpbnB1dCB0byBkZXRlcm1pbmUgdGhlIGRhdGEgdG8gYmUgcmVuZGVyZWQuIFRoZSBkYXRhIGNhbiBiZSBwcm92aWRlZCBlaXRoZXJcbiAqIGFzIGEgZGF0YSBhcnJheSwgYW4gT2JzZXJ2YWJsZSBzdHJlYW0gdGhhdCBlbWl0cyB0aGUgZGF0YSBhcnJheSB0byByZW5kZXIsIG9yIGEgRGF0YVNvdXJjZSB3aXRoIGFcbiAqIGNvbm5lY3QgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhbiBPYnNlcnZhYmxlIHN0cmVhbSB0aGF0IGVtaXRzIHRoZSBkYXRhIGFycmF5IHRvIHJlbmRlci5cbiAqL1xuY2xhc3MgQ2RrVGFibGUge1xuICAgIC8qKlxuICAgICAqIFRyYWNraW5nIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNoZWNrIHRoZSBkaWZmZXJlbmNlcyBpbiBkYXRhIGNoYW5nZXMuIFVzZWQgc2ltaWxhcmx5XG4gICAgICogdG8gYG5nRm9yYCBgdHJhY2tCeWAgZnVuY3Rpb24uIE9wdGltaXplIHJvdyBvcGVyYXRpb25zIGJ5IGlkZW50aWZ5aW5nIGEgcm93IGJhc2VkIG9uIGl0cyBkYXRhXG4gICAgICogcmVsYXRpdmUgdG8gdGhlIGZ1bmN0aW9uIHRvIGtub3cgaWYgYSByb3cgc2hvdWxkIGJlIGFkZGVkL3JlbW92ZWQvbW92ZWQuXG4gICAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnMsIGBpbmRleGAgYW5kIGBpdGVtYC5cbiAgICAgKi9cbiAgICBnZXQgdHJhY2tCeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrQnlGbjtcbiAgICB9XG4gICAgc2V0IHRyYWNrQnkoZm4pIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpICYmIGZuICE9IG51bGwgJiYgdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRyYWNrQnkgbXVzdCBiZSBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShmbil9LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYWNrQnlGbiA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdGFibGUncyBzb3VyY2Ugb2YgZGF0YSwgd2hpY2ggY2FuIGJlIHByb3ZpZGVkIGluIHRocmVlIHdheXMgKGluIG9yZGVyIG9mIGNvbXBsZXhpdHkpOlxuICAgICAqICAgLSBTaW1wbGUgZGF0YSBhcnJheSAoZWFjaCBvYmplY3QgcmVwcmVzZW50cyBvbmUgdGFibGUgcm93KVxuICAgICAqICAgLSBTdHJlYW0gdGhhdCBlbWl0cyBhIGRhdGEgYXJyYXkgZWFjaCB0aW1lIHRoZSBhcnJheSBjaGFuZ2VzXG4gICAgICogICAtIGBEYXRhU291cmNlYCBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBjb25uZWN0L2Rpc2Nvbm5lY3QgaW50ZXJmYWNlLlxuICAgICAqXG4gICAgICogSWYgYSBkYXRhIGFycmF5IGlzIHByb3ZpZGVkLCB0aGUgdGFibGUgbXVzdCBiZSBub3RpZmllZCB3aGVuIHRoZSBhcnJheSdzIG9iamVjdHMgYXJlXG4gICAgICogYWRkZWQsIHJlbW92ZWQsIG9yIG1vdmVkLiBUaGlzIGNhbiBiZSBkb25lIGJ5IGNhbGxpbmcgdGhlIGByZW5kZXJSb3dzKClgIGZ1bmN0aW9uIHdoaWNoIHdpbGxcbiAgICAgKiByZW5kZXIgdGhlIGRpZmYgc2luY2UgdGhlIGxhc3QgdGFibGUgcmVuZGVyLiBJZiB0aGUgZGF0YSBhcnJheSByZWZlcmVuY2UgaXMgY2hhbmdlZCwgdGhlIHRhYmxlXG4gICAgICogd2lsbCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgYW4gdXBkYXRlIHRvIHRoZSByb3dzLlxuICAgICAqXG4gICAgICogV2hlbiBwcm92aWRpbmcgYW4gT2JzZXJ2YWJsZSBzdHJlYW0sIHRoZSB0YWJsZSB3aWxsIHRyaWdnZXIgYW4gdXBkYXRlIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGVcbiAgICAgKiBzdHJlYW0gZW1pdHMgYSBuZXcgYXJyYXkgb2YgZGF0YS5cbiAgICAgKlxuICAgICAqIEZpbmFsbHksIHdoZW4gcHJvdmlkaW5nIGEgYERhdGFTb3VyY2VgIG9iamVjdCwgdGhlIHRhYmxlIHdpbGwgdXNlIHRoZSBPYnNlcnZhYmxlIHN0cmVhbVxuICAgICAqIHByb3ZpZGVkIGJ5IHRoZSBjb25uZWN0IGZ1bmN0aW9uIGFuZCB0cmlnZ2VyIHVwZGF0ZXMgd2hlbiB0aGF0IHN0cmVhbSBlbWl0cyBuZXcgZGF0YSBhcnJheVxuICAgICAqIHZhbHVlcy4gRHVyaW5nIHRoZSB0YWJsZSdzIG5nT25EZXN0cm95IG9yIHdoZW4gdGhlIGRhdGEgc291cmNlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdGFibGUsIHRoZVxuICAgICAqIHRhYmxlIHdpbGwgY2FsbCB0aGUgRGF0YVNvdXJjZSdzIGBkaXNjb25uZWN0YCBmdW5jdGlvbiAobWF5IGJlIHVzZWZ1bCBmb3IgY2xlYW5pbmcgdXAgYW55XG4gICAgICogc3Vic2NyaXB0aW9ucyByZWdpc3RlcmVkIGR1cmluZyB0aGUgY29ubmVjdCBwcm9jZXNzKS5cbiAgICAgKi9cbiAgICBnZXQgZGF0YVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFTb3VyY2U7XG4gICAgfVxuICAgIHNldCBkYXRhU291cmNlKGRhdGFTb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFTb3VyY2UgIT09IGRhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3N3aXRjaERhdGFTb3VyY2UoZGF0YVNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBtdWx0aXBsZSByb3dzIHBlciBkYXRhIG9iamVjdCBieSBldmFsdWF0aW5nIHdoaWNoIHJvd3MgZXZhbHVhdGUgdGhlaXIgJ3doZW4nXG4gICAgICogcHJlZGljYXRlIHRvIHRydWUuIElmIGBtdWx0aVRlbXBsYXRlRGF0YVJvd3NgIGlzIGZhbHNlLCB3aGljaCBpcyB0aGUgZGVmYXVsdCB2YWx1ZSwgdGhlbiBlYWNoXG4gICAgICogZGF0YW9iamVjdCB3aWxsIHJlbmRlciB0aGUgZmlyc3Qgcm93IHRoYXQgZXZhbHVhdGVzIGl0cyB3aGVuIHByZWRpY2F0ZSB0byB0cnVlLCBpbiB0aGUgb3JkZXJcbiAgICAgKiBkZWZpbmVkIGluIHRoZSB0YWJsZSwgb3Igb3RoZXJ3aXNlIHRoZSBkZWZhdWx0IHJvdyB3aGljaCBkb2VzIG5vdCBoYXZlIGEgd2hlbiBwcmVkaWNhdGUuXG4gICAgICovXG4gICAgZ2V0IG11bHRpVGVtcGxhdGVEYXRhUm93cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpVGVtcGxhdGVEYXRhUm93cztcbiAgICB9XG4gICAgc2V0IG11bHRpVGVtcGxhdGVEYXRhUm93cyh2KSB7XG4gICAgICAgIHRoaXMuX211bHRpVGVtcGxhdGVEYXRhUm93cyA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2KTtcbiAgICAgICAgLy8gSW4gSXZ5IGlmIHRoaXMgdmFsdWUgaXMgc2V0IHZpYSBhIHN0YXRpYyBhdHRyaWJ1dGUgKGUuZy4gPHRhYmxlIG11bHRpVGVtcGxhdGVEYXRhUm93cz4pLFxuICAgICAgICAvLyB0aGlzIHNldHRlciB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSByb3cgb3V0bGV0IGhhcyBiZWVuIGRlZmluZWQgaGVuY2UgdGhlIG51bGwgY2hlY2suXG4gICAgICAgIGlmICh0aGlzLl9yb3dPdXRsZXQgJiYgdGhpcy5fcm93T3V0bGV0LnZpZXdDb250YWluZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlbmRlckRhdGFSb3dzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreUNvbHVtblN0eWxlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gdXNlIGEgZml4ZWQgdGFibGUgbGF5b3V0LiBFbmFibGluZyB0aGlzIG9wdGlvbiB3aWxsIGVuZm9yY2UgY29uc2lzdGVudCBjb2x1bW4gd2lkdGhzXG4gICAgICogYW5kIG9wdGltaXplIHJlbmRlcmluZyBzdGlja3kgc3R5bGVzIGZvciBuYXRpdmUgdGFibGVzLiBOby1vcCBmb3IgZmxleCB0YWJsZXMuXG4gICAgICovXG4gICAgZ2V0IGZpeGVkTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZml4ZWRMYXlvdXQ7XG4gICAgfVxuICAgIHNldCBmaXhlZExheW91dCh2KSB7XG4gICAgICAgIHRoaXMuX2ZpeGVkTGF5b3V0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHYpO1xuICAgICAgICAvLyBUb2dnbGluZyBgZml4ZWRMYXlvdXRgIG1heSBjaGFuZ2UgY29sdW1uIHdpZHRocy4gU3RpY2t5IGNvbHVtbiBzdHlsZXMgc2hvdWxkIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgICAgdGhpcy5fZm9yY2VSZWNhbGN1bGF0ZUNlbGxXaWR0aHMgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGlja3lDb2x1bW5TdHlsZXNOZWVkUmVzZXQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfZGlmZmVycywgX2NoYW5nZURldGVjdG9yUmVmLCBfZWxlbWVudFJlZiwgcm9sZSwgX2RpciwgX2RvY3VtZW50LCBfcGxhdGZvcm0sIF92aWV3UmVwZWF0ZXIsIF9jb2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgX3ZpZXdwb3J0UnVsZXIsIFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIGBfc3RpY2t5UG9zaXRpb25pbmdMaXN0ZW5lcmAgcGFyYW1ldGVyIHRvIGJlY29tZSByZXF1aXJlZC5cbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIDEzLjAuMFxuICAgICAqL1xuICAgIF9zdGlja3lQb3NpdGlvbmluZ0xpc3RlbmVyLCBcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBgX25nWm9uZWAgcGFyYW1ldGVyIHRvIGJlY29tZSByZXF1aXJlZC5cbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMFxuICAgICAqL1xuICAgIF9uZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fZGlmZmVycyA9IF9kaWZmZXJzO1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IF9wbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5fdmlld1JlcGVhdGVyID0gX3ZpZXdSZXBlYXRlcjtcbiAgICAgICAgdGhpcy5fY29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgPSBfY29hbGVzY2VkU3R5bGVTY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0UnVsZXIgPSBfdmlld3BvcnRSdWxlcjtcbiAgICAgICAgdGhpcy5fc3RpY2t5UG9zaXRpb25pbmdMaXN0ZW5lciA9IF9zdGlja3lQb3NpdGlvbmluZ0xpc3RlbmVyO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKiogU3ViamVjdCB0aGF0IGVtaXRzIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWQuICovXG4gICAgICAgIHRoaXMuX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgYWxsIHRoZSB1c2VyJ3MgZGVmaW5lZCBjb2x1bW5zIChoZWFkZXIsIGRhdGEsIGFuZCBmb290ZXIgY2VsbCB0ZW1wbGF0ZSkgaWRlbnRpZmllZCBieVxuICAgICAgICAgKiBuYW1lLiBDb2xsZWN0aW9uIHBvcHVsYXRlZCBieSB0aGUgY29sdW1uIGRlZmluaXRpb25zIGdhdGhlcmVkIGJ5IGBDb250ZW50Q2hpbGRyZW5gIGFzIHdlbGwgYXNcbiAgICAgICAgICogYW55IGN1c3RvbSBjb2x1bW4gZGVmaW5pdGlvbnMgYWRkZWQgdG8gYF9jdXN0b21Db2x1bW5EZWZzYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NvbHVtbkRlZnNCeU5hbWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2x1bW4gZGVmaW5pdGlvbnMgdGhhdCB3ZXJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgZGlyZWN0IGNvbnRlbnQgY2hpbGRyZW4gb2YgdGhlIHRhYmxlLlxuICAgICAgICAgKiBUaGVzZSB3aWxsIGJlIGRlZmluZWQgd2hlbiwgZS5nLiwgY3JlYXRpbmcgYSB3cmFwcGVyIGFyb3VuZCB0aGUgY2RrVGFibGUgdGhhdCBoYXNcbiAgICAgICAgICogY29sdW1uIGRlZmluaXRpb25zIGFzICppdHMqIGNvbnRlbnQgY2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXN0b21Db2x1bW5EZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSByb3cgZGVmaW5pdGlvbnMgdGhhdCB3ZXJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgZGlyZWN0IGNvbnRlbnQgY2hpbGRyZW4gb2YgdGhlIHRhYmxlLlxuICAgICAgICAgKiBUaGVzZSB3aWxsIGJlIGRlZmluZWQgd2hlbiwgZS5nLiwgY3JlYXRpbmcgYSB3cmFwcGVyIGFyb3VuZCB0aGUgY2RrVGFibGUgdGhhdCBoYXNcbiAgICAgICAgICogYnVpbHQtaW4gZGF0YSByb3dzIGFzICppdHMqIGNvbnRlbnQgY2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXN0b21Sb3dEZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGVhZGVyIHJvdyBkZWZpbml0aW9ucyB0aGF0IHdlcmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBkaXJlY3QgY29udGVudCBjaGlsZHJlbiBvZiB0aGUgdGFibGUuXG4gICAgICAgICAqIFRoZXNlIHdpbGwgYmUgZGVmaW5lZCB3aGVuLCBlLmcuLCBjcmVhdGluZyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBjZGtUYWJsZSB0aGF0IGhhc1xuICAgICAgICAgKiBidWlsdC1pbiBoZWFkZXIgcm93cyBhcyAqaXRzKiBjb250ZW50IGNoaWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VzdG9tSGVhZGVyUm93RGVmcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvb3RlciByb3cgZGVmaW5pdGlvbnMgdGhhdCB3ZXJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgZGlyZWN0IGNvbnRlbnQgY2hpbGRyZW4gb2YgdGhlIHRhYmxlLlxuICAgICAgICAgKiBUaGVzZSB3aWxsIGJlIGRlZmluZWQgd2hlbiwgZS5nLiwgY3JlYXRpbmcgYSB3cmFwcGVyIGFyb3VuZCB0aGUgY2RrVGFibGUgdGhhdCBoYXMgYVxuICAgICAgICAgKiBidWlsdC1pbiBmb290ZXIgcm93IGFzICppdHMqIGNvbnRlbnQgY2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jdXN0b21Gb290ZXJSb3dEZWZzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgaGVhZGVyIHJvdyBkZWZpbml0aW9uIGhhcyBiZWVuIGNoYW5nZWQuIFRyaWdnZXJzIGFuIHVwZGF0ZSB0byB0aGUgaGVhZGVyIHJvdyBhZnRlclxuICAgICAgICAgKiBjb250ZW50IGlzIGNoZWNrZWQuIEluaXRpYWxpemVkIGFzIHRydWUgc28gdGhhdCB0aGUgdGFibGUgcmVuZGVycyB0aGUgaW5pdGlhbCBzZXQgb2Ygcm93cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlYWRlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZm9vdGVyIHJvdyBkZWZpbml0aW9uIGhhcyBiZWVuIGNoYW5nZWQuIFRyaWdnZXJzIGFuIHVwZGF0ZSB0byB0aGUgZm9vdGVyIHJvdyBhZnRlclxuICAgICAgICAgKiBjb250ZW50IGlzIGNoZWNrZWQuIEluaXRpYWxpemVkIGFzIHRydWUgc28gdGhhdCB0aGUgdGFibGUgcmVuZGVycyB0aGUgaW5pdGlhbCBzZXQgb2Ygcm93cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Zvb3RlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc3RpY2t5IGNvbHVtbiBzdHlsZXMgbmVlZCB0byBiZSB1cGRhdGVkLiBTZXQgdG8gYHRydWVgIHdoZW4gdGhlIHZpc2libGUgY29sdW1uc1xuICAgICAgICAgKiBjaGFuZ2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdGlja3lDb2x1bW5TdHlsZXNOZWVkUmVzZXQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc3RpY2t5IHN0eWxlciBzaG91bGQgcmVjYWxjdWxhdGUgY2VsbCB3aWR0aHMgd2hlbiBhcHBseWluZyBzdGlja3kgc3R5bGVzLiBJZlxuICAgICAgICAgKiBgZmFsc2VgLCBjYWNoZWQgdmFsdWVzIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSB0byB0YWJsZXMgd2l0aFxuICAgICAgICAgKiB7QGxpbmsgZml4ZWRMYXlvdXR9IGVuYWJsZWQuIEZvciBvdGhlciB0YWJsZXMsIGNlbGwgd2lkdGhzIHdpbGwgYWx3YXlzIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZvcmNlUmVjYWxjdWxhdGVDZWxsV2lkdGhzID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlIG9mIHRoZSBsYXRlc3QgcmVuZGVyZWQgYFJlbmRlclJvd2Agb2JqZWN0cyBhcyBhIG1hcCBmb3IgZWFzeSByZXRyaWV2YWwgd2hlbiBjb25zdHJ1Y3RpbmdcbiAgICAgICAgICogYSBuZXcgbGlzdCBvZiBgUmVuZGVyUm93YCBvYmplY3RzIGZvciByZW5kZXJpbmcgcm93cy4gU2luY2UgdGhlIG5ldyBsaXN0IGlzIGNvbnN0cnVjdGVkIHdpdGhcbiAgICAgICAgICogdGhlIGNhY2hlZCBgUmVuZGVyUm93YCBvYmplY3RzIHdoZW4gcG9zc2libGUsIHRoZSByb3cgaWRlbnRpdHkgaXMgcHJlc2VydmVkIHdoZW4gdGhlIGRhdGFcbiAgICAgICAgICogYW5kIHJvdyB0ZW1wbGF0ZSBtYXRjaGVzLCB3aGljaCBhbGxvd3MgdGhlIGBJdGVyYWJsZURpZmZlcmAgdG8gY2hlY2sgcm93cyBieSByZWZlcmVuY2VcbiAgICAgICAgICogYW5kIHVuZGVyc3RhbmQgd2hpY2ggcm93cyBhcmUgYWRkZWQvbW92ZWQvcmVtb3ZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSW1wbGVtZW50ZWQgYXMgYSBtYXAgb2YgbWFwcyB3aGVyZSB0aGUgZmlyc3Qga2V5IGlzIHRoZSBgZGF0YTogVGAgb2JqZWN0IGFuZCB0aGUgc2Vjb25kIGlzIHRoZVxuICAgICAgICAgKiBgQ2RrUm93RGVmPFQ+YCBvYmplY3QuIFdpdGggdGhlIHR3byBrZXlzLCB0aGUgY2FjaGUgcG9pbnRzIHRvIGEgYFJlbmRlclJvdzxUPmAgb2JqZWN0IHRoYXRcbiAgICAgICAgICogY29udGFpbnMgYW4gYXJyYXkgb2YgY3JlYXRlZCBwYWlycy4gVGhlIGFycmF5IGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGRhdGFcbiAgICAgICAgICogYXJyYXkgY29udGFpbnMgbXVsdGlwbGUgZHVwbGljYXRlIGRhdGEgb2JqZWN0cyBhbmQgZWFjaCBpbnN0YW50aWF0ZWQgYFJlbmRlclJvd2AgbXVzdCBiZVxuICAgICAgICAgKiBzdG9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYWNoZWRSZW5kZXJSb3dzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ1NTIGNsYXNzIGFkZGVkIHRvIGFueSByb3cgb3IgY2VsbCB0aGF0IGhhcyBzdGlja3kgcG9zaXRpb25pbmcgYXBwbGllZC4gTWF5IGJlIG92ZXJyaWRkZW4gYnlcbiAgICAgICAgICogdGFibGUgc3ViY2xhc3Nlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RpY2t5Q3NzQ2xhc3MgPSAnY2RrLXRhYmxlLXN0aWNreSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRvIG1hbnVhbGx5IGFkZCBwb3NpdGlvbjogc3RpY2t5IHRvIGFsbCBzdGlja3kgY2VsbCBlbGVtZW50cy4gTm90IG5lZWRlZCBpZlxuICAgICAgICAgKiB0aGUgcG9zaXRpb24gaXMgc2V0IGluIGEgc2VsZWN0b3IgYXNzb2NpYXRlZCB3aXRoIHRoZSB2YWx1ZSBvZiBzdGlja3lDc3NDbGFzcy4gTWF5IGJlXG4gICAgICAgICAqIG92ZXJyaWRkZW4gYnkgdGFibGUgc3ViY2xhc3Nlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZWVkc1Bvc2l0aW9uU3RpY2t5T25FbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIG5vIGRhdGEgcm93IGlzIGN1cnJlbnRseSBzaG93aW5nIGFueXRoaW5nLiAqL1xuICAgICAgICB0aGlzLl9pc1Nob3dpbmdOb0RhdGFSb3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXVsdGlUZW1wbGF0ZURhdGFSb3dzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpeGVkTGF5b3V0ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIHRoZSB0YWJsZSBjb21wbGV0ZXMgcmVuZGVyaW5nIGEgc2V0IG9mIGRhdGEgcm93cyBiYXNlZCBvbiB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGVcbiAgICAgICAgICogZGF0YSBzb3VyY2UsIGV2ZW4gaWYgdGhlIHNldCBvZiByb3dzIGlzIGVtcHR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZW50Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLy8gVE9ETyhhbmRyZXdzZWd1aW4pOiBSZW1vdmUgbWF4IHZhbHVlIGFzIHRoZSBlbmQgaW5kZXhcbiAgICAgICAgLy8gICBhbmQgaW5zdGVhZCBjYWxjdWxhdGUgdGhlIHZpZXcgb24gaW5pdCBhbmQgc2Nyb2xsLlxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyZWFtIGNvbnRhaW5pbmcgdGhlIGxhdGVzdCBpbmZvcm1hdGlvbiBvbiB3aGF0IHJvd3MgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICAgICAqIENhbiBiZSB1c2VkIGJ5IHRoZSBkYXRhIHNvdXJjZSB0byBhcyBhIGhldXJpc3RpYyBvZiB3aGF0IGRhdGEgc2hvdWxkIGJlIHByb3ZpZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdDaGFuZ2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHtcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyb2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm5vZGVOYW1lID09PSAnVEFCTEUnO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBTdGlja3lTdHlsZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseU5hdGl2ZVRhYmxlU2VjdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgdGhlIHRyYWNrQnkgZnVuY3Rpb24gc28gdGhhdCBpdCB1c2VzIHRoZSBgUmVuZGVyUm93YCBhcyBpdHMgaWRlbnRpdHkgYnkgZGVmYXVsdC4gSWZcbiAgICAgICAgLy8gdGhlIHVzZXIgaGFzIHByb3ZpZGVkIGEgY3VzdG9tIHRyYWNrQnksIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXQgZnVuY3Rpb24gYXMgZXZhbHVhdGVkXG4gICAgICAgIC8vIHdpdGggdGhlIHZhbHVlcyBvZiB0aGUgYFJlbmRlclJvd2AncyBkYXRhIGFuZCBpbmRleC5cbiAgICAgICAgdGhpcy5fZGF0YURpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZChbXSkuY3JlYXRlKChfaSwgZGF0YVJvdykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhY2tCeSA/IHRoaXMudHJhY2tCeShkYXRhUm93LmRhdGFJbmRleCwgZGF0YVJvdy5kYXRhKSA6IGRhdGFSb3c7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl92aWV3cG9ydFJ1bGVyXG4gICAgICAgICAgICAuY2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlY2FsY3VsYXRlQ2VsbFdpZHRocyA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgICAgIC8vIENhY2hlIHRoZSByb3cgYW5kIGNvbHVtbiBkZWZpbml0aW9ucyBnYXRoZXJlZCBieSBDb250ZW50Q2hpbGRyZW4gYW5kIHByb2dyYW1tYXRpYyBpbmplY3Rpb24uXG4gICAgICAgIHRoaXMuX2NhY2hlUm93RGVmcygpO1xuICAgICAgICB0aGlzLl9jYWNoZUNvbHVtbkRlZnMoKTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHVzZXIgaGFzIGF0IGxlYXN0IGFkZGVkIGhlYWRlciwgZm9vdGVyLCBvciBkYXRhIHJvdyBkZWYuXG4gICAgICAgIGlmICghdGhpcy5faGVhZGVyUm93RGVmcy5sZW5ndGggJiZcbiAgICAgICAgICAgICF0aGlzLl9mb290ZXJSb3dEZWZzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXRoaXMuX3Jvd0RlZnMubGVuZ3RoICYmXG4gICAgICAgICAgICAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVNaXNzaW5nUm93RGVmc0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZGVyIHVwZGF0ZXMgaWYgdGhlIGxpc3Qgb2YgY29sdW1ucyBoYXZlIGJlZW4gY2hhbmdlZCBmb3IgdGhlIGhlYWRlciwgcm93LCBvciBmb290ZXIgZGVmcy5cbiAgICAgICAgY29uc3QgY29sdW1uc0NoYW5nZWQgPSB0aGlzLl9yZW5kZXJVcGRhdGVkQ29sdW1ucygpO1xuICAgICAgICBjb25zdCByb3dEZWZzQ2hhbmdlZCA9IGNvbHVtbnNDaGFuZ2VkIHx8IHRoaXMuX2hlYWRlclJvd0RlZkNoYW5nZWQgfHwgdGhpcy5fZm9vdGVyUm93RGVmQ2hhbmdlZDtcbiAgICAgICAgLy8gRW5zdXJlIHN0aWNreSBjb2x1bW4gc3R5bGVzIGFyZSByZXNldCBpZiBzZXQgdG8gYHRydWVgIGVsc2V3aGVyZS5cbiAgICAgICAgdGhpcy5fc3RpY2t5Q29sdW1uU3R5bGVzTmVlZFJlc2V0ID0gdGhpcy5fc3RpY2t5Q29sdW1uU3R5bGVzTmVlZFJlc2V0IHx8IHJvd0RlZnNDaGFuZ2VkO1xuICAgICAgICB0aGlzLl9mb3JjZVJlY2FsY3VsYXRlQ2VsbFdpZHRocyA9IHJvd0RlZnNDaGFuZ2VkO1xuICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIHJvdyBkZWZpbml0aW9uIGhhcyBiZWVuIGNoYW5nZWQsIHRyaWdnZXIgYSByZW5kZXIgdG8gdGhlIGhlYWRlciByb3cuXG4gICAgICAgIGlmICh0aGlzLl9oZWFkZXJSb3dEZWZDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlbmRlckhlYWRlclJvd3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclJvd0RlZkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZm9vdGVyIHJvdyBkZWZpbml0aW9uIGhhcyBiZWVuIGNoYW5nZWQsIHRyaWdnZXIgYSByZW5kZXIgdG8gdGhlIGZvb3RlciByb3cuXG4gICAgICAgIGlmICh0aGlzLl9mb290ZXJSb3dEZWZDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlbmRlckZvb3RlclJvd3MoKTtcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlclJvd0RlZkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGRhdGEgc291cmNlIGFuZCByb3cgZGVmaW5pdGlvbnMsIGNvbm5lY3QgdG8gdGhlIGRhdGEgc291cmNlIHVubGVzcyBhXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBtYWRlLlxuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlICYmIHRoaXMuX3Jvd0RlZnMubGVuZ3RoID4gMCAmJiAhdGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlUmVuZGVyQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3N0aWNreUNvbHVtblN0eWxlc05lZWRSZXNldCkge1xuICAgICAgICAgICAgLy8gSW4gdGhlIGFib3ZlIGNhc2UsIF9vYnNlcnZlUmVuZGVyQ2hhbmdlcyB3aWxsIHJlc3VsdCBpbiB1cGRhdGVTdGlja3lDb2x1bW5TdHlsZXMgYmVpbmdcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGl0IHJvdyBkYXRhIGFycml2ZXMuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGl0IHByb2FjdGl2ZWx5LlxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGlja3lDb2x1bW5TdHlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGVja1N0aWNreVN0YXRlcygpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgdGhpcy5fcm93T3V0bGV0LnZpZXdDb250YWluZXIsXG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJSb3dPdXRsZXQudmlld0NvbnRhaW5lcixcbiAgICAgICAgICAgIHRoaXMuX2Zvb3RlclJvd091dGxldC52aWV3Q29udGFpbmVyLFxuICAgICAgICAgICAgdGhpcy5fY2FjaGVkUmVuZGVyUm93c01hcCxcbiAgICAgICAgICAgIHRoaXMuX2N1c3RvbUNvbHVtbkRlZnMsXG4gICAgICAgICAgICB0aGlzLl9jdXN0b21Sb3dEZWZzLFxuICAgICAgICAgICAgdGhpcy5fY3VzdG9tSGVhZGVyUm93RGVmcyxcbiAgICAgICAgICAgIHRoaXMuX2N1c3RvbUZvb3RlclJvd0RlZnMsXG4gICAgICAgICAgICB0aGlzLl9jb2x1bW5EZWZzQnlOYW1lLFxuICAgICAgICBdLmZvckVhY2goZGVmID0+IHtcbiAgICAgICAgICAgIGRlZi5jbGVhcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faGVhZGVyUm93RGVmcyA9IFtdO1xuICAgICAgICB0aGlzLl9mb290ZXJSb3dEZWZzID0gW107XG4gICAgICAgIHRoaXMuX2RlZmF1bHRSb3dEZWYgPSBudWxsO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKGlzRGF0YVNvdXJjZSh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJvd3MgYmFzZWQgb24gdGhlIHRhYmxlJ3MgbGF0ZXN0IHNldCBvZiBkYXRhLCB3aGljaCB3YXMgZWl0aGVyIHByb3ZpZGVkIGRpcmVjdGx5IGFzIGFuXG4gICAgICogaW5wdXQgb3IgcmV0cmlldmVkIHRocm91Z2ggYW4gT2JzZXJ2YWJsZSBzdHJlYW0gKGRpcmVjdGx5IG9yIGZyb20gYSBEYXRhU291cmNlKS5cbiAgICAgKiBDaGVja3MgZm9yIGRpZmZlcmVuY2VzIGluIHRoZSBkYXRhIHNpbmNlIHRoZSBsYXN0IGRpZmYgdG8gcGVyZm9ybSBvbmx5IHRoZSBuZWNlc3NhcnlcbiAgICAgKiBjaGFuZ2VzIChhZGQvcmVtb3ZlL21vdmUgcm93cykuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGFibGUncyBkYXRhIHNvdXJjZSBpcyBhIERhdGFTb3VyY2Ugb3IgT2JzZXJ2YWJsZSwgdGhpcyB3aWxsIGJlIGludm9rZWQgYXV0b21hdGljYWxseVxuICAgICAqIGVhY2ggdGltZSB0aGUgcHJvdmlkZWQgT2JzZXJ2YWJsZSBzdHJlYW0gZW1pdHMgYSBuZXcgZGF0YSBhcnJheS4gT3RoZXJ3aXNlIGlmIHlvdXIgZGF0YSBpc1xuICAgICAqIGFuIGFycmF5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgbmVlZCB0byBiZSBjYWxsZWQgdG8gcmVuZGVyIGFueSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHJlbmRlclJvd3MoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclJvd3MgPSB0aGlzLl9nZXRBbGxSZW5kZXJSb3dzKCk7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kYXRhRGlmZmVyLmRpZmYodGhpcy5fcmVuZGVyUm93cyk7XG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm9EYXRhUm93KCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRDaGFuZ2VkLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3Q29udGFpbmVyID0gdGhpcy5fcm93T3V0bGV0LnZpZXdDb250YWluZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdSZXBlYXRlci5hcHBseUNoYW5nZXMoY2hhbmdlcywgdmlld0NvbnRhaW5lciwgKHJlY29yZCwgX2FkanVzdGVkUHJldmlvdXNJbmRleCwgY3VycmVudEluZGV4KSA9PiB0aGlzLl9nZXRFbWJlZGRlZFZpZXdBcmdzKHJlY29yZC5pdGVtLCBjdXJyZW50SW5kZXgpLCByZWNvcmQgPT4gcmVjb3JkLml0ZW0uZGF0YSwgKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5vcGVyYXRpb24gPT09IDEgLyogX1ZpZXdSZXBlYXRlck9wZXJhdGlvbi5JTlNFUlRFRCAqLyAmJiBjaGFuZ2UuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNlbGxUZW1wbGF0ZUZvckl0ZW0oY2hhbmdlLnJlY29yZC5pdGVtLnJvd0RlZiwgY2hhbmdlLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtZXRhIGNvbnRleHQgb2YgYSByb3cncyBjb250ZXh0IGRhdGEgKGluZGV4LCBjb3VudCwgZmlyc3QsIGxhc3QsIC4uLilcbiAgICAgICAgdGhpcy5fdXBkYXRlUm93SW5kZXhDb250ZXh0KCk7XG4gICAgICAgIC8vIFVwZGF0ZSByb3dzIHRoYXQgZGlkIG5vdCBnZXQgYWRkZWQvcmVtb3ZlZC9tb3ZlZCBidXQgbWF5IGhhdmUgaGFkIHRoZWlyIGlkZW50aXR5IGNoYW5nZWQsXG4gICAgICAgIC8vIGUuZy4gaWYgdHJhY2tCeSBtYXRjaGVkIGRhdGEgb24gc29tZSBwcm9wZXJ0eSBidXQgdGhlIGFjdHVhbCBkYXRhIHJlZmVyZW5jZSBjaGFuZ2VkLlxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJZGVudGl0eUNoYW5nZSgocmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3dWaWV3ID0gdmlld0NvbnRhaW5lci5nZXQocmVjb3JkLmN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICByb3dWaWV3LmNvbnRleHQuJGltcGxpY2l0ID0gcmVjb3JkLml0ZW0uZGF0YTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZU5vRGF0YVJvdygpO1xuICAgICAgICAvLyBBbGxvdyB0aGUgbmV3IHJvdyBkYXRhIHRvIHJlbmRlciBiZWZvcmUgbWVhc3VyaW5nIGl0LlxuICAgICAgICAvLyBAYnJlYWtpbmctY2hhbmdlIDE0LjAuMCBSZW1vdmUgdW5kZWZpbmVkIGNoZWNrIG9uY2UgX25nWm9uZSBpcyByZXF1aXJlZC5cbiAgICAgICAgaWYgKHRoaXMuX25nWm9uZSAmJiBOZ1pvbmUuaXNJbkFuZ3VsYXJab25lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZS5waXBlKHRha2UoMSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RpY2t5Q29sdW1uU3R5bGVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RpY2t5Q29sdW1uU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZW50Q2hhbmdlZC5uZXh0KCk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgY29sdW1uIGRlZmluaXRpb24gdGhhdCB3YXMgbm90IGluY2x1ZGVkIGFzIHBhcnQgb2YgdGhlIGNvbnRlbnQgY2hpbGRyZW4uICovXG4gICAgYWRkQ29sdW1uRGVmKGNvbHVtbkRlZikge1xuICAgICAgICB0aGlzLl9jdXN0b21Db2x1bW5EZWZzLmFkZChjb2x1bW5EZWYpO1xuICAgIH1cbiAgICAvKiogUmVtb3ZlcyBhIGNvbHVtbiBkZWZpbml0aW9uIHRoYXQgd2FzIG5vdCBpbmNsdWRlZCBhcyBwYXJ0IG9mIHRoZSBjb250ZW50IGNoaWxkcmVuLiAqL1xuICAgIHJlbW92ZUNvbHVtbkRlZihjb2x1bW5EZWYpIHtcbiAgICAgICAgdGhpcy5fY3VzdG9tQ29sdW1uRGVmcy5kZWxldGUoY29sdW1uRGVmKTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSByb3cgZGVmaW5pdGlvbiB0aGF0IHdhcyBub3QgaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICBhZGRSb3dEZWYocm93RGVmKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbVJvd0RlZnMuYWRkKHJvd0RlZik7XG4gICAgfVxuICAgIC8qKiBSZW1vdmVzIGEgcm93IGRlZmluaXRpb24gdGhhdCB3YXMgbm90IGluY2x1ZGVkIGFzIHBhcnQgb2YgdGhlIGNvbnRlbnQgY2hpbGRyZW4uICovXG4gICAgcmVtb3ZlUm93RGVmKHJvd0RlZikge1xuICAgICAgICB0aGlzLl9jdXN0b21Sb3dEZWZzLmRlbGV0ZShyb3dEZWYpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIGhlYWRlciByb3cgZGVmaW5pdGlvbiB0aGF0IHdhcyBub3QgaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICBhZGRIZWFkZXJSb3dEZWYoaGVhZGVyUm93RGVmKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbUhlYWRlclJvd0RlZnMuYWRkKGhlYWRlclJvd0RlZik7XG4gICAgICAgIHRoaXMuX2hlYWRlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogUmVtb3ZlcyBhIGhlYWRlciByb3cgZGVmaW5pdGlvbiB0aGF0IHdhcyBub3QgaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICByZW1vdmVIZWFkZXJSb3dEZWYoaGVhZGVyUm93RGVmKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbUhlYWRlclJvd0RlZnMuZGVsZXRlKGhlYWRlclJvd0RlZik7XG4gICAgICAgIHRoaXMuX2hlYWRlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIGZvb3RlciByb3cgZGVmaW5pdGlvbiB0aGF0IHdhcyBub3QgaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICBhZGRGb290ZXJSb3dEZWYoZm9vdGVyUm93RGVmKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbUZvb3RlclJvd0RlZnMuYWRkKGZvb3RlclJvd0RlZik7XG4gICAgICAgIHRoaXMuX2Zvb3RlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogUmVtb3ZlcyBhIGZvb3RlciByb3cgZGVmaW5pdGlvbiB0aGF0IHdhcyBub3QgaW5jbHVkZWQgYXMgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICByZW1vdmVGb290ZXJSb3dEZWYoZm9vdGVyUm93RGVmKSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbUZvb3RlclJvd0RlZnMuZGVsZXRlKGZvb3RlclJvd0RlZik7XG4gICAgICAgIHRoaXMuX2Zvb3RlclJvd0RlZkNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogU2V0cyBhIG5vIGRhdGEgcm93IGRlZmluaXRpb24gdGhhdCB3YXMgbm90IGluY2x1ZGVkIGFzIGEgcGFydCBvZiB0aGUgY29udGVudCBjaGlsZHJlbi4gKi9cbiAgICBzZXROb0RhdGFSb3cobm9EYXRhUm93KSB7XG4gICAgICAgIHRoaXMuX2N1c3RvbU5vRGF0YVJvdyA9IG5vRGF0YVJvdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgaGVhZGVyIHN0aWNreSBzdHlsZXMuIEZpcnN0IHJlc2V0cyBhbGwgYXBwbGllZCBzdHlsZXMgd2l0aCByZXNwZWN0IHRvIHRoZSBjZWxsc1xuICAgICAqIHN0aWNraW5nIHRvIHRoZSB0b3AuIFRoZW4sIGV2YWx1YXRpbmcgd2hpY2ggY2VsbHMgbmVlZCB0byBiZSBzdHVjayB0byB0aGUgdG9wLiBUaGlzIGlzXG4gICAgICogYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiB0aGUgaGVhZGVyIHJvdyBjaGFuZ2VzIGl0cyBkaXNwbGF5ZWQgc2V0IG9mIGNvbHVtbnMsIG9yIGlmIGl0c1xuICAgICAqIHN0aWNreSBpbnB1dCBjaGFuZ2VzLiBNYXkgYmUgY2FsbGVkIG1hbnVhbGx5IGZvciBjYXNlcyB3aGVyZSB0aGUgY2VsbCBjb250ZW50IGNoYW5nZXMgb3V0c2lkZVxuICAgICAqIG9mIHRoZXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICB1cGRhdGVTdGlja3lIZWFkZXJSb3dTdHlsZXMoKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlclJvd3MgPSB0aGlzLl9nZXRSZW5kZXJlZFJvd3ModGhpcy5faGVhZGVyUm93T3V0bGV0KTtcbiAgICAgICAgY29uc3QgdGFibGVFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAvLyBIaWRlIHRoZSB0aGVhZCBlbGVtZW50IGlmIHRoZXJlIGFyZSBubyBoZWFkZXIgcm93cy4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc2F0aXNmeVxuICAgICAgICAvLyBvdmVyemVhbG91cyBhMTF5IGNoZWNrZXJzIHRoYXQgZmFpbCBiZWNhdXNlIHRoZSBgcm93Z3JvdXBgIGVsZW1lbnQgZG9lcyBub3QgY29udGFpblxuICAgICAgICAvLyByZXF1aXJlZCBjaGlsZCBgcm93YC5cbiAgICAgICAgY29uc3QgdGhlYWQgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGhlYWQnKTtcbiAgICAgICAgaWYgKHRoZWFkKSB7XG4gICAgICAgICAgICB0aGVhZC5zdHlsZS5kaXNwbGF5ID0gaGVhZGVyUm93cy5sZW5ndGggPyAnJyA6ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGlja3lTdGF0ZXMgPSB0aGlzLl9oZWFkZXJSb3dEZWZzLm1hcChkZWYgPT4gZGVmLnN0aWNreSk7XG4gICAgICAgIHRoaXMuX3N0aWNreVN0eWxlci5jbGVhclN0aWNreVBvc2l0aW9uaW5nKGhlYWRlclJvd3MsIFsndG9wJ10pO1xuICAgICAgICB0aGlzLl9zdGlja3lTdHlsZXIuc3RpY2tSb3dzKGhlYWRlclJvd3MsIHN0aWNreVN0YXRlcywgJ3RvcCcpO1xuICAgICAgICAvLyBSZXNldCB0aGUgZGlydHkgc3RhdGUgb2YgdGhlIHN0aWNreSBpbnB1dCBjaGFuZ2Ugc2luY2UgaXQgaGFzIGJlZW4gdXNlZC5cbiAgICAgICAgdGhpcy5faGVhZGVyUm93RGVmcy5mb3JFYWNoKGRlZiA9PiBkZWYucmVzZXRTdGlja3lDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmb290ZXIgc3RpY2t5IHN0eWxlcy4gRmlyc3QgcmVzZXRzIGFsbCBhcHBsaWVkIHN0eWxlcyB3aXRoIHJlc3BlY3QgdG8gdGhlIGNlbGxzXG4gICAgICogc3RpY2tpbmcgdG8gdGhlIGJvdHRvbS4gVGhlbiwgZXZhbHVhdGluZyB3aGljaCBjZWxscyBuZWVkIHRvIGJlIHN0dWNrIHRvIHRoZSBib3R0b20uIFRoaXMgaXNcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIHRoZSBmb290ZXIgcm93IGNoYW5nZXMgaXRzIGRpc3BsYXllZCBzZXQgb2YgY29sdW1ucywgb3IgaWYgaXRzXG4gICAgICogc3RpY2t5IGlucHV0IGNoYW5nZXMuIE1heSBiZSBjYWxsZWQgbWFudWFsbHkgZm9yIGNhc2VzIHdoZXJlIHRoZSBjZWxsIGNvbnRlbnQgY2hhbmdlcyBvdXRzaWRlXG4gICAgICogb2YgdGhlc2UgZXZlbnRzLlxuICAgICAqL1xuICAgIHVwZGF0ZVN0aWNreUZvb3RlclJvd1N0eWxlcygpIHtcbiAgICAgICAgY29uc3QgZm9vdGVyUm93cyA9IHRoaXMuX2dldFJlbmRlcmVkUm93cyh0aGlzLl9mb290ZXJSb3dPdXRsZXQpO1xuICAgICAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEhpZGUgdGhlIHRmb290IGVsZW1lbnQgaWYgdGhlcmUgYXJlIG5vIGZvb3RlciByb3dzLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzYXRpc2Z5XG4gICAgICAgIC8vIG92ZXJ6ZWFsb3VzIGExMXkgY2hlY2tlcnMgdGhhdCBmYWlsIGJlY2F1c2UgdGhlIGByb3dncm91cGAgZWxlbWVudCBkb2VzIG5vdCBjb250YWluXG4gICAgICAgIC8vIHJlcXVpcmVkIGNoaWxkIGByb3dgLlxuICAgICAgICBjb25zdCB0Zm9vdCA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Zm9vdCcpO1xuICAgICAgICBpZiAodGZvb3QpIHtcbiAgICAgICAgICAgIHRmb290LnN0eWxlLmRpc3BsYXkgPSBmb290ZXJSb3dzLmxlbmd0aCA/ICcnIDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0aWNreVN0YXRlcyA9IHRoaXMuX2Zvb3RlclJvd0RlZnMubWFwKGRlZiA9PiBkZWYuc3RpY2t5KTtcbiAgICAgICAgdGhpcy5fc3RpY2t5U3R5bGVyLmNsZWFyU3RpY2t5UG9zaXRpb25pbmcoZm9vdGVyUm93cywgWydib3R0b20nXSk7XG4gICAgICAgIHRoaXMuX3N0aWNreVN0eWxlci5zdGlja1Jvd3MoZm9vdGVyUm93cywgc3RpY2t5U3RhdGVzLCAnYm90dG9tJyk7XG4gICAgICAgIHRoaXMuX3N0aWNreVN0eWxlci51cGRhdGVTdGlja3lGb290ZXJDb250YWluZXIodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBzdGlja3lTdGF0ZXMpO1xuICAgICAgICAvLyBSZXNldCB0aGUgZGlydHkgc3RhdGUgb2YgdGhlIHN0aWNreSBpbnB1dCBjaGFuZ2Ugc2luY2UgaXQgaGFzIGJlZW4gdXNlZC5cbiAgICAgICAgdGhpcy5fZm9vdGVyUm93RGVmcy5mb3JFYWNoKGRlZiA9PiBkZWYucmVzZXRTdGlja3lDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb2x1bW4gc3RpY2t5IHN0eWxlcy4gRmlyc3QgcmVzZXRzIGFsbCBhcHBsaWVkIHN0eWxlcyB3aXRoIHJlc3BlY3QgdG8gdGhlIGNlbGxzXG4gICAgICogc3RpY2tpbmcgdG8gdGhlIGxlZnQgYW5kIHJpZ2h0LiBUaGVuIHN0aWNreSBzdHlsZXMgYXJlIGFkZGVkIGZvciB0aGUgbGVmdCBhbmQgcmlnaHQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIGNvbHVtbiBkZWZpbml0aW9ucyBmb3IgZWFjaCBjZWxsIGluIGVhY2ggcm93LiBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW5cbiAgICAgKiB0aGUgZGF0YSBzb3VyY2UgcHJvdmlkZXMgYSBuZXcgc2V0IG9mIGRhdGEgb3Igd2hlbiBhIGNvbHVtbiBkZWZpbml0aW9uIGNoYW5nZXMgaXRzIHN0aWNreVxuICAgICAqIGlucHV0LiBNYXkgYmUgY2FsbGVkIG1hbnVhbGx5IGZvciBjYXNlcyB3aGVyZSB0aGUgY2VsbCBjb250ZW50IGNoYW5nZXMgb3V0c2lkZSBvZiB0aGVzZSBldmVudHMuXG4gICAgICovXG4gICAgdXBkYXRlU3RpY2t5Q29sdW1uU3R5bGVzKCkge1xuICAgICAgICBjb25zdCBoZWFkZXJSb3dzID0gdGhpcy5fZ2V0UmVuZGVyZWRSb3dzKHRoaXMuX2hlYWRlclJvd091dGxldCk7XG4gICAgICAgIGNvbnN0IGRhdGFSb3dzID0gdGhpcy5fZ2V0UmVuZGVyZWRSb3dzKHRoaXMuX3Jvd091dGxldCk7XG4gICAgICAgIGNvbnN0IGZvb3RlclJvd3MgPSB0aGlzLl9nZXRSZW5kZXJlZFJvd3ModGhpcy5fZm9vdGVyUm93T3V0bGV0KTtcbiAgICAgICAgLy8gRm9yIHRhYmxlcyBub3QgdXNpbmcgYSBmaXhlZCBsYXlvdXQsIHRoZSBjb2x1bW4gd2lkdGhzIG1heSBjaGFuZ2Ugd2hlbiBuZXcgcm93cyBhcmUgcmVuZGVyZWQuXG4gICAgICAgIC8vIEluIGEgdGFibGUgdXNpbmcgYSBmaXhlZCBsYXlvdXQsIHJvdyBjb250ZW50IHdvbid0IGFmZmVjdCBjb2x1bW4gd2lkdGgsIHNvIHN0aWNreSBzdHlsZXNcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBiZSBjbGVhcmVkIHVubGVzcyBlaXRoZXIgdGhlIHN0aWNreSBjb2x1bW4gY29uZmlnIGNoYW5nZXMgb3Igb25lIG9mIHRoZSByb3dcbiAgICAgICAgLy8gZGVmcyBjaGFuZ2UuXG4gICAgICAgIGlmICgodGhpcy5faXNOYXRpdmVIdG1sVGFibGUgJiYgIXRoaXMuX2ZpeGVkTGF5b3V0KSB8fCB0aGlzLl9zdGlja3lDb2x1bW5TdHlsZXNOZWVkUmVzZXQpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBsZWZ0IGFuZCByaWdodCBwb3NpdGlvbmluZyBmcm9tIGFsbCBjb2x1bW5zIGluIHRoZSB0YWJsZSBhY3Jvc3MgYWxsIHJvd3Mgc2luY2VcbiAgICAgICAgICAgIC8vIHN0aWNreSBjb2x1bW5zIHNwYW4gYWNyb3NzIGFsbCB0YWJsZSBzZWN0aW9ucyAoaGVhZGVyLCBkYXRhLCBmb290ZXIpXG4gICAgICAgICAgICB0aGlzLl9zdGlja3lTdHlsZXIuY2xlYXJTdGlja3lQb3NpdGlvbmluZyhbLi4uaGVhZGVyUm93cywgLi4uZGF0YVJvd3MsIC4uLmZvb3RlclJvd3NdLCBbJ2xlZnQnLCAncmlnaHQnXSk7XG4gICAgICAgICAgICB0aGlzLl9zdGlja3lDb2x1bW5TdHlsZXNOZWVkUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgdGhlIHN0aWNreSBzdHlsZXMgZm9yIGVhY2ggaGVhZGVyIHJvdyBkZXBlbmRpbmcgb24gdGhlIGRlZidzIHN0aWNreSBzdGF0ZVxuICAgICAgICBoZWFkZXJSb3dzLmZvckVhY2goKGhlYWRlclJvdywgaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYWRkU3RpY2t5Q29sdW1uU3R5bGVzKFtoZWFkZXJSb3ddLCB0aGlzLl9oZWFkZXJSb3dEZWZzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RpY2t5IHN0eWxlcyBmb3IgZWFjaCBkYXRhIHJvdyBkZXBlbmRpbmcgb24gaXRzIGRlZidzIHN0aWNreSBzdGF0ZVxuICAgICAgICB0aGlzLl9yb3dEZWZzLmZvckVhY2gocm93RGVmID0+IHtcbiAgICAgICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSByb3dzIHJlbmRlcmVkIHdpdGggdGhpcyByb3cgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyUm93c1tpXS5yb3dEZWYgPT09IHJvd0RlZikge1xuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goZGF0YVJvd3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZFN0aWNreUNvbHVtblN0eWxlcyhyb3dzLCByb3dEZWYpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGlja3kgc3R5bGVzIGZvciBlYWNoIGZvb3RlciByb3cgZGVwZW5kaW5nIG9uIHRoZSBkZWYncyBzdGlja3kgc3RhdGVcbiAgICAgICAgZm9vdGVyUm93cy5mb3JFYWNoKChmb290ZXJSb3csIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFN0aWNreUNvbHVtblN0eWxlcyhbZm9vdGVyUm93XSwgdGhpcy5fZm9vdGVyUm93RGVmc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXNldCB0aGUgZGlydHkgc3RhdGUgb2YgdGhlIHN0aWNreSBpbnB1dCBjaGFuZ2Ugc2luY2UgaXQgaGFzIGJlZW4gdXNlZC5cbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLl9jb2x1bW5EZWZzQnlOYW1lLnZhbHVlcygpKS5mb3JFYWNoKGRlZiA9PiBkZWYucmVzZXRTdGlja3lDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgUmVuZGVyUm93IG9iamVjdHMgdG8gcmVuZGVyIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBsaXN0IG9mIGRhdGEgYW5kIGRlZmluZWRcbiAgICAgKiByb3cgZGVmaW5pdGlvbnMuIElmIHRoZSBwcmV2aW91cyBsaXN0IGFscmVhZHkgY29udGFpbmVkIGEgcGFydGljdWxhciBwYWlyLCBpdCBzaG91bGQgYmUgcmV1c2VkXG4gICAgICogc28gdGhhdCB0aGUgZGlmZmVyIGVxdWF0ZXMgdGhlaXIgcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBfZ2V0QWxsUmVuZGVyUm93cygpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyUm93cyA9IFtdO1xuICAgICAgICAvLyBTdG9yZSB0aGUgY2FjaGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuIEFueSByZS11c2VkIFJlbmRlclJvdyBvYmplY3RzIHdpbGwgYmUgbW92ZWQgaW50byB0aGVcbiAgICAgICAgLy8gbmV3IGNhY2hlIHdoaWxlIHVudXNlZCBvbmVzIGNhbiBiZSBwaWNrZWQgdXAgYnkgZ2FyYmFnZSBjb2xsZWN0aW9uLlxuICAgICAgICBjb25zdCBwcmV2Q2FjaGVkUmVuZGVyUm93cyA9IHRoaXMuX2NhY2hlZFJlbmRlclJvd3NNYXA7XG4gICAgICAgIHRoaXMuX2NhY2hlZFJlbmRlclJvd3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEZvciBlYWNoIGRhdGEgb2JqZWN0LCBnZXQgdGhlIGxpc3Qgb2Ygcm93cyB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCwgcmVwcmVzZW50ZWQgYnkgdGhlXG4gICAgICAgIC8vIHJlc3BlY3RpdmUgYFJlbmRlclJvd2Agb2JqZWN0IHdoaWNoIGlzIHRoZSBwYWlyIG9mIGBkYXRhYCBhbmQgYENka1Jvd0RlZmAuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9kYXRhW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyUm93c0ZvckRhdGEgPSB0aGlzLl9nZXRSZW5kZXJSb3dzRm9yRGF0YShkYXRhLCBpLCBwcmV2Q2FjaGVkUmVuZGVyUm93cy5nZXQoZGF0YSkpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRSZW5kZXJSb3dzTWFwLmhhcyhkYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFJlbmRlclJvd3NNYXAuc2V0KGRhdGEsIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZW5kZXJSb3dzRm9yRGF0YS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCByZW5kZXJSb3cgPSByZW5kZXJSb3dzRm9yRGF0YVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFJlbmRlclJvd3NNYXAuZ2V0KHJlbmRlclJvdy5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaGFzKHJlbmRlclJvdy5yb3dEZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmdldChyZW5kZXJSb3cucm93RGVmKS5wdXNoKHJlbmRlclJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQocmVuZGVyUm93LnJvd0RlZiwgW3JlbmRlclJvd10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW5kZXJSb3dzLnB1c2gocmVuZGVyUm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyUm93cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYFJlbmRlclJvdzxUPmAgZm9yIHRoZSBwcm92aWRlZCBkYXRhIG9iamVjdCBhbmQgYW55IGBDZGtSb3dEZWZgIG9iamVjdHMgdGhhdFxuICAgICAqIHNob3VsZCBiZSByZW5kZXJlZCBmb3IgdGhpcyBkYXRhLiBSZXVzZXMgdGhlIGNhY2hlZCBSZW5kZXJSb3cgb2JqZWN0cyBpZiB0aGV5IG1hdGNoIHRoZSBzYW1lXG4gICAgICogYChULCBDZGtSb3dEZWYpYCBwYWlyLlxuICAgICAqL1xuICAgIF9nZXRSZW5kZXJSb3dzRm9yRGF0YShkYXRhLCBkYXRhSW5kZXgsIGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHJvd0RlZnMgPSB0aGlzLl9nZXRSb3dEZWZzKGRhdGEsIGRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiByb3dEZWZzLm1hcChyb3dEZWYgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FjaGVkUmVuZGVyUm93cyA9IGNhY2hlICYmIGNhY2hlLmhhcyhyb3dEZWYpID8gY2FjaGUuZ2V0KHJvd0RlZikgOiBbXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZW5kZXJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFSb3cgPSBjYWNoZWRSZW5kZXJSb3dzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgZGF0YVJvdy5kYXRhSW5kZXggPSBkYXRhSW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFSb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCByb3dEZWYsIGRhdGFJbmRleCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFVwZGF0ZSB0aGUgbWFwIGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQncyBjb2x1bW4gZGVmaW5pdGlvbnMuICovXG4gICAgX2NhY2hlQ29sdW1uRGVmcygpIHtcbiAgICAgICAgdGhpcy5fY29sdW1uRGVmc0J5TmFtZS5jbGVhcigpO1xuICAgICAgICBjb25zdCBjb2x1bW5EZWZzID0gbWVyZ2VBcnJheUFuZFNldCh0aGlzLl9nZXRPd25EZWZzKHRoaXMuX2NvbnRlbnRDb2x1bW5EZWZzKSwgdGhpcy5fY3VzdG9tQ29sdW1uRGVmcyk7XG4gICAgICAgIGNvbHVtbkRlZnMuZm9yRWFjaChjb2x1bW5EZWYgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbHVtbkRlZnNCeU5hbWUuaGFzKGNvbHVtbkRlZi5uYW1lKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVEdXBsaWNhdGVDb2x1bW5OYW1lRXJyb3IoY29sdW1uRGVmLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY29sdW1uRGVmc0J5TmFtZS5zZXQoY29sdW1uRGVmLm5hbWUsIGNvbHVtbkRlZik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoZSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgcm93IGRlZmluaXRpb25zIHRoYXQgY2FuIGJlIHVzZWQuICovXG4gICAgX2NhY2hlUm93RGVmcygpIHtcbiAgICAgICAgdGhpcy5faGVhZGVyUm93RGVmcyA9IG1lcmdlQXJyYXlBbmRTZXQodGhpcy5fZ2V0T3duRGVmcyh0aGlzLl9jb250ZW50SGVhZGVyUm93RGVmcyksIHRoaXMuX2N1c3RvbUhlYWRlclJvd0RlZnMpO1xuICAgICAgICB0aGlzLl9mb290ZXJSb3dEZWZzID0gbWVyZ2VBcnJheUFuZFNldCh0aGlzLl9nZXRPd25EZWZzKHRoaXMuX2NvbnRlbnRGb290ZXJSb3dEZWZzKSwgdGhpcy5fY3VzdG9tRm9vdGVyUm93RGVmcyk7XG4gICAgICAgIHRoaXMuX3Jvd0RlZnMgPSBtZXJnZUFycmF5QW5kU2V0KHRoaXMuX2dldE93bkRlZnModGhpcy5fY29udGVudFJvd0RlZnMpLCB0aGlzLl9jdXN0b21Sb3dEZWZzKTtcbiAgICAgICAgLy8gQWZ0ZXIgYWxsIHJvdyBkZWZpbml0aW9ucyBhcmUgZGV0ZXJtaW5lZCwgZmluZCB0aGUgcm93IGRlZmluaXRpb24gdG8gYmUgY29uc2lkZXJlZCBkZWZhdWx0LlxuICAgICAgICBjb25zdCBkZWZhdWx0Um93RGVmcyA9IHRoaXMuX3Jvd0RlZnMuZmlsdGVyKGRlZiA9PiAhZGVmLndoZW4pO1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlUZW1wbGF0ZURhdGFSb3dzICYmXG4gICAgICAgICAgICBkZWZhdWx0Um93RGVmcy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVNdWx0aXBsZURlZmF1bHRSb3dEZWZzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZWZhdWx0Um93RGVmID0gZGVmYXVsdFJvd0RlZnNbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBoZWFkZXIsIGRhdGEsIG9yIGZvb3RlciByb3dzIGhhdmUgY2hhbmdlZCB3aGF0IGNvbHVtbnMgdGhleSB3YW50IHRvIGRpc3BsYXkgb3JcbiAgICAgKiB3aGV0aGVyIHRoZSBzdGlja3kgc3RhdGVzIGhhdmUgY2hhbmdlZCBmb3IgdGhlIGhlYWRlciBvciBmb290ZXIuIElmIHRoZXJlIGlzIGEgZGlmZiwgdGhlblxuICAgICAqIHJlLXJlbmRlciB0aGF0IHNlY3Rpb24uXG4gICAgICovXG4gICAgX3JlbmRlclVwZGF0ZWRDb2x1bW5zKCkge1xuICAgICAgICBjb25zdCBjb2x1bW5zRGlmZlJlZHVjZXIgPSAoYWNjLCBkZWYpID0+IGFjYyB8fCAhIWRlZi5nZXRDb2x1bW5zRGlmZigpO1xuICAgICAgICAvLyBGb3JjZSByZS1yZW5kZXIgZGF0YSByb3dzIGlmIHRoZSBsaXN0IG9mIGNvbHVtbiBkZWZpbml0aW9ucyBoYXZlIGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IGRhdGFDb2x1bW5zQ2hhbmdlZCA9IHRoaXMuX3Jvd0RlZnMucmVkdWNlKGNvbHVtbnNEaWZmUmVkdWNlciwgZmFsc2UpO1xuICAgICAgICBpZiAoZGF0YUNvbHVtbnNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlbmRlckRhdGFSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yY2UgcmUtcmVuZGVyIGhlYWRlci9mb290ZXIgcm93cyBpZiB0aGUgbGlzdCBvZiBjb2x1bW4gZGVmaW5pdGlvbnMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgICBjb25zdCBoZWFkZXJDb2x1bW5zQ2hhbmdlZCA9IHRoaXMuX2hlYWRlclJvd0RlZnMucmVkdWNlKGNvbHVtbnNEaWZmUmVkdWNlciwgZmFsc2UpO1xuICAgICAgICBpZiAoaGVhZGVyQ29sdW1uc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlUmVuZGVySGVhZGVyUm93cygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvb3RlckNvbHVtbnNDaGFuZ2VkID0gdGhpcy5fZm9vdGVyUm93RGVmcy5yZWR1Y2UoY29sdW1uc0RpZmZSZWR1Y2VyLCBmYWxzZSk7XG4gICAgICAgIGlmIChmb290ZXJDb2x1bW5zQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fZm9yY2VSZW5kZXJGb290ZXJSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFDb2x1bW5zQ2hhbmdlZCB8fCBoZWFkZXJDb2x1bW5zQ2hhbmdlZCB8fCBmb290ZXJDb2x1bW5zQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dpdGNoIHRvIHRoZSBwcm92aWRlZCBkYXRhIHNvdXJjZSBieSByZXNldHRpbmcgdGhlIGRhdGEgYW5kIHVuc3Vic2NyaWJpbmcgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIHJlbmRlciBjaGFuZ2Ugc3Vic2NyaXB0aW9uIGlmIG9uZSBleGlzdHMuIElmIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsLCBpbnRlcnByZXQgdGhpcyBieVxuICAgICAqIGNsZWFyaW5nIHRoZSByb3cgb3V0bGV0LiBPdGhlcndpc2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBuZXcgZGF0YS5cbiAgICAgKi9cbiAgICBfc3dpdGNoRGF0YVNvdXJjZShkYXRhU291cmNlKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgICAgaWYgKGlzRGF0YVNvdXJjZSh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGlzY29ubmVjdCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyBkYXRhIHNvdXJjZS5cbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlckNoYW5nZVN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDaGFuZ2VTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGFEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhRGlmZmVyLmRpZmYoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcm93T3V0bGV0LnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcbiAgICB9XG4gICAgLyoqIFNldCB1cCBhIHN1YnNjcmlwdGlvbiBmb3IgdGhlIGRhdGEgcHJvdmlkZWQgYnkgdGhlIGRhdGEgc291cmNlLiAqL1xuICAgIF9vYnNlcnZlUmVuZGVyQ2hhbmdlcygpIHtcbiAgICAgICAgLy8gSWYgbm8gZGF0YSBzb3VyY2UgaGFzIGJlZW4gc2V0LCB0aGVyZSBpcyBub3RoaW5nIHRvIG9ic2VydmUgZm9yIGNoYW5nZXMuXG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFTdHJlYW07XG4gICAgICAgIGlmIChpc0RhdGFTb3VyY2UodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgZGF0YVN0cmVhbSA9IHRoaXMuZGF0YVNvdXJjZS5jb25uZWN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JzZXJ2YWJsZSh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICBkYXRhU3RyZWFtID0gdGhpcy5kYXRhU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgZGF0YVN0cmVhbSA9IG9mKHRoaXMuZGF0YVNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFTdHJlYW0gPT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVVbmtub3duRGF0YVNvdXJjZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlU3Vic2NyaXB0aW9uID0gZGF0YVN0cmVhbVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGEgfHwgW107XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJvd3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgZXhpc3RpbmcgY29udGVudCBpbiB0aGUgaGVhZGVyIHJvdyBvdXRsZXQgYW5kIGNyZWF0ZXMgYSBuZXcgZW1iZWRkZWQgdmlld1xuICAgICAqIGluIHRoZSBvdXRsZXQgdXNpbmcgdGhlIGhlYWRlciByb3cgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBfZm9yY2VSZW5kZXJIZWFkZXJSb3dzKCkge1xuICAgICAgICAvLyBDbGVhciB0aGUgaGVhZGVyIHJvdyBvdXRsZXQgaWYgYW55IGNvbnRlbnQgZXhpc3RzLlxuICAgICAgICBpZiAodGhpcy5faGVhZGVyUm93T3V0bGV0LnZpZXdDb250YWluZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyUm93T3V0bGV0LnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkZXJSb3dEZWZzLmZvckVhY2goKGRlZiwgaSkgPT4gdGhpcy5fcmVuZGVyUm93KHRoaXMuX2hlYWRlclJvd091dGxldCwgZGVmLCBpKSk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RpY2t5SGVhZGVyUm93U3R5bGVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbnkgZXhpc3RpbmcgY29udGVudCBpbiB0aGUgZm9vdGVyIHJvdyBvdXRsZXQgYW5kIGNyZWF0ZXMgYSBuZXcgZW1iZWRkZWQgdmlld1xuICAgICAqIGluIHRoZSBvdXRsZXQgdXNpbmcgdGhlIGZvb3RlciByb3cgZGVmaW5pdGlvbi5cbiAgICAgKi9cbiAgICBfZm9yY2VSZW5kZXJGb290ZXJSb3dzKCkge1xuICAgICAgICAvLyBDbGVhciB0aGUgZm9vdGVyIHJvdyBvdXRsZXQgaWYgYW55IGNvbnRlbnQgZXhpc3RzLlxuICAgICAgICBpZiAodGhpcy5fZm9vdGVyUm93T3V0bGV0LnZpZXdDb250YWluZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZm9vdGVyUm93T3V0bGV0LnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb290ZXJSb3dEZWZzLmZvckVhY2goKGRlZiwgaSkgPT4gdGhpcy5fcmVuZGVyUm93KHRoaXMuX2Zvb3RlclJvd091dGxldCwgZGVmLCBpKSk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RpY2t5Rm9vdGVyUm93U3R5bGVzKCk7XG4gICAgfVxuICAgIC8qKiBBZGRzIHRoZSBzdGlja3kgY29sdW1uIHN0eWxlcyBmb3IgdGhlIHJvd3MgYWNjb3JkaW5nIHRvIHRoZSBjb2x1bW5zJyBzdGljayBzdGF0ZXMuICovXG4gICAgX2FkZFN0aWNreUNvbHVtblN0eWxlcyhyb3dzLCByb3dEZWYpIHtcbiAgICAgICAgY29uc3QgY29sdW1uRGVmcyA9IEFycmF5LmZyb20ocm93RGVmLmNvbHVtbnMgfHwgW10pLm1hcChjb2x1bW5OYW1lID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkRlZiA9IHRoaXMuX2NvbHVtbkRlZnNCeU5hbWUuZ2V0KGNvbHVtbk5hbWUpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW5EZWYgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXRUYWJsZVVua25vd25Db2x1bW5FcnJvcihjb2x1bW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2x1bW5EZWY7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzdGlja3lTdGFydFN0YXRlcyA9IGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiBjb2x1bW5EZWYuc3RpY2t5KTtcbiAgICAgICAgY29uc3Qgc3RpY2t5RW5kU3RhdGVzID0gY29sdW1uRGVmcy5tYXAoY29sdW1uRGVmID0+IGNvbHVtbkRlZi5zdGlja3lFbmQpO1xuICAgICAgICB0aGlzLl9zdGlja3lTdHlsZXIudXBkYXRlU3RpY2t5Q29sdW1ucyhyb3dzLCBzdGlja3lTdGFydFN0YXRlcywgc3RpY2t5RW5kU3RhdGVzLCAhdGhpcy5fZml4ZWRMYXlvdXQgfHwgdGhpcy5fZm9yY2VSZWNhbGN1bGF0ZUNlbGxXaWR0aHMpO1xuICAgIH1cbiAgICAvKiogR2V0cyB0aGUgbGlzdCBvZiByb3dzIHRoYXQgaGF2ZSBiZWVuIHJlbmRlcmVkIGluIHRoZSByb3cgb3V0bGV0LiAqL1xuICAgIF9nZXRSZW5kZXJlZFJvd3Mocm93T3V0bGV0KSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkUm93cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd091dGxldC52aWV3Q29udGFpbmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3UmVmID0gcm93T3V0bGV0LnZpZXdDb250YWluZXIuZ2V0KGkpO1xuICAgICAgICAgICAgcmVuZGVyZWRSb3dzLnB1c2godmlld1JlZi5yb290Tm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlZFJvd3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWF0Y2hpbmcgcm93IGRlZmluaXRpb25zIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoaXMgcm93IGRhdGEuIElmIHRoZXJlIGlzIG9ubHlcbiAgICAgKiBvbmUgcm93IGRlZmluaXRpb24sIGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIGZpbmQgdGhlIHJvdyBkZWZpbml0aW9ucyB0aGF0IGhhcyBhIHdoZW5cbiAgICAgKiBwcmVkaWNhdGUgdGhhdCByZXR1cm5zIHRydWUgd2l0aCB0aGUgZGF0YS4gSWYgbm9uZSByZXR1cm4gdHJ1ZSwgcmV0dXJuIHRoZSBkZWZhdWx0IHJvd1xuICAgICAqIGRlZmluaXRpb24uXG4gICAgICovXG4gICAgX2dldFJvd0RlZnMoZGF0YSwgZGF0YUluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3dEZWZzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMuX3Jvd0RlZnNbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGxldCByb3dEZWZzID0gW107XG4gICAgICAgIGlmICh0aGlzLm11bHRpVGVtcGxhdGVEYXRhUm93cykge1xuICAgICAgICAgICAgcm93RGVmcyA9IHRoaXMuX3Jvd0RlZnMuZmlsdGVyKGRlZiA9PiAhZGVmLndoZW4gfHwgZGVmLndoZW4oZGF0YUluZGV4LCBkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcm93RGVmID0gdGhpcy5fcm93RGVmcy5maW5kKGRlZiA9PiBkZWYud2hlbiAmJiBkZWYud2hlbihkYXRhSW5kZXgsIGRhdGEpKSB8fCB0aGlzLl9kZWZhdWx0Um93RGVmO1xuICAgICAgICAgICAgaWYgKHJvd0RlZikge1xuICAgICAgICAgICAgICAgIHJvd0RlZnMucHVzaChyb3dEZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcm93RGVmcy5sZW5ndGggJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IGdldFRhYmxlTWlzc2luZ01hdGNoaW5nUm93RGVmRXJyb3IoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0RlZnM7XG4gICAgfVxuICAgIF9nZXRFbWJlZGRlZFZpZXdBcmdzKHJlbmRlclJvdywgaW5kZXgpIHtcbiAgICAgICAgY29uc3Qgcm93RGVmID0gcmVuZGVyUm93LnJvd0RlZjtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgJGltcGxpY2l0OiByZW5kZXJSb3cuZGF0YSB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGVSZWY6IHJvd0RlZi50ZW1wbGF0ZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyByb3cgdGVtcGxhdGUgaW4gdGhlIG91dGxldCBhbmQgZmlsbHMgaXQgd2l0aCB0aGUgc2V0IG9mIGNlbGwgdGVtcGxhdGVzLlxuICAgICAqIE9wdGlvbmFsbHkgdGFrZXMgYSBjb250ZXh0IHRvIHByb3ZpZGUgdG8gdGhlIHJvdyBhbmQgY2VsbHMsIGFzIHdlbGwgYXMgYW4gb3B0aW9uYWwgaW5kZXhcbiAgICAgKiBvZiB3aGVyZSB0byBwbGFjZSB0aGUgbmV3IHJvdyB0ZW1wbGF0ZSBpbiB0aGUgb3V0bGV0LlxuICAgICAqL1xuICAgIF9yZW5kZXJSb3cob3V0bGV0LCByb3dEZWYsIGluZGV4LCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgLy8gVE9ETyhhbmRyZXdzZWd1aW4pOiBlbmZvcmNlIHRoYXQgb25lIG91dGxldCB3YXMgaW5zdGFudGlhdGVkIGZyb20gY3JlYXRlRW1iZWRkZWRWaWV3XG4gICAgICAgIGNvbnN0IHZpZXcgPSBvdXRsZXQudmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcocm93RGVmLnRlbXBsYXRlLCBjb250ZXh0LCBpbmRleCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckNlbGxUZW1wbGF0ZUZvckl0ZW0ocm93RGVmLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIF9yZW5kZXJDZWxsVGVtcGxhdGVGb3JJdGVtKHJvd0RlZiwgY29udGV4dCkge1xuICAgICAgICBmb3IgKGxldCBjZWxsVGVtcGxhdGUgb2YgdGhpcy5fZ2V0Q2VsbFRlbXBsYXRlcyhyb3dEZWYpKSB7XG4gICAgICAgICAgICBpZiAoQ2RrQ2VsbE91dGxldC5tb3N0UmVjZW50Q2VsbE91dGxldCkge1xuICAgICAgICAgICAgICAgIENka0NlbGxPdXRsZXQubW9zdFJlY2VudENlbGxPdXRsZXQuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KGNlbGxUZW1wbGF0ZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGluZGV4LXJlbGF0ZWQgY29udGV4dCBmb3IgZWFjaCByb3cgdG8gcmVmbGVjdCBhbnkgY2hhbmdlcyBpbiB0aGUgaW5kZXggb2YgdGhlIHJvd3MsXG4gICAgICogZS5nLiBmaXJzdC9sYXN0L2V2ZW4vb2RkLlxuICAgICAqL1xuICAgIF91cGRhdGVSb3dJbmRleENvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IHZpZXdDb250YWluZXIgPSB0aGlzLl9yb3dPdXRsZXQudmlld0NvbnRhaW5lcjtcbiAgICAgICAgZm9yIChsZXQgcmVuZGVySW5kZXggPSAwLCBjb3VudCA9IHZpZXdDb250YWluZXIubGVuZ3RoOyByZW5kZXJJbmRleCA8IGNvdW50OyByZW5kZXJJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3UmVmID0gdmlld0NvbnRhaW5lci5nZXQocmVuZGVySW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHZpZXdSZWYuY29udGV4dDtcbiAgICAgICAgICAgIGNvbnRleHQuY291bnQgPSBjb3VudDtcbiAgICAgICAgICAgIGNvbnRleHQuZmlyc3QgPSByZW5kZXJJbmRleCA9PT0gMDtcbiAgICAgICAgICAgIGNvbnRleHQubGFzdCA9IHJlbmRlckluZGV4ID09PSBjb3VudCAtIDE7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW4gPSByZW5kZXJJbmRleCAlIDIgPT09IDA7XG4gICAgICAgICAgICBjb250ZXh0Lm9kZCA9ICFjb250ZXh0LmV2ZW47XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVRlbXBsYXRlRGF0YVJvd3MpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRhdGFJbmRleCA9IHRoaXMuX3JlbmRlclJvd3NbcmVuZGVySW5kZXhdLmRhdGFJbmRleDtcbiAgICAgICAgICAgICAgICBjb250ZXh0LnJlbmRlckluZGV4ID0gcmVuZGVySW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluZGV4ID0gdGhpcy5fcmVuZGVyUm93c1tyZW5kZXJJbmRleF0uZGF0YUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBHZXRzIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgZm9yIHRoZSBwcm92aWRlZCByb3cgZGVmLiAqL1xuICAgIF9nZXRDZWxsVGVtcGxhdGVzKHJvd0RlZikge1xuICAgICAgICBpZiAoIXJvd0RlZiB8fCAhcm93RGVmLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyb3dEZWYuY29sdW1ucywgY29sdW1uSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5fY29sdW1uRGVmc0J5TmFtZS5nZXQoY29sdW1uSWQpO1xuICAgICAgICAgICAgaWYgKCFjb2x1bW4gJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXRUYWJsZVVua25vd25Db2x1bW5FcnJvcihjb2x1bW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm93RGVmLmV4dHJhY3RDZWxsVGVtcGxhdGUoY29sdW1uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIG5hdGl2ZSB0YWJsZSBzZWN0aW9ucyAoZS5nLiB0Ym9keSkgYW5kIG1vdmVzIHRoZSByb3cgb3V0bGV0cyBpbnRvIHRoZW0uICovXG4gICAgX2FwcGx5TmF0aXZlVGFibGVTZWN0aW9ucygpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBbXG4gICAgICAgICAgICB7IHRhZzogJ3RoZWFkJywgb3V0bGV0czogW3RoaXMuX2hlYWRlclJvd091dGxldF0gfSxcbiAgICAgICAgICAgIHsgdGFnOiAndGJvZHknLCBvdXRsZXRzOiBbdGhpcy5fcm93T3V0bGV0LCB0aGlzLl9ub0RhdGFSb3dPdXRsZXRdIH0sXG4gICAgICAgICAgICB7IHRhZzogJ3Rmb290Jywgb3V0bGV0czogW3RoaXMuX2Zvb3RlclJvd091dGxldF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHNlY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChzZWN0aW9uLnRhZyk7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdyb3dncm91cCcpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvdXRsZXQgb2Ygc2VjdGlvbi5vdXRsZXRzKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChvdXRsZXQuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY3VtZW50RnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGEgRG9jdW1lbnRGcmFnbWVudCBzbyB3ZSBkb24ndCBoaXQgdGhlIERPTSBvbiBlYWNoIGl0ZXJhdGlvbi5cbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JjZXMgYSByZS1yZW5kZXIgb2YgdGhlIGRhdGEgcm93cy4gU2hvdWxkIGJlIGNhbGxlZCBpbiBjYXNlcyB3aGVyZSB0aGVyZSBoYXMgYmVlbiBhbiBpbnB1dFxuICAgICAqIGNoYW5nZSB0aGF0IGFmZmVjdHMgdGhlIGV2YWx1YXRpb24gb2Ygd2hpY2ggcm93cyBzaG91bGQgYmUgcmVuZGVyZWQsIGUuZy4gdG9nZ2xpbmdcbiAgICAgKiBgbXVsdGlUZW1wbGF0ZURhdGFSb3dzYCBvciBhZGRpbmcvcmVtb3Zpbmcgcm93IGRlZmluaXRpb25zLlxuICAgICAqL1xuICAgIF9mb3JjZVJlbmRlckRhdGFSb3dzKCkge1xuICAgICAgICB0aGlzLl9kYXRhRGlmZmVyLmRpZmYoW10pO1xuICAgICAgICB0aGlzLl9yb3dPdXRsZXQudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlbmRlclJvd3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlIGhhcyBiZWVuIGEgY2hhbmdlIGluIHN0aWNreSBzdGF0ZXMgc2luY2UgbGFzdCBjaGVjayBhbmQgYXBwbGllcyB0aGUgY29ycmVjdFxuICAgICAqIHN0aWNreSBzdHlsZXMuIFNpbmNlIGNoZWNraW5nIHJlc2V0cyB0aGUgXCJkaXJ0eVwiIHN0YXRlLCB0aGlzIHNob3VsZCBvbmx5IGJlIHBlcmZvcm1lZCBvbmNlXG4gICAgICogZHVyaW5nIGEgY2hhbmdlIGRldGVjdGlvbiBhbmQgYWZ0ZXIgdGhlIGlucHV0cyBhcmUgc2V0dGxlZCAoYWZ0ZXIgY29udGVudCBjaGVjaykuXG4gICAgICovXG4gICAgX2NoZWNrU3RpY2t5U3RhdGVzKCkge1xuICAgICAgICBjb25zdCBzdGlja3lDaGVja1JlZHVjZXIgPSAoYWNjLCBkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjIHx8IGQuaGFzU3RpY2t5Q2hhbmdlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGNoZWNrIG5lZWRzIHRvIG9jY3VyIGZvciBldmVyeSBkZWZpbml0aW9uIHNpbmNlIGl0IG5vdGlmaWVzIHRoZSBkZWZpbml0aW9uXG4gICAgICAgIC8vIHRoYXQgaXQgY2FuIHJlc2V0IGl0cyBkaXJ0eSBzdGF0ZS4gVXNpbmcgYW5vdGhlciBvcGVyYXRvciBsaWtlIGBzb21lYCBtYXkgc2hvcnQtY2lyY3VpdFxuICAgICAgICAvLyByZW1haW5pbmcgZGVmaW5pdGlvbnMgYW5kIGxlYXZlIHRoZW0gaW4gYW4gdW5jaGVja2VkIHN0YXRlLlxuICAgICAgICBpZiAodGhpcy5faGVhZGVyUm93RGVmcy5yZWR1Y2Uoc3RpY2t5Q2hlY2tSZWR1Y2VyLCBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RpY2t5SGVhZGVyUm93U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2Zvb3RlclJvd0RlZnMucmVkdWNlKHN0aWNreUNoZWNrUmVkdWNlciwgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreUZvb3RlclJvd1N0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5mcm9tKHRoaXMuX2NvbHVtbkRlZnNCeU5hbWUudmFsdWVzKCkpLnJlZHVjZShzdGlja3lDaGVja1JlZHVjZXIsIGZhbHNlKSkge1xuICAgICAgICAgICAgdGhpcy5fc3RpY2t5Q29sdW1uU3R5bGVzTmVlZFJlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RpY2t5Q29sdW1uU3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgc3RpY2t5IHN0eWxlciB0aGF0IHdpbGwgYmUgdXNlZCBmb3Igc3RpY2t5IHJvd3MgYW5kIGNvbHVtbnMuIExpc3RlbnNcbiAgICAgKiBmb3IgZGlyZWN0aW9uYWxpdHkgY2hhbmdlcyBhbmQgcHJvdmlkZXMgdGhlIGxhdGVzdCBkaXJlY3Rpb24gdG8gdGhlIHN0eWxlci4gUmUtYXBwbGllcyBjb2x1bW5cbiAgICAgKiBzdGlja2luZXNzIHdoZW4gZGlyZWN0aW9uYWxpdHkgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBfc2V0dXBTdGlja3lTdHlsZXIoKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuX2RpciA/IHRoaXMuX2Rpci52YWx1ZSA6ICdsdHInO1xuICAgICAgICB0aGlzLl9zdGlja3lTdHlsZXIgPSBuZXcgU3RpY2t5U3R5bGVyKHRoaXMuX2lzTmF0aXZlSHRtbFRhYmxlLCB0aGlzLnN0aWNreUNzc0NsYXNzLCBkaXJlY3Rpb24sIHRoaXMuX2NvYWxlc2NlZFN0eWxlU2NoZWR1bGVyLCB0aGlzLl9wbGF0Zm9ybS5pc0Jyb3dzZXIsIHRoaXMubmVlZHNQb3NpdGlvblN0aWNreU9uRWxlbWVudCwgdGhpcy5fc3RpY2t5UG9zaXRpb25pbmdMaXN0ZW5lcik7XG4gICAgICAgICh0aGlzLl9kaXIgPyB0aGlzLl9kaXIuY2hhbmdlIDogb2YoKSlcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGlja3lTdHlsZXIuZGlyZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0aWNreUNvbHVtblN0eWxlcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEZpbHRlcnMgZGVmaW5pdGlvbnMgdGhhdCBiZWxvbmcgdG8gdGhpcyB0YWJsZSBmcm9tIGEgUXVlcnlMaXN0LiAqL1xuICAgIF9nZXRPd25EZWZzKGl0ZW1zKSB7XG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5fdGFibGUgfHwgaXRlbS5fdGFibGUgPT09IHRoaXMpO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBvciByZW1vdmVzIHRoZSBubyBkYXRhIHJvdywgZGVwZW5kaW5nIG9uIHdoZXRoZXIgYW55IGRhdGEgaXMgYmVpbmcgc2hvd24uICovXG4gICAgX3VwZGF0ZU5vRGF0YVJvdygpIHtcbiAgICAgICAgY29uc3Qgbm9EYXRhUm93ID0gdGhpcy5fY3VzdG9tTm9EYXRhUm93IHx8IHRoaXMuX25vRGF0YVJvdztcbiAgICAgICAgaWYgKCFub0RhdGFSb3cpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gdGhpcy5fcm93T3V0bGV0LnZpZXdDb250YWluZXIubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoc2hvdWxkU2hvdyA9PT0gdGhpcy5faXNTaG93aW5nTm9EYXRhUm93KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fbm9EYXRhUm93T3V0bGV0LnZpZXdDb250YWluZXI7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhub0RhdGFSb3cudGVtcGxhdGVSZWYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSB2aWV3LnJvb3ROb2Rlc1swXTtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBhdHRyaWJ1dGVzIGlmIHdlIGhhdmUgYSBzaW5nbGUgcm9vdCBub2RlIHNpbmNlIGl0J3MgaGFyZFxuICAgICAgICAgICAgLy8gdG8gZmlndXJlIG91dCB3aGljaCBvbmUgdG8gYWRkIGl0IHRvIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlLlxuICAgICAgICAgICAgaWYgKHZpZXcucm9vdE5vZGVzLmxlbmd0aCA9PT0gMSAmJiByb290Tm9kZT8ubm9kZVR5cGUgPT09IHRoaXMuX2RvY3VtZW50LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3ROb2RlLnNldEF0dHJpYnV0ZSgncm9sZScsICdyb3cnKTtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKG5vRGF0YVJvdy5fY29udGVudENsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1Nob3dpbmdOb0RhdGFSb3cgPSBzaG91bGRTaG93O1xuICAgIH1cbn1cbkNka1RhYmxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVGFibGUsIGRlcHM6IFt7IHRva2VuOiBpMC5JdGVyYWJsZURpZmZlcnMgfSwgeyB0b2tlbjogaTAuQ2hhbmdlRGV0ZWN0b3JSZWYgfSwgeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiAncm9sZScsIGF0dHJpYnV0ZTogdHJ1ZSB9LCB7IHRva2VuOiBpMS5EaXJlY3Rpb25hbGl0eSwgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogRE9DVU1FTlQgfSwgeyB0b2tlbjogaTIuUGxhdGZvcm0gfSwgeyB0b2tlbjogX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1kgfSwgeyB0b2tlbjogX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIgfSwgeyB0b2tlbjogaTMuVmlld3BvcnRSdWxlciB9LCB7IHRva2VuOiBTVElDS1lfUE9TSVRJT05JTkdfTElTVEVORVIsIG9wdGlvbmFsOiB0cnVlLCBza2lwU2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBpMC5OZ1pvbmUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbkNka1RhYmxlLsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgdHlwZTogQ2RrVGFibGUsIHNlbGVjdG9yOiBcImNkay10YWJsZSwgdGFibGVbY2RrLXRhYmxlXVwiLCBpbnB1dHM6IHsgdHJhY2tCeTogXCJ0cmFja0J5XCIsIGRhdGFTb3VyY2U6IFwiZGF0YVNvdXJjZVwiLCBtdWx0aVRlbXBsYXRlRGF0YVJvd3M6IFwibXVsdGlUZW1wbGF0ZURhdGFSb3dzXCIsIGZpeGVkTGF5b3V0OiBcImZpeGVkTGF5b3V0XCIgfSwgb3V0cHV0czogeyBjb250ZW50Q2hhbmdlZDogXCJjb250ZW50Q2hhbmdlZFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImNsYXNzLmNkay10YWJsZS1maXhlZC1sYXlvdXRcIjogXCJmaXhlZExheW91dFwiIH0sIGNsYXNzQXR0cmlidXRlOiBcImNkay10YWJsZVwiIH0sIHByb3ZpZGVyczogW1xuICAgICAgICB7IHByb3ZpZGU6IENES19UQUJMRSwgdXNlRXhpc3Rpbmc6IENka1RhYmxlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogX1ZJRVdfUkVQRUFURVJfU1RSQVRFR1ksIHVzZUNsYXNzOiBfRGlzcG9zZVZpZXdSZXBlYXRlclN0cmF0ZWd5IH0sXG4gICAgICAgIHsgcHJvdmlkZTogX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsIHVzZUNsYXNzOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgfSxcbiAgICAgICAgLy8gUHJldmVudCBuZXN0ZWQgdGFibGVzIGZyb20gc2VlaW5nIHRoaXMgdGFibGUncyBTdGlja3lQb3NpdGlvbmluZ0xpc3RlbmVyLlxuICAgICAgICB7IHByb3ZpZGU6IFNUSUNLWV9QT1NJVElPTklOR19MSVNURU5FUiwgdXNlVmFsdWU6IG51bGwgfSxcbiAgICBdLCBxdWVyaWVzOiBbeyBwcm9wZXJ0eU5hbWU6IFwiX25vRGF0YVJvd1wiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBDZGtOb0RhdGFSb3csIGRlc2NlbmRhbnRzOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9jb250ZW50Q29sdW1uRGVmc1wiLCBwcmVkaWNhdGU6IENka0NvbHVtbkRlZiwgZGVzY2VuZGFudHM6IHRydWUgfSwgeyBwcm9wZXJ0eU5hbWU6IFwiX2NvbnRlbnRSb3dEZWZzXCIsIHByZWRpY2F0ZTogQ2RrUm93RGVmLCBkZXNjZW5kYW50czogdHJ1ZSB9LCB7IHByb3BlcnR5TmFtZTogXCJfY29udGVudEhlYWRlclJvd0RlZnNcIiwgcHJlZGljYXRlOiBDZGtIZWFkZXJSb3dEZWYsIGRlc2NlbmRhbnRzOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9jb250ZW50Rm9vdGVyUm93RGVmc1wiLCBwcmVkaWNhdGU6IENka0Zvb3RlclJvd0RlZiwgZGVzY2VuZGFudHM6IHRydWUgfV0sIHZpZXdRdWVyaWVzOiBbeyBwcm9wZXJ0eU5hbWU6IFwiX3Jvd091dGxldFwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBEYXRhUm93T3V0bGV0LCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9oZWFkZXJSb3dPdXRsZXRcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogSGVhZGVyUm93T3V0bGV0LCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9mb290ZXJSb3dPdXRsZXRcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogRm9vdGVyUm93T3V0bGV0LCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcIl9ub0RhdGFSb3dPdXRsZXRcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogTm9EYXRhUm93T3V0bGV0LCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH1dLCBleHBvcnRBczogW1wiY2RrVGFibGVcIl0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IFwiXFxuICA8bmctY29udGVudCBzZWxlY3Q9XFxcImNhcHRpb25cXFwiPjwvbmctY29udGVudD5cXG4gIDxuZy1jb250ZW50IHNlbGVjdD1cXFwiY29sZ3JvdXAsIGNvbFxcXCI+PC9uZy1jb250ZW50PlxcbiAgPG5nLWNvbnRhaW5lciBoZWFkZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XFxuICA8bmctY29udGFpbmVyIHJvd091dGxldD48L25nLWNvbnRhaW5lcj5cXG4gIDxuZy1jb250YWluZXIgbm9EYXRhUm93T3V0bGV0PjwvbmctY29udGFpbmVyPlxcbiAgPG5nLWNvbnRhaW5lciBmb290ZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XFxuXCIsIGlzSW5saW5lOiB0cnVlLCBzdHlsZXM6IFtcIi5jZGstdGFibGUtZml4ZWQtbGF5b3V0e3RhYmxlLWxheW91dDpmaXhlZH1cIl0sIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogRGF0YVJvd091dGxldCwgc2VsZWN0b3I6IFwiW3Jvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IEhlYWRlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2hlYWRlclJvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IEZvb3RlclJvd091dGxldCwgc2VsZWN0b3I6IFwiW2Zvb3RlclJvd091dGxldF1cIiB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IE5vRGF0YVJvd091dGxldCwgc2VsZWN0b3I6IFwiW25vRGF0YVJvd091dGxldF1cIiB9XSwgY2hhbmdlRGV0ZWN0aW9uOiBpMC5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5EZWZhdWx0LCBlbmNhcHN1bGF0aW9uOiBpMC5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE1LjIuMC1yYy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2RrVGFibGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ2Nkay10YWJsZSwgdGFibGVbY2RrLXRhYmxlXScsIGV4cG9ydEFzOiAnY2RrVGFibGUnLCB0ZW1wbGF0ZTogQ0RLX1RBQkxFX1RFTVBMQVRFLCBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiAnY2RrLXRhYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdbY2xhc3MuY2RrLXRhYmxlLWZpeGVkLWxheW91dF0nOiAnZml4ZWRMYXlvdXQnLFxuICAgICAgICAgICAgICAgICAgICB9LCBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLCBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LkRlZmF1bHQsIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBDREtfVEFCTEUsIHVzZUV4aXN0aW5nOiBDZGtUYWJsZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBfVklFV19SRVBFQVRFUl9TVFJBVEVHWSwgdXNlQ2xhc3M6IF9EaXNwb3NlVmlld1JlcGVhdGVyU3RyYXRlZ3kgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsIHVzZUNsYXNzOiBfQ29hbGVzY2VkU3R5bGVTY2hlZHVsZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmVzdGVkIHRhYmxlcyBmcm9tIHNlZWluZyB0aGlzIHRhYmxlJ3MgU3RpY2t5UG9zaXRpb25pbmdMaXN0ZW5lci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogU1RJQ0tZX1BPU0lUSU9OSU5HX0xJU1RFTkVSLCB1c2VWYWx1ZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBdLCBzdHlsZXM6IFtcIi5jZGstdGFibGUtZml4ZWQtbGF5b3V0e3RhYmxlLWxheW91dDpmaXhlZH1cIl0gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5JdGVyYWJsZURpZmZlcnMgfSwgeyB0eXBlOiBpMC5DaGFuZ2VEZXRlY3RvclJlZiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogWydyb2xlJ11cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IGkxLkRpcmVjdGlvbmFsaXR5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtET0NVTUVOVF1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IGkyLlBsYXRmb3JtIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtfVklFV19SRVBFQVRFUl9TVFJBVEVHWV1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVJdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMy5WaWV3cG9ydFJ1bGVyIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1NUSUNLWV9QT1NJVElPTklOR19MSVNURU5FUl1cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IGkwLk5nWm9uZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9XSB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgdHJhY2tCeTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGRhdGFTb3VyY2U6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBtdWx0aVRlbXBsYXRlRGF0YVJvd3M6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBmaXhlZExheW91dDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGNvbnRlbnRDaGFuZ2VkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIF9yb3dPdXRsZXQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtEYXRhUm93T3V0bGV0LCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIF9oZWFkZXJSb3dPdXRsZXQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtIZWFkZXJSb3dPdXRsZXQsIHsgc3RhdGljOiB0cnVlIH1dXG4gICAgICAgICAgICB9XSwgX2Zvb3RlclJvd091dGxldDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgYXJnczogW0Zvb3RlclJvd091dGxldCwgeyBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dLCBfbm9EYXRhUm93T3V0bGV0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFZpZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbTm9EYXRhUm93T3V0bGV0LCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIF9jb250ZW50Q29sdW1uRGVmczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBDb250ZW50Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgYXJnczogW0Nka0NvbHVtbkRlZiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIF9jb250ZW50Um93RGVmczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBDb250ZW50Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgYXJnczogW0Nka1Jvd0RlZiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIF9jb250ZW50SGVhZGVyUm93RGVmczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBDb250ZW50Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgYXJnczogW0Nka0hlYWRlclJvd0RlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY2VuZGFudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9XSwgX2NvbnRlbnRGb290ZXJSb3dEZWZzOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbnRlbnRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICBhcmdzOiBbQ2RrRm9vdGVyUm93RGVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjZW5kYW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH1dLCBfbm9EYXRhUm93OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IENvbnRlbnRDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbQ2RrTm9EYXRhUm93XVxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgZ2V0cyBhIG1lcmdlZCBsaXN0IG9mIHRoZSBlbnRyaWVzIGluIGFuIGFycmF5IGFuZCB2YWx1ZXMgb2YgYSBTZXQuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5QW5kU2V0KGFycmF5LCBzZXQpIHtcbiAgICByZXR1cm4gYXJyYXkuY29uY2F0KEFycmF5LmZyb20oc2V0KSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBDb2x1bW4gdGhhdCBzaW1wbHkgc2hvd3MgdGV4dCBjb250ZW50IGZvciB0aGUgaGVhZGVyIGFuZCByb3cgY2VsbHMuIEFzc3VtZXMgdGhhdCB0aGUgdGFibGVcbiAqIGlzIHVzaW5nIHRoZSBuYXRpdmUgdGFibGUgaW1wbGVtZW50YXRpb24gKGA8dGFibGU+YCkuXG4gKlxuICogQnkgZGVmYXVsdCwgdGhlIG5hbWUgb2YgdGhpcyBjb2x1bW4gd2lsbCBiZSB0aGUgaGVhZGVyIHRleHQgYW5kIGRhdGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gKiBUaGUgaGVhZGVyIHRleHQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCB0aGUgYGhlYWRlclRleHRgIGlucHV0LiBDZWxsIHZhbHVlcyBjYW4gYmUgb3ZlcnJpZGRlbiB3aXRoXG4gKiB0aGUgYGRhdGFBY2Nlc3NvcmAgaW5wdXQuIENoYW5nZSB0aGUgdGV4dCBqdXN0aWZpY2F0aW9uIHRvIHRoZSBzdGFydCBvciBlbmQgdXNpbmcgdGhlIGBqdXN0aWZ5YFxuICogaW5wdXQuXG4gKi9cbmNsYXNzIENka1RleHRDb2x1bW4ge1xuICAgIC8qKiBDb2x1bW4gbmFtZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGNvbHVtbi4gKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKG5hbWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIC8vIFdpdGggSXZ5LCBpbnB1dHMgY2FuIGJlIGluaXRpYWxpemVkIGJlZm9yZSBzdGF0aWMgcXVlcnkgcmVzdWx0cyBhcmVcbiAgICAgICAgLy8gYXZhaWxhYmxlLiBJbiB0aGF0IGNhc2UsIHdlIGRlZmVyIHRoZSBzeW5jaHJvbml6YXRpb24gdW50aWwgXCJuZ09uSW5pdFwiIGZpcmVzLlxuICAgICAgICB0aGlzLl9zeW5jQ29sdW1uRGVmTmFtZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBgQ2RrVGV4dENvbHVtbmAgaXMgYWx3YXlzIHJlcXVpcmluZyBhIHRhYmxlLCBidXQgd2UganVzdCBhc3NlcnQgaXQgbWFudWFsbHlcbiAgICAvLyBmb3IgYmV0dGVyIGVycm9yIHJlcG9ydGluZy5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IGxpZ2h0d2VpZ2h0LXRva2Vuc1xuICAgIF90YWJsZSwgX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fdGFibGUgPSBfdGFibGU7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcbiAgICAgICAgLyoqIEFsaWdubWVudCBvZiB0aGUgY2VsbCB2YWx1ZXMuICovXG4gICAgICAgIHRoaXMuanVzdGlmeSA9ICdzdGFydCc7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX3N5bmNDb2x1bW5EZWZOYW1lKCk7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlclRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUZXh0ID0gdGhpcy5fY3JlYXRlRGVmYXVsdEhlYWRlclRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGF0YUFjY2Vzc29yKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFBY2Nlc3NvciA9XG4gICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0YUFjY2Vzc29yIHx8ICgoZGF0YSwgbmFtZSkgPT4gZGF0YVtuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RhYmxlKSB7XG4gICAgICAgICAgICAvLyBQcm92aWRlIHRoZSBjZWxsIGFuZCBoZWFkZXJDZWxsIGRpcmVjdGx5IHRvIHRoZSB0YWJsZSB3aXRoIHRoZSBzdGF0aWMgYFZpZXdDaGlsZGAgcXVlcnksXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGUgY29sdW1uRGVmIHdpbGwgbm90IHBpY2sgdXAgaXRzIGNvbnRlbnQgYnkgdGhlIHRpbWUgdGhlIHRhYmxlIGZpbmlzaGVzIGNoZWNraW5nXG4gICAgICAgICAgICAvLyBpdHMgY29udGVudCBhbmQgaW5pdGlhbGl6aW5nIHRoZSByb3dzLlxuICAgICAgICAgICAgdGhpcy5jb2x1bW5EZWYuY2VsbCA9IHRoaXMuY2VsbDtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uRGVmLmhlYWRlckNlbGwgPSB0aGlzLmhlYWRlckNlbGw7XG4gICAgICAgICAgICB0aGlzLl90YWJsZS5hZGRDb2x1bW5EZWYodGhpcy5jb2x1bW5EZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0VGFibGVUZXh0Q29sdW1uTWlzc2luZ1BhcmVudFRhYmxlRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl90YWJsZS5yZW1vdmVDb2x1bW5EZWYodGhpcy5jb2x1bW5EZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWZhdWx0IGhlYWRlciB0ZXh0LiBVc2UgdGhlIG9wdGlvbnMnIGhlYWRlciB0ZXh0IHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIGlmIG9uZVxuICAgICAqIGhhcyBiZWVuIHByb3ZpZGVkLiBPdGhlcndpc2Ugc2ltcGx5IGNhcGl0YWxpemUgdGhlIGNvbHVtbiBuYW1lLlxuICAgICAqL1xuICAgIF9jcmVhdGVEZWZhdWx0SGVhZGVyVGV4dCgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgaWYgKCFuYW1lICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXRUYWJsZVRleHRDb2x1bW5NaXNzaW5nTmFtZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgJiYgdGhpcy5fb3B0aW9ucy5kZWZhdWx0SGVhZGVyVGV4dFRyYW5zZm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZGVmYXVsdEhlYWRlclRleHRUcmFuc2Zvcm0obmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8qKiBTeW5jaHJvbml6ZXMgdGhlIGNvbHVtbiBkZWZpbml0aW9uIG5hbWUgd2l0aCB0aGUgdGV4dCBjb2x1bW4gbmFtZS4gKi9cbiAgICBfc3luY0NvbHVtbkRlZk5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRlZikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5EZWYubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNka1RleHRDb2x1bW4uybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTUuMi4wLXJjLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDZGtUZXh0Q29sdW1uLCBkZXBzOiBbeyB0b2tlbjogQ2RrVGFibGUsIG9wdGlvbmFsOiB0cnVlIH0sIHsgdG9rZW46IFRFWFRfQ09MVU1OX09QVElPTlMsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbkNka1RleHRDb2x1bW4uybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCB0eXBlOiBDZGtUZXh0Q29sdW1uLCBzZWxlY3RvcjogXCJjZGstdGV4dC1jb2x1bW5cIiwgaW5wdXRzOiB7IG5hbWU6IFwibmFtZVwiLCBoZWFkZXJUZXh0OiBcImhlYWRlclRleHRcIiwgZGF0YUFjY2Vzc29yOiBcImRhdGFBY2Nlc3NvclwiLCBqdXN0aWZ5OiBcImp1c3RpZnlcIiB9LCB2aWV3UXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcImNvbHVtbkRlZlwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBDZGtDb2x1bW5EZWYsIGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfSwgeyBwcm9wZXJ0eU5hbWU6IFwiY2VsbFwiLCBmaXJzdDogdHJ1ZSwgcHJlZGljYXRlOiBDZGtDZWxsRGVmLCBkZXNjZW5kYW50czogdHJ1ZSwgc3RhdGljOiB0cnVlIH0sIHsgcHJvcGVydHlOYW1lOiBcImhlYWRlckNlbGxcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogQ2RrSGVhZGVyQ2VsbERlZiwgZGVzY2VuZGFudHM6IHRydWUsIHN0YXRpYzogdHJ1ZSB9XSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgY2RrQ29sdW1uRGVmPlxuICAgICAgPHRoIGNkay1oZWFkZXItY2VsbCAqY2RrSGVhZGVyQ2VsbERlZiBbc3R5bGUudGV4dC1hbGlnbl09XCJqdXN0aWZ5XCI+XG4gICAgICAgIHt7aGVhZGVyVGV4dH19XG4gICAgICA8L3RoPlxuICAgICAgPHRkIGNkay1jZWxsICpjZGtDZWxsRGVmPVwibGV0IGRhdGFcIiBbc3R5bGUudGV4dC1hbGlnbl09XCJqdXN0aWZ5XCI+XG4gICAgICAgIHt7ZGF0YUFjY2Vzc29yKGRhdGEsIG5hbWUpfX1cbiAgICAgIDwvdGQ+XG4gICAgPC9uZy1jb250YWluZXI+XG4gIGAsIGlzSW5saW5lOiB0cnVlLCBkZXBlbmRlbmNpZXM6IFt7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IENka0NlbGxEZWYsIHNlbGVjdG9yOiBcIltjZGtDZWxsRGVmXVwiIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogQ2RrSGVhZGVyQ2VsbERlZiwgc2VsZWN0b3I6IFwiW2Nka0hlYWRlckNlbGxEZWZdXCIgfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBDZGtDb2x1bW5EZWYsIHNlbGVjdG9yOiBcIltjZGtDb2x1bW5EZWZdXCIsIGlucHV0czogW1wic3RpY2t5XCIsIFwiY2RrQ29sdW1uRGVmXCIsIFwic3RpY2t5RW5kXCJdIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogQ2RrQ2VsbCwgc2VsZWN0b3I6IFwiY2RrLWNlbGwsIHRkW2Nkay1jZWxsXVwiIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogQ2RrSGVhZGVyQ2VsbCwgc2VsZWN0b3I6IFwiY2RrLWhlYWRlci1jZWxsLCB0aFtjZGstaGVhZGVyLWNlbGxdXCIgfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCwgZW5jYXBzdWxhdGlvbjogaTAuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RleHRDb2x1bW4sIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2Nkay10ZXh0LWNvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBjZGtDb2x1bW5EZWY+XG4gICAgICA8dGggY2RrLWhlYWRlci1jZWxsICpjZGtIZWFkZXJDZWxsRGVmIFtzdHlsZS50ZXh0LWFsaWduXT1cImp1c3RpZnlcIj5cbiAgICAgICAge3toZWFkZXJUZXh0fX1cbiAgICAgIDwvdGg+XG4gICAgICA8dGQgY2RrLWNlbGwgKmNka0NlbGxEZWY9XCJsZXQgZGF0YVwiIFtzdHlsZS50ZXh0LWFsaWduXT1cImp1c3RpZnlcIj5cbiAgICAgICAge3tkYXRhQWNjZXNzb3IoZGF0YSwgbmFtZSl9fVxuICAgICAgPC90ZD5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCxcbiAgICAgICAgICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGRldGVjdGlvbiBpcyBpbnRlbnRpb25hbGx5IG5vdCBzZXQgdG8gT25QdXNoLiBUaGlzIGNvbXBvbmVudCdzIHRlbXBsYXRlIHdpbGwgYmUgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlIHRhYmxlIHRvIGJlIGluc2VydGVkIGludG8gaXRzIHZpZXcuIFRoaXMgaXMgcHJvYmxlbWF0aWMgd2hlbiBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bnMgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGJpbmRpbmdzIGluIHRoaXMgdGVtcGxhdGUgd2lsbCBiZSBldmFsdWF0ZWQgX2FmdGVyXyB0aGUgdGFibGUncyB2aWV3IGlzIGV2YWx1YXRlZCwgd2hpY2hcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVhbidzIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgdGFibGUncyB2aWV3IHdpbGwgbm90IGhhdmUgdGhlIHVwZGF0ZWQgdmFsdWUgKGFuZCBpbiBmYWN0IHdpbGwgY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gRXhwcmVzc2lvbkNoYW5nZWRBZnRlckl0SGFzQmVlbkNoZWNrZWRFcnJvcikuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YWxpZGF0ZS1kZWNvcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IENka1RhYmxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbVEVYVF9DT0xVTU5fT1BUSU9OU11cbiAgICAgICAgICAgICAgICB9XSB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGhlYWRlclRleHQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBkYXRhQWNjZXNzb3I6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBqdXN0aWZ5OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgY29sdW1uRGVmOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IFZpZXdDaGlsZCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbQ2RrQ29sdW1uRGVmLCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIGNlbGw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtDZGtDZWxsRGVmLCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIGhlYWRlckNlbGw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtDZGtIZWFkZXJDZWxsRGVmLCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCBFWFBPUlRFRF9ERUNMQVJBVElPTlMgPSBbXG4gICAgQ2RrVGFibGUsXG4gICAgQ2RrUm93RGVmLFxuICAgIENka0NlbGxEZWYsXG4gICAgQ2RrQ2VsbE91dGxldCxcbiAgICBDZGtIZWFkZXJDZWxsRGVmLFxuICAgIENka0Zvb3RlckNlbGxEZWYsXG4gICAgQ2RrQ29sdW1uRGVmLFxuICAgIENka0NlbGwsXG4gICAgQ2RrUm93LFxuICAgIENka0hlYWRlckNlbGwsXG4gICAgQ2RrRm9vdGVyQ2VsbCxcbiAgICBDZGtIZWFkZXJSb3csXG4gICAgQ2RrSGVhZGVyUm93RGVmLFxuICAgIENka0Zvb3RlclJvdyxcbiAgICBDZGtGb290ZXJSb3dEZWYsXG4gICAgRGF0YVJvd091dGxldCxcbiAgICBIZWFkZXJSb3dPdXRsZXQsXG4gICAgRm9vdGVyUm93T3V0bGV0LFxuICAgIENka1RleHRDb2x1bW4sXG4gICAgQ2RrTm9EYXRhUm93LFxuICAgIENka1JlY3ljbGVSb3dzLFxuICAgIE5vRGF0YVJvd091dGxldCxcbl07XG5jbGFzcyBDZGtUYWJsZU1vZHVsZSB7XG59XG5DZGtUYWJsZU1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RhYmxlTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkNka1RhYmxlTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RhYmxlTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtDZGtUYWJsZSxcbiAgICAgICAgQ2RrUm93RGVmLFxuICAgICAgICBDZGtDZWxsRGVmLFxuICAgICAgICBDZGtDZWxsT3V0bGV0LFxuICAgICAgICBDZGtIZWFkZXJDZWxsRGVmLFxuICAgICAgICBDZGtGb290ZXJDZWxsRGVmLFxuICAgICAgICBDZGtDb2x1bW5EZWYsXG4gICAgICAgIENka0NlbGwsXG4gICAgICAgIENka1JvdyxcbiAgICAgICAgQ2RrSGVhZGVyQ2VsbCxcbiAgICAgICAgQ2RrRm9vdGVyQ2VsbCxcbiAgICAgICAgQ2RrSGVhZGVyUm93LFxuICAgICAgICBDZGtIZWFkZXJSb3dEZWYsXG4gICAgICAgIENka0Zvb3RlclJvdyxcbiAgICAgICAgQ2RrRm9vdGVyUm93RGVmLFxuICAgICAgICBEYXRhUm93T3V0bGV0LFxuICAgICAgICBIZWFkZXJSb3dPdXRsZXQsXG4gICAgICAgIEZvb3RlclJvd091dGxldCxcbiAgICAgICAgQ2RrVGV4dENvbHVtbixcbiAgICAgICAgQ2RrTm9EYXRhUm93LFxuICAgICAgICBDZGtSZWN5Y2xlUm93cyxcbiAgICAgICAgTm9EYXRhUm93T3V0bGV0XSwgaW1wb3J0czogW1Njcm9sbGluZ01vZHVsZV0sIGV4cG9ydHM6IFtDZGtUYWJsZSxcbiAgICAgICAgQ2RrUm93RGVmLFxuICAgICAgICBDZGtDZWxsRGVmLFxuICAgICAgICBDZGtDZWxsT3V0bGV0LFxuICAgICAgICBDZGtIZWFkZXJDZWxsRGVmLFxuICAgICAgICBDZGtGb290ZXJDZWxsRGVmLFxuICAgICAgICBDZGtDb2x1bW5EZWYsXG4gICAgICAgIENka0NlbGwsXG4gICAgICAgIENka1JvdyxcbiAgICAgICAgQ2RrSGVhZGVyQ2VsbCxcbiAgICAgICAgQ2RrRm9vdGVyQ2VsbCxcbiAgICAgICAgQ2RrSGVhZGVyUm93LFxuICAgICAgICBDZGtIZWFkZXJSb3dEZWYsXG4gICAgICAgIENka0Zvb3RlclJvdyxcbiAgICAgICAgQ2RrRm9vdGVyUm93RGVmLFxuICAgICAgICBEYXRhUm93T3V0bGV0LFxuICAgICAgICBIZWFkZXJSb3dPdXRsZXQsXG4gICAgICAgIEZvb3RlclJvd091dGxldCxcbiAgICAgICAgQ2RrVGV4dENvbHVtbixcbiAgICAgICAgQ2RrTm9EYXRhUm93LFxuICAgICAgICBDZGtSZWN5Y2xlUm93cyxcbiAgICAgICAgTm9EYXRhUm93T3V0bGV0XSB9KTtcbkNka1RhYmxlTW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RhYmxlTW9kdWxlLCBpbXBvcnRzOiBbU2Nyb2xsaW5nTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNS4yLjAtcmMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENka1RhYmxlTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBFWFBPUlRFRF9ERUNMQVJBVElPTlMsXG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogRVhQT1JURURfREVDTEFSQVRJT05TLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbU2Nyb2xsaW5nTW9kdWxlXSxcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEJhc2VDZGtDZWxsLCBCYXNlUm93RGVmLCBDREtfUk9XX1RFTVBMQVRFLCBDREtfVEFCTEUsIENES19UQUJMRV9URU1QTEFURSwgQ2RrQ2VsbCwgQ2RrQ2VsbERlZiwgQ2RrQ2VsbE91dGxldCwgQ2RrQ29sdW1uRGVmLCBDZGtGb290ZXJDZWxsLCBDZGtGb290ZXJDZWxsRGVmLCBDZGtGb290ZXJSb3csIENka0Zvb3RlclJvd0RlZiwgQ2RrSGVhZGVyQ2VsbCwgQ2RrSGVhZGVyQ2VsbERlZiwgQ2RrSGVhZGVyUm93LCBDZGtIZWFkZXJSb3dEZWYsIENka05vRGF0YVJvdywgQ2RrUmVjeWNsZVJvd3MsIENka1JvdywgQ2RrUm93RGVmLCBDZGtUYWJsZSwgQ2RrVGFibGVNb2R1bGUsIENka1RleHRDb2x1bW4sIERhdGFSb3dPdXRsZXQsIEZvb3RlclJvd091dGxldCwgSGVhZGVyUm93T3V0bGV0LCBOb0RhdGFSb3dPdXRsZXQsIFNUSUNLWV9ESVJFQ1RJT05TLCBTVElDS1lfUE9TSVRJT05JTkdfTElTVEVORVIsIFN0aWNreVN0eWxlciwgVEVYVF9DT0xVTU5fT1BUSU9OUywgX0NPQUxFU0NFRF9TVFlMRV9TQ0hFRFVMRVIsIF9Db2FsZXNjZWRTdHlsZVNjaGVkdWxlciwgX1NjaGVkdWxlLCBtaXhpbkhhc1N0aWNreUlucHV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@angular/cdk/fesm2020/table.mjs\n");

/***/ })

}]);