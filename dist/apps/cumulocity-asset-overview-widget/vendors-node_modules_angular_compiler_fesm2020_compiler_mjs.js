"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_angular_compiler_fesm2020_compiler_mjs"],{

/***/ "./node_modules/@angular/compiler/fesm2020/compiler.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@angular/compiler/fesm2020/compiler.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AST\": function() { return /* binding */ AST; },\n/* harmony export */   \"ASTWithName\": function() { return /* binding */ ASTWithName; },\n/* harmony export */   \"ASTWithSource\": function() { return /* binding */ ASTWithSource; },\n/* harmony export */   \"AbsoluteSourceSpan\": function() { return /* binding */ AbsoluteSourceSpan; },\n/* harmony export */   \"ArrayType\": function() { return /* binding */ ArrayType; },\n/* harmony export */   \"AstMemoryEfficientTransformer\": function() { return /* binding */ AstMemoryEfficientTransformer; },\n/* harmony export */   \"AstTransformer\": function() { return /* binding */ AstTransformer; },\n/* harmony export */   \"Attribute\": function() { return /* binding */ Attribute; },\n/* harmony export */   \"Binary\": function() { return /* binding */ Binary; },\n/* harmony export */   \"BinaryOperator\": function() { return /* binding */ BinaryOperator; },\n/* harmony export */   \"BinaryOperatorExpr\": function() { return /* binding */ BinaryOperatorExpr; },\n/* harmony export */   \"BindingPipe\": function() { return /* binding */ BindingPipe; },\n/* harmony export */   \"BoundElementProperty\": function() { return /* binding */ BoundElementProperty; },\n/* harmony export */   \"BuiltinType\": function() { return /* binding */ BuiltinType; },\n/* harmony export */   \"BuiltinTypeName\": function() { return /* binding */ BuiltinTypeName; },\n/* harmony export */   \"CUSTOM_ELEMENTS_SCHEMA\": function() { return /* binding */ CUSTOM_ELEMENTS_SCHEMA; },\n/* harmony export */   \"Call\": function() { return /* binding */ Call; },\n/* harmony export */   \"Chain\": function() { return /* binding */ Chain; },\n/* harmony export */   \"ChangeDetectionStrategy\": function() { return /* binding */ ChangeDetectionStrategy; },\n/* harmony export */   \"CommaExpr\": function() { return /* binding */ CommaExpr; },\n/* harmony export */   \"Comment\": function() { return /* binding */ Comment; },\n/* harmony export */   \"CompilerConfig\": function() { return /* binding */ CompilerConfig; },\n/* harmony export */   \"Conditional\": function() { return /* binding */ Conditional; },\n/* harmony export */   \"ConditionalExpr\": function() { return /* binding */ ConditionalExpr; },\n/* harmony export */   \"ConstantPool\": function() { return /* binding */ ConstantPool; },\n/* harmony export */   \"CssSelector\": function() { return /* binding */ CssSelector; },\n/* harmony export */   \"DEFAULT_INTERPOLATION_CONFIG\": function() { return /* binding */ DEFAULT_INTERPOLATION_CONFIG; },\n/* harmony export */   \"DYNAMIC_TYPE\": function() { return /* binding */ DYNAMIC_TYPE; },\n/* harmony export */   \"DeclareFunctionStmt\": function() { return /* binding */ DeclareFunctionStmt; },\n/* harmony export */   \"DeclareVarStmt\": function() { return /* binding */ DeclareVarStmt; },\n/* harmony export */   \"DomElementSchemaRegistry\": function() { return /* binding */ DomElementSchemaRegistry; },\n/* harmony export */   \"EOF\": function() { return /* binding */ EOF; },\n/* harmony export */   \"Element\": function() { return /* binding */ Element; },\n/* harmony export */   \"ElementSchemaRegistry\": function() { return /* binding */ ElementSchemaRegistry; },\n/* harmony export */   \"EmitterVisitorContext\": function() { return /* binding */ EmitterVisitorContext; },\n/* harmony export */   \"EmptyExpr\": function() { return /* binding */ EmptyExpr; },\n/* harmony export */   \"Expansion\": function() { return /* binding */ Expansion; },\n/* harmony export */   \"ExpansionCase\": function() { return /* binding */ ExpansionCase; },\n/* harmony export */   \"Expression\": function() { return /* binding */ Expression; },\n/* harmony export */   \"ExpressionBinding\": function() { return /* binding */ ExpressionBinding; },\n/* harmony export */   \"ExpressionStatement\": function() { return /* binding */ ExpressionStatement; },\n/* harmony export */   \"ExpressionType\": function() { return /* binding */ ExpressionType; },\n/* harmony export */   \"ExternalExpr\": function() { return /* binding */ ExternalExpr; },\n/* harmony export */   \"ExternalReference\": function() { return /* binding */ ExternalReference; },\n/* harmony export */   \"FactoryTarget\": function() { return /* binding */ FactoryTarget$1; },\n/* harmony export */   \"FunctionExpr\": function() { return /* binding */ FunctionExpr; },\n/* harmony export */   \"HtmlParser\": function() { return /* binding */ HtmlParser; },\n/* harmony export */   \"HtmlTagDefinition\": function() { return /* binding */ HtmlTagDefinition; },\n/* harmony export */   \"I18NHtmlParser\": function() { return /* binding */ I18NHtmlParser; },\n/* harmony export */   \"IfStmt\": function() { return /* binding */ IfStmt; },\n/* harmony export */   \"ImplicitReceiver\": function() { return /* binding */ ImplicitReceiver; },\n/* harmony export */   \"InstantiateExpr\": function() { return /* binding */ InstantiateExpr; },\n/* harmony export */   \"Interpolation\": function() { return /* binding */ Interpolation; },\n/* harmony export */   \"InterpolationConfig\": function() { return /* binding */ InterpolationConfig; },\n/* harmony export */   \"InvokeFunctionExpr\": function() { return /* binding */ InvokeFunctionExpr; },\n/* harmony export */   \"JSDocComment\": function() { return /* binding */ JSDocComment; },\n/* harmony export */   \"JitEvaluator\": function() { return /* binding */ JitEvaluator; },\n/* harmony export */   \"KeyedRead\": function() { return /* binding */ KeyedRead; },\n/* harmony export */   \"KeyedWrite\": function() { return /* binding */ KeyedWrite; },\n/* harmony export */   \"LeadingComment\": function() { return /* binding */ LeadingComment; },\n/* harmony export */   \"Lexer\": function() { return /* binding */ Lexer; },\n/* harmony export */   \"LiteralArray\": function() { return /* binding */ LiteralArray; },\n/* harmony export */   \"LiteralArrayExpr\": function() { return /* binding */ LiteralArrayExpr; },\n/* harmony export */   \"LiteralExpr\": function() { return /* binding */ LiteralExpr; },\n/* harmony export */   \"LiteralMap\": function() { return /* binding */ LiteralMap; },\n/* harmony export */   \"LiteralMapExpr\": function() { return /* binding */ LiteralMapExpr; },\n/* harmony export */   \"LiteralPrimitive\": function() { return /* binding */ LiteralPrimitive; },\n/* harmony export */   \"LocalizedString\": function() { return /* binding */ LocalizedString; },\n/* harmony export */   \"MapType\": function() { return /* binding */ MapType; },\n/* harmony export */   \"MessageBundle\": function() { return /* binding */ MessageBundle; },\n/* harmony export */   \"NONE_TYPE\": function() { return /* binding */ NONE_TYPE; },\n/* harmony export */   \"NO_ERRORS_SCHEMA\": function() { return /* binding */ NO_ERRORS_SCHEMA; },\n/* harmony export */   \"NodeWithI18n\": function() { return /* binding */ NodeWithI18n; },\n/* harmony export */   \"NonNullAssert\": function() { return /* binding */ NonNullAssert; },\n/* harmony export */   \"NotExpr\": function() { return /* binding */ NotExpr; },\n/* harmony export */   \"ParseError\": function() { return /* binding */ ParseError; },\n/* harmony export */   \"ParseErrorLevel\": function() { return /* binding */ ParseErrorLevel; },\n/* harmony export */   \"ParseLocation\": function() { return /* binding */ ParseLocation; },\n/* harmony export */   \"ParseSourceFile\": function() { return /* binding */ ParseSourceFile; },\n/* harmony export */   \"ParseSourceSpan\": function() { return /* binding */ ParseSourceSpan; },\n/* harmony export */   \"ParseSpan\": function() { return /* binding */ ParseSpan; },\n/* harmony export */   \"ParseTreeResult\": function() { return /* binding */ ParseTreeResult; },\n/* harmony export */   \"ParsedEvent\": function() { return /* binding */ ParsedEvent; },\n/* harmony export */   \"ParsedProperty\": function() { return /* binding */ ParsedProperty; },\n/* harmony export */   \"ParsedPropertyType\": function() { return /* binding */ ParsedPropertyType; },\n/* harmony export */   \"ParsedVariable\": function() { return /* binding */ ParsedVariable; },\n/* harmony export */   \"Parser\": function() { return /* binding */ Parser$1; },\n/* harmony export */   \"ParserError\": function() { return /* binding */ ParserError; },\n/* harmony export */   \"PrefixNot\": function() { return /* binding */ PrefixNot; },\n/* harmony export */   \"PropertyRead\": function() { return /* binding */ PropertyRead; },\n/* harmony export */   \"PropertyWrite\": function() { return /* binding */ PropertyWrite; },\n/* harmony export */   \"R3BoundTarget\": function() { return /* binding */ R3BoundTarget; },\n/* harmony export */   \"R3Identifiers\": function() { return /* binding */ Identifiers; },\n/* harmony export */   \"R3SelectorScopeMode\": function() { return /* binding */ R3SelectorScopeMode; },\n/* harmony export */   \"R3TargetBinder\": function() { return /* binding */ R3TargetBinder; },\n/* harmony export */   \"R3TemplateDependencyKind\": function() { return /* binding */ R3TemplateDependencyKind; },\n/* harmony export */   \"ReadKeyExpr\": function() { return /* binding */ ReadKeyExpr; },\n/* harmony export */   \"ReadPropExpr\": function() { return /* binding */ ReadPropExpr; },\n/* harmony export */   \"ReadVarExpr\": function() { return /* binding */ ReadVarExpr; },\n/* harmony export */   \"RecursiveAstVisitor\": function() { return /* binding */ RecursiveAstVisitor; },\n/* harmony export */   \"RecursiveVisitor\": function() { return /* binding */ RecursiveVisitor; },\n/* harmony export */   \"ResourceLoader\": function() { return /* binding */ ResourceLoader; },\n/* harmony export */   \"ReturnStatement\": function() { return /* binding */ ReturnStatement; },\n/* harmony export */   \"STRING_TYPE\": function() { return /* binding */ STRING_TYPE; },\n/* harmony export */   \"SafeCall\": function() { return /* binding */ SafeCall; },\n/* harmony export */   \"SafeKeyedRead\": function() { return /* binding */ SafeKeyedRead; },\n/* harmony export */   \"SafePropertyRead\": function() { return /* binding */ SafePropertyRead; },\n/* harmony export */   \"SelectorContext\": function() { return /* binding */ SelectorContext; },\n/* harmony export */   \"SelectorListContext\": function() { return /* binding */ SelectorListContext; },\n/* harmony export */   \"SelectorMatcher\": function() { return /* binding */ SelectorMatcher; },\n/* harmony export */   \"Serializer\": function() { return /* binding */ Serializer; },\n/* harmony export */   \"SplitInterpolation\": function() { return /* binding */ SplitInterpolation; },\n/* harmony export */   \"Statement\": function() { return /* binding */ Statement; },\n/* harmony export */   \"StmtModifier\": function() { return /* binding */ StmtModifier; },\n/* harmony export */   \"TagContentType\": function() { return /* binding */ TagContentType; },\n/* harmony export */   \"TaggedTemplateExpr\": function() { return /* binding */ TaggedTemplateExpr; },\n/* harmony export */   \"TemplateBindingParseResult\": function() { return /* binding */ TemplateBindingParseResult; },\n/* harmony export */   \"TemplateLiteral\": function() { return /* binding */ TemplateLiteral; },\n/* harmony export */   \"TemplateLiteralElement\": function() { return /* binding */ TemplateLiteralElement; },\n/* harmony export */   \"Text\": function() { return /* binding */ Text; },\n/* harmony export */   \"ThisReceiver\": function() { return /* binding */ ThisReceiver; },\n/* harmony export */   \"TmplAstBoundAttribute\": function() { return /* binding */ BoundAttribute; },\n/* harmony export */   \"TmplAstBoundEvent\": function() { return /* binding */ BoundEvent; },\n/* harmony export */   \"TmplAstBoundText\": function() { return /* binding */ BoundText; },\n/* harmony export */   \"TmplAstContent\": function() { return /* binding */ Content; },\n/* harmony export */   \"TmplAstElement\": function() { return /* binding */ Element$1; },\n/* harmony export */   \"TmplAstIcu\": function() { return /* binding */ Icu$1; },\n/* harmony export */   \"TmplAstRecursiveVisitor\": function() { return /* binding */ RecursiveVisitor$1; },\n/* harmony export */   \"TmplAstReference\": function() { return /* binding */ Reference; },\n/* harmony export */   \"TmplAstTemplate\": function() { return /* binding */ Template; },\n/* harmony export */   \"TmplAstText\": function() { return /* binding */ Text$3; },\n/* harmony export */   \"TmplAstTextAttribute\": function() { return /* binding */ TextAttribute; },\n/* harmony export */   \"TmplAstVariable\": function() { return /* binding */ Variable; },\n/* harmony export */   \"Token\": function() { return /* binding */ Token; },\n/* harmony export */   \"TokenType\": function() { return /* binding */ TokenType; },\n/* harmony export */   \"TreeError\": function() { return /* binding */ TreeError; },\n/* harmony export */   \"Type\": function() { return /* binding */ Type; },\n/* harmony export */   \"TypeModifier\": function() { return /* binding */ TypeModifier; },\n/* harmony export */   \"TypeofExpr\": function() { return /* binding */ TypeofExpr; },\n/* harmony export */   \"Unary\": function() { return /* binding */ Unary; },\n/* harmony export */   \"UnaryOperator\": function() { return /* binding */ UnaryOperator; },\n/* harmony export */   \"UnaryOperatorExpr\": function() { return /* binding */ UnaryOperatorExpr; },\n/* harmony export */   \"VERSION\": function() { return /* binding */ VERSION; },\n/* harmony export */   \"VariableBinding\": function() { return /* binding */ VariableBinding; },\n/* harmony export */   \"Version\": function() { return /* binding */ Version; },\n/* harmony export */   \"ViewEncapsulation\": function() { return /* binding */ ViewEncapsulation; },\n/* harmony export */   \"WrappedNodeExpr\": function() { return /* binding */ WrappedNodeExpr; },\n/* harmony export */   \"WriteKeyExpr\": function() { return /* binding */ WriteKeyExpr; },\n/* harmony export */   \"WritePropExpr\": function() { return /* binding */ WritePropExpr; },\n/* harmony export */   \"WriteVarExpr\": function() { return /* binding */ WriteVarExpr; },\n/* harmony export */   \"Xliff\": function() { return /* binding */ Xliff; },\n/* harmony export */   \"Xliff2\": function() { return /* binding */ Xliff2; },\n/* harmony export */   \"Xmb\": function() { return /* binding */ Xmb; },\n/* harmony export */   \"XmlParser\": function() { return /* binding */ XmlParser; },\n/* harmony export */   \"Xtb\": function() { return /* binding */ Xtb; },\n/* harmony export */   \"_ParseAST\": function() { return /* binding */ _ParseAST; },\n/* harmony export */   \"compileClassMetadata\": function() { return /* binding */ compileClassMetadata; },\n/* harmony export */   \"compileComponentFromMetadata\": function() { return /* binding */ compileComponentFromMetadata; },\n/* harmony export */   \"compileDeclareClassMetadata\": function() { return /* binding */ compileDeclareClassMetadata; },\n/* harmony export */   \"compileDeclareComponentFromMetadata\": function() { return /* binding */ compileDeclareComponentFromMetadata; },\n/* harmony export */   \"compileDeclareDirectiveFromMetadata\": function() { return /* binding */ compileDeclareDirectiveFromMetadata; },\n/* harmony export */   \"compileDeclareFactoryFunction\": function() { return /* binding */ compileDeclareFactoryFunction; },\n/* harmony export */   \"compileDeclareInjectableFromMetadata\": function() { return /* binding */ compileDeclareInjectableFromMetadata; },\n/* harmony export */   \"compileDeclareInjectorFromMetadata\": function() { return /* binding */ compileDeclareInjectorFromMetadata; },\n/* harmony export */   \"compileDeclareNgModuleFromMetadata\": function() { return /* binding */ compileDeclareNgModuleFromMetadata; },\n/* harmony export */   \"compileDeclarePipeFromMetadata\": function() { return /* binding */ compileDeclarePipeFromMetadata; },\n/* harmony export */   \"compileDirectiveFromMetadata\": function() { return /* binding */ compileDirectiveFromMetadata; },\n/* harmony export */   \"compileFactoryFunction\": function() { return /* binding */ compileFactoryFunction; },\n/* harmony export */   \"compileInjectable\": function() { return /* binding */ compileInjectable; },\n/* harmony export */   \"compileInjector\": function() { return /* binding */ compileInjector; },\n/* harmony export */   \"compileNgModule\": function() { return /* binding */ compileNgModule; },\n/* harmony export */   \"compilePipeFromMetadata\": function() { return /* binding */ compilePipeFromMetadata; },\n/* harmony export */   \"computeMsgId\": function() { return /* binding */ computeMsgId; },\n/* harmony export */   \"core\": function() { return /* binding */ core; },\n/* harmony export */   \"createInjectableType\": function() { return /* binding */ createInjectableType; },\n/* harmony export */   \"createMayBeForwardRefExpression\": function() { return /* binding */ createMayBeForwardRefExpression; },\n/* harmony export */   \"devOnlyGuardedExpression\": function() { return /* binding */ devOnlyGuardedExpression; },\n/* harmony export */   \"emitDistinctChangesOnlyDefaultValue\": function() { return /* binding */ emitDistinctChangesOnlyDefaultValue; },\n/* harmony export */   \"getHtmlTagDefinition\": function() { return /* binding */ getHtmlTagDefinition; },\n/* harmony export */   \"getNsPrefix\": function() { return /* binding */ getNsPrefix; },\n/* harmony export */   \"getSafePropertyAccessString\": function() { return /* binding */ getSafePropertyAccessString; },\n/* harmony export */   \"identifierName\": function() { return /* binding */ identifierName; },\n/* harmony export */   \"isIdentifier\": function() { return /* binding */ isIdentifier; },\n/* harmony export */   \"isNgContainer\": function() { return /* binding */ isNgContainer; },\n/* harmony export */   \"isNgContent\": function() { return /* binding */ isNgContent; },\n/* harmony export */   \"isNgTemplate\": function() { return /* binding */ isNgTemplate; },\n/* harmony export */   \"jsDocComment\": function() { return /* binding */ jsDocComment; },\n/* harmony export */   \"leadingComment\": function() { return /* binding */ leadingComment; },\n/* harmony export */   \"literalMap\": function() { return /* binding */ literalMap; },\n/* harmony export */   \"makeBindingParser\": function() { return /* binding */ makeBindingParser; },\n/* harmony export */   \"mergeNsAndName\": function() { return /* binding */ mergeNsAndName; },\n/* harmony export */   \"outputAst\": function() { return /* binding */ output_ast; },\n/* harmony export */   \"parseHostBindings\": function() { return /* binding */ parseHostBindings; },\n/* harmony export */   \"parseTemplate\": function() { return /* binding */ parseTemplate; },\n/* harmony export */   \"preserveWhitespacesDefault\": function() { return /* binding */ preserveWhitespacesDefault; },\n/* harmony export */   \"publishFacade\": function() { return /* binding */ publishFacade; },\n/* harmony export */   \"r3JitTypeSourceSpan\": function() { return /* binding */ r3JitTypeSourceSpan; },\n/* harmony export */   \"sanitizeIdentifier\": function() { return /* binding */ sanitizeIdentifier; },\n/* harmony export */   \"splitNsName\": function() { return /* binding */ splitNsName; },\n/* harmony export */   \"verifyHostBindings\": function() { return /* binding */ verifyHostBindings; },\n/* harmony export */   \"visitAll\": function() { return /* binding */ visitAll; }\n/* harmony export */ });\n/**\n * @license Angular v15.2.7\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n    // 4: attribute; 5: attribute_string; 6: attribute_value\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n    // \"[name=\"value\"]\",\n    // \"[name='value']\"\n    '(\\\\))|' + // 7: \")\"\n    '(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nclass CssSelector {\n    constructor() {\n        this.element = null;\n        this.classNames = [];\n        /**\n         * The selectors are encoded in pairs where:\n         * - even locations are attribute names\n         * - odd locations are attribute values.\n         *\n         * Example:\n         * Selector: `[key1=value1][key2]` would parse to:\n         * ```\n         * ['key1', 'value1', 'key2', '']\n         * ```\n         */\n        this.attrs = [];\n        this.notSelectors = [];\n    }\n    static parse(selector) {\n        const results = [];\n        const _addResult = (res, cssSel) => {\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n                cssSel.attrs.length == 0) {\n                cssSel.element = '*';\n            }\n            res.push(cssSel);\n        };\n        let cssSelector = new CssSelector();\n        let match;\n        let current = cssSelector;\n        let inNot = false;\n        _SELECTOR_REGEXP.lastIndex = 0;\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\n            if (match[1 /* SelectorRegexp.NOT */]) {\n                if (inNot) {\n                    throw new Error('Nesting :not in a selector is not allowed');\n                }\n                inNot = true;\n                current = new CssSelector();\n                cssSelector.notSelectors.push(current);\n            }\n            const tag = match[2 /* SelectorRegexp.TAG */];\n            if (tag) {\n                const prefix = match[3 /* SelectorRegexp.PREFIX */];\n                if (prefix === '#') {\n                    // #hash\n                    current.addAttribute('id', tag.slice(1));\n                }\n                else if (prefix === '.') {\n                    // Class\n                    current.addClassName(tag.slice(1));\n                }\n                else {\n                    // Element\n                    current.setElement(tag);\n                }\n            }\n            const attribute = match[4 /* SelectorRegexp.ATTRIBUTE */];\n            if (attribute) {\n                current.addAttribute(current.unescapeAttribute(attribute), match[6 /* SelectorRegexp.ATTRIBUTE_VALUE */]);\n            }\n            if (match[7 /* SelectorRegexp.NOT_END */]) {\n                inNot = false;\n                current = cssSelector;\n            }\n            if (match[8 /* SelectorRegexp.SEPARATOR */]) {\n                if (inNot) {\n                    throw new Error('Multiple selectors in :not are not supported');\n                }\n                _addResult(results, cssSelector);\n                cssSelector = current = new CssSelector();\n            }\n        }\n        _addResult(results, cssSelector);\n        return results;\n    }\n    /**\n     * Unescape `\\$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * but we might want to match an attribute that contains `$`.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to unescape.\n     * @returns the unescaped string.\n     */\n    unescapeAttribute(attr) {\n        let result = '';\n        let escaping = false;\n        for (let i = 0; i < attr.length; i++) {\n            const char = attr.charAt(i);\n            if (char === '\\\\') {\n                escaping = true;\n                continue;\n            }\n            if (char === '$' && !escaping) {\n                throw new Error(`Error in attribute selector \"${attr}\". ` +\n                    `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n            }\n            escaping = false;\n            result += char;\n        }\n        return result;\n    }\n    /**\n     * Escape `$` sequences from the CSS attribute selector.\n     *\n     * This is needed because `$` can have a special meaning in CSS selectors,\n     * with this method we are escaping `$` with `\\$'.\n     * [MDN web link for more\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n     * @param attr the attribute to escape.\n     * @returns the escaped string.\n     */\n    escapeAttribute(attr) {\n        return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n    }\n    isElementSelector() {\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n            this.notSelectors.length === 0;\n    }\n    hasElementSelector() {\n        return !!this.element;\n    }\n    setElement(element = null) {\n        this.element = element;\n    }\n    getAttrs() {\n        const result = [];\n        if (this.classNames.length > 0) {\n            result.push('class', this.classNames.join(' '));\n        }\n        return result.concat(this.attrs);\n    }\n    addAttribute(name, value = '') {\n        this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n    addClassName(name) {\n        this.classNames.push(name.toLowerCase());\n    }\n    toString() {\n        let res = this.element || '';\n        if (this.classNames) {\n            this.classNames.forEach(klass => res += `.${klass}`);\n        }\n        if (this.attrs) {\n            for (let i = 0; i < this.attrs.length; i += 2) {\n                const name = this.escapeAttribute(this.attrs[i]);\n                const value = this.attrs[i + 1];\n                res += `[${name}${value ? '=' + value : ''}]`;\n            }\n        }\n        this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n        return res;\n    }\n}\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nclass SelectorMatcher {\n    constructor() {\n        this._elementMap = new Map();\n        this._elementPartialMap = new Map();\n        this._classMap = new Map();\n        this._classPartialMap = new Map();\n        this._attrValueMap = new Map();\n        this._attrValuePartialMap = new Map();\n        this._listContexts = [];\n    }\n    static createNotMatcher(notSelectors) {\n        const notMatcher = new SelectorMatcher();\n        notMatcher.addSelectables(notSelectors, null);\n        return notMatcher;\n    }\n    addSelectables(cssSelectors, callbackCtxt) {\n        let listContext = null;\n        if (cssSelectors.length > 1) {\n            listContext = new SelectorListContext(cssSelectors);\n            this._listContexts.push(listContext);\n        }\n        for (let i = 0; i < cssSelectors.length; i++) {\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n        }\n    }\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n    _addSelectable(cssSelector, callbackCtxt, listContext) {\n        let matcher = this;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n        if (element) {\n            const isTerminal = attrs.length === 0 && classNames.length === 0;\n            if (isTerminal) {\n                this._addTerminal(matcher._elementMap, element, selectable);\n            }\n            else {\n                matcher = this._addPartial(matcher._elementPartialMap, element);\n            }\n        }\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n                const className = classNames[i];\n                if (isTerminal) {\n                    this._addTerminal(matcher._classMap, className, selectable);\n                }\n                else {\n                    matcher = this._addPartial(matcher._classPartialMap, className);\n                }\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const isTerminal = i === attrs.length - 2;\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                if (isTerminal) {\n                    const terminalMap = matcher._attrValueMap;\n                    let terminalValuesMap = terminalMap.get(name);\n                    if (!terminalValuesMap) {\n                        terminalValuesMap = new Map();\n                        terminalMap.set(name, terminalValuesMap);\n                    }\n                    this._addTerminal(terminalValuesMap, value, selectable);\n                }\n                else {\n                    const partialMap = matcher._attrValuePartialMap;\n                    let partialValuesMap = partialMap.get(name);\n                    if (!partialValuesMap) {\n                        partialValuesMap = new Map();\n                        partialMap.set(name, partialValuesMap);\n                    }\n                    matcher = this._addPartial(partialValuesMap, value);\n                }\n            }\n        }\n    }\n    _addTerminal(map, name, selectable) {\n        let terminalList = map.get(name);\n        if (!terminalList) {\n            terminalList = [];\n            map.set(name, terminalList);\n        }\n        terminalList.push(selectable);\n    }\n    _addPartial(map, name) {\n        let matcher = map.get(name);\n        if (!matcher) {\n            matcher = new SelectorMatcher();\n            map.set(name, matcher);\n        }\n        return matcher;\n    }\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n    match(cssSelector, matchedCallback) {\n        let result = false;\n        const element = cssSelector.element;\n        const classNames = cssSelector.classNames;\n        const attrs = cssSelector.attrs;\n        for (let i = 0; i < this._listContexts.length; i++) {\n            this._listContexts[i].alreadyMatched = false;\n        }\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n            result;\n        if (classNames) {\n            for (let i = 0; i < classNames.length; i++) {\n                const className = classNames[i];\n                result =\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n                result =\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n                        result;\n            }\n        }\n        if (attrs) {\n            for (let i = 0; i < attrs.length; i += 2) {\n                const name = attrs[i];\n                const value = attrs[i + 1];\n                const terminalValuesMap = this._attrValueMap.get(name);\n                if (value) {\n                    result =\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n                const partialValuesMap = this._attrValuePartialMap.get(name);\n                if (value) {\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n                }\n                result =\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n            }\n        }\n        return result;\n    }\n    /** @internal */\n    _matchTerminal(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        let selectables = map.get(name) || [];\n        const starSelectables = map.get('*');\n        if (starSelectables) {\n            selectables = selectables.concat(starSelectables);\n        }\n        if (selectables.length === 0) {\n            return false;\n        }\n        let selectable;\n        let result = false;\n        for (let i = 0; i < selectables.length; i++) {\n            selectable = selectables[i];\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\n        }\n        return result;\n    }\n    /** @internal */\n    _matchPartial(map, name, cssSelector, matchedCallback) {\n        if (!map || typeof name !== 'string') {\n            return false;\n        }\n        const nestedSelector = map.get(name);\n        if (!nestedSelector) {\n            return false;\n        }\n        // TODO(perf): get rid of recursion and measure again\n        // TODO(perf): don't pass the whole selector into the recursion,\n        // but only the not processed parts\n        return nestedSelector.match(cssSelector, matchedCallback);\n    }\n}\nclass SelectorListContext {\n    constructor(selectors) {\n        this.selectors = selectors;\n        this.alreadyMatched = false;\n    }\n}\n// Store context to pass back selector and context when a selector is matched\nclass SelectorContext {\n    constructor(selector, cbContext, listContext) {\n        this.selector = selector;\n        this.cbContext = cbContext;\n        this.listContext = listContext;\n        this.notSelectors = selector.notSelectors;\n    }\n    finalize(cssSelector, callback) {\n        let result = true;\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n            const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n            result = !notMatcher.match(cssSelector, null);\n        }\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n            if (this.listContext) {\n                this.listContext.alreadyMatched = true;\n            }\n            callback(this.selector, this.cbContext);\n        }\n        return result;\n    }\n}\n\n// Attention:\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nconst emitDistinctChangesOnlyDefaultValue = true;\nvar ViewEncapsulation;\n(function (ViewEncapsulation) {\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nvar ChangeDetectionStrategy;\n(function (ChangeDetectionStrategy) {\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nconst CUSTOM_ELEMENTS_SCHEMA = {\n    name: 'custom-elements'\n};\nconst NO_ERRORS_SCHEMA = {\n    name: 'no-errors-schema'\n};\nconst Type$1 = Function;\nvar SecurityContext;\n(function (SecurityContext) {\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nvar MissingTranslationStrategy;\n(function (MissingTranslationStrategy) {\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nfunction parserSelectorToSimpleSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n        [];\n    const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n    return [elementName, ...selector.attrs, ...classes];\n}\nfunction parserSelectorToNegativeSelector(selector) {\n    const classes = selector.classNames && selector.classNames.length ?\n        [8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n        [];\n    if (selector.element) {\n        return [\n            1 /* SelectorFlags.NOT */ | 4 /* SelectorFlags.ELEMENT */, selector.element, ...selector.attrs, ...classes\n        ];\n    }\n    else if (selector.attrs.length) {\n        return [1 /* SelectorFlags.NOT */ | 2 /* SelectorFlags.ATTRIBUTE */, ...selector.attrs, ...classes];\n    }\n    else {\n        return selector.classNames && selector.classNames.length ?\n            [1 /* SelectorFlags.NOT */ | 8 /* SelectorFlags.CLASS */, ...selector.classNames] :\n            [];\n    }\n}\nfunction parserSelectorToR3Selector(selector) {\n    const positive = parserSelectorToSimpleSelector(selector);\n    const negative = selector.notSelectors && selector.notSelectors.length ?\n        selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n        [];\n    return positive.concat(...negative);\n}\nfunction parseSelectorToR3Selector(selector) {\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n    get ViewEncapsulation () { return ViewEncapsulation; },\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n    Type: Type$1,\n    get SecurityContext () { return SecurityContext; },\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\n    parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nclass BigInteger {\n    static zero() {\n        return new BigInteger([0]);\n    }\n    static one() {\n        return new BigInteger([1]);\n    }\n    /**\n     * Creates a big integer using its individual digits in little endian storage.\n     */\n    constructor(digits) {\n        this.digits = digits;\n    }\n    /**\n     * Creates a clone of this instance.\n     */\n    clone() {\n        return new BigInteger(this.digits.slice());\n    }\n    /**\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n     * `this` but instead returns a new instance, unlike `addToSelf`.\n     */\n    add(other) {\n        const result = this.clone();\n        result.addToSelf(other);\n        return result;\n    }\n    /**\n     * Adds `other` to the instance itself, thereby mutating its value.\n     */\n    addToSelf(other) {\n        const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n        let carry = 0;\n        for (let i = 0; i < maxNrOfDigits; i++) {\n            let digitSum = carry;\n            if (i < this.digits.length) {\n                digitSum += this.digits[i];\n            }\n            if (i < other.digits.length) {\n                digitSum += other.digits[i];\n            }\n            if (digitSum >= 10) {\n                this.digits[i] = digitSum - 10;\n                carry = 1;\n            }\n            else {\n                this.digits[i] = digitSum;\n                carry = 0;\n            }\n        }\n        // Apply a remaining carry if needed.\n        if (carry > 0) {\n            this.digits[maxNrOfDigits] = 1;\n        }\n    }\n    /**\n     * Builds the decimal string representation of the big integer. As this is stored in\n     * little endian, the digits are concatenated in reverse order.\n     */\n    toString() {\n        let res = '';\n        for (let i = this.digits.length - 1; i >= 0; i--) {\n            res += this.digits[i];\n        }\n        return res;\n    }\n}\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nclass BigIntForMultiplication {\n    constructor(value) {\n        this.powerOfTwos = [value];\n    }\n    /**\n     * Returns the big integer itself.\n     */\n    getValue() {\n        return this.powerOfTwos[0];\n    }\n    /**\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n     * value for `b` is represented by a storage model that is optimized for this computation.\n     *\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n     * used as exponent into the power-of-two multiplication of `b`.\n     *\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n     * algorithm unrolls into the following iterations:\n     *\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n     * -----------|------------|------|------------|------|--------\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n     *\n     * The computed product of 56154 is indeed the correct result.\n     *\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n     * power-of-two values to reduce the workload in computing those values.\n     */\n    multiplyBy(num) {\n        const product = BigInteger.zero();\n        this.multiplyByAndAddTo(num, product);\n        return product;\n    }\n    /**\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\n     * directly to the provided result big integer.\n     */\n    multiplyByAndAddTo(num, result) {\n        for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n            if (num & 1) {\n                const value = this.getMultipliedByPowerOfTwo(exponent);\n                result.addToSelf(value);\n            }\n        }\n    }\n    /**\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n     */\n    getMultipliedByPowerOfTwo(exponent) {\n        // Compute the powers up until the requested exponent, where each value is computed from its\n        // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n        // added to itself) to reach `this.number * 2^exponent`.\n        for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n            const previousPower = this.powerOfTwos[i - 1];\n            this.powerOfTwos[i] = previousPower.add(previousPower);\n        }\n        return this.powerOfTwos[exponent];\n    }\n}\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nclass BigIntExponentiation {\n    constructor(base) {\n        this.base = base;\n        this.exponents = [new BigIntForMultiplication(BigInteger.one())];\n    }\n    /**\n     * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n     * further multiplication operations.\n     */\n    toThePowerOf(exponent) {\n        // Compute the results up until the requested exponent, where every value is computed from its\n        // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n        // to reach `this.base^exponent`.\n        for (let i = this.exponents.length; i <= exponent; i++) {\n            const value = this.exponents[i - 1].multiplyBy(this.base);\n            this.exponents[i] = new BigIntForMultiplication(value);\n        }\n        return this.exponents[exponent];\n    }\n}\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder;\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nfunction digest$1(message) {\n    return message.id || computeDigest(message);\n}\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nfunction computeDigest(message) {\n    return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nfunction decimalDigest(message) {\n    return message.id || computeDecimalDigest(message);\n}\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nfunction computeDecimalDigest(message) {\n    const visitor = new _SerializerIgnoreIcuExpVisitor();\n    const parts = message.nodes.map(a => a.visit(visitor, null));\n    return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor {\n    visitText(text, context) {\n        return text.value;\n    }\n    visitContainer(container, context) {\n        return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n    }\n    visitIcu(icu, context) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n    }\n    visitTagPlaceholder(ph, context) {\n        return ph.isVoid ?\n            `<ph tag name=\"${ph.startName}\"/>` :\n            `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n    }\n    visitPlaceholder(ph, context) {\n        return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n    }\n    visitIcuPlaceholder(ph, context) {\n        return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n    }\n}\nconst serializerVisitor$1 = new _SerializerVisitor();\nfunction serializeNodes(nodes) {\n    return nodes.map(a => a.visit(serializerVisitor$1, null));\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n    visitIcu(icu, context) {\n        let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        // Do not take the expression into account\n        return `{${icu.type}, ${strCases.join(', ')}}`;\n    }\n}\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nfunction sha1(str) {\n    textEncoder ?? (textEncoder = new TextEncoder());\n    const utf8 = [...textEncoder.encode(str)];\n    const words32 = bytesToWords32(utf8, Endian.Big);\n    const len = utf8.length * 8;\n    const w = new Uint32Array(80);\n    let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\n    words32[((len + 64 >> 9) << 4) + 15] = len;\n    for (let i = 0; i < words32.length; i += 16) {\n        const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n        for (let j = 0; j < 80; j++) {\n            if (j < 16) {\n                w[j] = words32[i + j];\n            }\n            else {\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n            }\n            const fkVal = fk(j, b, c, d);\n            const f = fkVal[0];\n            const k = fkVal[1];\n            const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n            e = d;\n            d = c;\n            c = rol32(b, 30);\n            b = a;\n            a = temp;\n        }\n        a = add32(a, h0);\n        b = add32(b, h1);\n        c = add32(c, h2);\n        d = add32(d, h3);\n        e = add32(e, h4);\n    }\n    // Convert the output parts to a 160-bit hexadecimal string\n    return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value) {\n    // unsigned right shift of zero ensures an unsigned 32-bit number\n    return (value >>> 0).toString(16).padStart(8, '0');\n}\nfunction fk(index, b, c, d) {\n    if (index < 20) {\n        return [(b & c) | (~b & d), 0x5a827999];\n    }\n    if (index < 40) {\n        return [b ^ c ^ d, 0x6ed9eba1];\n    }\n    if (index < 60) {\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n    }\n    return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nfunction fingerprint(str) {\n    textEncoder ?? (textEncoder = new TextEncoder());\n    const utf8 = textEncoder.encode(str);\n    const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n    let hi = hash32(view, utf8.length, 0);\n    let lo = hash32(view, utf8.length, 102072);\n    if (hi == 0 && (lo == 0 || lo == 1)) {\n        hi = hi ^ 0x130f9bef;\n        lo = lo ^ -0x6b5f56d8;\n    }\n    return [hi, lo];\n}\nfunction computeMsgId(msg, meaning = '') {\n    let msgFingerprint = fingerprint(msg);\n    if (meaning) {\n        const meaningFingerprint = fingerprint(meaning);\n        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n    }\n    const hi = msgFingerprint[0];\n    const lo = msgFingerprint[1];\n    return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\nfunction hash32(view, length, c) {\n    let a = 0x9e3779b9, b = 0x9e3779b9;\n    let index = 0;\n    const end = length - 12;\n    for (; index <= end; index += 12) {\n        a += view.getUint32(index, true);\n        b += view.getUint32(index + 4, true);\n        c += view.getUint32(index + 8, true);\n        const res = mix(a, b, c);\n        a = res[0], b = res[1], c = res[2];\n    }\n    const remainder = length - index;\n    // the first byte of c is reserved for the length\n    c += length;\n    if (remainder >= 4) {\n        a += view.getUint32(index, true);\n        index += 4;\n        if (remainder >= 8) {\n            b += view.getUint32(index, true);\n            index += 4;\n            // Partial 32-bit word for c\n            if (remainder >= 9) {\n                c += view.getUint8(index++) << 8;\n            }\n            if (remainder >= 10) {\n                c += view.getUint8(index++) << 16;\n            }\n            if (remainder === 11) {\n                c += view.getUint8(index++) << 24;\n            }\n        }\n        else {\n            // Partial 32-bit word for b\n            if (remainder >= 5) {\n                b += view.getUint8(index++);\n            }\n            if (remainder >= 6) {\n                b += view.getUint8(index++) << 8;\n            }\n            if (remainder === 7) {\n                b += view.getUint8(index++) << 16;\n            }\n        }\n    }\n    else {\n        // Partial 32-bit word for a\n        if (remainder >= 1) {\n            a += view.getUint8(index++);\n        }\n        if (remainder >= 2) {\n            a += view.getUint8(index++) << 8;\n        }\n        if (remainder === 3) {\n            a += view.getUint8(index++) << 16;\n        }\n    }\n    return mix(a, b, c)[2];\n}\n// clang-format off\nfunction mix(a, b, c) {\n    a -= b;\n    a -= c;\n    a ^= c >>> 13;\n    b -= c;\n    b -= a;\n    b ^= a << 8;\n    c -= a;\n    c -= b;\n    c ^= b >>> 13;\n    a -= b;\n    a -= c;\n    a ^= c >>> 12;\n    b -= c;\n    b -= a;\n    b ^= a << 16;\n    c -= a;\n    c -= b;\n    c ^= b >>> 5;\n    a -= b;\n    a -= c;\n    a ^= c >>> 3;\n    b -= c;\n    b -= a;\n    b ^= a << 10;\n    c -= a;\n    c -= b;\n    c ^= b >>> 15;\n    return [a, b, c];\n}\n// clang-format on\n// Utils\nvar Endian;\n(function (Endian) {\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\nfunction add32(a, b) {\n    return add32to64(a, b)[1];\n}\nfunction add32to64(a, b) {\n    const low = (a & 0xffff) + (b & 0xffff);\n    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\nfunction add64(a, b) {\n    const ah = a[0], al = a[1];\n    const bh = b[0], bl = b[1];\n    const result = add32to64(al, bl);\n    const carry = result[0];\n    const l = result[1];\n    const h = add32(add32(ah, bh), carry);\n    return [h, l];\n}\n// Rotate a 32b number left `count` position\nfunction rol32(a, count) {\n    return (a << count) | (a >>> (32 - count));\n}\n// Rotate a 64b number left `count` position\nfunction rol64(num, count) {\n    const hi = num[0], lo = num[1];\n    const h = (hi << count) | (lo >>> (32 - count));\n    const l = (lo << count) | (hi >>> (32 - count));\n    return [h, l];\n}\nfunction bytesToWords32(bytes, endian) {\n    const size = (bytes.length + 3) >>> 2;\n    const words32 = [];\n    for (let i = 0; i < size; i++) {\n        words32[i] = wordAt(bytes, i * 4, endian);\n    }\n    return words32;\n}\nfunction byteAt(bytes, index) {\n    return index >= bytes.length ? 0 : bytes[index];\n}\nfunction wordAt(bytes, index, endian) {\n    let word = 0;\n    if (endian === Endian.Big) {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << (24 - 8 * i);\n        }\n    }\n    else {\n        for (let i = 0; i < 4; i++) {\n            word += byteAt(bytes, index + i) << 8 * i;\n        }\n    }\n    return word;\n}\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi, lo) {\n    // Encode the four bytes in lo in the lower digits of the decimal number.\n    // Note: the multiplication results in lo itself but represented by a big integer using its\n    // decimal digits.\n    const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n    // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n    // this multiplication factor is applied.\n    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n    return decimal.toString();\n}\n\n//// Types\nvar TypeModifier;\n(function (TypeModifier) {\n    TypeModifier[TypeModifier[\"None\"] = 0] = \"None\";\n    TypeModifier[TypeModifier[\"Const\"] = 1] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\nclass Type {\n    constructor(modifiers = TypeModifier.None) {\n        this.modifiers = modifiers;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n}\nvar BuiltinTypeName;\n(function (BuiltinTypeName) {\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\nclass BuiltinType extends Type {\n    constructor(name, modifiers) {\n        super(modifiers);\n        this.name = name;\n    }\n    visitType(visitor, context) {\n        return visitor.visitBuiltinType(this, context);\n    }\n}\nclass ExpressionType extends Type {\n    constructor(value, modifiers, typeParams = null) {\n        super(modifiers);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    visitType(visitor, context) {\n        return visitor.visitExpressionType(this, context);\n    }\n}\nclass ArrayType extends Type {\n    constructor(of, modifiers) {\n        super(modifiers);\n        this.of = of;\n    }\n    visitType(visitor, context) {\n        return visitor.visitArrayType(this, context);\n    }\n}\nclass MapType extends Type {\n    constructor(valueType, modifiers) {\n        super(modifiers);\n        this.valueType = valueType || null;\n    }\n    visitType(visitor, context) {\n        return visitor.visitMapType(this, context);\n    }\n}\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n///// Expressions\nvar UnaryOperator;\n(function (UnaryOperator) {\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n    UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(UnaryOperator || (UnaryOperator = {}));\nvar BinaryOperator;\n(function (BinaryOperator) {\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n    BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 16] = \"NullishCoalesce\";\n})(BinaryOperator || (BinaryOperator = {}));\nfunction nullSafeIsEquivalent(base, other) {\n    if (base == null || other == null) {\n        return base == other;\n    }\n    return base.isEquivalent(other);\n}\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n    const len = base.length;\n    if (len !== other.length) {\n        return false;\n    }\n    for (let i = 0; i < len; i++) {\n        if (!equivalentPredicate(base[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction areAllEquivalent(base, other) {\n    return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\n}\nclass Expression {\n    constructor(type, sourceSpan) {\n        this.type = type || null;\n        this.sourceSpan = sourceSpan || null;\n    }\n    prop(name, sourceSpan) {\n        return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n    key(index, type, sourceSpan) {\n        return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n    callFn(params, sourceSpan, pure) {\n        return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n    }\n    instantiate(params, type, sourceSpan) {\n        return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n    conditional(trueCase, falseCase = null, sourceSpan) {\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n    equals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n    notEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n    identical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n    notIdentical(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n    minus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n    plus(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n    divide(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n    multiply(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n    modulo(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n    and(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n    bitwiseAnd(rhs, sourceSpan, parens = true) {\n        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    }\n    or(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n    lower(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n    lowerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n    bigger(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n    biggerEquals(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n    isBlank(sourceSpan) {\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\n        // We use the typed null to allow strictNullChecks to narrow types.\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n    nullishCoalesce(rhs, sourceSpan) {\n        return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n    }\n    toStmt() {\n        return new ExpressionStatement(this, null);\n    }\n}\nclass ReadVarExpr extends Expression {\n    constructor(name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadVarExpr && this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadVarExpr(this, context);\n    }\n    set(value) {\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n}\nclass TypeofExpr extends Expression {\n    constructor(expr, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.expr = expr;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTypeofExpr(this, context);\n    }\n    isEquivalent(e) {\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    }\n    isConstant() {\n        return this.expr.isConstant();\n    }\n}\nclass WrappedNodeExpr extends Expression {\n    constructor(node, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.node = node;\n    }\n    isEquivalent(e) {\n        return e instanceof WrappedNodeExpr && this.node === e.node;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWrappedNodeExpr(this, context);\n    }\n}\nclass WriteVarExpr extends Expression {\n    constructor(name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteVarExpr(this, context);\n    }\n    toDeclStmt(type, modifiers) {\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n    toConstDecl() {\n        return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n    }\n}\nclass WriteKeyExpr extends Expression {\n    constructor(receiver, index, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWriteKeyExpr(this, context);\n    }\n}\nclass WritePropExpr extends Expression {\n    constructor(receiver, name, value, type, sourceSpan) {\n        super(type || value.type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name && this.value.isEquivalent(e.value);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitWritePropExpr(this, context);\n    }\n}\nclass InvokeFunctionExpr extends Expression {\n    constructor(fn, args, type, sourceSpan, pure = false) {\n        super(type, sourceSpan);\n        this.fn = fn;\n        this.args = args;\n        this.pure = pure;\n    }\n    isEquivalent(e) {\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInvokeFunctionExpr(this, context);\n    }\n}\nclass TaggedTemplateExpr extends Expression {\n    constructor(tag, template, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.tag = tag;\n        this.template = template;\n    }\n    isEquivalent(e) {\n        return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n            areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n            areAllEquivalent(this.template.expressions, e.template.expressions);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitTaggedTemplateExpr(this, context);\n    }\n}\nclass InstantiateExpr extends Expression {\n    constructor(classExpr, args, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.classExpr = classExpr;\n        this.args = args;\n    }\n    isEquivalent(e) {\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n            areAllEquivalent(this.args, e.args);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitInstantiateExpr(this, context);\n    }\n}\nclass LiteralExpr extends Expression {\n    constructor(value, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralExpr && this.value === e.value;\n    }\n    isConstant() {\n        return true;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralExpr(this, context);\n    }\n}\nclass TemplateLiteral {\n    constructor(elements, expressions) {\n        this.elements = elements;\n        this.expressions = expressions;\n    }\n}\nclass TemplateLiteralElement {\n    constructor(text, sourceSpan, rawText) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        // If `rawText` is not provided, try to extract the raw string from its\n        // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n        // string instead by escaping the following control sequences:\n        // - \"\\\" would otherwise indicate that the next character is a control character.\n        // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n        // indicate the end of the template literal element.\n        this.rawText =\n            rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n    }\n}\nclass LiteralPiece {\n    constructor(text, sourceSpan) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n    }\n}\nclass PlaceholderPiece {\n    /**\n     * Create a new instance of a `PlaceholderPiece`.\n     *\n     * @param text the name of this placeholder (e.g. `PH_1`).\n     * @param sourceSpan the location of this placeholder in its localized message the source code.\n     * @param associatedMessage reference to another message that this placeholder is associated with.\n     * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n     * been extracted out from the message containing the placeholder.\n     */\n    constructor(text, sourceSpan, associatedMessage) {\n        this.text = text;\n        this.sourceSpan = sourceSpan;\n        this.associatedMessage = associatedMessage;\n    }\n}\nconst MEANING_SEPARATOR$1 = '|';\nconst ID_SEPARATOR$1 = '@@';\nconst LEGACY_ID_INDICATOR = '';\nclass LocalizedString extends Expression {\n    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n        super(STRING_TYPE, sourceSpan);\n        this.metaBlock = metaBlock;\n        this.messageParts = messageParts;\n        this.placeHolderNames = placeHolderNames;\n        this.expressions = expressions;\n    }\n    isEquivalent(e) {\n        // return e instanceof LocalizedString && this.message === e.message;\n        return false;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLocalizedString(this, context);\n    }\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n    serializeI18nHead() {\n        let metaBlock = this.metaBlock.description || '';\n        if (this.metaBlock.meaning) {\n            metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR$1}${metaBlock}`;\n        }\n        if (this.metaBlock.customId) {\n            metaBlock = `${metaBlock}${ID_SEPARATOR$1}${this.metaBlock.customId}`;\n        }\n        if (this.metaBlock.legacyIds) {\n            this.metaBlock.legacyIds.forEach(legacyId => {\n                metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n            });\n        }\n        return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n    }\n    getMessagePartSourceSpan(i) {\n        return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n    }\n    getPlaceholderSourceSpan(i) {\n        return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n            this.sourceSpan;\n    }\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * The format is `:<placeholder-name>[@@<associated-id>]:`.\n     *\n     * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n     * refers.\n     *\n     * @param partIndex The index of the message part to serialize.\n     */\n    serializeI18nTemplatePart(partIndex) {\n        const placeholder = this.placeHolderNames[partIndex - 1];\n        const messagePart = this.messageParts[partIndex];\n        let metaBlock = placeholder.text;\n        if (placeholder.associatedMessage?.legacyIds.length === 0) {\n            metaBlock += `${ID_SEPARATOR$1}${computeMsgId(placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n        }\n        return createCookedRawString(metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n    }\n}\nconst escapeSlashes = (str) => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str) => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str) => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(metaBlock, messagePart, range) {\n    if (metaBlock === '') {\n        return {\n            cooked: messagePart,\n            raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n            range,\n        };\n    }\n    else {\n        return {\n            cooked: `:${metaBlock}:${messagePart}`,\n            raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n            range,\n        };\n    }\n}\nclass ExternalExpr extends Expression {\n    constructor(value, type, typeParams = null, sourceSpan) {\n        super(type, sourceSpan);\n        this.value = value;\n        this.typeParams = typeParams;\n    }\n    isEquivalent(e) {\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitExternalExpr(this, context);\n    }\n}\nclass ExternalReference {\n    constructor(moduleName, name, runtime) {\n        this.moduleName = moduleName;\n        this.name = name;\n        this.runtime = runtime;\n    }\n}\nclass ConditionalExpr extends Expression {\n    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\n        super(type || trueCase.type, sourceSpan);\n        this.condition = condition;\n        this.falseCase = falseCase;\n        this.trueCase = trueCase;\n    }\n    isEquivalent(e) {\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitConditionalExpr(this, context);\n    }\n}\nclass NotExpr extends Expression {\n    constructor(condition, sourceSpan) {\n        super(BOOL_TYPE, sourceSpan);\n        this.condition = condition;\n    }\n    isEquivalent(e) {\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitNotExpr(this, context);\n    }\n}\nclass FnParam {\n    constructor(name, type = null) {\n        this.name = name;\n        this.type = type;\n    }\n    isEquivalent(param) {\n        return this.name === param.name;\n    }\n}\nclass FunctionExpr extends Expression {\n    constructor(params, statements, type, sourceSpan, name) {\n        super(type, sourceSpan);\n        this.params = params;\n        this.statements = statements;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n            areAllEquivalent(this.statements, e.statements);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitFunctionExpr(this, context);\n    }\n    toDeclStmt(name, modifiers) {\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n}\nclass UnaryOperatorExpr extends Expression {\n    constructor(operator, expr, type, sourceSpan, parens = true) {\n        super(type || NUMBER_TYPE, sourceSpan);\n        this.operator = operator;\n        this.expr = expr;\n        this.parens = parens;\n    }\n    isEquivalent(e) {\n        return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n            this.expr.isEquivalent(e.expr);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitUnaryOperatorExpr(this, context);\n    }\n}\nclass BinaryOperatorExpr extends Expression {\n    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {\n        super(type || lhs.type, sourceSpan);\n        this.operator = operator;\n        this.rhs = rhs;\n        this.parens = parens;\n        this.lhs = lhs;\n    }\n    isEquivalent(e) {\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitBinaryOperatorExpr(this, context);\n    }\n}\nclass ReadPropExpr extends Expression {\n    constructor(receiver, name, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.name === e.name;\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadPropExpr(this, context);\n    }\n    set(value) {\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n}\nclass ReadKeyExpr extends Expression {\n    constructor(receiver, index, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.receiver = receiver;\n        this.index = index;\n    }\n    isEquivalent(e) {\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n            this.index.isEquivalent(e.index);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitReadKeyExpr(this, context);\n    }\n    set(value) {\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n}\nclass LiteralArrayExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n    }\n    isConstant() {\n        return this.entries.every(e => e.isConstant());\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralArrayExpr(this, context);\n    }\n}\nclass LiteralMapEntry {\n    constructor(key, value, quoted) {\n        this.key = key;\n        this.value = value;\n        this.quoted = quoted;\n    }\n    isEquivalent(e) {\n        return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n}\nclass LiteralMapExpr extends Expression {\n    constructor(entries, type, sourceSpan) {\n        super(type, sourceSpan);\n        this.entries = entries;\n        this.valueType = null;\n        if (type) {\n            this.valueType = type.valueType;\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n    isConstant() {\n        return this.entries.every(e => e.value.isConstant());\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitLiteralMapExpr(this, context);\n    }\n}\nclass CommaExpr extends Expression {\n    constructor(parts, sourceSpan) {\n        super(parts[parts.length - 1].type, sourceSpan);\n        this.parts = parts;\n    }\n    isEquivalent(e) {\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n    isConstant() {\n        return false;\n    }\n    visitExpression(visitor, context) {\n        return visitor.visitCommaExpr(this, context);\n    }\n}\nconst NULL_EXPR = new LiteralExpr(null, null, null);\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n//// Statements\nvar StmtModifier;\n(function (StmtModifier) {\n    StmtModifier[StmtModifier[\"None\"] = 0] = \"None\";\n    StmtModifier[StmtModifier[\"Final\"] = 1] = \"Final\";\n    StmtModifier[StmtModifier[\"Private\"] = 2] = \"Private\";\n    StmtModifier[StmtModifier[\"Exported\"] = 4] = \"Exported\";\n    StmtModifier[StmtModifier[\"Static\"] = 8] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\nclass LeadingComment {\n    constructor(text, multiline, trailingNewline) {\n        this.text = text;\n        this.multiline = multiline;\n        this.trailingNewline = trailingNewline;\n    }\n    toString() {\n        return this.multiline ? ` ${this.text} ` : this.text;\n    }\n}\nclass JSDocComment extends LeadingComment {\n    constructor(tags) {\n        super('', /* multiline */ true, /* trailingNewline */ true);\n        this.tags = tags;\n    }\n    toString() {\n        return serializeTags(this.tags);\n    }\n}\nclass Statement {\n    constructor(modifiers = StmtModifier.None, sourceSpan = null, leadingComments) {\n        this.modifiers = modifiers;\n        this.sourceSpan = sourceSpan;\n        this.leadingComments = leadingComments;\n    }\n    hasModifier(modifier) {\n        return (this.modifiers & modifier) !== 0;\n    }\n    addLeadingComment(leadingComment) {\n        this.leadingComments = this.leadingComments ?? [];\n        this.leadingComments.push(leadingComment);\n    }\n}\nclass DeclareVarStmt extends Statement {\n    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.value = value;\n        this.type = type || (value && value.type) || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareVarStmt(this, context);\n    }\n}\nclass DeclareFunctionStmt extends Statement {\n    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n        super(modifiers, sourceSpan, leadingComments);\n        this.name = name;\n        this.params = params;\n        this.statements = statements;\n        this.type = type || null;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n            areAllEquivalent(this.statements, stmt.statements);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitDeclareFunctionStmt(this, context);\n    }\n}\nclass ExpressionStatement extends Statement {\n    constructor(expr, sourceSpan, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.expr = expr;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitExpressionStmt(this, context);\n    }\n}\nclass ReturnStatement extends Statement {\n    constructor(value, sourceSpan = null, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.value = value;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitReturnStmt(this, context);\n    }\n}\nclass IfStmt extends Statement {\n    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\n        super(StmtModifier.None, sourceSpan, leadingComments);\n        this.condition = condition;\n        this.trueCase = trueCase;\n        this.falseCase = falseCase;\n    }\n    isEquivalent(stmt) {\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\n            areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n    visitStatement(visitor, context) {\n        return visitor.visitIfStmt(this, context);\n    }\n}\nclass RecursiveAstVisitor$1 {\n    visitType(ast, context) {\n        return ast;\n    }\n    visitExpression(ast, context) {\n        if (ast.type) {\n            ast.type.visitType(this, context);\n        }\n        return ast;\n    }\n    visitBuiltinType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitExpressionType(type, context) {\n        type.value.visitExpression(this, context);\n        if (type.typeParams !== null) {\n            type.typeParams.forEach(param => this.visitType(param, context));\n        }\n        return this.visitType(type, context);\n    }\n    visitArrayType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitMapType(type, context) {\n        return this.visitType(type, context);\n    }\n    visitWrappedNodeExpr(ast, context) {\n        return ast;\n    }\n    visitTypeofExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitReadVarExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitWriteVarExpr(ast, context) {\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWriteKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitWritePropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.value.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInvokeFunctionExpr(ast, context) {\n        ast.fn.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitTaggedTemplateExpr(ast, context) {\n        ast.tag.visitExpression(this, context);\n        this.visitAllExpressions(ast.template.expressions, context);\n        return this.visitExpression(ast, context);\n    }\n    visitInstantiateExpr(ast, context) {\n        ast.classExpr.visitExpression(this, context);\n        this.visitAllExpressions(ast.args, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralExpr(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitLocalizedString(ast, context) {\n        return this.visitExpression(ast, context);\n    }\n    visitExternalExpr(ast, context) {\n        if (ast.typeParams) {\n            ast.typeParams.forEach(type => type.visitType(this, context));\n        }\n        return this.visitExpression(ast, context);\n    }\n    visitConditionalExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        ast.trueCase.visitExpression(this, context);\n        ast.falseCase.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitNotExpr(ast, context) {\n        ast.condition.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitFunctionExpr(ast, context) {\n        this.visitAllStatements(ast.statements, context);\n        return this.visitExpression(ast, context);\n    }\n    visitUnaryOperatorExpr(ast, context) {\n        ast.expr.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitBinaryOperatorExpr(ast, context) {\n        ast.lhs.visitExpression(this, context);\n        ast.rhs.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadPropExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitReadKeyExpr(ast, context) {\n        ast.receiver.visitExpression(this, context);\n        ast.index.visitExpression(this, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralArrayExpr(ast, context) {\n        this.visitAllExpressions(ast.entries, context);\n        return this.visitExpression(ast, context);\n    }\n    visitLiteralMapExpr(ast, context) {\n        ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n        return this.visitExpression(ast, context);\n    }\n    visitCommaExpr(ast, context) {\n        this.visitAllExpressions(ast.parts, context);\n        return this.visitExpression(ast, context);\n    }\n    visitAllExpressions(exprs, context) {\n        exprs.forEach(expr => expr.visitExpression(this, context));\n    }\n    visitDeclareVarStmt(stmt, context) {\n        if (stmt.value) {\n            stmt.value.visitExpression(this, context);\n        }\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitDeclareFunctionStmt(stmt, context) {\n        this.visitAllStatements(stmt.statements, context);\n        if (stmt.type) {\n            stmt.type.visitType(this, context);\n        }\n        return stmt;\n    }\n    visitExpressionStmt(stmt, context) {\n        stmt.expr.visitExpression(this, context);\n        return stmt;\n    }\n    visitReturnStmt(stmt, context) {\n        stmt.value.visitExpression(this, context);\n        return stmt;\n    }\n    visitIfStmt(stmt, context) {\n        stmt.condition.visitExpression(this, context);\n        this.visitAllStatements(stmt.trueCase, context);\n        this.visitAllStatements(stmt.falseCase, context);\n        return stmt;\n    }\n    visitAllStatements(stmts, context) {\n        stmts.forEach(stmt => stmt.visitStatement(this, context));\n    }\n}\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\n    return new LeadingComment(text, multiline, trailingNewline);\n}\nfunction jsDocComment(tags = []) {\n    return new JSDocComment(tags);\n}\nfunction variable(name, type, sourceSpan) {\n    return new ReadVarExpr(name, type, sourceSpan);\n}\nfunction importExpr(id, typeParams = null, sourceSpan) {\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\nfunction importType(id, typeParams, typeModifiers) {\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\nfunction expressionType(expr, typeModifiers, typeParams) {\n    return new ExpressionType(expr, typeModifiers, typeParams);\n}\nfunction typeofExpr(expr) {\n    return new TypeofExpr(expr);\n}\nfunction literalArr(values, type, sourceSpan) {\n    return new LiteralArrayExpr(values, type, sourceSpan);\n}\nfunction literalMap(values, type = null) {\n    return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\nfunction unary(operator, expr, type, sourceSpan) {\n    return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\nfunction not(expr, sourceSpan) {\n    return new NotExpr(expr, sourceSpan);\n}\nfunction fn(params, body, type, sourceSpan, name) {\n    return new FunctionExpr(params, body, type, sourceSpan, name);\n}\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n    return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\nfunction literal(value, type, sourceSpan) {\n    return new LiteralExpr(value, type, sourceSpan);\n}\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\nfunction isNull(exp) {\n    return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag) {\n    let out = '';\n    if (tag.tagName) {\n        out += ` @${tag.tagName}`;\n    }\n    if (tag.text) {\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n        }\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\n    }\n    return out;\n}\nfunction serializeTags(tags) {\n    if (tags.length === 0)\n        return '';\n    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n        // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n        return `*${tagToString(tags[0])} `;\n    }\n    let out = '*\\n';\n    for (const tag of tags) {\n        out += ' *';\n        // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n        out += tagToString(tag).replace(/\\n/g, '\\n * ');\n        out += '\\n';\n    }\n    out += ' ';\n    return out;\n}\n\nvar output_ast = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    get TypeModifier () { return TypeModifier; },\n    Type: Type,\n    get BuiltinTypeName () { return BuiltinTypeName; },\n    BuiltinType: BuiltinType,\n    ExpressionType: ExpressionType,\n    ArrayType: ArrayType,\n    MapType: MapType,\n    DYNAMIC_TYPE: DYNAMIC_TYPE,\n    INFERRED_TYPE: INFERRED_TYPE,\n    BOOL_TYPE: BOOL_TYPE,\n    INT_TYPE: INT_TYPE,\n    NUMBER_TYPE: NUMBER_TYPE,\n    STRING_TYPE: STRING_TYPE,\n    FUNCTION_TYPE: FUNCTION_TYPE,\n    NONE_TYPE: NONE_TYPE,\n    get UnaryOperator () { return UnaryOperator; },\n    get BinaryOperator () { return BinaryOperator; },\n    nullSafeIsEquivalent: nullSafeIsEquivalent,\n    areAllEquivalent: areAllEquivalent,\n    Expression: Expression,\n    ReadVarExpr: ReadVarExpr,\n    TypeofExpr: TypeofExpr,\n    WrappedNodeExpr: WrappedNodeExpr,\n    WriteVarExpr: WriteVarExpr,\n    WriteKeyExpr: WriteKeyExpr,\n    WritePropExpr: WritePropExpr,\n    InvokeFunctionExpr: InvokeFunctionExpr,\n    TaggedTemplateExpr: TaggedTemplateExpr,\n    InstantiateExpr: InstantiateExpr,\n    LiteralExpr: LiteralExpr,\n    TemplateLiteral: TemplateLiteral,\n    TemplateLiteralElement: TemplateLiteralElement,\n    LiteralPiece: LiteralPiece,\n    PlaceholderPiece: PlaceholderPiece,\n    LocalizedString: LocalizedString,\n    ExternalExpr: ExternalExpr,\n    ExternalReference: ExternalReference,\n    ConditionalExpr: ConditionalExpr,\n    NotExpr: NotExpr,\n    FnParam: FnParam,\n    FunctionExpr: FunctionExpr,\n    UnaryOperatorExpr: UnaryOperatorExpr,\n    BinaryOperatorExpr: BinaryOperatorExpr,\n    ReadPropExpr: ReadPropExpr,\n    ReadKeyExpr: ReadKeyExpr,\n    LiteralArrayExpr: LiteralArrayExpr,\n    LiteralMapEntry: LiteralMapEntry,\n    LiteralMapExpr: LiteralMapExpr,\n    CommaExpr: CommaExpr,\n    NULL_EXPR: NULL_EXPR,\n    TYPED_NULL_EXPR: TYPED_NULL_EXPR,\n    get StmtModifier () { return StmtModifier; },\n    LeadingComment: LeadingComment,\n    JSDocComment: JSDocComment,\n    Statement: Statement,\n    DeclareVarStmt: DeclareVarStmt,\n    DeclareFunctionStmt: DeclareFunctionStmt,\n    ExpressionStatement: ExpressionStatement,\n    ReturnStatement: ReturnStatement,\n    IfStmt: IfStmt,\n    RecursiveAstVisitor: RecursiveAstVisitor$1,\n    leadingComment: leadingComment,\n    jsDocComment: jsDocComment,\n    variable: variable,\n    importExpr: importExpr,\n    importType: importType,\n    expressionType: expressionType,\n    typeofExpr: typeofExpr,\n    literalArr: literalArr,\n    literalMap: literalMap,\n    unary: unary,\n    not: not,\n    fn: fn,\n    ifStmt: ifStmt,\n    taggedTemplate: taggedTemplate,\n    literal: literal,\n    localizedString: localizedString,\n    isNull: isNull\n});\n\nconst CONSTANT_PREFIX = '_c';\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends Expression {\n    constructor(resolved) {\n        super(resolved.type);\n        this.resolved = resolved;\n        this.original = resolved;\n    }\n    visitExpression(visitor, context) {\n        if (context === KEY_CONTEXT) {\n            // When producing a key we want to traverse the constant not the\n            // variable used to refer to it.\n            return this.original.visitExpression(visitor, context);\n        }\n        else {\n            return this.resolved.visitExpression(visitor, context);\n        }\n    }\n    isEquivalent(e) {\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    }\n    isConstant() {\n        return true;\n    }\n    fixup(expression) {\n        this.resolved = expression;\n        this.shared = true;\n    }\n}\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nclass ConstantPool {\n    constructor(isClosureCompilerEnabled = false) {\n        this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n        this.statements = [];\n        this.literals = new Map();\n        this.literalFactories = new Map();\n        this.nextNameIndex = 0;\n    }\n    getConstLiteral(literal, forceShared) {\n        if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||\n            literal instanceof FixupExpression) {\n            // Do no put simple literals into the constant pool or try to produce a constant for a\n            // reference to a constant.\n            return literal;\n        }\n        const key = this.keyOf(literal);\n        let fixup = this.literals.get(key);\n        let newValue = false;\n        if (!fixup) {\n            fixup = new FixupExpression(literal);\n            this.literals.set(key, fixup);\n            newValue = true;\n        }\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n            // Replace the expression with a variable\n            const name = this.freshName();\n            let definition;\n            let usage;\n            if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n                // For string literals, Closure will **always** inline the string at\n                // **all** usages, duplicating it each time. For large strings, this\n                // unnecessarily bloats bundle size. To work around this restriction, we\n                // wrap the string in a function, and call that function for each usage.\n                // This tricks Closure into using inline logic for functions instead of\n                // string literals. Function calls are only inlined if the body is small\n                // enough to be worth it. By doing this, very large strings will be\n                // shared across multiple usages, rather than duplicating the string at\n                // each usage site.\n                //\n                // const myStr = function() { return \"very very very long string\"; };\n                // const usage1 = myStr();\n                // const usage2 = myStr();\n                definition = variable(name).set(new FunctionExpr([], // Params.\n                [\n                    // Statements.\n                    new ReturnStatement(literal),\n                ]));\n                usage = variable(name).callFn([]);\n            }\n            else {\n                // Just declare and use the variable directly, without a function call\n                // indirection. This saves a few bytes and avoids an unnecessary call.\n                definition = variable(name).set(literal);\n                usage = variable(name);\n            }\n            this.statements.push(definition.toDeclStmt(INFERRED_TYPE, StmtModifier.Final));\n            fixup.fixup(usage);\n        }\n        return fixup;\n    }\n    getLiteralFactory(literal) {\n        // Create a pure function that builds an array of a mix of constant and variable expressions\n        if (literal instanceof LiteralArrayExpr) {\n            const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n            const key = this.keyOf(literalArr(argumentsForKey));\n            return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\n        }\n        else {\n            const expressionForKey = literalMap(literal.entries.map(e => ({\n                key: e.key,\n                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                quoted: e.quoted\n            })));\n            const key = this.keyOf(expressionForKey);\n            return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\n                key: literal.entries[index].key,\n                value,\n                quoted: literal.entries[index].quoted\n            }))));\n        }\n    }\n    _getLiteralFactory(key, values, resultMap) {\n        let literalFactory = this.literalFactories.get(key);\n        const literalFactoryArguments = values.filter((e => !e.isConstant()));\n        if (!literalFactory) {\n            const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\n            const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\n            const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n            const name = this.freshName();\n            this.statements.push(variable(name)\n                .set(pureFunctionDeclaration)\n                .toDeclStmt(INFERRED_TYPE, StmtModifier.Final));\n            literalFactory = variable(name);\n            this.literalFactories.set(key, literalFactory);\n        }\n        return { literalFactory, literalFactoryArguments };\n    }\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n    uniqueName(prefix) {\n        return `${prefix}${this.nextNameIndex++}`;\n    }\n    freshName() {\n        return this.uniqueName(CONSTANT_PREFIX);\n    }\n    keyOf(expression) {\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    }\n}\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor {\n    constructor() {\n        this.visitWrappedNodeExpr = invalid$1;\n        this.visitWriteVarExpr = invalid$1;\n        this.visitWriteKeyExpr = invalid$1;\n        this.visitWritePropExpr = invalid$1;\n        this.visitInvokeFunctionExpr = invalid$1;\n        this.visitTaggedTemplateExpr = invalid$1;\n        this.visitInstantiateExpr = invalid$1;\n        this.visitConditionalExpr = invalid$1;\n        this.visitNotExpr = invalid$1;\n        this.visitAssertNotNullExpr = invalid$1;\n        this.visitCastExpr = invalid$1;\n        this.visitFunctionExpr = invalid$1;\n        this.visitUnaryOperatorExpr = invalid$1;\n        this.visitBinaryOperatorExpr = invalid$1;\n        this.visitReadPropExpr = invalid$1;\n        this.visitReadKeyExpr = invalid$1;\n        this.visitCommaExpr = invalid$1;\n        this.visitLocalizedString = invalid$1;\n    }\n    visitLiteralExpr(ast) {\n        return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n    }\n    visitLiteralArrayExpr(ast, context) {\n        return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n    }\n    visitLiteralMapExpr(ast, context) {\n        const mapKey = (entry) => {\n            const quote = entry.quoted ? '\"' : '';\n            return `${quote}${entry.key}${quote}`;\n        };\n        const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n        return `{${ast.entries.map(mapEntry).join(',')}`;\n    }\n    visitExternalExpr(ast) {\n        return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n            `EX:${ast.value.runtime.name}`;\n    }\n    visitReadVarExpr(node) {\n        return `VAR:${node.name}`;\n    }\n    visitTypeofExpr(node, context) {\n        return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n    }\n}\nfunction invalid$1(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction isVariable(e) {\n    return e instanceof ReadVarExpr;\n}\nfunction isLongStringLiteral(expr) {\n    return expr instanceof LiteralExpr && typeof expr.value === 'string' &&\n        expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n\nconst CORE = '@angular/core';\nclass Identifiers {\n}\n/* Methods */\nIdentifiers.NEW_METHOD = 'factory';\nIdentifiers.TRANSFORM_METHOD = 'transform';\nIdentifiers.PATCH_DEPS = 'patchedDeps';\nIdentifiers.core = { name: null, moduleName: CORE };\n/* Instructions */\nIdentifiers.namespaceHTML = { name: 'namespaceHTML', moduleName: CORE };\nIdentifiers.namespaceMathML = { name: 'namespaceMathML', moduleName: CORE };\nIdentifiers.namespaceSVG = { name: 'namespaceSVG', moduleName: CORE };\nIdentifiers.element = { name: 'element', moduleName: CORE };\nIdentifiers.elementStart = { name: 'elementStart', moduleName: CORE };\nIdentifiers.elementEnd = { name: 'elementEnd', moduleName: CORE };\nIdentifiers.advance = { name: 'advance', moduleName: CORE };\nIdentifiers.syntheticHostProperty = { name: 'syntheticHostProperty', moduleName: CORE };\nIdentifiers.syntheticHostListener = { name: 'syntheticHostListener', moduleName: CORE };\nIdentifiers.attribute = { name: 'attribute', moduleName: CORE };\nIdentifiers.attributeInterpolate1 = { name: 'attributeInterpolate1', moduleName: CORE };\nIdentifiers.attributeInterpolate2 = { name: 'attributeInterpolate2', moduleName: CORE };\nIdentifiers.attributeInterpolate3 = { name: 'attributeInterpolate3', moduleName: CORE };\nIdentifiers.attributeInterpolate4 = { name: 'attributeInterpolate4', moduleName: CORE };\nIdentifiers.attributeInterpolate5 = { name: 'attributeInterpolate5', moduleName: CORE };\nIdentifiers.attributeInterpolate6 = { name: 'attributeInterpolate6', moduleName: CORE };\nIdentifiers.attributeInterpolate7 = { name: 'attributeInterpolate7', moduleName: CORE };\nIdentifiers.attributeInterpolate8 = { name: 'attributeInterpolate8', moduleName: CORE };\nIdentifiers.attributeInterpolateV = { name: 'attributeInterpolateV', moduleName: CORE };\nIdentifiers.classProp = { name: 'classProp', moduleName: CORE };\nIdentifiers.elementContainerStart = { name: 'elementContainerStart', moduleName: CORE };\nIdentifiers.elementContainerEnd = { name: 'elementContainerEnd', moduleName: CORE };\nIdentifiers.elementContainer = { name: 'elementContainer', moduleName: CORE };\nIdentifiers.styleMap = { name: 'styleMap', moduleName: CORE };\nIdentifiers.styleMapInterpolate1 = { name: 'styleMapInterpolate1', moduleName: CORE };\nIdentifiers.styleMapInterpolate2 = { name: 'styleMapInterpolate2', moduleName: CORE };\nIdentifiers.styleMapInterpolate3 = { name: 'styleMapInterpolate3', moduleName: CORE };\nIdentifiers.styleMapInterpolate4 = { name: 'styleMapInterpolate4', moduleName: CORE };\nIdentifiers.styleMapInterpolate5 = { name: 'styleMapInterpolate5', moduleName: CORE };\nIdentifiers.styleMapInterpolate6 = { name: 'styleMapInterpolate6', moduleName: CORE };\nIdentifiers.styleMapInterpolate7 = { name: 'styleMapInterpolate7', moduleName: CORE };\nIdentifiers.styleMapInterpolate8 = { name: 'styleMapInterpolate8', moduleName: CORE };\nIdentifiers.styleMapInterpolateV = { name: 'styleMapInterpolateV', moduleName: CORE };\nIdentifiers.classMap = { name: 'classMap', moduleName: CORE };\nIdentifiers.classMapInterpolate1 = { name: 'classMapInterpolate1', moduleName: CORE };\nIdentifiers.classMapInterpolate2 = { name: 'classMapInterpolate2', moduleName: CORE };\nIdentifiers.classMapInterpolate3 = { name: 'classMapInterpolate3', moduleName: CORE };\nIdentifiers.classMapInterpolate4 = { name: 'classMapInterpolate4', moduleName: CORE };\nIdentifiers.classMapInterpolate5 = { name: 'classMapInterpolate5', moduleName: CORE };\nIdentifiers.classMapInterpolate6 = { name: 'classMapInterpolate6', moduleName: CORE };\nIdentifiers.classMapInterpolate7 = { name: 'classMapInterpolate7', moduleName: CORE };\nIdentifiers.classMapInterpolate8 = { name: 'classMapInterpolate8', moduleName: CORE };\nIdentifiers.classMapInterpolateV = { name: 'classMapInterpolateV', moduleName: CORE };\nIdentifiers.styleProp = { name: 'styleProp', moduleName: CORE };\nIdentifiers.stylePropInterpolate1 = { name: 'stylePropInterpolate1', moduleName: CORE };\nIdentifiers.stylePropInterpolate2 = { name: 'stylePropInterpolate2', moduleName: CORE };\nIdentifiers.stylePropInterpolate3 = { name: 'stylePropInterpolate3', moduleName: CORE };\nIdentifiers.stylePropInterpolate4 = { name: 'stylePropInterpolate4', moduleName: CORE };\nIdentifiers.stylePropInterpolate5 = { name: 'stylePropInterpolate5', moduleName: CORE };\nIdentifiers.stylePropInterpolate6 = { name: 'stylePropInterpolate6', moduleName: CORE };\nIdentifiers.stylePropInterpolate7 = { name: 'stylePropInterpolate7', moduleName: CORE };\nIdentifiers.stylePropInterpolate8 = { name: 'stylePropInterpolate8', moduleName: CORE };\nIdentifiers.stylePropInterpolateV = { name: 'stylePropInterpolateV', moduleName: CORE };\nIdentifiers.nextContext = { name: 'nextContext', moduleName: CORE };\nIdentifiers.resetView = { name: 'resetView', moduleName: CORE };\nIdentifiers.templateCreate = { name: 'template', moduleName: CORE };\nIdentifiers.text = { name: 'text', moduleName: CORE };\nIdentifiers.enableBindings = { name: 'enableBindings', moduleName: CORE };\nIdentifiers.disableBindings = { name: 'disableBindings', moduleName: CORE };\nIdentifiers.getCurrentView = { name: 'getCurrentView', moduleName: CORE };\nIdentifiers.textInterpolate = { name: 'textInterpolate', moduleName: CORE };\nIdentifiers.textInterpolate1 = { name: 'textInterpolate1', moduleName: CORE };\nIdentifiers.textInterpolate2 = { name: 'textInterpolate2', moduleName: CORE };\nIdentifiers.textInterpolate3 = { name: 'textInterpolate3', moduleName: CORE };\nIdentifiers.textInterpolate4 = { name: 'textInterpolate4', moduleName: CORE };\nIdentifiers.textInterpolate5 = { name: 'textInterpolate5', moduleName: CORE };\nIdentifiers.textInterpolate6 = { name: 'textInterpolate6', moduleName: CORE };\nIdentifiers.textInterpolate7 = { name: 'textInterpolate7', moduleName: CORE };\nIdentifiers.textInterpolate8 = { name: 'textInterpolate8', moduleName: CORE };\nIdentifiers.textInterpolateV = { name: 'textInterpolateV', moduleName: CORE };\nIdentifiers.restoreView = { name: 'restoreView', moduleName: CORE };\nIdentifiers.pureFunction0 = { name: 'pureFunction0', moduleName: CORE };\nIdentifiers.pureFunction1 = { name: 'pureFunction1', moduleName: CORE };\nIdentifiers.pureFunction2 = { name: 'pureFunction2', moduleName: CORE };\nIdentifiers.pureFunction3 = { name: 'pureFunction3', moduleName: CORE };\nIdentifiers.pureFunction4 = { name: 'pureFunction4', moduleName: CORE };\nIdentifiers.pureFunction5 = { name: 'pureFunction5', moduleName: CORE };\nIdentifiers.pureFunction6 = { name: 'pureFunction6', moduleName: CORE };\nIdentifiers.pureFunction7 = { name: 'pureFunction7', moduleName: CORE };\nIdentifiers.pureFunction8 = { name: 'pureFunction8', moduleName: CORE };\nIdentifiers.pureFunctionV = { name: 'pureFunctionV', moduleName: CORE };\nIdentifiers.pipeBind1 = { name: 'pipeBind1', moduleName: CORE };\nIdentifiers.pipeBind2 = { name: 'pipeBind2', moduleName: CORE };\nIdentifiers.pipeBind3 = { name: 'pipeBind3', moduleName: CORE };\nIdentifiers.pipeBind4 = { name: 'pipeBind4', moduleName: CORE };\nIdentifiers.pipeBindV = { name: 'pipeBindV', moduleName: CORE };\nIdentifiers.hostProperty = { name: 'hostProperty', moduleName: CORE };\nIdentifiers.property = { name: 'property', moduleName: CORE };\nIdentifiers.propertyInterpolate = { name: 'propertyInterpolate', moduleName: CORE };\nIdentifiers.propertyInterpolate1 = { name: 'propertyInterpolate1', moduleName: CORE };\nIdentifiers.propertyInterpolate2 = { name: 'propertyInterpolate2', moduleName: CORE };\nIdentifiers.propertyInterpolate3 = { name: 'propertyInterpolate3', moduleName: CORE };\nIdentifiers.propertyInterpolate4 = { name: 'propertyInterpolate4', moduleName: CORE };\nIdentifiers.propertyInterpolate5 = { name: 'propertyInterpolate5', moduleName: CORE };\nIdentifiers.propertyInterpolate6 = { name: 'propertyInterpolate6', moduleName: CORE };\nIdentifiers.propertyInterpolate7 = { name: 'propertyInterpolate7', moduleName: CORE };\nIdentifiers.propertyInterpolate8 = { name: 'propertyInterpolate8', moduleName: CORE };\nIdentifiers.propertyInterpolateV = { name: 'propertyInterpolateV', moduleName: CORE };\nIdentifiers.i18n = { name: 'i18n', moduleName: CORE };\nIdentifiers.i18nAttributes = { name: 'i18nAttributes', moduleName: CORE };\nIdentifiers.i18nExp = { name: 'i18nExp', moduleName: CORE };\nIdentifiers.i18nStart = { name: 'i18nStart', moduleName: CORE };\nIdentifiers.i18nEnd = { name: 'i18nEnd', moduleName: CORE };\nIdentifiers.i18nApply = { name: 'i18nApply', moduleName: CORE };\nIdentifiers.i18nPostprocess = { name: 'i18nPostprocess', moduleName: CORE };\nIdentifiers.pipe = { name: 'pipe', moduleName: CORE };\nIdentifiers.projection = { name: 'projection', moduleName: CORE };\nIdentifiers.projectionDef = { name: 'projectionDef', moduleName: CORE };\nIdentifiers.reference = { name: 'reference', moduleName: CORE };\nIdentifiers.inject = { name: 'inject', moduleName: CORE };\nIdentifiers.injectAttribute = { name: 'injectAttribute', moduleName: CORE };\nIdentifiers.directiveInject = { name: 'directiveInject', moduleName: CORE };\nIdentifiers.invalidFactory = { name: 'invalidFactory', moduleName: CORE };\nIdentifiers.invalidFactoryDep = { name: 'invalidFactoryDep', moduleName: CORE };\nIdentifiers.templateRefExtractor = { name: 'templateRefExtractor', moduleName: CORE };\nIdentifiers.forwardRef = { name: 'forwardRef', moduleName: CORE };\nIdentifiers.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE };\nIdentifiers.defineInjectable = { name: 'defineInjectable', moduleName: CORE };\nIdentifiers.declareInjectable = { name: 'ngDeclareInjectable', moduleName: CORE };\nIdentifiers.InjectableDeclaration = { name: 'InjectableDeclaration', moduleName: CORE };\nIdentifiers.resolveWindow = { name: 'resolveWindow', moduleName: CORE };\nIdentifiers.resolveDocument = { name: 'resolveDocument', moduleName: CORE };\nIdentifiers.resolveBody = { name: 'resolveBody', moduleName: CORE };\nIdentifiers.defineComponent = { name: 'defineComponent', moduleName: CORE };\nIdentifiers.declareComponent = { name: 'ngDeclareComponent', moduleName: CORE };\nIdentifiers.setComponentScope = { name: 'setComponentScope', moduleName: CORE };\nIdentifiers.ChangeDetectionStrategy = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n};\nIdentifiers.ViewEncapsulation = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n};\nIdentifiers.ComponentDeclaration = {\n    name: 'ComponentDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.FactoryDeclaration = {\n    name: 'FactoryDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.declareFactory = { name: 'ngDeclareFactory', moduleName: CORE };\nIdentifiers.FactoryTarget = { name: 'FactoryTarget', moduleName: CORE };\nIdentifiers.defineDirective = { name: 'defineDirective', moduleName: CORE };\nIdentifiers.declareDirective = { name: 'ngDeclareDirective', moduleName: CORE };\nIdentifiers.DirectiveDeclaration = {\n    name: 'DirectiveDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.InjectorDef = { name: 'InjectorDef', moduleName: CORE };\nIdentifiers.InjectorDeclaration = { name: 'InjectorDeclaration', moduleName: CORE };\nIdentifiers.defineInjector = { name: 'defineInjector', moduleName: CORE };\nIdentifiers.declareInjector = { name: 'ngDeclareInjector', moduleName: CORE };\nIdentifiers.NgModuleDeclaration = {\n    name: 'NgModuleDeclaration',\n    moduleName: CORE,\n};\nIdentifiers.ModuleWithProviders = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n};\nIdentifiers.defineNgModule = { name: 'defineNgModule', moduleName: CORE };\nIdentifiers.declareNgModule = { name: 'ngDeclareNgModule', moduleName: CORE };\nIdentifiers.setNgModuleScope = { name: 'setNgModuleScope', moduleName: CORE };\nIdentifiers.registerNgModuleType = { name: 'registerNgModuleType', moduleName: CORE };\nIdentifiers.PipeDeclaration = { name: 'PipeDeclaration', moduleName: CORE };\nIdentifiers.definePipe = { name: 'definePipe', moduleName: CORE };\nIdentifiers.declarePipe = { name: 'ngDeclarePipe', moduleName: CORE };\nIdentifiers.declareClassMetadata = { name: 'ngDeclareClassMetadata', moduleName: CORE };\nIdentifiers.setClassMetadata = { name: 'setClassMetadata', moduleName: CORE };\nIdentifiers.queryRefresh = { name: 'queryRefresh', moduleName: CORE };\nIdentifiers.viewQuery = { name: 'viewQuery', moduleName: CORE };\nIdentifiers.loadQuery = { name: 'loadQuery', moduleName: CORE };\nIdentifiers.contentQuery = { name: 'contentQuery', moduleName: CORE };\nIdentifiers.NgOnChangesFeature = { name: 'NgOnChangesFeature', moduleName: CORE };\nIdentifiers.InheritDefinitionFeature = { name: 'InheritDefinitionFeature', moduleName: CORE };\nIdentifiers.CopyDefinitionFeature = { name: 'CopyDefinitionFeature', moduleName: CORE };\nIdentifiers.StandaloneFeature = { name: 'StandaloneFeature', moduleName: CORE };\nIdentifiers.ProvidersFeature = { name: 'ProvidersFeature', moduleName: CORE };\nIdentifiers.HostDirectivesFeature = { name: 'HostDirectivesFeature', moduleName: CORE };\nIdentifiers.listener = { name: 'listener', moduleName: CORE };\nIdentifiers.getInheritedFactory = {\n    name: 'getInheritedFactory',\n    moduleName: CORE,\n};\n// sanitization-related functions\nIdentifiers.sanitizeHtml = { name: 'sanitizeHtml', moduleName: CORE };\nIdentifiers.sanitizeStyle = { name: 'sanitizeStyle', moduleName: CORE };\nIdentifiers.sanitizeResourceUrl = { name: 'sanitizeResourceUrl', moduleName: CORE };\nIdentifiers.sanitizeScript = { name: 'sanitizeScript', moduleName: CORE };\nIdentifiers.sanitizeUrl = { name: 'sanitizeUrl', moduleName: CORE };\nIdentifiers.sanitizeUrlOrResourceUrl = { name: 'sanitizeUrlOrResourceUrl', moduleName: CORE };\nIdentifiers.trustConstantHtml = { name: 'trustConstantHtml', moduleName: CORE };\nIdentifiers.trustConstantResourceUrl = { name: 'trustConstantResourceUrl', moduleName: CORE };\nIdentifiers.validateIframeAttribute = { name: 'validateIframeAttribute', moduleName: CORE };\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\nfunction dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n}\nfunction splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n}\nfunction splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n}\nfunction _splitAt(input, character, defaultValues) {\n    const characterIndex = input.indexOf(character);\n    if (characterIndex == -1)\n        return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\nfunction noUndefined(val) {\n    return val === undefined ? null : val;\n}\nfunction error(msg) {\n    throw new Error(`Internal Error: ${msg}`);\n}\n// Escape characters that have a special meaning in Regular Expressions\nfunction escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\nfunction utf8Encode(str) {\n    let encoded = [];\n    for (let index = 0; index < str.length; index++) {\n        let codePoint = str.charCodeAt(index);\n        // decode surrogate\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n            const low = str.charCodeAt(index + 1);\n            if (low >= 0xdc00 && low <= 0xdfff) {\n                index++;\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n            }\n        }\n        if (codePoint <= 0x7f) {\n            encoded.push(codePoint);\n        }\n        else if (codePoint <= 0x7ff) {\n            encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0xffff) {\n            encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n        else if (codePoint <= 0x1fffff) {\n            encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n        }\n    }\n    return encoded;\n}\nfunction stringify(token) {\n    if (typeof token === 'string') {\n        return token;\n    }\n    if (Array.isArray(token)) {\n        return '[' + token.map(stringify).join(', ') + ']';\n    }\n    if (token == null) {\n        return '' + token;\n    }\n    if (token.overriddenName) {\n        return `${token.overriddenName}`;\n    }\n    if (token.name) {\n        return `${token.name}`;\n    }\n    if (!token.toString) {\n        return 'object';\n    }\n    // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n    const res = token.toString();\n    if (res == null) {\n        return '' + res;\n    }\n    const newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\nclass Version {\n    constructor(full) {\n        this.full = full;\n        const splits = full.split('.');\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join('.');\n    }\n}\n// Check `global` first, because in Node tests both `global` and `window` may be defined and our\n// `_global` variable should point to the NodeJS `global` in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = ( /* @__PURE__ */(() => (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\nfunction newArray(size, value) {\n    const list = [];\n    for (let i = 0; i < size; i++) {\n        list.push(value);\n    }\n    return list;\n}\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nfunction partitionArray(arr, conditionFn) {\n    const truthy = [];\n    const falsy = [];\n    for (const item of arr) {\n        (conditionFn(item) ? truthy : falsy).push(item);\n    }\n    return [truthy, falsy];\n}\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION$1 = 3;\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\nclass SourceMapGenerator {\n    constructor(file = null) {\n        this.file = file;\n        this.sourcesContent = new Map();\n        this.lines = [];\n        this.lastCol0 = 0;\n        this.hasMappings = false;\n    }\n    // The content is `null` when the content is expected to be loaded using the URL\n    addSource(url, content = null) {\n        if (!this.sourcesContent.has(url)) {\n            this.sourcesContent.set(url, content);\n        }\n        return this;\n    }\n    addLine() {\n        this.lines.push([]);\n        this.lastCol0 = 0;\n        return this;\n    }\n    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n        if (!this.currentLine) {\n            throw new Error(`A line must be added before mappings can be added`);\n        }\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n            throw new Error(`Unknown source file \"${sourceUrl}\"`);\n        }\n        if (col0 == null) {\n            throw new Error(`The column in the generated code must be provided`);\n        }\n        if (col0 < this.lastCol0) {\n            throw new Error(`Mapping should be added in output order`);\n        }\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n            throw new Error(`The source location must be provided when a source url is provided`);\n        }\n        this.hasMappings = true;\n        this.lastCol0 = col0;\n        this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });\n        return this;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get currentLine() {\n        return this.lines.slice(-1)[0];\n    }\n    toJSON() {\n        if (!this.hasMappings) {\n            return null;\n        }\n        const sourcesIndex = new Map();\n        const sources = [];\n        const sourcesContent = [];\n        Array.from(this.sourcesContent.keys()).forEach((url, i) => {\n            sourcesIndex.set(url, i);\n            sources.push(url);\n            sourcesContent.push(this.sourcesContent.get(url) || null);\n        });\n        let mappings = '';\n        let lastCol0 = 0;\n        let lastSourceIndex = 0;\n        let lastSourceLine0 = 0;\n        let lastSourceCol0 = 0;\n        this.lines.forEach(segments => {\n            lastCol0 = 0;\n            mappings += segments\n                .map(segment => {\n                // zero-based starting column of the line in the generated code\n                let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                lastCol0 = segment.col0;\n                if (segment.sourceUrl != null) {\n                    // zero-based index into the sources list\n                    segAsStr +=\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\n                    // the zero-based starting line in the original source\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n                    lastSourceLine0 = segment.sourceLine0;\n                    // the zero-based starting column in the original source\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n                    lastSourceCol0 = segment.sourceCol0;\n                }\n                return segAsStr;\n            })\n                .join(',');\n            mappings += ';';\n        });\n        mappings = mappings.slice(0, -1);\n        return {\n            'file': this.file || '',\n            'version': VERSION$1,\n            'sourceRoot': '',\n            'sources': sources,\n            'sourcesContent': sourcesContent,\n            'mappings': mappings,\n        };\n    }\n    toJsComment() {\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n            '';\n    }\n}\nfunction toBase64String(value) {\n    let b64 = '';\n    const encoded = utf8Encode(value);\n    for (let i = 0; i < encoded.length;) {\n        const i1 = encoded[i++];\n        const i2 = i < encoded.length ? encoded[i++] : null;\n        const i3 = i < encoded.length ? encoded[i++] : null;\n        b64 += toBase64Digit(i1 >> 2);\n        b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n        b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n        b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n    }\n    return b64;\n}\nfunction toBase64VLQ(value) {\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n    let out = '';\n    do {\n        let digit = value & 31;\n        value = value >> 5;\n        if (value > 0) {\n            digit = digit | 32;\n        }\n        out += toBase64Digit(digit);\n    } while (value > 0);\n    return out;\n}\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfunction toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n        throw new Error(`Can only encode value in the range [0, 63]`);\n    }\n    return B64_DIGITS[value];\n}\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nclass _EmittedLine {\n    constructor(indent) {\n        this.indent = indent;\n        this.partsLength = 0;\n        this.parts = [];\n        this.srcSpans = [];\n    }\n}\nclass EmitterVisitorContext {\n    static createRoot() {\n        return new EmitterVisitorContext(0);\n    }\n    constructor(_indent) {\n        this._indent = _indent;\n        this._lines = [new _EmittedLine(_indent)];\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get _currentLine() {\n        return this._lines[this._lines.length - 1];\n    }\n    println(from, lastPart = '') {\n        this.print(from || null, lastPart, true);\n    }\n    lineIsEmpty() {\n        return this._currentLine.parts.length === 0;\n    }\n    lineLength() {\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n    print(from, part, newLine = false) {\n        if (part.length > 0) {\n            this._currentLine.parts.push(part);\n            this._currentLine.partsLength += part.length;\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n        }\n        if (newLine) {\n            this._lines.push(new _EmittedLine(this._indent));\n        }\n    }\n    removeEmptyLastLine() {\n        if (this.lineIsEmpty()) {\n            this._lines.pop();\n        }\n    }\n    incIndent() {\n        this._indent++;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    decIndent() {\n        this._indent--;\n        if (this.lineIsEmpty()) {\n            this._currentLine.indent = this._indent;\n        }\n    }\n    toSource() {\n        return this.sourceLines\n            .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n            .join('\\n');\n    }\n    toSourceMapGenerator(genFilePath, startsAtLine = 0) {\n        const map = new SourceMapGenerator(genFilePath);\n        let firstOffsetMapped = false;\n        const mapFirstOffsetIfNeeded = () => {\n            if (!firstOffsetMapped) {\n                // Add a single space so that tools won't try to load the file from disk.\n                // Note: We are using virtual urls like `ng:///`, so we have to\n                // provide a content here.\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n                firstOffsetMapped = true;\n            }\n        };\n        for (let i = 0; i < startsAtLine; i++) {\n            map.addLine();\n            mapFirstOffsetIfNeeded();\n        }\n        this.sourceLines.forEach((line, lineIdx) => {\n            map.addLine();\n            const spans = line.srcSpans;\n            const parts = line.parts;\n            let col0 = line.indent * _INDENT_WITH.length;\n            let spanIdx = 0;\n            // skip leading parts without source spans\n            while (spanIdx < spans.length && !spans[spanIdx]) {\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n            }\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n                firstOffsetMapped = true;\n            }\n            else {\n                mapFirstOffsetIfNeeded();\n            }\n            while (spanIdx < spans.length) {\n                const span = spans[spanIdx];\n                const source = span.start.file;\n                const sourceLine = span.start.line;\n                const sourceCol = span.start.col;\n                map.addSource(source.url, source.content)\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\n                col0 += parts[spanIdx].length;\n                spanIdx++;\n                // assign parts without span or the same span to the previous segment\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n                    col0 += parts[spanIdx].length;\n                    spanIdx++;\n                }\n            }\n        });\n        return map;\n    }\n    spanOf(line, column) {\n        const emittedLine = this._lines[line];\n        if (emittedLine) {\n            let columnsLeft = column - _createIndent(emittedLine.indent).length;\n            for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n                const part = emittedLine.parts[partIndex];\n                if (part.length > columnsLeft) {\n                    return emittedLine.srcSpans[partIndex];\n                }\n                columnsLeft -= part.length;\n            }\n        }\n        return null;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get sourceLines() {\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n            return this._lines.slice(0, -1);\n        }\n        return this._lines;\n    }\n}\nclass AbstractEmitterVisitor {\n    constructor(_escapeDollarInStrings) {\n        this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n    printLeadingComments(stmt, ctx) {\n        if (stmt.leadingComments === undefined) {\n            return;\n        }\n        for (const comment of stmt.leadingComments) {\n            if (comment instanceof JSDocComment) {\n                ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n            }\n            else {\n                if (comment.multiline) {\n                    ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n                }\n                else {\n                    comment.text.split('\\n').forEach((line) => {\n                        ctx.println(stmt, `// ${line}`);\n                    });\n                }\n            }\n        }\n    }\n    visitExpressionStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        stmt.expr.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitReturnStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `return `);\n        stmt.value.visitExpression(this, ctx);\n        ctx.println(stmt, ';');\n        return null;\n    }\n    visitIfStmt(stmt, ctx) {\n        this.printLeadingComments(stmt, ctx);\n        ctx.print(stmt, `if (`);\n        stmt.condition.visitExpression(this, ctx);\n        ctx.print(stmt, `) {`);\n        const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\n            ctx.print(stmt, ` `);\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.removeEmptyLastLine();\n            ctx.print(stmt, ` `);\n        }\n        else {\n            ctx.println();\n            ctx.incIndent();\n            this.visitAllStatements(stmt.trueCase, ctx);\n            ctx.decIndent();\n            if (hasElseCase) {\n                ctx.println(stmt, `} else {`);\n                ctx.incIndent();\n                this.visitAllStatements(stmt.falseCase, ctx);\n                ctx.decIndent();\n            }\n        }\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitWriteVarExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        ctx.print(expr, `${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWriteKeyExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `[`);\n        expr.index.visitExpression(this, ctx);\n        ctx.print(expr, `] = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitWritePropExpr(expr, ctx) {\n        const lineWasEmpty = ctx.lineIsEmpty();\n        if (!lineWasEmpty) {\n            ctx.print(expr, '(');\n        }\n        expr.receiver.visitExpression(this, ctx);\n        ctx.print(expr, `.${expr.name} = `);\n        expr.value.visitExpression(this, ctx);\n        if (!lineWasEmpty) {\n            ctx.print(expr, ')');\n        }\n        return null;\n    }\n    visitInvokeFunctionExpr(expr, ctx) {\n        expr.fn.visitExpression(this, ctx);\n        ctx.print(expr, `(`);\n        this.visitAllExpressions(expr.args, ctx, ',');\n        ctx.print(expr, `)`);\n        return null;\n    }\n    visitTaggedTemplateExpr(expr, ctx) {\n        expr.tag.visitExpression(this, ctx);\n        ctx.print(expr, '`' + expr.template.elements[0].rawText);\n        for (let i = 1; i < expr.template.elements.length; i++) {\n            ctx.print(expr, '${');\n            expr.template.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n        }\n        ctx.print(expr, '`');\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    }\n    visitTypeofExpr(expr, ctx) {\n        ctx.print(expr, 'typeof ');\n        expr.expr.visitExpression(this, ctx);\n    }\n    visitReadVarExpr(ast, ctx) {\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitInstantiateExpr(ast, ctx) {\n        ctx.print(ast, `new `);\n        ast.classExpr.visitExpression(this, ctx);\n        ctx.print(ast, `(`);\n        this.visitAllExpressions(ast.args, ctx, ',');\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitLiteralExpr(ast, ctx) {\n        const value = ast.value;\n        if (typeof value === 'string') {\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n        }\n        else {\n            ctx.print(ast, `${value}`);\n        }\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        const head = ast.serializeI18nHead();\n        ctx.print(ast, '$localize `' + head.raw);\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            ctx.print(ast, '${');\n            ast.expressions[i - 1].visitExpression(this, ctx);\n            ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n        }\n        ctx.print(ast, '`');\n        return null;\n    }\n    visitConditionalExpr(ast, ctx) {\n        ctx.print(ast, `(`);\n        ast.condition.visitExpression(this, ctx);\n        ctx.print(ast, '? ');\n        ast.trueCase.visitExpression(this, ctx);\n        ctx.print(ast, ': ');\n        ast.falseCase.visitExpression(this, ctx);\n        ctx.print(ast, `)`);\n        return null;\n    }\n    visitNotExpr(ast, ctx) {\n        ctx.print(ast, '!');\n        ast.condition.visitExpression(this, ctx);\n        return null;\n    }\n    visitUnaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case UnaryOperator.Plus:\n                opStr = '+';\n                break;\n            case UnaryOperator.Minus:\n                opStr = '-';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ctx.print(ast, opStr);\n        ast.expr.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitBinaryOperatorExpr(ast, ctx) {\n        let opStr;\n        switch (ast.operator) {\n            case BinaryOperator.Equals:\n                opStr = '==';\n                break;\n            case BinaryOperator.Identical:\n                opStr = '===';\n                break;\n            case BinaryOperator.NotEquals:\n                opStr = '!=';\n                break;\n            case BinaryOperator.NotIdentical:\n                opStr = '!==';\n                break;\n            case BinaryOperator.And:\n                opStr = '&&';\n                break;\n            case BinaryOperator.BitwiseAnd:\n                opStr = '&';\n                break;\n            case BinaryOperator.Or:\n                opStr = '||';\n                break;\n            case BinaryOperator.Plus:\n                opStr = '+';\n                break;\n            case BinaryOperator.Minus:\n                opStr = '-';\n                break;\n            case BinaryOperator.Divide:\n                opStr = '/';\n                break;\n            case BinaryOperator.Multiply:\n                opStr = '*';\n                break;\n            case BinaryOperator.Modulo:\n                opStr = '%';\n                break;\n            case BinaryOperator.Lower:\n                opStr = '<';\n                break;\n            case BinaryOperator.LowerEquals:\n                opStr = '<=';\n                break;\n            case BinaryOperator.Bigger:\n                opStr = '>';\n                break;\n            case BinaryOperator.BiggerEquals:\n                opStr = '>=';\n                break;\n            case BinaryOperator.NullishCoalesce:\n                opStr = '??';\n                break;\n            default:\n                throw new Error(`Unknown operator ${ast.operator}`);\n        }\n        if (ast.parens)\n            ctx.print(ast, `(`);\n        ast.lhs.visitExpression(this, ctx);\n        ctx.print(ast, ` ${opStr} `);\n        ast.rhs.visitExpression(this, ctx);\n        if (ast.parens)\n            ctx.print(ast, `)`);\n        return null;\n    }\n    visitReadPropExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `.`);\n        ctx.print(ast, ast.name);\n        return null;\n    }\n    visitReadKeyExpr(ast, ctx) {\n        ast.receiver.visitExpression(this, ctx);\n        ctx.print(ast, `[`);\n        ast.index.visitExpression(this, ctx);\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralArrayExpr(ast, ctx) {\n        ctx.print(ast, `[`);\n        this.visitAllExpressions(ast.entries, ctx, ',');\n        ctx.print(ast, `]`);\n        return null;\n    }\n    visitLiteralMapExpr(ast, ctx) {\n        ctx.print(ast, `{`);\n        this.visitAllObjects(entry => {\n            ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n            entry.value.visitExpression(this, ctx);\n        }, ast.entries, ctx, ',');\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitCommaExpr(ast, ctx) {\n        ctx.print(ast, '(');\n        this.visitAllExpressions(ast.parts, ctx, ',');\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitAllExpressions(expressions, ctx, separator) {\n        this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n    }\n    visitAllObjects(handler, expressions, ctx, separator) {\n        let incrementedIndent = false;\n        for (let i = 0; i < expressions.length; i++) {\n            if (i > 0) {\n                if (ctx.lineLength() > 80) {\n                    ctx.print(null, separator, true);\n                    if (!incrementedIndent) {\n                        // continuation are marked with double indent.\n                        ctx.incIndent();\n                        ctx.incIndent();\n                        incrementedIndent = true;\n                    }\n                }\n                else {\n                    ctx.print(null, separator, false);\n                }\n            }\n            handler(expressions[i]);\n        }\n        if (incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.decIndent();\n            ctx.decIndent();\n        }\n    }\n    visitAllStatements(statements, ctx) {\n        statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n    }\n}\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\n    if (input == null) {\n        return null;\n    }\n    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\n        if (match[0] == '$') {\n            return escapeDollar ? '\\\\$' : '$';\n        }\n        else if (match[0] == '\\n') {\n            return '\\\\n';\n        }\n        else if (match[0] == '\\r') {\n            return '\\\\r';\n        }\n        else {\n            return `\\\\${match[0]}`;\n        }\n    });\n    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? `'${body}'` : body;\n}\nfunction _createIndent(count) {\n    let res = '';\n    for (let i = 0; i < count; i++) {\n        res += _INDENT_WITH;\n    }\n    return res;\n}\n\nfunction typeWithParameters(type, numParams) {\n    if (numParams === 0) {\n        return expressionType(type);\n    }\n    const params = [];\n    for (let i = 0; i < numParams; i++) {\n        params.push(DYNAMIC_TYPE);\n    }\n    return expressionType(type, undefined, params);\n}\nconst ANIMATE_SYMBOL_PREFIX = '@';\nfunction prepareSyntheticPropertyName(name) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\nfunction prepareSyntheticListenerName(name, phase) {\n    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\nfunction getSafePropertyAccessString(accessor, name) {\n    const escapedName = escapeIdentifier(name, false, false);\n    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n    return `animation_${name}_${phase}`;\n}\nfunction jitOnlyGuardedExpression(expr) {\n    return guardedExpression('ngJitMode', expr);\n}\nfunction devOnlyGuardedExpression(expr) {\n    return guardedExpression('ngDevMode', expr);\n}\nfunction guardedExpression(guard, expr) {\n    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });\n    const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n    const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, \n    /* sourceSpan */ undefined, true);\n    return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\nfunction wrapReference(value) {\n    const wrapped = new WrappedNodeExpr(value);\n    return { value: wrapped, type: wrapped };\n}\nfunction refsToArray(refs, shouldForwardDeclare) {\n    const values = literalArr(refs.map(ref => ref.value));\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\nfunction createMayBeForwardRefExpression(expression, forwardRef) {\n    return { expression, forwardRef };\n}\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nfunction convertFromMaybeForwardRefExpression({ expression, forwardRef }) {\n    switch (forwardRef) {\n        case 0 /* ForwardRefHandling.None */:\n        case 1 /* ForwardRefHandling.Wrapped */:\n            return expression;\n        case 2 /* ForwardRefHandling.Unwrapped */:\n            return generateForwardRef(expression);\n    }\n}\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nfunction generateForwardRef(expr) {\n    return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);\n}\n\nvar R3FactoryDelegateType;\n(function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\nvar FactoryTarget$1;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget$1 || (FactoryTarget$1 = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nfunction compileFactoryFunction(meta) {\n    const t = variable('t');\n    let baseFactoryVar = null;\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n    const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n        new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :\n        t;\n    let ctorExpr = null;\n    if (meta.deps !== null) {\n        // There is a constructor (either explicitly or implicitly defined).\n        if (meta.deps !== 'invalid') {\n            ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n        }\n    }\n    else {\n        // There is no constructor, use the base class' factory to construct typeForCtor.\n        baseFactoryVar = variable(`${meta.name}_BaseFactory`);\n        ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n    }\n    const body = [];\n    let retExpr = null;\n    function makeConditionalFactory(nonCtorExpr) {\n        const r = variable('r');\n        body.push(r.set(NULL_EXPR).toDeclStmt());\n        const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n            importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n        return r;\n    }\n    if (isDelegatedFactoryMetadata(meta)) {\n        // This type is created with a delegated factory. If a type parameter is not specified, call\n        // the factory instead.\n        const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n        const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\n            InstantiateExpr :\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\n        retExpr = makeConditionalFactory(factoryExpr);\n    }\n    else if (isExpressionFactoryMetadata(meta)) {\n        // TODO(alxhub): decide whether to lower the value here or in the caller\n        retExpr = makeConditionalFactory(meta.expression);\n    }\n    else {\n        retExpr = ctorExpr;\n    }\n    if (retExpr === null) {\n        // The expression cannot be formed so render an `invalidFactory()` call.\n        body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n    }\n    else if (baseFactoryVar !== null) {\n        // This factory uses a base factory, so call `getInheritedFactory()` to compute it.\n        const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);\n        // Memoize the base factoryFn: `baseFactory || (baseFactory = getInheritedFactory(...))`\n        const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n        body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n    }\n    else {\n        // This is straightforward factory, just return it.\n        body.push(new ReturnStatement(retExpr));\n    }\n    let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n    if (baseFactoryVar !== null) {\n        // There is a base factory variable so wrap its declaration along with the factory function into\n        // an IIFE.\n        factoryFn = fn([], [\n            new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)\n        ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n    }\n    return {\n        expression: factoryFn,\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\nfunction createFactoryType(meta) {\n    const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n    return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\nfunction injectDependencies(deps, target) {\n    return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\nfunction compileInjectDependency(dep, target, index) {\n    // Interpret the dependency according to its resolved type.\n    if (dep.token === null) {\n        return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n    }\n    else if (dep.attributeNameType === null) {\n        // Build up the injection flags according to the metadata.\n        const flags = 0 /* InjectFlags.Default */ | (dep.self ? 2 /* InjectFlags.Self */ : 0) |\n            (dep.skipSelf ? 4 /* InjectFlags.SkipSelf */ : 0) | (dep.host ? 1 /* InjectFlags.Host */ : 0) |\n            (dep.optional ? 8 /* InjectFlags.Optional */ : 0) |\n            (target === FactoryTarget$1.Pipe ? 16 /* InjectFlags.ForPipe */ : 0);\n        // If this dependency is optional or otherwise has non-default flags, then additional\n        // parameters describing how to inject the dependency must be passed to the inject function\n        // that's being used.\n        let flagsParam = (flags !== 0 /* InjectFlags.Default */ || dep.optional) ? literal(flags) : null;\n        // Build up the arguments to the injectFn call.\n        const injectArgs = [dep.token];\n        if (flagsParam) {\n            injectArgs.push(flagsParam);\n        }\n        const injectFn = getInjectFn(target);\n        return importExpr(injectFn).callFn(injectArgs);\n    }\n    else {\n        // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n        // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n        // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n        // we want to generate `injectAttribute(foo())`.\n        //\n        // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n        // typings.\n        return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n    }\n}\nfunction createCtorDepsType(deps) {\n    let hasTypes = false;\n    const attributeTypes = deps.map(dep => {\n        const type = createCtorDepType(dep);\n        if (type !== null) {\n            hasTypes = true;\n            return type;\n        }\n        else {\n            return literal(null);\n        }\n    });\n    if (hasTypes) {\n        return expressionType(literalArr(attributeTypes));\n    }\n    else {\n        return NONE_TYPE;\n    }\n}\nfunction createCtorDepType(dep) {\n    const entries = [];\n    if (dep.attributeNameType !== null) {\n        entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });\n    }\n    if (dep.optional) {\n        entries.push({ key: 'optional', value: literal(true), quoted: false });\n    }\n    if (dep.host) {\n        entries.push({ key: 'host', value: literal(true), quoted: false });\n    }\n    if (dep.self) {\n        entries.push({ key: 'self', value: literal(true), quoted: false });\n    }\n    if (dep.skipSelf) {\n        entries.push({ key: 'skipSelf', value: literal(true), quoted: false });\n    }\n    return entries.length > 0 ? literalMap(entries) : null;\n}\nfunction isDelegatedFactoryMetadata(meta) {\n    return meta.delegateType !== undefined;\n}\nfunction isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n}\nfunction getInjectFn(target) {\n    switch (target) {\n        case FactoryTarget$1.Component:\n        case FactoryTarget$1.Directive:\n        case FactoryTarget$1.Pipe:\n            return Identifiers.directiveInject;\n        case FactoryTarget$1.NgModule:\n        case FactoryTarget$1.Injectable:\n        default:\n            return Identifiers.inject;\n    }\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nclass Comment$1 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(_visitor) {\n        throw new Error('visit() not implemented for Comment');\n    }\n}\nclass Text$3 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass BoundText {\n    constructor(value, sourceSpan, i18n) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitBoundText(this);\n    }\n}\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nclass TextAttribute {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTextAttribute(this);\n    }\n}\nclass BoundAttribute {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.i18n = i18n;\n    }\n    static fromBoundElementProperty(prop, i18n) {\n        if (prop.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\n        }\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n    }\n    visit(visitor) {\n        return visitor.visitBoundAttribute(this);\n    }\n}\nclass BoundEvent {\n    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.type = type;\n        this.handler = handler;\n        this.target = target;\n        this.phase = phase;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n    static fromParsedEvent(event) {\n        const target = event.type === 0 /* ParsedEventType.Regular */ ? event.targetOrPhase : null;\n        const phase = event.type === 1 /* ParsedEventType.Animation */ ? event.targetOrPhase : null;\n        if (event.keySpan === undefined) {\n            throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\n        }\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n    }\n    visit(visitor) {\n        return visitor.visitBoundEvent(this);\n    }\n}\nclass Element$1 {\n    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.name = name;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.children = children;\n        this.references = references;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitElement(this);\n    }\n}\nclass Template {\n    constructor(\n    // tagName is the name of the container element, if applicable.\n    // `null` is a special case for when there is a structural directive on an `ng-template` so\n    // the renderer can differentiate between the synthetic template and the one written in the\n    // file.\n    tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n        this.tagName = tagName;\n        this.attributes = attributes;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.templateAttrs = templateAttrs;\n        this.children = children;\n        this.references = references;\n        this.variables = variables;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitTemplate(this);\n    }\n}\nclass Content {\n    constructor(selector, attributes, sourceSpan, i18n) {\n        this.selector = selector;\n        this.attributes = attributes;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n        this.name = 'ng-content';\n    }\n    visit(visitor) {\n        return visitor.visitContent(this);\n    }\n}\nclass Variable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitVariable(this);\n    }\n}\nclass Reference {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n    visit(visitor) {\n        return visitor.visitReference(this);\n    }\n}\nclass Icu$1 {\n    constructor(vars, placeholders, sourceSpan, i18n) {\n        this.vars = vars;\n        this.placeholders = placeholders;\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n    visit(visitor) {\n        return visitor.visitIcu(this);\n    }\n}\nclass NullVisitor {\n    visitElement(element) { }\n    visitTemplate(template) { }\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\nclass RecursiveVisitor$1 {\n    visitElement(element) {\n        visitAll$1(this, element.attributes);\n        visitAll$1(this, element.inputs);\n        visitAll$1(this, element.outputs);\n        visitAll$1(this, element.children);\n        visitAll$1(this, element.references);\n    }\n    visitTemplate(template) {\n        visitAll$1(this, template.attributes);\n        visitAll$1(this, template.inputs);\n        visitAll$1(this, template.outputs);\n        visitAll$1(this, template.children);\n        visitAll$1(this, template.references);\n        visitAll$1(this, template.variables);\n    }\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\nclass TransformVisitor {\n    visitElement(element) {\n        const newAttributes = transformAll(this, element.attributes);\n        const newInputs = transformAll(this, element.inputs);\n        const newOutputs = transformAll(this, element.outputs);\n        const newChildren = transformAll(this, element.children);\n        const newReferences = transformAll(this, element.references);\n        if (newAttributes != element.attributes || newInputs != element.inputs ||\n            newOutputs != element.outputs || newChildren != element.children ||\n            newReferences != element.references) {\n            return new Element$1(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n        }\n        return element;\n    }\n    visitTemplate(template) {\n        const newAttributes = transformAll(this, template.attributes);\n        const newInputs = transformAll(this, template.inputs);\n        const newOutputs = transformAll(this, template.outputs);\n        const newTemplateAttrs = transformAll(this, template.templateAttrs);\n        const newChildren = transformAll(this, template.children);\n        const newReferences = transformAll(this, template.references);\n        const newVariables = transformAll(this, template.variables);\n        if (newAttributes != template.attributes || newInputs != template.inputs ||\n            newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n            newChildren != template.children || newReferences != template.references ||\n            newVariables != template.variables) {\n            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n        }\n        return template;\n    }\n    visitContent(content) {\n        return content;\n    }\n    visitVariable(variable) {\n        return variable;\n    }\n    visitReference(reference) {\n        return reference;\n    }\n    visitTextAttribute(attribute) {\n        return attribute;\n    }\n    visitBoundAttribute(attribute) {\n        return attribute;\n    }\n    visitBoundEvent(attribute) {\n        return attribute;\n    }\n    visitText(text) {\n        return text;\n    }\n    visitBoundText(text) {\n        return text;\n    }\n    visitIcu(icu) {\n        return icu;\n    }\n}\nfunction visitAll$1(visitor, nodes) {\n    const result = [];\n    if (visitor.visit) {\n        for (const node of nodes) {\n            const newNode = visitor.visit(node) || node.visit(visitor);\n        }\n    }\n    else {\n        for (const node of nodes) {\n            const newNode = node.visit(visitor);\n            if (newNode) {\n                result.push(newNode);\n            }\n        }\n    }\n    return result;\n}\nfunction transformAll(visitor, nodes) {\n    const result = [];\n    let changed = false;\n    for (const node of nodes) {\n        const newNode = node.visit(visitor);\n        if (newNode) {\n            result.push(newNode);\n        }\n        changed = changed || newNode != node;\n    }\n    return changed ? result : nodes;\n}\n\nclass Message {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content and their source spans\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param customId\n     */\n    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n        this.nodes = nodes;\n        this.placeholders = placeholders;\n        this.placeholderToMessage = placeholderToMessage;\n        this.meaning = meaning;\n        this.description = description;\n        this.customId = customId;\n        this.id = this.customId;\n        /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n        this.legacyIds = [];\n        this.messageString = serializeMessage(this.nodes);\n        if (nodes.length) {\n            this.sources = [{\n                    filePath: nodes[0].sourceSpan.start.file.url,\n                    startLine: nodes[0].sourceSpan.start.line + 1,\n                    startCol: nodes[0].sourceSpan.start.col + 1,\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n                    endCol: nodes[0].sourceSpan.start.col + 1\n                }];\n        }\n        else {\n            this.sources = [];\n        }\n    }\n}\nclass Text$2 {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\n// TODO(vicb): do we really need this node (vs an array) ?\nclass Container {\n    constructor(children, sourceSpan) {\n        this.children = children;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitContainer(this, context);\n    }\n}\nclass Icu {\n    constructor(expression, type, cases, sourceSpan) {\n        this.expression = expression;\n        this.type = type;\n        this.cases = cases;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcu(this, context);\n    }\n}\nclass TagPlaceholder {\n    constructor(tag, attrs, startName, closeName, children, isVoid, \n    // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n    sourceSpan, startSourceSpan, endSourceSpan) {\n        this.tag = tag;\n        this.attrs = attrs;\n        this.startName = startName;\n        this.closeName = closeName;\n        this.children = children;\n        this.isVoid = isVoid;\n        this.sourceSpan = sourceSpan;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitTagPlaceholder(this, context);\n    }\n}\nclass Placeholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitPlaceholder(this, context);\n    }\n}\nclass IcuPlaceholder {\n    constructor(value, name, sourceSpan) {\n        this.value = value;\n        this.name = name;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitIcuPlaceholder(this, context);\n    }\n}\n// Clone the AST\nclass CloneVisitor {\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitContainer(container, context) {\n        const children = container.children.map(n => n.visit(this, context));\n        return new Container(children, container.sourceSpan);\n    }\n    visitIcu(icu, context) {\n        const cases = {};\n        Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n        const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\n        return msg;\n    }\n    visitTagPlaceholder(ph, context) {\n        const children = ph.children.map(n => n.visit(this, context));\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, context) {\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n}\n// Visit all the nodes recursively\nclass RecurseVisitor {\n    visitText(text, context) { }\n    visitContainer(container, context) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu, context) {\n        Object.keys(icu.cases).forEach(k => {\n            icu.cases[k].visit(this);\n        });\n    }\n    visitTagPlaceholder(ph, context) {\n        ph.children.forEach(child => child.visit(this));\n    }\n    visitPlaceholder(ph, context) { }\n    visitIcuPlaceholder(ph, context) { }\n}\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes) {\n    const visitor = new LocalizeMessageStringVisitor();\n    const str = messageNodes.map(n => n.visit(visitor)).join('');\n    return str;\n}\nclass LocalizeMessageStringVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n    }\n    visitTagPlaceholder(ph) {\n        const children = ph.children.map(child => child.visit(this)).join('');\n        return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n    }\n    visitPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n    visitIcuPlaceholder(ph) {\n        return `{$${ph.name}}`;\n    }\n}\n\nclass Serializer {\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    createNameMapper(message) {\n        return null;\n    }\n}\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nclass SimplePlaceholderMapper extends RecurseVisitor {\n    // create a mapping from the message\n    constructor(message, mapName) {\n        super();\n        this.mapName = mapName;\n        this.internalToPublic = {};\n        this.publicToNextId = {};\n        this.publicToInternal = {};\n        message.nodes.forEach(node => node.visit(this));\n    }\n    toPublicName(internalName) {\n        return this.internalToPublic.hasOwnProperty(internalName) ?\n            this.internalToPublic[internalName] :\n            null;\n    }\n    toInternalName(publicName) {\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n            null;\n    }\n    visitText(text, context) {\n        return null;\n    }\n    visitTagPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.startName);\n        super.visitTagPlaceholder(ph, context);\n        this.visitPlaceholderName(ph.closeName);\n    }\n    visitPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        this.visitPlaceholderName(ph.name);\n    }\n    // XMB placeholders could only contains A-Z, 0-9 and _\n    visitPlaceholderName(internalName) {\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n            return;\n        }\n        let publicName = this.mapName(internalName);\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\n            // Create a new XMB when it has already been used\n            const nextId = this.publicToNextId[publicName];\n            this.publicToNextId[publicName] = nextId + 1;\n            publicName = `${publicName}_${nextId}`;\n        }\n        else {\n            this.publicToNextId[publicName] = 1;\n        }\n        this.internalToPublic[internalName] = publicName;\n        this.publicToInternal[publicName] = internalName;\n    }\n}\n\nclass _Visitor$2 {\n    visitTag(tag) {\n        const strAttrs = this._serializeAttributes(tag.attrs);\n        if (tag.children.length == 0) {\n            return `<${tag.name}${strAttrs}/>`;\n        }\n        const strChildren = tag.children.map(node => node.visit(this));\n        return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitDeclaration(decl) {\n        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n    }\n    _serializeAttributes(attrs) {\n        const strAttrs = Object.keys(attrs).map((name) => `${name}=\"${attrs[name]}\"`).join(' ');\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n    visitDoctype(doctype) {\n        return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n    }\n}\nconst _visitor = new _Visitor$2();\nfunction serialize(nodes) {\n    return nodes.map((node) => node.visit(_visitor)).join('');\n}\nclass Declaration {\n    constructor(unescapedAttrs) {\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitDeclaration(this);\n    }\n}\nclass Doctype {\n    constructor(rootTag, dtd) {\n        this.rootTag = rootTag;\n        this.dtd = dtd;\n    }\n    visit(visitor) {\n        return visitor.visitDoctype(this);\n    }\n}\nclass Tag {\n    constructor(name, unescapedAttrs = {}, children = []) {\n        this.name = name;\n        this.children = children;\n        this.attrs = {};\n        Object.keys(unescapedAttrs).forEach((k) => {\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\n        });\n    }\n    visit(visitor) {\n        return visitor.visitTag(this);\n    }\n}\nclass Text$1 {\n    constructor(unescapedValue) {\n        this.value = escapeXml(unescapedValue);\n    }\n    visit(visitor) {\n        return visitor.visitText(this);\n    }\n}\nclass CR extends Text$1 {\n    constructor(ws = 0) {\n        super(`\\n${new Array(ws + 1).join(' ')}`);\n    }\n}\nconst _ESCAPED_CHARS = [\n    [/&/g, '&amp;'],\n    [/\"/g, '&quot;'],\n    [/'/g, '&apos;'],\n    [/</g, '&lt;'],\n    [/>/g, '&gt;'],\n];\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nfunction escapeXml(text) {\n    return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\n}\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG$3 = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG$2 = 'source';\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\nclass Xmb extends Serializer {\n    write(messages, locale) {\n        const exampleVisitor = new ExampleVisitor();\n        const visitor = new _Visitor$1();\n        let rootNode = new Tag(_MESSAGES_TAG);\n        messages.forEach(message => {\n            const attrs = { id: message.id };\n            if (message.description) {\n                attrs['desc'] = message.description;\n            }\n            if (message.meaning) {\n                attrs['meaning'] = message.meaning;\n            }\n            let sourceTags = [];\n            message.sources.forEach((source) => {\n                sourceTags.push(new Tag(_SOURCE_TAG$2, {}, [new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n            });\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n        });\n        rootNode.children.push(new CR());\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\n            new CR(),\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\n            new CR(),\n            exampleVisitor.addDefaultExamples(rootNode),\n            new CR(),\n        ]);\n    }\n    load(content, url) {\n        throw new Error('Unsupported');\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nclass _Visitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const startTagAsText = new Text$1(`<${ph.tag}>`);\n        const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.startName }, [startEx, startTagAsText]);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [startTagPh];\n        }\n        const closeTagAsText = new Text$1(`</${ph.tag}>`);\n        const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$3, { name: ph.closeName }, [closeEx, closeTagAsText]);\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        const interpolationAsText = new Text$1(`{{${ph.value}}}`);\n        // Example tag needs to be not-empty for TC.\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, interpolationAsText])\n        ];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const icuExpression = ph.value.expression;\n        const icuType = ph.value.type;\n        const icuCases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const icuAsText = new Text$1(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n        return [\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n            new Tag(_PLACEHOLDER_TAG$3, { name: ph.name }, [exTag, icuAsText])\n        ];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\nfunction digest(message) {\n    return decimalDigest(message);\n}\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor {\n    addDefaultExamples(node) {\n        node.visit(this);\n        return node;\n    }\n    visitTag(tag) {\n        if (tag.name === _PLACEHOLDER_TAG$3) {\n            if (!tag.children || tag.children.length == 0) {\n                const exText = new Text$1(tag.attrs['name'] || '...');\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n            }\n        }\n        else if (tag.children) {\n            tag.children.forEach(node => node.visit(this));\n        }\n    }\n    visitText(text) { }\n    visitDeclaration(decl) { }\n    visitDoctype(doctype) { }\n}\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nfunction toPublicName(internalName) {\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\n/** Name of the i18n attributes **/\nconst I18N_ATTR = 'i18n';\nconst I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\nconst I18N_PLACEHOLDER_SYMBOL = '';\nfunction isI18nAttribute(name) {\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\nfunction isI18nRootNode(meta) {\n    return meta instanceof Message;\n}\nfunction isSingleI18nIcu(meta) {\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu;\n}\nfunction hasI18nMeta(node) {\n    return !!node.i18n;\n}\nfunction hasI18nAttrs(element) {\n    return element.attrs.some((attr) => isI18nAttribute(attr.name));\n}\nfunction icuFromI18nMessage(message) {\n    return message.nodes[0];\n}\nfunction wrapI18nPlaceholder(content, contextId = 0) {\n    const blockId = contextId > 0 ? `:${contextId}` : '';\n    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\nfunction assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {\n    if (!strings.length)\n        return '';\n    let acc = '';\n    const lastIdx = strings.length - 1;\n    for (let i = 0; i < lastIdx; i++) {\n        acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n    }\n    acc += strings[lastIdx];\n    return acc;\n}\nfunction getSeqNumberGenerator(startsAt = 0) {\n    let current = startsAt;\n    return () => current++;\n}\nfunction placeholdersToParams(placeholders) {\n    const params = {};\n    placeholders.forEach((values, key) => {\n        params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n    });\n    return params;\n}\nfunction updatePlaceholderMap(map, name, ...values) {\n    const current = map.get(name) || [];\n    current.push(...values);\n    map.set(name, current);\n}\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {\n    const startIdx = bindingStartIndex;\n    const placeholders = new Map();\n    const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;\n    if (node) {\n        node\n            .children\n            .filter((child) => child instanceof Placeholder)\n            .forEach((child, idx) => {\n            const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n            updatePlaceholderMap(placeholders, child.name, content);\n        });\n    }\n    return placeholders;\n}\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nfunction formatI18nPlaceholderNamesInMap(params = {}, useCamelCase) {\n    const _params = {};\n    if (params && Object.keys(params).length) {\n        Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n    }\n    return _params;\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\n    const publicName = toPublicName(name);\n    if (!useCamelCase) {\n        return publicName;\n    }\n    const chunks = publicName.split('_');\n    if (chunks.length === 1) {\n        // if no \"_\" found - just lowercase the value\n        return name.toLowerCase();\n    }\n    let postfix;\n    // eject last element if it's a number\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n        postfix = chunks.pop();\n    }\n    let raw = chunks.shift().toLowerCase();\n    if (chunks.length) {\n        raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n    }\n    return postfix ? `${raw}_${postfix}` : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nfunction getTranslationConstPrefix(extra) {\n    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nfunction declareI18nVariable(variable) {\n    return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\nconst TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\nconst CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\nconst RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\nconst REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\nconst IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\nconst NON_BINDABLE_ATTR = 'ngNonBindable';\n/** Name for the variable keeping track of the context returned by `restoreView`. */\nconst RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n/**\n * Maximum length of a single instruction chain. Because our output AST uses recursion, we're\n * limited in how many expressions we can nest before we reach the call stack limit. This\n * length is set very conservatively in order to reduce the chance of problems.\n */\nconst MAX_CHAIN_LENGTH = 500;\n/** Instructions that support chaining. */\nconst CHAINABLE_INSTRUCTIONS = new Set([\n    Identifiers.element,\n    Identifiers.elementStart,\n    Identifiers.elementEnd,\n    Identifiers.elementContainer,\n    Identifiers.elementContainerStart,\n    Identifiers.elementContainerEnd,\n    Identifiers.i18nExp,\n    Identifiers.listener,\n    Identifiers.classProp,\n    Identifiers.syntheticHostListener,\n    Identifiers.hostProperty,\n    Identifiers.syntheticHostProperty,\n    Identifiers.property,\n    Identifiers.propertyInterpolate1,\n    Identifiers.propertyInterpolate2,\n    Identifiers.propertyInterpolate3,\n    Identifiers.propertyInterpolate4,\n    Identifiers.propertyInterpolate5,\n    Identifiers.propertyInterpolate6,\n    Identifiers.propertyInterpolate7,\n    Identifiers.propertyInterpolate8,\n    Identifiers.propertyInterpolateV,\n    Identifiers.attribute,\n    Identifiers.attributeInterpolate1,\n    Identifiers.attributeInterpolate2,\n    Identifiers.attributeInterpolate3,\n    Identifiers.attributeInterpolate4,\n    Identifiers.attributeInterpolate5,\n    Identifiers.attributeInterpolate6,\n    Identifiers.attributeInterpolate7,\n    Identifiers.attributeInterpolate8,\n    Identifiers.attributeInterpolateV,\n    Identifiers.styleProp,\n    Identifiers.stylePropInterpolate1,\n    Identifiers.stylePropInterpolate2,\n    Identifiers.stylePropInterpolate3,\n    Identifiers.stylePropInterpolate4,\n    Identifiers.stylePropInterpolate5,\n    Identifiers.stylePropInterpolate6,\n    Identifiers.stylePropInterpolate7,\n    Identifiers.stylePropInterpolate8,\n    Identifiers.stylePropInterpolateV,\n    Identifiers.textInterpolate,\n    Identifiers.textInterpolate1,\n    Identifiers.textInterpolate2,\n    Identifiers.textInterpolate3,\n    Identifiers.textInterpolate4,\n    Identifiers.textInterpolate5,\n    Identifiers.textInterpolate6,\n    Identifiers.textInterpolate7,\n    Identifiers.textInterpolate8,\n    Identifiers.textInterpolateV,\n]);\n/** Generates a call to a single instruction. */\nfunction invokeInstruction(span, reference, params) {\n    return importExpr(reference, null, span).callFn(params, span);\n}\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nfunction temporaryAllocator(statements, name) {\n    let temp = null;\n    return () => {\n        if (!temp) {\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n            temp = variable(name);\n        }\n        return temp;\n    };\n}\nfunction invalid(arg) {\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\nfunction asLiteral(value) {\n    if (Array.isArray(value)) {\n        return literalArr(value.map(asLiteral));\n    }\n    return literal(value, INFERRED_TYPE);\n}\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n        return mapToExpression(keys, keepDeclared);\n    }\n    return null;\n}\nfunction mapToExpression(map, keepDeclared) {\n    return literalMap(Object.getOwnPropertyNames(map).map(key => {\n        // canonical syntax: `dirProp: publicProp`\n        const value = map[key];\n        let declaredName;\n        let publicName;\n        let minifiedName;\n        let needsDeclaredName;\n        if (Array.isArray(value)) {\n            [publicName, declaredName] = value;\n            minifiedName = key;\n            needsDeclaredName = publicName !== declaredName;\n        }\n        else {\n            minifiedName = declaredName = key;\n            publicName = value;\n            needsDeclaredName = false;\n        }\n        return {\n            key: minifiedName,\n            // put quotes around keys that contain potentially unsafe characters\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n            value: (keepDeclared && needsDeclaredName) ?\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n                asLiteral(publicName)\n        };\n    }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\nfunction trimTrailingNulls(parameters) {\n    while (isNull(parameters[parameters.length - 1])) {\n        parameters.pop();\n    }\n    return parameters;\n}\nfunction getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n        let predicate = [];\n        query.predicate.forEach((selector) => {\n            // Each item in predicates array may contain strings with comma-separated refs\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n            // as separate array entities\n            const selectors = selector.split(',').map(token => literal(token.trim()));\n            predicate.push(...selectors);\n        });\n        return constantPool.getConstLiteral(literalArr(predicate), true);\n    }\n    else {\n        // The original predicate may have been wrapped in a `forwardRef()` call.\n        switch (query.predicate.forwardRef) {\n            case 0 /* ForwardRefHandling.None */:\n            case 2 /* ForwardRefHandling.Unwrapped */:\n                return query.predicate.expression;\n            case 1 /* ForwardRefHandling.Wrapped */:\n                return importExpr(Identifiers.resolveForwardRef).callFn([query.predicate.expression]);\n        }\n    }\n}\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nclass DefinitionMap {\n    constructor() {\n        this.values = [];\n    }\n    set(key, value) {\n        if (value) {\n            this.values.push({ key: key, value, quoted: false });\n        }\n    }\n    toLiteralMap() {\n        return literalMap(this.values);\n    }\n}\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n    const attributesMap = {};\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n        elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n    }\n    else {\n        elOrTpl.attributes.forEach(a => {\n            if (!isI18nAttribute(a.name)) {\n                attributesMap[a.name] = a.value;\n            }\n        });\n        elOrTpl.inputs.forEach(i => {\n            attributesMap[i.name] = '';\n        });\n        elOrTpl.outputs.forEach(o => {\n            attributesMap[o.name] = '';\n        });\n    }\n    return attributesMap;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nfunction getInterpolationArgsLength(interpolation) {\n    const { expressions, strings } = interpolation;\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n        // `textInterpolate`.\n        return 1;\n    }\n    else {\n        return expressions.length + strings.length;\n    }\n}\n/**\n * Generates the final instruction call statements based on the passed in configuration.\n * Will try to chain instructions as much as possible, if chaining is supported.\n */\nfunction getInstructionStatements(instructions) {\n    const statements = [];\n    let pendingExpression = null;\n    let pendingExpressionType = null;\n    let chainLength = 0;\n    for (const current of instructions) {\n        const resolvedParams = (typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn) ??\n            [];\n        const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];\n        // If the current instruction is the same as the previous one\n        // and it can be chained, add another call to the chain.\n        if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference &&\n            CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {\n            // We'll always have a pending expression when there's a pending expression type.\n            pendingExpression = pendingExpression.callFn(params, pendingExpression.sourceSpan);\n            chainLength++;\n        }\n        else {\n            if (pendingExpression !== null) {\n                statements.push(pendingExpression.toStmt());\n            }\n            pendingExpression = invokeInstruction(current.span, current.reference, params);\n            pendingExpressionType = current.reference;\n            chainLength = 0;\n        }\n    }\n    // Since the current instruction adds the previous one to the statements,\n    // we may be left with the final one at the end that is still pending.\n    if (pendingExpression !== null) {\n        statements.push(pendingExpression.toStmt());\n    }\n    return statements;\n}\n\nfunction compileInjectable(meta, resolveForwardRefs) {\n    let result = null;\n    const factoryMeta = {\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: [],\n        target: FactoryTarget$1.Injectable,\n    };\n    if (meta.useClass !== undefined) {\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n        // used to instantiate the class with dependencies injected, or deps are not specified and\n        // the factory of the class is used to instantiate it.\n        //\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\n        // deps are specified, in which case 'useClass' is effectively ignored.\n        const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n        let deps = undefined;\n        if (meta.deps !== undefined) {\n            deps = meta.deps;\n        }\n        if (deps !== undefined) {\n            // factory: () => new meta.useClass(...deps)\n            result = compileFactoryFunction({\n                ...factoryMeta,\n                delegate: meta.useClass.expression,\n                delegateDeps: deps,\n                delegateType: R3FactoryDelegateType.Class,\n            });\n        }\n        else if (useClassOnSelf) {\n            result = compileFactoryFunction(factoryMeta);\n        }\n        else {\n            result = {\n                statements: [],\n                expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n            };\n        }\n    }\n    else if (meta.useFactory !== undefined) {\n        if (meta.deps !== undefined) {\n            result = compileFactoryFunction({\n                ...factoryMeta,\n                delegate: meta.useFactory,\n                delegateDeps: meta.deps || [],\n                delegateType: R3FactoryDelegateType.Function,\n            });\n        }\n        else {\n            result = {\n                statements: [],\n                expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n            };\n        }\n    }\n    else if (meta.useValue !== undefined) {\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n        // client code because meta.useValue is an Expression which will be defined even if the actual\n        // value is undefined.\n        result = compileFactoryFunction({\n            ...factoryMeta,\n            expression: meta.useValue.expression,\n        });\n    }\n    else if (meta.useExisting !== undefined) {\n        // useExisting is an `inject` call on the existing token.\n        result = compileFactoryFunction({\n            ...factoryMeta,\n            expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n        });\n    }\n    else {\n        result = {\n            statements: [],\n            expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)\n        };\n    }\n    const token = meta.internalType;\n    const injectableProps = new DefinitionMap();\n    injectableProps.set('token', token);\n    injectableProps.set('factory', result.expression);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn.expression.value !== null) {\n        injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n    }\n    const expression = importExpr(Identifiers.defineInjectable)\n        .callFn([injectableProps.toLiteralMap()], undefined, true);\n    return {\n        expression,\n        type: createInjectableType(meta),\n        statements: result.statements,\n    };\n}\nfunction createInjectableType(meta) {\n    return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\nfunction delegateToFactory(type, internalType, unwrapForwardRefs) {\n    if (type.node === internalType.node) {\n        // The types are the same, so we can simply delegate directly to the type's factory.\n        // ```\n        // factory: type.fac\n        // ```\n        return internalType.prop('fac');\n    }\n    if (!unwrapForwardRefs) {\n        // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n        // accepts a sub-type as an argument.\n        // ```\n        // factory: function(t) { return internalType.fac(t); }\n        // ```\n        return createFactoryFunction(internalType);\n    }\n    // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n    // calling its factory.\n    // ```\n    // factory: function(t) { return core.resolveForwardRef(type).fac(t); }\n    // ```\n    const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\n    return createFactoryFunction(unwrappedType);\n}\nfunction createFactoryFunction(type) {\n    return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.prop('fac').callFn([variable('t')]))]);\n}\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n    /^\\s*$/,\n    /[<>]/,\n    /^[{}]$/,\n    /&(#|[a-z])/i,\n    /^\\/\\//, // comment\n];\nfunction assertInterpolationSymbols(identifier, value) {\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n    }\n    else if (value != null) {\n        const start = value[0];\n        const end = value[1];\n        // Check for unusable interpolation symbols\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n            if (regexp.test(start) || regexp.test(end)) {\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n            }\n        });\n    }\n}\n\nclass InterpolationConfig {\n    static fromArray(markers) {\n        if (!markers) {\n            return DEFAULT_INTERPOLATION_CONFIG;\n        }\n        assertInterpolationSymbols('interpolation', markers);\n        return new InterpolationConfig(markers[0], markers[1]);\n    }\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n\nconst $EOF = 0;\nconst $BSPACE = 8;\nconst $TAB = 9;\nconst $LF = 10;\nconst $VTAB = 11;\nconst $FF = 12;\nconst $CR = 13;\nconst $SPACE = 32;\nconst $BANG = 33;\nconst $DQ = 34;\nconst $HASH = 35;\nconst $$ = 36;\nconst $PERCENT = 37;\nconst $AMPERSAND = 38;\nconst $SQ = 39;\nconst $LPAREN = 40;\nconst $RPAREN = 41;\nconst $STAR = 42;\nconst $PLUS = 43;\nconst $COMMA = 44;\nconst $MINUS = 45;\nconst $PERIOD = 46;\nconst $SLASH = 47;\nconst $COLON = 58;\nconst $SEMICOLON = 59;\nconst $LT = 60;\nconst $EQ = 61;\nconst $GT = 62;\nconst $QUESTION = 63;\nconst $0 = 48;\nconst $7 = 55;\nconst $9 = 57;\nconst $A = 65;\nconst $E = 69;\nconst $F = 70;\nconst $X = 88;\nconst $Z = 90;\nconst $LBRACKET = 91;\nconst $BACKSLASH = 92;\nconst $RBRACKET = 93;\nconst $CARET = 94;\nconst $_ = 95;\nconst $a = 97;\nconst $b = 98;\nconst $e = 101;\nconst $f = 102;\nconst $n = 110;\nconst $r = 114;\nconst $t = 116;\nconst $u = 117;\nconst $v = 118;\nconst $x = 120;\nconst $z = 122;\nconst $LBRACE = 123;\nconst $BAR = 124;\nconst $RBRACE = 125;\nconst $NBSP = 160;\nconst $PIPE = 124;\nconst $TILDA = 126;\nconst $AT = 64;\nconst $BT = 96;\nfunction isWhitespace(code) {\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\nfunction isDigit(code) {\n    return $0 <= code && code <= $9;\n}\nfunction isAsciiLetter(code) {\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\nfunction isAsciiHexDigit(code) {\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\nfunction isNewLine(code) {\n    return code === $LF || code === $CR;\n}\nfunction isOctalDigit(code) {\n    return $0 <= code && code <= $7;\n}\nfunction isQuote(code) {\n    return code === $SQ || code === $DQ || code === $BT;\n}\n\nclass ParseLocation {\n    constructor(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n    }\n    toString() {\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n    }\n    moveBy(delta) {\n        const source = this.file.content;\n        const len = source.length;\n        let offset = this.offset;\n        let line = this.line;\n        let col = this.col;\n        while (offset > 0 && delta < 0) {\n            offset--;\n            delta++;\n            const ch = source.charCodeAt(offset);\n            if (ch == $LF) {\n                line--;\n                const priorLine = source.substring(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n                col = priorLine > 0 ? offset - priorLine : offset;\n            }\n            else {\n                col--;\n            }\n        }\n        while (offset < len && delta > 0) {\n            const ch = source.charCodeAt(offset);\n            offset++;\n            delta--;\n            if (ch == $LF) {\n                line++;\n                col = 0;\n            }\n            else {\n                col++;\n            }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n    }\n    // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n    getContext(maxChars, maxLines) {\n        const content = this.file.content;\n        let startOffset = this.offset;\n        if (startOffset != null) {\n            if (startOffset > content.length - 1) {\n                startOffset = content.length - 1;\n            }\n            let endOffset = startOffset;\n            let ctxChars = 0;\n            let ctxLines = 0;\n            while (ctxChars < maxChars && startOffset > 0) {\n                startOffset--;\n                ctxChars++;\n                if (content[startOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            ctxChars = 0;\n            ctxLines = 0;\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\n                endOffset++;\n                ctxChars++;\n                if (content[endOffset] == '\\n') {\n                    if (++ctxLines == maxLines) {\n                        break;\n                    }\n                }\n            }\n            return {\n                before: content.substring(startOffset, this.offset),\n                after: content.substring(this.offset, endOffset + 1),\n            };\n        }\n        return null;\n    }\n}\nclass ParseSourceFile {\n    constructor(content, url) {\n        this.content = content;\n        this.url = url;\n    }\n}\nclass ParseSourceSpan {\n    /**\n     * Create an object that holds information about spans of tokens/nodes captured during\n     * lexing/parsing of text.\n     *\n     * @param start\n     * The location of the start of the span (having skipped leading trivia).\n     * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n     * elements will appear to begin at the start of the opening tag, rather than at the start of any\n     * leading trivia, which could include newlines.\n     *\n     * @param end\n     * The location of the end of the span.\n     *\n     * @param fullStart\n     * The start of the token without skipping the leading trivia.\n     * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n     * from text tokens. Such tooling creates new source-spans relative to the original token's\n     * source-span. If leading trivia characters have been skipped then the new source-spans may be\n     * incorrectly offset.\n     *\n     * @param details\n     * Additional information (such as identifier names) that should be associated with the span.\n     */\n    constructor(start, end, fullStart = start, details = null) {\n        this.start = start;\n        this.end = end;\n        this.fullStart = fullStart;\n        this.details = details;\n    }\n    toString() {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n}\nvar ParseErrorLevel;\n(function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\nclass ParseError {\n    constructor(span, msg, level = ParseErrorLevel.ERROR) {\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n    }\n    contextualMessage() {\n        const ctx = this.span.start.getContext(100, 3);\n        return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n            this.msg;\n    }\n    toString() {\n        const details = this.span.details ? `, ${this.span.details}` : '';\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\n    }\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n    const sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\nlet _anonymousTypeIndex = 0;\nfunction identifierName(compileIdentifier) {\n    if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n    }\n    const ref = compileIdentifier.reference;\n    if (ref['__anonymousType']) {\n        return ref['__anonymousType'];\n    }\n    if (ref['__forward_ref__']) {\n        // We do not want to try to stringify a `forwardRef()` function because that would cause the\n        // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n        return '__forward_ref__';\n    }\n    let identifier = stringify(ref);\n    if (identifier.indexOf('(') >= 0) {\n        // case: anonymous functions!\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\n        ref['__anonymousType'] = identifier;\n    }\n    else {\n        identifier = sanitizeIdentifier(identifier);\n    }\n    return identifier;\n}\nfunction sanitizeIdentifier(name) {\n    return name.replace(/\\W/g, '_');\n}\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n    constructor() {\n        super(false);\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        ctx.print(stmt, `var ${stmt.name}`);\n        if (stmt.value) {\n            ctx.print(stmt, ' = ');\n            stmt.value.visitExpression(this, ctx);\n        }\n        ctx.println(stmt, `;`);\n        return null;\n    }\n    visitTaggedTemplateExpr(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // tag`...`\n        // ```\n        // which is effectively like:\n        // ```\n        // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        const elements = ast.template.elements;\n        ast.tag.visitExpression(this, ctx);\n        ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n        ast.template.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    visitFunctionExpr(ast, ctx) {\n        ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n        this._visitParams(ast.params, ctx);\n        ctx.println(ast, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(ast.statements, ctx);\n        ctx.decIndent();\n        ctx.print(ast, `}`);\n        return null;\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        ctx.print(stmt, `function ${stmt.name}(`);\n        this._visitParams(stmt.params, ctx);\n        ctx.println(stmt, `) {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.statements, ctx);\n        ctx.decIndent();\n        ctx.println(stmt, `}`);\n        return null;\n    }\n    visitLocalizedString(ast, ctx) {\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\n        // ```\n        // $localize `...`\n        // ```\n        // which is effectively like:\n        // ```\n        // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n        // ```\n        ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n        const parts = [ast.serializeI18nHead()];\n        for (let i = 1; i < ast.messageParts.length; i++) {\n            parts.push(ast.serializeI18nTemplatePart(i));\n        }\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n        ast.expressions.forEach(expression => {\n            ctx.print(ast, ', ');\n            expression.visitExpression(this, ctx);\n        });\n        ctx.print(ast, ')');\n        return null;\n    }\n    _visitParams(params, ctx) {\n        this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n    }\n}\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy;\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy() {\n    if (policy === undefined) {\n        policy = null;\n        if (_global.trustedTypes) {\n            try {\n                policy =\n                    _global.trustedTypes.createPolicy('angular#unsafe-jit', {\n                        createScript: (s) => s,\n                    });\n            }\n            catch {\n                // trustedTypes.createPolicy throws if called with a name that is\n                // already registered, even in report-only mode. Until the API changes,\n                // catch the error not to break the applications functionally. In such\n                // cases, the code will fall back to using strings.\n            }\n        }\n    }\n    return policy;\n}\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script) {\n    return getPolicy()?.createScript(script) || script;\n}\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nfunction newTrustedFunctionForJIT(...args) {\n    if (!_global.trustedTypes) {\n        // In environments that don't support Trusted Types, fall back to the most\n        // straightforward implementation:\n        return new Function(...args);\n    }\n    // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n    const fnArgs = args.slice(0, -1).join(',');\n    const fnBody = args[args.length - 1];\n    const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n    // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n    const fn = _global['eval'](trustedScriptFromString(body));\n    if (fn.bind === undefined) {\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\n        // a TrustedScript to eval just returns the TrustedScript back without\n        // evaluating it. In that case, fall back to the most straightforward\n        // implementation:\n        return new Function(...args);\n    }\n    // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n    fn.toString = () => body;\n    // 2. When calling the resulting function, `this` should refer to `global`\n    return fn.bind(_global);\n    // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nclass JitEvaluator {\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param refResolver Resolves `o.ExternalReference`s into values.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    evaluateStatements(sourceUrl, statements, refResolver, createSourceMaps) {\n        const converter = new JitEmitterVisitor(refResolver);\n        const ctx = EmitterVisitorContext.createRoot();\n        // Ensure generated code is in strict mode\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n            statements = [\n                literal('use strict').toStmt(),\n                ...statements,\n            ];\n        }\n        converter.visitAllStatements(statements, ctx);\n        converter.createReturnStmt(ctx);\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    }\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n        let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n        const fnArgNames = [];\n        const fnArgValues = [];\n        for (const argName in vars) {\n            fnArgValues.push(vars[argName]);\n            fnArgNames.push(argName);\n        }\n        if (createSourceMap) {\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n            // E.g. ```\n            // function anonymous(a,b,c\n            // /**/) { ... }```\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\n            const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n            const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n            fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n        }\n        const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n        return this.executeFunction(fn, fnArgValues);\n    }\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n    executeFunction(fn, args) {\n        return fn(...args);\n    }\n}\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\n    constructor(refResolver) {\n        super();\n        this.refResolver = refResolver;\n        this._evalArgNames = [];\n        this._evalArgValues = [];\n        this._evalExportedVars = [];\n    }\n    createReturnStmt(ctx) {\n        const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\n        stmt.visitStatement(this, ctx);\n    }\n    getArgs() {\n        const result = {};\n        for (let i = 0; i < this._evalArgNames.length; i++) {\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\n        }\n        return result;\n    }\n    visitExternalExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n        return null;\n    }\n    visitWrappedNodeExpr(ast, ctx) {\n        this._emitReferenceToExternal(ast, ast.node, ctx);\n        return null;\n    }\n    visitDeclareVarStmt(stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareVarStmt(stmt, ctx);\n    }\n    visitDeclareFunctionStmt(stmt, ctx) {\n        if (stmt.hasModifier(StmtModifier.Exported)) {\n            this._evalExportedVars.push(stmt.name);\n        }\n        return super.visitDeclareFunctionStmt(stmt, ctx);\n    }\n    _emitReferenceToExternal(ast, value, ctx) {\n        let id = this._evalArgValues.indexOf(value);\n        if (id === -1) {\n            id = this._evalArgValues.length;\n            this._evalArgValues.push(value);\n            const name = identifierName({ reference: value }) || 'val';\n            this._evalArgNames.push(`jit_${name}_${id}`);\n        }\n        ctx.print(ast, this._evalArgNames[id]);\n    }\n}\nfunction isUseStrictStatement(statement) {\n    return statement.isEquivalent(literal('use strict').toStmt());\n}\n\nfunction compileInjector(meta) {\n    const definitionMap = new DefinitionMap();\n    if (meta.providers !== null) {\n        definitionMap.set('providers', meta.providers);\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\nfunction createInjectorType(meta) {\n    return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nclass R3JitReflector {\n    constructor(context) {\n        this.context = context;\n    }\n    resolveExternalReference(ref) {\n        // This reflector only handles @angular/core imports.\n        if (ref.moduleName !== '@angular/core') {\n            throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n        }\n        if (!this.context.hasOwnProperty(ref.name)) {\n            throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\n        }\n        return this.context[ref.name];\n    }\n}\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nvar R3SelectorScopeMode;\n(function (R3SelectorScopeMode) {\n    /**\n     * Emit the declarations inline into the module definition.\n     *\n     * This option is useful in certain contexts where it's known that JIT support is required. The\n     * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n     * they are unused, but the NgModule is used.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"Inline\"] = 0] = \"Inline\";\n    /**\n     * Emit the declarations using a side effectful function call, `setNgModuleScope`, that is\n     * guarded with the `ngJitMode` flag.\n     *\n     * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n     * false, which allows unused directives and pipes to be tree-shaken.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"SideEffect\"] = 1] = \"SideEffect\";\n    /**\n     * Don't generate selector scopes at all.\n     *\n     * This is useful for contexts where JIT support is known to be unnecessary.\n     */\n    R3SelectorScopeMode[R3SelectorScopeMode[\"Omit\"] = 2] = \"Omit\";\n})(R3SelectorScopeMode || (R3SelectorScopeMode = {}));\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nfunction compileNgModule(meta) {\n    const { adjacentType, internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, selectorScopeMode, id } = meta;\n    const statements = [];\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', internalType);\n    if (bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n    }\n    if (selectorScopeMode === R3SelectorScopeMode.Inline) {\n        // If requested to emit scope information inline, pass the `declarations`, `imports` and\n        // `exports` to the `defineNgModule()` call directly.\n        if (declarations.length > 0) {\n            definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n        }\n        if (imports.length > 0) {\n            definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n        }\n        if (exports.length > 0) {\n            definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n        }\n    }\n    else if (selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n        // In this mode, scope information is not passed into `defineNgModule` as it\n        // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n        // patched onto the NgModule definition with a `setNgModuleScope` call that's guarded by the\n        // `ngJitMode` flag.\n        const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n        if (setNgModuleScopeCall !== null) {\n            statements.push(setNgModuleScopeCall);\n        }\n    }\n    else {\n        // Selector scope emit was not requested, so skip it.\n    }\n    if (schemas !== null && schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));\n    }\n    if (id !== null) {\n        definitionMap.set('id', id);\n        // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n        // NgModule ids.\n        statements.push(importExpr(Identifiers.registerNgModuleType).callFn([adjacentType, id]).toStmt());\n    }\n    const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements };\n}\n/**\n * This function is used in JIT mode to generate the call to `defineNgModule()` from a call to\n * `ngDeclareNgModule()`.\n */\nfunction compileNgModuleDeclarationExpression(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('type', new WrappedNodeExpr(meta.type));\n    if (meta.bootstrap !== undefined) {\n        definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n    }\n    if (meta.declarations !== undefined) {\n        definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n    }\n    if (meta.imports !== undefined) {\n        definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n    }\n    if (meta.exports !== undefined) {\n        definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n    }\n    if (meta.schemas !== undefined) {\n        definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n    }\n    if (meta.id !== undefined) {\n        definitionMap.set('id', new WrappedNodeExpr(meta.id));\n    }\n    return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\nfunction createNgModuleType({ type: moduleType, declarations, exports, imports, includeImportTypes, publicDeclarationTypes }) {\n    return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [\n        new ExpressionType(moduleType.type),\n        publicDeclarationTypes === null ? tupleTypeOf(declarations) :\n            tupleOfTypes(publicDeclarationTypes),\n        includeImportTypes ? tupleTypeOf(imports) : NONE_TYPE,\n        tupleTypeOf(exports),\n    ]));\n}\n/**\n * Generates a function call to `setNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta) {\n    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;\n    const scopeMap = new DefinitionMap();\n    if (declarations.length > 0) {\n        scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n    if (imports.length > 0) {\n        scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n    if (exports.length > 0) {\n        scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n    if (Object.keys(scopeMap.values).length === 0) {\n        return null;\n    }\n    // setNgModuleScope(...)\n    const fnCall = new InvokeFunctionExpr(\n    /* fn */ importExpr(Identifiers.setNgModuleScope), \n    /* args */ [moduleType, scopeMap.toLiteralMap()]);\n    // (ngJitMode guard) && setNgModuleScope(...)\n    const guardedCall = jitOnlyGuardedExpression(fnCall);\n    // function() { (ngJitMode guard) && setNgModuleScope(...); }\n    const iife = new FunctionExpr(\n    /* params */ [], \n    /* statements */ [guardedCall.toStmt()]);\n    // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n    const iifeCall = new InvokeFunctionExpr(\n    /* fn */ iife, \n    /* args */ []);\n    return iifeCall.toStmt();\n}\nfunction tupleTypeOf(exp) {\n    const types = exp.map(ref => typeofExpr(ref.type));\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\nfunction tupleOfTypes(types) {\n    const typeofTypes = types.map(type => typeofExpr(type));\n    return types.length > 0 ? expressionType(literalArr(typeofTypes)) : NONE_TYPE;\n}\n\nfunction compilePipeFromMetadata(metadata) {\n    const definitionMapValues = [];\n    // e.g. `name: 'myPipe'`\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\n    // e.g. `type: MyPipe`\n    definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });\n    // e.g. `pure: true`\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\n    if (metadata.isStandalone) {\n        definitionMapValues.push({ key: 'standalone', value: literal(true), quoted: false });\n    }\n    const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n    const type = createPipeType(metadata);\n    return { expression, type, statements: [] };\n}\nfunction createPipeType(metadata) {\n    return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [\n        typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\n        new ExpressionType(new LiteralExpr(metadata.isStandalone)),\n    ]));\n}\n\nvar R3TemplateDependencyKind;\n(function (R3TemplateDependencyKind) {\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Directive\"] = 0] = \"Directive\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"Pipe\"] = 1] = \"Pipe\";\n    R3TemplateDependencyKind[R3TemplateDependencyKind[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\n\nclass ParserError {\n    constructor(message, input, errLocation, ctxLocation) {\n        this.input = input;\n        this.errLocation = errLocation;\n        this.ctxLocation = ctxLocation;\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n    }\n}\nclass ParseSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n    toAbsolute(absoluteOffset) {\n        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    }\n}\nclass AST {\n    constructor(span, \n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    sourceSpan) {\n        this.span = span;\n        this.sourceSpan = sourceSpan;\n    }\n    toString() {\n        return 'AST';\n    }\n}\nclass ASTWithName extends AST {\n    constructor(span, sourceSpan, nameSpan) {\n        super(span, sourceSpan);\n        this.nameSpan = nameSpan;\n    }\n}\nclass EmptyExpr extends AST {\n    visit(visitor, context = null) {\n        // do nothing\n    }\n}\nclass ImplicitReceiver extends AST {\n    visit(visitor, context = null) {\n        return visitor.visitImplicitReceiver(this, context);\n    }\n}\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nclass ThisReceiver extends ImplicitReceiver {\n    visit(visitor, context = null) {\n        return visitor.visitThisReceiver?.(this, context);\n    }\n}\n/**\n * Multiple expressions separated by a semicolon.\n */\nclass Chain extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitChain(this, context);\n    }\n}\nclass Conditional extends AST {\n    constructor(span, sourceSpan, condition, trueExp, falseExp) {\n        super(span, sourceSpan);\n        this.condition = condition;\n        this.trueExp = trueExp;\n        this.falseExp = falseExp;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitConditional(this, context);\n    }\n}\nclass PropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyRead(this, context);\n    }\n}\nclass PropertyWrite extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name, value) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPropertyWrite(this, context);\n    }\n}\nclass SafePropertyRead extends ASTWithName {\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\n        super(span, sourceSpan, nameSpan);\n        this.receiver = receiver;\n        this.name = name;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafePropertyRead(this, context);\n    }\n}\nclass KeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedRead(this, context);\n    }\n}\nclass SafeKeyedRead extends AST {\n    constructor(span, sourceSpan, receiver, key) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafeKeyedRead(this, context);\n    }\n}\nclass KeyedWrite extends AST {\n    constructor(span, sourceSpan, receiver, key, value) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.key = key;\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitKeyedWrite(this, context);\n    }\n}\nclass BindingPipe extends ASTWithName {\n    constructor(span, sourceSpan, exp, name, args, nameSpan) {\n        super(span, sourceSpan, nameSpan);\n        this.exp = exp;\n        this.name = name;\n        this.args = args;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPipe(this, context);\n    }\n}\nclass LiteralPrimitive extends AST {\n    constructor(span, sourceSpan, value) {\n        super(span, sourceSpan);\n        this.value = value;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralPrimitive(this, context);\n    }\n}\nclass LiteralArray extends AST {\n    constructor(span, sourceSpan, expressions) {\n        super(span, sourceSpan);\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralArray(this, context);\n    }\n}\nclass LiteralMap extends AST {\n    constructor(span, sourceSpan, keys, values) {\n        super(span, sourceSpan);\n        this.keys = keys;\n        this.values = values;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitLiteralMap(this, context);\n    }\n}\nclass Interpolation extends AST {\n    constructor(span, sourceSpan, strings, expressions) {\n        super(span, sourceSpan);\n        this.strings = strings;\n        this.expressions = expressions;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitInterpolation(this, context);\n    }\n}\nclass Binary extends AST {\n    constructor(span, sourceSpan, operation, left, right) {\n        super(span, sourceSpan);\n        this.operation = operation;\n        this.left = left;\n        this.right = right;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitBinary(this, context);\n    }\n}\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nclass Unary extends Binary {\n    /**\n     * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n     */\n    static createMinus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n    }\n    /**\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n     */\n    static createPlus(span, sourceSpan, expr) {\n        return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n    }\n    /**\n     * During the deprecation period this constructor is private, to avoid consumers from creating\n     * a `Unary` with the fallback properties for `Binary`.\n     */\n    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n        super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n        this.operator = operator;\n        this.expr = expr;\n        // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n        // depend on these fields when operating on `Unary`.\n        this.left = null;\n        this.right = null;\n        this.operation = null;\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitUnary !== undefined) {\n            return visitor.visitUnary(this, context);\n        }\n        return visitor.visitBinary(this, context);\n    }\n}\nclass PrefixNot extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitPrefixNot(this, context);\n    }\n}\nclass NonNullAssert extends AST {\n    constructor(span, sourceSpan, expression) {\n        super(span, sourceSpan);\n        this.expression = expression;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitNonNullAssert(this, context);\n    }\n}\nclass Call extends AST {\n    constructor(span, sourceSpan, receiver, args, argumentSpan) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        this.argumentSpan = argumentSpan;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitCall(this, context);\n    }\n}\nclass SafeCall extends AST {\n    constructor(span, sourceSpan, receiver, args, argumentSpan) {\n        super(span, sourceSpan);\n        this.receiver = receiver;\n        this.args = args;\n        this.argumentSpan = argumentSpan;\n    }\n    visit(visitor, context = null) {\n        return visitor.visitSafeCall(this, context);\n    }\n}\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nclass AbsoluteSourceSpan {\n    constructor(start, end) {\n        this.start = start;\n        this.end = end;\n    }\n}\nclass ASTWithSource extends AST {\n    constructor(ast, source, location, absoluteOffset, errors) {\n        super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n        this.ast = ast;\n        this.source = source;\n        this.location = location;\n        this.errors = errors;\n    }\n    visit(visitor, context = null) {\n        if (visitor.visitASTWithSource) {\n            return visitor.visitASTWithSource(this, context);\n        }\n        return this.ast.visit(visitor, context);\n    }\n    toString() {\n        return `${this.source} in ${this.location}`;\n    }\n}\nclass VariableBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key name of the LHS along with its span.\n     * @param value optional value for the RHS along with its span.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass ExpressionBinding {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n     * span. Note that the length of the span may not be the same as\n     * `key.source.length`. For example,\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\n     * 2. key.source = ngForOf, key.span is for \"of\"\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n     * @param value optional expression for the RHS.\n     */\n    constructor(sourceSpan, key, value) {\n        this.sourceSpan = sourceSpan;\n        this.key = key;\n        this.value = value;\n    }\n}\nclass RecursiveAstVisitor {\n    visit(ast, context) {\n        // The default implementation just visits every node.\n        // Classes that extend RecursiveAstVisitor should override this function\n        // to selectively visit the specified node.\n        ast.visit(this, context);\n    }\n    visitUnary(ast, context) {\n        this.visit(ast.expr, context);\n    }\n    visitBinary(ast, context) {\n        this.visit(ast.left, context);\n        this.visit(ast.right, context);\n    }\n    visitChain(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitConditional(ast, context) {\n        this.visit(ast.condition, context);\n        this.visit(ast.trueExp, context);\n        this.visit(ast.falseExp, context);\n    }\n    visitPipe(ast, context) {\n        this.visit(ast.exp, context);\n        this.visitAll(ast.args, context);\n    }\n    visitImplicitReceiver(ast, context) { }\n    visitThisReceiver(ast, context) { }\n    visitInterpolation(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitKeyedWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n        this.visit(ast.value, context);\n    }\n    visitLiteralArray(ast, context) {\n        this.visitAll(ast.expressions, context);\n    }\n    visitLiteralMap(ast, context) {\n        this.visitAll(ast.values, context);\n    }\n    visitLiteralPrimitive(ast, context) { }\n    visitPrefixNot(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitNonNullAssert(ast, context) {\n        this.visit(ast.expression, context);\n    }\n    visitPropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.value, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.visit(ast.receiver, context);\n    }\n    visitSafeKeyedRead(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visit(ast.key, context);\n    }\n    visitCall(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    }\n    visitSafeCall(ast, context) {\n        this.visit(ast.receiver, context);\n        this.visitAll(ast.args, context);\n    }\n    // This is not part of the AstVisitor interface, just a helper method\n    visitAll(asts, context) {\n        for (const ast of asts) {\n            this.visit(ast, context);\n        }\n    }\n}\nclass AstTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    }\n    visitLiteralPrimitive(ast, context) {\n        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    }\n    visitPropertyRead(ast, context) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitPropertyWrite(ast, context) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n    visitSafePropertyRead(ast, context) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n    visitLiteralArray(ast, context) {\n        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitLiteralMap(ast, context) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    }\n    visitUnary(ast, context) {\n        switch (ast.operator) {\n            case '+':\n                return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            case '-':\n                return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n            default:\n                throw new Error(`Unknown unary operator ${ast.operator}`);\n        }\n    }\n    visitBinary(ast, context) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n    visitPrefixNot(ast, context) {\n        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitNonNullAssert(ast, context) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n    visitConditional(ast, context) {\n        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n    visitPipe(ast, context) {\n        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    }\n    visitKeyedRead(ast, context) {\n        return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n    visitKeyedWrite(ast, context) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n    visitCall(ast, context) {\n        return new Call(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);\n    }\n    visitSafeCall(ast, context) {\n        return new SafeCall(ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args), ast.argumentSpan);\n    }\n    visitAll(asts) {\n        const res = [];\n        for (let i = 0; i < asts.length; ++i) {\n            res[i] = asts[i].visit(this);\n        }\n        return res;\n    }\n    visitChain(ast, context) {\n        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n    visitSafeKeyedRead(ast, context) {\n        return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n}\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nclass AstMemoryEfficientTransformer {\n    visitImplicitReceiver(ast, context) {\n        return ast;\n    }\n    visitThisReceiver(ast, context) {\n        return ast;\n    }\n    visitInterpolation(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions)\n            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n        return ast;\n    }\n    visitLiteralPrimitive(ast, context) {\n        return ast;\n    }\n    visitPropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitPropertyWrite(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const value = ast.value.visit(this);\n        if (receiver !== ast.receiver || value !== ast.value) {\n            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n        }\n        return ast;\n    }\n    visitSafePropertyRead(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        if (receiver !== ast.receiver) {\n            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n        }\n        return ast;\n    }\n    visitLiteralArray(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitLiteralMap(ast, context) {\n        const values = this.visitAll(ast.values);\n        if (values !== ast.values) {\n            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n        }\n        return ast;\n    }\n    visitUnary(ast, context) {\n        const expr = ast.expr.visit(this);\n        if (expr !== ast.expr) {\n            switch (ast.operator) {\n                case '+':\n                    return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n                case '-':\n                    return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n                default:\n                    throw new Error(`Unknown unary operator ${ast.operator}`);\n            }\n        }\n        return ast;\n    }\n    visitBinary(ast, context) {\n        const left = ast.left.visit(this);\n        const right = ast.right.visit(this);\n        if (left !== ast.left || right !== ast.right) {\n            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n        }\n        return ast;\n    }\n    visitPrefixNot(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new PrefixNot(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitNonNullAssert(ast, context) {\n        const expression = ast.expression.visit(this);\n        if (expression !== ast.expression) {\n            return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n        }\n        return ast;\n    }\n    visitConditional(ast, context) {\n        const condition = ast.condition.visit(this);\n        const trueExp = ast.trueExp.visit(this);\n        const falseExp = ast.falseExp.visit(this);\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n        }\n        return ast;\n    }\n    visitPipe(ast, context) {\n        const exp = ast.exp.visit(this);\n        const args = this.visitAll(ast.args);\n        if (exp !== ast.exp || args !== ast.args) {\n            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n        }\n        return ast;\n    }\n    visitKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n    visitKeyedWrite(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        const value = ast.value.visit(this);\n        if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n        }\n        return ast;\n    }\n    visitAll(asts) {\n        const res = [];\n        let modified = false;\n        for (let i = 0; i < asts.length; ++i) {\n            const original = asts[i];\n            const value = original.visit(this);\n            res[i] = value;\n            modified = modified || value !== original;\n        }\n        return modified ? res : asts;\n    }\n    visitChain(ast, context) {\n        const expressions = this.visitAll(ast.expressions);\n        if (expressions !== ast.expressions) {\n            return new Chain(ast.span, ast.sourceSpan, expressions);\n        }\n        return ast;\n    }\n    visitCall(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n        }\n        return ast;\n    }\n    visitSafeCall(ast, context) {\n        const receiver = ast.receiver.visit(this);\n        const args = this.visitAll(ast.args);\n        if (receiver !== ast.receiver || args !== ast.args) {\n            return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n        }\n        return ast;\n    }\n    visitSafeKeyedRead(ast, context) {\n        const obj = ast.receiver.visit(this);\n        const key = ast.key.visit(this);\n        if (obj !== ast.receiver || key !== ast.key) {\n            return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n        }\n        return ast;\n    }\n}\n// Bindings\nclass ParsedProperty {\n    constructor(name, expression, type, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.expression = expression;\n        this.type = type;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n    }\n}\nvar ParsedPropertyType;\n(function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\nclass ParsedEvent {\n    // Regular events have a target\n    // Animation events have a phase\n    constructor(name, targetOrPhase, type, handler, sourceSpan, handlerSpan, keySpan) {\n        this.name = name;\n        this.targetOrPhase = targetOrPhase;\n        this.type = type;\n        this.handler = handler;\n        this.sourceSpan = sourceSpan;\n        this.handlerSpan = handlerSpan;\n        this.keySpan = keySpan;\n    }\n}\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nclass ParsedVariable {\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\nclass BoundElementProperty {\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n        this.name = name;\n        this.type = type;\n        this.securityContext = securityContext;\n        this.value = value;\n        this.unit = unit;\n        this.sourceSpan = sourceSpan;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n    }\n}\n\nclass EventHandlerVars {\n}\nEventHandlerVars.event = variable('$event');\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, baseSourceSpan, implicitReceiverAccesses, globals) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver(globals);\n    }\n    const actionWithoutBuiltins = convertPropertyBindingBuiltins({\n        createLiteralArrayConverter: (argCount) => {\n            // Note: no caching for literal arrays in actions.\n            return (args) => literalArr(args);\n        },\n        createLiteralMapConverter: (keys) => {\n            // Note: no caching for literal maps in actions.\n            return (values) => {\n                const entries = keys.map((k, i) => ({\n                    key: k.key,\n                    value: values[i],\n                    quoted: k.quoted,\n                }));\n                return literalMap(entries);\n            };\n        },\n        createPipeConverter: (name) => {\n            throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n    }, action);\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan, implicitReceiverAccesses);\n    const actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const lastIndex = actionStmts.length - 1;\n    if (lastIndex >= 0) {\n        const lastStatement = actionStmts[lastIndex];\n        // Ensure that the value of the last expression statement is returned\n        if (lastStatement instanceof ExpressionStatement) {\n            actionStmts[lastIndex] = new ReturnStatement(lastStatement.expr);\n        }\n    }\n    return actionStmts;\n}\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n}\nclass ConvertPropertyBindingResult {\n    constructor(stmts, currValExpr) {\n        this.stmts = stmts;\n        this.currValExpr = currValExpr;\n    }\n}\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId) {\n    if (!localResolver) {\n        localResolver = new DefaultLocalResolver();\n    }\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n    const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n    if (visitor.usesImplicitReceiver) {\n        localResolver.notifyImplicitReceiverUse();\n    }\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\n    const args = outputExpr.args;\n    return { stmts, args };\n}\nfunction getStatementsFromVisitor(visitor, bindingId) {\n    const stmts = [];\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n        stmts.push(temporaryDeclaration(bindingId, i));\n    }\n    return stmts;\n}\nfunction convertBuiltins(converterFactory, ast) {\n    const visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n}\nfunction temporaryName(bindingId, temporaryNumber) {\n    return `tmp_${bindingId}_${temporaryNumber}`;\n}\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (let i = temporaryCount - 1; i >= 0; i--) {\n        statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n}\nvar _Mode;\n(function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\nfunction ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n        throw new Error(`Expected a statement, but saw ${ast}`);\n    }\n}\nfunction ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n        throw new Error(`Expected an expression, but saw ${ast}`);\n    }\n}\nfunction convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n        return expr.toStmt();\n    }\n    else {\n        return expr;\n    }\n}\nclass _BuiltinAstConverter extends AstTransformer {\n    constructor(_converterFactory) {\n        super();\n        this._converterFactory = _converterFactory;\n    }\n    visitPipe(ast, context) {\n        const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n    visitLiteralArray(ast, context) {\n        const args = ast.expressions.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n    visitLiteralMap(ast, context) {\n        const args = ast.values.map(ast => ast.visit(this, context));\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n}\nclass _AstToIrVisitor {\n    constructor(_localResolver, _implicitReceiver, bindingId, supportsInterpolation, baseSourceSpan, implicitReceiverAccesses) {\n        this._localResolver = _localResolver;\n        this._implicitReceiver = _implicitReceiver;\n        this.bindingId = bindingId;\n        this.supportsInterpolation = supportsInterpolation;\n        this.baseSourceSpan = baseSourceSpan;\n        this.implicitReceiverAccesses = implicitReceiverAccesses;\n        this._nodeMap = new Map();\n        this._resultMap = new Map();\n        this._currentTemporary = 0;\n        this.temporaryCount = 0;\n        this.usesImplicitReceiver = false;\n    }\n    visitUnary(ast, mode) {\n        let op;\n        switch (ast.operator) {\n            case '+':\n                op = UnaryOperator.Plus;\n                break;\n            case '-':\n                op = UnaryOperator.Minus;\n                break;\n            default:\n                throw new Error(`Unsupported operator ${ast.operator}`);\n        }\n        return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitBinary(ast, mode) {\n        let op;\n        switch (ast.operation) {\n            case '+':\n                op = BinaryOperator.Plus;\n                break;\n            case '-':\n                op = BinaryOperator.Minus;\n                break;\n            case '*':\n                op = BinaryOperator.Multiply;\n                break;\n            case '/':\n                op = BinaryOperator.Divide;\n                break;\n            case '%':\n                op = BinaryOperator.Modulo;\n                break;\n            case '&&':\n                op = BinaryOperator.And;\n                break;\n            case '||':\n                op = BinaryOperator.Or;\n                break;\n            case '==':\n                op = BinaryOperator.Equals;\n                break;\n            case '!=':\n                op = BinaryOperator.NotEquals;\n                break;\n            case '===':\n                op = BinaryOperator.Identical;\n                break;\n            case '!==':\n                op = BinaryOperator.NotIdentical;\n                break;\n            case '<':\n                op = BinaryOperator.Lower;\n                break;\n            case '>':\n                op = BinaryOperator.Bigger;\n                break;\n            case '<=':\n                op = BinaryOperator.LowerEquals;\n                break;\n            case '>=':\n                op = BinaryOperator.BiggerEquals;\n                break;\n            case '??':\n                return this.convertNullishCoalesce(ast, mode);\n            default:\n                throw new Error(`Unsupported operation ${ast.operation}`);\n        }\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n    visitChain(ast, mode) {\n        ensureStatementMode(mode, ast);\n        return this.visitAll(ast.expressions, mode);\n    }\n    visitConditional(ast, mode) {\n        const value = this._visit(ast.condition, _Mode.Expression);\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    }\n    visitPipe(ast, mode) {\n        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n    }\n    visitImplicitReceiver(ast, mode) {\n        ensureExpressionMode(mode, ast);\n        this.usesImplicitReceiver = true;\n        return this._implicitReceiver;\n    }\n    visitThisReceiver(ast, mode) {\n        return this.visitImplicitReceiver(ast, mode);\n    }\n    visitInterpolation(ast, mode) {\n        if (!this.supportsInterpolation) {\n            throw new Error('Unexpected interpolation');\n        }\n        ensureExpressionMode(mode, ast);\n        let args = [];\n        for (let i = 0; i < ast.strings.length - 1; i++) {\n            args.push(literal(ast.strings[i]));\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\n        }\n        args.push(literal(ast.strings[ast.strings.length - 1]));\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n        // args returned to just the value, because we're going to pass it to a special instruction.\n        const strings = ast.strings;\n        if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n            // Single argument interpolate instructions.\n            args = [args[1]];\n        }\n        else if (ast.expressions.length >= 9) {\n            // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n            // an array of arguments\n            args = [literalArr(args)];\n        }\n        return new InterpolationExpression(args);\n    }\n    visitKeyedRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n        }\n    }\n    visitKeyedWrite(ast, mode) {\n        const obj = this._visit(ast.receiver, _Mode.Expression);\n        const key = this._visit(ast.key, _Mode.Expression);\n        const value = this._visit(ast.value, _Mode.Expression);\n        if (obj === this._implicitReceiver) {\n            this._localResolver.maybeRestoreView();\n        }\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n    visitLiteralArray(ast, mode) {\n        throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n    }\n    visitLiteralMap(ast, mode) {\n        throw new Error(`Illegal State: literal maps should have been converted into functions`);\n    }\n    visitLiteralPrimitive(ast, mode) {\n        // For literal values of null, undefined, true, or false allow type interference\n        // to infer the type.\n        const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n            INFERRED_TYPE :\n            undefined;\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    }\n    _getLocal(name, receiver) {\n        if (this._localResolver.globals?.has(name) && receiver instanceof ThisReceiver) {\n            return null;\n        }\n        return this._localResolver.getLocal(name);\n    }\n    visitPrefixNot(ast, mode) {\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    }\n    visitNonNullAssert(ast, mode) {\n        return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n    }\n    visitPropertyRead(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        else {\n            let result = null;\n            const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n            const receiver = this._visit(ast.receiver, _Mode.Expression);\n            if (receiver === this._implicitReceiver) {\n                result = this._getLocal(ast.name, ast.receiver);\n                if (result) {\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n            }\n            if (result == null) {\n                result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n            }\n            return convertToStatementIfNeeded(mode, result);\n        }\n    }\n    visitPropertyWrite(ast, mode) {\n        const receiver = this._visit(ast.receiver, _Mode.Expression);\n        const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        let varExpr = null;\n        if (receiver === this._implicitReceiver) {\n            const localExpr = this._getLocal(ast.name, ast.receiver);\n            if (localExpr) {\n                if (localExpr instanceof ReadPropExpr) {\n                    // If the local variable is a property read expression, it's a reference\n                    // to a 'context.property' value and will be used as the target of the\n                    // write expression.\n                    varExpr = localExpr;\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\n                    // receiver has been replaced with a resolved local expression.\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\n                    this.addImplicitReceiverAccess(ast.name);\n                }\n                else {\n                    // Otherwise it's an error.\n                    const receiver = ast.name;\n                    const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;\n                    throw new Error(`Cannot assign value \"${value}\" to template variable \"${receiver}\". Template variables are read-only.`);\n                }\n            }\n        }\n        // If no local expression could be produced, use the original receiver's\n        // property as the target.\n        if (varExpr === null) {\n            varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n        }\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    }\n    visitSafePropertyRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitSafeKeyedRead(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    visitAll(asts, mode) {\n        return asts.map(ast => this._visit(ast, mode));\n    }\n    visitCall(ast, mode) {\n        const leftMostSafe = this.leftMostSafeNode(ast);\n        if (leftMostSafe) {\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\n        }\n        const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n        if (ast instanceof BuiltinFunctionCall) {\n            return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n        }\n        const receiver = ast.receiver;\n        if (receiver instanceof PropertyRead &&\n            receiver.receiver instanceof ImplicitReceiver &&\n            !(receiver.receiver instanceof ThisReceiver) && receiver.name === '$any') {\n            if (convertedArgs.length !== 1) {\n                throw new Error(`Invalid call to $any, expected 1 argument but received ${convertedArgs.length || 'none'}`);\n            }\n            return convertToStatementIfNeeded(mode, convertedArgs[0]);\n        }\n        const call = this._visit(receiver, _Mode.Expression)\n            .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n        return convertToStatementIfNeeded(mode, call);\n    }\n    visitSafeCall(ast, mode) {\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n    _visit(ast, mode) {\n        const result = this._resultMap.get(ast);\n        if (result)\n            return result;\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n    convertSafeAccess(ast, leftMostSafe, mode) {\n        // If the expression contains a safe access node on the left it needs to be converted to\n        // an expression that guards the access to the member by checking the receiver for blank. As\n        // execution proceeds from left to right, the left most part of the expression must be guarded\n        // first but, because member access is left associative, the right side of the expression is at\n        // the top of the AST. The desired result requires lifting a copy of the left part of the\n        // expression up to test it for blank before generating the unguarded version.\n        // Consider, for example the following expression: a?.b.c?.d.e\n        // This results in the ast:\n        //         .\n        //        / \\\n        //       ?.   e\n        //      /  \\\n        //     .    d\n        //    / \\\n        //   ?.  c\n        //  /  \\\n        // a    b\n        // The following tree should be generated:\n        //\n        //        /---- ? ----\\\n        //       /      |      \\\n        //     a   /--- ? ---\\  null\n        //        /     |     \\\n        //       .      .     null\n        //      / \\    / \\\n        //     .  c   .   e\n        //    / \\    / \\\n        //   a   b  .   d\n        //         / \\\n        //        .   c\n        //       / \\\n        //      a   b\n        //\n        // Notice that the first guard condition is the left hand of the left most safe access node\n        // which comes in as leftMostSafe to this routine.\n        let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n        let temporary = undefined;\n        if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n            // If the expression has method calls or pipes then we need to save the result into a\n            // temporary variable to avoid calling stateful or impure code more than once.\n            temporary = this.allocateTemporary();\n            // Preserve the result in the temporary variable\n            guardedExpression = temporary.set(guardedExpression);\n            // Ensure all further references to the guarded expression refer to the temporary instead.\n            this._resultMap.set(leftMostSafe.receiver, temporary);\n        }\n        const condition = guardedExpression.isBlank();\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\n        if (leftMostSafe instanceof SafeCall) {\n            this._nodeMap.set(leftMostSafe, new Call(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args, leftMostSafe.argumentSpan));\n        }\n        else if (leftMostSafe instanceof SafeKeyedRead) {\n            this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n        }\n        else {\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n        }\n        // Recursively convert the node now without the guarded member access.\n        const access = this._visit(ast, _Mode.Expression);\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\n        this._nodeMap.delete(leftMostSafe);\n        // If we allocated a temporary, release it.\n        if (temporary) {\n            this.releaseTemporary(temporary);\n        }\n        // Produce the conditional\n        return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));\n    }\n    convertNullishCoalesce(ast, mode) {\n        const left = this._visit(ast.left, _Mode.Expression);\n        const right = this._visit(ast.right, _Mode.Expression);\n        const temporary = this.allocateTemporary();\n        this.releaseTemporary(temporary);\n        // Generate the following expression. It is identical to how TS\n        // transpiles binary expressions with a nullish coalescing operator.\n        // let temp;\n        // (temp = a) !== null && temp !== undefined ? temp : b;\n        return convertToStatementIfNeeded(mode, temporary.set(left)\n            .notIdentical(NULL_EXPR)\n            .and(temporary.notIdentical(literal(undefined)))\n            .conditional(temporary, right));\n    }\n    // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n    leftMostSafeNode(ast) {\n        const visit = (visitor, ast) => {\n            return (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return null;\n            },\n            visitBinary(ast) {\n                return null;\n            },\n            visitChain(ast) {\n                return null;\n            },\n            visitConditional(ast) {\n                return null;\n            },\n            visitCall(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitSafeCall(ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitImplicitReceiver(ast) {\n                return null;\n            },\n            visitThisReceiver(ast) {\n                return null;\n            },\n            visitInterpolation(ast) {\n                return null;\n            },\n            visitKeyedRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitKeyedWrite(ast) {\n                return null;\n            },\n            visitLiteralArray(ast) {\n                return null;\n            },\n            visitLiteralMap(ast) {\n                return null;\n            },\n            visitLiteralPrimitive(ast) {\n                return null;\n            },\n            visitPipe(ast) {\n                return null;\n            },\n            visitPrefixNot(ast) {\n                return null;\n            },\n            visitNonNullAssert(ast) {\n                return visit(this, ast.expression);\n            },\n            visitPropertyRead(ast) {\n                return visit(this, ast.receiver);\n            },\n            visitPropertyWrite(ast) {\n                return null;\n            },\n            visitSafePropertyRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            },\n            visitSafeKeyedRead(ast) {\n                return visit(this, ast.receiver) || ast;\n            }\n        });\n    }\n    // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n    needsTemporaryInSafeAccess(ast) {\n        const visit = (visitor, ast) => {\n            return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n        };\n        const visitSome = (visitor, ast) => {\n            return ast.some(ast => visit(visitor, ast));\n        };\n        return ast.visit({\n            visitUnary(ast) {\n                return visit(this, ast.expr);\n            },\n            visitBinary(ast) {\n                return visit(this, ast.left) || visit(this, ast.right);\n            },\n            visitChain(ast) {\n                return false;\n            },\n            visitConditional(ast) {\n                return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n            },\n            visitCall(ast) {\n                return true;\n            },\n            visitSafeCall(ast) {\n                return true;\n            },\n            visitImplicitReceiver(ast) {\n                return false;\n            },\n            visitThisReceiver(ast) {\n                return false;\n            },\n            visitInterpolation(ast) {\n                return visitSome(this, ast.expressions);\n            },\n            visitKeyedRead(ast) {\n                return false;\n            },\n            visitKeyedWrite(ast) {\n                return false;\n            },\n            visitLiteralArray(ast) {\n                return true;\n            },\n            visitLiteralMap(ast) {\n                return true;\n            },\n            visitLiteralPrimitive(ast) {\n                return false;\n            },\n            visitPipe(ast) {\n                return true;\n            },\n            visitPrefixNot(ast) {\n                return visit(this, ast.expression);\n            },\n            visitNonNullAssert(ast) {\n                return visit(this, ast.expression);\n            },\n            visitPropertyRead(ast) {\n                return false;\n            },\n            visitPropertyWrite(ast) {\n                return false;\n            },\n            visitSafePropertyRead(ast) {\n                return false;\n            },\n            visitSafeKeyedRead(ast) {\n                return false;\n            }\n        });\n    }\n    allocateTemporary() {\n        const tempNumber = this._currentTemporary++;\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n    releaseTemporary(temporary) {\n        this._currentTemporary--;\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n            throw new Error(`Temporary ${temporary.name} released out of order`);\n        }\n    }\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n    convertSourceSpan(span) {\n        if (this.baseSourceSpan) {\n            const start = this.baseSourceSpan.start.moveBy(span.start);\n            const end = this.baseSourceSpan.start.moveBy(span.end);\n            const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n            return new ParseSourceSpan(start, end, fullStart);\n        }\n        else {\n            return null;\n        }\n    }\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n    addImplicitReceiverAccess(name) {\n        if (this.implicitReceiverAccesses) {\n            this.implicitReceiverAccesses.add(name);\n        }\n    }\n}\nfunction flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n        arg.forEach((entry) => flattenStatements(entry, output));\n    }\n    else {\n        output.push(arg);\n    }\n}\nfunction unsupported() {\n    throw new Error('Unsupported operation');\n}\nclass InterpolationExpression extends Expression {\n    constructor(args) {\n        super(null, null);\n        this.args = args;\n        this.isConstant = unsupported;\n        this.isEquivalent = unsupported;\n        this.visitExpression = unsupported;\n    }\n}\nclass DefaultLocalResolver {\n    constructor(globals) {\n        this.globals = globals;\n    }\n    notifyImplicitReceiverUse() { }\n    maybeRestoreView() { }\n    getLocal(name) {\n        if (name === EventHandlerVars.event.name) {\n            return EventHandlerVars.event;\n        }\n        return null;\n    }\n}\nclass BuiltinFunctionCall extends Call {\n    constructor(span, sourceSpan, args, converter) {\n        super(span, sourceSpan, new EmptyExpr(span, sourceSpan), args, null);\n        this.converter = converter;\n    }\n}\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA;\nfunction SECURITY_SCHEMA() {\n    if (!_SECURITY_SCHEMA) {\n        _SECURITY_SCHEMA = {};\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n        registerContext(SecurityContext.HTML, [\n            'iframe|srcdoc',\n            '*|innerHTML',\n            '*|outerHTML',\n        ]);\n        registerContext(SecurityContext.STYLE, ['*|style']);\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n        registerContext(SecurityContext.URL, [\n            '*|formAction',\n            'area|href',\n            'area|ping',\n            'audio|src',\n            'a|href',\n            'a|ping',\n            'blockquote|cite',\n            'body|background',\n            'del|cite',\n            'form|action',\n            'img|src',\n            'input|src',\n            'ins|cite',\n            'q|cite',\n            'source|src',\n            'track|src',\n            'video|poster',\n            'video|src',\n        ]);\n        registerContext(SecurityContext.RESOURCE_URL, [\n            'applet|code',\n            'applet|codebase',\n            'base|href',\n            'embed|src',\n            'frame|src',\n            'head|profile',\n            'html|manifest',\n            'iframe|src',\n            'link|href',\n            'media|src',\n            'object|codebase',\n            'object|data',\n            'script|src',\n        ]);\n    }\n    return _SECURITY_SCHEMA;\n}\nfunction registerContext(ctx, specs) {\n    for (const spec of specs)\n        _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n/**\n * The set of security-sensitive attributes of an `<iframe>` that *must* be\n * applied as a static attribute only. This ensures that all security-sensitive\n * attributes are taken into account while creating an instance of an `<iframe>`\n * at runtime.\n *\n * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function\n * in the code instead.\n */\nconst IFRAME_SECURITY_SENSITIVE_ATTRS = new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\n/**\n * Checks whether a given attribute name might represent a security-sensitive\n * attribute of an <iframe>.\n */\nfunction isIframeSecuritySensitiveAttr(attrName) {\n    // The `setAttribute` DOM API is case-insensitive, so we lowercase the value\n    // before checking it against a known security-sensitive attributes.\n    return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n\n/**\n * The following set contains all keywords that can be used in the animation css shorthand\n * property and is used during the scoping of keyframes to make sure such keywords\n * are not modified.\n */\nconst animationKeywords = new Set([\n    // global values\n    'inherit', 'initial', 'revert', 'unset',\n    // animation-direction\n    'alternate', 'alternate-reverse', 'normal', 'reverse',\n    // animation-fill-mode\n    'backwards', 'both', 'forwards', 'none',\n    // animation-play-state\n    'paused', 'running',\n    // animation-timing-function\n    'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end',\n    // `steps()` function\n    'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start'\n]);\n/**\n * The following class has its origin from a port of shadowCSS from webcomponents.js to TypeScript.\n * It has since diverge in many ways to tailor Angular's needs.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM.\n  The selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nclass ShadowCss {\n    constructor() {\n        /**\n         * Regular expression used to extrapolate the possible keyframes from an\n         * animation declaration (with possibly multiple animation definitions)\n         *\n         * The regular expression can be divided in three parts\n         *  - (^|\\s+)\n         *    simply captures how many (if any) leading whitespaces are present\n         *  - (?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))\n         *    captures two different possible keyframes, ones which are quoted or ones which are valid css\n         * idents (custom properties excluded)\n         *  - (?=[,\\s;]|$)\n         *    simply matches the end of the possible keyframe, valid endings are: a comma, a space, a\n         * semicolon or the end of the string\n         */\n        this._animationDeclarationKeyframesRe = /(^|\\s+)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n    }\n    /*\n     * Shim some cssText with the given selector. Returns cssText that can be included in the document\n     *\n     * The selector is the attribute added to all elements inside the host,\n     * The hostSelector is the attribute added to the host itself.\n     */\n    shimCssText(cssText, selector, hostSelector = '') {\n        const commentsWithHash = extractCommentsWithHash(cssText);\n        cssText = stripComments(cssText);\n        cssText = this._insertDirectives(cssText);\n        const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n        return [scopedCssText, ...commentsWithHash].join('\\n');\n    }\n    _insertDirectives(cssText) {\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\n        return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /**\n     * Process styles to add scope to keyframes.\n     *\n     * Modify both the names of the keyframes defined in the component styles and also the css\n     * animation rules using them.\n     *\n     * Animation rules using keyframes defined elsewhere are not modified to allow for globally\n     * defined keyframes.\n     *\n     * For example, we convert this css:\n     *\n     * ```\n     * .box {\n     *   animation: box-animation 1s forwards;\n     * }\n     *\n     * @keyframes box-animation {\n     *   to {\n     *     background-color: green;\n     *   }\n     * }\n     * ```\n     *\n     * to this:\n     *\n     * ```\n     * .box {\n     *   animation: scopeName_box-animation 1s forwards;\n     * }\n     *\n     * @keyframes scopeName_box-animation {\n     *   to {\n     *     background-color: green;\n     *   }\n     * }\n     * ```\n     *\n     * @param cssText the component's css text that needs to be scoped.\n     * @param scopeSelector the component's scope selector.\n     *\n     * @returns the scoped css text.\n     */\n    _scopeKeyframesRelatedCss(cssText, scopeSelector) {\n        const unscopedKeyframesSet = new Set();\n        const scopedKeyframesCssText = processRules(cssText, rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n        return processRules(scopedKeyframesCssText, rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n    }\n    /**\n     * Scopes local keyframes names, returning the updated css rule and it also\n     * adds the original keyframe name to a provided set to collect all keyframes names\n     * so that it can later be used to scope the animation rules.\n     *\n     * For example, it takes a rule such as:\n     *\n     * ```\n     * @keyframes box-animation {\n     *   to {\n     *     background-color: green;\n     *   }\n     * }\n     * ```\n     *\n     * and returns:\n     *\n     * ```\n     * @keyframes scopeName_box-animation {\n     *   to {\n     *     background-color: green;\n     *   }\n     * }\n     * ```\n     * and as a side effect it adds \"box-animation\" to the `unscopedKeyframesSet` set\n     *\n     * @param cssRule the css rule to process.\n     * @param scopeSelector the component's scope selector.\n     * @param unscopedKeyframesSet the set of unscoped keyframes names (which can be\n     * modified as a side effect)\n     *\n     * @returns the css rule modified with the scoped keyframes name.\n     */\n    _scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet) {\n        return {\n            ...rule,\n            selector: rule.selector.replace(/(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/, (_, start, quote, keyframeName, endSpaces) => {\n                unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n                return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n            }),\n        };\n    }\n    /**\n     * Function used to scope a keyframes name (obtained from an animation declaration)\n     * using an existing set of unscopedKeyframes names to discern if the scoping needs to be\n     * performed (keyframes names of keyframes not defined in the component's css need not to be\n     * scoped).\n     *\n     * @param keyframe the keyframes name to check.\n     * @param scopeSelector the component's scope selector.\n     * @param unscopedKeyframesSet the set of unscoped keyframes names.\n     *\n     * @returns the scoped name of the keyframe, or the original name is the name need not to be\n     * scoped.\n     */\n    _scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet) {\n        return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n            name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${name}`;\n            return `${spaces1}${quote}${name}${quote}${spaces2}`;\n        });\n    }\n    /**\n     * Scope an animation rule so that the keyframes mentioned in such rule\n     * are scoped if defined in the component's css and left untouched otherwise.\n     *\n     * It can scope values of both the 'animation' and 'animation-name' properties.\n     *\n     * @param rule css rule to scope.\n     * @param scopeSelector the component's scope selector.\n     * @param unscopedKeyframesSet the set of unscoped keyframes names.\n     *\n     * @returns the updated css rule.\n     **/\n    _scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet) {\n        let content = rule.content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation(?:\\s*):(?:\\s*))([^;]+)/g, (_, start, animationDeclarations) => start +\n            animationDeclarations.replace(this._animationDeclarationKeyframesRe, (original, leadingSpaces, quote = '', quotedName, nonQuotedName) => {\n                if (quotedName) {\n                    return `${leadingSpaces}${this._scopeAnimationKeyframe(`${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n                }\n                else {\n                    return animationKeywords.has(nonQuotedName) ?\n                        original :\n                        `${leadingSpaces}${this._scopeAnimationKeyframe(nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n                }\n            }));\n        content = content.replace(/((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g, (_match, start, commaSeparatedKeyframes) => `${start}${commaSeparatedKeyframes.split(',')\n            .map((keyframe) => this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet))\n            .join(',')}`);\n        return { ...rule, content };\n    }\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n     **/\n    _insertPolyfillDirectivesInCssText(cssText) {\n        return cssText.replace(_cssContentNextSelectorRe, function (...m) {\n            return m[2] + '{';\n        });\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n     **/\n    _insertPolyfillRulesInCssText(cssText) {\n        return cssText.replace(_cssContentRuleRe, (...m) => {\n            const rule = m[0].replace(m[1], '').replace(m[2], '');\n            return m[4] + rule;\n        });\n    }\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n     */\n    _scopeCssText(cssText, scopeSelector, hostSelector) {\n        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n        cssText = this._insertPolyfillHostInCssText(cssText);\n        cssText = this._convertColonHost(cssText);\n        cssText = this._convertColonHostContext(cssText);\n        cssText = this._convertShadowDOMSelectors(cssText);\n        if (scopeSelector) {\n            cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n        }\n        cssText = cssText + '\\n' + unscopedRules;\n        return cssText.trim();\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n     **/\n    _extractUnscopedRulesFromCssText(cssText) {\n        let r = '';\n        let m;\n        _cssContentUnscopedRuleRe.lastIndex = 0;\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n            r += rule + '\\n\\n';\n        }\n        return r;\n    }\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n     */\n    _convertColonHost(cssText) {\n        return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\n            if (hostSelectors) {\n                const convertedSelectors = [];\n                const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\n                for (const hostSelector of hostSelectorArray) {\n                    if (!hostSelector)\n                        break;\n                    const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n                    convertedSelectors.push(convertedSelector);\n                }\n                return convertedSelectors.join(',');\n            }\n            else {\n                return _polyfillHostNoCombinator + otherSelectors;\n            }\n        });\n    }\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n     */\n    _convertColonHostContext(cssText) {\n        return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\n            // We have captured a selector that contains a `:host-context` rule.\n            // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n            // Each context selector group will contain a list of host-context selectors that must match\n            // an ancestor of the host.\n            // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n            const contextSelectorGroups = [[]];\n            // There may be more than `:host-context` in this selector so `selectorText` could look like:\n            // `:host-context(.one):host-context(.two)`.\n            // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n            // `:host-context` selectors from this selector.\n            let match;\n            while (match = _cssColonHostContextRe.exec(selectorText)) {\n                // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n                // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n                const newContextSelectors = (match[1] ?? '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\n                // We must duplicate the current selector group for each of these new selectors.\n                // For example if the current groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c'],\n                //   ['x', 'y', 'z'],\n                // ]\n                // ```\n                // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n                // groups are:\n                // ```\n                // [\n                //   ['a', 'b', 'c', 'm'],\n                //   ['x', 'y', 'z', 'm'],\n                //   ['a', 'b', 'c', 'n'],\n                //   ['x', 'y', 'z', 'n'],\n                // ]\n                // ```\n                const contextSelectorGroupsLength = contextSelectorGroups.length;\n                repeatGroups(contextSelectorGroups, newContextSelectors.length);\n                for (let i = 0; i < newContextSelectors.length; i++) {\n                    for (let j = 0; j < contextSelectorGroupsLength; j++) {\n                        contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);\n                    }\n                }\n                // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n                selectorText = match[2];\n            }\n            // The context selectors now must be combined with each other to capture all the possible\n            // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n            // info about how this is done.\n            return contextSelectorGroups\n                .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\n                .join(', ');\n        });\n    }\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n     */\n    _convertShadowDOMSelectors(cssText) {\n        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n    }\n    // change a selector like 'div' to 'name div'\n    _scopeSelectors(cssText, scopeSelector, hostSelector) {\n        return processRules(cssText, (rule) => {\n            let selector = rule.selector;\n            let content = rule.content;\n            if (rule.selector[0] !== '@') {\n                selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector);\n            }\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n                rule.selector.startsWith('@document') || rule.selector.startsWith('@layer') ||\n                rule.selector.startsWith('@container')) {\n                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n            }\n            else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n                content = this._stripScopingSelectors(rule.content);\n            }\n            return new CssRule(selector, content);\n        });\n    }\n    /**\n     * Handle a css text that is within a rule that should not contain scope selectors by simply\n     * removing them! An example of such a rule is `@font-face`.\n     *\n     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n     * can end up with broken css if the imported styles happen to contain @font-face rules.\n     *\n     * For example:\n     *\n     * ```\n     * :host ::ng-deep {\n     *   import 'some/lib/containing/font-face';\n     * }\n     *\n     * Similar logic applies to `@page` rules which can contain a particular set of properties,\n     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n     * ```\n     */\n    _stripScopingSelectors(cssText) {\n        return processRules(cssText, rule => {\n            const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                .replace(_polyfillHostNoCombinatorRe, ' ');\n            return new CssRule(selector, rule.content);\n        });\n    }\n    _scopeSelector(selector, scopeSelector, hostSelector) {\n        return selector.split(',')\n            .map(part => part.trim().split(_shadowDeepSelectors))\n            .map((deepParts) => {\n            const [shallowPart, ...otherParts] = deepParts;\n            const applyScope = (shallowPart) => {\n                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n                    return this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n                }\n                else {\n                    return shallowPart;\n                }\n            };\n            return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n            .join(', ');\n    }\n    _selectorNeedsScoping(selector, scopeSelector) {\n        const re = this._makeScopeMatcher(scopeSelector);\n        return !re.test(selector);\n    }\n    _makeScopeMatcher(scopeSelector) {\n        const lre = /\\[/g;\n        const rre = /\\]/g;\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n    // scope via name and [is=name]\n    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n        _polyfillHostRe.lastIndex = 0;\n        if (_polyfillHostRe.test(selector)) {\n            const replaceBy = `[${hostSelector}]`;\n            return selector\n                .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {\n                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {\n                    return before + replaceBy + colon + after;\n                });\n            })\n                .replace(_polyfillHostRe, replaceBy + ' ');\n        }\n        return scopeSelector + ' ' + selector;\n    }\n    // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n    _applySelectorScope(selector, scopeSelector, hostSelector) {\n        const isRe = /\\[is=([^\\]]*)\\]/g;\n        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\n        const attrName = '[' + scopeSelector + ']';\n        const _scopeSelectorPart = (p) => {\n            let scopedP = p.trim();\n            if (!scopedP) {\n                return '';\n            }\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n            }\n            else {\n                // remove :host since it should be unnecessary\n                const t = p.replace(_polyfillHostRe, '');\n                if (t.length > 0) {\n                    const matches = t.match(/([^:]*)(:*)(.*)/);\n                    if (matches) {\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\n                    }\n                }\n            }\n            return scopedP;\n        };\n        const safeContent = new SafeSelector(selector);\n        selector = safeContent.content();\n        let scopedSelector = '';\n        let startIndex = 0;\n        let res;\n        const sep = /( |>|\\+|~(?!=))\\s*/g;\n        // If a selector appears before :host it should not be shimmed as it\n        // matches on ancestor elements and not on elements in the host's shadow\n        // `:host-context(div)` is transformed to\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n        // Historically `component-tag:host` was matching the component so we also want to preserve\n        // this behavior to avoid breaking legacy apps (it should not match).\n        // The behavior should be:\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n        //   `:host-context(tag)`)\n        const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n        let shouldScope = !hasHost;\n        while ((res = sep.exec(selector)) !== null) {\n            const separator = res[1];\n            const part = selector.slice(startIndex, res.index).trim();\n            // A space following an escaped hex value and followed by another hex character\n            // (ie: \".\\fc ber\" for \".ber\") is not a separator between 2 selectors\n            // also keep in mind that backslashes are replaced by a placeholder by SafeSelector\n            // These escaped selectors happen for example when esbuild runs with optimization.minify.\n            if (part.match(_placeholderRe) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n                continue;\n            }\n            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n            const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n            scopedSelector += `${scopedPart} ${separator} `;\n            startIndex = sep.lastIndex;\n        }\n        const part = selector.substring(startIndex);\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n        // replace the placeholders with their original values\n        return safeContent.restore(scopedSelector);\n    }\n    _insertPolyfillHostInCssText(selector) {\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\n            .replace(_colonHostRe, _polyfillHost);\n    }\n}\nclass SafeSelector {\n    constructor(selector) {\n        this.placeholders = [];\n        this.index = 0;\n        // Replaces attribute selectors with placeholders.\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n        selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n        // CSS allows for certain special characters to be used in selectors if they're escaped.\n        // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n        // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n        // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n        // that our handling of pseudo-selectors doesn't mess with them.\n        selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n        // WS and \"+\" would otherwise be interpreted as selector separators.\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(exp);\n            this.index++;\n            return pseudo + replaceBy;\n        });\n    }\n    restore(content) {\n        return content.replace(_placeholderRe, (_ph, index) => this.placeholders[+index]);\n    }\n    content() {\n        return this._content;\n    }\n    /**\n     * Replaces all of the substrings that match a regex within a\n     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n     */\n    _escapeRegexMatches(content, pattern) {\n        return content.replace(pattern, (_, keep) => {\n            const replaceBy = `__ph-${this.index}__`;\n            this.placeholders.push(keep);\n            this.index++;\n            return replaceBy;\n        });\n    }\n}\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n    /::shadow/g,\n    /::content/g,\n    // Deprecated selectors\n    /\\/shadow-deep\\//g,\n    /\\/shadow\\//g,\n];\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _placeholderRe = /__ph-(\\d+)__/g;\nfunction stripComments(input) {\n    return input.replace(_commentRe, '');\n}\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\nfunction extractCommentsWithHash(input) {\n    return input.match(_commentWithHashRe) || [];\n}\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst CONTENT_PAIRS = new Map([['{', '}']]);\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\nclass CssRule {\n    constructor(selector, content) {\n        this.selector = selector;\n        this.content = content;\n    }\n}\nfunction processRules(input, ruleCallback) {\n    const escaped = escapeInStrings(input);\n    const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n    let nextBlockIndex = 0;\n    const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m) => {\n        const selector = m[2];\n        let content = '';\n        let suffix = m[4];\n        let contentPrefix = '';\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n            contentPrefix = '{';\n        }\n        const rule = ruleCallback(new CssRule(selector, content));\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n    });\n    return unescapeInStrings(escapedResult);\n}\nclass StringWithEscapedBlocks {\n    constructor(escapedString, blocks) {\n        this.escapedString = escapedString;\n        this.blocks = blocks;\n    }\n}\nfunction escapeBlocks(input, charPairs, placeholder) {\n    const resultParts = [];\n    const escapedBlocks = [];\n    let openCharCount = 0;\n    let nonBlockStartIndex = 0;\n    let blockStartIndex = -1;\n    let openChar;\n    let closeChar;\n    for (let i = 0; i < input.length; i++) {\n        const char = input[i];\n        if (char === '\\\\') {\n            i++;\n        }\n        else if (char === closeChar) {\n            openCharCount--;\n            if (openCharCount === 0) {\n                escapedBlocks.push(input.substring(blockStartIndex, i));\n                resultParts.push(placeholder);\n                nonBlockStartIndex = i;\n                blockStartIndex = -1;\n                openChar = closeChar = undefined;\n            }\n        }\n        else if (char === openChar) {\n            openCharCount++;\n        }\n        else if (openCharCount === 0 && charPairs.has(char)) {\n            openChar = char;\n            closeChar = charPairs.get(char);\n            openCharCount = 1;\n            blockStartIndex = i + 1;\n            resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n        }\n    }\n    if (blockStartIndex !== -1) {\n        escapedBlocks.push(input.substring(blockStartIndex));\n        resultParts.push(placeholder);\n    }\n    else {\n        resultParts.push(input.substring(nonBlockStartIndex));\n    }\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * Object containing as keys characters that should be substituted by placeholders\n * when found in strings during the css text parsing, and as values the respective\n * placeholders\n */\nconst ESCAPE_IN_STRING_MAP = {\n    ';': SEMI_IN_PLACEHOLDER,\n    ',': COMMA_IN_PLACEHOLDER,\n    ':': COLON_IN_PLACEHOLDER\n};\n/**\n * Parse the provided css text and inside strings (meaning, inside pairs of unescaped single or\n * double quotes) replace specific characters with their respective placeholders as indicated\n * by the `ESCAPE_IN_STRING_MAP` map.\n *\n * For example convert the text\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n * to\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n *\n * This is necessary in order to remove the meaning of some characters when found inside strings\n * (for example `;` indicates the end of a css declaration, `,` the sequence of values and `:` the\n * division between property and value during a declaration, none of these meanings apply when such\n * characters are within strings and so in order to prevent parsing issues they need to be replaced\n * with placeholder text for the duration of the css manipulation process).\n *\n * @param input the original css text.\n *\n * @returns the css text with specific characters in strings replaced by placeholders.\n **/\nfunction escapeInStrings(input) {\n    let result = input;\n    let currentQuoteChar = null;\n    for (let i = 0; i < result.length; i++) {\n        const char = result[i];\n        if (char === '\\\\') {\n            i++;\n        }\n        else {\n            if (currentQuoteChar !== null) {\n                // index i is inside a quoted sub-string\n                if (char === currentQuoteChar) {\n                    currentQuoteChar = null;\n                }\n                else {\n                    const placeholder = ESCAPE_IN_STRING_MAP[char];\n                    if (placeholder) {\n                        result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n                        i += placeholder.length - 1;\n                    }\n                }\n            }\n            else if (char === '\\'' || char === '\"') {\n                currentQuoteChar = char;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Replace in a string all occurrences of keys in the `ESCAPE_IN_STRING_MAP` map with their\n * original representation, this is simply used to revert the changes applied by the\n * escapeInStrings function.\n *\n * For example it reverts the text:\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n * to it's original form of:\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n *\n * Note: For the sake of simplicity this function does not check that the placeholders are\n * actually inside strings as it would anyway be extremely unlikely to find them outside of strings.\n *\n * @param input the css text containing the placeholders.\n *\n * @returns the css text without the placeholders.\n */\nfunction unescapeInStrings(input) {\n    let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n    result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n    result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n    return result;\n}\n/**\n * Unescape all quotes present in a string, but only if the string was actually already\n * quoted.\n *\n * This generates a \"canonical\" representation of strings which can be used to match strings\n * which would otherwise only differ because of differently escaped quotes.\n *\n * For example it converts the string (assumed to be quoted):\n *  `this \\\\\"is\\\\\" a \\\\'\\\\\\\\'test`\n * to:\n *  `this \"is\" a '\\\\\\\\'test`\n * (note that the latter backslashes are not removed as they are not actually escaping the single\n * quote)\n *\n *\n * @param input the string possibly containing escaped quotes.\n * @param isQuoted boolean indicating whether the string was quoted inside a bigger string (if not\n * then it means that it doesn't represent an inner string and thus no unescaping is required)\n *\n * @returns the string in the \"canonical\" representation without escaped quotes.\n */\nfunction unescapeQuotes(str, isQuoted) {\n    return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param hostMarker the string that selects the host element.\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors, otherSelectors) {\n    const hostMarker = _polyfillHostNoCombinator;\n    _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\n    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n    // If there are no context selectors then just output a host marker\n    if (contextSelectors.length === 0) {\n        return hostMarker + otherSelectors;\n    }\n    const combined = [contextSelectors.pop() || ''];\n    while (contextSelectors.length > 0) {\n        const length = combined.length;\n        const contextSelector = contextSelectors.pop();\n        for (let i = 0; i < length; i++) {\n            const previousSelectors = combined[i];\n            // Add the new selector as a descendant of the previous selectors\n            combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n            // Add the new selector as an ancestor of the previous selectors\n            combined[length + i] = contextSelector + ' ' + previousSelectors;\n            // Add the new selector to act on the same element as the previous selectors\n            combined[i] = contextSelector + previousSelectors;\n        }\n    }\n    // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n    // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n    return combined\n        .map(s => otherSelectorsHasHost ?\n        `${s}${otherSelectors}` :\n        `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n        .join(',');\n}\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nfunction repeatGroups(groups, multiples) {\n    const length = groups.length;\n    for (let i = 1; i < multiples; i++) {\n        for (let j = 0; j < length; j++) {\n            groups[j + (i * length)] = groups[j].slice(0);\n        }\n    }\n}\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nfunction parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // constructed in a [key, value, key, value] format.\n    const styles = [];\n    let i = 0;\n    let parenDepth = 0;\n    let quote = 0 /* Char.QuoteNone */;\n    let valueStart = 0;\n    let propStart = 0;\n    let currentProp = null;\n    while (i < value.length) {\n        const token = value.charCodeAt(i++);\n        switch (token) {\n            case 40 /* Char.OpenParen */:\n                parenDepth++;\n                break;\n            case 41 /* Char.CloseParen */:\n                parenDepth--;\n                break;\n            case 39 /* Char.QuoteSingle */:\n                // valueStart needs to be there since prop values don't\n                // have quotes in CSS\n                if (quote === 0 /* Char.QuoteNone */) {\n                    quote = 39 /* Char.QuoteSingle */;\n                }\n                else if (quote === 39 /* Char.QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* Char.BackSlash */) {\n                    quote = 0 /* Char.QuoteNone */;\n                }\n                break;\n            case 34 /* Char.QuoteDouble */:\n                // same logic as above\n                if (quote === 0 /* Char.QuoteNone */) {\n                    quote = 34 /* Char.QuoteDouble */;\n                }\n                else if (quote === 34 /* Char.QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* Char.BackSlash */) {\n                    quote = 0 /* Char.QuoteNone */;\n                }\n                break;\n            case 58 /* Char.Colon */:\n                if (!currentProp && parenDepth === 0 && quote === 0 /* Char.QuoteNone */) {\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n                    valueStart = i;\n                }\n                break;\n            case 59 /* Char.Semicolon */:\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* Char.QuoteNone */) {\n                    const styleVal = value.substring(valueStart, i - 1).trim();\n                    styles.push(currentProp, styleVal);\n                    propStart = i;\n                    valueStart = 0;\n                    currentProp = null;\n                }\n                break;\n        }\n    }\n    if (currentProp && valueStart) {\n        const styleVal = value.slice(valueStart).trim();\n        styles.push(currentProp, styleVal);\n    }\n    return styles;\n}\nfunction hyphenate(value) {\n    return value\n        .replace(/[a-z][A-Z]/g, v => {\n        return v.charAt(0) + '-' + v.charAt(1);\n    })\n        .toLowerCase();\n}\n\nconst IMPORTANT_FLAG = '!important';\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nconst MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nclass StylingBuilder {\n    constructor(_directiveExpr) {\n        this._directiveExpr = _directiveExpr;\n        /** Whether or not there are any static styling values present */\n        this._hasInitialValues = false;\n        /**\n         *  Whether or not there are any styling bindings present\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n         */\n        this.hasBindings = false;\n        this.hasBindingsWithPipes = false;\n        /** the input for [class] (if it exists) */\n        this._classMapInput = null;\n        /** the input for [style] (if it exists) */\n        this._styleMapInput = null;\n        /** an array of each [style.prop] input */\n        this._singleStyleInputs = null;\n        /** an array of each [class.name] input */\n        this._singleClassInputs = null;\n        this._lastStylingInput = null;\n        this._firstStylingInput = null;\n        // maps are used instead of hash maps because a Map will\n        // retain the ordering of the keys\n        /**\n         * Represents the location of each style binding in the template\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n         * that `width=0` and `height=1`)\n         */\n        this._stylesIndex = new Map();\n        /**\n         * Represents the location of each class binding in the template\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n         * that `big=0` and `hidden=1`)\n         */\n        this._classesIndex = new Map();\n        this._initialStyleValues = [];\n        this._initialClassValues = [];\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n    registerBoundInput(input) {\n        // [attr.style] or [attr.class] are skipped in the code below,\n        // they should not be treated as styling-based bindings since\n        // they are intended to be written directly to the attr and\n        // will therefore skip all style/class resolution that is present\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n        // [class.prop]=\"\". [class]=\"\" assignments\n        let binding = null;\n        let name = input.name;\n        switch (input.type) {\n            case 0 /* BindingType.Property */:\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n                break;\n            case 3 /* BindingType.Style */:\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n                break;\n            case 2 /* BindingType.Class */:\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n                break;\n        }\n        return binding ? true : false;\n    }\n    registerInputBasedOnName(name, expression, sourceSpan) {\n        let binding = null;\n        const prefix = name.substring(0, 6);\n        const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n        const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n        if (isStyle || isClass) {\n            const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n            const property = name.slice(isMapBased ? 5 : 6); // the dot explains why there's a +1\n            if (isStyle) {\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n            }\n            else {\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n            }\n        }\n        return binding;\n    }\n    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        // CSS custom properties are case-sensitive so we shouldn't normalize them.\n        // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n        if (!isCssCustomProperty(name)) {\n            name = hyphenate(name);\n        }\n        const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);\n        suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n        const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };\n        if (isMapBased) {\n            this._styleMapInput = entry;\n        }\n        else {\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n            registerIntoMap(this._stylesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    registerClassInput(name, isMapBased, value, sourceSpan) {\n        if (isEmptyExpression(value)) {\n            return null;\n        }\n        const { property, hasOverrideFlag } = parseProperty(name);\n        const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };\n        if (isMapBased) {\n            this._classMapInput = entry;\n        }\n        else {\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n            registerIntoMap(this._classesIndex, property);\n        }\n        this._lastStylingInput = entry;\n        this._firstStylingInput = this._firstStylingInput || entry;\n        this._checkForPipes(value);\n        this.hasBindings = true;\n        return entry;\n    }\n    _checkForPipes(value) {\n        if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n            this.hasBindingsWithPipes = true;\n        }\n    }\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n    registerStyleAttr(value) {\n        this._initialStyleValues = parse(value);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n    registerClassAttr(value) {\n        this._initialClassValues = value.trim().split(/\\s+/g);\n        this._hasInitialValues = true;\n    }\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n    populateInitialStylingAttrs(attrs) {\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n        if (this._initialClassValues.length) {\n            attrs.push(literal(1 /* AttributeMarker.Classes */));\n            for (let i = 0; i < this._initialClassValues.length; i++) {\n                attrs.push(literal(this._initialClassValues[i]));\n            }\n        }\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n        if (this._initialStyleValues.length) {\n            attrs.push(literal(2 /* AttributeMarker.Styles */));\n            for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\n            }\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n    assignHostAttrs(attrs, definitionMap) {\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n            this.populateInitialStylingAttrs(attrs);\n            definitionMap.set('hostAttrs', literalArr(attrs));\n        }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n    buildClassMapInstruction(valueConverter) {\n        if (this._classMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n        }\n        return null;\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n    buildStyleMapInstruction(valueConverter) {\n        if (this._styleMapInput) {\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n        }\n        return null;\n    }\n    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\n        // each styling binding value is stored in the LView\n        // map-based bindings allocate two slots: one for the\n        // previous binding value and another for the previous\n        // className or style attribute value.\n        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        // these values must be outside of the update block so that they can\n        // be evaluated (the AST visit call) during creation time so that any\n        // pipes can be picked up in time before the template is built\n        const mapValue = stylingInput.value.visit(valueConverter);\n        let reference;\n        if (mapValue instanceof Interpolation) {\n            totalBindingSlotsRequired += mapValue.expressions.length;\n            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                getStyleMapInterpolationExpression(mapValue);\n        }\n        else {\n            reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;\n        }\n        return {\n            reference,\n            calls: [{\n                    supportsInterpolation: true,\n                    sourceSpan: stylingInput.sourceSpan,\n                    allocateBindingSlots: totalBindingSlotsRequired,\n                    params: (convertFn) => {\n                        const convertResult = convertFn(mapValue);\n                        const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n                        return params;\n                    }\n                }]\n        };\n    }\n    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n        const instructions = [];\n        inputs.forEach(input => {\n            const previousInstruction = instructions[instructions.length - 1];\n            const value = input.value.visit(valueConverter);\n            let referenceForCall = reference;\n            // each styling binding value is stored in the LView\n            // but there are two values stored for each binding:\n            //   1) the value itself\n            //   2) an intermediate value (concatenation of style up to this point).\n            //      We need to store the intermediate value so that we don't allocate\n            //      the strings on each CD.\n            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n            if (value instanceof Interpolation) {\n                totalBindingSlotsRequired += value.expressions.length;\n                if (getInterpolationExpressionFn) {\n                    referenceForCall = getInterpolationExpressionFn(value);\n                }\n            }\n            const call = {\n                sourceSpan: input.sourceSpan,\n                allocateBindingSlots: totalBindingSlotsRequired,\n                supportsInterpolation: !!getInterpolationExpressionFn,\n                params: (convertFn) => {\n                    // params => stylingProp(propName, value, suffix)\n                    const params = [];\n                    params.push(literal(input.name));\n                    const convertResult = convertFn(value);\n                    if (Array.isArray(convertResult)) {\n                        params.push(...convertResult);\n                    }\n                    else {\n                        params.push(convertResult);\n                    }\n                    // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n                    // if that is detected then we need to pass that in as an optional param.\n                    if (!isClassBased && input.suffix !== null) {\n                        params.push(literal(input.suffix));\n                    }\n                    return params;\n                }\n            };\n            // If we ended up generating a call to the same instruction as the previous styling property\n            // we can chain the calls together safely to save some bytes, otherwise we have to generate\n            // a separate instruction call. This is primarily a concern with interpolation instructions\n            // where we may start off with one `reference`, but end up using another based on the\n            // number of interpolations.\n            if (previousInstruction && previousInstruction.reference === referenceForCall) {\n                previousInstruction.calls.push(call);\n            }\n            else {\n                instructions.push({ reference: referenceForCall, calls: [call] });\n            }\n        });\n        return instructions;\n    }\n    _buildClassInputs(valueConverter) {\n        if (this._singleClassInputs) {\n            return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);\n        }\n        return [];\n    }\n    _buildStyleInputs(valueConverter) {\n        if (this._singleStyleInputs) {\n            return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n        }\n        return [];\n    }\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n    buildUpdateLevelInstructions(valueConverter) {\n        const instructions = [];\n        if (this.hasBindings) {\n            const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n            if (styleMapInstruction) {\n                instructions.push(styleMapInstruction);\n            }\n            const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n            if (classMapInstruction) {\n                instructions.push(classMapInstruction);\n            }\n            instructions.push(...this._buildStyleInputs(valueConverter));\n            instructions.push(...this._buildClassInputs(valueConverter));\n        }\n        return instructions;\n    }\n}\nfunction registerIntoMap(map, key) {\n    if (!map.has(key)) {\n        map.set(key, map.size);\n    }\n}\nfunction parseProperty(name) {\n    let hasOverrideFlag = false;\n    const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n    if (overrideIndex !== -1) {\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n        hasOverrideFlag = true;\n    }\n    let suffix = null;\n    let property = name;\n    const unitIndex = name.lastIndexOf('.');\n    if (unitIndex > 0) {\n        suffix = name.slice(unitIndex + 1);\n        property = name.substring(0, unitIndex);\n    }\n    return { property, suffix, hasOverrideFlag };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.classMap;\n        case 3:\n            return Identifiers.classMapInterpolate1;\n        case 5:\n            return Identifiers.classMapInterpolate2;\n        case 7:\n            return Identifiers.classMapInterpolate3;\n        case 9:\n            return Identifiers.classMapInterpolate4;\n        case 11:\n            return Identifiers.classMapInterpolate5;\n        case 13:\n            return Identifiers.classMapInterpolate6;\n        case 15:\n            return Identifiers.classMapInterpolate7;\n        case 17:\n            return Identifiers.classMapInterpolate8;\n        default:\n            return Identifiers.classMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.styleMap;\n        case 3:\n            return Identifiers.styleMapInterpolate1;\n        case 5:\n            return Identifiers.styleMapInterpolate2;\n        case 7:\n            return Identifiers.styleMapInterpolate3;\n        case 9:\n            return Identifiers.styleMapInterpolate4;\n        case 11:\n            return Identifiers.styleMapInterpolate5;\n        case 13:\n            return Identifiers.styleMapInterpolate6;\n        case 15:\n            return Identifiers.styleMapInterpolate7;\n        case 17:\n            return Identifiers.styleMapInterpolate8;\n        default:\n            return Identifiers.styleMapInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.styleProp;\n        case 3:\n            return Identifiers.stylePropInterpolate1;\n        case 5:\n            return Identifiers.stylePropInterpolate2;\n        case 7:\n            return Identifiers.stylePropInterpolate3;\n        case 9:\n            return Identifiers.stylePropInterpolate4;\n        case 11:\n            return Identifiers.stylePropInterpolate5;\n        case 13:\n            return Identifiers.stylePropInterpolate6;\n        case 15:\n            return Identifiers.stylePropInterpolate7;\n        case 17:\n            return Identifiers.stylePropInterpolate8;\n        default:\n            return Identifiers.stylePropInterpolateV;\n    }\n}\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name) {\n    return name.startsWith('--');\n}\nfunction isEmptyExpression(ast) {\n    if (ast instanceof ASTWithSource) {\n        ast = ast.ast;\n    }\n    return ast instanceof EmptyExpr;\n}\n\nvar TokenType;\n(function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n    TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 4] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 7] = \"Error\";\n})(TokenType || (TokenType = {}));\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nclass Lexer {\n    tokenize(text) {\n        const scanner = new _Scanner(text);\n        const tokens = [];\n        let token = scanner.scanToken();\n        while (token != null) {\n            tokens.push(token);\n            token = scanner.scanToken();\n        }\n        return tokens;\n    }\n}\nclass Token {\n    constructor(index, end, type, numValue, strValue) {\n        this.index = index;\n        this.end = end;\n        this.type = type;\n        this.numValue = numValue;\n        this.strValue = strValue;\n    }\n    isCharacter(code) {\n        return this.type == TokenType.Character && this.numValue == code;\n    }\n    isNumber() {\n        return this.type == TokenType.Number;\n    }\n    isString() {\n        return this.type == TokenType.String;\n    }\n    isOperator(operator) {\n        return this.type == TokenType.Operator && this.strValue == operator;\n    }\n    isIdentifier() {\n        return this.type == TokenType.Identifier;\n    }\n    isPrivateIdentifier() {\n        return this.type == TokenType.PrivateIdentifier;\n    }\n    isKeyword() {\n        return this.type == TokenType.Keyword;\n    }\n    isKeywordLet() {\n        return this.type == TokenType.Keyword && this.strValue == 'let';\n    }\n    isKeywordAs() {\n        return this.type == TokenType.Keyword && this.strValue == 'as';\n    }\n    isKeywordNull() {\n        return this.type == TokenType.Keyword && this.strValue == 'null';\n    }\n    isKeywordUndefined() {\n        return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    }\n    isKeywordTrue() {\n        return this.type == TokenType.Keyword && this.strValue == 'true';\n    }\n    isKeywordFalse() {\n        return this.type == TokenType.Keyword && this.strValue == 'false';\n    }\n    isKeywordThis() {\n        return this.type == TokenType.Keyword && this.strValue == 'this';\n    }\n    isError() {\n        return this.type == TokenType.Error;\n    }\n    toNumber() {\n        return this.type == TokenType.Number ? this.numValue : -1;\n    }\n    toString() {\n        switch (this.type) {\n            case TokenType.Character:\n            case TokenType.Identifier:\n            case TokenType.Keyword:\n            case TokenType.Operator:\n            case TokenType.PrivateIdentifier:\n            case TokenType.String:\n            case TokenType.Error:\n                return this.strValue;\n            case TokenType.Number:\n                return this.numValue.toString();\n            default:\n                return null;\n        }\n    }\n}\nfunction newCharacterToken(index, end, code) {\n    return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\nfunction newIdentifierToken(index, end, text) {\n    return new Token(index, end, TokenType.Identifier, 0, text);\n}\nfunction newPrivateIdentifierToken(index, end, text) {\n    return new Token(index, end, TokenType.PrivateIdentifier, 0, text);\n}\nfunction newKeywordToken(index, end, text) {\n    return new Token(index, end, TokenType.Keyword, 0, text);\n}\nfunction newOperatorToken(index, end, text) {\n    return new Token(index, end, TokenType.Operator, 0, text);\n}\nfunction newStringToken(index, end, text) {\n    return new Token(index, end, TokenType.String, 0, text);\n}\nfunction newNumberToken(index, end, n) {\n    return new Token(index, end, TokenType.Number, n, '');\n}\nfunction newErrorToken(index, end, message) {\n    return new Token(index, end, TokenType.Error, 0, message);\n}\nconst EOF = new Token(-1, -1, TokenType.Character, 0, '');\nclass _Scanner {\n    constructor(input) {\n        this.input = input;\n        this.peek = 0;\n        this.index = -1;\n        this.length = input.length;\n        this.advance();\n    }\n    advance() {\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    }\n    scanToken() {\n        const input = this.input, length = this.length;\n        let peek = this.peek, index = this.index;\n        // Skip whitespace.\n        while (peek <= $SPACE) {\n            if (++index >= length) {\n                peek = $EOF;\n                break;\n            }\n            else {\n                peek = input.charCodeAt(index);\n            }\n        }\n        this.peek = peek;\n        this.index = index;\n        if (index >= length) {\n            return null;\n        }\n        // Handle identifiers and numbers.\n        if (isIdentifierStart(peek))\n            return this.scanIdentifier();\n        if (isDigit(peek))\n            return this.scanNumber(index);\n        const start = index;\n        switch (peek) {\n            case $PERIOD:\n                this.advance();\n                return isDigit(this.peek) ? this.scanNumber(start) :\n                    newCharacterToken(start, this.index, $PERIOD);\n            case $LPAREN:\n            case $RPAREN:\n            case $LBRACE:\n            case $RBRACE:\n            case $LBRACKET:\n            case $RBRACKET:\n            case $COMMA:\n            case $COLON:\n            case $SEMICOLON:\n                return this.scanCharacter(start, peek);\n            case $SQ:\n            case $DQ:\n                return this.scanString();\n            case $HASH:\n                return this.scanPrivateIdentifier();\n            case $PLUS:\n            case $MINUS:\n            case $STAR:\n            case $SLASH:\n            case $PERCENT:\n            case $CARET:\n                return this.scanOperator(start, String.fromCharCode(peek));\n            case $QUESTION:\n                return this.scanQuestion(start);\n            case $LT:\n            case $GT:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n            case $BANG:\n            case $EQ:\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n            case $AMPERSAND:\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n            case $BAR:\n                return this.scanComplexOperator(start, '|', $BAR, '|');\n            case $NBSP:\n                while (isWhitespace(this.peek))\n                    this.advance();\n                return this.scanToken();\n        }\n        this.advance();\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n    }\n    scanCharacter(start, code) {\n        this.advance();\n        return newCharacterToken(start, this.index, code);\n    }\n    scanOperator(start, str) {\n        this.advance();\n        return newOperatorToken(start, this.index, str);\n    }\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n    scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n        this.advance();\n        let str = one;\n        if (this.peek == twoCode) {\n            this.advance();\n            str += two;\n        }\n        if (threeCode != null && this.peek == threeCode) {\n            this.advance();\n            str += three;\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    scanIdentifier() {\n        const start = this.index;\n        this.advance();\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const str = this.input.substring(start, this.index);\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n            newIdentifierToken(start, this.index, str);\n    }\n    /** Scans an ECMAScript private identifier. */\n    scanPrivateIdentifier() {\n        const start = this.index;\n        this.advance();\n        if (!isIdentifierStart(this.peek)) {\n            return this.error('Invalid character [#]', -1);\n        }\n        while (isIdentifierPart(this.peek))\n            this.advance();\n        const identifierName = this.input.substring(start, this.index);\n        return newPrivateIdentifierToken(start, this.index, identifierName);\n    }\n    scanNumber(start) {\n        let simple = (this.index === start);\n        let hasSeparators = false;\n        this.advance(); // Skip initial digit.\n        while (true) {\n            if (isDigit(this.peek)) {\n                // Do nothing.\n            }\n            else if (this.peek === $_) {\n                // Separators are only valid when they're surrounded by digits. E.g. `1_0_1` is\n                // valid while `_101` and `101_` are not. The separator can't be next to the decimal\n                // point or another separator either. Note that it's unlikely that we'll hit a case where\n                // the underscore is at the start, because that's a valid identifier and it will be picked\n                // up earlier in the parsing. We validate for it anyway just in case.\n                if (!isDigit(this.input.charCodeAt(this.index - 1)) ||\n                    !isDigit(this.input.charCodeAt(this.index + 1))) {\n                    return this.error('Invalid numeric separator', 0);\n                }\n                hasSeparators = true;\n            }\n            else if (this.peek === $PERIOD) {\n                simple = false;\n            }\n            else if (isExponentStart(this.peek)) {\n                this.advance();\n                if (isExponentSign(this.peek))\n                    this.advance();\n                if (!isDigit(this.peek))\n                    return this.error('Invalid exponent', -1);\n                simple = false;\n            }\n            else {\n                break;\n            }\n            this.advance();\n        }\n        let str = this.input.substring(start, this.index);\n        if (hasSeparators) {\n            str = str.replace(/_/g, '');\n        }\n        const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n        return newNumberToken(start, this.index, value);\n    }\n    scanString() {\n        const start = this.index;\n        const quote = this.peek;\n        this.advance(); // Skip initial quote.\n        let buffer = '';\n        let marker = this.index;\n        const input = this.input;\n        while (this.peek != quote) {\n            if (this.peek == $BACKSLASH) {\n                buffer += input.substring(marker, this.index);\n                let unescapedCode;\n                this.advance(); // mutates this.peek\n                // @ts-expect-error see microsoft/TypeScript#9998\n                if (this.peek == $u) {\n                    // 4 character hex code for unicode character.\n                    const hex = input.substring(this.index + 1, this.index + 5);\n                    if (/^[0-9a-f]+$/i.test(hex)) {\n                        unescapedCode = parseInt(hex, 16);\n                    }\n                    else {\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n                    }\n                    for (let i = 0; i < 5; i++) {\n                        this.advance();\n                    }\n                }\n                else {\n                    unescapedCode = unescape(this.peek);\n                    this.advance();\n                }\n                buffer += String.fromCharCode(unescapedCode);\n                marker = this.index;\n            }\n            else if (this.peek == $EOF) {\n                return this.error('Unterminated quote', 0);\n            }\n            else {\n                this.advance();\n            }\n        }\n        const last = input.substring(marker, this.index);\n        this.advance(); // Skip terminating quote.\n        return newStringToken(start, this.index, buffer + last);\n    }\n    scanQuestion(start) {\n        this.advance();\n        let str = '?';\n        // Either `a ?? b` or 'a?.b'.\n        if (this.peek === $QUESTION || this.peek === $PERIOD) {\n            str += this.peek === $PERIOD ? '.' : '?';\n            this.advance();\n        }\n        return newOperatorToken(start, this.index, str);\n    }\n    error(message, offset) {\n        const position = this.index + offset;\n        return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n    }\n}\nfunction isIdentifierStart(code) {\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n        (code == $_) || (code == $$);\n}\nfunction isIdentifier(input) {\n    if (input.length == 0)\n        return false;\n    const scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek))\n        return false;\n    scanner.advance();\n    while (scanner.peek !== $EOF) {\n        if (!isIdentifierPart(scanner.peek))\n            return false;\n        scanner.advance();\n    }\n    return true;\n}\nfunction isIdentifierPart(code) {\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\n        (code == $$);\n}\nfunction isExponentStart(code) {\n    return code == $e || code == $E;\n}\nfunction isExponentSign(code) {\n    return code == $MINUS || code == $PLUS;\n}\nfunction unescape(code) {\n    switch (code) {\n        case $n:\n            return $LF;\n        case $f:\n            return $FF;\n        case $r:\n            return $CR;\n        case $t:\n            return $TAB;\n        case $v:\n            return $VTAB;\n        default:\n            return code;\n    }\n}\nfunction parseIntAutoRadix(text) {\n    const result = parseInt(text);\n    if (isNaN(result)) {\n        throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n}\n\nclass SplitInterpolation {\n    constructor(strings, expressions, offsets) {\n        this.strings = strings;\n        this.expressions = expressions;\n        this.offsets = offsets;\n    }\n}\nclass TemplateBindingParseResult {\n    constructor(templateBindings, warnings, errors) {\n        this.templateBindings = templateBindings;\n        this.warnings = warnings;\n        this.errors = errors;\n    }\n}\nclass Parser$1 {\n    constructor(_lexer) {\n        this._lexer = _lexer;\n        this.errors = [];\n    }\n    parseAction(input, isAssignmentEvent, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        let flags = 1 /* ParseFlags.Action */;\n        if (isAssignmentEvent) {\n            flags |= 2 /* ParseFlags.AssignmentEvent */;\n        }\n        const ast = new _ParseAST(input, location, absoluteOffset, tokens, flags, this.errors, 0).parseChain();\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    checkSimpleExpression(ast) {\n        const checker = new SimpleExpressionChecker();\n        ast.visit(checker);\n        return checker.errors;\n    }\n    parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n        const errors = this.checkSimpleExpression(ast);\n        if (errors.length > 0) {\n            this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n        }\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n    _reportError(message, input, errLocation, ctxLocation) {\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n    _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\n        this._checkNoInterpolation(input, location, interpolationConfig);\n        const sourceToLex = this._stripComments(input);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        return new _ParseAST(input, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0)\n            .parseChain();\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n        const tokens = this._lexer.tokenize(templateValue);\n        const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0 /* relative offset */);\n        return parser.parseTemplateBindings({\n            source: templateKey,\n            span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n        });\n    }\n    parseInterpolation(input, location, absoluteOffset, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolatedTokens, interpolationConfig);\n        if (expressions.length === 0)\n            return null;\n        const expressionNodes = [];\n        for (let i = 0; i < expressions.length; ++i) {\n            const expressionText = expressions[i].text;\n            const sourceToLex = this._stripComments(expressionText);\n            const tokens = this._lexer.tokenize(sourceToLex);\n            const ast = new _ParseAST(input, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, offsets[i])\n                .parseChain();\n            expressionNodes.push(ast);\n        }\n        return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, location, absoluteOffset) {\n        const sourceToLex = this._stripComments(expression);\n        const tokens = this._lexer.tokenize(sourceToLex);\n        const ast = new _ParseAST(expression, location, absoluteOffset, tokens, 0 /* ParseFlags.None */, this.errors, 0)\n            .parseChain();\n        const strings = ['', '']; // The prefix and suffix strings are both empty\n        return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n    }\n    createInterpolationAst(strings, expressions, input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input.length);\n        const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n        return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n    }\n    /**\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n     * the string.\n     * Returns `null` if there are no interpolations, otherwise a\n     * `SplitInterpolation` with splits that look like\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n     */\n    splitInterpolation(input, location, interpolatedTokens, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n        const strings = [];\n        const expressions = [];\n        const offsets = [];\n        const inputToTemplateIndexMap = interpolatedTokens ? getIndexMapForOriginalTemplate(interpolatedTokens) : null;\n        let i = 0;\n        let atInterpolation = false;\n        let extendLastString = false;\n        let { start: interpStart, end: interpEnd } = interpolationConfig;\n        while (i < input.length) {\n            if (!atInterpolation) {\n                // parse until starting {{\n                const start = i;\n                i = input.indexOf(interpStart, i);\n                if (i === -1) {\n                    i = input.length;\n                }\n                const text = input.substring(start, i);\n                strings.push({ text, start, end: i });\n                atInterpolation = true;\n            }\n            else {\n                // parse from starting {{ to ending }} while ignoring content inside quotes.\n                const fullStart = i;\n                const exprStart = fullStart + interpStart.length;\n                const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n                if (exprEnd === -1) {\n                    // Could not find the end of the interpolation; do not parse an expression.\n                    // Instead we should extend the content on the last raw string.\n                    atInterpolation = false;\n                    extendLastString = true;\n                    break;\n                }\n                const fullEnd = exprEnd + interpEnd.length;\n                const text = input.substring(exprStart, exprEnd);\n                if (text.trim().length === 0) {\n                    this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);\n                }\n                expressions.push({ text, start: fullStart, end: fullEnd });\n                const startInOriginalTemplate = inputToTemplateIndexMap?.get(fullStart) ?? fullStart;\n                const offset = startInOriginalTemplate + interpStart.length;\n                offsets.push(offset);\n                i = fullEnd;\n                atInterpolation = false;\n            }\n        }\n        if (!atInterpolation) {\n            // If we are now at a text section, add the remaining content as a raw string.\n            if (extendLastString) {\n                const piece = strings[strings.length - 1];\n                piece.text += input.substring(i);\n                piece.end = input.length;\n            }\n            else {\n                strings.push({ text: input.substring(i), start: i, end: input.length });\n            }\n        }\n        return new SplitInterpolation(strings, expressions, offsets);\n    }\n    wrapLiteralPrimitive(input, location, absoluteOffset) {\n        const span = new ParseSpan(0, input == null ? 0 : input.length);\n        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    }\n    _stripComments(input) {\n        const i = this._commentStart(input);\n        return i != null ? input.substring(0, i) : input;\n    }\n    _commentStart(input) {\n        let outerQuote = null;\n        for (let i = 0; i < input.length - 1; i++) {\n            const char = input.charCodeAt(i);\n            const nextChar = input.charCodeAt(i + 1);\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\n                return i;\n            if (outerQuote === char) {\n                outerQuote = null;\n            }\n            else if (outerQuote == null && isQuote(char)) {\n                outerQuote = char;\n            }\n        }\n        return null;\n    }\n    _checkNoInterpolation(input, location, { start, end }) {\n        let startIndex = -1;\n        let endIndex = -1;\n        for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n            if (startIndex === -1) {\n                if (input.startsWith(start)) {\n                    startIndex = charIndex;\n                }\n            }\n            else {\n                endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n                if (endIndex > -1) {\n                    break;\n                }\n            }\n        }\n        if (startIndex > -1 && endIndex > -1) {\n            this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);\n        }\n    }\n    /**\n     * Finds the index of the end of an interpolation expression\n     * while ignoring comments and quoted content.\n     */\n    _getInterpolationEndIndex(input, expressionEnd, start) {\n        for (const charIndex of this._forEachUnquotedChar(input, start)) {\n            if (input.startsWith(expressionEnd, charIndex)) {\n                return charIndex;\n            }\n            // Nothing else in the expression matters after we've\n            // hit a comment so look directly for the end token.\n            if (input.startsWith('//', charIndex)) {\n                return input.indexOf(expressionEnd, charIndex);\n            }\n        }\n        return -1;\n    }\n    /**\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\n     * @param input String to loop through.\n     * @param start Index within the string at which to start.\n     */\n    *_forEachUnquotedChar(input, start) {\n        let currentQuote = null;\n        let escapeCount = 0;\n        for (let i = start; i < input.length; i++) {\n            const char = input[i];\n            // Skip the characters inside quotes. Note that we only care about the outer-most\n            // quotes matching up and we need to account for escape characters.\n            if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n                escapeCount % 2 === 0) {\n                currentQuote = currentQuote === null ? char : null;\n            }\n            else if (currentQuote === null) {\n                yield i;\n            }\n            escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n        }\n    }\n}\n/** Describes a stateful context an expression parser is in. */\nvar ParseContextFlags;\n(function (ParseContextFlags) {\n    ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n    /**\n     * A Writable context is one in which a value may be written to an lvalue.\n     * For example, after we see a property access, we may expect a write to the\n     * property via the \"=\" operator.\n     *   prop\n     *        ^ possible \"=\" after\n     */\n    ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\nclass _ParseAST {\n    constructor(input, location, absoluteOffset, tokens, parseFlags, errors, offset) {\n        this.input = input;\n        this.location = location;\n        this.absoluteOffset = absoluteOffset;\n        this.tokens = tokens;\n        this.parseFlags = parseFlags;\n        this.errors = errors;\n        this.offset = offset;\n        this.rparensExpected = 0;\n        this.rbracketsExpected = 0;\n        this.rbracesExpected = 0;\n        this.context = ParseContextFlags.None;\n        // Cache of expression start and input indeces to the absolute source span they map to, used to\n        // prevent creating superfluous source spans in `sourceSpan`.\n        // A serial of the expression start and input index is used for mapping because both are stateful\n        // and may change for subsequent expressions visited by the parser.\n        this.sourceSpanCache = new Map();\n        this.index = 0;\n    }\n    peek(offset) {\n        const i = this.index + offset;\n        return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n    get next() {\n        return this.peek(0);\n    }\n    /** Whether all the parser input has been processed. */\n    get atEOF() {\n        return this.index >= this.tokens.length;\n    }\n    /**\n     * Index of the next token to be processed, or the end of the last token if all have been\n     * processed.\n     */\n    get inputIndex() {\n        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n    }\n    /**\n     * End index of the last processed token, or the start of the first token if none have been\n     * processed.\n     */\n    get currentEndIndex() {\n        if (this.index > 0) {\n            const curToken = this.peek(-1);\n            return curToken.end + this.offset;\n        }\n        // No tokens have been processed yet; return the next token's start or the length of the input\n        // if there is no token.\n        if (this.tokens.length === 0) {\n            return this.input.length + this.offset;\n        }\n        return this.next.index + this.offset;\n    }\n    /**\n     * Returns the absolute offset of the start of the current token.\n     */\n    get currentAbsoluteOffset() {\n        return this.absoluteOffset + this.inputIndex;\n    }\n    /**\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n     * provided).\n     *\n     * @param start Position from which the `ParseSpan` will start.\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n     *     natural ending index)\n     */\n    span(start, artificialEndIndex) {\n        let endIndex = this.currentEndIndex;\n        if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n            endIndex = artificialEndIndex;\n        }\n        // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n        // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n        // appears to be a deep-seated parser bug.\n        //\n        // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n        // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n        if (start > endIndex) {\n            const tmp = endIndex;\n            endIndex = start;\n            start = tmp;\n        }\n        return new ParseSpan(start, endIndex);\n    }\n    sourceSpan(start, artificialEndIndex) {\n        const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n        if (!this.sourceSpanCache.has(serial)) {\n            this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n        }\n        return this.sourceSpanCache.get(serial);\n    }\n    advance() {\n        this.index++;\n    }\n    /**\n     * Executes a callback in the provided context.\n     */\n    withContext(context, cb) {\n        this.context |= context;\n        const ret = cb();\n        this.context ^= context;\n        return ret;\n    }\n    consumeOptionalCharacter(code) {\n        if (this.next.isCharacter(code)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    peekKeywordLet() {\n        return this.next.isKeywordLet();\n    }\n    peekKeywordAs() {\n        return this.next.isKeywordAs();\n    }\n    /**\n     * Consumes an expected character, otherwise emits an error about the missing expected character\n     * and skips over the token stream until reaching a recoverable point.\n     *\n     * See `this.error` and `this.skip` for more details.\n     */\n    expectCharacter(code) {\n        if (this.consumeOptionalCharacter(code))\n            return;\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\n    }\n    consumeOptionalOperator(op) {\n        if (this.next.isOperator(op)) {\n            this.advance();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    expectOperator(operator) {\n        if (this.consumeOptionalOperator(operator))\n            return;\n        this.error(`Missing expected operator ${operator}`);\n    }\n    prettyPrintToken(tok) {\n        return tok === EOF ? 'end of input' : `token ${tok}`;\n    }\n    expectIdentifierOrKeyword() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n            }\n            return null;\n        }\n        this.advance();\n        return n.toString();\n    }\n    expectIdentifierOrKeywordOrString() {\n        const n = this.next;\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n            if (n.isPrivateIdentifier()) {\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n            }\n            else {\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n            }\n            return '';\n        }\n        this.advance();\n        return n.toString();\n    }\n    parseChain() {\n        const exprs = [];\n        const start = this.inputIndex;\n        while (this.index < this.tokens.length) {\n            const expr = this.parsePipe();\n            exprs.push(expr);\n            if (this.consumeOptionalCharacter($SEMICOLON)) {\n                if (!(this.parseFlags & 1 /* ParseFlags.Action */)) {\n                    this.error('Binding expression cannot contain chained expression');\n                }\n                while (this.consumeOptionalCharacter($SEMICOLON)) {\n                } // read all semicolons\n            }\n            else if (this.index < this.tokens.length) {\n                const errorIndex = this.index;\n                this.error(`Unexpected token '${this.next}'`);\n                // The `error` call above will skip ahead to the next recovery point in an attempt to\n                // recover part of the expression, but that might be the token we started from which will\n                // lead to an infinite loop. If that's the case, break the loop assuming that we can't\n                // parse further.\n                if (this.index === errorIndex) {\n                    break;\n                }\n            }\n        }\n        if (exprs.length === 0) {\n            // We have no expressions so create an empty expression that spans the entire input length\n            const artificialStart = this.offset;\n            const artificialEnd = this.offset + this.input.length;\n            return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n        }\n        if (exprs.length == 1)\n            return exprs[0];\n        return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    }\n    parsePipe() {\n        const start = this.inputIndex;\n        let result = this.parseExpression();\n        if (this.consumeOptionalOperator('|')) {\n            if (this.parseFlags & 1 /* ParseFlags.Action */) {\n                this.error('Cannot have a pipe in an action expression');\n            }\n            do {\n                const nameStart = this.inputIndex;\n                let nameId = this.expectIdentifierOrKeyword();\n                let nameSpan;\n                let fullSpanEnd = undefined;\n                if (nameId !== null) {\n                    nameSpan = this.sourceSpan(nameStart);\n                }\n                else {\n                    // No valid identifier was found, so we'll assume an empty pipe name ('').\n                    nameId = '';\n                    // However, there may have been whitespace present between the pipe character and the next\n                    // token in the sequence (or the end of input). We want to track this whitespace so that\n                    // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n                    // whitespace beyond it. Another way of thinking about this is that the zero-length name\n                    // is assumed to be at the end of any whitespace beyond the pipe character.\n                    //\n                    // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n                    // beginning of the next token, or until the end of input if the next token is EOF.\n                    fullSpanEnd = this.next.index !== -1 ? this.next.index : this.input.length + this.offset;\n                    // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n                    // beyond the pipe character.\n                    nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n                }\n                const args = [];\n                while (this.consumeOptionalCharacter($COLON)) {\n                    args.push(this.parseExpression());\n                    // If there are additional expressions beyond the name, then the artificial end for the\n                    // name is no longer relevant.\n                }\n                result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n            } while (this.consumeOptionalOperator('|'));\n        }\n        return result;\n    }\n    parseExpression() {\n        return this.parseConditional();\n    }\n    parseConditional() {\n        const start = this.inputIndex;\n        const result = this.parseLogicalOr();\n        if (this.consumeOptionalOperator('?')) {\n            const yes = this.parsePipe();\n            let no;\n            if (!this.consumeOptionalCharacter($COLON)) {\n                const end = this.inputIndex;\n                const expression = this.input.substring(start, end);\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\n                no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                no = this.parsePipe();\n            }\n            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n        }\n        else {\n            return result;\n        }\n    }\n    parseLogicalOr() {\n        // '||'\n        const start = this.inputIndex;\n        let result = this.parseLogicalAnd();\n        while (this.consumeOptionalOperator('||')) {\n            const right = this.parseLogicalAnd();\n            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n        }\n        return result;\n    }\n    parseLogicalAnd() {\n        // '&&'\n        const start = this.inputIndex;\n        let result = this.parseNullishCoalescing();\n        while (this.consumeOptionalOperator('&&')) {\n            const right = this.parseNullishCoalescing();\n            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n        }\n        return result;\n    }\n    parseNullishCoalescing() {\n        // '??'\n        const start = this.inputIndex;\n        let result = this.parseEquality();\n        while (this.consumeOptionalOperator('??')) {\n            const right = this.parseEquality();\n            result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n        }\n        return result;\n    }\n    parseEquality() {\n        // '==','!=','===','!=='\n        const start = this.inputIndex;\n        let result = this.parseRelational();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '==':\n                case '===':\n                case '!=':\n                case '!==':\n                    this.advance();\n                    const right = this.parseRelational();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseRelational() {\n        // '<', '>', '<=', '>='\n        const start = this.inputIndex;\n        let result = this.parseAdditive();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '<':\n                case '>':\n                case '<=':\n                case '>=':\n                    this.advance();\n                    const right = this.parseAdditive();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseAdditive() {\n        // '+', '-'\n        const start = this.inputIndex;\n        let result = this.parseMultiplicative();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '+':\n                case '-':\n                    this.advance();\n                    let right = this.parseMultiplicative();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parseMultiplicative() {\n        // '*', '%', '/'\n        const start = this.inputIndex;\n        let result = this.parsePrefix();\n        while (this.next.type == TokenType.Operator) {\n            const operator = this.next.strValue;\n            switch (operator) {\n                case '*':\n                case '%':\n                case '/':\n                    this.advance();\n                    let right = this.parsePrefix();\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n                    continue;\n            }\n            break;\n        }\n        return result;\n    }\n    parsePrefix() {\n        if (this.next.type == TokenType.Operator) {\n            const start = this.inputIndex;\n            const operator = this.next.strValue;\n            let result;\n            switch (operator) {\n                case '+':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n                case '-':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n                case '!':\n                    this.advance();\n                    result = this.parsePrefix();\n                    return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n            }\n        }\n        return this.parseCallChain();\n    }\n    parseCallChain() {\n        const start = this.inputIndex;\n        let result = this.parsePrimary();\n        while (true) {\n            if (this.consumeOptionalCharacter($PERIOD)) {\n                result = this.parseAccessMember(result, start, false);\n            }\n            else if (this.consumeOptionalOperator('?.')) {\n                if (this.consumeOptionalCharacter($LPAREN)) {\n                    result = this.parseCall(result, start, true);\n                }\n                else {\n                    result = this.consumeOptionalCharacter($LBRACKET) ?\n                        this.parseKeyedReadOrWrite(result, start, true) :\n                        this.parseAccessMember(result, start, true);\n                }\n            }\n            else if (this.consumeOptionalCharacter($LBRACKET)) {\n                result = this.parseKeyedReadOrWrite(result, start, false);\n            }\n            else if (this.consumeOptionalCharacter($LPAREN)) {\n                result = this.parseCall(result, start, false);\n            }\n            else if (this.consumeOptionalOperator('!')) {\n                result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n            }\n            else {\n                return result;\n            }\n        }\n    }\n    parsePrimary() {\n        const start = this.inputIndex;\n        if (this.consumeOptionalCharacter($LPAREN)) {\n            this.rparensExpected++;\n            const result = this.parsePipe();\n            this.rparensExpected--;\n            this.expectCharacter($RPAREN);\n            return result;\n        }\n        else if (this.next.isKeywordNull()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n        }\n        else if (this.next.isKeywordUndefined()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n        }\n        else if (this.next.isKeywordTrue()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n        }\n        else if (this.next.isKeywordFalse()) {\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n        }\n        else if (this.next.isKeywordThis()) {\n            this.advance();\n            return new ThisReceiver(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.consumeOptionalCharacter($LBRACKET)) {\n            this.rbracketsExpected++;\n            const elements = this.parseExpressionList($RBRACKET);\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n        }\n        else if (this.next.isCharacter($LBRACE)) {\n            return this.parseLiteralMap();\n        }\n        else if (this.next.isIdentifier()) {\n            return this.parseAccessMember(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n        }\n        else if (this.next.isNumber()) {\n            const value = this.next.toNumber();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n        }\n        else if (this.next.isString()) {\n            const literalValue = this.next.toString();\n            this.advance();\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n        }\n        else if (this.next.isPrivateIdentifier()) {\n            this._reportErrorForPrivateIdentifier(this.next, null);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else if (this.index >= this.tokens.length) {\n            this.error(`Unexpected end of expression: ${this.input}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n        else {\n            this.error(`Unexpected token ${this.next}`);\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        }\n    }\n    parseExpressionList(terminator) {\n        const result = [];\n        do {\n            if (!this.next.isCharacter(terminator)) {\n                result.push(this.parsePipe());\n            }\n            else {\n                break;\n            }\n        } while (this.consumeOptionalCharacter($COMMA));\n        return result;\n    }\n    parseLiteralMap() {\n        const keys = [];\n        const values = [];\n        const start = this.inputIndex;\n        this.expectCharacter($LBRACE);\n        if (!this.consumeOptionalCharacter($RBRACE)) {\n            this.rbracesExpected++;\n            do {\n                const keyStart = this.inputIndex;\n                const quoted = this.next.isString();\n                const key = this.expectIdentifierOrKeywordOrString();\n                keys.push({ key, quoted });\n                // Properties with quoted keys can't use the shorthand syntax.\n                if (quoted) {\n                    this.expectCharacter($COLON);\n                    values.push(this.parsePipe());\n                }\n                else if (this.consumeOptionalCharacter($COLON)) {\n                    values.push(this.parsePipe());\n                }\n                else {\n                    const span = this.span(keyStart);\n                    const sourceSpan = this.sourceSpan(keyStart);\n                    values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n                }\n            } while (this.consumeOptionalCharacter($COMMA) &&\n                !this.next.isCharacter($RBRACE));\n            this.rbracesExpected--;\n            this.expectCharacter($RBRACE);\n        }\n        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    }\n    parseAccessMember(readReceiver, start, isSafe) {\n        const nameStart = this.inputIndex;\n        const id = this.withContext(ParseContextFlags.Writable, () => {\n            const id = this.expectIdentifierOrKeyword() ?? '';\n            if (id.length === 0) {\n                this.error(`Expected identifier for property access`, readReceiver.span.end);\n            }\n            return id;\n        });\n        const nameSpan = this.sourceSpan(nameStart);\n        let receiver;\n        if (isSafe) {\n            if (this.consumeOptionalAssignment()) {\n                this.error('The \\'?.\\' operator cannot be used in the assignment');\n                receiver = new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n            else {\n                receiver = new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        else {\n            if (this.consumeOptionalAssignment()) {\n                if (!(this.parseFlags & 1 /* ParseFlags.Action */)) {\n                    this.error('Bindings cannot contain assignments');\n                    return new EmptyExpr(this.span(start), this.sourceSpan(start));\n                }\n                const value = this.parseConditional();\n                receiver = new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id, value);\n            }\n            else {\n                receiver =\n                    new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, readReceiver, id);\n            }\n        }\n        return receiver;\n    }\n    parseCall(receiver, start, isSafe) {\n        const argumentStart = this.inputIndex;\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n        this.expectCharacter($RPAREN);\n        this.rparensExpected--;\n        const span = this.span(start);\n        const sourceSpan = this.sourceSpan(start);\n        return isSafe ? new SafeCall(span, sourceSpan, receiver, args, argumentSpan) :\n            new Call(span, sourceSpan, receiver, args, argumentSpan);\n    }\n    consumeOptionalAssignment() {\n        // When parsing assignment events (originating from two-way-binding aka banana-in-a-box syntax),\n        // it is valid for the primary expression to be terminated by the non-null operator. This\n        // primary expression is substituted as LHS of the assignment operator to achieve\n        // two-way-binding, such that the LHS could be the non-null operator. The grammar doesn't\n        // naturally allow for this syntax, so assignment events are parsed specially.\n        if ((this.parseFlags & 2 /* ParseFlags.AssignmentEvent */) && this.next.isOperator('!') &&\n            this.peek(1).isOperator('=')) {\n            // First skip over the ! operator.\n            this.advance();\n            // Then skip over the = operator, to fully consume the optional assignment operator.\n            this.advance();\n            return true;\n        }\n        return this.consumeOptionalOperator('=');\n    }\n    parseCallArguments() {\n        if (this.next.isCharacter($RPAREN))\n            return [];\n        const positionals = [];\n        do {\n            positionals.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n        return positionals;\n    }\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n    expectTemplateBindingKey() {\n        let result = '';\n        let operatorFound = false;\n        const start = this.currentAbsoluteOffset;\n        do {\n            result += this.expectIdentifierOrKeywordOrString();\n            operatorFound = this.consumeOptionalOperator('-');\n            if (operatorFound) {\n                result += '-';\n            }\n        } while (operatorFound);\n        return {\n            source: result,\n            span: new AbsoluteSourceSpan(start, start + result.length),\n        };\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n    parseTemplateBindings(templateKey) {\n        const bindings = [];\n        // The first binding is for the template key itself\n        // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n        // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n        bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n        while (this.index < this.tokens.length) {\n            // If it starts with 'let', then this must be variable declaration\n            const letBinding = this.parseLetBinding();\n            if (letBinding) {\n                bindings.push(letBinding);\n            }\n            else {\n                // Two possible cases here, either `value \"as\" key` or\n                // \"directive-keyword expression\". We don't know which case, but both\n                // \"value\" and \"directive-keyword\" are template binding key, so consume\n                // the key first.\n                const key = this.expectTemplateBindingKey();\n                // Peek at the next token, if it is \"as\" then this must be variable\n                // declaration.\n                const binding = this.parseAsBinding(key);\n                if (binding) {\n                    bindings.push(binding);\n                }\n                else {\n                    // Otherwise the key must be a directive keyword, like \"of\". Transform\n                    // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n                    key.source =\n                        templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n                    bindings.push(...this.parseDirectiveKeywordBindings(key));\n                }\n            }\n            this.consumeStatementTerminator();\n        }\n        return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n    }\n    parseKeyedReadOrWrite(receiver, start, isSafe) {\n        return this.withContext(ParseContextFlags.Writable, () => {\n            this.rbracketsExpected++;\n            const key = this.parsePipe();\n            if (key instanceof EmptyExpr) {\n                this.error(`Key access cannot be empty`);\n            }\n            this.rbracketsExpected--;\n            this.expectCharacter($RBRACKET);\n            if (this.consumeOptionalOperator('=')) {\n                if (isSafe) {\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\n                }\n                else {\n                    const value = this.parseConditional();\n                    return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\n                }\n            }\n            else {\n                return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\n                    new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\n            }\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        });\n    }\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n    parseDirectiveKeywordBindings(key) {\n        const bindings = [];\n        this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n        const value = this.getDirectiveBoundTarget();\n        let spanEnd = this.currentAbsoluteOffset;\n        // The binding could optionally be followed by \"as\". For example,\n        // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n        // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n        // 'key' in the current context now becomes the \"value\" in the next binding.\n        const asBinding = this.parseAsBinding(key);\n        if (!asBinding) {\n            this.consumeStatementTerminator();\n            spanEnd = this.currentAbsoluteOffset;\n        }\n        const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n        bindings.push(new ExpressionBinding(sourceSpan, key, value));\n        if (asBinding) {\n            bindings.push(asBinding);\n        }\n        return bindings;\n    }\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n    getDirectiveBoundTarget() {\n        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n            return null;\n        }\n        const ast = this.parsePipe(); // example: \"condition | async\"\n        const { start, end } = ast.span;\n        const value = this.input.substring(start, end);\n        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    }\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n    parseAsBinding(value) {\n        if (!this.peekKeywordAs()) {\n            return null;\n        }\n        this.advance(); // consume the 'as' keyword\n        const key = this.expectTemplateBindingKey();\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n    parseLetBinding() {\n        if (!this.peekKeywordLet()) {\n            return null;\n        }\n        const spanStart = this.currentAbsoluteOffset;\n        this.advance(); // consume the 'let' keyword\n        const key = this.expectTemplateBindingKey();\n        let value = null;\n        if (this.consumeOptionalOperator('=')) {\n            value = this.expectTemplateBindingKey();\n        }\n        this.consumeStatementTerminator();\n        const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n        return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n    consumeStatementTerminator() {\n        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    }\n    /**\n     * Records an error and skips over the token stream until reaching a recoverable point. See\n     * `this.skip` for more details on token skipping.\n     */\n    error(message, index = null) {\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n        this.skip();\n    }\n    locationText(index = null) {\n        if (index == null)\n            index = this.index;\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n            `at the end of the expression`;\n    }\n    /**\n     * Records an error for an unexpected private identifier being discovered.\n     * @param token Token representing a private identifier.\n     * @param extraMessage Optional additional message being appended to the error.\n     */\n    _reportErrorForPrivateIdentifier(token, extraMessage) {\n        let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\n        if (extraMessage !== null) {\n            errorMessage += `, ${extraMessage}`;\n        }\n        this.error(errorMessage);\n    }\n    /**\n     * Error recovery should skip tokens until it encounters a recovery point.\n     *\n     * The following are treated as unconditional recovery points:\n     *   - end of input\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n     *\n     * The following are conditional recovery points:\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n     *       an '(' <expr> ')' production).\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\n     *       none of the calling productions are not expecting the closing token else we will never\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n     *       That is, we skip a closing symbol if we are not in a grouping production.\n     *   - '=' in a `Writable` context\n     *     - In this context, we are able to recover after seeing the `=` operator, which\n     *       signals the presence of an independent rvalue expression following the `=` operator.\n     *\n     * If a production expects one of these token it increments the corresponding nesting count,\n     * and then decrements it just prior to checking if the token is in the input.\n     */\n    skip() {\n        let n = this.next;\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\n            !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&\n            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n            if (this.next.isError()) {\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n            }\n            this.advance();\n            n = this.next;\n        }\n    }\n}\nclass SimpleExpressionChecker extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.errors = [];\n    }\n    visitPipe() {\n        this.errors.push('pipes');\n    }\n}\n/**\n * Computes the real offset in the original template for indexes in an interpolation.\n *\n * Because templates can have encoded HTML entities and the input passed to the parser at this stage\n * of the compiler is the _decoded_ value, we need to compute the real offset using the original\n * encoded values in the interpolated tokens. Note that this is only a special case handling for\n * `MlParserTokenType.ENCODED_ENTITY` token types. All other interpolated tokens are expected to\n * have parts which exactly match the input string for parsing the interpolation.\n *\n * @param interpolatedTokens The tokens for the interpolated value.\n *\n * @returns A map of index locations in the decoded template to indexes in the original template\n */\nfunction getIndexMapForOriginalTemplate(interpolatedTokens) {\n    let offsetMap = new Map();\n    let consumedInOriginalTemplate = 0;\n    let consumedInInput = 0;\n    let tokenIndex = 0;\n    while (tokenIndex < interpolatedTokens.length) {\n        const currentToken = interpolatedTokens[tokenIndex];\n        if (currentToken.type === 9 /* MlParserTokenType.ENCODED_ENTITY */) {\n            const [decoded, encoded] = currentToken.parts;\n            consumedInOriginalTemplate += encoded.length;\n            consumedInInput += decoded.length;\n        }\n        else {\n            const lengthOfParts = currentToken.parts.reduce((sum, current) => sum + current.length, 0);\n            consumedInInput += lengthOfParts;\n            consumedInOriginalTemplate += lengthOfParts;\n        }\n        offsetMap.set(consumedInInput, consumedInOriginalTemplate);\n        tokenIndex++;\n    }\n    return offsetMap;\n}\n\nclass NodeWithI18n {\n    constructor(sourceSpan, i18n) {\n        this.sourceSpan = sourceSpan;\n        this.i18n = i18n;\n    }\n}\nclass Text extends NodeWithI18n {\n    constructor(value, sourceSpan, tokens, i18n) {\n        super(sourceSpan, i18n);\n        this.value = value;\n        this.tokens = tokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitText(this, context);\n    }\n}\nclass Expansion extends NodeWithI18n {\n    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n        super(sourceSpan, i18n);\n        this.switchValue = switchValue;\n        this.type = type;\n        this.cases = cases;\n        this.switchValueSourceSpan = switchValueSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansion(this, context);\n    }\n}\nclass ExpansionCase {\n    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n        this.value = value;\n        this.expression = expression;\n        this.sourceSpan = sourceSpan;\n        this.valueSourceSpan = valueSourceSpan;\n        this.expSourceSpan = expSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitExpansionCase(this, context);\n    }\n}\nclass Attribute extends NodeWithI18n {\n    constructor(name, value, sourceSpan, keySpan, valueSpan, valueTokens, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.value = value;\n        this.keySpan = keySpan;\n        this.valueSpan = valueSpan;\n        this.valueTokens = valueTokens;\n    }\n    visit(visitor, context) {\n        return visitor.visitAttribute(this, context);\n    }\n}\nclass Element extends NodeWithI18n {\n    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\n        super(sourceSpan, i18n);\n        this.name = name;\n        this.attrs = attrs;\n        this.children = children;\n        this.startSourceSpan = startSourceSpan;\n        this.endSourceSpan = endSourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitElement(this, context);\n    }\n}\nclass Comment {\n    constructor(value, sourceSpan) {\n        this.value = value;\n        this.sourceSpan = sourceSpan;\n    }\n    visit(visitor, context) {\n        return visitor.visitComment(this, context);\n    }\n}\nfunction visitAll(visitor, nodes, context = null) {\n    const result = [];\n    const visit = visitor.visit ?\n        (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :\n        (ast) => ast.visit(visitor, context);\n    nodes.forEach(ast => {\n        const astResult = visit(ast);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\nclass RecursiveVisitor {\n    constructor() { }\n    visitElement(ast, context) {\n        this.visitChildren(context, visit => {\n            visit(ast.attrs);\n            visit(ast.children);\n        });\n    }\n    visitAttribute(ast, context) { }\n    visitText(ast, context) { }\n    visitComment(ast, context) { }\n    visitExpansion(ast, context) {\n        return this.visitChildren(context, visit => {\n            visit(ast.cases);\n        });\n    }\n    visitExpansionCase(ast, context) { }\n    visitChildren(context, cb) {\n        let results = [];\n        let t = this;\n        function visit(children) {\n            if (children)\n                results.push(visitAll(t, children, context));\n        }\n        cb(visit);\n        return Array.prototype.concat.apply([], results);\n    }\n}\n\nvar TagContentType;\n(function (TagContentType) {\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\nfunction splitNsName(elementName) {\n    if (elementName[0] != ':') {\n        return [null, elementName];\n    }\n    const colonIndex = elementName.indexOf(':', 1);\n    if (colonIndex === -1) {\n        throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n    }\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n// `<ng-container>` tags work the same regardless the namespace\nfunction isNgContainer(tagName) {\n    return splitNsName(tagName)[1] === 'ng-container';\n}\n// `<ng-content>` tags work the same regardless the namespace\nfunction isNgContent(tagName) {\n    return splitNsName(tagName)[1] === 'ng-content';\n}\n// `<ng-template>` tags work the same regardless the namespace\nfunction isNgTemplate(tagName) {\n    return splitNsName(tagName)[1] === 'ng-template';\n}\nfunction getNsPrefix(fullName) {\n    return fullName === null ? null : splitNsName(fullName)[0];\n}\nfunction mergeNsAndName(prefix, localName) {\n    return prefix ? `:${prefix}:${localName}` : localName;\n}\n\nclass ElementSchemaRegistry {\n}\n\nconst BOOLEAN = 'boolean';\nconst NUMBER = 'number';\nconst STRING = 'string';\nconst OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\nconst SCHEMA = [\n    '[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot' +\n        /* added manually to avoid breaking changes */\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\n    '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n    'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy',\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume',\n    ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex',\n    ':svg:graphics^:svg:|',\n    ':svg:animation^:svg:|*begin,*end,*repeat',\n    ':svg:geometry^:svg:|',\n    ':svg:componentTransferFunction^:svg:|',\n    ':svg:gradient^:svg:|',\n    ':svg:textContent^:svg:graphics|',\n    ':svg:textPositioning^:svg:textContent|',\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username',\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username',\n    'audio^media|',\n    'br^[HTMLElement]|clear',\n    'base^[HTMLElement]|href,target',\n    'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\n    'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\n    'canvas^[HTMLElement]|#height,#width',\n    'content^[HTMLElement]|select',\n    'dl^[HTMLElement]|!compact',\n    'data^[HTMLElement]|value',\n    'datalist^[HTMLElement]|',\n    'details^[HTMLElement]|!open',\n    'dialog^[HTMLElement]|!open,returnValue',\n    'dir^[HTMLElement]|!compact',\n    'div^[HTMLElement]|align',\n    'embed^[HTMLElement]|align,height,name,src,type,width',\n    'fieldset^[HTMLElement]|!disabled,name',\n    'font^[HTMLElement]|color,face,size',\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\n    'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\n    'head^[HTMLElement]|',\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\n    'html^[HTMLElement]|version',\n    'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\n    'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\n    'li^[HTMLElement]|type,#value',\n    'label^[HTMLElement]|htmlFor',\n    'legend^[HTMLElement]|align',\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\n    'map^[HTMLElement]|name',\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\n    'menu^[HTMLElement]|!compact',\n    'meta^[HTMLElement]|content,httpEquiv,media,name,scheme',\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\n    'ins,del^[HTMLElement]|cite,dateTime',\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\n    'optgroup^[HTMLElement]|!disabled,label',\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\n    'p^[HTMLElement]|align',\n    'param^[HTMLElement]|name,type,value,valueType',\n    'picture^[HTMLElement]|',\n    'pre^[HTMLElement]|#width',\n    'progress^[HTMLElement]|#max,#value',\n    'q,blockquote,cite^[HTMLElement]|',\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type',\n    'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\n    'slot^[HTMLElement]|name',\n    'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width',\n    'span^[HTMLElement]|',\n    'style^[HTMLElement]|!disabled,media,type',\n    'caption^[HTMLElement]|align',\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\n    'template^[HTMLElement]|',\n    'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\n    'time^[HTMLElement]|dateTime',\n    'title^[HTMLElement]|text',\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\n    'ul^[HTMLElement]|!compact,type',\n    'unknown^[HTMLElement]|',\n    'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width',\n    ':svg:a^:svg:graphics|',\n    ':svg:animate^:svg:animation|',\n    ':svg:animateMotion^:svg:animation|',\n    ':svg:animateTransform^:svg:animation|',\n    ':svg:circle^:svg:geometry|',\n    ':svg:clipPath^:svg:graphics|',\n    ':svg:defs^:svg:graphics|',\n    ':svg:desc^:svg:|',\n    ':svg:discard^:svg:|',\n    ':svg:ellipse^:svg:geometry|',\n    ':svg:feBlend^:svg:|',\n    ':svg:feColorMatrix^:svg:|',\n    ':svg:feComponentTransfer^:svg:|',\n    ':svg:feComposite^:svg:|',\n    ':svg:feConvolveMatrix^:svg:|',\n    ':svg:feDiffuseLighting^:svg:|',\n    ':svg:feDisplacementMap^:svg:|',\n    ':svg:feDistantLight^:svg:|',\n    ':svg:feDropShadow^:svg:|',\n    ':svg:feFlood^:svg:|',\n    ':svg:feFuncA^:svg:componentTransferFunction|',\n    ':svg:feFuncB^:svg:componentTransferFunction|',\n    ':svg:feFuncG^:svg:componentTransferFunction|',\n    ':svg:feFuncR^:svg:componentTransferFunction|',\n    ':svg:feGaussianBlur^:svg:|',\n    ':svg:feImage^:svg:|',\n    ':svg:feMerge^:svg:|',\n    ':svg:feMergeNode^:svg:|',\n    ':svg:feMorphology^:svg:|',\n    ':svg:feOffset^:svg:|',\n    ':svg:fePointLight^:svg:|',\n    ':svg:feSpecularLighting^:svg:|',\n    ':svg:feSpotLight^:svg:|',\n    ':svg:feTile^:svg:|',\n    ':svg:feTurbulence^:svg:|',\n    ':svg:filter^:svg:|',\n    ':svg:foreignObject^:svg:graphics|',\n    ':svg:g^:svg:graphics|',\n    ':svg:image^:svg:graphics|decoding',\n    ':svg:line^:svg:geometry|',\n    ':svg:linearGradient^:svg:gradient|',\n    ':svg:mpath^:svg:|',\n    ':svg:marker^:svg:|',\n    ':svg:mask^:svg:|',\n    ':svg:metadata^:svg:|',\n    ':svg:path^:svg:geometry|',\n    ':svg:pattern^:svg:|',\n    ':svg:polygon^:svg:geometry|',\n    ':svg:polyline^:svg:geometry|',\n    ':svg:radialGradient^:svg:gradient|',\n    ':svg:rect^:svg:geometry|',\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\n    ':svg:script^:svg:|type',\n    ':svg:set^:svg:animation|',\n    ':svg:stop^:svg:|',\n    ':svg:style^:svg:|!disabled,media,title,type',\n    ':svg:switch^:svg:graphics|',\n    ':svg:symbol^:svg:|',\n    ':svg:tspan^:svg:textPositioning|',\n    ':svg:text^:svg:textPositioning|',\n    ':svg:textPath^:svg:textContent|',\n    ':svg:title^:svg:|',\n    ':svg:use^:svg:graphics|',\n    ':svg:view^:svg:|#zoomAndPan',\n    'data^[HTMLElement]|value',\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\n    'summary^[HTMLElement]|',\n    'time^[HTMLElement]|dateTime',\n    ':svg:cursor^:svg:|',\n];\nconst _ATTR_TO_PROP = new Map(Object.entries({\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex',\n}));\n// Invert _ATTR_TO_PROP.\nconst _PROP_TO_ATTR = Array.from(_ATTR_TO_PROP).reduce((inverted, [propertyName, attributeName]) => {\n    inverted.set(propertyName, attributeName);\n    return inverted;\n}, new Map());\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\n    constructor() {\n        super();\n        this._schema = new Map();\n        // We don't allow binding to events for security reasons. Allowing event bindings would almost\n        // certainly introduce bad XSS vulnerabilities. Instead, we store events in a separate schema.\n        this._eventSchema = new Map;\n        SCHEMA.forEach(encodedType => {\n            const type = new Map();\n            const events = new Set();\n            const [strType, strProperties] = encodedType.split('|');\n            const properties = strProperties.split(',');\n            const [typeNames, superName] = strType.split('^');\n            typeNames.split(',').forEach(tag => {\n                this._schema.set(tag.toLowerCase(), type);\n                this._eventSchema.set(tag.toLowerCase(), events);\n            });\n            const superType = superName && this._schema.get(superName.toLowerCase());\n            if (superType) {\n                for (const [prop, value] of superType) {\n                    type.set(prop, value);\n                }\n                for (const superEvent of this._eventSchema.get(superName.toLowerCase())) {\n                    events.add(superEvent);\n                }\n            }\n            properties.forEach((property) => {\n                if (property.length > 0) {\n                    switch (property[0]) {\n                        case '*':\n                            events.add(property.substring(1));\n                            break;\n                        case '!':\n                            type.set(property.substring(1), BOOLEAN);\n                            break;\n                        case '#':\n                            type.set(property.substring(1), NUMBER);\n                            break;\n                        case '%':\n                            type.set(property.substring(1), OBJECT);\n                            break;\n                        default:\n                            type.set(property, STRING);\n                    }\n                }\n            });\n        });\n    }\n    hasProperty(tagName, propName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return false;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Can't tell now as we don't know which properties a custom element will get\n                // once it is instantiated\n                return true;\n            }\n        }\n        const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n        return elementProperties.has(propName);\n    }\n    hasElement(tagName, schemaMetas) {\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\n            return true;\n        }\n        if (tagName.indexOf('-') > -1) {\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\n                return true;\n            }\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\n                // Allow any custom elements\n                return true;\n            }\n        }\n        return this._schema.has(tagName.toLowerCase());\n    }\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n    securityContext(tagName, propName, isAttribute) {\n        if (isAttribute) {\n            // NB: For security purposes, use the mapped property name, not the attribute name.\n            propName = this.getMappedPropName(propName);\n        }\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\n        // property names do not have a security impact.\n        tagName = tagName.toLowerCase();\n        propName = propName.toLowerCase();\n        let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n        if (ctx) {\n            return ctx;\n        }\n        ctx = SECURITY_SCHEMA()['*|' + propName];\n        return ctx ? ctx : SecurityContext.NONE;\n    }\n    getMappedPropName(propName) {\n        return _ATTR_TO_PROP.get(propName) ?? propName;\n    }\n    getDefaultComponentElementName() {\n        return 'ng-component';\n    }\n    validateProperty(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...` +\n                `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n                ` current module.`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    validateAttribute(name) {\n        if (name.toLowerCase().startsWith('on')) {\n            const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n                `please use (${name.slice(2)})=...`;\n            return { error: true, msg: msg };\n        }\n        else {\n            return { error: false };\n        }\n    }\n    allKnownElementNames() {\n        return Array.from(this._schema.keys());\n    }\n    allKnownAttributesOfElement(tagName) {\n        const elementProperties = this._schema.get(tagName.toLowerCase()) || this._schema.get('unknown');\n        // Convert properties to attributes.\n        return Array.from(elementProperties.keys()).map(prop => _PROP_TO_ATTR.get(prop) ?? prop);\n    }\n    allKnownEventsOfElement(tagName) {\n        return Array.from(this._eventSchema.get(tagName.toLowerCase()) ?? []);\n    }\n    normalizeAnimationStyleProperty(propName) {\n        return dashCaseToCamelCase(propName);\n    }\n    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n        let unit = '';\n        const strVal = val.toString().trim();\n        let errorMsg = null;\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n            if (typeof val === 'number') {\n                unit = 'px';\n            }\n            else {\n                const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n                    errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\n                }\n            }\n        }\n        return { error: errorMsg, value: strVal + unit };\n    }\n}\nfunction _isPixelDimensionStyle(prop) {\n    switch (prop) {\n        case 'width':\n        case 'height':\n        case 'minWidth':\n        case 'minHeight':\n        case 'maxWidth':\n        case 'maxHeight':\n        case 'left':\n        case 'top':\n        case 'bottom':\n        case 'right':\n        case 'fontSize':\n        case 'outlineWidth':\n        case 'outlineOffset':\n        case 'paddingTop':\n        case 'paddingLeft':\n        case 'paddingBottom':\n        case 'paddingRight':\n        case 'marginTop':\n        case 'marginLeft':\n        case 'marginBottom':\n        case 'marginRight':\n        case 'borderRadius':\n        case 'borderWidth':\n        case 'borderTopWidth':\n        case 'borderLeftWidth':\n        case 'borderRightWidth':\n        case 'borderBottomWidth':\n        case 'textIndent':\n            return true;\n        default:\n            return false;\n    }\n}\n\nclass HtmlTagDefinition {\n    constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false, canSelfClose = false, } = {}) {\n        this.closedByChildren = {};\n        this.closedByParent = false;\n        if (closedByChildren && closedByChildren.length > 0) {\n            closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n        }\n        this.isVoid = isVoid;\n        this.closedByParent = closedByParent || isVoid;\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n        this.contentType = contentType;\n        this.ignoreFirstLf = ignoreFirstLf;\n        this.preventNamespaceInheritance = preventNamespaceInheritance;\n        this.canSelfClose = canSelfClose ?? isVoid;\n    }\n    isClosedByChild(name) {\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n    getContentType(prefix) {\n        if (typeof this.contentType === 'object') {\n            const overrideType = prefix === undefined ? undefined : this.contentType[prefix];\n            return overrideType ?? this.contentType.default;\n        }\n        return this.contentType;\n    }\n}\nlet DEFAULT_TAG_DEFINITION;\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS;\nfunction getHtmlTagDefinition(tagName) {\n    if (!TAG_DEFINITIONS) {\n        DEFAULT_TAG_DEFINITION = new HtmlTagDefinition({ canSelfClose: true });\n        TAG_DEFINITIONS = {\n            'base': new HtmlTagDefinition({ isVoid: true }),\n            'meta': new HtmlTagDefinition({ isVoid: true }),\n            'area': new HtmlTagDefinition({ isVoid: true }),\n            'embed': new HtmlTagDefinition({ isVoid: true }),\n            'link': new HtmlTagDefinition({ isVoid: true }),\n            'img': new HtmlTagDefinition({ isVoid: true }),\n            'input': new HtmlTagDefinition({ isVoid: true }),\n            'param': new HtmlTagDefinition({ isVoid: true }),\n            'hr': new HtmlTagDefinition({ isVoid: true }),\n            'br': new HtmlTagDefinition({ isVoid: true }),\n            'source': new HtmlTagDefinition({ isVoid: true }),\n            'track': new HtmlTagDefinition({ isVoid: true }),\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\n            'p': new HtmlTagDefinition({\n                closedByChildren: [\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\n                    'p', 'pre', 'section', 'table', 'ul'\n                ],\n                closedByParent: true\n            }),\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\n            'col': new HtmlTagDefinition({ isVoid: true }),\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\n            'foreignObject': new HtmlTagDefinition({\n                // Usually the implicit namespace here would be redundant since it will be inherited from\n                // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n                // works is that the parent node of an end tag is its own start tag which means that\n                // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n                // implicit namespace which is `html`, unless specified otherwise.\n                implicitNamespacePrefix: 'svg',\n                // We want to prevent children of foreignObject from inheriting its namespace, because\n                // the point of the element is to allow nodes from other namespaces to be inserted.\n                preventNamespaceInheritance: true,\n            }),\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\n            'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\n            'title': new HtmlTagDefinition({\n                // The browser supports two separate `title` tags which have to use\n                // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n                contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }\n            }),\n            'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\n        };\n        new DomElementSchemaRegistry().allKnownElementNames().forEach(knownTagName => {\n            if (!TAG_DEFINITIONS.hasOwnProperty(knownTagName) && getNsPrefix(knownTagName) === null) {\n                TAG_DEFINITIONS[knownTagName] = new HtmlTagDefinition({ canSelfClose: false });\n            }\n        });\n    }\n    // We have to make both a case-sensitive and a case-insensitive lookup, because\n    // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n    return TAG_DEFINITIONS[tagName] ?? TAG_DEFINITIONS[tagName.toLowerCase()] ??\n        DEFAULT_TAG_DEFINITION;\n}\n\n// Mapping between all HTML entity names and their unicode representation.\n// Generated from https://html.spec.whatwg.org/multipage/entities.json by stripping\n// the `&` and `;` from the keys and removing the duplicates.\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\nconst NAMED_ENTITIES = {\n    'AElig': '\\u00C6',\n    'AMP': '\\u0026',\n    'amp': '\\u0026',\n    'Aacute': '\\u00C1',\n    'Abreve': '\\u0102',\n    'Acirc': '\\u00C2',\n    'Acy': '\\u0410',\n    'Afr': '\\uD835\\uDD04',\n    'Agrave': '\\u00C0',\n    'Alpha': '\\u0391',\n    'Amacr': '\\u0100',\n    'And': '\\u2A53',\n    'Aogon': '\\u0104',\n    'Aopf': '\\uD835\\uDD38',\n    'ApplyFunction': '\\u2061',\n    'af': '\\u2061',\n    'Aring': '\\u00C5',\n    'angst': '\\u00C5',\n    'Ascr': '\\uD835\\uDC9C',\n    'Assign': '\\u2254',\n    'colone': '\\u2254',\n    'coloneq': '\\u2254',\n    'Atilde': '\\u00C3',\n    'Auml': '\\u00C4',\n    'Backslash': '\\u2216',\n    'setminus': '\\u2216',\n    'setmn': '\\u2216',\n    'smallsetminus': '\\u2216',\n    'ssetmn': '\\u2216',\n    'Barv': '\\u2AE7',\n    'Barwed': '\\u2306',\n    'doublebarwedge': '\\u2306',\n    'Bcy': '\\u0411',\n    'Because': '\\u2235',\n    'becaus': '\\u2235',\n    'because': '\\u2235',\n    'Bernoullis': '\\u212C',\n    'Bscr': '\\u212C',\n    'bernou': '\\u212C',\n    'Beta': '\\u0392',\n    'Bfr': '\\uD835\\uDD05',\n    'Bopf': '\\uD835\\uDD39',\n    'Breve': '\\u02D8',\n    'breve': '\\u02D8',\n    'Bumpeq': '\\u224E',\n    'HumpDownHump': '\\u224E',\n    'bump': '\\u224E',\n    'CHcy': '\\u0427',\n    'COPY': '\\u00A9',\n    'copy': '\\u00A9',\n    'Cacute': '\\u0106',\n    'Cap': '\\u22D2',\n    'CapitalDifferentialD': '\\u2145',\n    'DD': '\\u2145',\n    'Cayleys': '\\u212D',\n    'Cfr': '\\u212D',\n    'Ccaron': '\\u010C',\n    'Ccedil': '\\u00C7',\n    'Ccirc': '\\u0108',\n    'Cconint': '\\u2230',\n    'Cdot': '\\u010A',\n    'Cedilla': '\\u00B8',\n    'cedil': '\\u00B8',\n    'CenterDot': '\\u00B7',\n    'centerdot': '\\u00B7',\n    'middot': '\\u00B7',\n    'Chi': '\\u03A7',\n    'CircleDot': '\\u2299',\n    'odot': '\\u2299',\n    'CircleMinus': '\\u2296',\n    'ominus': '\\u2296',\n    'CirclePlus': '\\u2295',\n    'oplus': '\\u2295',\n    'CircleTimes': '\\u2297',\n    'otimes': '\\u2297',\n    'ClockwiseContourIntegral': '\\u2232',\n    'cwconint': '\\u2232',\n    'CloseCurlyDoubleQuote': '\\u201D',\n    'rdquo': '\\u201D',\n    'rdquor': '\\u201D',\n    'CloseCurlyQuote': '\\u2019',\n    'rsquo': '\\u2019',\n    'rsquor': '\\u2019',\n    'Colon': '\\u2237',\n    'Proportion': '\\u2237',\n    'Colone': '\\u2A74',\n    'Congruent': '\\u2261',\n    'equiv': '\\u2261',\n    'Conint': '\\u222F',\n    'DoubleContourIntegral': '\\u222F',\n    'ContourIntegral': '\\u222E',\n    'conint': '\\u222E',\n    'oint': '\\u222E',\n    'Copf': '\\u2102',\n    'complexes': '\\u2102',\n    'Coproduct': '\\u2210',\n    'coprod': '\\u2210',\n    'CounterClockwiseContourIntegral': '\\u2233',\n    'awconint': '\\u2233',\n    'Cross': '\\u2A2F',\n    'Cscr': '\\uD835\\uDC9E',\n    'Cup': '\\u22D3',\n    'CupCap': '\\u224D',\n    'asympeq': '\\u224D',\n    'DDotrahd': '\\u2911',\n    'DJcy': '\\u0402',\n    'DScy': '\\u0405',\n    'DZcy': '\\u040F',\n    'Dagger': '\\u2021',\n    'ddagger': '\\u2021',\n    'Darr': '\\u21A1',\n    'Dashv': '\\u2AE4',\n    'DoubleLeftTee': '\\u2AE4',\n    'Dcaron': '\\u010E',\n    'Dcy': '\\u0414',\n    'Del': '\\u2207',\n    'nabla': '\\u2207',\n    'Delta': '\\u0394',\n    'Dfr': '\\uD835\\uDD07',\n    'DiacriticalAcute': '\\u00B4',\n    'acute': '\\u00B4',\n    'DiacriticalDot': '\\u02D9',\n    'dot': '\\u02D9',\n    'DiacriticalDoubleAcute': '\\u02DD',\n    'dblac': '\\u02DD',\n    'DiacriticalGrave': '\\u0060',\n    'grave': '\\u0060',\n    'DiacriticalTilde': '\\u02DC',\n    'tilde': '\\u02DC',\n    'Diamond': '\\u22C4',\n    'diam': '\\u22C4',\n    'diamond': '\\u22C4',\n    'DifferentialD': '\\u2146',\n    'dd': '\\u2146',\n    'Dopf': '\\uD835\\uDD3B',\n    'Dot': '\\u00A8',\n    'DoubleDot': '\\u00A8',\n    'die': '\\u00A8',\n    'uml': '\\u00A8',\n    'DotDot': '\\u20DC',\n    'DotEqual': '\\u2250',\n    'doteq': '\\u2250',\n    'esdot': '\\u2250',\n    'DoubleDownArrow': '\\u21D3',\n    'Downarrow': '\\u21D3',\n    'dArr': '\\u21D3',\n    'DoubleLeftArrow': '\\u21D0',\n    'Leftarrow': '\\u21D0',\n    'lArr': '\\u21D0',\n    'DoubleLeftRightArrow': '\\u21D4',\n    'Leftrightarrow': '\\u21D4',\n    'hArr': '\\u21D4',\n    'iff': '\\u21D4',\n    'DoubleLongLeftArrow': '\\u27F8',\n    'Longleftarrow': '\\u27F8',\n    'xlArr': '\\u27F8',\n    'DoubleLongLeftRightArrow': '\\u27FA',\n    'Longleftrightarrow': '\\u27FA',\n    'xhArr': '\\u27FA',\n    'DoubleLongRightArrow': '\\u27F9',\n    'Longrightarrow': '\\u27F9',\n    'xrArr': '\\u27F9',\n    'DoubleRightArrow': '\\u21D2',\n    'Implies': '\\u21D2',\n    'Rightarrow': '\\u21D2',\n    'rArr': '\\u21D2',\n    'DoubleRightTee': '\\u22A8',\n    'vDash': '\\u22A8',\n    'DoubleUpArrow': '\\u21D1',\n    'Uparrow': '\\u21D1',\n    'uArr': '\\u21D1',\n    'DoubleUpDownArrow': '\\u21D5',\n    'Updownarrow': '\\u21D5',\n    'vArr': '\\u21D5',\n    'DoubleVerticalBar': '\\u2225',\n    'par': '\\u2225',\n    'parallel': '\\u2225',\n    'shortparallel': '\\u2225',\n    'spar': '\\u2225',\n    'DownArrow': '\\u2193',\n    'ShortDownArrow': '\\u2193',\n    'darr': '\\u2193',\n    'downarrow': '\\u2193',\n    'DownArrowBar': '\\u2913',\n    'DownArrowUpArrow': '\\u21F5',\n    'duarr': '\\u21F5',\n    'DownBreve': '\\u0311',\n    'DownLeftRightVector': '\\u2950',\n    'DownLeftTeeVector': '\\u295E',\n    'DownLeftVector': '\\u21BD',\n    'leftharpoondown': '\\u21BD',\n    'lhard': '\\u21BD',\n    'DownLeftVectorBar': '\\u2956',\n    'DownRightTeeVector': '\\u295F',\n    'DownRightVector': '\\u21C1',\n    'rhard': '\\u21C1',\n    'rightharpoondown': '\\u21C1',\n    'DownRightVectorBar': '\\u2957',\n    'DownTee': '\\u22A4',\n    'top': '\\u22A4',\n    'DownTeeArrow': '\\u21A7',\n    'mapstodown': '\\u21A7',\n    'Dscr': '\\uD835\\uDC9F',\n    'Dstrok': '\\u0110',\n    'ENG': '\\u014A',\n    'ETH': '\\u00D0',\n    'Eacute': '\\u00C9',\n    'Ecaron': '\\u011A',\n    'Ecirc': '\\u00CA',\n    'Ecy': '\\u042D',\n    'Edot': '\\u0116',\n    'Efr': '\\uD835\\uDD08',\n    'Egrave': '\\u00C8',\n    'Element': '\\u2208',\n    'in': '\\u2208',\n    'isin': '\\u2208',\n    'isinv': '\\u2208',\n    'Emacr': '\\u0112',\n    'EmptySmallSquare': '\\u25FB',\n    'EmptyVerySmallSquare': '\\u25AB',\n    'Eogon': '\\u0118',\n    'Eopf': '\\uD835\\uDD3C',\n    'Epsilon': '\\u0395',\n    'Equal': '\\u2A75',\n    'EqualTilde': '\\u2242',\n    'eqsim': '\\u2242',\n    'esim': '\\u2242',\n    'Equilibrium': '\\u21CC',\n    'rightleftharpoons': '\\u21CC',\n    'rlhar': '\\u21CC',\n    'Escr': '\\u2130',\n    'expectation': '\\u2130',\n    'Esim': '\\u2A73',\n    'Eta': '\\u0397',\n    'Euml': '\\u00CB',\n    'Exists': '\\u2203',\n    'exist': '\\u2203',\n    'ExponentialE': '\\u2147',\n    'ee': '\\u2147',\n    'exponentiale': '\\u2147',\n    'Fcy': '\\u0424',\n    'Ffr': '\\uD835\\uDD09',\n    'FilledSmallSquare': '\\u25FC',\n    'FilledVerySmallSquare': '\\u25AA',\n    'blacksquare': '\\u25AA',\n    'squarf': '\\u25AA',\n    'squf': '\\u25AA',\n    'Fopf': '\\uD835\\uDD3D',\n    'ForAll': '\\u2200',\n    'forall': '\\u2200',\n    'Fouriertrf': '\\u2131',\n    'Fscr': '\\u2131',\n    'GJcy': '\\u0403',\n    'GT': '\\u003E',\n    'gt': '\\u003E',\n    'Gamma': '\\u0393',\n    'Gammad': '\\u03DC',\n    'Gbreve': '\\u011E',\n    'Gcedil': '\\u0122',\n    'Gcirc': '\\u011C',\n    'Gcy': '\\u0413',\n    'Gdot': '\\u0120',\n    'Gfr': '\\uD835\\uDD0A',\n    'Gg': '\\u22D9',\n    'ggg': '\\u22D9',\n    'Gopf': '\\uD835\\uDD3E',\n    'GreaterEqual': '\\u2265',\n    'ge': '\\u2265',\n    'geq': '\\u2265',\n    'GreaterEqualLess': '\\u22DB',\n    'gel': '\\u22DB',\n    'gtreqless': '\\u22DB',\n    'GreaterFullEqual': '\\u2267',\n    'gE': '\\u2267',\n    'geqq': '\\u2267',\n    'GreaterGreater': '\\u2AA2',\n    'GreaterLess': '\\u2277',\n    'gl': '\\u2277',\n    'gtrless': '\\u2277',\n    'GreaterSlantEqual': '\\u2A7E',\n    'geqslant': '\\u2A7E',\n    'ges': '\\u2A7E',\n    'GreaterTilde': '\\u2273',\n    'gsim': '\\u2273',\n    'gtrsim': '\\u2273',\n    'Gscr': '\\uD835\\uDCA2',\n    'Gt': '\\u226B',\n    'NestedGreaterGreater': '\\u226B',\n    'gg': '\\u226B',\n    'HARDcy': '\\u042A',\n    'Hacek': '\\u02C7',\n    'caron': '\\u02C7',\n    'Hat': '\\u005E',\n    'Hcirc': '\\u0124',\n    'Hfr': '\\u210C',\n    'Poincareplane': '\\u210C',\n    'HilbertSpace': '\\u210B',\n    'Hscr': '\\u210B',\n    'hamilt': '\\u210B',\n    'Hopf': '\\u210D',\n    'quaternions': '\\u210D',\n    'HorizontalLine': '\\u2500',\n    'boxh': '\\u2500',\n    'Hstrok': '\\u0126',\n    'HumpEqual': '\\u224F',\n    'bumpe': '\\u224F',\n    'bumpeq': '\\u224F',\n    'IEcy': '\\u0415',\n    'IJlig': '\\u0132',\n    'IOcy': '\\u0401',\n    'Iacute': '\\u00CD',\n    'Icirc': '\\u00CE',\n    'Icy': '\\u0418',\n    'Idot': '\\u0130',\n    'Ifr': '\\u2111',\n    'Im': '\\u2111',\n    'image': '\\u2111',\n    'imagpart': '\\u2111',\n    'Igrave': '\\u00CC',\n    'Imacr': '\\u012A',\n    'ImaginaryI': '\\u2148',\n    'ii': '\\u2148',\n    'Int': '\\u222C',\n    'Integral': '\\u222B',\n    'int': '\\u222B',\n    'Intersection': '\\u22C2',\n    'bigcap': '\\u22C2',\n    'xcap': '\\u22C2',\n    'InvisibleComma': '\\u2063',\n    'ic': '\\u2063',\n    'InvisibleTimes': '\\u2062',\n    'it': '\\u2062',\n    'Iogon': '\\u012E',\n    'Iopf': '\\uD835\\uDD40',\n    'Iota': '\\u0399',\n    'Iscr': '\\u2110',\n    'imagline': '\\u2110',\n    'Itilde': '\\u0128',\n    'Iukcy': '\\u0406',\n    'Iuml': '\\u00CF',\n    'Jcirc': '\\u0134',\n    'Jcy': '\\u0419',\n    'Jfr': '\\uD835\\uDD0D',\n    'Jopf': '\\uD835\\uDD41',\n    'Jscr': '\\uD835\\uDCA5',\n    'Jsercy': '\\u0408',\n    'Jukcy': '\\u0404',\n    'KHcy': '\\u0425',\n    'KJcy': '\\u040C',\n    'Kappa': '\\u039A',\n    'Kcedil': '\\u0136',\n    'Kcy': '\\u041A',\n    'Kfr': '\\uD835\\uDD0E',\n    'Kopf': '\\uD835\\uDD42',\n    'Kscr': '\\uD835\\uDCA6',\n    'LJcy': '\\u0409',\n    'LT': '\\u003C',\n    'lt': '\\u003C',\n    'Lacute': '\\u0139',\n    'Lambda': '\\u039B',\n    'Lang': '\\u27EA',\n    'Laplacetrf': '\\u2112',\n    'Lscr': '\\u2112',\n    'lagran': '\\u2112',\n    'Larr': '\\u219E',\n    'twoheadleftarrow': '\\u219E',\n    'Lcaron': '\\u013D',\n    'Lcedil': '\\u013B',\n    'Lcy': '\\u041B',\n    'LeftAngleBracket': '\\u27E8',\n    'lang': '\\u27E8',\n    'langle': '\\u27E8',\n    'LeftArrow': '\\u2190',\n    'ShortLeftArrow': '\\u2190',\n    'larr': '\\u2190',\n    'leftarrow': '\\u2190',\n    'slarr': '\\u2190',\n    'LeftArrowBar': '\\u21E4',\n    'larrb': '\\u21E4',\n    'LeftArrowRightArrow': '\\u21C6',\n    'leftrightarrows': '\\u21C6',\n    'lrarr': '\\u21C6',\n    'LeftCeiling': '\\u2308',\n    'lceil': '\\u2308',\n    'LeftDoubleBracket': '\\u27E6',\n    'lobrk': '\\u27E6',\n    'LeftDownTeeVector': '\\u2961',\n    'LeftDownVector': '\\u21C3',\n    'dharl': '\\u21C3',\n    'downharpoonleft': '\\u21C3',\n    'LeftDownVectorBar': '\\u2959',\n    'LeftFloor': '\\u230A',\n    'lfloor': '\\u230A',\n    'LeftRightArrow': '\\u2194',\n    'harr': '\\u2194',\n    'leftrightarrow': '\\u2194',\n    'LeftRightVector': '\\u294E',\n    'LeftTee': '\\u22A3',\n    'dashv': '\\u22A3',\n    'LeftTeeArrow': '\\u21A4',\n    'mapstoleft': '\\u21A4',\n    'LeftTeeVector': '\\u295A',\n    'LeftTriangle': '\\u22B2',\n    'vartriangleleft': '\\u22B2',\n    'vltri': '\\u22B2',\n    'LeftTriangleBar': '\\u29CF',\n    'LeftTriangleEqual': '\\u22B4',\n    'ltrie': '\\u22B4',\n    'trianglelefteq': '\\u22B4',\n    'LeftUpDownVector': '\\u2951',\n    'LeftUpTeeVector': '\\u2960',\n    'LeftUpVector': '\\u21BF',\n    'uharl': '\\u21BF',\n    'upharpoonleft': '\\u21BF',\n    'LeftUpVectorBar': '\\u2958',\n    'LeftVector': '\\u21BC',\n    'leftharpoonup': '\\u21BC',\n    'lharu': '\\u21BC',\n    'LeftVectorBar': '\\u2952',\n    'LessEqualGreater': '\\u22DA',\n    'leg': '\\u22DA',\n    'lesseqgtr': '\\u22DA',\n    'LessFullEqual': '\\u2266',\n    'lE': '\\u2266',\n    'leqq': '\\u2266',\n    'LessGreater': '\\u2276',\n    'lessgtr': '\\u2276',\n    'lg': '\\u2276',\n    'LessLess': '\\u2AA1',\n    'LessSlantEqual': '\\u2A7D',\n    'leqslant': '\\u2A7D',\n    'les': '\\u2A7D',\n    'LessTilde': '\\u2272',\n    'lesssim': '\\u2272',\n    'lsim': '\\u2272',\n    'Lfr': '\\uD835\\uDD0F',\n    'Ll': '\\u22D8',\n    'Lleftarrow': '\\u21DA',\n    'lAarr': '\\u21DA',\n    'Lmidot': '\\u013F',\n    'LongLeftArrow': '\\u27F5',\n    'longleftarrow': '\\u27F5',\n    'xlarr': '\\u27F5',\n    'LongLeftRightArrow': '\\u27F7',\n    'longleftrightarrow': '\\u27F7',\n    'xharr': '\\u27F7',\n    'LongRightArrow': '\\u27F6',\n    'longrightarrow': '\\u27F6',\n    'xrarr': '\\u27F6',\n    'Lopf': '\\uD835\\uDD43',\n    'LowerLeftArrow': '\\u2199',\n    'swarr': '\\u2199',\n    'swarrow': '\\u2199',\n    'LowerRightArrow': '\\u2198',\n    'searr': '\\u2198',\n    'searrow': '\\u2198',\n    'Lsh': '\\u21B0',\n    'lsh': '\\u21B0',\n    'Lstrok': '\\u0141',\n    'Lt': '\\u226A',\n    'NestedLessLess': '\\u226A',\n    'll': '\\u226A',\n    'Map': '\\u2905',\n    'Mcy': '\\u041C',\n    'MediumSpace': '\\u205F',\n    'Mellintrf': '\\u2133',\n    'Mscr': '\\u2133',\n    'phmmat': '\\u2133',\n    'Mfr': '\\uD835\\uDD10',\n    'MinusPlus': '\\u2213',\n    'mnplus': '\\u2213',\n    'mp': '\\u2213',\n    'Mopf': '\\uD835\\uDD44',\n    'Mu': '\\u039C',\n    'NJcy': '\\u040A',\n    'Nacute': '\\u0143',\n    'Ncaron': '\\u0147',\n    'Ncedil': '\\u0145',\n    'Ncy': '\\u041D',\n    'NegativeMediumSpace': '\\u200B',\n    'NegativeThickSpace': '\\u200B',\n    'NegativeThinSpace': '\\u200B',\n    'NegativeVeryThinSpace': '\\u200B',\n    'ZeroWidthSpace': '\\u200B',\n    'NewLine': '\\u000A',\n    'Nfr': '\\uD835\\uDD11',\n    'NoBreak': '\\u2060',\n    'NonBreakingSpace': '\\u00A0',\n    'nbsp': '\\u00A0',\n    'Nopf': '\\u2115',\n    'naturals': '\\u2115',\n    'Not': '\\u2AEC',\n    'NotCongruent': '\\u2262',\n    'nequiv': '\\u2262',\n    'NotCupCap': '\\u226D',\n    'NotDoubleVerticalBar': '\\u2226',\n    'npar': '\\u2226',\n    'nparallel': '\\u2226',\n    'nshortparallel': '\\u2226',\n    'nspar': '\\u2226',\n    'NotElement': '\\u2209',\n    'notin': '\\u2209',\n    'notinva': '\\u2209',\n    'NotEqual': '\\u2260',\n    'ne': '\\u2260',\n    'NotEqualTilde': '\\u2242\\u0338',\n    'nesim': '\\u2242\\u0338',\n    'NotExists': '\\u2204',\n    'nexist': '\\u2204',\n    'nexists': '\\u2204',\n    'NotGreater': '\\u226F',\n    'ngt': '\\u226F',\n    'ngtr': '\\u226F',\n    'NotGreaterEqual': '\\u2271',\n    'nge': '\\u2271',\n    'ngeq': '\\u2271',\n    'NotGreaterFullEqual': '\\u2267\\u0338',\n    'ngE': '\\u2267\\u0338',\n    'ngeqq': '\\u2267\\u0338',\n    'NotGreaterGreater': '\\u226B\\u0338',\n    'nGtv': '\\u226B\\u0338',\n    'NotGreaterLess': '\\u2279',\n    'ntgl': '\\u2279',\n    'NotGreaterSlantEqual': '\\u2A7E\\u0338',\n    'ngeqslant': '\\u2A7E\\u0338',\n    'nges': '\\u2A7E\\u0338',\n    'NotGreaterTilde': '\\u2275',\n    'ngsim': '\\u2275',\n    'NotHumpDownHump': '\\u224E\\u0338',\n    'nbump': '\\u224E\\u0338',\n    'NotHumpEqual': '\\u224F\\u0338',\n    'nbumpe': '\\u224F\\u0338',\n    'NotLeftTriangle': '\\u22EA',\n    'nltri': '\\u22EA',\n    'ntriangleleft': '\\u22EA',\n    'NotLeftTriangleBar': '\\u29CF\\u0338',\n    'NotLeftTriangleEqual': '\\u22EC',\n    'nltrie': '\\u22EC',\n    'ntrianglelefteq': '\\u22EC',\n    'NotLess': '\\u226E',\n    'nless': '\\u226E',\n    'nlt': '\\u226E',\n    'NotLessEqual': '\\u2270',\n    'nle': '\\u2270',\n    'nleq': '\\u2270',\n    'NotLessGreater': '\\u2278',\n    'ntlg': '\\u2278',\n    'NotLessLess': '\\u226A\\u0338',\n    'nLtv': '\\u226A\\u0338',\n    'NotLessSlantEqual': '\\u2A7D\\u0338',\n    'nleqslant': '\\u2A7D\\u0338',\n    'nles': '\\u2A7D\\u0338',\n    'NotLessTilde': '\\u2274',\n    'nlsim': '\\u2274',\n    'NotNestedGreaterGreater': '\\u2AA2\\u0338',\n    'NotNestedLessLess': '\\u2AA1\\u0338',\n    'NotPrecedes': '\\u2280',\n    'npr': '\\u2280',\n    'nprec': '\\u2280',\n    'NotPrecedesEqual': '\\u2AAF\\u0338',\n    'npre': '\\u2AAF\\u0338',\n    'npreceq': '\\u2AAF\\u0338',\n    'NotPrecedesSlantEqual': '\\u22E0',\n    'nprcue': '\\u22E0',\n    'NotReverseElement': '\\u220C',\n    'notni': '\\u220C',\n    'notniva': '\\u220C',\n    'NotRightTriangle': '\\u22EB',\n    'nrtri': '\\u22EB',\n    'ntriangleright': '\\u22EB',\n    'NotRightTriangleBar': '\\u29D0\\u0338',\n    'NotRightTriangleEqual': '\\u22ED',\n    'nrtrie': '\\u22ED',\n    'ntrianglerighteq': '\\u22ED',\n    'NotSquareSubset': '\\u228F\\u0338',\n    'NotSquareSubsetEqual': '\\u22E2',\n    'nsqsube': '\\u22E2',\n    'NotSquareSuperset': '\\u2290\\u0338',\n    'NotSquareSupersetEqual': '\\u22E3',\n    'nsqsupe': '\\u22E3',\n    'NotSubset': '\\u2282\\u20D2',\n    'nsubset': '\\u2282\\u20D2',\n    'vnsub': '\\u2282\\u20D2',\n    'NotSubsetEqual': '\\u2288',\n    'nsube': '\\u2288',\n    'nsubseteq': '\\u2288',\n    'NotSucceeds': '\\u2281',\n    'nsc': '\\u2281',\n    'nsucc': '\\u2281',\n    'NotSucceedsEqual': '\\u2AB0\\u0338',\n    'nsce': '\\u2AB0\\u0338',\n    'nsucceq': '\\u2AB0\\u0338',\n    'NotSucceedsSlantEqual': '\\u22E1',\n    'nsccue': '\\u22E1',\n    'NotSucceedsTilde': '\\u227F\\u0338',\n    'NotSuperset': '\\u2283\\u20D2',\n    'nsupset': '\\u2283\\u20D2',\n    'vnsup': '\\u2283\\u20D2',\n    'NotSupersetEqual': '\\u2289',\n    'nsupe': '\\u2289',\n    'nsupseteq': '\\u2289',\n    'NotTilde': '\\u2241',\n    'nsim': '\\u2241',\n    'NotTildeEqual': '\\u2244',\n    'nsime': '\\u2244',\n    'nsimeq': '\\u2244',\n    'NotTildeFullEqual': '\\u2247',\n    'ncong': '\\u2247',\n    'NotTildeTilde': '\\u2249',\n    'nap': '\\u2249',\n    'napprox': '\\u2249',\n    'NotVerticalBar': '\\u2224',\n    'nmid': '\\u2224',\n    'nshortmid': '\\u2224',\n    'nsmid': '\\u2224',\n    'Nscr': '\\uD835\\uDCA9',\n    'Ntilde': '\\u00D1',\n    'Nu': '\\u039D',\n    'OElig': '\\u0152',\n    'Oacute': '\\u00D3',\n    'Ocirc': '\\u00D4',\n    'Ocy': '\\u041E',\n    'Odblac': '\\u0150',\n    'Ofr': '\\uD835\\uDD12',\n    'Ograve': '\\u00D2',\n    'Omacr': '\\u014C',\n    'Omega': '\\u03A9',\n    'ohm': '\\u03A9',\n    'Omicron': '\\u039F',\n    'Oopf': '\\uD835\\uDD46',\n    'OpenCurlyDoubleQuote': '\\u201C',\n    'ldquo': '\\u201C',\n    'OpenCurlyQuote': '\\u2018',\n    'lsquo': '\\u2018',\n    'Or': '\\u2A54',\n    'Oscr': '\\uD835\\uDCAA',\n    'Oslash': '\\u00D8',\n    'Otilde': '\\u00D5',\n    'Otimes': '\\u2A37',\n    'Ouml': '\\u00D6',\n    'OverBar': '\\u203E',\n    'oline': '\\u203E',\n    'OverBrace': '\\u23DE',\n    'OverBracket': '\\u23B4',\n    'tbrk': '\\u23B4',\n    'OverParenthesis': '\\u23DC',\n    'PartialD': '\\u2202',\n    'part': '\\u2202',\n    'Pcy': '\\u041F',\n    'Pfr': '\\uD835\\uDD13',\n    'Phi': '\\u03A6',\n    'Pi': '\\u03A0',\n    'PlusMinus': '\\u00B1',\n    'plusmn': '\\u00B1',\n    'pm': '\\u00B1',\n    'Popf': '\\u2119',\n    'primes': '\\u2119',\n    'Pr': '\\u2ABB',\n    'Precedes': '\\u227A',\n    'pr': '\\u227A',\n    'prec': '\\u227A',\n    'PrecedesEqual': '\\u2AAF',\n    'pre': '\\u2AAF',\n    'preceq': '\\u2AAF',\n    'PrecedesSlantEqual': '\\u227C',\n    'prcue': '\\u227C',\n    'preccurlyeq': '\\u227C',\n    'PrecedesTilde': '\\u227E',\n    'precsim': '\\u227E',\n    'prsim': '\\u227E',\n    'Prime': '\\u2033',\n    'Product': '\\u220F',\n    'prod': '\\u220F',\n    'Proportional': '\\u221D',\n    'prop': '\\u221D',\n    'propto': '\\u221D',\n    'varpropto': '\\u221D',\n    'vprop': '\\u221D',\n    'Pscr': '\\uD835\\uDCAB',\n    'Psi': '\\u03A8',\n    'QUOT': '\\u0022',\n    'quot': '\\u0022',\n    'Qfr': '\\uD835\\uDD14',\n    'Qopf': '\\u211A',\n    'rationals': '\\u211A',\n    'Qscr': '\\uD835\\uDCAC',\n    'RBarr': '\\u2910',\n    'drbkarow': '\\u2910',\n    'REG': '\\u00AE',\n    'circledR': '\\u00AE',\n    'reg': '\\u00AE',\n    'Racute': '\\u0154',\n    'Rang': '\\u27EB',\n    'Rarr': '\\u21A0',\n    'twoheadrightarrow': '\\u21A0',\n    'Rarrtl': '\\u2916',\n    'Rcaron': '\\u0158',\n    'Rcedil': '\\u0156',\n    'Rcy': '\\u0420',\n    'Re': '\\u211C',\n    'Rfr': '\\u211C',\n    'real': '\\u211C',\n    'realpart': '\\u211C',\n    'ReverseElement': '\\u220B',\n    'SuchThat': '\\u220B',\n    'ni': '\\u220B',\n    'niv': '\\u220B',\n    'ReverseEquilibrium': '\\u21CB',\n    'leftrightharpoons': '\\u21CB',\n    'lrhar': '\\u21CB',\n    'ReverseUpEquilibrium': '\\u296F',\n    'duhar': '\\u296F',\n    'Rho': '\\u03A1',\n    'RightAngleBracket': '\\u27E9',\n    'rang': '\\u27E9',\n    'rangle': '\\u27E9',\n    'RightArrow': '\\u2192',\n    'ShortRightArrow': '\\u2192',\n    'rarr': '\\u2192',\n    'rightarrow': '\\u2192',\n    'srarr': '\\u2192',\n    'RightArrowBar': '\\u21E5',\n    'rarrb': '\\u21E5',\n    'RightArrowLeftArrow': '\\u21C4',\n    'rightleftarrows': '\\u21C4',\n    'rlarr': '\\u21C4',\n    'RightCeiling': '\\u2309',\n    'rceil': '\\u2309',\n    'RightDoubleBracket': '\\u27E7',\n    'robrk': '\\u27E7',\n    'RightDownTeeVector': '\\u295D',\n    'RightDownVector': '\\u21C2',\n    'dharr': '\\u21C2',\n    'downharpoonright': '\\u21C2',\n    'RightDownVectorBar': '\\u2955',\n    'RightFloor': '\\u230B',\n    'rfloor': '\\u230B',\n    'RightTee': '\\u22A2',\n    'vdash': '\\u22A2',\n    'RightTeeArrow': '\\u21A6',\n    'map': '\\u21A6',\n    'mapsto': '\\u21A6',\n    'RightTeeVector': '\\u295B',\n    'RightTriangle': '\\u22B3',\n    'vartriangleright': '\\u22B3',\n    'vrtri': '\\u22B3',\n    'RightTriangleBar': '\\u29D0',\n    'RightTriangleEqual': '\\u22B5',\n    'rtrie': '\\u22B5',\n    'trianglerighteq': '\\u22B5',\n    'RightUpDownVector': '\\u294F',\n    'RightUpTeeVector': '\\u295C',\n    'RightUpVector': '\\u21BE',\n    'uharr': '\\u21BE',\n    'upharpoonright': '\\u21BE',\n    'RightUpVectorBar': '\\u2954',\n    'RightVector': '\\u21C0',\n    'rharu': '\\u21C0',\n    'rightharpoonup': '\\u21C0',\n    'RightVectorBar': '\\u2953',\n    'Ropf': '\\u211D',\n    'reals': '\\u211D',\n    'RoundImplies': '\\u2970',\n    'Rrightarrow': '\\u21DB',\n    'rAarr': '\\u21DB',\n    'Rscr': '\\u211B',\n    'realine': '\\u211B',\n    'Rsh': '\\u21B1',\n    'rsh': '\\u21B1',\n    'RuleDelayed': '\\u29F4',\n    'SHCHcy': '\\u0429',\n    'SHcy': '\\u0428',\n    'SOFTcy': '\\u042C',\n    'Sacute': '\\u015A',\n    'Sc': '\\u2ABC',\n    'Scaron': '\\u0160',\n    'Scedil': '\\u015E',\n    'Scirc': '\\u015C',\n    'Scy': '\\u0421',\n    'Sfr': '\\uD835\\uDD16',\n    'ShortUpArrow': '\\u2191',\n    'UpArrow': '\\u2191',\n    'uarr': '\\u2191',\n    'uparrow': '\\u2191',\n    'Sigma': '\\u03A3',\n    'SmallCircle': '\\u2218',\n    'compfn': '\\u2218',\n    'Sopf': '\\uD835\\uDD4A',\n    'Sqrt': '\\u221A',\n    'radic': '\\u221A',\n    'Square': '\\u25A1',\n    'squ': '\\u25A1',\n    'square': '\\u25A1',\n    'SquareIntersection': '\\u2293',\n    'sqcap': '\\u2293',\n    'SquareSubset': '\\u228F',\n    'sqsub': '\\u228F',\n    'sqsubset': '\\u228F',\n    'SquareSubsetEqual': '\\u2291',\n    'sqsube': '\\u2291',\n    'sqsubseteq': '\\u2291',\n    'SquareSuperset': '\\u2290',\n    'sqsup': '\\u2290',\n    'sqsupset': '\\u2290',\n    'SquareSupersetEqual': '\\u2292',\n    'sqsupe': '\\u2292',\n    'sqsupseteq': '\\u2292',\n    'SquareUnion': '\\u2294',\n    'sqcup': '\\u2294',\n    'Sscr': '\\uD835\\uDCAE',\n    'Star': '\\u22C6',\n    'sstarf': '\\u22C6',\n    'Sub': '\\u22D0',\n    'Subset': '\\u22D0',\n    'SubsetEqual': '\\u2286',\n    'sube': '\\u2286',\n    'subseteq': '\\u2286',\n    'Succeeds': '\\u227B',\n    'sc': '\\u227B',\n    'succ': '\\u227B',\n    'SucceedsEqual': '\\u2AB0',\n    'sce': '\\u2AB0',\n    'succeq': '\\u2AB0',\n    'SucceedsSlantEqual': '\\u227D',\n    'sccue': '\\u227D',\n    'succcurlyeq': '\\u227D',\n    'SucceedsTilde': '\\u227F',\n    'scsim': '\\u227F',\n    'succsim': '\\u227F',\n    'Sum': '\\u2211',\n    'sum': '\\u2211',\n    'Sup': '\\u22D1',\n    'Supset': '\\u22D1',\n    'Superset': '\\u2283',\n    'sup': '\\u2283',\n    'supset': '\\u2283',\n    'SupersetEqual': '\\u2287',\n    'supe': '\\u2287',\n    'supseteq': '\\u2287',\n    'THORN': '\\u00DE',\n    'TRADE': '\\u2122',\n    'trade': '\\u2122',\n    'TSHcy': '\\u040B',\n    'TScy': '\\u0426',\n    'Tab': '\\u0009',\n    'Tau': '\\u03A4',\n    'Tcaron': '\\u0164',\n    'Tcedil': '\\u0162',\n    'Tcy': '\\u0422',\n    'Tfr': '\\uD835\\uDD17',\n    'Therefore': '\\u2234',\n    'there4': '\\u2234',\n    'therefore': '\\u2234',\n    'Theta': '\\u0398',\n    'ThickSpace': '\\u205F\\u200A',\n    'ThinSpace': '\\u2009',\n    'thinsp': '\\u2009',\n    'Tilde': '\\u223C',\n    'sim': '\\u223C',\n    'thicksim': '\\u223C',\n    'thksim': '\\u223C',\n    'TildeEqual': '\\u2243',\n    'sime': '\\u2243',\n    'simeq': '\\u2243',\n    'TildeFullEqual': '\\u2245',\n    'cong': '\\u2245',\n    'TildeTilde': '\\u2248',\n    'ap': '\\u2248',\n    'approx': '\\u2248',\n    'asymp': '\\u2248',\n    'thickapprox': '\\u2248',\n    'thkap': '\\u2248',\n    'Topf': '\\uD835\\uDD4B',\n    'TripleDot': '\\u20DB',\n    'tdot': '\\u20DB',\n    'Tscr': '\\uD835\\uDCAF',\n    'Tstrok': '\\u0166',\n    'Uacute': '\\u00DA',\n    'Uarr': '\\u219F',\n    'Uarrocir': '\\u2949',\n    'Ubrcy': '\\u040E',\n    'Ubreve': '\\u016C',\n    'Ucirc': '\\u00DB',\n    'Ucy': '\\u0423',\n    'Udblac': '\\u0170',\n    'Ufr': '\\uD835\\uDD18',\n    'Ugrave': '\\u00D9',\n    'Umacr': '\\u016A',\n    'UnderBar': '\\u005F',\n    'lowbar': '\\u005F',\n    'UnderBrace': '\\u23DF',\n    'UnderBracket': '\\u23B5',\n    'bbrk': '\\u23B5',\n    'UnderParenthesis': '\\u23DD',\n    'Union': '\\u22C3',\n    'bigcup': '\\u22C3',\n    'xcup': '\\u22C3',\n    'UnionPlus': '\\u228E',\n    'uplus': '\\u228E',\n    'Uogon': '\\u0172',\n    'Uopf': '\\uD835\\uDD4C',\n    'UpArrowBar': '\\u2912',\n    'UpArrowDownArrow': '\\u21C5',\n    'udarr': '\\u21C5',\n    'UpDownArrow': '\\u2195',\n    'updownarrow': '\\u2195',\n    'varr': '\\u2195',\n    'UpEquilibrium': '\\u296E',\n    'udhar': '\\u296E',\n    'UpTee': '\\u22A5',\n    'bot': '\\u22A5',\n    'bottom': '\\u22A5',\n    'perp': '\\u22A5',\n    'UpTeeArrow': '\\u21A5',\n    'mapstoup': '\\u21A5',\n    'UpperLeftArrow': '\\u2196',\n    'nwarr': '\\u2196',\n    'nwarrow': '\\u2196',\n    'UpperRightArrow': '\\u2197',\n    'nearr': '\\u2197',\n    'nearrow': '\\u2197',\n    'Upsi': '\\u03D2',\n    'upsih': '\\u03D2',\n    'Upsilon': '\\u03A5',\n    'Uring': '\\u016E',\n    'Uscr': '\\uD835\\uDCB0',\n    'Utilde': '\\u0168',\n    'Uuml': '\\u00DC',\n    'VDash': '\\u22AB',\n    'Vbar': '\\u2AEB',\n    'Vcy': '\\u0412',\n    'Vdash': '\\u22A9',\n    'Vdashl': '\\u2AE6',\n    'Vee': '\\u22C1',\n    'bigvee': '\\u22C1',\n    'xvee': '\\u22C1',\n    'Verbar': '\\u2016',\n    'Vert': '\\u2016',\n    'VerticalBar': '\\u2223',\n    'mid': '\\u2223',\n    'shortmid': '\\u2223',\n    'smid': '\\u2223',\n    'VerticalLine': '\\u007C',\n    'verbar': '\\u007C',\n    'vert': '\\u007C',\n    'VerticalSeparator': '\\u2758',\n    'VerticalTilde': '\\u2240',\n    'wr': '\\u2240',\n    'wreath': '\\u2240',\n    'VeryThinSpace': '\\u200A',\n    'hairsp': '\\u200A',\n    'Vfr': '\\uD835\\uDD19',\n    'Vopf': '\\uD835\\uDD4D',\n    'Vscr': '\\uD835\\uDCB1',\n    'Vvdash': '\\u22AA',\n    'Wcirc': '\\u0174',\n    'Wedge': '\\u22C0',\n    'bigwedge': '\\u22C0',\n    'xwedge': '\\u22C0',\n    'Wfr': '\\uD835\\uDD1A',\n    'Wopf': '\\uD835\\uDD4E',\n    'Wscr': '\\uD835\\uDCB2',\n    'Xfr': '\\uD835\\uDD1B',\n    'Xi': '\\u039E',\n    'Xopf': '\\uD835\\uDD4F',\n    'Xscr': '\\uD835\\uDCB3',\n    'YAcy': '\\u042F',\n    'YIcy': '\\u0407',\n    'YUcy': '\\u042E',\n    'Yacute': '\\u00DD',\n    'Ycirc': '\\u0176',\n    'Ycy': '\\u042B',\n    'Yfr': '\\uD835\\uDD1C',\n    'Yopf': '\\uD835\\uDD50',\n    'Yscr': '\\uD835\\uDCB4',\n    'Yuml': '\\u0178',\n    'ZHcy': '\\u0416',\n    'Zacute': '\\u0179',\n    'Zcaron': '\\u017D',\n    'Zcy': '\\u0417',\n    'Zdot': '\\u017B',\n    'Zeta': '\\u0396',\n    'Zfr': '\\u2128',\n    'zeetrf': '\\u2128',\n    'Zopf': '\\u2124',\n    'integers': '\\u2124',\n    'Zscr': '\\uD835\\uDCB5',\n    'aacute': '\\u00E1',\n    'abreve': '\\u0103',\n    'ac': '\\u223E',\n    'mstpos': '\\u223E',\n    'acE': '\\u223E\\u0333',\n    'acd': '\\u223F',\n    'acirc': '\\u00E2',\n    'acy': '\\u0430',\n    'aelig': '\\u00E6',\n    'afr': '\\uD835\\uDD1E',\n    'agrave': '\\u00E0',\n    'alefsym': '\\u2135',\n    'aleph': '\\u2135',\n    'alpha': '\\u03B1',\n    'amacr': '\\u0101',\n    'amalg': '\\u2A3F',\n    'and': '\\u2227',\n    'wedge': '\\u2227',\n    'andand': '\\u2A55',\n    'andd': '\\u2A5C',\n    'andslope': '\\u2A58',\n    'andv': '\\u2A5A',\n    'ang': '\\u2220',\n    'angle': '\\u2220',\n    'ange': '\\u29A4',\n    'angmsd': '\\u2221',\n    'measuredangle': '\\u2221',\n    'angmsdaa': '\\u29A8',\n    'angmsdab': '\\u29A9',\n    'angmsdac': '\\u29AA',\n    'angmsdad': '\\u29AB',\n    'angmsdae': '\\u29AC',\n    'angmsdaf': '\\u29AD',\n    'angmsdag': '\\u29AE',\n    'angmsdah': '\\u29AF',\n    'angrt': '\\u221F',\n    'angrtvb': '\\u22BE',\n    'angrtvbd': '\\u299D',\n    'angsph': '\\u2222',\n    'angzarr': '\\u237C',\n    'aogon': '\\u0105',\n    'aopf': '\\uD835\\uDD52',\n    'apE': '\\u2A70',\n    'apacir': '\\u2A6F',\n    'ape': '\\u224A',\n    'approxeq': '\\u224A',\n    'apid': '\\u224B',\n    'apos': '\\u0027',\n    'aring': '\\u00E5',\n    'ascr': '\\uD835\\uDCB6',\n    'ast': '\\u002A',\n    'midast': '\\u002A',\n    'atilde': '\\u00E3',\n    'auml': '\\u00E4',\n    'awint': '\\u2A11',\n    'bNot': '\\u2AED',\n    'backcong': '\\u224C',\n    'bcong': '\\u224C',\n    'backepsilon': '\\u03F6',\n    'bepsi': '\\u03F6',\n    'backprime': '\\u2035',\n    'bprime': '\\u2035',\n    'backsim': '\\u223D',\n    'bsim': '\\u223D',\n    'backsimeq': '\\u22CD',\n    'bsime': '\\u22CD',\n    'barvee': '\\u22BD',\n    'barwed': '\\u2305',\n    'barwedge': '\\u2305',\n    'bbrktbrk': '\\u23B6',\n    'bcy': '\\u0431',\n    'bdquo': '\\u201E',\n    'ldquor': '\\u201E',\n    'bemptyv': '\\u29B0',\n    'beta': '\\u03B2',\n    'beth': '\\u2136',\n    'between': '\\u226C',\n    'twixt': '\\u226C',\n    'bfr': '\\uD835\\uDD1F',\n    'bigcirc': '\\u25EF',\n    'xcirc': '\\u25EF',\n    'bigodot': '\\u2A00',\n    'xodot': '\\u2A00',\n    'bigoplus': '\\u2A01',\n    'xoplus': '\\u2A01',\n    'bigotimes': '\\u2A02',\n    'xotime': '\\u2A02',\n    'bigsqcup': '\\u2A06',\n    'xsqcup': '\\u2A06',\n    'bigstar': '\\u2605',\n    'starf': '\\u2605',\n    'bigtriangledown': '\\u25BD',\n    'xdtri': '\\u25BD',\n    'bigtriangleup': '\\u25B3',\n    'xutri': '\\u25B3',\n    'biguplus': '\\u2A04',\n    'xuplus': '\\u2A04',\n    'bkarow': '\\u290D',\n    'rbarr': '\\u290D',\n    'blacklozenge': '\\u29EB',\n    'lozf': '\\u29EB',\n    'blacktriangle': '\\u25B4',\n    'utrif': '\\u25B4',\n    'blacktriangledown': '\\u25BE',\n    'dtrif': '\\u25BE',\n    'blacktriangleleft': '\\u25C2',\n    'ltrif': '\\u25C2',\n    'blacktriangleright': '\\u25B8',\n    'rtrif': '\\u25B8',\n    'blank': '\\u2423',\n    'blk12': '\\u2592',\n    'blk14': '\\u2591',\n    'blk34': '\\u2593',\n    'block': '\\u2588',\n    'bne': '\\u003D\\u20E5',\n    'bnequiv': '\\u2261\\u20E5',\n    'bnot': '\\u2310',\n    'bopf': '\\uD835\\uDD53',\n    'bowtie': '\\u22C8',\n    'boxDL': '\\u2557',\n    'boxDR': '\\u2554',\n    'boxDl': '\\u2556',\n    'boxDr': '\\u2553',\n    'boxH': '\\u2550',\n    'boxHD': '\\u2566',\n    'boxHU': '\\u2569',\n    'boxHd': '\\u2564',\n    'boxHu': '\\u2567',\n    'boxUL': '\\u255D',\n    'boxUR': '\\u255A',\n    'boxUl': '\\u255C',\n    'boxUr': '\\u2559',\n    'boxV': '\\u2551',\n    'boxVH': '\\u256C',\n    'boxVL': '\\u2563',\n    'boxVR': '\\u2560',\n    'boxVh': '\\u256B',\n    'boxVl': '\\u2562',\n    'boxVr': '\\u255F',\n    'boxbox': '\\u29C9',\n    'boxdL': '\\u2555',\n    'boxdR': '\\u2552',\n    'boxdl': '\\u2510',\n    'boxdr': '\\u250C',\n    'boxhD': '\\u2565',\n    'boxhU': '\\u2568',\n    'boxhd': '\\u252C',\n    'boxhu': '\\u2534',\n    'boxminus': '\\u229F',\n    'minusb': '\\u229F',\n    'boxplus': '\\u229E',\n    'plusb': '\\u229E',\n    'boxtimes': '\\u22A0',\n    'timesb': '\\u22A0',\n    'boxuL': '\\u255B',\n    'boxuR': '\\u2558',\n    'boxul': '\\u2518',\n    'boxur': '\\u2514',\n    'boxv': '\\u2502',\n    'boxvH': '\\u256A',\n    'boxvL': '\\u2561',\n    'boxvR': '\\u255E',\n    'boxvh': '\\u253C',\n    'boxvl': '\\u2524',\n    'boxvr': '\\u251C',\n    'brvbar': '\\u00A6',\n    'bscr': '\\uD835\\uDCB7',\n    'bsemi': '\\u204F',\n    'bsol': '\\u005C',\n    'bsolb': '\\u29C5',\n    'bsolhsub': '\\u27C8',\n    'bull': '\\u2022',\n    'bullet': '\\u2022',\n    'bumpE': '\\u2AAE',\n    'cacute': '\\u0107',\n    'cap': '\\u2229',\n    'capand': '\\u2A44',\n    'capbrcup': '\\u2A49',\n    'capcap': '\\u2A4B',\n    'capcup': '\\u2A47',\n    'capdot': '\\u2A40',\n    'caps': '\\u2229\\uFE00',\n    'caret': '\\u2041',\n    'ccaps': '\\u2A4D',\n    'ccaron': '\\u010D',\n    'ccedil': '\\u00E7',\n    'ccirc': '\\u0109',\n    'ccups': '\\u2A4C',\n    'ccupssm': '\\u2A50',\n    'cdot': '\\u010B',\n    'cemptyv': '\\u29B2',\n    'cent': '\\u00A2',\n    'cfr': '\\uD835\\uDD20',\n    'chcy': '\\u0447',\n    'check': '\\u2713',\n    'checkmark': '\\u2713',\n    'chi': '\\u03C7',\n    'cir': '\\u25CB',\n    'cirE': '\\u29C3',\n    'circ': '\\u02C6',\n    'circeq': '\\u2257',\n    'cire': '\\u2257',\n    'circlearrowleft': '\\u21BA',\n    'olarr': '\\u21BA',\n    'circlearrowright': '\\u21BB',\n    'orarr': '\\u21BB',\n    'circledS': '\\u24C8',\n    'oS': '\\u24C8',\n    'circledast': '\\u229B',\n    'oast': '\\u229B',\n    'circledcirc': '\\u229A',\n    'ocir': '\\u229A',\n    'circleddash': '\\u229D',\n    'odash': '\\u229D',\n    'cirfnint': '\\u2A10',\n    'cirmid': '\\u2AEF',\n    'cirscir': '\\u29C2',\n    'clubs': '\\u2663',\n    'clubsuit': '\\u2663',\n    'colon': '\\u003A',\n    'comma': '\\u002C',\n    'commat': '\\u0040',\n    'comp': '\\u2201',\n    'complement': '\\u2201',\n    'congdot': '\\u2A6D',\n    'copf': '\\uD835\\uDD54',\n    'copysr': '\\u2117',\n    'crarr': '\\u21B5',\n    'cross': '\\u2717',\n    'cscr': '\\uD835\\uDCB8',\n    'csub': '\\u2ACF',\n    'csube': '\\u2AD1',\n    'csup': '\\u2AD0',\n    'csupe': '\\u2AD2',\n    'ctdot': '\\u22EF',\n    'cudarrl': '\\u2938',\n    'cudarrr': '\\u2935',\n    'cuepr': '\\u22DE',\n    'curlyeqprec': '\\u22DE',\n    'cuesc': '\\u22DF',\n    'curlyeqsucc': '\\u22DF',\n    'cularr': '\\u21B6',\n    'curvearrowleft': '\\u21B6',\n    'cularrp': '\\u293D',\n    'cup': '\\u222A',\n    'cupbrcap': '\\u2A48',\n    'cupcap': '\\u2A46',\n    'cupcup': '\\u2A4A',\n    'cupdot': '\\u228D',\n    'cupor': '\\u2A45',\n    'cups': '\\u222A\\uFE00',\n    'curarr': '\\u21B7',\n    'curvearrowright': '\\u21B7',\n    'curarrm': '\\u293C',\n    'curlyvee': '\\u22CE',\n    'cuvee': '\\u22CE',\n    'curlywedge': '\\u22CF',\n    'cuwed': '\\u22CF',\n    'curren': '\\u00A4',\n    'cwint': '\\u2231',\n    'cylcty': '\\u232D',\n    'dHar': '\\u2965',\n    'dagger': '\\u2020',\n    'daleth': '\\u2138',\n    'dash': '\\u2010',\n    'hyphen': '\\u2010',\n    'dbkarow': '\\u290F',\n    'rBarr': '\\u290F',\n    'dcaron': '\\u010F',\n    'dcy': '\\u0434',\n    'ddarr': '\\u21CA',\n    'downdownarrows': '\\u21CA',\n    'ddotseq': '\\u2A77',\n    'eDDot': '\\u2A77',\n    'deg': '\\u00B0',\n    'delta': '\\u03B4',\n    'demptyv': '\\u29B1',\n    'dfisht': '\\u297F',\n    'dfr': '\\uD835\\uDD21',\n    'diamondsuit': '\\u2666',\n    'diams': '\\u2666',\n    'digamma': '\\u03DD',\n    'gammad': '\\u03DD',\n    'disin': '\\u22F2',\n    'div': '\\u00F7',\n    'divide': '\\u00F7',\n    'divideontimes': '\\u22C7',\n    'divonx': '\\u22C7',\n    'djcy': '\\u0452',\n    'dlcorn': '\\u231E',\n    'llcorner': '\\u231E',\n    'dlcrop': '\\u230D',\n    'dollar': '\\u0024',\n    'dopf': '\\uD835\\uDD55',\n    'doteqdot': '\\u2251',\n    'eDot': '\\u2251',\n    'dotminus': '\\u2238',\n    'minusd': '\\u2238',\n    'dotplus': '\\u2214',\n    'plusdo': '\\u2214',\n    'dotsquare': '\\u22A1',\n    'sdotb': '\\u22A1',\n    'drcorn': '\\u231F',\n    'lrcorner': '\\u231F',\n    'drcrop': '\\u230C',\n    'dscr': '\\uD835\\uDCB9',\n    'dscy': '\\u0455',\n    'dsol': '\\u29F6',\n    'dstrok': '\\u0111',\n    'dtdot': '\\u22F1',\n    'dtri': '\\u25BF',\n    'triangledown': '\\u25BF',\n    'dwangle': '\\u29A6',\n    'dzcy': '\\u045F',\n    'dzigrarr': '\\u27FF',\n    'eacute': '\\u00E9',\n    'easter': '\\u2A6E',\n    'ecaron': '\\u011B',\n    'ecir': '\\u2256',\n    'eqcirc': '\\u2256',\n    'ecirc': '\\u00EA',\n    'ecolon': '\\u2255',\n    'eqcolon': '\\u2255',\n    'ecy': '\\u044D',\n    'edot': '\\u0117',\n    'efDot': '\\u2252',\n    'fallingdotseq': '\\u2252',\n    'efr': '\\uD835\\uDD22',\n    'eg': '\\u2A9A',\n    'egrave': '\\u00E8',\n    'egs': '\\u2A96',\n    'eqslantgtr': '\\u2A96',\n    'egsdot': '\\u2A98',\n    'el': '\\u2A99',\n    'elinters': '\\u23E7',\n    'ell': '\\u2113',\n    'els': '\\u2A95',\n    'eqslantless': '\\u2A95',\n    'elsdot': '\\u2A97',\n    'emacr': '\\u0113',\n    'empty': '\\u2205',\n    'emptyset': '\\u2205',\n    'emptyv': '\\u2205',\n    'varnothing': '\\u2205',\n    'emsp13': '\\u2004',\n    'emsp14': '\\u2005',\n    'emsp': '\\u2003',\n    'eng': '\\u014B',\n    'ensp': '\\u2002',\n    'eogon': '\\u0119',\n    'eopf': '\\uD835\\uDD56',\n    'epar': '\\u22D5',\n    'eparsl': '\\u29E3',\n    'eplus': '\\u2A71',\n    'epsi': '\\u03B5',\n    'epsilon': '\\u03B5',\n    'epsiv': '\\u03F5',\n    'straightepsilon': '\\u03F5',\n    'varepsilon': '\\u03F5',\n    'equals': '\\u003D',\n    'equest': '\\u225F',\n    'questeq': '\\u225F',\n    'equivDD': '\\u2A78',\n    'eqvparsl': '\\u29E5',\n    'erDot': '\\u2253',\n    'risingdotseq': '\\u2253',\n    'erarr': '\\u2971',\n    'escr': '\\u212F',\n    'eta': '\\u03B7',\n    'eth': '\\u00F0',\n    'euml': '\\u00EB',\n    'euro': '\\u20AC',\n    'excl': '\\u0021',\n    'fcy': '\\u0444',\n    'female': '\\u2640',\n    'ffilig': '\\uFB03',\n    'fflig': '\\uFB00',\n    'ffllig': '\\uFB04',\n    'ffr': '\\uD835\\uDD23',\n    'filig': '\\uFB01',\n    'fjlig': '\\u0066\\u006A',\n    'flat': '\\u266D',\n    'fllig': '\\uFB02',\n    'fltns': '\\u25B1',\n    'fnof': '\\u0192',\n    'fopf': '\\uD835\\uDD57',\n    'fork': '\\u22D4',\n    'pitchfork': '\\u22D4',\n    'forkv': '\\u2AD9',\n    'fpartint': '\\u2A0D',\n    'frac12': '\\u00BD',\n    'half': '\\u00BD',\n    'frac13': '\\u2153',\n    'frac14': '\\u00BC',\n    'frac15': '\\u2155',\n    'frac16': '\\u2159',\n    'frac18': '\\u215B',\n    'frac23': '\\u2154',\n    'frac25': '\\u2156',\n    'frac34': '\\u00BE',\n    'frac35': '\\u2157',\n    'frac38': '\\u215C',\n    'frac45': '\\u2158',\n    'frac56': '\\u215A',\n    'frac58': '\\u215D',\n    'frac78': '\\u215E',\n    'frasl': '\\u2044',\n    'frown': '\\u2322',\n    'sfrown': '\\u2322',\n    'fscr': '\\uD835\\uDCBB',\n    'gEl': '\\u2A8C',\n    'gtreqqless': '\\u2A8C',\n    'gacute': '\\u01F5',\n    'gamma': '\\u03B3',\n    'gap': '\\u2A86',\n    'gtrapprox': '\\u2A86',\n    'gbreve': '\\u011F',\n    'gcirc': '\\u011D',\n    'gcy': '\\u0433',\n    'gdot': '\\u0121',\n    'gescc': '\\u2AA9',\n    'gesdot': '\\u2A80',\n    'gesdoto': '\\u2A82',\n    'gesdotol': '\\u2A84',\n    'gesl': '\\u22DB\\uFE00',\n    'gesles': '\\u2A94',\n    'gfr': '\\uD835\\uDD24',\n    'gimel': '\\u2137',\n    'gjcy': '\\u0453',\n    'glE': '\\u2A92',\n    'gla': '\\u2AA5',\n    'glj': '\\u2AA4',\n    'gnE': '\\u2269',\n    'gneqq': '\\u2269',\n    'gnap': '\\u2A8A',\n    'gnapprox': '\\u2A8A',\n    'gne': '\\u2A88',\n    'gneq': '\\u2A88',\n    'gnsim': '\\u22E7',\n    'gopf': '\\uD835\\uDD58',\n    'gscr': '\\u210A',\n    'gsime': '\\u2A8E',\n    'gsiml': '\\u2A90',\n    'gtcc': '\\u2AA7',\n    'gtcir': '\\u2A7A',\n    'gtdot': '\\u22D7',\n    'gtrdot': '\\u22D7',\n    'gtlPar': '\\u2995',\n    'gtquest': '\\u2A7C',\n    'gtrarr': '\\u2978',\n    'gvertneqq': '\\u2269\\uFE00',\n    'gvnE': '\\u2269\\uFE00',\n    'hardcy': '\\u044A',\n    'harrcir': '\\u2948',\n    'harrw': '\\u21AD',\n    'leftrightsquigarrow': '\\u21AD',\n    'hbar': '\\u210F',\n    'hslash': '\\u210F',\n    'planck': '\\u210F',\n    'plankv': '\\u210F',\n    'hcirc': '\\u0125',\n    'hearts': '\\u2665',\n    'heartsuit': '\\u2665',\n    'hellip': '\\u2026',\n    'mldr': '\\u2026',\n    'hercon': '\\u22B9',\n    'hfr': '\\uD835\\uDD25',\n    'hksearow': '\\u2925',\n    'searhk': '\\u2925',\n    'hkswarow': '\\u2926',\n    'swarhk': '\\u2926',\n    'hoarr': '\\u21FF',\n    'homtht': '\\u223B',\n    'hookleftarrow': '\\u21A9',\n    'larrhk': '\\u21A9',\n    'hookrightarrow': '\\u21AA',\n    'rarrhk': '\\u21AA',\n    'hopf': '\\uD835\\uDD59',\n    'horbar': '\\u2015',\n    'hscr': '\\uD835\\uDCBD',\n    'hstrok': '\\u0127',\n    'hybull': '\\u2043',\n    'iacute': '\\u00ED',\n    'icirc': '\\u00EE',\n    'icy': '\\u0438',\n    'iecy': '\\u0435',\n    'iexcl': '\\u00A1',\n    'ifr': '\\uD835\\uDD26',\n    'igrave': '\\u00EC',\n    'iiiint': '\\u2A0C',\n    'qint': '\\u2A0C',\n    'iiint': '\\u222D',\n    'tint': '\\u222D',\n    'iinfin': '\\u29DC',\n    'iiota': '\\u2129',\n    'ijlig': '\\u0133',\n    'imacr': '\\u012B',\n    'imath': '\\u0131',\n    'inodot': '\\u0131',\n    'imof': '\\u22B7',\n    'imped': '\\u01B5',\n    'incare': '\\u2105',\n    'infin': '\\u221E',\n    'infintie': '\\u29DD',\n    'intcal': '\\u22BA',\n    'intercal': '\\u22BA',\n    'intlarhk': '\\u2A17',\n    'intprod': '\\u2A3C',\n    'iprod': '\\u2A3C',\n    'iocy': '\\u0451',\n    'iogon': '\\u012F',\n    'iopf': '\\uD835\\uDD5A',\n    'iota': '\\u03B9',\n    'iquest': '\\u00BF',\n    'iscr': '\\uD835\\uDCBE',\n    'isinE': '\\u22F9',\n    'isindot': '\\u22F5',\n    'isins': '\\u22F4',\n    'isinsv': '\\u22F3',\n    'itilde': '\\u0129',\n    'iukcy': '\\u0456',\n    'iuml': '\\u00EF',\n    'jcirc': '\\u0135',\n    'jcy': '\\u0439',\n    'jfr': '\\uD835\\uDD27',\n    'jmath': '\\u0237',\n    'jopf': '\\uD835\\uDD5B',\n    'jscr': '\\uD835\\uDCBF',\n    'jsercy': '\\u0458',\n    'jukcy': '\\u0454',\n    'kappa': '\\u03BA',\n    'kappav': '\\u03F0',\n    'varkappa': '\\u03F0',\n    'kcedil': '\\u0137',\n    'kcy': '\\u043A',\n    'kfr': '\\uD835\\uDD28',\n    'kgreen': '\\u0138',\n    'khcy': '\\u0445',\n    'kjcy': '\\u045C',\n    'kopf': '\\uD835\\uDD5C',\n    'kscr': '\\uD835\\uDCC0',\n    'lAtail': '\\u291B',\n    'lBarr': '\\u290E',\n    'lEg': '\\u2A8B',\n    'lesseqqgtr': '\\u2A8B',\n    'lHar': '\\u2962',\n    'lacute': '\\u013A',\n    'laemptyv': '\\u29B4',\n    'lambda': '\\u03BB',\n    'langd': '\\u2991',\n    'lap': '\\u2A85',\n    'lessapprox': '\\u2A85',\n    'laquo': '\\u00AB',\n    'larrbfs': '\\u291F',\n    'larrfs': '\\u291D',\n    'larrlp': '\\u21AB',\n    'looparrowleft': '\\u21AB',\n    'larrpl': '\\u2939',\n    'larrsim': '\\u2973',\n    'larrtl': '\\u21A2',\n    'leftarrowtail': '\\u21A2',\n    'lat': '\\u2AAB',\n    'latail': '\\u2919',\n    'late': '\\u2AAD',\n    'lates': '\\u2AAD\\uFE00',\n    'lbarr': '\\u290C',\n    'lbbrk': '\\u2772',\n    'lbrace': '\\u007B',\n    'lcub': '\\u007B',\n    'lbrack': '\\u005B',\n    'lsqb': '\\u005B',\n    'lbrke': '\\u298B',\n    'lbrksld': '\\u298F',\n    'lbrkslu': '\\u298D',\n    'lcaron': '\\u013E',\n    'lcedil': '\\u013C',\n    'lcy': '\\u043B',\n    'ldca': '\\u2936',\n    'ldrdhar': '\\u2967',\n    'ldrushar': '\\u294B',\n    'ldsh': '\\u21B2',\n    'le': '\\u2264',\n    'leq': '\\u2264',\n    'leftleftarrows': '\\u21C7',\n    'llarr': '\\u21C7',\n    'leftthreetimes': '\\u22CB',\n    'lthree': '\\u22CB',\n    'lescc': '\\u2AA8',\n    'lesdot': '\\u2A7F',\n    'lesdoto': '\\u2A81',\n    'lesdotor': '\\u2A83',\n    'lesg': '\\u22DA\\uFE00',\n    'lesges': '\\u2A93',\n    'lessdot': '\\u22D6',\n    'ltdot': '\\u22D6',\n    'lfisht': '\\u297C',\n    'lfr': '\\uD835\\uDD29',\n    'lgE': '\\u2A91',\n    'lharul': '\\u296A',\n    'lhblk': '\\u2584',\n    'ljcy': '\\u0459',\n    'llhard': '\\u296B',\n    'lltri': '\\u25FA',\n    'lmidot': '\\u0140',\n    'lmoust': '\\u23B0',\n    'lmoustache': '\\u23B0',\n    'lnE': '\\u2268',\n    'lneqq': '\\u2268',\n    'lnap': '\\u2A89',\n    'lnapprox': '\\u2A89',\n    'lne': '\\u2A87',\n    'lneq': '\\u2A87',\n    'lnsim': '\\u22E6',\n    'loang': '\\u27EC',\n    'loarr': '\\u21FD',\n    'longmapsto': '\\u27FC',\n    'xmap': '\\u27FC',\n    'looparrowright': '\\u21AC',\n    'rarrlp': '\\u21AC',\n    'lopar': '\\u2985',\n    'lopf': '\\uD835\\uDD5D',\n    'loplus': '\\u2A2D',\n    'lotimes': '\\u2A34',\n    'lowast': '\\u2217',\n    'loz': '\\u25CA',\n    'lozenge': '\\u25CA',\n    'lpar': '\\u0028',\n    'lparlt': '\\u2993',\n    'lrhard': '\\u296D',\n    'lrm': '\\u200E',\n    'lrtri': '\\u22BF',\n    'lsaquo': '\\u2039',\n    'lscr': '\\uD835\\uDCC1',\n    'lsime': '\\u2A8D',\n    'lsimg': '\\u2A8F',\n    'lsquor': '\\u201A',\n    'sbquo': '\\u201A',\n    'lstrok': '\\u0142',\n    'ltcc': '\\u2AA6',\n    'ltcir': '\\u2A79',\n    'ltimes': '\\u22C9',\n    'ltlarr': '\\u2976',\n    'ltquest': '\\u2A7B',\n    'ltrPar': '\\u2996',\n    'ltri': '\\u25C3',\n    'triangleleft': '\\u25C3',\n    'lurdshar': '\\u294A',\n    'luruhar': '\\u2966',\n    'lvertneqq': '\\u2268\\uFE00',\n    'lvnE': '\\u2268\\uFE00',\n    'mDDot': '\\u223A',\n    'macr': '\\u00AF',\n    'strns': '\\u00AF',\n    'male': '\\u2642',\n    'malt': '\\u2720',\n    'maltese': '\\u2720',\n    'marker': '\\u25AE',\n    'mcomma': '\\u2A29',\n    'mcy': '\\u043C',\n    'mdash': '\\u2014',\n    'mfr': '\\uD835\\uDD2A',\n    'mho': '\\u2127',\n    'micro': '\\u00B5',\n    'midcir': '\\u2AF0',\n    'minus': '\\u2212',\n    'minusdu': '\\u2A2A',\n    'mlcp': '\\u2ADB',\n    'models': '\\u22A7',\n    'mopf': '\\uD835\\uDD5E',\n    'mscr': '\\uD835\\uDCC2',\n    'mu': '\\u03BC',\n    'multimap': '\\u22B8',\n    'mumap': '\\u22B8',\n    'nGg': '\\u22D9\\u0338',\n    'nGt': '\\u226B\\u20D2',\n    'nLeftarrow': '\\u21CD',\n    'nlArr': '\\u21CD',\n    'nLeftrightarrow': '\\u21CE',\n    'nhArr': '\\u21CE',\n    'nLl': '\\u22D8\\u0338',\n    'nLt': '\\u226A\\u20D2',\n    'nRightarrow': '\\u21CF',\n    'nrArr': '\\u21CF',\n    'nVDash': '\\u22AF',\n    'nVdash': '\\u22AE',\n    'nacute': '\\u0144',\n    'nang': '\\u2220\\u20D2',\n    'napE': '\\u2A70\\u0338',\n    'napid': '\\u224B\\u0338',\n    'napos': '\\u0149',\n    'natur': '\\u266E',\n    'natural': '\\u266E',\n    'ncap': '\\u2A43',\n    'ncaron': '\\u0148',\n    'ncedil': '\\u0146',\n    'ncongdot': '\\u2A6D\\u0338',\n    'ncup': '\\u2A42',\n    'ncy': '\\u043D',\n    'ndash': '\\u2013',\n    'neArr': '\\u21D7',\n    'nearhk': '\\u2924',\n    'nedot': '\\u2250\\u0338',\n    'nesear': '\\u2928',\n    'toea': '\\u2928',\n    'nfr': '\\uD835\\uDD2B',\n    'nharr': '\\u21AE',\n    'nleftrightarrow': '\\u21AE',\n    'nhpar': '\\u2AF2',\n    'nis': '\\u22FC',\n    'nisd': '\\u22FA',\n    'njcy': '\\u045A',\n    'nlE': '\\u2266\\u0338',\n    'nleqq': '\\u2266\\u0338',\n    'nlarr': '\\u219A',\n    'nleftarrow': '\\u219A',\n    'nldr': '\\u2025',\n    'nopf': '\\uD835\\uDD5F',\n    'not': '\\u00AC',\n    'notinE': '\\u22F9\\u0338',\n    'notindot': '\\u22F5\\u0338',\n    'notinvb': '\\u22F7',\n    'notinvc': '\\u22F6',\n    'notnivb': '\\u22FE',\n    'notnivc': '\\u22FD',\n    'nparsl': '\\u2AFD\\u20E5',\n    'npart': '\\u2202\\u0338',\n    'npolint': '\\u2A14',\n    'nrarr': '\\u219B',\n    'nrightarrow': '\\u219B',\n    'nrarrc': '\\u2933\\u0338',\n    'nrarrw': '\\u219D\\u0338',\n    'nscr': '\\uD835\\uDCC3',\n    'nsub': '\\u2284',\n    'nsubE': '\\u2AC5\\u0338',\n    'nsubseteqq': '\\u2AC5\\u0338',\n    'nsup': '\\u2285',\n    'nsupE': '\\u2AC6\\u0338',\n    'nsupseteqq': '\\u2AC6\\u0338',\n    'ntilde': '\\u00F1',\n    'nu': '\\u03BD',\n    'num': '\\u0023',\n    'numero': '\\u2116',\n    'numsp': '\\u2007',\n    'nvDash': '\\u22AD',\n    'nvHarr': '\\u2904',\n    'nvap': '\\u224D\\u20D2',\n    'nvdash': '\\u22AC',\n    'nvge': '\\u2265\\u20D2',\n    'nvgt': '\\u003E\\u20D2',\n    'nvinfin': '\\u29DE',\n    'nvlArr': '\\u2902',\n    'nvle': '\\u2264\\u20D2',\n    'nvlt': '\\u003C\\u20D2',\n    'nvltrie': '\\u22B4\\u20D2',\n    'nvrArr': '\\u2903',\n    'nvrtrie': '\\u22B5\\u20D2',\n    'nvsim': '\\u223C\\u20D2',\n    'nwArr': '\\u21D6',\n    'nwarhk': '\\u2923',\n    'nwnear': '\\u2927',\n    'oacute': '\\u00F3',\n    'ocirc': '\\u00F4',\n    'ocy': '\\u043E',\n    'odblac': '\\u0151',\n    'odiv': '\\u2A38',\n    'odsold': '\\u29BC',\n    'oelig': '\\u0153',\n    'ofcir': '\\u29BF',\n    'ofr': '\\uD835\\uDD2C',\n    'ogon': '\\u02DB',\n    'ograve': '\\u00F2',\n    'ogt': '\\u29C1',\n    'ohbar': '\\u29B5',\n    'olcir': '\\u29BE',\n    'olcross': '\\u29BB',\n    'olt': '\\u29C0',\n    'omacr': '\\u014D',\n    'omega': '\\u03C9',\n    'omicron': '\\u03BF',\n    'omid': '\\u29B6',\n    'oopf': '\\uD835\\uDD60',\n    'opar': '\\u29B7',\n    'operp': '\\u29B9',\n    'or': '\\u2228',\n    'vee': '\\u2228',\n    'ord': '\\u2A5D',\n    'order': '\\u2134',\n    'orderof': '\\u2134',\n    'oscr': '\\u2134',\n    'ordf': '\\u00AA',\n    'ordm': '\\u00BA',\n    'origof': '\\u22B6',\n    'oror': '\\u2A56',\n    'orslope': '\\u2A57',\n    'orv': '\\u2A5B',\n    'oslash': '\\u00F8',\n    'osol': '\\u2298',\n    'otilde': '\\u00F5',\n    'otimesas': '\\u2A36',\n    'ouml': '\\u00F6',\n    'ovbar': '\\u233D',\n    'para': '\\u00B6',\n    'parsim': '\\u2AF3',\n    'parsl': '\\u2AFD',\n    'pcy': '\\u043F',\n    'percnt': '\\u0025',\n    'period': '\\u002E',\n    'permil': '\\u2030',\n    'pertenk': '\\u2031',\n    'pfr': '\\uD835\\uDD2D',\n    'phi': '\\u03C6',\n    'phiv': '\\u03D5',\n    'straightphi': '\\u03D5',\n    'varphi': '\\u03D5',\n    'phone': '\\u260E',\n    'pi': '\\u03C0',\n    'piv': '\\u03D6',\n    'varpi': '\\u03D6',\n    'planckh': '\\u210E',\n    'plus': '\\u002B',\n    'plusacir': '\\u2A23',\n    'pluscir': '\\u2A22',\n    'plusdu': '\\u2A25',\n    'pluse': '\\u2A72',\n    'plussim': '\\u2A26',\n    'plustwo': '\\u2A27',\n    'pointint': '\\u2A15',\n    'popf': '\\uD835\\uDD61',\n    'pound': '\\u00A3',\n    'prE': '\\u2AB3',\n    'prap': '\\u2AB7',\n    'precapprox': '\\u2AB7',\n    'precnapprox': '\\u2AB9',\n    'prnap': '\\u2AB9',\n    'precneqq': '\\u2AB5',\n    'prnE': '\\u2AB5',\n    'precnsim': '\\u22E8',\n    'prnsim': '\\u22E8',\n    'prime': '\\u2032',\n    'profalar': '\\u232E',\n    'profline': '\\u2312',\n    'profsurf': '\\u2313',\n    'prurel': '\\u22B0',\n    'pscr': '\\uD835\\uDCC5',\n    'psi': '\\u03C8',\n    'puncsp': '\\u2008',\n    'qfr': '\\uD835\\uDD2E',\n    'qopf': '\\uD835\\uDD62',\n    'qprime': '\\u2057',\n    'qscr': '\\uD835\\uDCC6',\n    'quatint': '\\u2A16',\n    'quest': '\\u003F',\n    'rAtail': '\\u291C',\n    'rHar': '\\u2964',\n    'race': '\\u223D\\u0331',\n    'racute': '\\u0155',\n    'raemptyv': '\\u29B3',\n    'rangd': '\\u2992',\n    'range': '\\u29A5',\n    'raquo': '\\u00BB',\n    'rarrap': '\\u2975',\n    'rarrbfs': '\\u2920',\n    'rarrc': '\\u2933',\n    'rarrfs': '\\u291E',\n    'rarrpl': '\\u2945',\n    'rarrsim': '\\u2974',\n    'rarrtl': '\\u21A3',\n    'rightarrowtail': '\\u21A3',\n    'rarrw': '\\u219D',\n    'rightsquigarrow': '\\u219D',\n    'ratail': '\\u291A',\n    'ratio': '\\u2236',\n    'rbbrk': '\\u2773',\n    'rbrace': '\\u007D',\n    'rcub': '\\u007D',\n    'rbrack': '\\u005D',\n    'rsqb': '\\u005D',\n    'rbrke': '\\u298C',\n    'rbrksld': '\\u298E',\n    'rbrkslu': '\\u2990',\n    'rcaron': '\\u0159',\n    'rcedil': '\\u0157',\n    'rcy': '\\u0440',\n    'rdca': '\\u2937',\n    'rdldhar': '\\u2969',\n    'rdsh': '\\u21B3',\n    'rect': '\\u25AD',\n    'rfisht': '\\u297D',\n    'rfr': '\\uD835\\uDD2F',\n    'rharul': '\\u296C',\n    'rho': '\\u03C1',\n    'rhov': '\\u03F1',\n    'varrho': '\\u03F1',\n    'rightrightarrows': '\\u21C9',\n    'rrarr': '\\u21C9',\n    'rightthreetimes': '\\u22CC',\n    'rthree': '\\u22CC',\n    'ring': '\\u02DA',\n    'rlm': '\\u200F',\n    'rmoust': '\\u23B1',\n    'rmoustache': '\\u23B1',\n    'rnmid': '\\u2AEE',\n    'roang': '\\u27ED',\n    'roarr': '\\u21FE',\n    'ropar': '\\u2986',\n    'ropf': '\\uD835\\uDD63',\n    'roplus': '\\u2A2E',\n    'rotimes': '\\u2A35',\n    'rpar': '\\u0029',\n    'rpargt': '\\u2994',\n    'rppolint': '\\u2A12',\n    'rsaquo': '\\u203A',\n    'rscr': '\\uD835\\uDCC7',\n    'rtimes': '\\u22CA',\n    'rtri': '\\u25B9',\n    'triangleright': '\\u25B9',\n    'rtriltri': '\\u29CE',\n    'ruluhar': '\\u2968',\n    'rx': '\\u211E',\n    'sacute': '\\u015B',\n    'scE': '\\u2AB4',\n    'scap': '\\u2AB8',\n    'succapprox': '\\u2AB8',\n    'scaron': '\\u0161',\n    'scedil': '\\u015F',\n    'scirc': '\\u015D',\n    'scnE': '\\u2AB6',\n    'succneqq': '\\u2AB6',\n    'scnap': '\\u2ABA',\n    'succnapprox': '\\u2ABA',\n    'scnsim': '\\u22E9',\n    'succnsim': '\\u22E9',\n    'scpolint': '\\u2A13',\n    'scy': '\\u0441',\n    'sdot': '\\u22C5',\n    'sdote': '\\u2A66',\n    'seArr': '\\u21D8',\n    'sect': '\\u00A7',\n    'semi': '\\u003B',\n    'seswar': '\\u2929',\n    'tosa': '\\u2929',\n    'sext': '\\u2736',\n    'sfr': '\\uD835\\uDD30',\n    'sharp': '\\u266F',\n    'shchcy': '\\u0449',\n    'shcy': '\\u0448',\n    'shy': '\\u00AD',\n    'sigma': '\\u03C3',\n    'sigmaf': '\\u03C2',\n    'sigmav': '\\u03C2',\n    'varsigma': '\\u03C2',\n    'simdot': '\\u2A6A',\n    'simg': '\\u2A9E',\n    'simgE': '\\u2AA0',\n    'siml': '\\u2A9D',\n    'simlE': '\\u2A9F',\n    'simne': '\\u2246',\n    'simplus': '\\u2A24',\n    'simrarr': '\\u2972',\n    'smashp': '\\u2A33',\n    'smeparsl': '\\u29E4',\n    'smile': '\\u2323',\n    'ssmile': '\\u2323',\n    'smt': '\\u2AAA',\n    'smte': '\\u2AAC',\n    'smtes': '\\u2AAC\\uFE00',\n    'softcy': '\\u044C',\n    'sol': '\\u002F',\n    'solb': '\\u29C4',\n    'solbar': '\\u233F',\n    'sopf': '\\uD835\\uDD64',\n    'spades': '\\u2660',\n    'spadesuit': '\\u2660',\n    'sqcaps': '\\u2293\\uFE00',\n    'sqcups': '\\u2294\\uFE00',\n    'sscr': '\\uD835\\uDCC8',\n    'star': '\\u2606',\n    'sub': '\\u2282',\n    'subset': '\\u2282',\n    'subE': '\\u2AC5',\n    'subseteqq': '\\u2AC5',\n    'subdot': '\\u2ABD',\n    'subedot': '\\u2AC3',\n    'submult': '\\u2AC1',\n    'subnE': '\\u2ACB',\n    'subsetneqq': '\\u2ACB',\n    'subne': '\\u228A',\n    'subsetneq': '\\u228A',\n    'subplus': '\\u2ABF',\n    'subrarr': '\\u2979',\n    'subsim': '\\u2AC7',\n    'subsub': '\\u2AD5',\n    'subsup': '\\u2AD3',\n    'sung': '\\u266A',\n    'sup1': '\\u00B9',\n    'sup2': '\\u00B2',\n    'sup3': '\\u00B3',\n    'supE': '\\u2AC6',\n    'supseteqq': '\\u2AC6',\n    'supdot': '\\u2ABE',\n    'supdsub': '\\u2AD8',\n    'supedot': '\\u2AC4',\n    'suphsol': '\\u27C9',\n    'suphsub': '\\u2AD7',\n    'suplarr': '\\u297B',\n    'supmult': '\\u2AC2',\n    'supnE': '\\u2ACC',\n    'supsetneqq': '\\u2ACC',\n    'supne': '\\u228B',\n    'supsetneq': '\\u228B',\n    'supplus': '\\u2AC0',\n    'supsim': '\\u2AC8',\n    'supsub': '\\u2AD4',\n    'supsup': '\\u2AD6',\n    'swArr': '\\u21D9',\n    'swnwar': '\\u292A',\n    'szlig': '\\u00DF',\n    'target': '\\u2316',\n    'tau': '\\u03C4',\n    'tcaron': '\\u0165',\n    'tcedil': '\\u0163',\n    'tcy': '\\u0442',\n    'telrec': '\\u2315',\n    'tfr': '\\uD835\\uDD31',\n    'theta': '\\u03B8',\n    'thetasym': '\\u03D1',\n    'thetav': '\\u03D1',\n    'vartheta': '\\u03D1',\n    'thorn': '\\u00FE',\n    'times': '\\u00D7',\n    'timesbar': '\\u2A31',\n    'timesd': '\\u2A30',\n    'topbot': '\\u2336',\n    'topcir': '\\u2AF1',\n    'topf': '\\uD835\\uDD65',\n    'topfork': '\\u2ADA',\n    'tprime': '\\u2034',\n    'triangle': '\\u25B5',\n    'utri': '\\u25B5',\n    'triangleq': '\\u225C',\n    'trie': '\\u225C',\n    'tridot': '\\u25EC',\n    'triminus': '\\u2A3A',\n    'triplus': '\\u2A39',\n    'trisb': '\\u29CD',\n    'tritime': '\\u2A3B',\n    'trpezium': '\\u23E2',\n    'tscr': '\\uD835\\uDCC9',\n    'tscy': '\\u0446',\n    'tshcy': '\\u045B',\n    'tstrok': '\\u0167',\n    'uHar': '\\u2963',\n    'uacute': '\\u00FA',\n    'ubrcy': '\\u045E',\n    'ubreve': '\\u016D',\n    'ucirc': '\\u00FB',\n    'ucy': '\\u0443',\n    'udblac': '\\u0171',\n    'ufisht': '\\u297E',\n    'ufr': '\\uD835\\uDD32',\n    'ugrave': '\\u00F9',\n    'uhblk': '\\u2580',\n    'ulcorn': '\\u231C',\n    'ulcorner': '\\u231C',\n    'ulcrop': '\\u230F',\n    'ultri': '\\u25F8',\n    'umacr': '\\u016B',\n    'uogon': '\\u0173',\n    'uopf': '\\uD835\\uDD66',\n    'upsi': '\\u03C5',\n    'upsilon': '\\u03C5',\n    'upuparrows': '\\u21C8',\n    'uuarr': '\\u21C8',\n    'urcorn': '\\u231D',\n    'urcorner': '\\u231D',\n    'urcrop': '\\u230E',\n    'uring': '\\u016F',\n    'urtri': '\\u25F9',\n    'uscr': '\\uD835\\uDCCA',\n    'utdot': '\\u22F0',\n    'utilde': '\\u0169',\n    'uuml': '\\u00FC',\n    'uwangle': '\\u29A7',\n    'vBar': '\\u2AE8',\n    'vBarv': '\\u2AE9',\n    'vangrt': '\\u299C',\n    'varsubsetneq': '\\u228A\\uFE00',\n    'vsubne': '\\u228A\\uFE00',\n    'varsubsetneqq': '\\u2ACB\\uFE00',\n    'vsubnE': '\\u2ACB\\uFE00',\n    'varsupsetneq': '\\u228B\\uFE00',\n    'vsupne': '\\u228B\\uFE00',\n    'varsupsetneqq': '\\u2ACC\\uFE00',\n    'vsupnE': '\\u2ACC\\uFE00',\n    'vcy': '\\u0432',\n    'veebar': '\\u22BB',\n    'veeeq': '\\u225A',\n    'vellip': '\\u22EE',\n    'vfr': '\\uD835\\uDD33',\n    'vopf': '\\uD835\\uDD67',\n    'vscr': '\\uD835\\uDCCB',\n    'vzigzag': '\\u299A',\n    'wcirc': '\\u0175',\n    'wedbar': '\\u2A5F',\n    'wedgeq': '\\u2259',\n    'weierp': '\\u2118',\n    'wp': '\\u2118',\n    'wfr': '\\uD835\\uDD34',\n    'wopf': '\\uD835\\uDD68',\n    'wscr': '\\uD835\\uDCCC',\n    'xfr': '\\uD835\\uDD35',\n    'xi': '\\u03BE',\n    'xnis': '\\u22FB',\n    'xopf': '\\uD835\\uDD69',\n    'xscr': '\\uD835\\uDCCD',\n    'yacute': '\\u00FD',\n    'yacy': '\\u044F',\n    'ycirc': '\\u0177',\n    'ycy': '\\u044B',\n    'yen': '\\u00A5',\n    'yfr': '\\uD835\\uDD36',\n    'yicy': '\\u0457',\n    'yopf': '\\uD835\\uDD6A',\n    'yscr': '\\uD835\\uDCCE',\n    'yucy': '\\u044E',\n    'yuml': '\\u00FF',\n    'zacute': '\\u017A',\n    'zcaron': '\\u017E',\n    'zcy': '\\u0437',\n    'zdot': '\\u017C',\n    'zeta': '\\u03B6',\n    'zfr': '\\uD835\\uDD37',\n    'zhcy': '\\u0436',\n    'zigrarr': '\\u21DD',\n    'zopf': '\\uD835\\uDD6B',\n    'zscr': '\\uD835\\uDCCF',\n    'zwj': '\\u200D',\n    'zwnj': '\\u200C'\n};\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nconst NGSP_UNICODE = '\\uE500';\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n\nclass TokenError extends ParseError {\n    constructor(errorMsg, tokenType, span) {\n        super(span, errorMsg);\n        this.tokenType = tokenType;\n    }\n}\nclass TokenizeResult {\n    constructor(tokens, errors, nonNormalizedIcuExpressions) {\n        this.tokens = tokens;\n        this.errors = errors;\n        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n    }\n}\nfunction tokenize(source, url, getTagDefinition, options = {}) {\n    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n    tokenizer.tokenize();\n    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\nfunction _unexpectedCharacterErrorMsg(charCode) {\n    const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n    return `Unexpected character \"${char}\"`;\n}\nfunction _unknownEntityErrorMsg(entitySrc) {\n    return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n    return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\n}\nvar CharacterReferenceType;\n(function (CharacterReferenceType) {\n    CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n    CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\nclass _ControlFlowError {\n    constructor(error) {\n        this.error = error;\n    }\n}\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    constructor(_file, _getTagDefinition, options) {\n        this._getTagDefinition = _getTagDefinition;\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        this._expansionCaseStack = [];\n        this._inInterpolation = false;\n        this.tokens = [];\n        this.errors = [];\n        this.nonNormalizedIcuExpressions = [];\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        this._leadingTriviaCodePoints =\n            options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n        const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n            new PlainCharacterCursor(_file, range);\n        this._preserveLineEndings = options.preserveLineEndings || false;\n        this._escapedString = options.escapedString || false;\n        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n        try {\n            this._cursor.init();\n        }\n        catch (e) {\n            this.handleError(e);\n        }\n    }\n    _processCarriageReturns(content) {\n        if (this._preserveLineEndings) {\n            return content;\n        }\n        // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n        // In order to keep the original position in the source, we can not\n        // pre-process it.\n        // Instead CRs are processed right before instantiating the tokens.\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n    tokenize() {\n        while (this._cursor.peek() !== $EOF) {\n            const start = this._cursor.clone();\n            try {\n                if (this._attemptCharCode($LT)) {\n                    if (this._attemptCharCode($BANG)) {\n                        if (this._attemptCharCode($LBRACKET)) {\n                            this._consumeCdata(start);\n                        }\n                        else if (this._attemptCharCode($MINUS)) {\n                            this._consumeComment(start);\n                        }\n                        else {\n                            this._consumeDocType(start);\n                        }\n                    }\n                    else if (this._attemptCharCode($SLASH)) {\n                        this._consumeTagClose(start);\n                    }\n                    else {\n                        this._consumeTagOpen(start);\n                    }\n                }\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n                    // In (possibly interpolated) text the end of the text is given by `isTextEnd()`, while\n                    // the premature end of an interpolation is given by the start of a new HTML element.\n                    this._consumeWithInterpolation(5 /* TokenType.TEXT */, 8 /* TokenType.INTERPOLATION */, () => this._isTextEnd(), () => this._isTagStart());\n                }\n            }\n            catch (e) {\n                this.handleError(e);\n            }\n        }\n        this._beginToken(24 /* TokenType.EOF */);\n        this._endToken([]);\n    }\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n    _tokenizeExpansionForm() {\n        if (this.isExpansionFormStart()) {\n            this._consumeExpansionFormStart();\n            return true;\n        }\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n            this._consumeExpansionCaseStart();\n            return true;\n        }\n        if (this._cursor.peek() === $RBRACE) {\n            if (this._isInExpansionCase()) {\n                this._consumeExpansionCaseEnd();\n                return true;\n            }\n            if (this._isInExpansionForm()) {\n                this._consumeExpansionFormEnd();\n                return true;\n            }\n        }\n        return false;\n    }\n    _beginToken(type, start = this._cursor.clone()) {\n        this._currentTokenStart = start;\n        this._currentTokenType = type;\n    }\n    _endToken(parts, end) {\n        if (this._currentTokenStart === null) {\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n        }\n        if (this._currentTokenType === null) {\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n        }\n        const token = {\n            type: this._currentTokenType,\n            parts,\n            sourceSpan: (end ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints),\n        };\n        this.tokens.push(token);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return token;\n    }\n    _createError(msg, span) {\n        if (this._isInExpansionForm()) {\n            msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n        }\n        const error = new TokenError(msg, this._currentTokenType, span);\n        this._currentTokenStart = null;\n        this._currentTokenType = null;\n        return new _ControlFlowError(error);\n    }\n    handleError(e) {\n        if (e instanceof CursorError) {\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n        }\n        if (e instanceof _ControlFlowError) {\n            this.errors.push(e.error);\n        }\n        else {\n            throw e;\n        }\n    }\n    _attemptCharCode(charCode) {\n        if (this._cursor.peek() === charCode) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _attemptCharCodeCaseInsensitive(charCode) {\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n            this._cursor.advance();\n            return true;\n        }\n        return false;\n    }\n    _requireCharCode(charCode) {\n        const location = this._cursor.clone();\n        if (!this._attemptCharCode(charCode)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptStr(chars) {\n        const len = chars.length;\n        if (this._cursor.charsLeft() < len) {\n            return false;\n        }\n        const initialPosition = this._cursor.clone();\n        for (let i = 0; i < len; i++) {\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\n                // If attempting to parse the string fails, we want to reset the parser\n                // to where it was before the attempt\n                this._cursor = initialPosition;\n                return false;\n            }\n        }\n        return true;\n    }\n    _attemptStrCaseInsensitive(chars) {\n        for (let i = 0; i < chars.length; i++) {\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _requireStr(chars) {\n        const location = this._cursor.clone();\n        if (!this._attemptStr(chars)) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n        }\n    }\n    _attemptCharCodeUntilFn(predicate) {\n        while (!predicate(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n    }\n    _requireCharCodeUntilFn(predicate, len) {\n        const start = this._cursor.clone();\n        this._attemptCharCodeUntilFn(predicate);\n        if (this._cursor.diff(start) < len) {\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n    }\n    _attemptUntilChar(char) {\n        while (this._cursor.peek() !== char) {\n            this._cursor.advance();\n        }\n    }\n    _readChar() {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        const char = String.fromCodePoint(this._cursor.peek());\n        this._cursor.advance();\n        return char;\n    }\n    _consumeEntity(textTokenType) {\n        this._beginToken(9 /* TokenType.ENCODED_ENTITY */);\n        const start = this._cursor.clone();\n        this._cursor.advance();\n        if (this._attemptCharCode($HASH)) {\n            const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n            const codeStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // Advance cursor to include the peeked character in the string provided to the error\n                // message.\n                this._cursor.advance();\n                const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n                throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n            const strNum = this._cursor.getChars(codeStart);\n            this._cursor.advance();\n            try {\n                const charCode = parseInt(strNum, isHex ? 16 : 10);\n                this._endToken([String.fromCharCode(charCode), this._cursor.getChars(start)]);\n            }\n            catch {\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n            }\n        }\n        else {\n            const nameStart = this._cursor.clone();\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\n            if (this._cursor.peek() != $SEMICOLON) {\n                // No semicolon was found so abort the encoded entity token that was in progress, and treat\n                // this as a text token\n                this._beginToken(textTokenType, start);\n                this._cursor = nameStart;\n                this._endToken(['&']);\n            }\n            else {\n                const name = this._cursor.getChars(nameStart);\n                this._cursor.advance();\n                const char = NAMED_ENTITIES[name];\n                if (!char) {\n                    throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n                }\n                this._endToken([char, `&${name};`]);\n            }\n        }\n    }\n    _consumeRawText(consumeEntities, endMarkerPredicate) {\n        this._beginToken(consumeEntities ? 6 /* TokenType.ESCAPABLE_RAW_TEXT */ : 7 /* TokenType.RAW_TEXT */);\n        const parts = [];\n        while (true) {\n            const tagCloseStart = this._cursor.clone();\n            const foundEndMarker = endMarkerPredicate();\n            this._cursor = tagCloseStart;\n            if (foundEndMarker) {\n                break;\n            }\n            if (consumeEntities && this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(6 /* TokenType.ESCAPABLE_RAW_TEXT */);\n                this._beginToken(6 /* TokenType.ESCAPABLE_RAW_TEXT */);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    _consumeComment(start) {\n        this._beginToken(10 /* TokenType.COMMENT_START */, start);\n        this._requireCharCode($MINUS);\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr('-->'));\n        this._beginToken(11 /* TokenType.COMMENT_END */);\n        this._requireStr('-->');\n        this._endToken([]);\n    }\n    _consumeCdata(start) {\n        this._beginToken(12 /* TokenType.CDATA_START */, start);\n        this._requireStr('CDATA[');\n        this._endToken([]);\n        this._consumeRawText(false, () => this._attemptStr(']]>'));\n        this._beginToken(13 /* TokenType.CDATA_END */);\n        this._requireStr(']]>');\n        this._endToken([]);\n    }\n    _consumeDocType(start) {\n        this._beginToken(18 /* TokenType.DOC_TYPE */, start);\n        const contentStart = this._cursor.clone();\n        this._attemptUntilChar($GT);\n        const content = this._cursor.getChars(contentStart);\n        this._cursor.advance();\n        this._endToken([content]);\n    }\n    _consumePrefixAndName() {\n        const nameOrPrefixStart = this._cursor.clone();\n        let prefix = '';\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n            this._cursor.advance();\n        }\n        let nameStart;\n        if (this._cursor.peek() === $COLON) {\n            prefix = this._cursor.getChars(nameOrPrefixStart);\n            this._cursor.advance();\n            nameStart = this._cursor.clone();\n        }\n        else {\n            nameStart = nameOrPrefixStart;\n        }\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n        const name = this._cursor.getChars(nameStart);\n        return [prefix, name];\n    }\n    _consumeTagOpen(start) {\n        let tagName;\n        let prefix;\n        let openTagToken;\n        try {\n            if (!isAsciiLetter(this._cursor.peek())) {\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n            }\n            openTagToken = this._consumeTagOpenStart(start);\n            prefix = openTagToken.parts[0];\n            tagName = openTagToken.parts[1];\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&\n                this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {\n                this._consumeAttributeName();\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n                if (this._attemptCharCode($EQ)) {\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\n                    this._consumeAttributeValue();\n                }\n                this._attemptCharCodeUntilFn(isNotWhitespace);\n            }\n            this._consumeTagOpenEnd();\n        }\n        catch (e) {\n            if (e instanceof _ControlFlowError) {\n                if (openTagToken) {\n                    // We errored before we could close the opening tag, so it is incomplete.\n                    openTagToken.type = 4 /* TokenType.INCOMPLETE_TAG_OPEN */;\n                }\n                else {\n                    // When the start tag is invalid, assume we want a \"<\" as text.\n                    // Back to back text tokens are merged at the end.\n                    this._beginToken(5 /* TokenType.TEXT */, start);\n                    this._endToken(['<']);\n                }\n                return;\n            }\n            throw e;\n        }\n        const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n        if (contentTokenType === TagContentType.RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\n        }\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\n        }\n    }\n    _consumeRawTextWithTagClose(prefix, tagName, consumeEntities) {\n        this._consumeRawText(consumeEntities, () => {\n            if (!this._attemptCharCode($LT))\n                return false;\n            if (!this._attemptCharCode($SLASH))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            if (!this._attemptStrCaseInsensitive(tagName))\n                return false;\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n            return this._attemptCharCode($GT);\n        });\n        this._beginToken(3 /* TokenType.TAG_CLOSE */);\n        this._requireCharCodeUntilFn(code => code === $GT, 3);\n        this._cursor.advance(); // Consume the `>`\n        this._endToken([prefix, tagName]);\n    }\n    _consumeTagOpenStart(start) {\n        this._beginToken(0 /* TokenType.TAG_OPEN_START */, start);\n        const parts = this._consumePrefixAndName();\n        return this._endToken(parts);\n    }\n    _consumeAttributeName() {\n        const attrNameStart = this._cursor.peek();\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n        }\n        this._beginToken(14 /* TokenType.ATTR_NAME */);\n        const prefixAndName = this._consumePrefixAndName();\n        this._endToken(prefixAndName);\n    }\n    _consumeAttributeValue() {\n        let value;\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n            const quoteChar = this._cursor.peek();\n            this._consumeQuote(quoteChar);\n            // In an attribute then end of the attribute value and the premature end to an interpolation\n            // are both triggered by the `quoteChar`.\n            const endPredicate = () => this._cursor.peek() === quoteChar;\n            this._consumeWithInterpolation(16 /* TokenType.ATTR_VALUE_TEXT */, 17 /* TokenType.ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n            this._consumeQuote(quoteChar);\n        }\n        else {\n            const endPredicate = () => isNameEnd(this._cursor.peek());\n            this._consumeWithInterpolation(16 /* TokenType.ATTR_VALUE_TEXT */, 17 /* TokenType.ATTR_VALUE_INTERPOLATION */, endPredicate, endPredicate);\n        }\n    }\n    _consumeQuote(quoteChar) {\n        this._beginToken(15 /* TokenType.ATTR_QUOTE */);\n        this._requireCharCode(quoteChar);\n        this._endToken([String.fromCodePoint(quoteChar)]);\n    }\n    _consumeTagOpenEnd() {\n        const tokenType = this._attemptCharCode($SLASH) ? 2 /* TokenType.TAG_OPEN_END_VOID */ : 1 /* TokenType.TAG_OPEN_END */;\n        this._beginToken(tokenType);\n        this._requireCharCode($GT);\n        this._endToken([]);\n    }\n    _consumeTagClose(start) {\n        this._beginToken(3 /* TokenType.TAG_CLOSE */, start);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        const prefixAndName = this._consumePrefixAndName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._requireCharCode($GT);\n        this._endToken(prefixAndName);\n    }\n    _consumeExpansionFormStart() {\n        this._beginToken(19 /* TokenType.EXPANSION_FORM_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.push(19 /* TokenType.EXPANSION_FORM_START */);\n        this._beginToken(7 /* TokenType.RAW_TEXT */);\n        const condition = this._readUntil($COMMA);\n        const normalizedCondition = this._processCarriageReturns(condition);\n        if (this._i18nNormalizeLineEndingsInICUs) {\n            // We explicitly want to normalize line endings for this text.\n            this._endToken([normalizedCondition]);\n        }\n        else {\n            // We are not normalizing line endings.\n            const conditionToken = this._endToken([condition]);\n            if (normalizedCondition !== condition) {\n                this.nonNormalizedIcuExpressions.push(conditionToken);\n            }\n        }\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(7 /* TokenType.RAW_TEXT */);\n        const type = this._readUntil($COMMA);\n        this._endToken([type]);\n        this._requireCharCode($COMMA);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n    _consumeExpansionCaseStart() {\n        this._beginToken(20 /* TokenType.EXPANSION_CASE_VALUE */);\n        const value = this._readUntil($LBRACE).trim();\n        this._endToken([value]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._beginToken(21 /* TokenType.EXPANSION_CASE_EXP_START */);\n        this._requireCharCode($LBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.push(21 /* TokenType.EXPANSION_CASE_EXP_START */);\n    }\n    _consumeExpansionCaseEnd() {\n        this._beginToken(22 /* TokenType.EXPANSION_CASE_EXP_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        this._expansionCaseStack.pop();\n    }\n    _consumeExpansionFormEnd() {\n        this._beginToken(23 /* TokenType.EXPANSION_FORM_END */);\n        this._requireCharCode($RBRACE);\n        this._endToken([]);\n        this._expansionCaseStack.pop();\n    }\n    /**\n     * Consume a string that may contain interpolation expressions.\n     *\n     * The first token consumed will be of `tokenType` and then there will be alternating\n     * `interpolationTokenType` and `tokenType` tokens until the `endPredicate()` returns true.\n     *\n     * If an interpolation token ends prematurely it will have no end marker in its `parts` array.\n     *\n     * @param textTokenType the kind of tokens to interleave around interpolation tokens.\n     * @param interpolationTokenType the kind of tokens that contain interpolation.\n     * @param endPredicate a function that should return true when we should stop consuming.\n     * @param endInterpolation a function that should return true if there is a premature end to an\n     *     interpolation expression - i.e. before we get to the normal interpolation closing marker.\n     */\n    _consumeWithInterpolation(textTokenType, interpolationTokenType, endPredicate, endInterpolation) {\n        this._beginToken(textTokenType);\n        const parts = [];\n        while (!endPredicate()) {\n            const current = this._cursor.clone();\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n                this._endToken([this._processCarriageReturns(parts.join(''))], current);\n                parts.length = 0;\n                this._consumeInterpolation(interpolationTokenType, current, endInterpolation);\n                this._beginToken(textTokenType);\n            }\n            else if (this._cursor.peek() === $AMPERSAND) {\n                this._endToken([this._processCarriageReturns(parts.join(''))]);\n                parts.length = 0;\n                this._consumeEntity(textTokenType);\n                this._beginToken(textTokenType);\n            }\n            else {\n                parts.push(this._readChar());\n            }\n        }\n        // It is possible that an interpolation was started but not ended inside this text token.\n        // Make sure that we reset the state of the lexer correctly.\n        this._inInterpolation = false;\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n    /**\n     * Consume a block of text that has been interpreted as an Angular interpolation.\n     *\n     * @param interpolationTokenType the type of the interpolation token to generate.\n     * @param interpolationStart a cursor that points to the start of this interpolation.\n     * @param prematureEndPredicate a function that should return true if the next characters indicate\n     *     an end to the interpolation before its normal closing marker.\n     */\n    _consumeInterpolation(interpolationTokenType, interpolationStart, prematureEndPredicate) {\n        const parts = [];\n        this._beginToken(interpolationTokenType, interpolationStart);\n        parts.push(this._interpolationConfig.start);\n        // Find the end of the interpolation, ignoring content inside quotes.\n        const expressionStart = this._cursor.clone();\n        let inQuote = null;\n        let inComment = false;\n        while (this._cursor.peek() !== $EOF &&\n            (prematureEndPredicate === null || !prematureEndPredicate())) {\n            const current = this._cursor.clone();\n            if (this._isTagStart()) {\n                // We are starting what looks like an HTML element in the middle of this interpolation.\n                // Reset the cursor to before the `<` character and end the interpolation token.\n                // (This is actually wrong but here for backward compatibility).\n                this._cursor = current;\n                parts.push(this._getProcessedChars(expressionStart, current));\n                this._endToken(parts);\n                return;\n            }\n            if (inQuote === null) {\n                if (this._attemptStr(this._interpolationConfig.end)) {\n                    // We are not in a string, and we hit the end interpolation marker\n                    parts.push(this._getProcessedChars(expressionStart, current));\n                    parts.push(this._interpolationConfig.end);\n                    this._endToken(parts);\n                    return;\n                }\n                else if (this._attemptStr('//')) {\n                    // Once we are in a comment we ignore any quotes\n                    inComment = true;\n                }\n            }\n            const char = this._cursor.peek();\n            this._cursor.advance();\n            if (char === $BACKSLASH) {\n                // Skip the next character because it was escaped.\n                this._cursor.advance();\n            }\n            else if (char === inQuote) {\n                // Exiting the current quoted string\n                inQuote = null;\n            }\n            else if (!inComment && inQuote === null && isQuote(char)) {\n                // Entering a new quoted string\n                inQuote = char;\n            }\n        }\n        // We hit EOF without finding a closing interpolation marker\n        parts.push(this._getProcessedChars(expressionStart, this._cursor));\n        this._endToken(parts);\n    }\n    _getProcessedChars(start, end) {\n        return this._processCarriageReturns(end.getChars(start));\n    }\n    _isTextEnd() {\n        if (this._isTagStart() || this._cursor.peek() === $EOF) {\n            return true;\n        }\n        if (this._tokenizeIcu && !this._inInterpolation) {\n            if (this.isExpansionFormStart()) {\n                // start of an expansion form\n                return true;\n            }\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n                // end of and expansion case\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the current cursor is pointing to the start of a tag\n     * (opening/closing/comments/cdata/etc).\n     */\n    _isTagStart() {\n        if (this._cursor.peek() === $LT) {\n            // We assume that `<` followed by whitespace is not the start of an HTML element.\n            const tmp = this._cursor.clone();\n            tmp.advance();\n            // If the next character is alphabetic, ! nor / then it is a tag start\n            const code = tmp.peek();\n            if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\n                code === $SLASH || code === $BANG) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _readUntil(char) {\n        const start = this._cursor.clone();\n        this._attemptUntilChar(char);\n        return this._cursor.getChars(start);\n    }\n    _isInExpansionCase() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                21 /* TokenType.EXPANSION_CASE_EXP_START */;\n    }\n    _isInExpansionForm() {\n        return this._expansionCaseStack.length > 0 &&\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n                19 /* TokenType.EXPANSION_FORM_START */;\n    }\n    isExpansionFormStart() {\n        if (this._cursor.peek() !== $LBRACE) {\n            return false;\n        }\n        if (this._interpolationConfig) {\n            const start = this._cursor.clone();\n            const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n            this._cursor = start;\n            return !isInterpolation;\n        }\n        return true;\n    }\n}\nfunction isNotWhitespace(code) {\n    return !isWhitespace(code) || code === $EOF;\n}\nfunction isNameEnd(code) {\n    return isWhitespace(code) || code === $GT || code === $LT ||\n        code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||\n        code === $EOF;\n}\nfunction isPrefixEnd(code) {\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\n        (code < $0 || code > $9);\n}\nfunction isDigitEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiHexDigit(code);\n}\nfunction isNamedEntityEnd(code) {\n    return code === $SEMICOLON || code === $EOF || !isAsciiLetter(code);\n}\nfunction isExpansionCaseStart(peek) {\n    return peek !== $RBRACE;\n}\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) === toUpperCaseCharCode(code2);\n}\nfunction toUpperCaseCharCode(code) {\n    return code >= $a && code <= $z ? code - $a + $A : code;\n}\nfunction mergeTextTokens(srcTokens) {\n    const dstTokens = [];\n    let lastDstToken = undefined;\n    for (let i = 0; i < srcTokens.length; i++) {\n        const token = srcTokens[i];\n        if ((lastDstToken && lastDstToken.type === 5 /* TokenType.TEXT */ && token.type === 5 /* TokenType.TEXT */) ||\n            (lastDstToken && lastDstToken.type === 16 /* TokenType.ATTR_VALUE_TEXT */ &&\n                token.type === 16 /* TokenType.ATTR_VALUE_TEXT */)) {\n            lastDstToken.parts[0] += token.parts[0];\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\n        }\n        else {\n            lastDstToken = token;\n            dstTokens.push(lastDstToken);\n        }\n    }\n    return dstTokens;\n}\nclass PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof PlainCharacterCursor) {\n            this.file = fileOrCursor.file;\n            this.input = fileOrCursor.input;\n            this.end = fileOrCursor.end;\n            const state = fileOrCursor.state;\n            // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n            // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n            // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n            // called in tight loops, this difference matters.\n            this.state = {\n                peek: state.peek,\n                offset: state.offset,\n                line: state.line,\n                column: state.column,\n            };\n        }\n        else {\n            if (!range) {\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\n            }\n            this.file = fileOrCursor;\n            this.input = fileOrCursor.content;\n            this.end = range.endPos;\n            this.state = {\n                peek: -1,\n                offset: range.startPos,\n                line: range.startLine,\n                column: range.startCol,\n            };\n        }\n    }\n    clone() {\n        return new PlainCharacterCursor(this);\n    }\n    peek() {\n        return this.state.peek;\n    }\n    charsLeft() {\n        return this.end - this.state.offset;\n    }\n    diff(other) {\n        return this.state.offset - other.state.offset;\n    }\n    advance() {\n        this.advanceState(this.state);\n    }\n    init() {\n        this.updatePeek(this.state);\n    }\n    getSpan(start, leadingTriviaCodePoints) {\n        start = start || this;\n        let fullStart = start;\n        if (leadingTriviaCodePoints) {\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n                if (fullStart === start) {\n                    start = start.clone();\n                }\n                start.advance();\n            }\n        }\n        const startLocation = this.locationFromCursor(start);\n        const endLocation = this.locationFromCursor(this);\n        const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n        return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n    }\n    getChars(start) {\n        return this.input.substring(start.state.offset, this.state.offset);\n    }\n    charAt(pos) {\n        return this.input.charCodeAt(pos);\n    }\n    advanceState(state) {\n        if (state.offset >= this.end) {\n            this.state = state;\n            throw new CursorError('Unexpected character \"EOF\"', this);\n        }\n        const currentChar = this.charAt(state.offset);\n        if (currentChar === $LF) {\n            state.line++;\n            state.column = 0;\n        }\n        else if (!isNewLine(currentChar)) {\n            state.column++;\n        }\n        state.offset++;\n        this.updatePeek(state);\n    }\n    updatePeek(state) {\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    }\n    locationFromCursor(cursor) {\n        return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n    }\n}\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n    constructor(fileOrCursor, range) {\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\n            super(fileOrCursor);\n            this.internalState = { ...fileOrCursor.internalState };\n        }\n        else {\n            super(fileOrCursor, range);\n            this.internalState = this.state;\n        }\n    }\n    advance() {\n        this.state = this.internalState;\n        super.advance();\n        this.processEscapeSequence();\n    }\n    init() {\n        super.init();\n        this.processEscapeSequence();\n    }\n    clone() {\n        return new EscapedCharacterCursor(this);\n    }\n    getChars(start) {\n        const cursor = start.clone();\n        let chars = '';\n        while (cursor.internalState.offset < this.internalState.offset) {\n            chars += String.fromCodePoint(cursor.peek());\n            cursor.advance();\n        }\n        return chars;\n    }\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n    processEscapeSequence() {\n        const peek = () => this.internalState.peek;\n        if (peek() === $BACKSLASH) {\n            // We have hit an escape sequence so we need the internal state to become independent\n            // of the external state.\n            this.internalState = { ...this.state };\n            // Move past the backslash\n            this.advanceState(this.internalState);\n            // First check for standard control char sequences\n            if (peek() === $n) {\n                this.state.peek = $LF;\n            }\n            else if (peek() === $r) {\n                this.state.peek = $CR;\n            }\n            else if (peek() === $v) {\n                this.state.peek = $VTAB;\n            }\n            else if (peek() === $t) {\n                this.state.peek = $TAB;\n            }\n            else if (peek() === $b) {\n                this.state.peek = $BSPACE;\n            }\n            else if (peek() === $f) {\n                this.state.peek = $FF;\n            }\n            // Now consider more complex sequences\n            else if (peek() === $u) {\n                // Unicode code-point sequence\n                this.advanceState(this.internalState); // advance past the `u` char\n                if (peek() === $LBRACE) {\n                    // Variable length Unicode, e.g. `\\x{123}`\n                    this.advanceState(this.internalState); // advance past the `{` char\n                    // Advance past the variable number of hex digits until we hit a `}` char\n                    const digitStart = this.clone();\n                    let length = 0;\n                    while (peek() !== $RBRACE) {\n                        this.advanceState(this.internalState);\n                        length++;\n                    }\n                    this.state.peek = this.decodeHexDigits(digitStart, length);\n                }\n                else {\n                    // Fixed length Unicode, e.g. `\\u1234`\n                    const digitStart = this.clone();\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.advanceState(this.internalState);\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\n                }\n            }\n            else if (peek() === $x) {\n                // Hex char code, e.g. `\\x2F`\n                this.advanceState(this.internalState); // advance past the `x` char\n                const digitStart = this.clone();\n                this.advanceState(this.internalState);\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\n            }\n            else if (isOctalDigit(peek())) {\n                // Octal char code, e.g. `\\012`,\n                let octal = '';\n                let length = 0;\n                let previous = this.clone();\n                while (isOctalDigit(peek()) && length < 3) {\n                    previous = this.clone();\n                    octal += String.fromCodePoint(peek());\n                    this.advanceState(this.internalState);\n                    length++;\n                }\n                this.state.peek = parseInt(octal, 8);\n                // Backup one char\n                this.internalState = previous.internalState;\n            }\n            else if (isNewLine(this.internalState.peek)) {\n                // Line continuation `\\` followed by a new line\n                this.advanceState(this.internalState); // advance over the newline\n                this.state = this.internalState;\n            }\n            else {\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\n                // In that case we just, effectively, skip the backslash from the character.\n                this.state.peek = this.internalState.peek;\n            }\n        }\n    }\n    decodeHexDigits(start, length) {\n        const hex = this.input.slice(start.internalState.offset, start.internalState.offset + length);\n        const charCode = parseInt(hex, 16);\n        if (!isNaN(charCode)) {\n            return charCode;\n        }\n        else {\n            start.state = start.internalState;\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\n        }\n    }\n}\nclass CursorError {\n    constructor(msg, cursor) {\n        this.msg = msg;\n        this.cursor = cursor;\n    }\n}\n\nclass TreeError extends ParseError {\n    static create(elementName, span, msg) {\n        return new TreeError(elementName, span, msg);\n    }\n    constructor(elementName, span, msg) {\n        super(span, msg);\n        this.elementName = elementName;\n    }\n}\nclass ParseTreeResult {\n    constructor(rootNodes, errors) {\n        this.rootNodes = rootNodes;\n        this.errors = errors;\n    }\n}\nclass Parser {\n    constructor(getTagDefinition) {\n        this.getTagDefinition = getTagDefinition;\n    }\n    parse(source, url, options) {\n        const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n        const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n        parser.build();\n        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\n    }\n}\nclass _TreeBuilder {\n    constructor(tokens, getTagDefinition) {\n        this.tokens = tokens;\n        this.getTagDefinition = getTagDefinition;\n        this._index = -1;\n        this._elementStack = [];\n        this.rootNodes = [];\n        this.errors = [];\n        this._advance();\n    }\n    build() {\n        while (this._peek.type !== 24 /* TokenType.EOF */) {\n            if (this._peek.type === 0 /* TokenType.TAG_OPEN_START */ ||\n                this._peek.type === 4 /* TokenType.INCOMPLETE_TAG_OPEN */) {\n                this._consumeStartTag(this._advance());\n            }\n            else if (this._peek.type === 3 /* TokenType.TAG_CLOSE */) {\n                this._consumeEndTag(this._advance());\n            }\n            else if (this._peek.type === 12 /* TokenType.CDATA_START */) {\n                this._closeVoidElement();\n                this._consumeCdata(this._advance());\n            }\n            else if (this._peek.type === 10 /* TokenType.COMMENT_START */) {\n                this._closeVoidElement();\n                this._consumeComment(this._advance());\n            }\n            else if (this._peek.type === 5 /* TokenType.TEXT */ || this._peek.type === 7 /* TokenType.RAW_TEXT */ ||\n                this._peek.type === 6 /* TokenType.ESCAPABLE_RAW_TEXT */) {\n                this._closeVoidElement();\n                this._consumeText(this._advance());\n            }\n            else if (this._peek.type === 19 /* TokenType.EXPANSION_FORM_START */) {\n                this._consumeExpansion(this._advance());\n            }\n            else {\n                // Skip all other tokens...\n                this._advance();\n            }\n        }\n    }\n    _advance() {\n        const prev = this._peek;\n        if (this._index < this.tokens.length - 1) {\n            // Note: there is always an EOF token at the end\n            this._index++;\n        }\n        this._peek = this.tokens[this._index];\n        return prev;\n    }\n    _advanceIf(type) {\n        if (this._peek.type === type) {\n            return this._advance();\n        }\n        return null;\n    }\n    _consumeCdata(_startToken) {\n        this._consumeText(this._advance());\n        this._advanceIf(13 /* TokenType.CDATA_END */);\n    }\n    _consumeComment(token) {\n        const text = this._advanceIf(7 /* TokenType.RAW_TEXT */);\n        this._advanceIf(11 /* TokenType.COMMENT_END */);\n        const value = text != null ? text.parts[0].trim() : null;\n        this._addToParent(new Comment(value, token.sourceSpan));\n    }\n    _consumeExpansion(token) {\n        const switchValue = this._advance();\n        const type = this._advance();\n        const cases = [];\n        // read =\n        while (this._peek.type === 20 /* TokenType.EXPANSION_CASE_VALUE */) {\n            const expCase = this._parseExpansionCase();\n            if (!expCase)\n                return; // error\n            cases.push(expCase);\n        }\n        // read the final }\n        if (this._peek.type !== 23 /* TokenType.EXPANSION_FORM_END */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n            return;\n        }\n        const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n        this._advance();\n    }\n    _parseExpansionCase() {\n        const value = this._advance();\n        // read {\n        if (this._peek.type !== 21 /* TokenType.EXPANSION_CASE_EXP_START */) {\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n            return null;\n        }\n        // read until }\n        const start = this._advance();\n        const exp = this._collectExpansionExpTokens(start);\n        if (!exp)\n            return null;\n        const end = this._advance();\n        exp.push({ type: 24 /* TokenType.EOF */, parts: [], sourceSpan: end.sourceSpan });\n        // parse everything in between { and }\n        const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n        expansionCaseParser.build();\n        if (expansionCaseParser.errors.length > 0) {\n            this.errors = this.errors.concat(expansionCaseParser.errors);\n            return null;\n        }\n        const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n        const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n        return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n    _collectExpansionExpTokens(start) {\n        const exp = [];\n        const expansionFormStack = [21 /* TokenType.EXPANSION_CASE_EXP_START */];\n        while (true) {\n            if (this._peek.type === 19 /* TokenType.EXPANSION_FORM_START */ ||\n                this._peek.type === 21 /* TokenType.EXPANSION_CASE_EXP_START */) {\n                expansionFormStack.push(this._peek.type);\n            }\n            if (this._peek.type === 22 /* TokenType.EXPANSION_CASE_EXP_END */) {\n                if (lastOnStack(expansionFormStack, 21 /* TokenType.EXPANSION_CASE_EXP_START */)) {\n                    expansionFormStack.pop();\n                    if (expansionFormStack.length === 0)\n                        return exp;\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 23 /* TokenType.EXPANSION_FORM_END */) {\n                if (lastOnStack(expansionFormStack, 19 /* TokenType.EXPANSION_FORM_START */)) {\n                    expansionFormStack.pop();\n                }\n                else {\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                    return null;\n                }\n            }\n            if (this._peek.type === 24 /* TokenType.EOF */) {\n                this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n                return null;\n            }\n            exp.push(this._advance());\n        }\n    }\n    _consumeText(token) {\n        const tokens = [token];\n        const startSpan = token.sourceSpan;\n        let text = token.parts[0];\n        if (text.length > 0 && text[0] === '\\n') {\n            const parent = this._getParentElement();\n            if (parent != null && parent.children.length === 0 &&\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\n                text = text.substring(1);\n                tokens[0] = { type: token.type, sourceSpan: token.sourceSpan, parts: [text] };\n            }\n        }\n        while (this._peek.type === 8 /* TokenType.INTERPOLATION */ || this._peek.type === 5 /* TokenType.TEXT */ ||\n            this._peek.type === 9 /* TokenType.ENCODED_ENTITY */) {\n            token = this._advance();\n            tokens.push(token);\n            if (token.type === 8 /* TokenType.INTERPOLATION */) {\n                // For backward compatibility we decode HTML entities that appear in interpolation\n                // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                // chain after View Engine has been removed.\n                text += token.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n            }\n            else if (token.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                text += token.parts[0];\n            }\n            else {\n                text += token.parts.join('');\n            }\n        }\n        if (text.length > 0) {\n            const endSpan = token.sourceSpan;\n            this._addToParent(new Text(text, new ParseSourceSpan(startSpan.start, endSpan.end, startSpan.fullStart, startSpan.details), tokens));\n        }\n    }\n    _closeVoidElement() {\n        const el = this._getParentElement();\n        if (el && this.getTagDefinition(el.name).isVoid) {\n            this._elementStack.pop();\n        }\n    }\n    _consumeStartTag(startTagToken) {\n        const [prefix, name] = startTagToken.parts;\n        const attrs = [];\n        while (this._peek.type === 14 /* TokenType.ATTR_NAME */) {\n            attrs.push(this._consumeAttr(this._advance()));\n        }\n        const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n        let selfClosing = false;\n        // Note: There could have been a tokenizer error\n        // so that we don't get a token for the end tag...\n        if (this._peek.type === 2 /* TokenType.TAG_OPEN_END_VOID */) {\n            this._advance();\n            selfClosing = true;\n            const tagDef = this.getTagDefinition(fullName);\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n                this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void, custom and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n            }\n        }\n        else if (this._peek.type === 1 /* TokenType.TAG_OPEN_END */) {\n            this._advance();\n            selfClosing = false;\n        }\n        const end = this._peek.sourceSpan.fullStart;\n        const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n        const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n        const el = new Element(fullName, attrs, [], span, startSpan, undefined);\n        this._pushElement(el);\n        if (selfClosing) {\n            // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n            // element start tag also represents the end tag.\n            this._popElement(fullName, span);\n        }\n        else if (startTagToken.type === 4 /* TokenType.INCOMPLETE_TAG_OPEN */) {\n            // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n            // close tag. Let's optimistically parse it as a full element and emit an error.\n            this._popElement(fullName, null);\n            this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\n        }\n    }\n    _pushElement(el) {\n        const parentEl = this._getParentElement();\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n            this._elementStack.pop();\n        }\n        this._addToParent(el);\n        this._elementStack.push(el);\n    }\n    _consumeEndTag(endTagToken) {\n        const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n        if (this.getTagDefinition(fullName).isVoid) {\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n        }\n        else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n            const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n        }\n    }\n    /**\n     * Closes the nearest element with the tag name `fullName` in the parse tree.\n     * `endSourceSpan` is the span of the closing tag, or null if the element does\n     * not have a closing tag (for example, this happens when an incomplete\n     * opening tag is recovered).\n     */\n    _popElement(fullName, endSourceSpan) {\n        let unexpectedCloseTagDetected = false;\n        for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n            const el = this._elementStack[stackIndex];\n            if (el.name === fullName) {\n                // Record the parse span with the element that is being closed. Any elements that are\n                // removed from the element stack at this point are closed implicitly, so they won't get\n                // an end source span (as there is no explicit closing element).\n                el.endSourceSpan = endSourceSpan;\n                el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n                return !unexpectedCloseTagDetected;\n            }\n            if (!this.getTagDefinition(el.name).closedByParent) {\n                // Note that we encountered an unexpected close tag but continue processing the element\n                // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n                // end tag in the stack.\n                unexpectedCloseTagDetected = true;\n            }\n        }\n        return false;\n    }\n    _consumeAttr(attrName) {\n        const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n        let attrEnd = attrName.sourceSpan.end;\n        // Consume any quote\n        if (this._peek.type === 15 /* TokenType.ATTR_QUOTE */) {\n            this._advance();\n        }\n        // Consume the attribute value\n        let value = '';\n        const valueTokens = [];\n        let valueStartSpan = undefined;\n        let valueEnd = undefined;\n        // NOTE: We need to use a new variable `nextTokenType` here to hide the actual type of\n        // `_peek.type` from TS. Otherwise TS will narrow the type of `_peek.type` preventing it from\n        // being able to consider `ATTR_VALUE_INTERPOLATION` as an option. This is because TS is not\n        // able to see that `_advance()` will actually mutate `_peek`.\n        const nextTokenType = this._peek.type;\n        if (nextTokenType === 16 /* TokenType.ATTR_VALUE_TEXT */) {\n            valueStartSpan = this._peek.sourceSpan;\n            valueEnd = this._peek.sourceSpan.end;\n            while (this._peek.type === 16 /* TokenType.ATTR_VALUE_TEXT */ ||\n                this._peek.type === 17 /* TokenType.ATTR_VALUE_INTERPOLATION */ ||\n                this._peek.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                const valueToken = this._advance();\n                valueTokens.push(valueToken);\n                if (valueToken.type === 17 /* TokenType.ATTR_VALUE_INTERPOLATION */) {\n                    // For backward compatibility we decode HTML entities that appear in interpolation\n                    // expressions. This is arguably a bug, but it could be a considerable breaking change to\n                    // fix it. It should be addressed in a larger project to refactor the entire parser/lexer\n                    // chain after View Engine has been removed.\n                    value += valueToken.parts.join('').replace(/&([^;]+);/g, decodeEntity);\n                }\n                else if (valueToken.type === 9 /* TokenType.ENCODED_ENTITY */) {\n                    value += valueToken.parts[0];\n                }\n                else {\n                    value += valueToken.parts.join('');\n                }\n                valueEnd = attrEnd = valueToken.sourceSpan.end;\n            }\n        }\n        // Consume any quote\n        if (this._peek.type === 15 /* TokenType.ATTR_QUOTE */) {\n            const quoteToken = this._advance();\n            attrEnd = quoteToken.sourceSpan.end;\n        }\n        const valueSpan = valueStartSpan && valueEnd &&\n            new ParseSourceSpan(valueStartSpan.start, valueEnd, valueStartSpan.fullStart);\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, attrEnd, attrName.sourceSpan.fullStart), attrName.sourceSpan, valueSpan, valueTokens.length > 0 ? valueTokens : undefined, undefined);\n    }\n    _getParentElement() {\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n    _addToParent(node) {\n        const parent = this._getParentElement();\n        if (parent != null) {\n            parent.children.push(node);\n        }\n        else {\n            this.rootNodes.push(node);\n        }\n    }\n    _getElementFullName(prefix, localName, parentElement) {\n        if (prefix === '') {\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n            if (prefix === '' && parentElement != null) {\n                const parentTagName = splitNsName(parentElement.name)[1];\n                const parentTagDefinition = this.getTagDefinition(parentTagName);\n                if (!parentTagDefinition.preventNamespaceInheritance) {\n                    prefix = getNsPrefix(parentElement.name);\n                }\n            }\n        }\n        return mergeNsAndName(prefix, localName);\n    }\n}\nfunction lastOnStack(stack, element) {\n    return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * Decode the `entity` string, which we believe is the contents of an HTML entity.\n *\n * If the string is not actually a valid/known entity then just return the original `match` string.\n */\nfunction decodeEntity(match, entity) {\n    if (NAMED_ENTITIES[entity] !== undefined) {\n        return NAMED_ENTITIES[entity] || match;\n    }\n    if (/^#x[a-f0-9]+$/i.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(2), 16));\n    }\n    if (/^#\\d+$/.test(entity)) {\n        return String.fromCodePoint(parseInt(entity.slice(1), 10));\n    }\n    return match;\n}\n\nclass HtmlParser extends Parser {\n    constructor() {\n        super(getHtmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\nfunction hasPreserveWhitespacesAttr(attrs) {\n    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nfunction replaceNgsp(value) {\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nclass WhitespaceVisitor {\n    visitElement(element, context) {\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n            // don't descent into elements where we need to preserve whitespaces\n            // but still visit all attributes to eliminate one used as a market to preserve WS\n            return new Element(element.name, visitAll(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        return new Element(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n    visitAttribute(attribute, context) {\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n    visitText(text, context) {\n        const isNotBlank = text.value.match(NO_WS_REGEXP);\n        const hasExpansionSibling = context &&\n            (context.prev instanceof Expansion || context.next instanceof Expansion);\n        if (isNotBlank || hasExpansionSibling) {\n            // Process the whitespace in the tokens of this Text node\n            const tokens = text.tokens.map(token => token.type === 5 /* TokenType.TEXT */ ? createWhitespaceProcessedTextToken(token) : token);\n            // Process the whitespace of the value of this Text node\n            const value = processWhitespace(text.value);\n            return new Text(value, text.sourceSpan, tokens, text.i18n);\n        }\n        return null;\n    }\n    visitComment(comment, context) {\n        return comment;\n    }\n    visitExpansion(expansion, context) {\n        return expansion;\n    }\n    visitExpansionCase(expansionCase, context) {\n        return expansionCase;\n    }\n}\nfunction createWhitespaceProcessedTextToken({ type, parts, sourceSpan }) {\n    return { type, parts: [processWhitespace(parts[0])], sourceSpan };\n}\nfunction processWhitespace(text) {\n    return replaceNgsp(text).replace(WS_REPLACE_REGEXP, ' ');\n}\nfunction removeWhitespaces(htmlAstWithErrors) {\n    return new ParseTreeResult(visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\nfunction visitAllWithSiblings(visitor, nodes) {\n    const result = [];\n    nodes.forEach((ast, i) => {\n        const context = { prev: nodes[i - 1], next: nodes[i + 1] };\n        const astResult = ast.visit(visitor, context);\n        if (astResult) {\n            result.push(astResult);\n        }\n    });\n    return result;\n}\n\nfunction mapEntry(key, value) {\n    return { key, value, quoted: false };\n}\nfunction mapLiteral(obj, quoted = false) {\n    return literalMap(Object.keys(obj).map(key => ({\n        key,\n        quoted,\n        value: obj[key],\n    })));\n}\n\n/**\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\n * tags use '*'.\n *\n * Extracted from, and should be kept in sync with\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\n */\nconst TRUSTED_TYPES_SINKS = new Set([\n    // NOTE: All strings in this set *must* be lowercase!\n    // TrustedHTML\n    'iframe|srcdoc',\n    '*|innerhtml',\n    '*|outerhtml',\n    // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n    // TrustedScriptURL\n    'embed|src',\n    'object|codebase',\n    'object|data',\n]);\n/**\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\n * Trusted Type is required for values passed to the sink:\n * - SecurityContext.HTML corresponds to TrustedHTML\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\n */\nfunction isTrustedTypesSink(tagName, propName) {\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\n    // property names do not have a security impact.\n    tagName = tagName.toLowerCase();\n    propName = propName.toLowerCase();\n    return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\n        TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\nclass BindingParser {\n    constructor(_exprParser, _interpolationConfig, _schemaRegistry, errors) {\n        this._exprParser = _exprParser;\n        this._interpolationConfig = _interpolationConfig;\n        this._schemaRegistry = _schemaRegistry;\n        this.errors = errors;\n    }\n    get interpolationConfig() {\n        return this._interpolationConfig;\n    }\n    createBoundHostProperties(properties, sourceSpan) {\n        const boundProps = [];\n        for (const propName of Object.keys(properties)) {\n            const expression = properties[propName];\n            if (typeof expression === 'string') {\n                this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], \n                // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n                // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n                // source of the host binding (which doesn't exist in the template). Regardless,\n                // neither of these values are used in Ivy but are only here to satisfy the function\n                // signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                boundProps, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return boundProps;\n    }\n    createDirectiveHostEventAsts(hostListeners, sourceSpan) {\n        const targetEvents = [];\n        for (const propName of Object.keys(hostListeners)) {\n            const expression = hostListeners[propName];\n            if (typeof expression === 'string') {\n                // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n                // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n                // rather than the source of the host binding (which doesn't exist in the template).\n                // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n                // function signature. This should likely be refactored in the future so that `sourceSpan`\n                // isn't being used inaccurately.\n                this.parseEvent(propName, expression, /* isAssignmentEvent */ false, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n            }\n            else {\n                this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\n            }\n        }\n        return targetEvents;\n    }\n    parseInterpolation(value, sourceSpan, interpolatedTokens) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.fullStart.offset;\n        try {\n            const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, interpolatedTokens, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n    parseInterpolationExpression(expression, sourceSpan) {\n        const sourceInfo = sourceSpan.start.toString();\n        const absoluteOffset = sourceSpan.start.offset;\n        try {\n            const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n        const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX$1.length;\n        const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n        for (const binding of bindings) {\n            // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n            // binding within the microsyntax expression so it's more narrow than sourceSpan.\n            const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n            const key = binding.key.source;\n            const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n            if (binding instanceof VariableBinding) {\n                const value = binding.value ? binding.value.source : '$implicit';\n                const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n                targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n            }\n            else if (binding.value) {\n                const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n                const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n                this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            }\n            else {\n                targetMatchableAttrs.push([key, '' /* value */]);\n                // Since this is a literal attribute with no RHS, source span should be\n                // just the key span.\n                this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);\n            }\n        }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n        const sourceInfo = sourceSpan.start.toString();\n        try {\n            const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n            bindingsResult.warnings.forEach((warning) => {\n                this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n            });\n            return bindingsResult.templateBindings;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return [];\n        }\n    }\n    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (isAnimationLabel(name)) {\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            if (value) {\n                this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                    ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\n            }\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n        }\n    }\n    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Property name is missing in binding`, sourceSpan);\n        }\n        let isAnimationProp = false;\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n            isAnimationProp = true;\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n            }\n        }\n        else if (isAnimationLabel(name)) {\n            isAnimationProp = true;\n            name = name.substring(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n        }\n        if (isAnimationProp) {\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n        else {\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n        }\n    }\n    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps, keySpan, interpolatedTokens) {\n        const expr = this.parseInterpolation(value, valueSpan || sourceSpan, interpolatedTokens);\n        if (expr) {\n            this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n            return true;\n        }\n        return false;\n    }\n    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n    }\n    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n        if (name.length === 0) {\n            this._reportError('Animation trigger is missing', sourceSpan);\n        }\n        // This will occur when a @trigger is not paired with an expression.\n        // For animations it is valid to not have an expression since */void\n        // states will be applied by angular when the element is attached/detached\n        const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n    }\n    _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n        try {\n            const ast = isHostBinding ?\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast)\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\n        if (boundProp.isAnimation) {\n            return new BoundElementProperty(boundProp.name, 4 /* BindingType.Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n        }\n        let unit = null;\n        let bindingType = undefined;\n        let boundPropertyName = null;\n        const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n        let securityContexts = undefined;\n        // Check for special cases (prefix style, attr, class)\n        if (parts.length > 1) {\n            if (parts[0] == ATTRIBUTE_PREFIX) {\n                boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n                if (!skipValidation) {\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n                }\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n                const nsSeparatorIdx = boundPropertyName.indexOf(':');\n                if (nsSeparatorIdx > -1) {\n                    const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n                    const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n                    boundPropertyName = mergeNsAndName(ns, name);\n                }\n                bindingType = 1 /* BindingType.Attribute */;\n            }\n            else if (parts[0] == CLASS_PREFIX) {\n                boundPropertyName = parts[1];\n                bindingType = 2 /* BindingType.Class */;\n                securityContexts = [SecurityContext.NONE];\n            }\n            else if (parts[0] == STYLE_PREFIX) {\n                unit = parts.length > 2 ? parts[2] : null;\n                boundPropertyName = parts[1];\n                bindingType = 3 /* BindingType.Style */;\n                securityContexts = [SecurityContext.STYLE];\n            }\n        }\n        // If not a special case, use the full property name\n        if (boundPropertyName === null) {\n            const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n            bindingType = 0 /* BindingType.Property */;\n            if (!skipValidation) {\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n            }\n        }\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n    // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n    parseEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        if (name.length === 0) {\n            this._reportError(`Event name is missing in binding`, sourceSpan);\n        }\n        if (isAnimationLabel(name)) {\n            name = name.slice(1);\n            if (keySpan !== undefined) {\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n            }\n            this._parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan);\n        }\n        else {\n            this._parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n        }\n    }\n    calcPossibleSecurityContexts(selector, propName, isAttribute) {\n        const prop = this._schemaRegistry.getMappedPropName(propName);\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    }\n    _parseAnimationEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetEvents, keySpan) {\n        const matches = splitAtPeriod(name, [name, '']);\n        const eventName = matches[0];\n        const phase = matches[1].toLowerCase();\n        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n        targetEvents.push(new ParsedEvent(eventName, phase, 1 /* ParsedEventType.Animation */, ast, sourceSpan, handlerSpan, keySpan));\n        if (eventName.length === 0) {\n            this._reportError(`Animation event name is missing in binding`, sourceSpan);\n        }\n        if (phase) {\n            if (phase !== 'start' && phase !== 'done') {\n                this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\n            }\n        }\n        else {\n            this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\n        }\n    }\n    _parseRegularEvent(name, expression, isAssignmentEvent, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n        // long format: 'target: eventName'\n        const [target, eventName] = splitAtColon(name, [null, name]);\n        const ast = this._parseAction(expression, isAssignmentEvent, handlerSpan);\n        targetMatchableAttrs.push([name, ast.source]);\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* ParsedEventType.Regular */, ast, sourceSpan, handlerSpan, keySpan));\n        // Don't detect directives for event names for now,\n        // so don't add the event name to the matchableAttrs\n    }\n    _parseAction(value, isAssignmentEvent, sourceSpan) {\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n        const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n        try {\n            const ast = this._exprParser.parseAction(value, isAssignmentEvent, sourceInfo, absoluteOffset, this._interpolationConfig);\n            if (ast) {\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\n            }\n            if (!ast || ast.ast instanceof EmptyExpr) {\n                this._reportError(`Empty expressions are not allowed`, sourceSpan);\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n            }\n            return ast;\n        }\n        catch (e) {\n            this._reportError(`${e}`, sourceSpan);\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n    }\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n    _reportExpressionParserErrors(errors, sourceSpan) {\n        for (const error of errors) {\n            this._reportError(error.message, sourceSpan);\n        }\n    }\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n        const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n            this._schemaRegistry.validateProperty(propName);\n        if (report.error) {\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n        }\n    }\n}\nclass PipeCollector extends RecursiveAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.pipes = new Map();\n    }\n    visitPipe(ast, context) {\n        this.pipes.set(ast.name, ast);\n        ast.exp.visit(this);\n        this.visitAll(ast.args, context);\n        return null;\n    }\n}\nfunction isAnimationLabel(name) {\n    return name[0] == '@';\n}\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    const ctxs = [];\n    CssSelector.parse(selector).forEach((selector) => {\n        const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n        const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n            .map((selector) => selector.element));\n        const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));\n        ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));\n    });\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n    // The difference of two absolute offsets provide the relative offset\n    const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n    const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\nfunction isStyleUrlResolvable(url) {\n    if (url == null || url.length === 0 || url[0] == '/')\n        return false;\n    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n\nconst NG_CONTENT_SELECT_ATTR$1 = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\nfunction preparseElement(ast) {\n    let selectAttr = null;\n    let hrefAttr = null;\n    let relAttr = null;\n    let nonBindable = false;\n    let projectAs = '';\n    ast.attrs.forEach(attr => {\n        const lcAttrName = attr.name.toLowerCase();\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR$1) {\n            selectAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n            hrefAttr = attr.value;\n        }\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n            relAttr = attr.value;\n        }\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\n            nonBindable = true;\n        }\n        else if (attr.name == NG_PROJECT_AS) {\n            if (attr.value.length > 0) {\n                projectAs = attr.value;\n            }\n        }\n    });\n    selectAttr = normalizeNgContentSelect(selectAttr);\n    const nodeName = ast.name.toLowerCase();\n    let type = PreparsedElementType.OTHER;\n    if (isNgContent(nodeName)) {\n        type = PreparsedElementType.NG_CONTENT;\n    }\n    else if (nodeName == STYLE_ELEMENT) {\n        type = PreparsedElementType.STYLE;\n    }\n    else if (nodeName == SCRIPT_ELEMENT) {\n        type = PreparsedElementType.SCRIPT;\n    }\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n        type = PreparsedElementType.STYLESHEET;\n    }\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\nvar PreparsedElementType;\n(function (PreparsedElementType) {\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\nclass PreparsedElement {\n    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n        this.type = type;\n        this.selectAttr = selectAttr;\n        this.hrefAttr = hrefAttr;\n        this.nonBindable = nonBindable;\n        this.projectAs = projectAs;\n    }\n}\nfunction normalizeNgContentSelect(selectAttr) {\n    if (selectAttr === null || selectAttr.length === 0) {\n        return '*';\n    }\n    return selectAttr;\n}\n\nconst BIND_NAME_REGEXP = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\nconst BINDING_DELIMS = {\n    BANANA_BOX: { start: '[(', end: ')]' },\n    PROPERTY: { start: '[', end: ']' },\n    EVENT: { start: '(', end: ')' },\n};\nconst TEMPLATE_ATTR_PREFIX = '*';\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n    const transformer = new HtmlAstToIvyAst(bindingParser, options);\n    const ivyNodes = visitAll(transformer, htmlNodes);\n    // Errors might originate in either the binding parser or the html to ivy transformer\n    const allErrors = bindingParser.errors.concat(transformer.errors);\n    const result = {\n        nodes: ivyNodes,\n        errors: allErrors,\n        styleUrls: transformer.styleUrls,\n        styles: transformer.styles,\n        ngContentSelectors: transformer.ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        result.commentNodes = transformer.commentNodes;\n    }\n    return result;\n}\nclass HtmlAstToIvyAst {\n    constructor(bindingParser, options) {\n        this.bindingParser = bindingParser;\n        this.options = options;\n        this.errors = [];\n        this.styles = [];\n        this.styleUrls = [];\n        this.ngContentSelectors = [];\n        // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n        this.commentNodes = [];\n        this.inI18nBlock = false;\n    }\n    // HTML visitor\n    visitElement(element) {\n        const isI18nRootElement = isI18nRootNode(element.i18n);\n        if (isI18nRootElement) {\n            if (this.inI18nBlock) {\n                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n            }\n            this.inI18nBlock = true;\n        }\n        const preparsedElement = preparseElement(element);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\n            const contents = textContents(element);\n            if (contents !== null) {\n                this.styles.push(contents);\n            }\n            return null;\n        }\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n            this.styleUrls.push(preparsedElement.hrefAttr);\n            return null;\n        }\n        // Whether the element is a `<ng-template>`\n        const isTemplateElement = isNgTemplate(element.name);\n        const parsedProperties = [];\n        const boundEvents = [];\n        const variables = [];\n        const references = [];\n        const attributes = [];\n        const i18nAttrsMeta = {};\n        const templateParsedProperties = [];\n        const templateVariables = [];\n        // Whether the element has any *-attribute\n        let elementHasInlineTemplate = false;\n        for (const attribute of element.attrs) {\n            let hasBinding = false;\n            const normalizedName = normalizeAttributeName(attribute.name);\n            // `*attr` defines template bindings\n            let isTemplateBinding = false;\n            if (attribute.i18n) {\n                i18nAttrsMeta[attribute.name] = attribute.i18n;\n            }\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n                // *-attributes\n                if (elementHasInlineTemplate) {\n                    this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\n                }\n                isTemplateBinding = true;\n                elementHasInlineTemplate = true;\n                const templateValue = attribute.value;\n                const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n                const parsedVariables = [];\n                const absoluteValueOffset = attribute.valueSpan ?\n                    attribute.valueSpan.start.offset :\n                    // If there is no value span the attribute does not have a value, like `attr` in\n                    //`<div attr></div>`. In this case, point to one character beyond the last character of\n                    // the attribute name.\n                    attribute.sourceSpan.start.offset + attribute.name.length;\n                this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);\n                templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\n            }\n            else {\n                // Check for variables, events, property bindings, interpolation\n                hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n            }\n            if (!hasBinding && !isTemplateBinding) {\n                // don't include the bindings as attributes as well in the AST\n                attributes.push(this.visitAttribute(attribute));\n            }\n        }\n        const children = visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n        let parsedElement;\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n            // `<ng-content>`\n            if (element.children &&\n                !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {\n                this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n            }\n            const selector = preparsedElement.selectAttr;\n            const attrs = element.attrs.map(attr => this.visitAttribute(attr));\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n            this.ngContentSelectors.push(selector);\n        }\n        else if (isTemplateElement) {\n            // `<ng-template>`\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        else {\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n            parsedElement = new Element$1(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n        }\n        if (elementHasInlineTemplate) {\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n            // node that contains this node.\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\n            // node for matching against content projection selectors.\n            const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n            const templateAttrs = [];\n            attrs.literal.forEach(attr => templateAttrs.push(attr));\n            attrs.bound.forEach(attr => templateAttrs.push(attr));\n            const hoistedAttrs = parsedElement instanceof Element$1 ?\n                {\n                    attributes: parsedElement.attributes,\n                    inputs: parsedElement.inputs,\n                    outputs: parsedElement.outputs,\n                } :\n                { attributes: [], inputs: [], outputs: [] };\n            // For <ng-template>s with structural directives on them, avoid passing i18n information to\n            // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n            // necessary i18n meta information will be extracted from child elements.\n            const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\n            const name = parsedElement instanceof Template ? null : parsedElement.name;\n            parsedElement = new Template(name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\n        }\n        if (isI18nRootElement) {\n            this.inI18nBlock = false;\n        }\n        return parsedElement;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.tokens, text.i18n);\n    }\n    visitExpansion(expansion) {\n        if (!expansion.i18n) {\n            // do not generate Icu in case it was created\n            // outside of i18n block in a template\n            return null;\n        }\n        if (!isI18nRootNode(expansion.i18n)) {\n            throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\n        }\n        const message = expansion.i18n;\n        const vars = {};\n        const placeholders = {};\n        // extract VARs from ICUs - we process them separately while\n        // assembling resulting message via goog.getMsg function, since\n        // we need to pass them to top-level goog.getMsg call\n        Object.keys(message.placeholders).forEach(key => {\n            const value = message.placeholders[key];\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n                // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n                // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n                // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n                // converted into `_` symbols while normalizing placeholder names, which might lead to\n                // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n                const formattedKey = key.trim();\n                const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n                vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n            }\n            else {\n                placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan, null);\n            }\n        });\n        return new Icu$1(vars, placeholders, expansion.sourceSpan, message);\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n    visitComment(comment) {\n        if (this.options.collectCommentNodes) {\n            this.commentNodes.push(new Comment$1(comment.value || '', comment.sourceSpan));\n        }\n        return null;\n    }\n    // convert view engine `ParsedProperty` to a format suitable for IVY\n    extractAttributes(elementName, properties, i18nPropsMeta) {\n        const bound = [];\n        const literal = [];\n        properties.forEach(prop => {\n            const i18n = i18nPropsMeta[prop.name];\n            if (prop.isLiteral) {\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n            }\n            else {\n                // Note that validation is skipped and property mapping is disabled\n                // due to the fact that we need to make sure a given prop is not an\n                // input of a directive and directive matching happens at runtime.\n                const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n            }\n        });\n        return { bound, literal };\n    }\n    parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n        const name = normalizeAttributeName(attribute.name);\n        const value = attribute.value;\n        const srcSpan = attribute.sourceSpan;\n        const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n        function createKeySpan(srcSpan, prefix, identifier) {\n            // We need to adjust the start location for the keySpan to account for the removed 'data-'\n            // prefix from `normalizeAttributeName`.\n            const normalizationAdjustment = attribute.name.length - name.length;\n            const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n            const keySpanEnd = keySpanStart.moveBy(identifier.length);\n            return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n        }\n        const bindParts = name.match(BIND_NAME_REGEXP);\n        if (bindParts) {\n            if (bindParts[KW_BIND_IDX] != null) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else if (bindParts[KW_LET_IDX]) {\n                if (isTemplateElement) {\n                    const identifier = bindParts[IDENT_KW_IDX];\n                    const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX], identifier);\n                    this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\n                }\n                else {\n                    this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n                }\n            }\n            else if (bindParts[KW_REF_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX], identifier);\n                this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\n            }\n            else if (bindParts[KW_ON_IDX]) {\n                const events = [];\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX], identifier);\n                this.bindingParser.parseEvent(identifier, value, /* isAssignmentEvent */ false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            else if (bindParts[KW_BINDON_IDX]) {\n                const identifier = bindParts[IDENT_KW_IDX];\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX], identifier);\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (bindParts[KW_AT_IDX]) {\n                const keySpan = createKeySpan(srcSpan, '', name);\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            return true;\n        }\n        // We didn't see a kw-prefixed property binding, but we have not yet checked\n        // for the []/()/[()] syntax.\n        let delims = null;\n        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n            delims = BINDING_DELIMS.BANANA_BOX;\n        }\n        else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n            delims = BINDING_DELIMS.PROPERTY;\n        }\n        else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n            delims = BINDING_DELIMS.EVENT;\n        }\n        if (delims !== null &&\n            // NOTE: older versions of the parser would match a start/end delimited\n            // binding iff the property name was terminated by the ending delimiter\n            // and the identifier in the binding was non-empty.\n            // TODO(ayazhafiz): update this to handle malformed bindings.\n            name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n            const identifier = name.substring(delims.start.length, name.length - delims.end.length);\n            const keySpan = createKeySpan(srcSpan, delims.start, identifier);\n            if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\n            }\n            else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n            }\n            else {\n                const events = [];\n                this.bindingParser.parseEvent(identifier, value, /* isAssignmentEvent */ false, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\n                addEvents(events, boundEvents);\n            }\n            return true;\n        }\n        // No explicit binding found.\n        const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\n        const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan, attribute.valueTokens ?? null);\n        return hasBinding;\n    }\n    _visitTextWithInterpolation(value, sourceSpan, interpolatedTokens, i18n) {\n        const valueNoNgsp = replaceNgsp(value);\n        const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan, interpolatedTokens);\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text$3(valueNoNgsp, sourceSpan);\n    }\n    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Variable does not have a name`, sourceSpan);\n        }\n        variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n        if (identifier.indexOf('-') > -1) {\n            this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n        }\n        else if (identifier.length === 0) {\n            this.reportError(`Reference does not have a name`, sourceSpan);\n        }\n        else if (references.some(reference => reference.name === identifier)) {\n            this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\n        }\n        references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\n        const events = [];\n        this.bindingParser.parseEvent(`${name}Change`, `${expression} =$event`, /* isAssignmentEvent */ true, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n        addEvents(events, boundEvents);\n    }\n    reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\n        this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n}\nclass NonBindableVisitor {\n    visitElement(ast) {\n        const preparsedElement = preparseElement(ast);\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n            preparsedElement.type === PreparsedElementType.STYLE ||\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\n            // Skipping <script> for security reasons\n            // Skipping <style> and stylesheets as we already processed them\n            // in the StyleCompiler\n            return null;\n        }\n        const children = visitAll(this, ast.children, null);\n        return new Element$1(ast.name, visitAll(this, ast.attrs), \n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    }\n    visitComment(comment) {\n        return null;\n    }\n    visitAttribute(attribute) {\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n    visitText(text) {\n        return new Text$3(text.value, text.sourceSpan);\n    }\n    visitExpansion(expansion) {\n        return null;\n    }\n    visitExpansionCase(expansionCase) {\n        return null;\n    }\n}\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\nfunction normalizeAttributeName(attrName) {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\nfunction addEvents(events, boundEvents) {\n    boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\n}\nfunction isEmptyTextNode(node) {\n    return node instanceof Text && node.value.trim().length == 0;\n}\nfunction isCommentNode(node) {\n    return node instanceof Comment;\n}\nfunction textContents(node) {\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text)) {\n        return null;\n    }\n    else {\n        return node.children[0].value;\n    }\n}\n\nvar TagType;\n(function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nesting level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nclass I18nContext {\n    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {\n        this.index = index;\n        this.ref = ref;\n        this.level = level;\n        this.templateIndex = templateIndex;\n        this.meta = meta;\n        this.registry = registry;\n        this.bindings = new Set();\n        this.placeholders = new Map();\n        this.isEmitted = false;\n        this._unresolvedCtxCount = 0;\n        this._registry = registry || setupRegistry();\n        this.id = this._registry.getUniqueId();\n    }\n    appendTag(type, node, index, closed) {\n        if (node.isVoid && closed) {\n            return; // ignore \"close\" for void tags\n        }\n        const ph = node.isVoid || !closed ? node.startName : node.closeName;\n        const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };\n        updatePlaceholderMap(this.placeholders, ph, content);\n    }\n    get icus() {\n        return this._registry.icus;\n    }\n    get isRoot() {\n        return this.level === 0;\n    }\n    get isResolved() {\n        return this._unresolvedCtxCount === 0;\n    }\n    getSerializedPlaceholders() {\n        const result = new Map();\n        this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));\n        return result;\n    }\n    // public API to accumulate i18n-related content\n    appendBinding(binding) {\n        this.bindings.add(binding);\n    }\n    appendIcu(name, ref) {\n        updatePlaceholderMap(this._registry.icus, name, ref);\n    }\n    appendBoundText(node) {\n        const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n        phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n    }\n    appendTemplate(node, index) {\n        // add open and close tags at the same time,\n        // since we process nested templates separately\n        this.appendTag(TagType.TEMPLATE, node, index, false);\n        this.appendTag(TagType.TEMPLATE, node, index, true);\n        this._unresolvedCtxCount++;\n    }\n    appendElement(node, index, closed) {\n        this.appendTag(TagType.ELEMENT, node, index, closed);\n    }\n    appendProjection(node, index) {\n        // Add open and close tags at the same time, since `<ng-content>` has no content,\n        // so when we come across `<ng-content>` we can register both open and close tags.\n        // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n        // regular element tag placeholders, so we generate element placeholders for both types.\n        this.appendTag(TagType.ELEMENT, node, index, false);\n        this.appendTag(TagType.ELEMENT, node, index, true);\n    }\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n    forkChildContext(index, templateIndex, meta) {\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    }\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n    reconcileChildContext(context) {\n        // set the right context id for open and close\n        // template tags, so we can use it as sub-block ids\n        ['start', 'close'].forEach((op) => {\n            const key = context.meta[`${op}Name`];\n            const phs = this.placeholders.get(key) || [];\n            const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n            if (tag) {\n                tag.ctx = context.id;\n            }\n        });\n        // reconcile placeholders\n        const childPhs = context.placeholders;\n        childPhs.forEach((values, key) => {\n            const phs = this.placeholders.get(key);\n            if (!phs) {\n                this.placeholders.set(key, values);\n                return;\n            }\n            // try to find matching template...\n            const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n            if (tmplIdx >= 0) {\n                // ... if found - replace it with nested template content\n                const isCloseTag = key.startsWith('CLOSE');\n                const isTemplateTag = key.endsWith('NG-TEMPLATE');\n                if (isTemplateTag) {\n                    // current template's content is placed before or after\n                    // parent template tag, depending on the open/close attribute\n                    phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n                }\n                else {\n                    const idx = isCloseTag ? values.length - 1 : 0;\n                    values[idx].tmpl = phs[tmplIdx];\n                    phs.splice(tmplIdx, 1, ...values);\n                }\n            }\n            else {\n                // ... otherwise just append content to placeholder value\n                phs.push(...values);\n            }\n            this.placeholders.set(key, phs);\n        });\n        this._unresolvedCtxCount--;\n    }\n}\n//\n// Helper methods\n//\nfunction wrap(symbol, index, contextId, closed) {\n    const state = closed ? '/' : '';\n    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\nfunction wrapTag(symbol, { index, ctx, isVoid }, closed) {\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n        wrap(symbol, index, ctx, closed);\n}\nfunction findTemplateFn(ctx, templateIndex) {\n    return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n        token.index === templateIndex && token.ctx === ctx;\n}\nfunction serializePlaceholderValue(value) {\n    const element = (data, closed) => wrapTag('#', data, closed);\n    const template = (data, closed) => wrapTag('*', data, closed);\n    switch (value.type) {\n        case TagType.ELEMENT:\n            // close element tag\n            if (value.closed) {\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n            }\n            // open element tag that also initiates a template\n            if (value.tmpl) {\n                return template(value.tmpl) + element(value) +\n                    (value.isVoid ? template(value.tmpl, true) : '');\n            }\n            return element(value);\n        case TagType.TEMPLATE:\n            return template(value, value.closed);\n        default:\n            return value;\n    }\n}\n\nclass IcuSerializerVisitor {\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\n        const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n        return result;\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n    formatPh(value) {\n        return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\n    }\n}\nconst serializer = new IcuSerializerVisitor();\nfunction serializeIcuNode(icu) {\n    return icu.visit(serializer);\n}\n\nconst TAG_TO_PLACEHOLDER_NAMES = {\n    'A': 'LINK',\n    'B': 'BOLD_TEXT',\n    'BR': 'LINE_BREAK',\n    'EM': 'EMPHASISED_TEXT',\n    'H1': 'HEADING_LEVEL1',\n    'H2': 'HEADING_LEVEL2',\n    'H3': 'HEADING_LEVEL3',\n    'H4': 'HEADING_LEVEL4',\n    'H5': 'HEADING_LEVEL5',\n    'H6': 'HEADING_LEVEL6',\n    'HR': 'HORIZONTAL_RULE',\n    'I': 'ITALIC_TEXT',\n    'LI': 'LIST_ITEM',\n    'LINK': 'MEDIA_LINK',\n    'OL': 'ORDERED_LIST',\n    'P': 'PARAGRAPH',\n    'Q': 'QUOTATION',\n    'S': 'STRIKETHROUGH_TEXT',\n    'SMALL': 'SMALL_TEXT',\n    'SUB': 'SUBSTRIPT',\n    'SUP': 'SUPERSCRIPT',\n    'TBODY': 'TABLE_BODY',\n    'TD': 'TABLE_CELL',\n    'TFOOT': 'TABLE_FOOTER',\n    'TH': 'TABLE_HEADER_CELL',\n    'THEAD': 'TABLE_HEADER',\n    'TR': 'TABLE_ROW',\n    'TT': 'MONOSPACED_TEXT',\n    'U': 'UNDERLINED_TEXT',\n    'UL': 'UNORDERED_LIST',\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\nclass PlaceholderRegistry {\n    constructor() {\n        // Count the occurrence of the base name top generate a unique name\n        this._placeHolderNameCounts = {};\n        // Maps signature to placeholder names\n        this._signatureToName = {};\n    }\n    getStartTagPlaceholderName(tag, attrs, isVoid) {\n        const signature = this._hashTag(tag, attrs, isVoid);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getCloseTagPlaceholderName(tag) {\n        const signature = this._hashClosingTag(tag);\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const upperTag = tag.toUpperCase();\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\n        const name = this._generateUniqueName(`CLOSE_${baseName}`);\n        this._signatureToName[signature] = name;\n        return name;\n    }\n    getPlaceholderName(name, content) {\n        const upperName = name.toUpperCase();\n        const signature = `PH: ${upperName}=${content}`;\n        if (this._signatureToName[signature]) {\n            return this._signatureToName[signature];\n        }\n        const uniqueName = this._generateUniqueName(upperName);\n        this._signatureToName[signature] = uniqueName;\n        return uniqueName;\n    }\n    getUniquePlaceholder(name) {\n        return this._generateUniqueName(name.toUpperCase());\n    }\n    // Generate a hash for a tag - does not take attribute order into account\n    _hashTag(tag, attrs, isVoid) {\n        const start = `<${tag}`;\n        const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\n        const end = isVoid ? '/>' : `></${tag}>`;\n        return start + strAttrs + end;\n    }\n    _hashClosingTag(tag) {\n        return this._hashTag(`/${tag}`, {}, false);\n    }\n    _generateUniqueName(base) {\n        const seen = this._placeHolderNameCounts.hasOwnProperty(base);\n        if (!seen) {\n            this._placeHolderNameCounts[base] = 1;\n            return base;\n        }\n        const id = this._placeHolderNameCounts[base];\n        this._placeHolderNameCounts[base] = id + 1;\n        return `${base}_${id}`;\n    }\n}\n\nconst _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nfunction createI18nMessageFactory(interpolationConfig) {\n    const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\nfunction noopVisitNodeFn(_html, i18n) {\n    return i18n;\n}\nclass _I18nVisitor {\n    constructor(_expressionParser, _interpolationConfig) {\n        this._expressionParser = _expressionParser;\n        this._interpolationConfig = _interpolationConfig;\n    }\n    toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\n        const context = {\n            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n            icuDepth: 0,\n            placeholderRegistry: new PlaceholderRegistry(),\n            placeholderToContent: {},\n            placeholderToMessage: {},\n            visitNodeFn: visitNodeFn || noopVisitNodeFn,\n        };\n        const i18nodes = visitAll(this, nodes, context);\n        return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    }\n    visitElement(el, context) {\n        const children = visitAll(this, el.children, context);\n        const attrs = {};\n        el.attrs.forEach(attr => {\n            // Do not visit the attributes, translatable ones are top-level ASTs\n            attrs[attr.name] = attr.value;\n        });\n        const isVoid = getHtmlTagDefinition(el.name).isVoid;\n        const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n        context.placeholderToContent[startPhName] = {\n            text: el.startSourceSpan.toString(),\n            sourceSpan: el.startSourceSpan,\n        };\n        let closePhName = '';\n        if (!isVoid) {\n            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n            context.placeholderToContent[closePhName] = {\n                text: `</${el.name}>`,\n                sourceSpan: el.endSourceSpan ?? el.sourceSpan,\n            };\n        }\n        const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        return context.visitNodeFn(el, node);\n    }\n    visitAttribute(attribute, context) {\n        const node = attribute.valueTokens === undefined || attribute.valueTokens.length === 1 ?\n            new Text$2(attribute.value, attribute.valueSpan || attribute.sourceSpan) :\n            this._visitTextWithInterpolation(attribute.valueTokens, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n        return context.visitNodeFn(attribute, node);\n    }\n    visitText(text, context) {\n        const node = text.tokens.length === 1 ?\n            new Text$2(text.value, text.sourceSpan) :\n            this._visitTextWithInterpolation(text.tokens, text.sourceSpan, context, text.i18n);\n        return context.visitNodeFn(text, node);\n    }\n    visitComment(comment, context) {\n        return null;\n    }\n    visitExpansion(icu, context) {\n        context.icuDepth++;\n        const i18nIcuCases = {};\n        const i18nIcu = new Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n        icu.cases.forEach((caze) => {\n            i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n        });\n        context.icuDepth--;\n        if (context.isIcu || context.icuDepth > 0) {\n            // Returns an ICU node when:\n            // - the message (vs a part of the message) is an ICU message, or\n            // - the ICU message is nested.\n            const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n            i18nIcu.expressionPlaceholder = expPh;\n            context.placeholderToContent[expPh] = {\n                text: icu.switchValue,\n                sourceSpan: icu.switchValueSourceSpan,\n            };\n            return context.visitNodeFn(icu, i18nIcu);\n        }\n        // Else returns a placeholder\n        // ICU placeholders should not be replaced with their original content but with the their\n        // translations.\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n        const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n        context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n        const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n        return context.visitNodeFn(icu, node);\n    }\n    visitExpansionCase(_icuCase, _context) {\n        throw new Error('Unreachable code');\n    }\n    /**\n     * Convert, text and interpolated tokens up into text and placeholder pieces.\n     *\n     * @param tokens The text and interpolated tokens.\n     * @param sourceSpan The span of the whole of the `text` string.\n     * @param context The current context of the visitor, used to compute and store placeholders.\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n     */\n    _visitTextWithInterpolation(tokens, sourceSpan, context, previousI18n) {\n        // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n        const nodes = [];\n        // We will only create a container if there are actually interpolations,\n        // so this flag tracks that.\n        let hasInterpolation = false;\n        for (const token of tokens) {\n            switch (token.type) {\n                case 8 /* TokenType.INTERPOLATION */:\n                case 17 /* TokenType.ATTR_VALUE_INTERPOLATION */:\n                    hasInterpolation = true;\n                    const expression = token.parts[1];\n                    const baseName = extractPlaceholderName(expression) || 'INTERPOLATION';\n                    const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n                    context.placeholderToContent[phName] = {\n                        text: token.parts.join(''),\n                        sourceSpan: token.sourceSpan\n                    };\n                    nodes.push(new Placeholder(expression, phName, token.sourceSpan));\n                    break;\n                default:\n                    if (token.parts[0].length > 0) {\n                        // This token is text or an encoded entity.\n                        // If it is following on from a previous text node then merge it into that node\n                        // Otherwise, if it is following an interpolation, then add a new node.\n                        const previous = nodes[nodes.length - 1];\n                        if (previous instanceof Text$2) {\n                            previous.value += token.parts[0];\n                            previous.sourceSpan = new ParseSourceSpan(previous.sourceSpan.start, token.sourceSpan.end, previous.sourceSpan.fullStart, previous.sourceSpan.details);\n                        }\n                        else {\n                            nodes.push(new Text$2(token.parts[0], token.sourceSpan));\n                        }\n                    }\n                    break;\n            }\n        }\n        if (hasInterpolation) {\n            // Whitespace removal may have invalidated the interpolation source-spans.\n            reusePreviousSourceSpans(nodes, previousI18n);\n            return new Container(nodes, sourceSpan);\n        }\n        else {\n            return nodes[0];\n        }\n    }\n}\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n    if (previousI18n instanceof Message) {\n        // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n        // metadata. The `Message` should consist only of a single `Container` that contains the\n        // parts (`Text` and `Placeholder`) to process.\n        assertSingleContainerMessage(previousI18n);\n        previousI18n = previousI18n.nodes[0];\n    }\n    if (previousI18n instanceof Container) {\n        // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n        // after whitespace has been removed from the AST nodes.\n        assertEquivalentNodes(previousI18n.children, nodes);\n        // Reuse the source-spans from the first pass.\n        for (let i = 0; i < nodes.length; i++) {\n            nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n        }\n    }\n}\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message) {\n    const nodes = message.nodes;\n    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n        throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n    }\n}\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes, nodes) {\n    if (previousNodes.length !== nodes.length) {\n        throw new Error('The number of i18n message children changed between first and second pass.');\n    }\n    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n        throw new Error('The types of the i18n message children changed between first and second pass.');\n    }\n}\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\nfunction extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n}\n\n/**\n * An i18n error.\n */\nclass I18nError extends ParseError {\n    constructor(span, msg) {\n        super(span, msg);\n    }\n}\n\nconst setI18nRefs = (htmlNode, i18nNode) => {\n    if (htmlNode instanceof NodeWithI18n) {\n        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n            // This html node represents an ICU but this is a second processing pass, and the legacy id\n            // was computed in the previous pass and stored in the `i18n` property as a message.\n            // We are about to wipe out that property so capture the previous message to be reused when\n            // generating the message for this ICU later. See `_generateI18nMessage()`.\n            i18nNode.previousMessage = htmlNode.i18n;\n        }\n        htmlNode.i18n = i18nNode;\n    }\n    return i18nNode;\n};\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nclass I18nMetaVisitor {\n    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {\n        this.interpolationConfig = interpolationConfig;\n        this.keepI18nAttrs = keepI18nAttrs;\n        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n        // whether visited nodes contain i18n information\n        this.hasI18nMeta = false;\n        this._errors = [];\n        // i18n message generation factory\n        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n    }\n    _generateI18nMessage(nodes, meta = '', visitNodeFn) {\n        const { meaning, description, customId } = this._parseMetadata(meta);\n        const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n        this._setMessageId(message, meta);\n        this._setLegacyIds(message, meta);\n        return message;\n    }\n    visitAllWithErrors(nodes) {\n        const result = nodes.map(node => node.visit(this, null));\n        return new ParseTreeResult(result, this._errors);\n    }\n    visitElement(element) {\n        let message = undefined;\n        if (hasI18nAttrs(element)) {\n            this.hasI18nMeta = true;\n            const attrs = [];\n            const attrsMeta = {};\n            for (const attr of element.attrs) {\n                if (attr.name === I18N_ATTR) {\n                    // root 'i18n' node attribute\n                    const i18n = element.i18n || attr.value;\n                    message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n                    if (message.nodes.length === 0) {\n                        // Ignore the message if it is empty.\n                        message = undefined;\n                    }\n                    // Store the message on the element\n                    element.i18n = message;\n                }\n                else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n                    // 'i18n-*' attributes\n                    const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n                    if (isTrustedTypesSink(element.name, name)) {\n                        this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n                    }\n                    else {\n                        attrsMeta[name] = attr.value;\n                    }\n                }\n                else {\n                    // non-i18n attributes\n                    attrs.push(attr);\n                }\n            }\n            // set i18n meta for attributes\n            if (Object.keys(attrsMeta).length) {\n                for (const attr of attrs) {\n                    const meta = attrsMeta[attr.name];\n                    // do not create translation for empty attributes\n                    if (meta !== undefined && attr.value) {\n                        attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n                    }\n                }\n            }\n            if (!this.keepI18nAttrs) {\n                // update element's attributes,\n                // keeping only non-i18n related ones\n                element.attrs = attrs;\n            }\n        }\n        visitAll(this, element.children, message);\n        return element;\n    }\n    visitExpansion(expansion, currentMessage) {\n        let message;\n        const meta = expansion.i18n;\n        this.hasI18nMeta = true;\n        if (meta instanceof IcuPlaceholder) {\n            // set ICU placeholder name (e.g. \"ICU_1\"),\n            // generated while processing root element contents,\n            // so we can reference it when we output translation\n            const name = meta.name;\n            message = this._generateI18nMessage([expansion], meta);\n            const icu = icuFromI18nMessage(message);\n            icu.name = name;\n            if (currentMessage !== null) {\n                // Also update the placeholderToMessage map with this new message\n                currentMessage.placeholderToMessage[name] = message;\n            }\n        }\n        else {\n            // ICU is a top level message, try to use metadata from container element if provided via\n            // `context` argument. Note: context may not be available for standalone ICUs (without\n            // wrapping element), so fallback to ICU metadata in this case.\n            message = this._generateI18nMessage([expansion], currentMessage || meta);\n        }\n        expansion.i18n = message;\n        return expansion;\n    }\n    visitText(text) {\n        return text;\n    }\n    visitAttribute(attribute) {\n        return attribute;\n    }\n    visitComment(comment) {\n        return comment;\n    }\n    visitExpansionCase(expansionCase) {\n        return expansionCase;\n    }\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n    _parseMetadata(meta) {\n        return typeof meta === 'string' ? parseI18nMeta(meta) :\n            meta instanceof Message ? meta :\n                {};\n    }\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n    _setMessageId(message, meta) {\n        if (!message.id) {\n            message.id = meta instanceof Message && meta.id || decimalDigest(message);\n        }\n    }\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n    _setLegacyIds(message, meta) {\n        if (this.enableI18nLegacyMessageIdFormat) {\n            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n        }\n        else if (typeof meta !== 'string') {\n            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n            // `packages/compiler/src/render3/view/template.ts`).\n            // In that case we want to reuse the legacy message generated in the 1st pass (see\n            // `setI18nRefs()`).\n            const previousMessage = meta instanceof Message ? meta :\n                meta instanceof IcuPlaceholder ? meta.previousMessage :\n                    undefined;\n            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n        }\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nfunction parseI18nMeta(meta = '') {\n    let customId;\n    let meaning;\n    let description;\n    meta = meta.trim();\n    if (meta) {\n        const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n        const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n        let meaningAndDesc;\n        [meaningAndDesc, customId] =\n            (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n        [meaning, description] = (descIndex > -1) ?\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n            ['', meaningAndDesc];\n    }\n    return { customId, meaning, description };\n}\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nfunction i18nMetaToJSDoc(meta) {\n    const tags = [];\n    if (meta.description) {\n        tags.push({ tagName: \"desc\" /* o.JSDocTagName.Desc */, text: meta.description });\n    }\n    else {\n        // Suppress the JSCompiler warning that a `@desc` was not given for this message.\n        tags.push({ tagName: \"suppress\" /* o.JSDocTagName.Suppress */, text: '{msgDescriptions}' });\n    }\n    if (meta.meaning) {\n        tags.push({ tagName: \"meaning\" /* o.JSDocTagName.Meaning */, text: meta.meaning });\n    }\n    return jsDocComment(tags);\n}\n\n/** Closure uses `goog.getMsg(message)` to lookup translations */\nconst GOOG_GET_MSG = 'goog.getMsg';\n/**\n * Generates a `goog.getMsg()` statement and reassignment. The template:\n *\n * ```html\n * <div i18n>Sent from {{ sender }} to <span class=\"receiver\">{{ receiver }}</span></div>\n * ```\n *\n * Generates:\n *\n * ```typescript\n * const MSG_FOO = goog.getMsg(\n *   // Message template.\n *   'Sent from {$interpolation} to {$startTagSpan}{$interpolation_1}{$closeTagSpan}.',\n *   // Placeholder values, set to magic strings which get replaced by the Angular runtime.\n *   {\n *     'interpolation': '\\uFFFD0\\uFFFD',\n *     'startTagSpan': '\\uFFFD1\\uFFFD',\n *     'interpolation_1': '\\uFFFD2\\uFFFD',\n *     'closeTagSpan': '\\uFFFD3\\uFFFD',\n *   },\n *   // Options bag.\n *   {\n *     // Maps each placeholder to the original Angular source code which generates it's value.\n *     original_code: {\n *       'interpolation': '{{ sender }}',\n *       'startTagSpan': '<span class=\"receiver\">',\n *       'interpolation_1': '{{ receiver }}',\n *       'closeTagSpan': '</span>',\n *     },\n *   },\n * );\n * const I18N_0 = MSG_FOO;\n * ```\n */\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, placeholderValues) {\n    const messageString = serializeI18nMessageForGetMsg(message);\n    const args = [literal(messageString)];\n    if (Object.keys(placeholderValues).length) {\n        // Message template parameters containing the magic strings replaced by the Angular runtime with\n        // real data, e.g. `{'interpolation': '\\uFFFD0\\uFFFD'}`.\n        args.push(mapLiteral(formatI18nPlaceholderNamesInMap(placeholderValues, true /* useCamelCase */), true /* quoted */));\n        // Message options object, which contains original source code for placeholders (as they are\n        // present in a template, e.g.\n        // `{original_code: {'interpolation': '{{ name }}', 'startTagSpan': '<span>'}}`.\n        args.push(mapLiteral({\n            original_code: literalMap(Object.keys(placeholderValues)\n                .map((param) => ({\n                key: formatI18nPlaceholderName(param),\n                quoted: true,\n                value: message.placeholders[param] ?\n                    // Get source span for typical placeholder if it exists.\n                    literal(message.placeholders[param].sourceSpan.toString()) :\n                    // Otherwise must be an ICU expression, get it's source span.\n                    literal(message.placeholderToMessage[param]\n                        .nodes.map((node) => node.sourceSpan.toString())\n                        .join('')),\n            }))),\n        }));\n    }\n    // /**\n    //  * @desc description of message\n    //  * @meaning meaning of message\n    //  */\n    // const MSG_... = goog.getMsg(..);\n    // I18N_X = MSG_...;\n    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n    googGetMsgStmt.addLeadingComment(i18nMetaToJSDoc(message));\n    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n    return [googGetMsgStmt, i18nAssignmentStmt];\n}\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\nclass GetMsgSerializerVisitor {\n    formatPh(value) {\n        return `{$${formatI18nPlaceholderName(value)}}`;\n    }\n    visitText(text) {\n        return text.value;\n    }\n    visitContainer(container) {\n        return container.children.map(child => child.visit(this)).join('');\n    }\n    visitIcu(icu) {\n        return serializeIcuNode(icu);\n    }\n    visitTagPlaceholder(ph) {\n        return ph.isVoid ?\n            this.formatPh(ph.startName) :\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\n    }\n    visitPlaceholder(ph) {\n        return this.formatPh(ph.name);\n    }\n    visitIcuPlaceholder(ph, context) {\n        return this.formatPh(ph.name);\n    }\n}\nconst serializerVisitor = new GetMsgSerializerVisitor();\nfunction serializeI18nMessageForGetMsg(message) {\n    return message.nodes.map(node => node.visit(serializerVisitor, null)).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);\n    const sourceSpan = getSourceSpan(message);\n    const expressions = placeHolders.map(ph => params[ph.text]);\n    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n    const variableInitialization = variable.set(localizedString$1);\n    return [new ExpressionStatement(variableInitialization)];\n}\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor {\n    constructor(placeholderToMessage, pieces) {\n        this.placeholderToMessage = placeholderToMessage;\n        this.pieces = pieces;\n    }\n    visitText(text) {\n        if (this.pieces[this.pieces.length - 1] instanceof LiteralPiece) {\n            // Two literal pieces in a row means that there was some comment node in-between.\n            this.pieces[this.pieces.length - 1].text += text.value;\n        }\n        else {\n            const sourceSpan = new ParseSourceSpan(text.sourceSpan.fullStart, text.sourceSpan.end, text.sourceSpan.fullStart, text.sourceSpan.details);\n            this.pieces.push(new LiteralPiece(text.value, sourceSpan));\n        }\n    }\n    visitContainer(container) {\n        container.children.forEach(child => child.visit(this));\n    }\n    visitIcu(icu) {\n        this.pieces.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n    }\n    visitTagPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n        if (!ph.isVoid) {\n            ph.children.forEach(child => child.visit(this));\n            this.pieces.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n        }\n    }\n    visitPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    }\n    visitIcuPlaceholder(ph) {\n        this.pieces.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan, this.placeholderToMessage[ph.name]));\n    }\n    createPlaceholderPiece(name, sourceSpan, associatedMessage) {\n        return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan, associatedMessage);\n    }\n}\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction serializeI18nMessageForLocalize(message) {\n    const pieces = [];\n    const serializerVisitor = new LocalizeSerializerVisitor(message.placeholderToMessage, pieces);\n    message.nodes.forEach(node => node.visit(serializerVisitor));\n    return processMessagePieces(pieces);\n}\nfunction getSourceSpan(message) {\n    const startNode = message.nodes[0];\n    const endNode = message.nodes[message.nodes.length - 1];\n    return new ParseSourceSpan(startNode.sourceSpan.fullStart, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces) {\n    const messageParts = [];\n    const placeHolders = [];\n    if (pieces[0] instanceof PlaceholderPiece) {\n        // The first piece was a placeholder so we need to add an initial empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n    }\n    for (let i = 0; i < pieces.length; i++) {\n        const part = pieces[i];\n        if (part instanceof LiteralPiece) {\n            messageParts.push(part);\n        }\n        else {\n            placeHolders.push(part);\n            if (pieces[i - 1] instanceof PlaceholderPiece) {\n                // There were two placeholders in a row, so we need to add an empty message part.\n                messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n            }\n        }\n    }\n    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n        // The last piece was a placeholder so we need to add a final empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n    }\n    return { messageParts, placeHolders };\n}\nfunction createEmptyMessagePart(location) {\n    return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\n\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n//  if (rf & flags) { .. }\nfunction renderFlagCheckIfStmt(flags, statements) {\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\nfunction prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {\n    const { type, name, target, phase, handler } = eventAst;\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n        throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n    }\n    const eventArgumentName = '$event';\n    const implicitReceiverAccesses = new Set();\n    const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n        variable(CONTEXT_NAME) :\n        scope.getOrCreateSharedContextVar(0);\n    const bindingStatements = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n    const statements = [];\n    const variableDeclarations = scope?.variableDeclarations();\n    const restoreViewStatement = scope?.restoreViewStatement();\n    if (variableDeclarations) {\n        // `variableDeclarations` needs to run first, because\n        // `restoreViewStatement` depends on the result.\n        statements.push(...variableDeclarations);\n    }\n    statements.push(...bindingStatements);\n    if (restoreViewStatement) {\n        statements.unshift(restoreViewStatement);\n        // If there's a `restoreView` call, we need to reset the view at the end of the listener\n        // in order to avoid a leak. If there's a `return` statement already, we wrap it in the\n        // call, e.g. `return resetView(ctx.foo())`. Otherwise we add the call as the last statement.\n        const lastStatement = statements[statements.length - 1];\n        if (lastStatement instanceof ReturnStatement) {\n            statements[statements.length - 1] = new ReturnStatement(invokeInstruction(lastStatement.value.sourceSpan, Identifiers.resetView, [lastStatement.value]));\n        }\n        else {\n            statements.push(new ExpressionStatement(invokeInstruction(null, Identifiers.resetView, [])));\n        }\n    }\n    const eventName = type === 1 /* ParsedEventType.Animation */ ? prepareSyntheticListenerName(name, phase) : name;\n    const fnName = handlerName && sanitizeIdentifier(handlerName);\n    const fnArgs = [];\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\n        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n    }\n    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n    const params = [literal(eventName), handlerFn];\n    if (target) {\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n    return params;\n}\nfunction createComponentDefConsts() {\n    return {\n        prepareStatements: [],\n        constExpressions: [],\n        i18nVarRefsCache: new Map(),\n    };\n}\nclass TemplateDefinitionBuilder {\n    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {\n        this.constantPool = constantPool;\n        this.level = level;\n        this.contextName = contextName;\n        this.i18nContext = i18nContext;\n        this.templateIndex = templateIndex;\n        this.templateName = templateName;\n        this._namespace = _namespace;\n        this.i18nUseExternalIds = i18nUseExternalIds;\n        this._constants = _constants;\n        this._dataIndex = 0;\n        this._bindingContext = 0;\n        this._prefixCode = [];\n        /**\n         * List of callbacks to generate creation mode instructions. We store them here as we process\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\n         * This ensures all local refs and context variables are available for matching.\n         */\n        this._creationCodeFns = [];\n        /**\n         * List of callbacks to generate update mode instructions. We store them here as we process\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\n         * all local refs and context variables are available for matching.\n         */\n        this._updateCodeFns = [];\n        /** Index of the currently-selected node. */\n        this._currentIndex = 0;\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n        this._tempVariables = [];\n        /**\n         * List of callbacks to build nested templates. Nested templates must not be visited until\n         * after the parent template has finished visiting all of its nodes. This ensures that all\n         * local ref bindings in nested templates are able to find local ref values if the refs\n         * are defined after the template declaration.\n         */\n        this._nestedTemplateFns = [];\n        // i18n context local to this template\n        this.i18n = null;\n        // Number of slots to reserve for pureFunctions\n        this._pureFunctionSlots = 0;\n        // Number of binding slots\n        this._bindingSlots = 0;\n        // Projection slots found in the template. Projection slots can distribute projected\n        // nodes based on a selector, or can just use the wildcard selector to match\n        // all nodes which aren't matching any selector.\n        this._ngContentReservedSlots = [];\n        // Number of non-default selectors found in all parent templates of this template. We need to\n        // track it to properly adjust projection slot index in the `projection` instruction.\n        this._ngContentSelectorsOffset = 0;\n        // Expression that should be used as implicit receiver when converting template\n        // expressions to output AST.\n        this._implicitReceiverExpr = null;\n        // These should be handled in the template or element directly.\n        this.visitReference = invalid;\n        this.visitVariable = invalid;\n        this.visitTextAttribute = invalid;\n        this.visitBoundAttribute = invalid;\n        this.visitBoundEvent = invalid;\n        this._bindingScope = parentBindingScope.nestedScope(level);\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\n        // characters with underscores.\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n        this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {\n            this._bindingScope.set(this.level, localName, value);\n            this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);\n        });\n    }\n    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n        if (this._namespace !== Identifiers.namespaceHTML) {\n            this.creationInstruction(null, this._namespace);\n        }\n        // Create variable bindings\n        variables.forEach(v => this.registerContextVariables(v));\n        // Initiate i18n context in case:\n        // - this template has parent i18n context\n        // - or the template has i18n meta associated with it,\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n        const initI18nContext = this.i18nContext ||\n            (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n                !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n        const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n        if (initI18nContext) {\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\n        }\n        // This is the initial pass through the nodes of this template. In this pass, we\n        // queue all creation mode and update mode instructions for generation in the second\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n        visitAll$1(this, nodes);\n        // Add total binding count to pure function count so pure function instructions are\n        // generated with the correct slot offset when update instructions are processed.\n        this._pureFunctionSlots += this._bindingSlots;\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\n        // to account for bindings.\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n        // Nested templates must be processed before creation instructions so template()\n        // instructions can be generated with the correct internal const count.\n        this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n        // The `projectionDef` instruction is only emitted for the component template and\n        // is skipped for nested templates (<ng-template> tags).\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\n            const parameters = [];\n            // By default the `projectionDef` instructions creates one slot for the wildcard\n            // selector if no parameters are passed. Therefore we only want to allocate a new\n            // array for the projection slots if the default projection slot is not sufficient.\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n                const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n            }\n            // Since we accumulate ngContent selectors while processing template elements,\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\n            // any `projection` instructions\n            this.creationInstruction(null, Identifiers.projectionDef, parameters, /* prepend */ true);\n        }\n        if (initI18nContext) {\n            this.i18nEnd(null, selfClosingI18nInstruction);\n        }\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n        const creationStatements = getInstructionStatements(this._creationCodeFns);\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\n        const updateStatements = getInstructionStatements(this._updateCodeFns);\n        //  Variable declaration must occur after binding resolution so we can generate context\n        //  instructions that build on each other.\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\n        const creationVariables = this._bindingScope.viewSnapshotStatements();\n        const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n        const creationBlock = creationStatements.length > 0 ?\n            [renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, creationVariables.concat(creationStatements))] :\n            [];\n        const updateBlock = updateStatements.length > 0 ?\n            [renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateVariables.concat(updateStatements))] :\n            [];\n        return fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n            // Temporary variable declarations for query refresh (i.e. let _t: any;)\n            ...this._prefixCode,\n            // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n            ...creationBlock,\n            // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n            ...updateBlock,\n        ], INFERRED_TYPE, null, this.templateName);\n    }\n    // LocalResolver\n    getLocal(name) {\n        return this._bindingScope.get(name);\n    }\n    // LocalResolver\n    notifyImplicitReceiverUse() {\n        this._bindingScope.notifyImplicitReceiverUse();\n    }\n    // LocalResolver\n    maybeRestoreView() {\n        this._bindingScope.maybeRestoreView();\n    }\n    i18nTranslate(message, params = {}, ref, transformFn) {\n        const _ref = ref || this.i18nGenerateMainBlockVar();\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n        const closureVar = this.i18nGenerateClosureVar(message.id);\n        const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n        this._constants.prepareStatements.push(...statements);\n        return _ref;\n    }\n    registerContextVariables(variable$1) {\n        const scopedName = this._bindingScope.freshReferenceName();\n        const retrievalLevel = this.level;\n        const lhs = variable(variable$1.name + scopedName);\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* DeclarationPriority.CONTEXT */, (scope, relativeLevel) => {\n            let rhs;\n            if (scope.bindingLevel === retrievalLevel) {\n                if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n                    // e.g. restoredCtx.\n                    // We have to get the context from a view reference, if one is available, because\n                    // the context that was passed in during creation may not be correct anymore.\n                    // For more information see: https://github.com/angular/angular/pull/40360.\n                    rhs = variable(RESTORED_VIEW_CONTEXT_NAME);\n                    scope.notifyRestoredViewContextUse();\n                }\n                else {\n                    // e.g. ctx\n                    rhs = variable(CONTEXT_NAME);\n                }\n            }\n            else {\n                const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n                // e.g. ctx_r0   OR  x(2);\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n            }\n            // e.g. const $item$ = x(2).$implicit;\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n    }\n    i18nAppendBindings(expressions) {\n        if (expressions.length > 0) {\n            expressions.forEach(expression => this.i18n.appendBinding(expression));\n        }\n    }\n    i18nBindProps(props) {\n        const bound = {};\n        Object.keys(props).forEach(key => {\n            const prop = props[key];\n            if (prop instanceof Text$3) {\n                bound[key] = literal(prop.value);\n            }\n            else {\n                const value = prop.value.visit(this._valueConverter);\n                this.allocateBindingSlots(value);\n                if (value instanceof Interpolation) {\n                    const { strings, expressions } = value;\n                    const { id, bindings } = this.i18n;\n                    const label = assembleI18nBoundString(strings, bindings.size, id);\n                    this.i18nAppendBindings(expressions);\n                    bound[key] = literal(label);\n                }\n            }\n        });\n        return bound;\n    }\n    // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n    i18nGenerateMainBlockVar() {\n        return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n    }\n    // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n    i18nGenerateClosureVar(messageId) {\n        let name;\n        const suffix = this.fileBasedI18nSuffix.toUpperCase();\n        if (this.i18nUseExternalIds) {\n            const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n            const uniqueSuffix = this.constantPool.uniqueName(suffix);\n            name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n        }\n        else {\n            const prefix = getTranslationConstPrefix(suffix);\n            name = this.constantPool.uniqueName(prefix);\n        }\n        return variable(name);\n    }\n    i18nUpdateRef(context) {\n        const { icus, meta, isRoot, isResolved, isEmitted } = context;\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n            context.isEmitted = true;\n            const placeholders = context.getSerializedPlaceholders();\n            let icuMapping = {};\n            let params = placeholders.size ? placeholdersToParams(placeholders) : {};\n            if (icus.size) {\n                icus.forEach((refs, key) => {\n                    if (refs.length === 1) {\n                        // if we have one ICU defined for a given\n                        // placeholder - just output its reference\n                        params[key] = refs[0];\n                    }\n                    else {\n                        // ... otherwise we need to activate post-processing\n                        // to replace ICU placeholders with proper values\n                        const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n                        params[key] = literal(placeholder);\n                        icuMapping[key] = literalArr(refs);\n                    }\n                });\n            }\n            // translation requires post processing in 2 cases:\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [#1, #2, ...])\n            // - if we have multiple ICUs that refer to the same placeholder name\n            const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||\n                Object.keys(icuMapping).length;\n            let transformFn;\n            if (needsPostprocessing) {\n                transformFn = (raw) => {\n                    const args = [raw];\n                    if (Object.keys(icuMapping).length) {\n                        args.push(mapLiteral(icuMapping, true));\n                    }\n                    return invokeInstruction(null, Identifiers.i18nPostprocess, args);\n                };\n            }\n            this.i18nTranslate(meta, params, context.ref, transformFn);\n        }\n    }\n    i18nStart(span = null, meta, selfClosing) {\n        const index = this.allocateDataSlot();\n        this.i18n = this.i18nContext ?\n            this.i18nContext.forkChildContext(index, this.templateIndex, meta) :\n            new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n        // generate i18nStart instruction\n        const { id, ref } = this.i18n;\n        const params = [literal(index), this.addToConsts(ref)];\n        if (id > 0) {\n            // do not push 3rd argument (sub-block id)\n            // into i18nStart call for top level i18n context\n            params.push(literal(id));\n        }\n        this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);\n    }\n    i18nEnd(span = null, selfClosing) {\n        if (!this.i18n) {\n            throw new Error('i18nEnd is executed with no i18n context present');\n        }\n        if (this.i18nContext) {\n            this.i18nContext.reconcileChildContext(this.i18n);\n            this.i18nUpdateRef(this.i18nContext);\n        }\n        else {\n            this.i18nUpdateRef(this.i18n);\n        }\n        // setup accumulated bindings\n        const { index, bindings } = this.i18n;\n        if (bindings.size) {\n            for (const binding of bindings) {\n                // for i18n block, advance to the most recent element index (by taking the current number of\n                // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n                // necessary lifecycle hooks of components/directives are properly flushed.\n                this.updateInstructionWithAdvance(this.getConstCount() - 1, span, Identifiers.i18nExp, () => this.convertPropertyBinding(binding));\n            }\n            this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);\n        }\n        if (!selfClosing) {\n            this.creationInstruction(span, Identifiers.i18nEnd);\n        }\n        this.i18n = null; // reset local i18n context\n    }\n    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\n        let hasBindings = false;\n        const i18nAttrArgs = [];\n        attrs.forEach(attr => {\n            const message = attr.i18n;\n            const converted = attr.value.visit(this._valueConverter);\n            this.allocateBindingSlots(converted);\n            if (converted instanceof Interpolation) {\n                const placeholders = assembleBoundTextPlaceholders(message);\n                const params = placeholdersToParams(placeholders);\n                i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));\n                converted.expressions.forEach(expression => {\n                    hasBindings = true;\n                    this.updateInstructionWithAdvance(nodeIndex, sourceSpan, Identifiers.i18nExp, () => this.convertPropertyBinding(expression));\n                });\n            }\n        });\n        if (i18nAttrArgs.length > 0) {\n            const index = literal(this.allocateDataSlot());\n            const constIndex = this.addToConsts(literalArr(i18nAttrArgs));\n            this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);\n            if (hasBindings) {\n                this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);\n            }\n        }\n    }\n    getNamespaceInstruction(namespaceKey) {\n        switch (namespaceKey) {\n            case 'math':\n                return Identifiers.namespaceMathML;\n            case 'svg':\n                return Identifiers.namespaceSVG;\n            default:\n                return Identifiers.namespaceHTML;\n        }\n    }\n    addNamespaceInstruction(nsInstruction, element) {\n        this._namespace = nsInstruction;\n        this.creationInstruction(element.startSourceSpan, nsInstruction);\n    }\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n    interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\n        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n    }\n    visitContent(ngContent) {\n        const slot = this.allocateDataSlot();\n        const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n        const parameters = [literal(slot)];\n        this._ngContentReservedSlots.push(ngContent.selector);\n        const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n        const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n        if (attributes.length > 0) {\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n        }\n        else if (projectionSlotIdx !== 0) {\n            parameters.push(literal(projectionSlotIdx));\n        }\n        this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);\n        if (this.i18n) {\n            this.i18n.appendProjection(ngContent.i18n, slot);\n        }\n    }\n    visitElement(element) {\n        const elementIndex = this.allocateDataSlot();\n        const stylingBuilder = new StylingBuilder(null);\n        let isNonBindableMode = false;\n        const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n        const outputAttrs = [];\n        const [namespaceKey, elementName] = splitNsName(element.name);\n        const isNgContainer$1 = isNgContainer(element.name);\n        // Handle styling, i18n, ngNonBindable attributes\n        for (const attr of element.attributes) {\n            const { name, value } = attr;\n            if (name === NON_BINDABLE_ATTR) {\n                isNonBindableMode = true;\n            }\n            else if (name === 'style') {\n                stylingBuilder.registerStyleAttr(value);\n            }\n            else if (name === 'class') {\n                stylingBuilder.registerClassAttr(value);\n            }\n            else {\n                outputAttrs.push(attr);\n            }\n        }\n        // Regular element or ng-container creation mode\n        const parameters = [literal(elementIndex)];\n        if (!isNgContainer$1) {\n            parameters.push(literal(elementName));\n        }\n        // Add the attributes\n        const allOtherInputs = [];\n        const boundI18nAttrs = [];\n        element.inputs.forEach(input => {\n            const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n            if (!stylingInputWasSet) {\n                if (input.type === 0 /* BindingType.Property */ && input.i18n) {\n                    boundI18nAttrs.push(input);\n                }\n                else {\n                    allOtherInputs.push(input);\n                }\n            }\n        });\n        // add attributes for directive and projection matching purposes\n        const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\n        parameters.push(this.addAttrsToConsts(attributes));\n        // local refs (ex.: <div #foo #bar=\"baz\">)\n        const refs = this.prepareRefsArray(element.references);\n        parameters.push(this.addToConsts(refs));\n        const wasInNamespace = this._namespace;\n        const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n        // If the namespace is changing now, include an instruction to change it\n        // during element creation.\n        if (currentNamespace !== wasInNamespace) {\n            this.addNamespaceInstruction(currentNamespace, element);\n        }\n        if (this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex);\n        }\n        // Note that we do not append text node instructions and ICUs inside i18n section,\n        // so we exclude them while calculating whether current element has children\n        const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n            element.children.length > 0;\n        const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n            element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n        const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n        if (createSelfClosingInstruction) {\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));\n        }\n        else {\n            this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));\n            if (isNonBindableMode) {\n                this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);\n            }\n            if (boundI18nAttrs.length > 0) {\n                this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, element.startSourceSpan ?? element.sourceSpan);\n            }\n            // Generate Listeners (outputs)\n            if (element.outputs.length > 0) {\n                for (const outputAst of element.outputs) {\n                    this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter(element.name, outputAst, elementIndex));\n                }\n            }\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n            if (isI18nRootElement) {\n                this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\n            }\n        }\n        // the code here will collect all update-level styling instructions and add them to the\n        // update block of the template function AOT code. Instructions like `styleProp`,\n        // `styleMap`, `classMap`, `classProp`\n        // are all generated and assigned in the code below.\n        const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n        const limit = stylingInstructions.length - 1;\n        for (let i = 0; i <= limit; i++) {\n            const instruction = stylingInstructions[i];\n            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n        }\n        // the reason why `undefined` is used is because the renderer understands this as a\n        // special value to symbolize that there is no RHS to this binding\n        // TODO (matsko): revisit this once FW-959 is approached\n        const emptyValueBindInstruction = literal(undefined);\n        const propertyBindings = [];\n        const attributeBindings = [];\n        // Generate element input bindings\n        allOtherInputs.forEach(input => {\n            const inputType = input.type;\n            if (inputType === 4 /* BindingType.Animation */) {\n                const value = input.value.visit(this._valueConverter);\n                // animation bindings can be presented in the following formats:\n                // 1. [@binding]=\"fooExp\"\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n                // 3. [@binding]\n                // 4. @binding\n                // All formats will be valid for when a synthetic binding is created.\n                // The reasoning for this is because the renderer should get each\n                // synthetic binding value in the order of the array that they are\n                // defined in...\n                const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n                this.allocateBindingSlots(value);\n                propertyBindings.push({\n                    span: input.sourceSpan,\n                    paramsOrFn: getBindingFunctionParams(() => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction, prepareSyntheticPropertyName(input.name))\n                });\n            }\n            else {\n                // we must skip attributes with associated i18n context, since these attributes are handled\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n                if (input.i18n)\n                    return;\n                const value = input.value.visit(this._valueConverter);\n                if (value !== undefined) {\n                    const params = [];\n                    const [attrNamespace, attrName] = splitNsName(input.name);\n                    const isAttributeBinding = inputType === 1 /* BindingType.Attribute */;\n                    let sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n                    if (!sanitizationRef) {\n                        // If there was no sanitization function found based on the security context\n                        // of an attribute/property - check whether this attribute/property is\n                        // one of the security-sensitive <iframe> attributes (and that the current\n                        // element is actually an <iframe>).\n                        if (isIframeElement(element.name) && isIframeSecuritySensitiveAttr(input.name)) {\n                            sanitizationRef = importExpr(Identifiers.validateIframeAttribute);\n                        }\n                    }\n                    if (sanitizationRef) {\n                        params.push(sanitizationRef);\n                    }\n                    if (attrNamespace) {\n                        const namespaceLiteral = literal(attrNamespace);\n                        if (sanitizationRef) {\n                            params.push(namespaceLiteral);\n                        }\n                        else {\n                            // If there wasn't a sanitization ref, we need to add\n                            // an extra param so that we can pass in the namespace.\n                            params.push(literal(null), namespaceLiteral);\n                        }\n                    }\n                    this.allocateBindingSlots(value);\n                    if (inputType === 0 /* BindingType.Property */) {\n                        if (value instanceof Interpolation) {\n                            // prop=\"{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            // [prop]=\"value\"\n                            // Collect all the properties so that we can chain into a single function at the end.\n                            propertyBindings.push({\n                                span: input.sourceSpan,\n                                paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), attrName, params)\n                            });\n                        }\n                    }\n                    else if (inputType === 1 /* BindingType.Attribute */) {\n                        if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n                            // attr.name=\"text{{value}}\" and friends\n                            this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);\n                        }\n                        else {\n                            const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                            // Collect the attribute bindings so that they can be chained at the end.\n                            attributeBindings.push({\n                                span: input.sourceSpan,\n                                paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(boundValue), attrName, params)\n                            });\n                        }\n                    }\n                    else {\n                        // class prop\n                        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {\n                            return [\n                                literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),\n                                ...params\n                            ];\n                        });\n                    }\n                }\n            }\n        });\n        for (const propertyBinding of propertyBindings) {\n            this.updateInstructionWithAdvance(elementIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);\n        }\n        for (const attributeBinding of attributeBindings) {\n            this.updateInstructionWithAdvance(elementIndex, attributeBinding.span, Identifiers.attribute, attributeBinding.paramsOrFn);\n        }\n        // Traverse element child nodes\n        visitAll$1(this, element.children);\n        if (!isI18nRootElement && this.i18n) {\n            this.i18n.appendElement(element.i18n, elementIndex, true);\n        }\n        if (!createSelfClosingInstruction) {\n            // Finish element construction mode.\n            const span = element.endSourceSpan ?? element.sourceSpan;\n            if (isI18nRootElement) {\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\n            }\n            if (isNonBindableMode) {\n                this.creationInstruction(span, Identifiers.enableBindings);\n            }\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);\n        }\n    }\n    visitTemplate(template) {\n        const NG_TEMPLATE_TAG_NAME = 'ng-template';\n        const templateIndex = this.allocateDataSlot();\n        if (this.i18n) {\n            this.i18n.appendTemplate(template.i18n, templateIndex);\n        }\n        const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n        const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\n        const templateName = `${contextName}_Template`;\n        const parameters = [\n            literal(templateIndex),\n            variable(templateName),\n            // We don't care about the tag's namespace here, because we infer\n            // it based on the parent nodes inside the template instruction.\n            literal(tagNameWithoutNamespace),\n        ];\n        // prepare attributes parameter (including attributes used for directive matching)\n        const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);\n        parameters.push(this.addAttrsToConsts(attrsExprs));\n        // local refs (ex.: <ng-template #foo>)\n        if (template.references && template.references.length) {\n            const refs = this.prepareRefsArray(template.references);\n            parameters.push(this.addToConsts(refs));\n            parameters.push(importExpr(Identifiers.templateRefExtractor));\n        }\n        // Create the template function\n        const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);\n        // Nested templates must not be visited until after their parent templates have completed\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n        // be able to support bindings in nested templates to local refs that occur after the\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n        this._nestedTemplateFns.push(() => {\n            const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n            this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n            if (templateVisitor._ngContentReservedSlots.length) {\n                this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n            }\n        });\n        // e.g. template(1, MyComp_Template_1)\n        this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n            return trimTrailingNulls(parameters);\n        });\n        // handle property bindings e.g. property('ngForOf', ctx.items), et al;\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\n        // Only add normal input/output binding instructions on explicit <ng-template> elements.\n        if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n            const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);\n            // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n            // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n            // elements, in case of inline templates, corresponding instructions will be generated in the\n            // nested template function.\n            if (i18nInputs.length > 0) {\n                this.i18nAttributesInstruction(templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);\n            }\n            // Add the input bindings\n            if (inputs.length > 0) {\n                this.templatePropertyBindings(templateIndex, inputs);\n            }\n            // Generate listeners for directive output\n            for (const outputAst of template.outputs) {\n                this.creationInstruction(outputAst.sourceSpan, Identifiers.listener, this.prepareListenerParameter('ng_template', outputAst, templateIndex));\n            }\n        }\n    }\n    visitBoundText(text) {\n        if (this.i18n) {\n            const value = text.value.visit(this._valueConverter);\n            this.allocateBindingSlots(value);\n            if (value instanceof Interpolation) {\n                this.i18n.appendBoundText(text.i18n);\n                this.i18nAppendBindings(value.expressions);\n            }\n            return;\n        }\n        const nodeIndex = this.allocateDataSlot();\n        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);\n        const value = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));\n        }\n        else {\n            error('Text nodes should be interpolated and never bound directly.');\n        }\n    }\n    visitText(text) {\n        // when a text element is located within a translatable\n        // block, we exclude this text element from instructions set,\n        // since it will be captured in i18n content and processed at runtime\n        if (!this.i18n) {\n            this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n        }\n    }\n    visitIcu(icu) {\n        let initWasInvoked = false;\n        // if an ICU was created outside of i18n block, we still treat\n        // it as a translatable entity and invoke i18nStart and i18nEnd\n        // to generate i18n context and the necessary instructions\n        if (!this.i18n) {\n            initWasInvoked = true;\n            this.i18nStart(null, icu.i18n, true);\n        }\n        const i18n = this.i18n;\n        const vars = this.i18nBindProps(icu.vars);\n        const placeholders = this.i18nBindProps(icu.placeholders);\n        // output ICU directly and keep ICU reference in context\n        const message = icu.i18n;\n        // we always need post-processing function for ICUs, to make sure that:\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n        // inside ICUs)\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n        const transformFn = (raw) => {\n            const params = { ...vars, ...placeholders };\n            const formatted = formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false);\n            return invokeInstruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n        };\n        // in case the whole i18n message is a single ICU - we do not need to\n        // create a separate top-level translation, we can use the root ref instead\n        // and make this ICU a top-level translation\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\n        if (isSingleI18nIcu(i18n.meta)) {\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n        }\n        else {\n            // output ICU directly and keep ICU reference in context\n            const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n        }\n        if (initWasInvoked) {\n            this.i18nEnd(null, true);\n        }\n        return null;\n    }\n    allocateDataSlot() {\n        return this._dataIndex++;\n    }\n    getConstCount() {\n        return this._dataIndex;\n    }\n    getVarCount() {\n        return this._pureFunctionSlots;\n    }\n    getConsts() {\n        return this._constants;\n    }\n    getNgContentSelectors() {\n        return this._ngContentReservedSlots.length ?\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n            null;\n    }\n    bindingContext() {\n        return `${this._bindingContext++}`;\n    }\n    templatePropertyBindings(templateIndex, attrs) {\n        const propertyBindings = [];\n        for (const input of attrs) {\n            if (!(input instanceof BoundAttribute)) {\n                continue;\n            }\n            const value = input.value.visit(this._valueConverter);\n            if (value === undefined) {\n                continue;\n            }\n            this.allocateBindingSlots(value);\n            if (value instanceof Interpolation) {\n                // Params typically contain attribute namespace and value sanitizer, which is applicable\n                // for regular HTML elements, but not applicable for <ng-template> (since props act as\n                // inputs to directives), so keep params array empty.\n                const params = [];\n                // prop=\"{{value}}\" case\n                this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);\n            }\n            else {\n                // [prop]=\"value\" case\n                propertyBindings.push({\n                    span: input.sourceSpan,\n                    paramsOrFn: getBindingFunctionParams(() => this.convertPropertyBinding(value), input.name)\n                });\n            }\n        }\n        for (const propertyBinding of propertyBindings) {\n            this.updateInstructionWithAdvance(templateIndex, propertyBinding.span, Identifiers.property, propertyBinding.paramsOrFn);\n        }\n    }\n    // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {\n        fns[prepend ? 'unshift' : 'push']({ span, reference, paramsOrFn });\n    }\n    processStylingUpdateInstruction(elementIndex, instruction) {\n        let allocateBindingSlots = 0;\n        if (instruction) {\n            for (const call of instruction.calls) {\n                allocateBindingSlots += call.allocateBindingSlots;\n                this.updateInstructionWithAdvance(elementIndex, call.sourceSpan, instruction.reference, () => call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                    this.getUpdateInstructionArguments(value) :\n                    this.convertPropertyBinding(value)));\n            }\n        }\n        return allocateBindingSlots;\n    }\n    creationInstruction(span, reference, paramsOrFn, prepend) {\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    }\n    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\n        this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n        this.updateInstruction(span, reference, paramsOrFn);\n    }\n    updateInstruction(span, reference, paramsOrFn) {\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    }\n    addAdvanceInstructionIfNecessary(nodeIndex, span) {\n        if (nodeIndex !== this._currentIndex) {\n            const delta = nodeIndex - this._currentIndex;\n            if (delta < 1) {\n                throw new Error('advance instruction can only go forwards');\n            }\n            this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);\n            this._currentIndex = nodeIndex;\n        }\n    }\n    allocatePureFunctionSlots(numSlots) {\n        const originalSlots = this._pureFunctionSlots;\n        this._pureFunctionSlots += numSlots;\n        return originalSlots;\n    }\n    allocateBindingSlots(value) {\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    }\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n    getImplicitReceiverExpr() {\n        if (this._implicitReceiverExpr) {\n            return this._implicitReceiverExpr;\n        }\n        return this._implicitReceiverExpr = this.level === 0 ?\n            variable(CONTEXT_NAME) :\n            this._bindingScope.getOrCreateSharedContextVar(0);\n    }\n    convertPropertyBinding(value) {\n        const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n        const valExpr = convertedPropertyBinding.currValExpr;\n        this._tempVariables.push(...convertedPropertyBinding.stmts);\n        return valExpr;\n    }\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n    getUpdateInstructionArguments(value) {\n        const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n        this._tempVariables.push(...stmts);\n        return args;\n    }\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {\n        const alreadySeen = new Set();\n        const attrExprs = [];\n        let ngProjectAsAttr;\n        for (const attr of renderAttributes) {\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n                ngProjectAsAttr = attr;\n            }\n            // Note that static i18n attributes aren't in the i18n array,\n            // because they're treated in the same way as regular attributes.\n            if (attr.i18n) {\n                // When i18n attributes are present on elements with structural directives\n                // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n                // duplicate i18n translation blocks for `template` and `element` instruction\n                // attributes. So we do a cache lookup to see if suitable i18n translation block\n                // already exists.\n                const { i18nVarRefsCache } = this._constants;\n                let i18nVarRef;\n                if (i18nVarRefsCache.has(attr.i18n)) {\n                    i18nVarRef = i18nVarRefsCache.get(attr.i18n);\n                }\n                else {\n                    i18nVarRef = this.i18nTranslate(attr.i18n);\n                    i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n                }\n                attrExprs.push(literal(attr.name), i18nVarRef);\n            }\n            else {\n                attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n            }\n        }\n        // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n        // ngProjectAs marker in the attribute name slot.\n        if (ngProjectAsAttr) {\n            attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n        }\n        function addAttrExpr(key, value) {\n            if (typeof key === 'string') {\n                if (!alreadySeen.has(key)) {\n                    attrExprs.push(...getAttributeNameLiterals(key));\n                    value !== undefined && attrExprs.push(value);\n                    alreadySeen.add(key);\n                }\n            }\n            else {\n                attrExprs.push(literal(key));\n            }\n        }\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n        // as single property value cell by cell.\n        if (styles) {\n            styles.populateInitialStylingAttrs(attrExprs);\n        }\n        if (inputs.length || outputs.length) {\n            const attrsLengthBeforeInputs = attrExprs.length;\n            for (let i = 0; i < inputs.length; i++) {\n                const input = inputs[i];\n                // We don't want the animation and attribute bindings in the\n                // attributes array since they aren't used for directive matching.\n                if (input.type !== 4 /* BindingType.Animation */ && input.type !== 1 /* BindingType.Attribute */) {\n                    addAttrExpr(input.name);\n                }\n            }\n            for (let i = 0; i < outputs.length; i++) {\n                const output = outputs[i];\n                if (output.type !== 1 /* ParsedEventType.Animation */) {\n                    addAttrExpr(output.name);\n                }\n            }\n            // this is a cheap way of adding the marker only after all the input/output\n            // values have been filtered (by not including the animation ones) and added\n            // to the expressions. The marker is important because it tells the runtime\n            // code that this is where attributes without values start...\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* core.AttributeMarker.Bindings */));\n            }\n        }\n        if (templateAttrs.length) {\n            attrExprs.push(literal(4 /* core.AttributeMarker.Template */));\n            templateAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        if (boundI18nAttrs.length) {\n            attrExprs.push(literal(6 /* core.AttributeMarker.I18n */));\n            boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n        }\n        return attrExprs;\n    }\n    addToConsts(expression) {\n        if (isNull(expression)) {\n            return TYPED_NULL_EXPR;\n        }\n        const consts = this._constants.constExpressions;\n        // Try to reuse a literal that's already in the array, if possible.\n        for (let i = 0; i < consts.length; i++) {\n            if (consts[i].isEquivalent(expression)) {\n                return literal(i);\n            }\n        }\n        return literal(consts.push(expression) - 1);\n    }\n    addAttrsToConsts(attrs) {\n        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    }\n    prepareRefsArray(references) {\n        if (!references || references.length === 0) {\n            return TYPED_NULL_EXPR;\n        }\n        const refsParam = references.flatMap(reference => {\n            const slot = this.allocateDataSlot();\n            // Generate the update temporary.\n            const variableName = this._bindingScope.freshReferenceName();\n            const retrievalLevel = this.level;\n            const lhs = variable(variableName);\n            this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DeclarationPriority.DEFAULT */, (scope, relativeLevel) => {\n                // e.g. nextContext(2);\n                const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n                // e.g. const $foo$ = reference(1);\n                const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));\n                return nextContextStmt.concat(refExpr.toConstDecl());\n            }, true);\n            return [reference.name, reference.value];\n        });\n        return asLiteral(refsParam);\n    }\n    prepareListenerParameter(tagName, outputAst, index) {\n        return () => {\n            const eventName = outputAst.name;\n            const bindingFnName = outputAst.type === 1 /* ParsedEventType.Animation */ ?\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\n                sanitizeIdentifier(eventName);\n            const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n            const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\n        };\n    }\n}\nclass ValueConverter extends AstMemoryEfficientTransformer {\n    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n        super();\n        this.constantPool = constantPool;\n        this.allocateSlot = allocateSlot;\n        this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n        this.definePipe = definePipe;\n        this._pipeBindExprs = [];\n    }\n    // AstMemoryEfficientTransformer\n    visitPipe(pipe, context) {\n        // Allocate a slot to create the pipe\n        const slot = this.allocateSlot();\n        const slotPseudoLocal = `PIPE:${slot}`;\n        // Allocate one slot for the result plus one slot per pipe argument\n        const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n        const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n        const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n        const args = [pipe.exp, ...pipe.args];\n        const convertedArgs = isVarLength ?\n            this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n            this.visitAll(args);\n        const pipeBindExpr = new Call(pipe.span, pipe.sourceSpan, target, [\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n            ...convertedArgs,\n        ], null);\n        this._pipeBindExprs.push(pipeBindExpr);\n        return pipeBindExpr;\n    }\n    updatePipeSlotOffsets(bindingSlots) {\n        this._pipeBindExprs.forEach((pipe) => {\n            // update the slot offset arg (index 1) to account for binding slots\n            const slotOffset = pipe.args[1];\n            slotOffset.value += bindingSlots;\n        });\n    }\n    visitLiteralArray(array, context) {\n        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n            // If the literal has calculated (non-literal) elements transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalArr(values);\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n    visitLiteralMap(map, context) {\n        return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n            // If the literal has calculated (non-literal) elements  transform it into\n            // calls to literal factories that compose the literal and will cache intermediate\n            // values.\n            const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n    }\n}\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\nfunction pipeBindingCallInfo(args) {\n    const identifier = pipeBindingIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers.pipeBindV,\n        isVarLength: !identifier,\n    };\n}\nconst pureFunctionIdentifiers = [\n    Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4,\n    Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8\n];\nfunction pureFunctionCallInfo(args) {\n    const identifier = pureFunctionIdentifiers[args.length];\n    return {\n        identifier: identifier || Identifiers.pureFunctionV,\n        isVarLength: !identifier,\n    };\n}\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff) {\n    return importExpr(Identifiers.nextContext)\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);\n    // Allocate 1 slot for the result plus 1 per argument\n    const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n    const args = [literal(startSlot), literalFactory];\n    if (isVarLength) {\n        args.push(literalArr(literalFactoryArguments));\n    }\n    else {\n        args.push(...literalFactoryArguments);\n    }\n    return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name) {\n    const [attributeNamespace, attributeName] = splitNsName(name);\n    const nameLiteral = literal(attributeName);\n    if (attributeNamespace) {\n        return [\n            literal(0 /* core.AttributeMarker.NamespaceURI */), literal(attributeNamespace), nameLiteral\n        ];\n    }\n    return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\nclass BindingScope {\n    static createRootScope() {\n        return new BindingScope();\n    }\n    constructor(bindingLevel = 0, parent = null, globals) {\n        this.bindingLevel = bindingLevel;\n        this.parent = parent;\n        this.globals = globals;\n        /** Keeps a map from local variables to their BindingData. */\n        this.map = new Map();\n        this.referenceNameIndex = 0;\n        this.restoreViewVariable = null;\n        this.usesRestoredViewContext = false;\n        if (globals !== undefined) {\n            for (const name of globals) {\n                this.set(0, name, variable(name));\n            }\n        }\n    }\n    get(name) {\n        let current = this;\n        while (current) {\n            let value = current.map.get(name);\n            if (value != null) {\n                if (current !== this) {\n                    // make a local copy and reset the `declare` state\n                    value = {\n                        retrievalLevel: value.retrievalLevel,\n                        lhs: value.lhs,\n                        declareLocalCallback: value.declareLocalCallback,\n                        declare: false,\n                        priority: value.priority\n                    };\n                    // Cache the value locally.\n                    this.map.set(name, value);\n                    // Possibly generate a shared context var\n                    this.maybeGenerateSharedContextVar(value);\n                    this.maybeRestoreView();\n                }\n                if (value.declareLocalCallback && !value.declare) {\n                    value.declare = true;\n                }\n                return value.lhs;\n            }\n            current = current.parent;\n        }\n        // If we get to this point, we are looking for a property on the top level component\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n        // local var we used to store the component context, e.g. const $comp$ = x();\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    }\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n    set(retrievalLevel, name, lhs, priority = 0 /* DeclarationPriority.DEFAULT */, declareLocalCallback, localRef) {\n        if (this.map.has(name)) {\n            if (localRef) {\n                // Do not throw an error if it's a local ref and do not update existing value,\n                // so the first defined ref is always returned.\n                return this;\n            }\n            error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n        }\n        this.map.set(name, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declare: false,\n            declareLocalCallback: declareLocalCallback,\n            priority: priority,\n        });\n        return this;\n    }\n    // Implemented as part of LocalResolver.\n    getLocal(name) {\n        return this.get(name);\n    }\n    // Implemented as part of LocalResolver.\n    notifyImplicitReceiverUse() {\n        if (this.bindingLevel !== 0) {\n            // Since the implicit receiver is accessed in an embedded view, we need to\n            // ensure that we declare a shared context variable for the current template\n            // in the update variables.\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n        }\n    }\n    nestedScope(level, globals) {\n        const newScope = new BindingScope(level, this, globals);\n        if (level > 0)\n            newScope.generateSharedContextVar(0);\n        return newScope;\n    }\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n    getOrCreateSharedContextVar(retrievalLevel) {\n        const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n        if (!this.map.has(bindingKey)) {\n            this.generateSharedContextVar(retrievalLevel);\n        }\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return this.map.get(bindingKey).lhs;\n    }\n    getSharedContextName(retrievalLevel) {\n        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n        // Shared context variables are always generated as \"ReadVarExpr\".\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    }\n    maybeGenerateSharedContextVar(value) {\n        if (value.priority === 1 /* DeclarationPriority.CONTEXT */ &&\n            value.retrievalLevel < this.bindingLevel) {\n            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n            if (sharedCtxObj) {\n                sharedCtxObj.declare = true;\n            }\n            else {\n                this.generateSharedContextVar(value.retrievalLevel);\n            }\n        }\n    }\n    generateSharedContextVar(retrievalLevel) {\n        const lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n            retrievalLevel: retrievalLevel,\n            lhs: lhs,\n            declareLocalCallback: (scope, relativeLevel) => {\n                // const ctx_r0 = nextContext(2);\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n            },\n            declare: false,\n            priority: 2 /* DeclarationPriority.SHARED_CONTEXT */,\n        });\n    }\n    getComponentProperty(name) {\n        const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n        componentValue.declare = true;\n        this.maybeRestoreView();\n        return componentValue.lhs.prop(name);\n    }\n    maybeRestoreView() {\n        // View restoration is required for listener instructions inside embedded views, because\n        // they only run in creation mode and they can have references to the context object.\n        // If the context object changes in update mode, the reference will be incorrect, because\n        // it was established during creation.\n        if (this.isListenerScope()) {\n            if (!this.parent.restoreViewVariable) {\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n            }\n            this.restoreViewVariable = this.parent.restoreViewVariable;\n        }\n    }\n    restoreViewStatement() {\n        if (this.restoreViewVariable) {\n            const restoreCall = invokeInstruction(null, Identifiers.restoreView, [this.restoreViewVariable]);\n            // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n            // depending on whether it is being used.\n            return this.usesRestoredViewContext ?\n                variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\n                restoreCall.toStmt();\n        }\n        return null;\n    }\n    viewSnapshotStatements() {\n        // const $state$ = getCurrentView();\n        return this.restoreViewVariable ?\n            [\n                this.restoreViewVariable.set(invokeInstruction(null, Identifiers.getCurrentView, [])).toConstDecl()\n            ] :\n            [];\n    }\n    isListenerScope() {\n        return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    }\n    variableDeclarations() {\n        let currentContextLevel = 0;\n        return Array.from(this.map.values())\n            .filter(value => value.declare)\n            .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n            .reduce((stmts, value) => {\n            const levelDiff = this.bindingLevel - value.retrievalLevel;\n            const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);\n            currentContextLevel = levelDiff;\n            return stmts.concat(currStmts);\n        }, []);\n    }\n    freshReferenceName() {\n        let current = this;\n        // Find the top scope as it maintains the global reference count\n        while (current.parent)\n            current = current.parent;\n        const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n        return ref;\n    }\n    hasRestoreViewVariable() {\n        return !!this.restoreViewVariable;\n    }\n    notifyRestoredViewContextUse() {\n        this.usesRestoredViewContext = true;\n    }\n}\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nfunction createCssSelector(elementName, attributes) {\n    const cssSelector = new CssSelector();\n    const elementNameNoNs = splitNsName(elementName)[1];\n    cssSelector.setElement(elementNameNoNs);\n    Object.getOwnPropertyNames(attributes).forEach((name) => {\n        const nameNoNs = splitNsName(name)[1];\n        const value = attributes[name];\n        cssSelector.addAttribute(nameNoNs, value);\n        if (name.toLowerCase() === 'class') {\n            const classes = value.trim().split(/\\s+/);\n            classes.forEach(className => cssSelector.addClassName(className));\n        }\n    });\n    return cssSelector;\n}\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n    return [literal(5 /* core.AttributeMarker.ProjectAs */), asLiteral(parsedR3Selector)];\n}\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.propertyInterpolate;\n        case 3:\n            return Identifiers.propertyInterpolate1;\n        case 5:\n            return Identifiers.propertyInterpolate2;\n        case 7:\n            return Identifiers.propertyInterpolate3;\n        case 9:\n            return Identifiers.propertyInterpolate4;\n        case 11:\n            return Identifiers.propertyInterpolate5;\n        case 13:\n            return Identifiers.propertyInterpolate6;\n        case 15:\n            return Identifiers.propertyInterpolate7;\n        case 17:\n            return Identifiers.propertyInterpolate8;\n        default:\n            return Identifiers.propertyInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 3:\n            return Identifiers.attributeInterpolate1;\n        case 5:\n            return Identifiers.attributeInterpolate2;\n        case 7:\n            return Identifiers.attributeInterpolate3;\n        case 9:\n            return Identifiers.attributeInterpolate4;\n        case 11:\n            return Identifiers.attributeInterpolate5;\n        case 13:\n            return Identifiers.attributeInterpolate6;\n        case 15:\n            return Identifiers.attributeInterpolate7;\n        case 17:\n            return Identifiers.attributeInterpolate8;\n        default:\n            return Identifiers.attributeInterpolateV;\n    }\n}\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation) {\n    switch (getInterpolationArgsLength(interpolation)) {\n        case 1:\n            return Identifiers.textInterpolate;\n        case 3:\n            return Identifiers.textInterpolate1;\n        case 5:\n            return Identifiers.textInterpolate2;\n        case 7:\n            return Identifiers.textInterpolate3;\n        case 9:\n            return Identifiers.textInterpolate4;\n        case 11:\n            return Identifiers.textInterpolate5;\n        case 13:\n            return Identifiers.textInterpolate6;\n        case 15:\n            return Identifiers.textInterpolate7;\n        case 17:\n            return Identifiers.textInterpolate8;\n        default:\n            return Identifiers.textInterpolateV;\n    }\n}\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nfunction parseTemplate(template, templateUrl, options = {}) {\n    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;\n    const bindingParser = makeBindingParser(interpolationConfig);\n    const htmlParser = new HtmlParser();\n    const parseResult = htmlParser.parse(template, templateUrl, { leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true });\n    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n        parseResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: parseResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    let rootNodes = parseResult.rootNodes;\n    // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng extract-i18n) relies on a raw content to generate\n    // message ids\n    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n        i18nMetaResult.errors.length > 0) {\n        const parsedTemplate = {\n            interpolationConfig,\n            preserveWhitespaces,\n            errors: i18nMetaResult.errors,\n            nodes: [],\n            styleUrls: [],\n            styles: [],\n            ngContentSelectors: []\n        };\n        if (options.collectCommentNodes) {\n            parsedTemplate.commentNodes = [];\n        }\n        return parsedTemplate;\n    }\n    rootNodes = i18nMetaResult.rootNodes;\n    if (!preserveWhitespaces) {\n        rootNodes = visitAll(new WhitespaceVisitor(), rootNodes);\n        // run i18n meta visitor again in case whitespaces are removed (because that might affect\n        // generated i18n message content) and first pass indicated that i18n content is present in a\n        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n        // mimic existing extraction process (ng extract-i18n)\n        if (i18nMetaVisitor.hasI18nMeta) {\n            rootNodes = visitAll(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n        }\n    }\n    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });\n    errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n    const parsedTemplate = {\n        interpolationConfig,\n        preserveWhitespaces,\n        errors: errors.length > 0 ? errors : null,\n        nodes,\n        styleUrls,\n        styles,\n        ngContentSelectors\n    };\n    if (options.collectCommentNodes) {\n        parsedTemplate.commentNodes = commentNodes;\n    }\n    return parsedTemplate;\n}\nconst elementRegistry = new DomElementSchemaRegistry();\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nfunction makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    return new BindingParser(new Parser$1(new Lexer()), interpolationConfig, elementRegistry, []);\n}\nfunction resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n        case SecurityContext.HTML:\n            return importExpr(Identifiers.sanitizeHtml);\n        case SecurityContext.SCRIPT:\n            return importExpr(Identifiers.sanitizeScript);\n        case SecurityContext.STYLE:\n            // the compiler does not fill in an instruction for [style.prop?] binding\n            // values because the style algorithm knows internally what props are subject\n            // to sanitization (only [attr.style] values are explicitly sanitized)\n            return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;\n        case SecurityContext.URL:\n            return importExpr(Identifiers.sanitizeUrl);\n        case SecurityContext.RESOURCE_URL:\n            return importExpr(Identifiers.sanitizeResourceUrl);\n        default:\n            return null;\n    }\n}\nfunction trustedConstAttribute(tagName, attr) {\n    const value = asLiteral(attr.value);\n    if (isTrustedTypesSink(tagName, attr.name)) {\n        switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n            case SecurityContext.HTML:\n                return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n            case SecurityContext.RESOURCE_URL:\n                return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n            default:\n                return value;\n        }\n    }\n    else {\n        return value;\n    }\n}\nfunction isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof Element$1;\n}\nfunction isTextNode(node) {\n    return node instanceof Text$3 || node instanceof BoundText || node instanceof Icu$1;\n}\nfunction isIframeElement(tagName) {\n    return tagName.toLowerCase() === 'iframe';\n}\nfunction hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n}\nfunction getBindingFunctionParams(deferredParams, name, eagerParams) {\n    return () => {\n        const value = deferredParams();\n        const fnParams = Array.isArray(value) ? value : [value];\n        if (eagerParams) {\n            fnParams.push(...eagerParams);\n        }\n        if (name) {\n            // We want the property name to always be the first function parameter.\n            fnParams.unshift(literal(name));\n        }\n        return fnParams;\n    };\n}\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nfunction getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {\n    const statements = [\n        declareI18nVariable(variable),\n        ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, params), createLocalizeStatements(variable, message, formatI18nPlaceholderNamesInMap(params, /* useCamelCase */ false))),\n    ];\n    if (transformFn) {\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n    }\n    return statements;\n}\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard() {\n    return typeofExpr(variable(NG_I18N_CLOSURE_MODE))\n        .notIdentical(literal('undefined', STRING_TYPE))\n        .and(variable(NG_I18N_CLOSURE_MODE));\n}\n\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\nconst COMPONENT_VARIABLE = '%COMP%';\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n    const definitionMap = new DefinitionMap();\n    const selectors = parseSelectorToR3Selector(meta.selector);\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    // e.g. `selectors: [['', 'someDir', '']]`\n    if (selectors.length > 0) {\n        definitionMap.set('selectors', asLiteral(selectors));\n    }\n    if (meta.queries.length > 0) {\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n    if (meta.viewQueries.length) {\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    }\n    // e.g. `hostBindings: (rf, ctx) => { ... }\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\n    // e.g 'inputs: {a: 'a'}`\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    // e.g 'outputs: {a: 'a'}`\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\n    }\n    if (meta.isStandalone) {\n        definitionMap.set('standalone', literal(true));\n    }\n    return definitionMap;\n}\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature]`\n    const features = [];\n    const providers = meta.providers;\n    const viewProviders = meta.viewProviders;\n    if (providers || viewProviders) {\n        const args = [providers || new LiteralArrayExpr([])];\n        if (viewProviders) {\n            args.push(viewProviders);\n        }\n        features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n    }\n    if (meta.usesInheritance) {\n        features.push(importExpr(Identifiers.InheritDefinitionFeature));\n    }\n    if (meta.fullInheritance) {\n        features.push(importExpr(Identifiers.CopyDefinitionFeature));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        features.push(importExpr(Identifiers.NgOnChangesFeature));\n    }\n    // TODO: better way of differentiating component vs directive metadata.\n    if (meta.hasOwnProperty('template') && meta.isStandalone) {\n        features.push(importExpr(Identifiers.StandaloneFeature));\n    }\n    if (meta.hostDirectives?.length) {\n        features.push(importExpr(Identifiers.HostDirectivesFeature).callFn([createHostDirectivesFeatureArg(meta.hostDirectives)]));\n    }\n    if (features.length) {\n        definitionMap.set('features', literalArr(features));\n    }\n}\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    const selector = meta.selector && CssSelector.parse(meta.selector);\n    const firstSelector = selector && selector[0];\n    // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n    if (firstSelector) {\n        const selectorAttributes = firstSelector.getAttrs();\n        if (selectorAttributes.length) {\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), \n            /* forceShared */ true));\n        }\n    }\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n    const templateTypeName = meta.name;\n    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n    const changeDetection = meta.changeDetection;\n    const template = meta.template;\n    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n    // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n    const ngContentSelectors = templateBuilder.getNgContentSelectors();\n    if (ngContentSelectors) {\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\n    }\n    // e.g. `decls: 2`\n    definitionMap.set('decls', literal(templateBuilder.getConstCount()));\n    // e.g. `vars: 2`\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\n    // Generate `consts` section of ComponentDef:\n    // - either as an array:\n    //   `consts: [['one', 'two'], ['three', 'four']]`\n    // - or as a factory function in case additional statements are present (to support i18n):\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n    const { constExpressions, prepareStatements } = templateBuilder.getConsts();\n    if (constExpressions.length > 0) {\n        let constsExpr = literalArr(constExpressions);\n        // Prepare statements are present - turn `consts` into a function.\n        if (prepareStatements.length > 0) {\n            constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);\n        }\n        definitionMap.set('consts', constsExpr);\n    }\n    definitionMap.set('template', templateFunctionExpression);\n    if (meta.declarations.length > 0) {\n        definitionMap.set('dependencies', compileDeclarationList(literalArr(meta.declarations.map(decl => decl.type)), meta.declarationListEmitMode));\n    }\n    if (meta.encapsulation === null) {\n        meta.encapsulation = ViewEncapsulation.Emulated;\n    }\n    // e.g. `styles: [str1, str2]`\n    if (meta.styles && meta.styles.length) {\n        const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n            meta.styles;\n        const styleNodes = styleValues.reduce((result, style) => {\n            if (style.trim().length > 0) {\n                result.push(constantPool.getConstLiteral(literal(style)));\n            }\n            return result;\n        }, []);\n        if (styleNodes.length > 0) {\n            definitionMap.set('styles', literalArr(styleNodes));\n        }\n    }\n    else if (meta.encapsulation === ViewEncapsulation.Emulated) {\n        // If there is no style, don't generate css selectors on elements\n        meta.encapsulation = ViewEncapsulation.None;\n    }\n    // Only set view encapsulation if it's not the default value\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\n    }\n    // e.g. `animation: [trigger('123', [])]`\n    if (meta.animations !== null) {\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\n    }\n    // Only set the change detection flag if it's defined and it's not the default.\n    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\n        definitionMap.set('changeDetection', literal(changeDetection));\n    }\n    const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createComponentType(meta) {\n    const typeParams = createBaseDirectiveTypeParams(meta);\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n    typeParams.push(expressionType(literal(meta.isStandalone)));\n    typeParams.push(createHostDirectivesType(meta));\n    return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(list, mode) {\n    switch (mode) {\n        case 0 /* DeclarationListEmitMode.Direct */:\n            // directives: [MyDir],\n            return list;\n        case 1 /* DeclarationListEmitMode.Closure */:\n            // directives: function () { return [MyDir]; }\n            return fn([], [new ReturnStatement(list)]);\n        case 2 /* DeclarationListEmitMode.ClosureResolved */:\n            // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n            const resolvedList = list.prop('map').callFn([importExpr(Identifiers.resolveForwardRef)]);\n            return fn([], [new ReturnStatement(resolvedList)]);\n    }\n}\nfunction prepareQueryParams(query, constantPool) {\n    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];\n    if (query.read) {\n        parameters.push(query.read);\n    }\n    return parameters;\n}\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query) {\n    return (query.descendants ? 1 /* QueryFlags.descendants */ : 0 /* QueryFlags.none */) |\n        (query.static ? 2 /* QueryFlags.isStatic */ : 0 /* QueryFlags.none */) |\n        (query.emitDistinctChangesOnly ? 4 /* QueryFlags.emitDistinctChangesOnly */ : 0 /* QueryFlags.none */);\n}\nfunction convertAttributesToExpressions(attributes) {\n    const values = [];\n    for (let key of Object.getOwnPropertyNames(attributes)) {\n        const value = attributes[key];\n        values.push(literal(key), value);\n    }\n    return values;\n}\n// Define and update any content queries\nfunction createContentQueriesFunction(queries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    for (const query of queries) {\n        // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n        createStatements.push(importExpr(Identifiers.contentQuery)\n            .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])\n            .toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    }\n    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n    return fn([\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\n        new FnParam('dirIndex', null)\n    ], [\n        renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateStatements)\n    ], INFERRED_TYPE, null, contentQueriesFnName);\n}\nfunction stringAsType(str) {\n    return expressionType(literal(str));\n}\nfunction stringMapAsLiteralExpression(map) {\n    const mapValues = Object.keys(map).map(key => {\n        const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n        return {\n            key,\n            value: literal(value),\n            quoted: true,\n        };\n    });\n    return literalMap(mapValues);\n}\nfunction stringArrayAsType(arr) {\n    return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :\n        NONE_TYPE;\n}\nfunction createBaseDirectiveTypeParams(meta) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n    return [\n        typeWithParameters(meta.type.type, meta.typeArgumentCount),\n        selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\n        expressionType(stringMapAsLiteralExpression(meta.inputs)),\n        expressionType(stringMapAsLiteralExpression(meta.outputs)),\n        stringArrayAsType(meta.queries.map(q => q.propertyName)),\n    ];\n}\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nfunction createDirectiveType(meta) {\n    const typeParams = createBaseDirectiveTypeParams(meta);\n    // Directives have no NgContentSelectors slot, but instead express a `never` type\n    // so that future fields align.\n    typeParams.push(NONE_TYPE);\n    typeParams.push(expressionType(literal(meta.isStandalone)));\n    typeParams.push(createHostDirectivesType(meta));\n    return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n}\n// Define and update any view queries\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n    const createStatements = [];\n    const updateStatements = [];\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n    viewQueries.forEach((query) => {\n        // creation, e.g. r3.viewQuery(somePredicate, true);\n        const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));\n        createStatements.push(queryDefinition.toStmt());\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n        const temporary = tempAllocator();\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n        const updateDirective = variable(CONTEXT_NAME)\n            .prop(query.propertyName)\n            .set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    const viewQueryFnName = name ? `${name}_Query` : null;\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\n        renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, createStatements),\n        renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateStatements)\n    ], INFERRED_TYPE, null, viewQueryFnName);\n}\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n    const bindingContext = variable(CONTEXT_NAME);\n    const styleBuilder = new StylingBuilder(bindingContext);\n    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;\n    if (styleAttr !== undefined) {\n        styleBuilder.registerStyleAttr(styleAttr);\n    }\n    if (classAttr !== undefined) {\n        styleBuilder.registerClassAttr(classAttr);\n    }\n    const createInstructions = [];\n    const updateInstructions = [];\n    const updateVariables = [];\n    const hostBindingSourceSpan = typeSourceSpan;\n    // Calculate host event bindings\n    const eventBindings = bindingParser.createDirectiveHostEventAsts(hostBindingsMetadata.listeners, hostBindingSourceSpan);\n    if (eventBindings && eventBindings.length) {\n        createInstructions.push(...createHostListeners(eventBindings, name));\n    }\n    // Calculate the host property bindings\n    const bindings = bindingParser.createBoundHostProperties(hostBindingsMetadata.properties, hostBindingSourceSpan);\n    const allOtherBindings = [];\n    // We need to calculate the total amount of binding slots required by\n    // all the instructions together before any value conversions happen.\n    // Value conversions may require additional slots for interpolation and\n    // bindings with pipes. These calculates happen after this block.\n    let totalHostVarsCount = 0;\n    bindings && bindings.forEach((binding) => {\n        const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\n        if (stylingInputWasSet) {\n            totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n        }\n        else {\n            allOtherBindings.push(binding);\n            totalHostVarsCount++;\n        }\n    });\n    let valueConverter;\n    const getValueConverter = () => {\n        if (!valueConverter) {\n            const hostVarsCountFn = (numSlots) => {\n                const originalVarsCount = totalHostVarsCount;\n                totalHostVarsCount += numSlots;\n                return originalVarsCount;\n            };\n            valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here\n            hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here\n        }\n        return valueConverter;\n    };\n    const propertyBindings = [];\n    const attributeBindings = [];\n    const syntheticHostBindings = [];\n    for (const binding of allOtherBindings) {\n        // resolve literal arrays and literal objects\n        const value = binding.expression.visit(getValueConverter());\n        const bindingExpr = bindingFn(bindingContext, value);\n        const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);\n        const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== SecurityContext.NONE);\n        let sanitizerFn = null;\n        if (securityContexts.length) {\n            if (securityContexts.length === 2 &&\n                securityContexts.indexOf(SecurityContext.URL) > -1 &&\n                securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n                // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n                // of different security contexts. In this case we use special sanitization function and\n                // select the actual sanitizer at runtime based on a tag name that is provided while\n                // invoking sanitization function.\n                sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);\n            }\n            else {\n                sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n            }\n        }\n        const instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n        if (sanitizerFn) {\n            instructionParams.push(sanitizerFn);\n        }\n        else {\n            // If there was no sanitization function found based on the security context\n            // of an attribute/property binding - check whether this attribute/property is\n            // one of the security-sensitive <iframe> attributes.\n            // Note: for host bindings defined on a directive, we do not try to find all\n            // possible places where it can be matched, so we can not determine whether\n            // the host element is an <iframe>. In this case, if an attribute/binding\n            // name is in the `IFRAME_SECURITY_SENSITIVE_ATTRS` set - append a validation\n            // function, which would be invoked at runtime and would have access to the\n            // underlying DOM element, check if it's an <iframe> and if so - runs extra checks.\n            if (isIframeSecuritySensitiveAttr(bindingName)) {\n                instructionParams.push(importExpr(Identifiers.validateIframeAttribute));\n            }\n        }\n        updateVariables.push(...bindingExpr.stmts);\n        if (instruction === Identifiers.hostProperty) {\n            propertyBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers.attribute) {\n            attributeBindings.push(instructionParams);\n        }\n        else if (instruction === Identifiers.syntheticHostProperty) {\n            syntheticHostBindings.push(instructionParams);\n        }\n        else {\n            updateInstructions.push({ reference: instruction, paramsOrFn: instructionParams, span: null });\n        }\n    }\n    for (const bindingParams of propertyBindings) {\n        updateInstructions.push({ reference: Identifiers.hostProperty, paramsOrFn: bindingParams, span: null });\n    }\n    for (const bindingParams of attributeBindings) {\n        updateInstructions.push({ reference: Identifiers.attribute, paramsOrFn: bindingParams, span: null });\n    }\n    for (const bindingParams of syntheticHostBindings) {\n        updateInstructions.push({ reference: Identifiers.syntheticHostProperty, paramsOrFn: bindingParams, span: null });\n    }\n    // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n    if (styleBuilder.hasBindings) {\n        // finally each binding that was registered in the statement above will need to be added to\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n        // are evaluated and updated for the element.\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n            for (const call of instruction.calls) {\n                // we subtract a value of `1` here because the binding slot was already allocated\n                // at the top of this method when all the input bindings were counted.\n                totalHostVarsCount +=\n                    Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n                updateInstructions.push({\n                    reference: instruction.reference,\n                    paramsOrFn: convertStylingCall(call, bindingContext, bindingFn),\n                    span: null\n                });\n            }\n        });\n    }\n    if (totalHostVarsCount) {\n        definitionMap.set('hostVars', literal(totalHostVarsCount));\n    }\n    if (createInstructions.length > 0 || updateInstructions.length > 0) {\n        const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n        const statements = [];\n        if (createInstructions.length > 0) {\n            statements.push(renderFlagCheckIfStmt(1 /* core.RenderFlags.Create */, getInstructionStatements(createInstructions)));\n        }\n        if (updateInstructions.length > 0) {\n            statements.push(renderFlagCheckIfStmt(2 /* core.RenderFlags.Update */, updateVariables.concat(getInstructionStatements(updateInstructions))));\n        }\n        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\n    }\n    return null;\n}\nfunction bindingFn(implicit, value) {\n    return convertPropertyBinding(null, implicit, value, 'b');\n}\nfunction convertStylingCall(call, bindingContext, bindingFn) {\n    return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\nfunction getBindingNameAndInstruction(binding) {\n    let bindingName = binding.name;\n    let instruction;\n    // Check to see if this is an attr binding or a property binding\n    const attrMatches = bindingName.match(ATTR_REGEX);\n    if (attrMatches) {\n        bindingName = attrMatches[1];\n        instruction = Identifiers.attribute;\n    }\n    else {\n        if (binding.isAnimation) {\n            bindingName = prepareSyntheticPropertyName(bindingName);\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n            // in the context of the component and not the parent. Therefore there is a special\n            // compatibility instruction available for this purpose.\n            instruction = Identifiers.syntheticHostProperty;\n        }\n        else {\n            instruction = Identifiers.hostProperty;\n        }\n    }\n    return { bindingName, instruction, isAttribute: !!attrMatches };\n}\nfunction createHostListeners(eventBindings, name) {\n    const listenerParams = [];\n    const syntheticListenerParams = [];\n    const instructions = [];\n    for (const binding of eventBindings) {\n        let bindingName = binding.name && sanitizeIdentifier(binding.name);\n        const bindingFnName = binding.type === 1 /* ParsedEventType.Animation */ ?\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n            bindingName;\n        const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n        const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n        if (binding.type == 1 /* ParsedEventType.Animation */) {\n            syntheticListenerParams.push(params);\n        }\n        else {\n            listenerParams.push(params);\n        }\n    }\n    for (const params of syntheticListenerParams) {\n        instructions.push({ reference: Identifiers.syntheticHostListener, paramsOrFn: params, span: null });\n    }\n    for (const params of listenerParams) {\n        instructions.push({ reference: Identifiers.listener, paramsOrFn: params, span: null });\n    }\n    return instructions;\n}\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\nfunction parseHostBindings(host) {\n    const attributes = {};\n    const listeners = {};\n    const properties = {};\n    const specialAttributes = {};\n    for (const key of Object.keys(host)) {\n        const value = host[key];\n        const matches = key.match(HOST_REG_EXP);\n        if (matches === null) {\n            switch (key) {\n                case 'class':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Class binding must be string`);\n                    }\n                    specialAttributes.classAttr = value;\n                    break;\n                case 'style':\n                    if (typeof value !== 'string') {\n                        // TODO(alxhub): make this a diagnostic.\n                        throw new Error(`Style binding must be string`);\n                    }\n                    specialAttributes.styleAttr = value;\n                    break;\n                default:\n                    if (typeof value === 'string') {\n                        attributes[key] = literal(value);\n                    }\n                    else {\n                        attributes[key] = value;\n                    }\n            }\n        }\n        else if (matches[1 /* HostBindingGroup.Binding */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Property binding must be string`);\n            }\n            // synthetic properties (the ones that have a `@` as a prefix)\n            // are still treated the same as regular properties. Therefore\n            // there is no point in storing them in a separate map.\n            properties[matches[1 /* HostBindingGroup.Binding */]] = value;\n        }\n        else if (matches[2 /* HostBindingGroup.Event */] != null) {\n            if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(`Event binding must be string`);\n            }\n            listeners[matches[2 /* HostBindingGroup.Event */]] = value;\n        }\n    }\n    return { attributes, listeners, properties, specialAttributes };\n}\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nfunction verifyHostBindings(bindings, sourceSpan) {\n    // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n    const bindingParser = makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(bindings.listeners, sourceSpan);\n    bindingParser.createBoundHostProperties(bindings.properties, sourceSpan);\n    return bindingParser.errors;\n}\nfunction compileStyles(styles, selector, hostSelector) {\n    const shadowCss = new ShadowCss();\n    return styles.map(style => {\n        return shadowCss.shimCssText(style, selector, hostSelector);\n    });\n}\nfunction createHostDirectivesType(meta) {\n    if (!meta.hostDirectives?.length) {\n        return NONE_TYPE;\n    }\n    return expressionType(literalArr(meta.hostDirectives.map(hostMeta => literalMap([\n        { key: 'directive', value: typeofExpr(hostMeta.directive.type), quoted: false },\n        { key: 'inputs', value: stringMapAsLiteralExpression(hostMeta.inputs || {}), quoted: false },\n        { key: 'outputs', value: stringMapAsLiteralExpression(hostMeta.outputs || {}), quoted: false },\n    ]))));\n}\nfunction createHostDirectivesFeatureArg(hostDirectives) {\n    const expressions = [];\n    let hasForwardRef = false;\n    for (const current of hostDirectives) {\n        // Use a shorthand if there are no inputs or outputs.\n        if (!current.inputs && !current.outputs) {\n            expressions.push(current.directive.type);\n        }\n        else {\n            const keys = [{ key: 'directive', value: current.directive.type, quoted: false }];\n            if (current.inputs) {\n                const inputsLiteral = createHostDirectivesMappingArray(current.inputs);\n                if (inputsLiteral) {\n                    keys.push({ key: 'inputs', value: inputsLiteral, quoted: false });\n                }\n            }\n            if (current.outputs) {\n                const outputsLiteral = createHostDirectivesMappingArray(current.outputs);\n                if (outputsLiteral) {\n                    keys.push({ key: 'outputs', value: outputsLiteral, quoted: false });\n                }\n            }\n            expressions.push(literalMap(keys));\n        }\n        if (current.isForwardReference) {\n            hasForwardRef = true;\n        }\n    }\n    // If there's a forward reference, we generate a `function() { return [HostDir] }`,\n    // otherwise we can save some bytes by using a plain array, e.g. `[HostDir]`.\n    return hasForwardRef ?\n        new FunctionExpr([], [new ReturnStatement(literalArr(expressions))]) :\n        literalArr(expressions);\n}\n/**\n * Converts an input/output mapping object literal into an array where the even keys are the\n * public name of the binding and the odd ones are the name it was aliased to. E.g.\n * `{inputOne: 'aliasOne', inputTwo: 'aliasTwo'}` will become\n * `['inputOne', 'aliasOne', 'inputTwo', 'aliasTwo']`.\n *\n * This conversion is necessary, because hosts bind to the public name of the host directive and\n * keeping the mapping in an object literal will break for apps using property renaming.\n */\nfunction createHostDirectivesMappingArray(mapping) {\n    const elements = [];\n    for (const publicName in mapping) {\n        if (mapping.hasOwnProperty(publicName)) {\n            elements.push(literal(publicName), literal(mapping[publicName]));\n        }\n    }\n    return elements.length > 0 ? literalArr(elements) : null;\n}\n\n/**\n * An interface for retrieving documents by URL that the compiler uses to\n * load templates.\n *\n * This is an abstract class, rather than an interface, so that it can be used\n * as injection token.\n */\nclass ResourceLoader {\n}\n\nclass CompilerFacadeImpl {\n    constructor(jitEvaluator = new JitEvaluator()) {\n        this.jitEvaluator = jitEvaluator;\n        this.FactoryTarget = FactoryTarget$1;\n        this.ResourceLoader = ResourceLoader;\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\n    }\n    compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n        const metadata = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            deps: null,\n            pipeName: facade.pipeName,\n            pure: facade.pure,\n            isStandalone: facade.isStandalone,\n        };\n        const res = compilePipeFromMetadata(metadata);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclarePipeFacadeToMetadata(declaration);\n        const res = compilePipeFromMetadata(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n        const { expression, statements } = compileInjectable({\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: facade.typeArgumentCount,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, 'useClass'),\n            useFactory: wrapExpression(facade, 'useFactory'),\n            useValue: convertToProviderExpression(facade, 'useValue'),\n            useExisting: convertToProviderExpression(facade, 'useExisting'),\n            deps: facade.deps?.map(convertR3DependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n        const { expression, statements } = compileInjectable({\n            name: facade.type.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            typeArgumentCount: 0,\n            providedIn: computeProvidedIn(facade.providedIn),\n            useClass: convertToProviderExpression(facade, 'useClass'),\n            useFactory: wrapExpression(facade, 'useFactory'),\n            useValue: convertToProviderExpression(facade, 'useValue'),\n            useExisting: convertToProviderExpression(facade, 'useExisting'),\n            deps: facade.deps?.map(convertR3DeclareDependencyMetadata),\n        }, \n        /* resolveForwardRefs */ true);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n    compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            name: facade.name,\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            providers: facade.providers && facade.providers.length > 0 ?\n                new WrappedNodeExpr(facade.providers) :\n                null,\n            imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n        };\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const meta = convertDeclareInjectorFacadeToMetadata(declaration);\n        const res = compileInjector(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = {\n            type: wrapReference(facade.type),\n            internalType: new WrappedNodeExpr(facade.type),\n            adjacentType: new WrappedNodeExpr(facade.type),\n            bootstrap: facade.bootstrap.map(wrapReference),\n            declarations: facade.declarations.map(wrapReference),\n            publicDeclarationTypes: null,\n            imports: facade.imports.map(wrapReference),\n            includeImportTypes: true,\n            exports: facade.exports.map(wrapReference),\n            selectorScopeMode: R3SelectorScopeMode.Inline,\n            containsForwardDecls: false,\n            schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n        };\n        const res = compileNgModule(meta);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const expression = compileNgModuleDeclarationExpression(declaration);\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n    }\n    compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n        const meta = convertDirectiveFacadeToMetadata(facade);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser();\n        const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n        // Parse the template and check for errors.\n        const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);\n        // Compile the component metadata, including template, into an expression.\n        const meta = {\n            ...facade,\n            ...convertDirectiveFacadeToMetadata(facade),\n            selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n            template,\n            declarations: facade.declarations.map(convertDeclarationFacadeToMetadata),\n            declarationListEmitMode: 0 /* DeclarationListEmitMode.Direct */,\n            styles: [...facade.styles, ...template.styles],\n            encapsulation: facade.encapsulation,\n            interpolation,\n            changeDetection: facade.changeDetection,\n            animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n            viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                null,\n            relativeContextFilePath: '',\n            i18nUseExternalIds: true,\n        };\n        const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n        return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n    }\n    compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n        const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n        const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n        return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n    compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n        const constantPool = new ConstantPool();\n        const bindingParser = makeBindingParser(meta.interpolation);\n        const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n    compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: meta.typeArgumentCount,\n            deps: convertR3DependencyMetadataArray(meta.deps),\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n        const factoryRes = compileFactoryFunction({\n            name: meta.type.name,\n            type: wrapReference(meta.type),\n            internalType: new WrappedNodeExpr(meta.type),\n            typeArgumentCount: 0,\n            deps: Array.isArray(meta.deps) ? meta.deps.map(convertR3DeclareDependencyMetadata) :\n                meta.deps,\n            target: meta.target,\n        });\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n    createParseSourceSpan(kind, typeName, sourceUrl) {\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    }\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n    jitExpression(def, context, sourceUrl, preStatements) {\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n        // declaration of $def which is set to the expression being compiled.\n        const statements = [\n            ...preStatements,\n            new DeclareVarStmt('$def', def, undefined, StmtModifier.Exported),\n        ];\n        const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n        return res['$def'];\n    }\n}\nfunction convertToR3QueryMetadata(facade) {\n    return {\n        ...facade,\n        predicate: convertQueryPredicate(facade.predicate),\n        read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n        static: facade.static,\n        emitDistinctChangesOnly: facade.emitDistinctChangesOnly,\n    };\n}\nfunction convertQueryDeclarationToMetadata(declaration) {\n    return {\n        propertyName: declaration.propertyName,\n        first: declaration.first ?? false,\n        predicate: convertQueryPredicate(declaration.predicate),\n        descendants: declaration.descendants ?? false,\n        read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n        static: declaration.static ?? false,\n        emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n    };\n}\nfunction convertQueryPredicate(predicate) {\n    return Array.isArray(predicate) ?\n        // The predicate is an array of strings so pass it through.\n        predicate :\n        // The predicate is a type - assume that we will need to unwrap any `forwardRef()` calls.\n        createMayBeForwardRefExpression(new WrappedNodeExpr(predicate), 1 /* ForwardRefHandling.Wrapped */);\n}\nfunction convertDirectiveFacadeToMetadata(facade) {\n    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    const propMetadata = facade.propMetadata;\n    const inputsFromType = {};\n    const outputsFromType = {};\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isInput(ann)) {\n                    inputsFromType[field] =\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n                }\n                else if (isOutput(ann)) {\n                    outputsFromType[field] = ann.bindingPropertyName || field;\n                }\n            });\n        }\n    }\n    return {\n        ...facade,\n        typeArgumentCount: 0,\n        typeSourceSpan: facade.typeSourceSpan,\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        deps: null,\n        host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n        inputs: { ...inputsFromMetadata, ...inputsFromType },\n        outputs: { ...outputsFromMetadata, ...outputsFromType },\n        queries: facade.queries.map(convertToR3QueryMetadata),\n        providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n        viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n        fullInheritance: false,\n        hostDirectives: convertHostDirectivesToMetadata(facade),\n    };\n}\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        typeSourceSpan,\n        internalType: new WrappedNodeExpr(declaration.type),\n        selector: declaration.selector ?? null,\n        inputs: declaration.inputs ?? {},\n        outputs: declaration.outputs ?? {},\n        host: convertHostDeclarationToMetadata(declaration.host),\n        queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n        viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n            null,\n        exportAs: declaration.exportAs ?? null,\n        usesInheritance: declaration.usesInheritance ?? false,\n        lifecycle: { usesOnChanges: declaration.usesOnChanges ?? false },\n        deps: null,\n        typeArgumentCount: 0,\n        fullInheritance: false,\n        isStandalone: declaration.isStandalone ?? false,\n        hostDirectives: convertHostDirectivesToMetadata(declaration),\n    };\n}\nfunction convertHostDeclarationToMetadata(host = {}) {\n    return {\n        attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n        listeners: host.listeners ?? {},\n        properties: host.properties ?? {},\n        specialAttributes: {\n            classAttr: host.classAttribute,\n            styleAttr: host.styleAttribute,\n        },\n    };\n}\nfunction convertHostDirectivesToMetadata(metadata) {\n    if (metadata.hostDirectives?.length) {\n        return metadata.hostDirectives.map(hostDirective => {\n            return typeof hostDirective === 'function' ?\n                {\n                    directive: wrapReference(hostDirective),\n                    inputs: null,\n                    outputs: null,\n                    isForwardReference: false\n                } :\n                {\n                    directive: wrapReference(hostDirective.directive),\n                    isForwardReference: false,\n                    inputs: hostDirective.inputs ? parseInputOutputs(hostDirective.inputs) : null,\n                    outputs: hostDirective.outputs ? parseInputOutputs(hostDirective.outputs) : null,\n                };\n        });\n    }\n    return null;\n}\nfunction convertOpaqueValuesToExpressions(obj) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        result[key] = new WrappedNodeExpr(obj[key]);\n    }\n    return result;\n}\nfunction convertDeclareComponentFacadeToMetadata(decl, typeSourceSpan, sourceMapUrl) {\n    const { template, interpolation } = parseJitTemplate(decl.template, decl.type.name, sourceMapUrl, decl.preserveWhitespaces ?? false, decl.interpolation);\n    const declarations = [];\n    if (decl.dependencies) {\n        for (const innerDep of decl.dependencies) {\n            switch (innerDep.kind) {\n                case 'directive':\n                case 'component':\n                    declarations.push(convertDirectiveDeclarationToMetadata(innerDep));\n                    break;\n                case 'pipe':\n                    declarations.push(convertPipeDeclarationToMetadata(innerDep));\n                    break;\n            }\n        }\n    }\n    else if (decl.components || decl.directives || decl.pipes) {\n        // Existing declarations on NPM may not be using the new `dependencies` merged field, and may\n        // have separate fields for dependencies instead. Unify them for JIT compilation.\n        decl.components &&\n            declarations.push(...decl.components.map(dir => convertDirectiveDeclarationToMetadata(dir, /* isComponent */ true)));\n        decl.directives &&\n            declarations.push(...decl.directives.map(dir => convertDirectiveDeclarationToMetadata(dir)));\n        decl.pipes && declarations.push(...convertPipeMapToMetadata(decl.pipes));\n    }\n    return {\n        ...convertDeclareDirectiveFacadeToMetadata(decl, typeSourceSpan),\n        template,\n        styles: decl.styles ?? [],\n        declarations,\n        viewProviders: decl.viewProviders !== undefined ? new WrappedNodeExpr(decl.viewProviders) :\n            null,\n        animations: decl.animations !== undefined ? new WrappedNodeExpr(decl.animations) : null,\n        changeDetection: decl.changeDetection ?? ChangeDetectionStrategy.Default,\n        encapsulation: decl.encapsulation ?? ViewEncapsulation.Emulated,\n        interpolation,\n        declarationListEmitMode: 2 /* DeclarationListEmitMode.ClosureResolved */,\n        relativeContextFilePath: '',\n        i18nUseExternalIds: true,\n    };\n}\nfunction convertDeclarationFacadeToMetadata(declaration) {\n    return {\n        ...declaration,\n        type: new WrappedNodeExpr(declaration.type),\n    };\n}\nfunction convertDirectiveDeclarationToMetadata(declaration, isComponent = null) {\n    return {\n        kind: R3TemplateDependencyKind.Directive,\n        isComponent: isComponent || declaration.kind === 'component',\n        selector: declaration.selector,\n        type: new WrappedNodeExpr(declaration.type),\n        inputs: declaration.inputs ?? [],\n        outputs: declaration.outputs ?? [],\n        exportAs: declaration.exportAs ?? null,\n    };\n}\nfunction convertPipeMapToMetadata(pipes) {\n    if (!pipes) {\n        return [];\n    }\n    return Object.keys(pipes).map(name => {\n        return {\n            kind: R3TemplateDependencyKind.Pipe,\n            name,\n            type: new WrappedNodeExpr(pipes[name]),\n        };\n    });\n}\nfunction convertPipeDeclarationToMetadata(pipe) {\n    return {\n        kind: R3TemplateDependencyKind.Pipe,\n        name: pipe.name,\n        type: new WrappedNodeExpr(pipe.type),\n    };\n}\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\n    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n    // Parse the template and check for errors.\n    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces, interpolationConfig });\n    if (parsed.errors !== null) {\n        const errors = parsed.errors.map(err => err.toString()).join(', ');\n        throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n    }\n    return { template: parsed, interpolation: interpolationConfig };\n}\n/**\n * Convert the expression, if present to an `R3ProviderExpression`.\n *\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\n * use `ForwardRefHandling.None`.\n */\nfunction convertToProviderExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return createMayBeForwardRefExpression(new WrappedNodeExpr(obj[property]), 0 /* ForwardRefHandling.None */);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n        return new WrappedNodeExpr(obj[property]);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction computeProvidedIn(providedIn) {\n    const expression = typeof providedIn === 'function' ? new WrappedNodeExpr(providedIn) :\n        new LiteralExpr(providedIn ?? null);\n    // See `convertToProviderExpression()` for why this uses `ForwardRefHandling.None`.\n    return createMayBeForwardRefExpression(expression, 0 /* ForwardRefHandling.None */);\n}\nfunction convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\nfunction convertR3DependencyMetadata(facade) {\n    const isAttributeDep = facade.attribute != null; // both `null` and `undefined`\n    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n    // `attribute` rather than the `token`.\n    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\nfunction convertR3DeclareDependencyMetadata(facade) {\n    const isAttributeDep = facade.attribute ?? false;\n    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n    return createR3DependencyMetadata(token, isAttributeDep, facade.host ?? false, facade.optional ?? false, facade.self ?? false, facade.skipSelf ?? false);\n}\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n    // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n    // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n    // marker.\n    const attributeNameType = isAttributeDep ? literal('unknown') : null;\n    return { token, attributeNameType, host, optional, self, skipSelf };\n}\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    const bindings = parseHostBindings(host || {});\n    // After that check host bindings for errors\n    const errors = verifyHostBindings(bindings, sourceSpan);\n    if (errors.length) {\n        throw new Error(errors.map((error) => error.msg).join('\\n'));\n    }\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n    for (const field in propMetadata) {\n        if (propMetadata.hasOwnProperty(field)) {\n            propMetadata[field].forEach(ann => {\n                if (isHostBinding(ann)) {\n                    // Since this is a decorator, we know that the value is a class member. Always access it\n                    // through `this` so that further down the line it can't be confused for a literal value\n                    // (e.g. if there's a property called `true`).\n                    bindings.properties[ann.hostPropertyName || field] =\n                        getSafePropertyAccessString('this', field);\n                }\n                else if (isHostListener(ann)) {\n                    bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n                }\n            });\n        }\n    }\n    return bindings;\n}\nfunction isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n}\nfunction isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n}\nfunction isInput(value) {\n    return value.ngMetadataName === 'Input';\n}\nfunction isOutput(value) {\n    return value.ngMetadataName === 'Output';\n}\nfunction parseInputOutputs(values) {\n    return values.reduce((results, value) => {\n        const [field, property] = value.split(':', 2).map(str => str.trim());\n        results[field] = property || field;\n        return results;\n    }, {});\n}\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        typeArgumentCount: 0,\n        pipeName: declaration.name,\n        deps: null,\n        pure: declaration.pure ?? true,\n        isStandalone: declaration.isStandalone ?? false,\n    };\n}\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n    return {\n        name: declaration.type.name,\n        type: wrapReference(declaration.type),\n        internalType: new WrappedNodeExpr(declaration.type),\n        providers: declaration.providers !== undefined && declaration.providers.length > 0 ?\n            new WrappedNodeExpr(declaration.providers) :\n            null,\n        imports: declaration.imports !== undefined ?\n            declaration.imports.map(i => new WrappedNodeExpr(i)) :\n            [],\n    };\n}\nfunction publishFacade(global) {\n    const ng = global.ng || (global.ng = {});\n    ng.compilerFacade = new CompilerFacadeImpl();\n}\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of the compiler package.\n */\nconst VERSION = new Version('15.2.7');\n\nclass CompilerConfig {\n    constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {\n        this.defaultEncapsulation = defaultEncapsulation;\n        this.useJit = !!useJit;\n        this.missingTranslation = missingTranslation;\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n        this.strictInjectionParameters = strictInjectionParameters === true;\n    }\n}\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n/**\n * Extract translatable messages from an html AST\n */\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n}\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    const visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n}\nclass ExtractionResult {\n    constructor(messages, errors) {\n        this.messages = messages;\n        this.errors = errors;\n    }\n}\nvar _VisitorMode;\n(function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor {\n    constructor(_implicitTags, _implicitAttrs) {\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n    extract(nodes, interpolationConfig) {\n        this._init(_VisitorMode.Extract, interpolationConfig);\n        nodes.forEach(node => node.visit(this, null));\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ExtractionResult(this._messages, this._errors);\n    }\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n    merge(nodes, translations, interpolationConfig) {\n        this._init(_VisitorMode.Merge, interpolationConfig);\n        this._translations = translations;\n        // Construct a single fake root element\n        const wrapper = new Element('wrapper', [], nodes, undefined, undefined, undefined);\n        const translatedNode = wrapper.visit(this, null);\n        if (this._inI18nBlock) {\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n        }\n        return new ParseTreeResult(translatedNode.children, this._errors);\n    }\n    visitExpansionCase(icuCase, context) {\n        // Parse cases for translatable html attributes\n        const expression = visitAll(this, icuCase.expression, context);\n        if (this._mode === _VisitorMode.Merge) {\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n        }\n    }\n    visitExpansion(icu, context) {\n        this._mayBeAddBlockChildren(icu);\n        const wasInIcu = this._inIcu;\n        if (!this._inIcu) {\n            // nested ICU messages should not be extracted but top-level translated as a whole\n            if (this._isInTranslatableSection) {\n                this._addMessage([icu]);\n            }\n            this._inIcu = true;\n        }\n        const cases = visitAll(this, icu.cases, context);\n        if (this._mode === _VisitorMode.Merge) {\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n        }\n        this._inIcu = wasInIcu;\n        return icu;\n    }\n    visitComment(comment, context) {\n        const isOpening = _isOpeningComment(comment);\n        if (isOpening && this._isInTranslatableSection) {\n            this._reportError(comment, 'Could not start a block inside a translatable section');\n            return;\n        }\n        const isClosing = _isClosingComment(comment);\n        if (isClosing && !this._inI18nBlock) {\n            this._reportError(comment, 'Trying to close an unopened block');\n            return;\n        }\n        if (!this._inI18nNode && !this._inIcu) {\n            if (!this._inI18nBlock) {\n                if (isOpening) {\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n                    if (!i18nCommentsWarned && console && console.warn) {\n                        i18nCommentsWarned = true;\n                        const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n                        // TODO(ocombe): use a log service once there is a public one available\n                        console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\n                    }\n                    this._inI18nBlock = true;\n                    this._blockStartDepth = this._depth;\n                    this._blockChildren = [];\n                    this._blockMeaningAndDesc =\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n                    this._openTranslatableSection(comment);\n                }\n            }\n            else {\n                if (isClosing) {\n                    if (this._depth == this._blockStartDepth) {\n                        this._closeTranslatableSection(comment, this._blockChildren);\n                        this._inI18nBlock = false;\n                        const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\n                        // merge attributes in sections\n                        const nodes = this._translateMessage(comment, message);\n                        return visitAll(this, nodes);\n                    }\n                    else {\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    visitText(text, context) {\n        if (this._isInTranslatableSection) {\n            this._mayBeAddBlockChildren(text);\n        }\n        return text;\n    }\n    visitElement(el, context) {\n        this._mayBeAddBlockChildren(el);\n        this._depth++;\n        const wasInI18nNode = this._inI18nNode;\n        const wasInImplicitNode = this._inImplicitNode;\n        let childNodes = [];\n        let translatedChildNodes = undefined;\n        // Extract:\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n        // - ICU messages\n        const i18nAttr = _getI18nAttr(el);\n        const i18nMeta = i18nAttr ? i18nAttr.value : '';\n        const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n            !this._isInTranslatableSection;\n        const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\n        if (!this._isInTranslatableSection && !this._inIcu) {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._inI18nNode = true;\n                const message = this._addMessage(el.children, i18nMeta);\n                translatedChildNodes = this._translateMessage(el, message);\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                const isTranslatable = i18nAttr || isTopLevelImplicit;\n                if (isTranslatable)\n                    this._openTranslatableSection(el);\n                visitAll(this, el.children);\n                if (isTranslatable)\n                    this._closeTranslatableSection(el, el.children);\n            }\n        }\n        else {\n            if (i18nAttr || isTopLevelImplicit) {\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n            }\n            if (this._mode == _VisitorMode.Extract) {\n                // Descend into child nodes for extraction\n                visitAll(this, el.children);\n            }\n        }\n        if (this._mode === _VisitorMode.Merge) {\n            const visitNodes = translatedChildNodes || el.children;\n            visitNodes.forEach(child => {\n                const visited = child.visit(this, context);\n                if (visited && !this._isInTranslatableSection) {\n                    // Do not add the children from translatable sections (= i18n blocks here)\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n                    childNodes = childNodes.concat(visited);\n                }\n            });\n        }\n        this._visitAttributesOf(el);\n        this._depth--;\n        this._inI18nNode = wasInI18nNode;\n        this._inImplicitNode = wasInImplicitNode;\n        if (this._mode === _VisitorMode.Merge) {\n            const translatedAttrs = this._translateAttributes(el);\n            return new Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n        }\n        return null;\n    }\n    visitAttribute(attribute, context) {\n        throw new Error('unreachable code');\n    }\n    _init(mode, interpolationConfig) {\n        this._mode = mode;\n        this._inI18nBlock = false;\n        this._inI18nNode = false;\n        this._depth = 0;\n        this._inIcu = false;\n        this._msgCountAtSectionStart = undefined;\n        this._errors = [];\n        this._messages = [];\n        this._inImplicitNode = false;\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    }\n    // looks for translatable attributes\n    _visitAttributesOf(el) {\n        const explicitAttrNameToValue = {};\n        const implicitAttrNames = this._implicitAttrs[el.name] || [];\n        el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n            .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            attr.value);\n        el.attrs.forEach(attr => {\n            if (attr.name in explicitAttrNameToValue) {\n                this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n            }\n            else if (implicitAttrNames.some(name => attr.name === name)) {\n                this._addMessage([attr]);\n            }\n        });\n    }\n    // add a translatable message\n    _addMessage(ast, msgMeta) {\n        if (ast.length == 0 ||\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n            // Do not create empty messages\n            return null;\n        }\n        const { meaning, description, id } = _parseMessageMeta(msgMeta);\n        const message = this._createI18nMessage(ast, meaning, description, id);\n        this._messages.push(message);\n        return message;\n    }\n    // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n    _translateMessage(el, message) {\n        if (message && this._mode === _VisitorMode.Merge) {\n            const nodes = this._translations.get(message);\n            if (nodes) {\n                return nodes;\n            }\n            this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n        }\n        return [];\n    }\n    // translate the attributes of an element and remove i18n specific attributes\n    _translateAttributes(el) {\n        const attributes = el.attrs;\n        const i18nParsedMessageMeta = {};\n        attributes.forEach(attr => {\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                    _parseMessageMeta(attr.value);\n            }\n        });\n        const translatedAttributes = [];\n        attributes.forEach((attr) => {\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n                // strip i18n specific attributes\n                return;\n            }\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n                const { meaning, description, id } = i18nParsedMessageMeta[attr.name];\n                const message = this._createI18nMessage([attr], meaning, description, id);\n                const nodes = this._translations.get(message);\n                if (nodes) {\n                    if (nodes.length == 0) {\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else if (nodes[0] instanceof Text) {\n                        const value = nodes[0].value;\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* valueTokens */, undefined /* i18n */));\n                    }\n                    else {\n                        this._reportError(el, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                    }\n                }\n                else {\n                    this._reportError(el, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\n                }\n            }\n            else {\n                translatedAttributes.push(attr);\n            }\n        });\n        return translatedAttributes;\n    }\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n    _mayBeAddBlockChildren(node) {\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n            this._blockChildren.push(node);\n        }\n    }\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n    _openTranslatableSection(node) {\n        if (this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section start');\n        }\n        else {\n            this._msgCountAtSectionStart = this._messages.length;\n        }\n    }\n    /**\n     * A translatable section could be:\n     * - the content of translatable element,\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n     */\n    get _isInTranslatableSection() {\n        return this._msgCountAtSectionStart !== void 0;\n    }\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n    _closeTranslatableSection(node, directChildren) {\n        if (!this._isInTranslatableSection) {\n            this._reportError(node, 'Unexpected section end');\n            return;\n        }\n        const startIndex = this._msgCountAtSectionStart;\n        const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment ? 0 : 1), 0);\n        if (significantChildren == 1) {\n            for (let i = this._messages.length - 1; i >= startIndex; i--) {\n                const ast = this._messages[i].nodes;\n                if (!(ast.length == 1 && ast[0] instanceof Text$2)) {\n                    this._messages.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        this._msgCountAtSectionStart = undefined;\n    }\n    _reportError(node, msg) {\n        this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n}\nfunction _isOpeningComment(n) {\n    return !!(n instanceof Comment && n.value && n.value.startsWith('i18n'));\n}\nfunction _isClosingComment(n) {\n    return !!(n instanceof Comment && n.value && n.value === '/i18n');\n}\nfunction _getI18nAttr(p) {\n    return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\nfunction _parseMessageMeta(i18n) {\n    if (!i18n)\n        return { meaning: '', description: '', id: '' };\n    const idIndex = i18n.indexOf(ID_SEPARATOR);\n    const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n    const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n    const [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n    return { meaning, description, id: id.trim() };\n}\n\nclass XmlTagDefinition {\n    constructor() {\n        this.closedByParent = false;\n        this.isVoid = false;\n        this.ignoreFirstLf = false;\n        this.canSelfClose = true;\n        this.preventNamespaceInheritance = false;\n    }\n    requireExtraParent(currentParent) {\n        return false;\n    }\n    isClosedByChild(name) {\n        return false;\n    }\n    getContentType() {\n        return TagContentType.PARSABLE_DATA;\n    }\n}\nconst _TAG_DEFINITION = new XmlTagDefinition();\nfunction getXmlTagDefinition(tagName) {\n    return _TAG_DEFINITION;\n}\n\nclass XmlParser extends Parser {\n    constructor() {\n        super(getXmlTagDefinition);\n    }\n    parse(source, url, options) {\n        return super.parse(source, url, options);\n    }\n}\n\nconst _VERSION$1 = '1.2';\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:1.2';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\nconst _PLACEHOLDER_TAG$2 = 'x';\nconst _MARKER_TAG$1 = 'mrk';\nconst _FILE_TAG = 'file';\nconst _SOURCE_TAG$1 = 'source';\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\nconst _ALT_TRANS_TAG = 'alt-trans';\nconst _TARGET_TAG$1 = 'target';\nconst _UNIT_TAG$1 = 'trans-unit';\nconst _CONTEXT_GROUP_TAG = 'context-group';\nconst _CONTEXT_TAG = 'context';\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\nclass Xliff extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor$1();\n        const transUnits = [];\n        messages.forEach(message => {\n            let contextTags = [];\n            message.sources.forEach((source) => {\n                let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$1(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$1(`${source.startLine}`)]), new CR(8));\n                contextTags.push(new CR(8), contextGroupTag);\n            });\n            const transUnit = new Tag(_UNIT_TAG$1, { id: message.id, datatype: 'html' });\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\n            if (message.description) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$1(message.description)]));\n            }\n            if (message.meaning) {\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$1(message.meaning)]));\n            }\n            transUnit.children.push(new CR(6));\n            transUnits.push(new CR(6), transUnit);\n        });\n        const body = new Tag('body', {}, [...transUnits, new CR(4)]);\n        const file = new Tag('file', {\n            'source-language': locale || _DEFAULT_SOURCE_LANG$1,\n            datatype: 'plaintext',\n            original: 'ng2.template',\n        }, [new CR(4), body, new CR(2)]);\n        const xliff = new Tag('xliff', { version: _VERSION$1, xmlns: _XMLNS$1 }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliffParser = new XliffParser();\n        const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$2();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest$1(message);\n    }\n}\nclass _WriteVisitor$1 {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const ctype = getCtypeForTag(ph.tag);\n        if (ph.isVoid) {\n            // void tags have no children nor closing tags\n            return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];\n        }\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$2, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n    }\n    visitPlaceholder(ph, context) {\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: ph.name, 'equiv-text': equivText })];\n    }\n    serialize(nodes) {\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\nclass XliffParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG$1:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            // ignore those tags\n            case _SOURCE_TAG$1:\n            case _SEGMENT_SOURCE_TAG:\n            case _ALT_TRANS_TAG:\n                break;\n            case _TARGET_TAG$1:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _FILE_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                visitAll(this, element.children, null);\n                break;\n            default:\n                // TODO(vicb): assert file structure, xliff version\n                // For now only recurse on unhandled nodes\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$2 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes: i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG$2) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'id');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"id\" attribute`);\n            return null;\n        }\n        if (el.name === _MARKER_TAG$1) {\n            return [].concat(...visitAll(this, el.children));\n        }\n        this._addError(el, `Unexpected tag`);\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getCtypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n            return 'lb';\n        case 'img':\n            return 'image';\n        default:\n            return `x-${tag}`;\n    }\n}\n\nconst _VERSION = '2.0';\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:2.0';\n// TODO(vicb): make this a param (s/_/-/)\nconst _DEFAULT_SOURCE_LANG = 'en';\nconst _PLACEHOLDER_TAG$1 = 'ph';\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\nconst _MARKER_TAG = 'mrk';\nconst _XLIFF_TAG = 'xliff';\nconst _SOURCE_TAG = 'source';\nconst _TARGET_TAG = 'target';\nconst _UNIT_TAG = 'unit';\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\nclass Xliff2 extends Serializer {\n    write(messages, locale) {\n        const visitor = new _WriteVisitor();\n        const units = [];\n        messages.forEach(message => {\n            const unit = new Tag(_UNIT_TAG, { id: message.id });\n            const notes = new Tag('notes');\n            if (message.description || message.meaning) {\n                if (message.description) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$1(message.description)]));\n                }\n                if (message.meaning) {\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$1(message.meaning)]));\n                }\n            }\n            message.sources.forEach((source) => {\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\n                    new Text$1(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n                ]));\n            });\n            notes.children.push(new CR(6));\n            unit.children.push(new CR(6), notes);\n            const segment = new Tag('segment');\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG, {}, visitor.serialize(message.nodes)), new CR(6));\n            unit.children.push(new CR(6), segment, new CR(4));\n            units.push(new CR(4), unit);\n        });\n        const file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new CR(2)]);\n        const xliff = new Tag(_XLIFF_TAG, { version: _VERSION, xmlns: _XMLNS, srcLang: locale || _DEFAULT_SOURCE_LANG }, [new CR(2), file, new CR()]);\n        return serialize([\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\n        ]);\n    }\n    load(content, url) {\n        // xliff to xml nodes\n        const xliff2Parser = new Xliff2Parser();\n        const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n$1();\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\n            errors.push(...e);\n            i18nNodesByMsgId[msgId] = i18nNodes;\n        });\n        if (errors.length) {\n            throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return decimalDigest(message);\n    }\n}\nclass _WriteVisitor {\n    visitText(text, context) {\n        return [new Text$1(text.value)];\n    }\n    visitContainer(container, context) {\n        const nodes = [];\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\n        return nodes;\n    }\n    visitIcu(icu, context) {\n        const nodes = [new Text$1(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n        Object.keys(icu.cases).forEach((c) => {\n            nodes.push(new Text$1(`${c} {`), ...icu.cases[c].visit(this), new Text$1(`} `));\n        });\n        nodes.push(new Text$1(`}`));\n        return nodes;\n    }\n    visitTagPlaceholder(ph, context) {\n        const type = getTypeForTag(ph.tag);\n        if (ph.isVoid) {\n            const tagPh = new Tag(_PLACEHOLDER_TAG$1, {\n                id: (this._nextPlaceholderId++).toString(),\n                equiv: ph.startName,\n                type: type,\n                disp: `<${ph.tag}/>`,\n            });\n            return [tagPh];\n        }\n        const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n            id: (this._nextPlaceholderId++).toString(),\n            equivStart: ph.startName,\n            equivEnd: ph.closeName,\n            type: type,\n            dispStart: `<${ph.tag}>`,\n            dispEnd: `</${ph.tag}>`,\n        });\n        const nodes = [].concat(...ph.children.map(node => node.visit(this)));\n        if (nodes.length) {\n            nodes.forEach((node) => tagPc.children.push(node));\n        }\n        else {\n            tagPc.children.push(new Text$1(''));\n        }\n        return [tagPc];\n    }\n    visitPlaceholder(ph, context) {\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n                id: idStr,\n                equiv: ph.name,\n                disp: `{{${ph.value}}}`,\n            })];\n    }\n    visitIcuPlaceholder(ph, context) {\n        const cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\n        const idStr = (this._nextPlaceholderId++).toString();\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];\n    }\n    serialize(nodes) {\n        this._nextPlaceholderId = 0;\n        return [].concat(...nodes.map(node => node.visit(this)));\n    }\n}\n// Extract messages as xml nodes from the xliff file\nclass Xliff2Parser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xliff, url) {\n        this._unitMlString = null;\n        this._msgIdToHtml = {};\n        const xml = new XmlParser().parse(xliff, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes, null);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _UNIT_TAG:\n                this._unitMlString = null;\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                        if (typeof this._unitMlString === 'string') {\n                            this._msgIdToHtml[id] = this._unitMlString;\n                        }\n                        else {\n                            this._addError(element, `Message ${id} misses a translation`);\n                        }\n                    }\n                }\n                break;\n            case _SOURCE_TAG:\n                // ignore source message\n                break;\n            case _TARGET_TAG:\n                const innerTextStart = element.startSourceSpan.end.offset;\n                const innerTextEnd = element.endSourceSpan.start.offset;\n                const content = element.startSourceSpan.start.file.content;\n                const innerText = content.slice(innerTextStart, innerTextEnd);\n                this._unitMlString = innerText;\n                break;\n            case _XLIFF_TAG:\n                const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\n                if (localeAttr) {\n                    this._locale = localeAttr.value;\n                }\n                const versionAttr = element.attrs.find((attr) => attr.name === 'version');\n                if (versionAttr) {\n                    const version = versionAttr.value;\n                    if (version !== '2.0') {\n                        this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\n                    }\n                    else {\n                        visitAll(this, element.children, null);\n                    }\n                }\n                break;\n            default:\n                visitAll(this, element.children, null);\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xliff syntax) to i18n nodes\nclass XmlToI18n$1 {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            [].concat(...visitAll(this, xmlIcu.rootNodes));\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitElement(el, context) {\n        switch (el.name) {\n            case _PLACEHOLDER_TAG$1:\n                const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\n                if (nameAttr) {\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n                }\n                this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equiv\" attribute`);\n                break;\n            case _PLACEHOLDER_SPANNING_TAG:\n                const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\n                const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\n                if (!startAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivStart\" attribute`);\n                }\n                else if (!endAttr) {\n                    this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"equivEnd\" attribute`);\n                }\n                else {\n                    const startId = startAttr.value;\n                    const endId = endAttr.value;\n                    const nodes = [];\n                    return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\n                }\n                break;\n            case _MARKER_TAG:\n                return [].concat(...visitAll(this, el.children));\n            default:\n                this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach((c) => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: [].concat(...visitAll(this, icuCase.expression)),\n        };\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\nfunction getTypeForTag(tag) {\n    switch (tag.toLowerCase()) {\n        case 'br':\n        case 'b':\n        case 'i':\n        case 'u':\n            return 'fmt';\n        case 'img':\n            return 'image';\n        case 'a':\n            return 'link';\n        default:\n            return 'other';\n    }\n}\n\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\nclass Xtb extends Serializer {\n    write(messages, locale) {\n        throw new Error('Unsupported');\n    }\n    load(content, url) {\n        // xtb to xml nodes\n        const xtbParser = new XtbParser();\n        const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);\n        // xml nodes to i18n nodes\n        const i18nNodesByMsgId = {};\n        const converter = new XmlToI18n();\n        // Because we should be able to load xtb files that rely on features not supported by angular,\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n        // converted\n        Object.keys(msgIdToHtml).forEach(msgId => {\n            const valueFn = function () {\n                const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);\n                if (errors.length) {\n                    throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n                }\n                return i18nNodes;\n            };\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n        });\n        if (errors.length) {\n            throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return { locale: locale, i18nNodesByMsgId };\n    }\n    digest(message) {\n        return digest(message);\n    }\n    createNameMapper(message) {\n        return new SimplePlaceholderMapper(message, toPublicName);\n    }\n}\nfunction createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n        configurable: true,\n        enumerable: true,\n        get: function () {\n            const value = valueFn();\n            Object.defineProperty(messages, id, { enumerable: true, value });\n            return value;\n        },\n        set: _ => {\n            throw new Error('Could not overwrite an XTB translation');\n        },\n    });\n}\n// Extract messages as xml nodes from the xtb file\nclass XtbParser {\n    constructor() {\n        this._locale = null;\n    }\n    parse(xtb, url) {\n        this._bundleDepth = 0;\n        this._msgIdToHtml = {};\n        // We can not parse the ICU messages at this point as some messages might not originate\n        // from Angular that could not be lex'd.\n        const xml = new XmlParser().parse(xtb, url);\n        this._errors = xml.errors;\n        visitAll(this, xml.rootNodes);\n        return {\n            msgIdToHtml: this._msgIdToHtml,\n            errors: this._errors,\n            locale: this._locale,\n        };\n    }\n    visitElement(element, context) {\n        switch (element.name) {\n            case _TRANSLATIONS_TAG:\n                this._bundleDepth++;\n                if (this._bundleDepth > 1) {\n                    this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n                }\n                const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n                if (langAttr) {\n                    this._locale = langAttr.value;\n                }\n                visitAll(this, element.children, null);\n                this._bundleDepth--;\n                break;\n            case _TRANSLATION_TAG:\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\n                if (!idAttr) {\n                    this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n                }\n                else {\n                    const id = idAttr.value;\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\n                        this._addError(element, `Duplicated translations for msg ${id}`);\n                    }\n                    else {\n                        const innerTextStart = element.startSourceSpan.end.offset;\n                        const innerTextEnd = element.endSourceSpan.start.offset;\n                        const content = element.startSourceSpan.start.file.content;\n                        const innerText = content.slice(innerTextStart, innerTextEnd);\n                        this._msgIdToHtml[id] = innerText;\n                    }\n                }\n                break;\n            default:\n                this._addError(element, 'Unexpected tag');\n        }\n    }\n    visitAttribute(attribute, context) { }\n    visitText(text, context) { }\n    visitComment(comment, context) { }\n    visitExpansion(expansion, context) { }\n    visitExpansionCase(expansionCase, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n {\n    convert(message, url) {\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\n        this._errors = xmlIcu.errors;\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n            [] :\n            visitAll(this, xmlIcu.rootNodes);\n        return {\n            i18nNodes,\n            errors: this._errors,\n        };\n    }\n    visitText(text, context) {\n        return new Text$2(text.value, text.sourceSpan);\n    }\n    visitExpansion(icu, context) {\n        const caseMap = {};\n        visitAll(this, icu.cases).forEach(c => {\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n        });\n        return new Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n    visitExpansionCase(icuCase, context) {\n        return {\n            value: icuCase.value,\n            nodes: visitAll(this, icuCase.expression),\n        };\n    }\n    visitElement(el, context) {\n        if (el.name === _PLACEHOLDER_TAG) {\n            const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n            if (nameAttr) {\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\n            }\n            this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n        }\n        else {\n            this._addError(el, `Unexpected tag`);\n        }\n        return null;\n    }\n    visitComment(comment, context) { }\n    visitAttribute(attribute, context) { }\n    _addError(node, message) {\n        this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n}\n\n/**\n * A container for translated messages\n */\nclass TranslationBundle {\n    constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this.digest = digest;\n        this.mapperFactory = mapperFactory;\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n    static load(content, url, serializer, missingTranslationStrategy, console) {\n        const { locale, i18nNodesByMsgId } = serializer.load(content, url);\n        const digestFn = (m) => serializer.digest(m);\n        const mapperFactory = (m) => serializer.createNameMapper(m);\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }\n    // Returns the translation as HTML nodes from the given source message.\n    get(srcMsg) {\n        const html = this._i18nToHtml.convert(srcMsg);\n        if (html.errors.length) {\n            throw new Error(html.errors.join('\\n'));\n        }\n        return html.nodes;\n    }\n    has(srcMsg) {\n        return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    }\n}\nclass I18nToHtmlVisitor {\n    constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\n        this._locale = _locale;\n        this._digest = _digest;\n        this._mapperFactory = _mapperFactory;\n        this._missingTranslationStrategy = _missingTranslationStrategy;\n        this._console = _console;\n        this._contextStack = [];\n        this._errors = [];\n    }\n    convert(srcMsg) {\n        this._contextStack.length = 0;\n        this._errors.length = 0;\n        // i18n to text\n        const text = this._convertToText(srcMsg);\n        // text to html\n        const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n        const html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\n        return {\n            nodes: html.rootNodes,\n            errors: [...this._errors, ...html.errors],\n        };\n    }\n    visitText(text, context) {\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\n        // we should then make sure that any special characters are escaped\n        return escapeXml(text.value);\n    }\n    visitContainer(container, context) {\n        return container.children.map(n => n.visit(this)).join('');\n    }\n    visitIcu(icu, context) {\n        const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n        // TODO(vicb): Once all format switch to using expression placeholders\n        // we should throw when the placeholder is not in the source message\n        const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n            this._srcMsg.placeholders[icu.expression].text :\n            icu.expression;\n        return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n    }\n    visitPlaceholder(ph, context) {\n        const phName = this._mapper(ph.name);\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n            return this._srcMsg.placeholders[phName].text;\n        }\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n        }\n        this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n        return '';\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitTagPlaceholder(ph, context) {\n        const tag = `${ph.tag}`;\n        const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n        if (ph.isVoid) {\n            return `<${tag} ${attrs}/>`;\n        }\n        const children = ph.children.map((c) => c.visit(this)).join('');\n        return `<${tag} ${attrs}>${children}</${tag}>`;\n    }\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n    visitIcuPlaceholder(ph, context) {\n        // An ICU placeholder references the source message to be serialized\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    }\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n    _convertToText(srcMsg) {\n        const id = this._digest(srcMsg);\n        const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n        let nodes;\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\n        this._srcMsg = srcMsg;\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n            // When there is a translation use its nodes as the source\n            // And create a mapper to convert serialized placeholder names to internal names\n            nodes = this._i18nNodesByMsgId[id];\n            this._mapper = (name) => mapper ? mapper.toInternalName(name) : name;\n        }\n        else {\n            // When no translation has been found\n            // - report an error / a warning / nothing,\n            // - use the nodes from the original message\n            // - placeholders are already internal and need no mapper\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n            }\n            else if (this._console &&\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n                this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n            }\n            nodes = srcMsg.nodes;\n            this._mapper = (name) => name;\n        }\n        const text = nodes.map(node => node.visit(this)).join('');\n        const context = this._contextStack.pop();\n        this._srcMsg = context.msg;\n        this._mapper = context.mapper;\n        return text;\n    }\n    _addError(el, msg) {\n        this._errors.push(new I18nError(el.sourceSpan, msg));\n    }\n}\n\nclass I18NHtmlParser {\n    constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\n        this._htmlParser = _htmlParser;\n        if (translations) {\n            const serializer = createSerializer(translationsFormat);\n            this._translationBundle =\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\n        }\n        else {\n            this._translationBundle =\n                new TranslationBundle({}, null, digest$1, undefined, missingTranslation, console);\n        }\n    }\n    parse(source, url, options = {}) {\n        const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n        const parseResult = this._htmlParser.parse(source, url, { interpolationConfig, ...options });\n        if (parseResult.errors.length) {\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n        }\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    }\n}\nfunction createSerializer(format) {\n    format = (format || 'xlf').toLowerCase();\n    switch (format) {\n        case 'xmb':\n            return new Xmb();\n        case 'xtb':\n            return new Xtb();\n        case 'xliff2':\n        case 'xlf2':\n            return new Xliff2();\n        case 'xliff':\n        case 'xlf':\n        default:\n            return new Xliff();\n    }\n}\n\n/**\n * A container for message extracted from the templates.\n */\nclass MessageBundle {\n    constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null) {\n        this._htmlParser = _htmlParser;\n        this._implicitTags = _implicitTags;\n        this._implicitAttrs = _implicitAttrs;\n        this._locale = _locale;\n        this._messages = [];\n    }\n    updateFromTemplate(html, url, interpolationConfig) {\n        const htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig });\n        if (htmlParserResult.errors.length) {\n            return htmlParserResult.errors;\n        }\n        const i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n        if (i18nParserResult.errors.length) {\n            return i18nParserResult.errors;\n        }\n        this._messages.push(...i18nParserResult.messages);\n        return [];\n    }\n    // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n    getMessages() {\n        return this._messages;\n    }\n    write(serializer, filterSources) {\n        const messages = {};\n        const mapperVisitor = new MapPlaceholderNames();\n        // Deduplicate messages based on their ID\n        this._messages.forEach(message => {\n            const id = serializer.digest(message);\n            if (!messages.hasOwnProperty(id)) {\n                messages[id] = message;\n            }\n            else {\n                messages[id].sources.push(...message.sources);\n            }\n        });\n        // Transform placeholder names using the serializer mapping\n        const msgList = Object.keys(messages).map(id => {\n            const mapper = serializer.createNameMapper(messages[id]);\n            const src = messages[id];\n            const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n            let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n            transformedMessage.sources = src.sources;\n            if (filterSources) {\n                transformedMessage.sources.forEach((source) => source.filePath = filterSources(source.filePath));\n            }\n            return transformedMessage;\n        });\n        return serializer.write(msgList, this._locale);\n    }\n}\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\nclass MapPlaceholderNames extends CloneVisitor {\n    convert(nodes, mapper) {\n        return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\n    }\n    visitTagPlaceholder(ph, mapper) {\n        const startName = mapper.toPublicName(ph.startName);\n        const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n        const children = ph.children.map(n => n.visit(this, mapper));\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n    visitPlaceholder(ph, mapper) {\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n    visitIcuPlaceholder(ph, mapper) {\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n}\n\nvar FactoryTarget;\n(function (FactoryTarget) {\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nclass R3TargetBinder {\n    constructor(directiveMatcher) {\n        this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n    bind(target) {\n        if (!target.template) {\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n            throw new Error('Binding without a template not yet supported');\n        }\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\n        // scopes in the template and makes them available for later use.\n        const scope = Scope.apply(target.template);\n        // Use the `Scope` to extract the entities present at every level of the template.\n        const templateEntities = extractTemplateEntities(scope);\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n        //   - references: Map of #references to their targets.\n        const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n        // template. This extracts all the metadata that doesn't depend on directive matching.\n        const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.applyWithScope(target.template, scope);\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\n    }\n}\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope {\n    constructor(parentScope, template) {\n        this.parentScope = parentScope;\n        this.template = template;\n        /**\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n         */\n        this.namedEntities = new Map();\n        /**\n         * Child `Scope`s for immediately nested `Template`s.\n         */\n        this.childScopes = new Map();\n    }\n    static newRootScope() {\n        return new Scope(null, null);\n    }\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n    static apply(template) {\n        const scope = Scope.newRootScope();\n        scope.ingest(template);\n        return scope;\n    }\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n    ingest(template) {\n        if (template instanceof Template) {\n            // Variables on an <ng-template> are defined in the inner scope.\n            template.variables.forEach(node => this.visitVariable(node));\n            // Process the nodes of the template.\n            template.children.forEach(node => node.visit(this));\n        }\n        else {\n            // No overarching `Template` instance, so process the nodes directly.\n            template.forEach(node => node.visit(this));\n        }\n    }\n    visitElement(element) {\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\n        element.references.forEach(node => this.visitReference(node));\n        // Recurse into the `Element`'s children.\n        element.children.forEach(node => node.visit(this));\n    }\n    visitTemplate(template) {\n        // References on a <ng-template> are defined in the outer scope, so capture them before\n        // processing the template's child scope.\n        template.references.forEach(node => this.visitReference(node));\n        // Next, create an inner scope and process the template within it.\n        const scope = new Scope(this, template);\n        scope.ingest(template);\n        this.childScopes.set(template, scope);\n    }\n    visitVariable(variable) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(variable);\n    }\n    visitReference(reference) {\n        // Declare the variable if it's not already.\n        this.maybeDeclare(reference);\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitBoundAttribute(attr) { }\n    visitBoundEvent(event) { }\n    visitBoundText(text) { }\n    visitText(text) { }\n    visitTextAttribute(attr) { }\n    visitIcu(icu) { }\n    maybeDeclare(thing) {\n        // Declare something with a name, as long as that name isn't taken.\n        if (!this.namedEntities.has(thing.name)) {\n            this.namedEntities.set(thing.name, thing);\n        }\n    }\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n    lookup(name) {\n        if (this.namedEntities.has(name)) {\n            // Found in the local scope.\n            return this.namedEntities.get(name);\n        }\n        else if (this.parentScope !== null) {\n            // Not in the local scope, but there's a parent scope so check there.\n            return this.parentScope.lookup(name);\n        }\n        else {\n            // At the top level and it wasn't found.\n            return null;\n        }\n    }\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n    getChildScope(template) {\n        const res = this.childScopes.get(template);\n        if (res === undefined) {\n            throw new Error(`Assertion error: child scope for ${template} not found`);\n        }\n        return res;\n    }\n}\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder {\n    constructor(matcher, directives, bindings, references) {\n        this.matcher = matcher;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n    static apply(template, selectorMatcher) {\n        const directives = new Map();\n        const bindings = new Map();\n        const references = new Map();\n        const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n        matcher.ingest(template);\n        return { directives, bindings, references };\n    }\n    ingest(template) {\n        template.forEach(node => node.visit(this));\n    }\n    visitElement(element) {\n        this.visitElementOrTemplate(element.name, element);\n    }\n    visitTemplate(template) {\n        this.visitElementOrTemplate('ng-template', template);\n    }\n    visitElementOrTemplate(elementName, node) {\n        // First, determine the HTML shape of the node for the purpose of directive matching.\n        // Do this by building up a `CssSelector` for the node.\n        const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\n        const directives = [];\n        this.matcher.match(cssSelector, (_selector, results) => directives.push(...results));\n        if (directives.length > 0) {\n            this.directives.set(node, directives);\n        }\n        // Resolve any references that are created on this node.\n        node.references.forEach(ref => {\n            let dirTarget = null;\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\n            // (if there is one). Otherwise it matches the host node itself (either an element or\n            // <ng-template> node).\n            if (ref.value.trim() === '') {\n                // This could be a reference to a component if there is one.\n                dirTarget = directives.find(dir => dir.isComponent) || null;\n            }\n            else {\n                // This should be a reference to a directive exported via exportAs.\n                dirTarget =\n                    directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n                        null;\n                // Check if a matching directive was found.\n                if (dirTarget === null) {\n                    // No matching directive was found - this reference points to an unknown target. Leave it\n                    // unmapped.\n                    return;\n                }\n            }\n            if (dirTarget !== null) {\n                // This reference points to a directive.\n                this.references.set(ref, { directive: dirTarget, node });\n            }\n            else {\n                // This reference points to the node itself.\n                this.references.set(ref, node);\n            }\n        });\n        const setAttributeBinding = (attribute, ioType) => {\n            const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n            const binding = dir !== undefined ? dir : node;\n            this.bindings.set(attribute, binding);\n        };\n        // Node inputs (bound attributes) and text attributes can be bound to an\n        // input on a directive.\n        node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n        node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        if (node instanceof Template) {\n            node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n        }\n        // Node outputs (bound events) can be bound to an output on a directive.\n        node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n        // Recurse into the node's children.\n        node.children.forEach(child => child.visit(this));\n    }\n    // Unused visitors.\n    visitContent(content) { }\n    visitVariable(variable) { }\n    visitReference(reference) { }\n    visitTextAttribute(attribute) { }\n    visitBoundAttribute(attribute) { }\n    visitBoundEvent(attribute) { }\n    visitBoundAttributeOrEvent(node) { }\n    visitText(text) { }\n    visitBoundText(text) { }\n    visitIcu(icu) { }\n}\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor {\n    constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n        super();\n        this.bindings = bindings;\n        this.symbols = symbols;\n        this.usedPipes = usedPipes;\n        this.nestingLevel = nestingLevel;\n        this.scope = scope;\n        this.template = template;\n        this.level = level;\n        // Save a bit of processing time by constructing this closure in advance.\n        this.visitNode = (node) => node.visit(this);\n    }\n    // This method is defined to reconcile the type of TemplateBinder since both\n    // RecursiveAstVisitor and Visitor define the visit() method in their\n    // interfaces.\n    visit(node, context) {\n        if (node instanceof AST) {\n            node.visit(this, context);\n        }\n        else {\n            node.visit(this);\n        }\n    }\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n    static applyWithScope(template, scope) {\n        const expressions = new Map();\n        const symbols = new Map();\n        const nestingLevel = new Map();\n        const usedPipes = new Set();\n        // The top-level template has nesting level 0.\n        const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n        binder.ingest(template);\n        return { expressions, symbols, nestingLevel, usedPipes };\n    }\n    ingest(template) {\n        if (template instanceof Template) {\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n            // and references were all processed in the scope of the containing template.\n            template.variables.forEach(this.visitNode);\n            template.children.forEach(this.visitNode);\n            // Set the nesting level.\n            this.nestingLevel.set(template, this.level);\n        }\n        else {\n            // Visit each node from the top-level template.\n            template.forEach(this.visitNode);\n        }\n    }\n    visitElement(element) {\n        // Visit the inputs, outputs, and children of the element.\n        element.inputs.forEach(this.visitNode);\n        element.outputs.forEach(this.visitNode);\n        element.children.forEach(this.visitNode);\n    }\n    visitTemplate(template) {\n        // First, visit inputs, outputs and template attributes of the template node.\n        template.inputs.forEach(this.visitNode);\n        template.outputs.forEach(this.visitNode);\n        template.templateAttrs.forEach(this.visitNode);\n        // References are also evaluated in the outer context.\n        template.references.forEach(this.visitNode);\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n        const childScope = this.scope.getChildScope(template);\n        const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n        binder.ingest(template);\n    }\n    visitVariable(variable) {\n        // Register the `Variable` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(variable, this.template);\n        }\n    }\n    visitReference(reference) {\n        // Register the `Reference` as a symbol in the current `Template`.\n        if (this.template !== null) {\n            this.symbols.set(reference, this.template);\n        }\n    }\n    // Unused template visitors\n    visitText(text) { }\n    visitContent(content) { }\n    visitTextAttribute(attribute) { }\n    visitIcu(icu) {\n        Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n        Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n    }\n    // The remaining visitors are concerned with processing AST expressions within template bindings\n    visitBoundAttribute(attribute) {\n        attribute.value.visit(this);\n    }\n    visitBoundEvent(event) {\n        event.handler.visit(this);\n    }\n    visitBoundText(text) {\n        text.value.visit(this);\n    }\n    visitPipe(ast, context) {\n        this.usedPipes.add(ast.name);\n        return super.visitPipe(ast, context);\n    }\n    // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n    visitPropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyRead(ast, context);\n    }\n    visitSafePropertyRead(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitSafePropertyRead(ast, context);\n    }\n    visitPropertyWrite(ast, context) {\n        this.maybeMap(context, ast, ast.name);\n        return super.visitPropertyWrite(ast, context);\n    }\n    maybeMap(scope, ast, name) {\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n        // `AST` expression that maps to a `Variable` or `Reference`.\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\n            return;\n        }\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n        // probably a property on the top-level component context.\n        let target = this.scope.lookup(name);\n        if (target !== null) {\n            this.bindings.set(ast, target);\n        }\n    }\n}\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nclass R3BoundTarget {\n    constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\n        this.target = target;\n        this.directives = directives;\n        this.bindings = bindings;\n        this.references = references;\n        this.exprTargets = exprTargets;\n        this.symbols = symbols;\n        this.nestingLevel = nestingLevel;\n        this.templateEntities = templateEntities;\n        this.usedPipes = usedPipes;\n    }\n    getEntitiesInTemplateScope(template) {\n        return this.templateEntities.get(template) ?? new Set();\n    }\n    getDirectivesOfNode(node) {\n        return this.directives.get(node) || null;\n    }\n    getReferenceTarget(ref) {\n        return this.references.get(ref) || null;\n    }\n    getConsumerOfBinding(binding) {\n        return this.bindings.get(binding) || null;\n    }\n    getExpressionTarget(expr) {\n        return this.exprTargets.get(expr) || null;\n    }\n    getTemplateOfSymbol(symbol) {\n        return this.symbols.get(symbol) || null;\n    }\n    getNestingLevel(template) {\n        return this.nestingLevel.get(template) || 0;\n    }\n    getUsedDirectives() {\n        const set = new Set();\n        this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n        return Array.from(set.values());\n    }\n    getUsedPipes() {\n        return Array.from(this.usedPipes);\n    }\n}\nfunction extractTemplateEntities(rootScope) {\n    const entityMap = new Map();\n    function extractScopeEntities(scope) {\n        if (entityMap.has(scope.template)) {\n            return entityMap.get(scope.template);\n        }\n        const currentEntities = scope.namedEntities;\n        let templateEntities;\n        if (scope.parentScope !== null) {\n            templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n        }\n        else {\n            templateEntities = new Map(currentEntities);\n        }\n        entityMap.set(scope.template, templateEntities);\n        return templateEntities;\n    }\n    const scopesToProcess = [rootScope];\n    while (scopesToProcess.length > 0) {\n        const scope = scopesToProcess.pop();\n        for (const childScope of scope.childScopes.values()) {\n            scopesToProcess.push(childScope);\n        }\n        extractScopeEntities(scope);\n    }\n    const templateEntities = new Map();\n    for (const [template, entities] of entityMap) {\n        templateEntities.set(template, new Set(entities.values()));\n    }\n    return templateEntities;\n}\n\nfunction compileClassMetadata(metadata) {\n    // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n    // metadata.\n    const fnCall = importExpr(Identifiers.setClassMetadata).callFn([\n        metadata.type,\n        metadata.decorators,\n        metadata.ctorParameters ?? literal(null),\n        metadata.propDecorators ?? literal(null),\n    ]);\n    const iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n    return iife.callFn([]);\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';\nfunction compileDeclareClassMetadata(metadata) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', metadata.type);\n    definitionMap.set('decorators', metadata.decorators);\n    definitionMap.set('ctorParameters', metadata.ctorParameters);\n    definitionMap.set('propDecorators', metadata.propDecorators);\n    return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n\n/**\n * Creates an array literal expression from the given array, mapping all values to an expression\n * using the provided mapping function. If the array is empty or null, then null is returned.\n *\n * @param values The array to transfer into literal array expression.\n * @param mapper The logic to use for creating an expression for the array's values.\n * @returns An array literal expression representing `values`, or null if `values` is empty or\n * is itself null.\n */\nfunction toOptionalLiteralArray(values, mapper) {\n    if (values === null || values.length === 0) {\n        return null;\n    }\n    return literalArr(values.map(value => mapper(value)));\n}\n/**\n * Creates an object literal expression from the given object, mapping all values to an expression\n * using the provided mapping function. If the object has no keys, then null is returned.\n *\n * @param object The object to transfer into an object literal expression.\n * @param mapper The logic to use for creating an expression for the object's values.\n * @returns An object literal expression representing `object`, or null if `object` does not have\n * any keys.\n */\nfunction toOptionalLiteralMap(object, mapper) {\n    const entries = Object.keys(object).map(key => {\n        const value = object[key];\n        return { key, value: mapper(value), quoted: true };\n    });\n    if (entries.length > 0) {\n        return literalMap(entries);\n    }\n    else {\n        return null;\n    }\n}\nfunction compileDependencies(deps) {\n    if (deps === 'invalid') {\n        // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n        // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n        return literal('invalid');\n    }\n    else if (deps === null) {\n        return literal(null);\n    }\n    else {\n        return literalArr(deps.map(compileDependency));\n    }\n}\nfunction compileDependency(dep) {\n    const depMeta = new DefinitionMap();\n    depMeta.set('token', dep.token);\n    if (dep.attributeNameType !== null) {\n        depMeta.set('attribute', literal(true));\n    }\n    if (dep.host) {\n        depMeta.set('host', literal(true));\n    }\n    if (dep.optional) {\n        depMeta.set('optional', literal(true));\n    }\n    if (dep.self) {\n        depMeta.set('self', literal(true));\n    }\n    if (dep.skipSelf) {\n        depMeta.set('skipSelf', literal(true));\n    }\n    return depMeta.toLiteralMap();\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '14.0.0';\n/**\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\n */\nfunction compileDeclareDirectiveFromMetadata(meta) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n    const type = createDirectiveType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the directive metadata.\n */\nfunction createDirectiveDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n    definitionMap.set('version', literal('15.2.7'));\n    // e.g. `type: MyDirective`\n    definitionMap.set('type', meta.internalType);\n    if (meta.isStandalone) {\n        definitionMap.set('isStandalone', literal(meta.isStandalone));\n    }\n    // e.g. `selector: 'some-dir'`\n    if (meta.selector !== null) {\n        definitionMap.set('selector', literal(meta.selector));\n    }\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n    definitionMap.set('host', compileHostMetadata(meta.host));\n    definitionMap.set('providers', meta.providers);\n    if (meta.queries.length > 0) {\n        definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n    }\n    if (meta.viewQueries.length > 0) {\n        definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n    }\n    if (meta.exportAs !== null) {\n        definitionMap.set('exportAs', asLiteral(meta.exportAs));\n    }\n    if (meta.usesInheritance) {\n        definitionMap.set('usesInheritance', literal(true));\n    }\n    if (meta.lifecycle.usesOnChanges) {\n        definitionMap.set('usesOnChanges', literal(true));\n    }\n    if (meta.hostDirectives?.length) {\n        definitionMap.set('hostDirectives', createHostDirectives(meta.hostDirectives));\n    }\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    return definitionMap;\n}\n/**\n * Compiles the metadata of a single query into its partial declaration form as declared\n * by `R3DeclareQueryMetadata`.\n */\nfunction compileQuery(query) {\n    const meta = new DefinitionMap();\n    meta.set('propertyName', literal(query.propertyName));\n    if (query.first) {\n        meta.set('first', literal(true));\n    }\n    meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) :\n        convertFromMaybeForwardRefExpression(query.predicate));\n    if (!query.emitDistinctChangesOnly) {\n        // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n        // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n        meta.set('emitDistinctChangesOnly', literal(false));\n    }\n    else {\n        // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n    }\n    if (query.descendants) {\n        meta.set('descendants', literal(true));\n    }\n    meta.set('read', query.read);\n    if (query.static) {\n        meta.set('static', literal(true));\n    }\n    return meta.toLiteralMap();\n}\n/**\n * Compiles the host metadata into its partial declaration form as declared\n * in `R3DeclareDirectiveMetadata['host']`\n */\nfunction compileHostMetadata(meta) {\n    const hostMetadata = new DefinitionMap();\n    hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\n    hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n    hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n    if (meta.specialAttributes.styleAttr) {\n        hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n    }\n    if (meta.specialAttributes.classAttr) {\n        hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n    }\n    if (hostMetadata.values.length > 0) {\n        return hostMetadata.toLiteralMap();\n    }\n    else {\n        return null;\n    }\n}\nfunction createHostDirectives(hostDirectives) {\n    const expressions = hostDirectives.map(current => {\n        const keys = [{\n                key: 'directive',\n                value: current.isForwardReference ? generateForwardRef(current.directive.type) :\n                    current.directive.type,\n                quoted: false\n            }];\n        const inputsLiteral = current.inputs ? createHostDirectivesMappingArray(current.inputs) : null;\n        const outputsLiteral = current.outputs ? createHostDirectivesMappingArray(current.outputs) : null;\n        if (inputsLiteral) {\n            keys.push({ key: 'inputs', value: inputsLiteral, quoted: false });\n        }\n        if (outputsLiteral) {\n            keys.push({ key: 'outputs', value: outputsLiteral, quoted: false });\n        }\n        return literalMap(keys);\n    });\n    // If there's a forward reference, we generate a `function() { return [{directive: HostDir}] }`,\n    // otherwise we can save some bytes by using a plain array, e.g. `[{directive: HostDir}]`.\n    return literalArr(expressions);\n}\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n    const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n    const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n    const type = createComponentType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n    const definitionMap = createDirectiveDefinitionMap(meta);\n    definitionMap.set('template', getTemplateExpression(template, templateInfo));\n    if (templateInfo.isInline) {\n        definitionMap.set('isInline', literal(true));\n    }\n    definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n    definitionMap.set('dependencies', compileUsedDependenciesMetadata(meta));\n    definitionMap.set('viewProviders', meta.viewProviders);\n    definitionMap.set('animations', meta.animations);\n    if (meta.changeDetection !== undefined) {\n        definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy)\n            .prop(ChangeDetectionStrategy[meta.changeDetection]));\n    }\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n        definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));\n    }\n    if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n        definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));\n    }\n    if (template.preserveWhitespaces === true) {\n        definitionMap.set('preserveWhitespaces', literal(true));\n    }\n    return definitionMap;\n}\nfunction getTemplateExpression(template, templateInfo) {\n    // If the template has been defined using a direct literal, we use that expression directly\n    // without any modifications. This is ensures proper source mapping from the partially\n    // compiled code to the source file declaring the template. Note that this does not capture\n    // template literals referenced indirectly through an identifier.\n    if (templateInfo.inlineTemplateLiteralExpression !== null) {\n        return templateInfo.inlineTemplateLiteralExpression;\n    }\n    // If the template is defined inline but not through a literal, the template has been resolved\n    // through static interpretation. We create a literal but cannot provide any source span. Note\n    // that we cannot use the expression defining the template because the linker expects the template\n    // to be defined as a literal in the declaration.\n    if (templateInfo.isInline) {\n        return literal(templateInfo.content, null, null);\n    }\n    // The template is external so we must synthesize an expression node with\n    // the appropriate source-span.\n    const contents = templateInfo.content;\n    const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n    const start = new ParseLocation(file, 0, 0, 0);\n    const end = computeEndLocation(file, contents);\n    const span = new ParseSourceSpan(start, end);\n    return literal(contents, null, span);\n}\nfunction computeEndLocation(file, contents) {\n    const length = contents.length;\n    let lineStart = 0;\n    let lastLineStart = 0;\n    let line = 0;\n    do {\n        lineStart = contents.indexOf('\\n', lastLineStart);\n        if (lineStart !== -1) {\n            lastLineStart = lineStart + 1;\n            line++;\n        }\n    } while (lineStart !== -1);\n    return new ParseLocation(file, length, line, length - lastLineStart);\n}\nfunction compileUsedDependenciesMetadata(meta) {\n    const wrapType = meta.declarationListEmitMode !== 0 /* DeclarationListEmitMode.Direct */ ?\n        generateForwardRef :\n        (expr) => expr;\n    return toOptionalLiteralArray(meta.declarations, decl => {\n        switch (decl.kind) {\n            case R3TemplateDependencyKind.Directive:\n                const dirMeta = new DefinitionMap();\n                dirMeta.set('kind', literal(decl.isComponent ? 'component' : 'directive'));\n                dirMeta.set('type', wrapType(decl.type));\n                dirMeta.set('selector', literal(decl.selector));\n                dirMeta.set('inputs', toOptionalLiteralArray(decl.inputs, literal));\n                dirMeta.set('outputs', toOptionalLiteralArray(decl.outputs, literal));\n                dirMeta.set('exportAs', toOptionalLiteralArray(decl.exportAs, literal));\n                return dirMeta.toLiteralMap();\n            case R3TemplateDependencyKind.Pipe:\n                const pipeMeta = new DefinitionMap();\n                pipeMeta.set('kind', literal('pipe'));\n                pipeMeta.set('type', wrapType(decl.type));\n                pipeMeta.set('name', literal(decl.name));\n                return pipeMeta.toLiteralMap();\n            case R3TemplateDependencyKind.NgModule:\n                const ngModuleMeta = new DefinitionMap();\n                ngModuleMeta.set('kind', literal('ngmodule'));\n                ngModuleMeta.set('type', wrapType(decl.type));\n                return ngModuleMeta.toLiteralMap();\n        }\n    });\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\nfunction compileDeclareFactoryFunction(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('deps', compileDependencies(meta.deps));\n    definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget$1[meta.target]));\n    return {\n        expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n        statements: [],\n        type: createFactoryType(meta),\n    };\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\n/**\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\n */\nfunction compileDeclareInjectableFromMetadata(meta) {\n    const definitionMap = createInjectableDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectableType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\n */\nfunction createInjectableDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    // Only generate providedIn property if it has a non-null value\n    if (meta.providedIn !== undefined) {\n        const providedIn = convertFromMaybeForwardRefExpression(meta.providedIn);\n        if (providedIn.value !== null) {\n            definitionMap.set('providedIn', providedIn);\n        }\n    }\n    if (meta.useClass !== undefined) {\n        definitionMap.set('useClass', convertFromMaybeForwardRefExpression(meta.useClass));\n    }\n    if (meta.useExisting !== undefined) {\n        definitionMap.set('useExisting', convertFromMaybeForwardRefExpression(meta.useExisting));\n    }\n    if (meta.useValue !== undefined) {\n        definitionMap.set('useValue', convertFromMaybeForwardRefExpression(meta.useValue));\n    }\n    // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n    // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n    // with `convertFromProviderExpression()`.\n    if (meta.useFactory !== undefined) {\n        definitionMap.set('useFactory', meta.useFactory);\n    }\n    if (meta.deps !== undefined) {\n        definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n    }\n    return definitionMap;\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\nfunction compileDeclareInjectorFromMetadata(meta) {\n    const definitionMap = createInjectorDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n    const type = createInjectorType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\n */\nfunction createInjectorDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    definitionMap.set('providers', meta.providers);\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', literalArr(meta.imports));\n    }\n    return definitionMap;\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '14.0.0';\nfunction compileDeclareNgModuleFromMetadata(meta) {\n    const definitionMap = createNgModuleDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n    const type = createNgModuleType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\n */\nfunction createNgModuleDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    definitionMap.set('type', meta.internalType);\n    // We only generate the keys in the metadata if the arrays contain values.\n    // We must wrap the arrays inside a function if any of the values are a forward reference to a\n    // not-yet-declared class. This is to support JIT execution of the `ngDeclareNgModule()` call.\n    // In the linker these wrappers are stripped and then reapplied for the `defineNgModule()` call.\n    if (meta.bootstrap.length > 0) {\n        definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n    }\n    if (meta.declarations.length > 0) {\n        definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n    if (meta.imports.length > 0) {\n        definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n    if (meta.exports.length > 0) {\n        definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n    if (meta.schemas !== null && meta.schemas.length > 0) {\n        definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\n    }\n    if (meta.id !== null) {\n        definitionMap.set('id', meta.id);\n    }\n    return definitionMap;\n}\n\n/**\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\n * must update this constant to prevent old partial-linkers from incorrectly processing the\n * declaration.\n *\n * Do not include any prerelease in these versions as they are ignored.\n */\nconst MINIMUM_PARTIAL_LINKER_VERSION = '14.0.0';\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nfunction compileDeclarePipeFromMetadata(meta) {\n    const definitionMap = createPipeDefinitionMap(meta);\n    const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n    const type = createPipeType(meta);\n    return { expression, type, statements: [] };\n}\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\n */\nfunction createPipeDefinitionMap(meta) {\n    const definitionMap = new DefinitionMap();\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n    definitionMap.set('version', literal('15.2.7'));\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\n    // e.g. `type: MyPipe`\n    definitionMap.set('type', meta.internalType);\n    if (meta.isStandalone) {\n        definitionMap.set('isStandalone', literal(meta.isStandalone));\n    }\n    // e.g. `name: \"myPipe\"`\n    definitionMap.set('name', literal(meta.pipeName));\n    if (meta.pure === false) {\n        // e.g. `pure: false`\n        definitionMap.set('pure', literal(meta.pure));\n    }\n    return definitionMap;\n}\n\n//////////////////////////////////////\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\npublishFacade(_global);\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n// This file is not used to build this module. It is only used during editing\n\n// This file is not used to build this module. It is only used during editing\n\n\n//# sourceMappingURL=compiler.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvZmVzbTIwMjAvY29tcGlsZXIubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvY29tcGlsZXIvZmVzbTIwMjAvY29tcGlsZXIubWpzP2RlMGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYxNS4yLjdcbiAqIChjKSAyMDEwLTIwMjIgR29vZ2xlIExMQy4gaHR0cHM6Ly9hbmd1bGFyLmlvL1xuICogTGljZW5zZTogTUlUXG4gKi9cblxuY29uc3QgX1NFTEVDVE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoJyhcXFxcOm5vdFxcXFwoKXwnICsgLy8gMTogXCI6bm90KFwiXG4gICAgJygoW1xcXFwuXFxcXCNdPylbLVxcXFx3XSspfCcgKyAvLyAyOiBcInRhZ1wiOyAzOiBcIi5cIi9cIiNcIjtcbiAgICAvLyBcIi1cIiBzaG91bGQgYXBwZWFyIGZpcnN0IGluIHRoZSByZWdleHAgYmVsb3cgYXMgRkYzMSBwYXJzZXMgXCJbLi1cXHddXCIgYXMgYSByYW5nZVxuICAgIC8vIDQ6IGF0dHJpYnV0ZTsgNTogYXR0cmlidXRlX3N0cmluZzsgNjogYXR0cmlidXRlX3ZhbHVlXG4gICAgJyg/OlxcXFxbKFstLlxcXFx3KlxcXFxcXFxcJF0rKSg/Oj0oW1xcXCJcXCddPykoW15cXFxcXVxcXCJcXCddKilcXFxcNSk/XFxcXF0pfCcgKyAvLyBcIltuYW1lXVwiLCBcIltuYW1lPXZhbHVlXVwiLFxuICAgIC8vIFwiW25hbWU9XCJ2YWx1ZVwiXVwiLFxuICAgIC8vIFwiW25hbWU9J3ZhbHVlJ11cIlxuICAgICcoXFxcXCkpfCcgKyAvLyA3OiBcIilcIlxuICAgICcoXFxcXHMqLFxcXFxzKiknLCAvLyA4OiBcIixcIlxuJ2cnKTtcbi8qKlxuICogQSBjc3Mgc2VsZWN0b3IgY29udGFpbnMgYW4gZWxlbWVudCBuYW1lLFxuICogY3NzIGNsYXNzZXMgYW5kIGF0dHJpYnV0ZS92YWx1ZSBwYWlycyB3aXRoIHRoZSBwdXJwb3NlXG4gKiBvZiBzZWxlY3Rpbmcgc3Vic2V0cyBvdXQgb2YgdGhlbS5cbiAqL1xuY2xhc3MgQ3NzU2VsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmNsYXNzTmFtZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZWxlY3RvcnMgYXJlIGVuY29kZWQgaW4gcGFpcnMgd2hlcmU6XG4gICAgICAgICAqIC0gZXZlbiBsb2NhdGlvbnMgYXJlIGF0dHJpYnV0ZSBuYW1lc1xuICAgICAgICAgKiAtIG9kZCBsb2NhdGlvbnMgYXJlIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqIFNlbGVjdG9yOiBgW2tleTE9dmFsdWUxXVtrZXkyXWAgd291bGQgcGFyc2UgdG86XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBbJ2tleTEnLCAndmFsdWUxJywgJ2tleTInLCAnJ11cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dHJzID0gW107XG4gICAgICAgIHRoaXMubm90U2VsZWN0b3JzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGNvbnN0IF9hZGRSZXN1bHQgPSAocmVzLCBjc3NTZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChjc3NTZWwubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgIWNzc1NlbC5lbGVtZW50ICYmIGNzc1NlbC5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgY3NzU2VsLmF0dHJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY3NzU2VsLmVsZW1lbnQgPSAnKic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChjc3NTZWwpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgY3NzU2VsZWN0b3IgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICBsZXQgaW5Ob3QgPSBmYWxzZTtcbiAgICAgICAgX1NFTEVDVE9SX1JFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAobWF0Y2ggPSBfU0VMRUNUT1JfUkVHRVhQLmV4ZWMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMSAvKiBTZWxlY3RvclJlZ2V4cC5OT1QgKi9dKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluTm90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGluZyA6bm90IGluIGEgc2VsZWN0b3IgaXMgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5Ob3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgQ3NzU2VsZWN0b3IoKTtcbiAgICAgICAgICAgICAgICBjc3NTZWxlY3Rvci5ub3RTZWxlY3RvcnMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IG1hdGNoWzIgLyogU2VsZWN0b3JSZWdleHAuVEFHICovXTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBtYXRjaFszIC8qIFNlbGVjdG9yUmVnZXhwLlBSRUZJWCAqL107XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNoYXNoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQXR0cmlidXRlKCdpZCcsIHRhZy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZWZpeCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsYXNzXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuYWRkQ2xhc3NOYW1lKHRhZy5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0RWxlbWVudCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG1hdGNoWzQgLyogU2VsZWN0b3JSZWdleHAuQVRUUklCVVRFICovXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFkZEF0dHJpYnV0ZShjdXJyZW50LnVuZXNjYXBlQXR0cmlidXRlKGF0dHJpYnV0ZSksIG1hdGNoWzYgLyogU2VsZWN0b3JSZWdleHAuQVRUUklCVVRFX1ZBTFVFICovXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNyAvKiBTZWxlY3RvclJlZ2V4cC5OT1RfRU5EICovXSkge1xuICAgICAgICAgICAgICAgIGluTm90ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGNzc1NlbGVjdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzggLyogU2VsZWN0b3JSZWdleHAuU0VQQVJBVE9SICovXSkge1xuICAgICAgICAgICAgICAgIGlmIChpbk5vdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNlbGVjdG9ycyBpbiA6bm90IGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIGNzc1NlbGVjdG9yID0gY3VycmVudCA9IG5ldyBDc3NTZWxlY3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9hZGRSZXN1bHQocmVzdWx0cywgY3NzU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5lc2NhcGUgYFxcJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIGJ1dCB3ZSBtaWdodCB3YW50IHRvIG1hdGNoIGFuIGF0dHJpYnV0ZSB0aGF0IGNvbnRhaW5zIGAkYC5cbiAgICAgKiBbTUROIHdlYiBsaW5rIGZvciBtb3JlXG4gICAgICogaW5mb10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0F0dHJpYnV0ZV9zZWxlY3RvcnMpLlxuICAgICAqIEBwYXJhbSBhdHRyIHRoZSBhdHRyaWJ1dGUgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICovXG4gICAgdW5lc2NhcGVBdHRyaWJ1dGUoYXR0cikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGxldCBlc2NhcGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBhdHRyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyQnICYmICFlc2NhcGluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gYXR0cmlidXRlIHNlbGVjdG9yIFwiJHthdHRyfVwiLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVuZXNjYXBlZCBcIiRcIiBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgZXNjYXBlIHdpdGggXCJcXFxcJFwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVzY2FwZSBgJGAgc2VxdWVuY2VzIGZyb20gdGhlIENTUyBhdHRyaWJ1dGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIGAkYCBjYW4gaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBDU1Mgc2VsZWN0b3JzLFxuICAgICAqIHdpdGggdGhpcyBtZXRob2Qgd2UgYXJlIGVzY2FwaW5nIGAkYCB3aXRoIGBcXCQnLlxuICAgICAqIFtNRE4gd2ViIGxpbmsgZm9yIG1vcmVcbiAgICAgKiBpbmZvXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQXR0cmlidXRlX3NlbGVjdG9ycykuXG4gICAgICogQHBhcmFtIGF0dHIgdGhlIGF0dHJpYnV0ZSB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVzY2FwZUF0dHJpYnV0ZShhdHRyKSB7XG4gICAgICAgIHJldHVybiBhdHRyLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpO1xuICAgIH1cbiAgICBpc0VsZW1lbnRTZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzRWxlbWVudFNlbGVjdG9yKCkgJiYgdGhpcy5jbGFzc05hbWVzLmxlbmd0aCA9PSAwICYmIHRoaXMuYXR0cnMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgIHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaGFzRWxlbWVudFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmVsZW1lbnQ7XG4gICAgfVxuICAgIHNldEVsZW1lbnQoZWxlbWVudCA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0QXR0cnMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdjbGFzcycsIHRoaXMuY2xhc3NOYW1lcy5qb2luKCcgJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KHRoaXMuYXR0cnMpO1xuICAgIH1cbiAgICBhZGRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPSAnJykge1xuICAgICAgICB0aGlzLmF0dHJzLnB1c2gobmFtZSwgdmFsdWUgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSB8fCAnJyk7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgcmVzID0gdGhpcy5lbGVtZW50IHx8ICcnO1xuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZXMuZm9yRWFjaChrbGFzcyA9PiByZXMgKz0gYC4ke2tsYXNzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5lc2NhcGVBdHRyaWJ1dGUodGhpcy5hdHRyc1tpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmF0dHJzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICByZXMgKz0gYFske25hbWV9JHt2YWx1ZSA/ICc9JyArIHZhbHVlIDogJyd9XWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMuZm9yRWFjaChub3RTZWxlY3RvciA9PiByZXMgKz0gYDpub3QoJHtub3RTZWxlY3Rvcn0pYCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkcyBhIGxpc3Qgb2YgQ3NzU2VsZWN0b3JzIGFuZCBhbGxvd3MgdG8gY2FsY3VsYXRlIHdoaWNoIG9uZXNcbiAqIGFyZSBjb250YWluZWQgaW4gYSBnaXZlbiBDc3NTZWxlY3Rvci5cbiAqL1xuY2xhc3MgU2VsZWN0b3JNYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFBhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NsYXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jbGFzc1BhcnRpYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2F0dHJWYWx1ZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fbGlzdENvbnRleHRzID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVOb3RNYXRjaGVyKG5vdFNlbGVjdG9ycykge1xuICAgICAgICBjb25zdCBub3RNYXRjaGVyID0gbmV3IFNlbGVjdG9yTWF0Y2hlcigpO1xuICAgICAgICBub3RNYXRjaGVyLmFkZFNlbGVjdGFibGVzKG5vdFNlbGVjdG9ycywgbnVsbCk7XG4gICAgICAgIHJldHVybiBub3RNYXRjaGVyO1xuICAgIH1cbiAgICBhZGRTZWxlY3RhYmxlcyhjc3NTZWxlY3RvcnMsIGNhbGxiYWNrQ3R4dCkge1xuICAgICAgICBsZXQgbGlzdENvbnRleHQgPSBudWxsO1xuICAgICAgICBpZiAoY3NzU2VsZWN0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxpc3RDb250ZXh0ID0gbmV3IFNlbGVjdG9yTGlzdENvbnRleHQoY3NzU2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0cy5wdXNoKGxpc3RDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzc1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWRkU2VsZWN0YWJsZShjc3NTZWxlY3RvcnNbaV0sIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBvYmplY3QgdGhhdCBjYW4gYmUgZm91bmQgbGF0ZXIgb24gYnkgY2FsbGluZyBgbWF0Y2hgLlxuICAgICAqIEBwYXJhbSBjc3NTZWxlY3RvciBBIGNzcyBzZWxlY3RvclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0N0eHQgQW4gb3BhcXVlIG9iamVjdCB0aGF0IHdpbGwgYmUgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIG9mIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uXG4gICAgICovXG4gICAgX2FkZFNlbGVjdGFibGUoY3NzU2VsZWN0b3IsIGNhbGxiYWNrQ3R4dCwgbGlzdENvbnRleHQpIHtcbiAgICAgICAgbGV0IG1hdGNoZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gY3NzU2VsZWN0b3IuZWxlbWVudDtcbiAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IGNzc1NlbGVjdG9yLmNsYXNzTmFtZXM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gY3NzU2VsZWN0b3IuYXR0cnM7XG4gICAgICAgIGNvbnN0IHNlbGVjdGFibGUgPSBuZXcgU2VsZWN0b3JDb250ZXh0KGNzc1NlbGVjdG9yLCBjYWxsYmFja0N0eHQsIGxpc3RDb250ZXh0KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVGVybWluYWwgPSBhdHRycy5sZW5ndGggPT09IDAgJiYgY2xhc3NOYW1lcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICBpZiAoaXNUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2VsZW1lbnRNYXAsIGVsZW1lbnQsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gYXR0cnMubGVuZ3RoID09PSAwICYmIGkgPT09IGNsYXNzTmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpc1Rlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKG1hdGNoZXIuX2NsYXNzTWFwLCBjbGFzc05hbWUsIHNlbGVjdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwobWF0Y2hlci5fY2xhc3NQYXJ0aWFsTWFwLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Rlcm1pbmFsID0gaSA9PT0gYXR0cnMubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxNYXAgPSBtYXRjaGVyLl9hdHRyVmFsdWVNYXA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtaW5hbFZhbHVlc01hcCA9IHRlcm1pbmFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbFZhbHVlc01hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVybWluYWxWYWx1ZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXJtaW5hbE1hcC5zZXQobmFtZSwgdGVybWluYWxWYWx1ZXNNYXApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRlcm1pbmFsKHRlcm1pbmFsVmFsdWVzTWFwLCB2YWx1ZSwgc2VsZWN0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsTWFwID0gbWF0Y2hlci5fYXR0clZhbHVlUGFydGlhbE1hcDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnRpYWxWYWx1ZXNNYXAgPSBwYXJ0aWFsTWFwLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWFsVmFsdWVzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsVmFsdWVzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbE1hcC5zZXQobmFtZSwgcGFydGlhbFZhbHVlc01hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlciA9IHRoaXMuX2FkZFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkVGVybWluYWwobWFwLCBuYW1lLCBzZWxlY3RhYmxlKSB7XG4gICAgICAgIGxldCB0ZXJtaW5hbExpc3QgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXRlcm1pbmFsTGlzdCkge1xuICAgICAgICAgICAgdGVybWluYWxMaXN0ID0gW107XG4gICAgICAgICAgICBtYXAuc2V0KG5hbWUsIHRlcm1pbmFsTGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGVybWluYWxMaXN0LnB1c2goc2VsZWN0YWJsZSk7XG4gICAgfVxuICAgIF9hZGRQYXJ0aWFsKG1hcCwgbmFtZSkge1xuICAgICAgICBsZXQgbWF0Y2hlciA9IG1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbWF0Y2hlcikge1xuICAgICAgICAgICAgbWF0Y2hlciA9IG5ldyBTZWxlY3Rvck1hdGNoZXIoKTtcbiAgICAgICAgICAgIG1hcC5zZXQobmFtZSwgbWF0Y2hlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdmlhIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIHdob3NlIGNzcyBzZWxlY3RvciBpcyBjb250YWluZWQgaW4gdGhlIGdpdmVuIGNzcyBzZWxlY3Rvci5cbiAgICAgKiBAcGFyYW0gY3NzU2VsZWN0b3IgQSBjc3Mgc2VsZWN0b3JcbiAgICAgKiBAcGFyYW0gbWF0Y2hlZENhbGxiYWNrIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgb2JqZWN0IGhhbmRlZCBpbnRvIGBhZGRTZWxlY3RhYmxlYFxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB0cnVlIGlmIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICovXG4gICAgbWF0Y2goY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjc3NTZWxlY3Rvci5lbGVtZW50O1xuICAgICAgICBjb25zdCBjbGFzc05hbWVzID0gY3NzU2VsZWN0b3IuY2xhc3NOYW1lcztcbiAgICAgICAgY29uc3QgYXR0cnMgPSBjc3NTZWxlY3Rvci5hdHRycztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXN0Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RDb250ZXh0c1tpXS5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fZWxlbWVudE1hcCwgZWxlbWVudCwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9tYXRjaFBhcnRpYWwodGhpcy5fZWxlbWVudFBhcnRpYWxNYXAsIGVsZW1lbnQsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8XG4gICAgICAgICAgICByZXN1bHQ7XG4gICAgICAgIGlmIChjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoVGVybWluYWwodGhpcy5fY2xhc3NNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21hdGNoUGFydGlhbCh0aGlzLl9jbGFzc1BhcnRpYWxNYXAsIGNsYXNzTmFtZSwgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYXR0cnNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWxWYWx1ZXNNYXAgPSB0aGlzLl9hdHRyVmFsdWVNYXAuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgJycsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF0Y2hUZXJtaW5hbCh0ZXJtaW5hbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVmFsdWVzTWFwID0gdGhpcy5fYXR0clZhbHVlUGFydGlhbE1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX21hdGNoUGFydGlhbChwYXJ0aWFsVmFsdWVzTWFwLCAnJywgY3NzU2VsZWN0b3IsIG1hdGNoZWRDYWxsYmFjaykgfHwgcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXRjaFBhcnRpYWwocGFydGlhbFZhbHVlc01hcCwgdmFsdWUsIGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spIHx8IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX21hdGNoVGVybWluYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RhYmxlcyA9IG1hcC5nZXQobmFtZSkgfHwgW107XG4gICAgICAgIGNvbnN0IHN0YXJTZWxlY3RhYmxlcyA9IG1hcC5nZXQoJyonKTtcbiAgICAgICAgaWYgKHN0YXJTZWxlY3RhYmxlcykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZXMgPSBzZWxlY3RhYmxlcy5jb25jYXQoc3RhclNlbGVjdGFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0YWJsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlbGVjdGFibGU7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0YWJsZSA9IHNlbGVjdGFibGVzW2ldO1xuICAgICAgICAgICAgcmVzdWx0ID0gc2VsZWN0YWJsZS5maW5hbGl6ZShjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB8fCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9tYXRjaFBhcnRpYWwobWFwLCBuYW1lLCBjc3NTZWxlY3RvciwgbWF0Y2hlZENhbGxiYWNrKSB7XG4gICAgICAgIGlmICghbWFwIHx8IHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5lc3RlZFNlbGVjdG9yID0gbWFwLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuZXN0ZWRTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGdldCByaWQgb2YgcmVjdXJzaW9uIGFuZCBtZWFzdXJlIGFnYWluXG4gICAgICAgIC8vIFRPRE8ocGVyZik6IGRvbid0IHBhc3MgdGhlIHdob2xlIHNlbGVjdG9yIGludG8gdGhlIHJlY3Vyc2lvbixcbiAgICAgICAgLy8gYnV0IG9ubHkgdGhlIG5vdCBwcm9jZXNzZWQgcGFydHNcbiAgICAgICAgcmV0dXJuIG5lc3RlZFNlbGVjdG9yLm1hdGNoKGNzc1NlbGVjdG9yLCBtYXRjaGVkQ2FsbGJhY2spO1xuICAgIH1cbn1cbmNsYXNzIFNlbGVjdG9yTGlzdENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9ycykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5hbHJlYWR5TWF0Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn1cbi8vIFN0b3JlIGNvbnRleHQgdG8gcGFzcyBiYWNrIHNlbGVjdG9yIGFuZCBjb250ZXh0IHdoZW4gYSBzZWxlY3RvciBpcyBtYXRjaGVkXG5jbGFzcyBTZWxlY3RvckNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBjYkNvbnRleHQsIGxpc3RDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYkNvbnRleHQgPSBjYkNvbnRleHQ7XG4gICAgICAgIHRoaXMubGlzdENvbnRleHQgPSBsaXN0Q29udGV4dDtcbiAgICAgICAgdGhpcy5ub3RTZWxlY3RvcnMgPSBzZWxlY3Rvci5ub3RTZWxlY3RvcnM7XG4gICAgfVxuICAgIGZpbmFsaXplKGNzc1NlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMubm90U2VsZWN0b3JzLmxlbmd0aCA+IDAgJiYgKCF0aGlzLmxpc3RDb250ZXh0IHx8ICF0aGlzLmxpc3RDb250ZXh0LmFscmVhZHlNYXRjaGVkKSkge1xuICAgICAgICAgICAgY29uc3Qgbm90TWF0Y2hlciA9IFNlbGVjdG9yTWF0Y2hlci5jcmVhdGVOb3RNYXRjaGVyKHRoaXMubm90U2VsZWN0b3JzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9ICFub3RNYXRjaGVyLm1hdGNoKGNzc1NlbGVjdG9yLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ICYmIGNhbGxiYWNrICYmICghdGhpcy5saXN0Q29udGV4dCB8fCAhdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Q29udGV4dC5hbHJlYWR5TWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLnNlbGVjdG9yLCB0aGlzLmNiQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8vIEF0dGVudGlvbjpcbi8vIFN0b3JlcyB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIHdoZW4gdGhlIGBlbWl0RGlzdGluY3RDaGFuZ2VzT25seWAgaXMgbm90XG4vLyBleHBsaWNpdGx5IHNldC5cbmNvbnN0IGVtaXREaXN0aW5jdENoYW5nZXNPbmx5RGVmYXVsdFZhbHVlID0gdHJ1ZTtcbnZhciBWaWV3RW5jYXBzdWxhdGlvbjtcbihmdW5jdGlvbiAoVmlld0VuY2Fwc3VsYXRpb24pIHtcbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIkVtdWxhdGVkXCJdID0gMF0gPSBcIkVtdWxhdGVkXCI7XG4gICAgLy8gSGlzdG9yaWNhbGx5IHRoZSAxIHZhbHVlIHdhcyBmb3IgYE5hdGl2ZWAgZW5jYXBzdWxhdGlvbiB3aGljaCBoYXMgYmVlbiByZW1vdmVkIGFzIG9mIHYxMS5cbiAgICBWaWV3RW5jYXBzdWxhdGlvbltWaWV3RW5jYXBzdWxhdGlvbltcIk5vbmVcIl0gPSAyXSA9IFwiTm9uZVwiO1xuICAgIFZpZXdFbmNhcHN1bGF0aW9uW1ZpZXdFbmNhcHN1bGF0aW9uW1wiU2hhZG93RG9tXCJdID0gM10gPSBcIlNoYWRvd0RvbVwiO1xufSkoVmlld0VuY2Fwc3VsYXRpb24gfHwgKFZpZXdFbmNhcHN1bGF0aW9uID0ge30pKTtcbnZhciBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIk9uUHVzaFwiXSA9IDBdID0gXCJPblB1c2hcIjtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVtcIkRlZmF1bHRcIl0gPSAxXSA9IFwiRGVmYXVsdFwiO1xufSkoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfHwgKENoYW5nZURldGVjdGlvblN0cmF0ZWd5ID0ge30pKTtcbmNvbnN0IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEgPSB7XG4gICAgbmFtZTogJ2N1c3RvbS1lbGVtZW50cydcbn07XG5jb25zdCBOT19FUlJPUlNfU0NIRU1BID0ge1xuICAgIG5hbWU6ICduby1lcnJvcnMtc2NoZW1hJ1xufTtcbmNvbnN0IFR5cGUkMSA9IEZ1bmN0aW9uO1xudmFyIFNlY3VyaXR5Q29udGV4dDtcbihmdW5jdGlvbiAoU2VjdXJpdHlDb250ZXh0KSB7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJIVE1MXCJdID0gMV0gPSBcIkhUTUxcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU1RZTEVcIl0gPSAyXSA9IFwiU1RZTEVcIjtcbiAgICBTZWN1cml0eUNvbnRleHRbU2VjdXJpdHlDb250ZXh0W1wiU0NSSVBUXCJdID0gM10gPSBcIlNDUklQVFwiO1xuICAgIFNlY3VyaXR5Q29udGV4dFtTZWN1cml0eUNvbnRleHRbXCJVUkxcIl0gPSA0XSA9IFwiVVJMXCI7XG4gICAgU2VjdXJpdHlDb250ZXh0W1NlY3VyaXR5Q29udGV4dFtcIlJFU09VUkNFX1VSTFwiXSA9IDVdID0gXCJSRVNPVVJDRV9VUkxcIjtcbn0pKFNlY3VyaXR5Q29udGV4dCB8fCAoU2VjdXJpdHlDb250ZXh0ID0ge30pKTtcbnZhciBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneTtcbihmdW5jdGlvbiAoTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kpIHtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIkVycm9yXCJdID0gMF0gPSBcIkVycm9yXCI7XG4gICAgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3lbXCJXYXJuaW5nXCJdID0gMV0gPSBcIldhcm5pbmdcIjtcbiAgICBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneVtcIklnbm9yZVwiXSA9IDJdID0gXCJJZ25vcmVcIjtcbn0pKE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5IHx8IChNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IHt9KSk7XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICBjb25zdCBjbGFzc2VzID0gc2VsZWN0b3IuY2xhc3NOYW1lcyAmJiBzZWxlY3Rvci5jbGFzc05hbWVzLmxlbmd0aCA/XG4gICAgICAgIFs4IC8qIFNlbGVjdG9yRmxhZ3MuQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgW107XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBzZWxlY3Rvci5lbGVtZW50ICYmIHNlbGVjdG9yLmVsZW1lbnQgIT09ICcqJyA/IHNlbGVjdG9yLmVsZW1lbnQgOiAnJztcbiAgICByZXR1cm4gW2VsZW1lbnROYW1lLCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc107XG59XG5mdW5jdGlvbiBwYXJzZXJTZWxlY3RvclRvTmVnYXRpdmVTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBzZWxlY3Rvci5jbGFzc05hbWVzICYmIHNlbGVjdG9yLmNsYXNzTmFtZXMubGVuZ3RoID9cbiAgICAgICAgWzggLyogU2VsZWN0b3JGbGFncy5DTEFTUyAqLywgLi4uc2VsZWN0b3IuY2xhc3NOYW1lc10gOlxuICAgICAgICBbXTtcbiAgICBpZiAoc2VsZWN0b3IuZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMSAvKiBTZWxlY3RvckZsYWdzLk5PVCAqLyB8IDQgLyogU2VsZWN0b3JGbGFncy5FTEVNRU5UICovLCBzZWxlY3Rvci5lbGVtZW50LCAuLi5zZWxlY3Rvci5hdHRycywgLi4uY2xhc3Nlc1xuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3Rvci5hdHRycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFsxIC8qIFNlbGVjdG9yRmxhZ3MuTk9UICovIHwgMiAvKiBTZWxlY3RvckZsYWdzLkFUVFJJQlVURSAqLywgLi4uc2VsZWN0b3IuYXR0cnMsIC4uLmNsYXNzZXNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yLmNsYXNzTmFtZXMgJiYgc2VsZWN0b3IuY2xhc3NOYW1lcy5sZW5ndGggP1xuICAgICAgICAgICAgWzEgLyogU2VsZWN0b3JGbGFncy5OT1QgKi8gfCA4IC8qIFNlbGVjdG9yRmxhZ3MuQ0xBU1MgKi8sIC4uLnNlbGVjdG9yLmNsYXNzTmFtZXNdIDpcbiAgICAgICAgICAgIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlclNlbGVjdG9yVG9SM1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcG9zaXRpdmUgPSBwYXJzZXJTZWxlY3RvclRvU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gc2VsZWN0b3Iubm90U2VsZWN0b3JzICYmIHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5sZW5ndGggP1xuICAgICAgICBzZWxlY3Rvci5ub3RTZWxlY3RvcnMubWFwKG5vdFNlbGVjdG9yID0+IHBhcnNlclNlbGVjdG9yVG9OZWdhdGl2ZVNlbGVjdG9yKG5vdFNlbGVjdG9yKSkgOlxuICAgICAgICBbXTtcbiAgICByZXR1cm4gcG9zaXRpdmUuY29uY2F0KC4uLm5lZ2F0aXZlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBDc3NTZWxlY3Rvci5wYXJzZShzZWxlY3RvcikubWFwKHBhcnNlclNlbGVjdG9yVG9SM1NlbGVjdG9yKSA6IFtdO1xufVxuXG52YXIgY29yZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWU6IGVtaXREaXN0aW5jdENoYW5nZXNPbmx5RGVmYXVsdFZhbHVlLFxuICAgIGdldCBWaWV3RW5jYXBzdWxhdGlvbiAoKSB7IHJldHVybiBWaWV3RW5jYXBzdWxhdGlvbjsgfSxcbiAgICBnZXQgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgKCkgeyByZXR1cm4gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3k7IH0sXG4gICAgQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQTogQ1VTVE9NX0VMRU1FTlRTX1NDSEVNQSxcbiAgICBOT19FUlJPUlNfU0NIRU1BOiBOT19FUlJPUlNfU0NIRU1BLFxuICAgIFR5cGU6IFR5cGUkMSxcbiAgICBnZXQgU2VjdXJpdHlDb250ZXh0ICgpIHsgcmV0dXJuIFNlY3VyaXR5Q29udGV4dDsgfSxcbiAgICBnZXQgTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgKCkgeyByZXR1cm4gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3k7IH0sXG4gICAgcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcjogcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvclxufSk7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpZyBpbnRlZ2VyIHVzaW5nIGEgYnVmZmVyIG9mIGl0cyBpbmRpdmlkdWFsIGRpZ2l0cywgd2l0aCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnRcbiAqIGRpZ2l0IHN0b3JlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSAobGl0dGxlIGVuZGlhbikuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGVhY2ggaW5zdGFuY2UgaXMgbXV0YWJsZS4gVGhlIGFkZGl0aW9uIG9wZXJhdGlvbiBjYW4gYmUgZG9uZSBpbi1wbGFjZVxuICogdG8gcmVkdWNlIG1lbW9yeSBwcmVzc3VyZSBvZiBhbGxvY2F0aW9uIGZvciB0aGUgZGlnaXRzIGFycmF5LlxuICovXG5jbGFzcyBCaWdJbnRlZ2VyIHtcbiAgICBzdGF0aWMgemVybygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKFswXSk7XG4gICAgfVxuICAgIHN0YXRpYyBvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnSW50ZWdlcihbMV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmlnIGludGVnZXIgdXNpbmcgaXRzIGluZGl2aWR1YWwgZGlnaXRzIGluIGxpdHRsZSBlbmRpYW4gc3RvcmFnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihkaWdpdHMpIHtcbiAgICAgICAgdGhpcy5kaWdpdHMgPSBkaWdpdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0ludGVnZXIodGhpcy5kaWdpdHMuc2xpY2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYmlnIGludGVnZXIgd2l0aCB0aGUgc3VtIG9mIGB0aGlzYCBhbmQgYG90aGVyYCBhcyBpdHMgdmFsdWUuIFRoaXMgZG9lcyBub3QgbXV0YXRlXG4gICAgICogYHRoaXNgIGJ1dCBpbnN0ZWFkIHJldHVybnMgYSBuZXcgaW5zdGFuY2UsIHVubGlrZSBgYWRkVG9TZWxmYC5cbiAgICAgKi9cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuYWRkVG9TZWxmKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgb3RoZXJgIHRvIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHRoZXJlYnkgbXV0YXRpbmcgaXRzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZFRvU2VsZihvdGhlcikge1xuICAgICAgICBjb25zdCBtYXhOck9mRGlnaXRzID0gTWF0aC5tYXgodGhpcy5kaWdpdHMubGVuZ3RoLCBvdGhlci5kaWdpdHMubGVuZ3RoKTtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhOck9mRGlnaXRzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkaWdpdFN1bSA9IGNhcnJ5O1xuICAgICAgICAgICAgaWYgKGkgPCB0aGlzLmRpZ2l0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkaWdpdFN1bSArPSB0aGlzLmRpZ2l0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgb3RoZXIuZGlnaXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0U3VtICs9IG90aGVyLmRpZ2l0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWdpdFN1bSA+PSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlnaXRzW2ldID0gZGlnaXRTdW0gLSAxMDtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZ2l0c1tpXSA9IGRpZ2l0U3VtO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBseSBhIHJlbWFpbmluZyBjYXJyeSBpZiBuZWVkZWQuXG4gICAgICAgIGlmIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlnaXRzW21heE5yT2ZEaWdpdHNdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIGRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiaWcgaW50ZWdlci4gQXMgdGhpcyBpcyBzdG9yZWQgaW5cbiAgICAgKiBsaXR0bGUgZW5kaWFuLCB0aGUgZGlnaXRzIGFyZSBjb25jYXRlbmF0ZWQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5kaWdpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlcyArPSB0aGlzLmRpZ2l0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIGJpZyBpbnRlZ2VyIHdoaWNoIGlzIG9wdGltaXplZCBmb3IgbXVsdGlwbGljYXRpb24gb3BlcmF0aW9ucywgYXMgaXRzIHBvd2VyLW9mLXR3b3NcbiAqIGFyZSBtZW1vaXplZC4gU2VlIGBtdWx0aXBseUJ5KClgIGZvciBkZXRhaWxzIG9uIHRoZSBtdWx0aXBsaWNhdGlvbiBhbGdvcml0aG0uXG4gKi9cbmNsYXNzIEJpZ0ludEZvck11bHRpcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnBvd2VyT2ZUd29zID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmlnIGludGVnZXIgaXRzZWxmLlxuICAgICAqL1xuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3dlck9mVHdvc1swXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGZvciBgbnVtICogYmAsIHdoZXJlIGBudW1gIGlzIGEgSlMgbnVtYmVyIGFuZCBgYmAgaXMgYSBiaWcgaW50ZWdlci4gVGhlXG4gICAgICogdmFsdWUgZm9yIGBiYCBpcyByZXByZXNlbnRlZCBieSBhIHN0b3JhZ2UgbW9kZWwgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yIHRoaXMgY29tcHV0YXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpbXBsZW1lbnRlZCBpbiBOKGxvZzIobnVtKSkgYnkgY29udGludW91cyBoYWx2aW5nIG9mIHRoZSBudW1iZXIsIHdoZXJlIHRoZVxuICAgICAqIGxlYXN0LXNpZ25pZmljYW50IGJpdCAoTFNCKSBpcyB0ZXN0ZWQgaW4gZWFjaCBpdGVyYXRpb24uIElmIHRoZSBiaXQgaXMgc2V0LCB0aGUgYml0J3MgaW5kZXggaXNcbiAgICAgKiB1c2VkIGFzIGV4cG9uZW50IGludG8gdGhlIHBvd2VyLW9mLXR3byBtdWx0aXBsaWNhdGlvbiBvZiBgYmAuXG4gICAgICpcbiAgICAgKiBBcyBhbiBleGFtcGxlLCBjb25zaWRlciB0aGUgbXVsdGlwbGljYXRpb24gbnVtPTQyLCBiPTEzMzcuIEluIGJpbmFyeSA0MiBpcyAwYjAwMTAxMDEwIGFuZCB0aGVcbiAgICAgKiBhbGdvcml0aG0gdW5yb2xscyBpbnRvIHRoZSBmb2xsb3dpbmcgaXRlcmF0aW9uczpcbiAgICAgKlxuICAgICAqICBJdGVyYXRpb24gfCBudW0gICAgICAgIHwgTFNCICB8IGIgKiAyXml0ZXIgfCBBZGQ/IHwgcHJvZHVjdFxuICAgICAqIC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLXwtLS0tLS0tLVxuICAgICAqICAwICAgICAgICAgfCAwYjAwMTAxMDEwIHwgMCAgICB8IDEzMzcgICAgICAgfCBObyAgIHwgMFxuICAgICAqICAxICAgICAgICAgfCAwYjAwMDEwMTAxIHwgMSAgICB8IDI2NzQgICAgICAgfCBZZXMgIHwgMjY3NFxuICAgICAqICAyICAgICAgICAgfCAwYjAwMDAxMDEwIHwgMCAgICB8IDUzNDggICAgICAgfCBObyAgIHwgMjY3NFxuICAgICAqICAzICAgICAgICAgfCAwYjAwMDAwMTAxIHwgMSAgICB8IDEwNjk2ICAgICAgfCBZZXMgIHwgMTMzNzBcbiAgICAgKiAgNCAgICAgICAgIHwgMGIwMDAwMDAxMCB8IDAgICAgfCAyMTM5MiAgICAgIHwgTm8gICB8IDEzMzcwXG4gICAgICogIDUgICAgICAgICB8IDBiMDAwMDAwMDEgfCAxICAgIHwgNDI3ODQgICAgICB8IFllcyAgfCA1NjE1NFxuICAgICAqICA2ICAgICAgICAgfCAwYjAwMDAwMDAwIHwgMCAgICB8IDg1NTY4ICAgICAgfCBObyAgIHwgNTYxNTRcbiAgICAgKlxuICAgICAqIFRoZSBjb21wdXRlZCBwcm9kdWN0IG9mIDU2MTU0IGlzIGluZGVlZCB0aGUgY29ycmVjdCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBUaGUgYEJpZ0ludEZvck11bHRpcGxpY2F0aW9uYCByZXByZXNlbnRhdGlvbiBmb3IgYSBiaWcgaW50ZWdlciBwcm92aWRlcyBtZW1vaXplZCBhY2Nlc3MgdG8gdGhlXG4gICAgICogcG93ZXItb2YtdHdvIHZhbHVlcyB0byByZWR1Y2UgdGhlIHdvcmtsb2FkIGluIGNvbXB1dGluZyB0aG9zZSB2YWx1ZXMuXG4gICAgICovXG4gICAgbXVsdGlwbHlCeShudW0pIHtcbiAgICAgICAgY29uc3QgcHJvZHVjdCA9IEJpZ0ludGVnZXIuemVybygpO1xuICAgICAgICB0aGlzLm11bHRpcGx5QnlBbmRBZGRUbyhudW0sIHByb2R1Y3QpO1xuICAgICAgICByZXR1cm4gcHJvZHVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VlIGBtdWx0aXBseUJ5KClgIGZvciBkZXRhaWxzLiBUaGlzIGZ1bmN0aW9uIGFsbG93cyBmb3IgdGhlIGNvbXB1dGVkIHByb2R1Y3QgdG8gYmUgYWRkZWRcbiAgICAgKiBkaXJlY3RseSB0byB0aGUgcHJvdmlkZWQgcmVzdWx0IGJpZyBpbnRlZ2VyLlxuICAgICAqL1xuICAgIG11bHRpcGx5QnlBbmRBZGRUbyhudW0sIHJlc3VsdCkge1xuICAgICAgICBmb3IgKGxldCBleHBvbmVudCA9IDA7IG51bSAhPT0gMDsgbnVtID0gbnVtID4+PiAxLCBleHBvbmVudCsrKSB7XG4gICAgICAgICAgICBpZiAobnVtICYgMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRNdWx0aXBsaWVkQnlQb3dlck9mVHdvKGV4cG9uZW50KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkVG9TZWxmKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBhbmQgbWVtb2l6ZXMgdGhlIGJpZyBpbnRlZ2VyIHZhbHVlIGZvciBgdGhpcy5udW1iZXIgKiAyXmV4cG9uZW50YC5cbiAgICAgKi9cbiAgICBnZXRNdWx0aXBsaWVkQnlQb3dlck9mVHdvKGV4cG9uZW50KSB7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBvd2VycyB1cCB1bnRpbCB0aGUgcmVxdWVzdGVkIGV4cG9uZW50LCB3aGVyZSBlYWNoIHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gaXRzXG4gICAgICAgIC8vIHByZWRlY2Vzc29yLiBUaGlzIGlzIHNpbXBsZSBhcyBgdGhpcy5udW1iZXIgKiAyXihleHBvbmVudCAtIDEpYCBvbmx5IGhhcyB0byBiZSBkb3VibGVkIChpLmUuXG4gICAgICAgIC8vIGFkZGVkIHRvIGl0c2VsZikgdG8gcmVhY2ggYHRoaXMubnVtYmVyICogMl5leHBvbmVudGAuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnBvd2VyT2ZUd29zLmxlbmd0aDsgaSA8PSBleHBvbmVudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1Bvd2VyID0gdGhpcy5wb3dlck9mVHdvc1tpIC0gMV07XG4gICAgICAgICAgICB0aGlzLnBvd2VyT2ZUd29zW2ldID0gcHJldmlvdXNQb3dlci5hZGQocHJldmlvdXNQb3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG93ZXJPZlR3b3NbZXhwb25lbnRdO1xuICAgIH1cbn1cbi8qKlxuICogUmVwcmVzZW50cyBhbiBleHBvbmVudGlhdGlvbiBvcGVyYXRpb24gZm9yIHRoZSBwcm92aWRlZCBiYXNlLCBvZiB3aGljaCBleHBvbmVudHMgYXJlIGNvbXB1dGVkIGFuZFxuICogbWVtb2l6ZWQuIFRoZSByZXN1bHRzIGFyZSByZXByZXNlbnRlZCBieSBhIGBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbmAgd2hpY2ggaXMgdGFpbG9yZWQgZm9yXG4gKiBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25zIGJ5IG1lbW9pemluZyB0aGUgcG93ZXItb2YtdHdvcy4gVGhpcyBlZmZlY3RpdmVseSByZXN1bHRzIGluIGEgbWF0cml4XG4gKiByZXByZXNlbnRhdGlvbiB0aGF0IGlzIGxhemlseSBjb21wdXRlZCB1cG9uIHJlcXVlc3QuXG4gKi9cbmNsYXNzIEJpZ0ludEV4cG9uZW50aWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlKSB7XG4gICAgICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgICAgIHRoaXMuZXhwb25lbnRzID0gW25ldyBCaWdJbnRGb3JNdWx0aXBsaWNhdGlvbihCaWdJbnRlZ2VyLm9uZSgpKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHZhbHVlIGZvciBgdGhpcy5iYXNlXmV4cG9uZW50YCwgcmVzdWx0aW5nIGluIGEgYmlnIGludGVnZXIgdGhhdCBpcyBvcHRpbWl6ZWQgZm9yXG4gICAgICogZnVydGhlciBtdWx0aXBsaWNhdGlvbiBvcGVyYXRpb25zLlxuICAgICAqL1xuICAgIHRvVGhlUG93ZXJPZihleHBvbmVudCkge1xuICAgICAgICAvLyBDb21wdXRlIHRoZSByZXN1bHRzIHVwIHVudGlsIHRoZSByZXF1ZXN0ZWQgZXhwb25lbnQsIHdoZXJlIGV2ZXJ5IHZhbHVlIGlzIGNvbXB1dGVkIGZyb20gaXRzXG4gICAgICAgIC8vIHByZWRlY2Vzc29yLiBUaGlzIGlzIGJlY2F1c2UgYHRoaXMuYmFzZV4oZXhwb25lbnQgLSAxKWAgb25seSBoYXMgdG8gYmUgbXVsdGlwbGllZCBieSBgYmFzZWBcbiAgICAgICAgLy8gdG8gcmVhY2ggYHRoaXMuYmFzZV5leHBvbmVudGAuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmV4cG9uZW50cy5sZW5ndGg7IGkgPD0gZXhwb25lbnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmV4cG9uZW50c1tpIC0gMV0ubXVsdGlwbHlCeSh0aGlzLmJhc2UpO1xuICAgICAgICAgICAgdGhpcy5leHBvbmVudHNbaV0gPSBuZXcgQmlnSW50Rm9yTXVsdGlwbGljYXRpb24odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9uZW50c1tleHBvbmVudF07XG4gICAgfVxufVxuXG4vKipcbiAqIEEgbGF6aWx5IGNyZWF0ZWQgVGV4dEVuY29kZXIgaW5zdGFuY2UgZm9yIGNvbnZlcnRpbmcgc3RyaW5ncyBpbnRvIFVURi04IGJ5dGVzXG4gKi9cbmxldCB0ZXh0RW5jb2Rlcjtcbi8qKlxuICogUmV0dXJuIHRoZSBtZXNzYWdlIGlkIG9yIGNvbXB1dGUgaXQgdXNpbmcgdGhlIFhMSUZGMSBkaWdlc3QuXG4gKi9cbmZ1bmN0aW9uIGRpZ2VzdCQxKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBjb21wdXRlRGlnZXN0KG1lc3NhZ2UpO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBtZXNzYWdlIGlkIHVzaW5nIHRoZSBYTElGRjEgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gc2hhMShzZXJpYWxpemVOb2RlcyhtZXNzYWdlLm5vZGVzKS5qb2luKCcnKSArIGBbJHttZXNzYWdlLm1lYW5pbmd9XWApO1xufVxuLyoqXG4gKiBSZXR1cm4gdGhlIG1lc3NhZ2UgaWQgb3IgY29tcHV0ZSBpdCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5pZCB8fCBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbn1cbi8qKlxuICogQ29tcHV0ZSB0aGUgbWVzc2FnZSBpZCB1c2luZyB0aGUgWExJRkYyL1hNQi8kbG9jYWxpemUgZGlnZXN0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBfU2VyaWFsaXplcklnbm9yZUljdUV4cFZpc2l0b3IoKTtcbiAgICBjb25zdCBwYXJ0cyA9IG1lc3NhZ2Uubm9kZXMubWFwKGEgPT4gYS52aXNpdCh2aXNpdG9yLCBudWxsKSk7XG4gICAgcmV0dXJuIGNvbXB1dGVNc2dJZChwYXJ0cy5qb2luKCcnKSwgbWVzc2FnZS5tZWFuaW5nKTtcbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBpMThuIGFzdCB0byBzb21ldGhpbmcgeG1sLWxpa2UgaW4gb3JkZXIgdG8gZ2VuZXJhdGUgYW4gVUlELlxuICpcbiAqIFRoZSB2aXNpdG9yIGlzIGFsc28gdXNlZCBpbiB0aGUgaTE4biBwYXJzZXIgdGVzdHNcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgX1NlcmlhbGl6ZXJWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBgWyR7Y29udGFpbmVyLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignLCAnKX1dYDtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoKGspID0+IGAke2t9IHske2ljdS5jYXNlc1trXS52aXNpdCh0aGlzKX19YCk7XG4gICAgICAgIHJldHVybiBgeyR7aWN1LmV4cHJlc3Npb259LCAke2ljdS50eXBlfSwgJHtzdHJDYXNlcy5qb2luKCcsICcpfX1gO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwaC5pc1ZvaWQgP1xuICAgICAgICAgICAgYDxwaCB0YWcgbmFtZT1cIiR7cGguc3RhcnROYW1lfVwiLz5gIDpcbiAgICAgICAgICAgIGA8cGggdGFnIG5hbWU9XCIke3BoLnN0YXJ0TmFtZX1cIj4ke3BoLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignLCAnKX08L3BoIG5hbWU9XCIke3BoLmNsb3NlTmFtZX1cIj5gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBwaC52YWx1ZSA/IGA8cGggbmFtZT1cIiR7cGgubmFtZX1cIj4ke3BoLnZhbHVlfTwvcGg+YCA6IGA8cGggbmFtZT1cIiR7cGgubmFtZX1cIi8+YDtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYDxwaCBpY3UgbmFtZT1cIiR7cGgubmFtZX1cIj4ke3BoLnZhbHVlLnZpc2l0KHRoaXMpfTwvcGg+YDtcbiAgICB9XG59XG5jb25zdCBzZXJpYWxpemVyVmlzaXRvciQxID0gbmV3IF9TZXJpYWxpemVyVmlzaXRvcigpO1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGEgPT4gYS52aXNpdChzZXJpYWxpemVyVmlzaXRvciQxLCBudWxsKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgaTE4biBhc3QgdG8gc29tZXRoaW5nIHhtbC1saWtlIGluIG9yZGVyIHRvIGdlbmVyYXRlIGFuIFVJRC5cbiAqXG4gKiBJZ25vcmUgdGhlIElDVSBleHByZXNzaW9ucyBzbyB0aGF0IG1lc3NhZ2UgSURzIHN0YXlzIGlkZW50aWNhbCBpZiBvbmx5IHRoZSBleHByZXNzaW9uIGNoYW5nZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIF9TZXJpYWxpemVySWdub3JlSWN1RXhwVmlzaXRvciBleHRlbmRzIF9TZXJpYWxpemVyVmlzaXRvciB7XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGxldCBzdHJDYXNlcyA9IE9iamVjdC5rZXlzKGljdS5jYXNlcykubWFwKChrKSA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICAvLyBEbyBub3QgdGFrZSB0aGUgZXhwcmVzc2lvbiBpbnRvIGFjY291bnRcbiAgICAgICAgcmV0dXJuIGB7JHtpY3UudHlwZX0sICR7c3RyQ2FzZXMuam9pbignLCAnKX19YDtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGUgdGhlIFNIQTEgb2YgdGhlIGdpdmVuIHN0cmluZ1xuICpcbiAqIHNlZSBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC00L2ZpcHMtMTgwLTQucGRmXG4gKlxuICogV0FSTklORzogdGhpcyBmdW5jdGlvbiBoYXMgbm90IGJlZW4gZGVzaWduZWQgbm90IHRlc3RlZCB3aXRoIHNlY3VyaXR5IGluIG1pbmQuXG4gKiAgICAgICAgICBETyBOT1QgVVNFIElUIElOIEEgU0VDVVJJVFkgU0VOU0lUSVZFIENPTlRFWFQuXG4gKi9cbmZ1bmN0aW9uIHNoYTEoc3RyKSB7XG4gICAgdGV4dEVuY29kZXIgPz8gKHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCkpO1xuICAgIGNvbnN0IHV0ZjggPSBbLi4udGV4dEVuY29kZXIuZW5jb2RlKHN0cildO1xuICAgIGNvbnN0IHdvcmRzMzIgPSBieXRlc1RvV29yZHMzMih1dGY4LCBFbmRpYW4uQmlnKTtcbiAgICBjb25zdCBsZW4gPSB1dGY4Lmxlbmd0aCAqIDg7XG4gICAgY29uc3QgdyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG4gICAgbGV0IGEgPSAweDY3NDUyMzAxLCBiID0gMHhlZmNkYWI4OSwgYyA9IDB4OThiYWRjZmUsIGQgPSAweDEwMzI1NDc2LCBlID0gMHhjM2QyZTFmMDtcbiAgICB3b3JkczMyW2xlbiA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGxlbiAlIDMyKTtcbiAgICB3b3JkczMyWygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkczMyLmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICBjb25zdCBoMCA9IGEsIGgxID0gYiwgaDIgPSBjLCBoMyA9IGQsIGg0ID0gZTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaiA8IDE2KSB7XG4gICAgICAgICAgICAgICAgd1tqXSA9IHdvcmRzMzJbaSArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd1tqXSA9IHJvbDMyKHdbaiAtIDNdIF4gd1tqIC0gOF0gXiB3W2ogLSAxNF0gXiB3W2ogLSAxNl0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmtWYWwgPSBmayhqLCBiLCBjLCBkKTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBma1ZhbFswXTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBma1ZhbFsxXTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBbcm9sMzIoYSwgNSksIGYsIGUsIGssIHdbal1dLnJlZHVjZShhZGQzMik7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9IHJvbDMyKGIsIDMwKTtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGFkZDMyKGEsIGgwKTtcbiAgICAgICAgYiA9IGFkZDMyKGIsIGgxKTtcbiAgICAgICAgYyA9IGFkZDMyKGMsIGgyKTtcbiAgICAgICAgZCA9IGFkZDMyKGQsIGgzKTtcbiAgICAgICAgZSA9IGFkZDMyKGUsIGg0KTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0aGUgb3V0cHV0IHBhcnRzIHRvIGEgMTYwLWJpdCBoZXhhZGVjaW1hbCBzdHJpbmdcbiAgICByZXR1cm4gdG9IZXhVMzIoYSkgKyB0b0hleFUzMihiKSArIHRvSGV4VTMyKGMpICsgdG9IZXhVMzIoZCkgKyB0b0hleFUzMihlKTtcbn1cbi8qKlxuICogQ29udmVydCBhbmQgZm9ybWF0IGEgbnVtYmVyIGFzIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIDMyLWJpdCB1bnNpZ25lZCBoZXhhZGVjaW1hbCBudW1iZXIuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGZvcm1hdCBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIEEgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHRvSGV4VTMyKHZhbHVlKSB7XG4gICAgLy8gdW5zaWduZWQgcmlnaHQgc2hpZnQgb2YgemVybyBlbnN1cmVzIGFuIHVuc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAgICByZXR1cm4gKHZhbHVlID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgJzAnKTtcbn1cbmZ1bmN0aW9uIGZrKGluZGV4LCBiLCBjLCBkKSB7XG4gICAgaWYgKGluZGV4IDwgMjApIHtcbiAgICAgICAgcmV0dXJuIFsoYiAmIGMpIHwgKH5iICYgZCksIDB4NWE4Mjc5OTldO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPCA0MCkge1xuICAgICAgICByZXR1cm4gW2IgXiBjIF4gZCwgMHg2ZWQ5ZWJhMV07XG4gICAgfVxuICAgIGlmIChpbmRleCA8IDYwKSB7XG4gICAgICAgIHJldHVybiBbKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpLCAweDhmMWJiY2RjXTtcbiAgICB9XG4gICAgcmV0dXJuIFtiIF4gYyBeIGQsIDB4Y2E2MmMxZDZdO1xufVxuLyoqXG4gKiBDb21wdXRlIHRoZSBmaW5nZXJwcmludCBvZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKlxuICogVGhlIG91dHB1dCBpcyA2NCBiaXQgbnVtYmVyIGVuY29kZWQgYXMgYSBkZWNpbWFsIHN0cmluZ1xuICpcbiAqIGJhc2VkIG9uOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL0dvb2dsZUpzTWVzc2FnZUlkR2VuZXJhdG9yLmphdmFcbiAqL1xuZnVuY3Rpb24gZmluZ2VycHJpbnQoc3RyKSB7XG4gICAgdGV4dEVuY29kZXIgPz8gKHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCkpO1xuICAgIGNvbnN0IHV0ZjggPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHV0ZjguYnVmZmVyLCB1dGY4LmJ5dGVPZmZzZXQsIHV0ZjguYnl0ZUxlbmd0aCk7XG4gICAgbGV0IGhpID0gaGFzaDMyKHZpZXcsIHV0ZjgubGVuZ3RoLCAwKTtcbiAgICBsZXQgbG8gPSBoYXNoMzIodmlldywgdXRmOC5sZW5ndGgsIDEwMjA3Mik7XG4gICAgaWYgKGhpID09IDAgJiYgKGxvID09IDAgfHwgbG8gPT0gMSkpIHtcbiAgICAgICAgaGkgPSBoaSBeIDB4MTMwZjliZWY7XG4gICAgICAgIGxvID0gbG8gXiAtMHg2YjVmNTZkODtcbiAgICB9XG4gICAgcmV0dXJuIFtoaSwgbG9dO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1zZ0lkKG1zZywgbWVhbmluZyA9ICcnKSB7XG4gICAgbGV0IG1zZ0ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQobXNnKTtcbiAgICBpZiAobWVhbmluZykge1xuICAgICAgICBjb25zdCBtZWFuaW5nRmluZ2VycHJpbnQgPSBmaW5nZXJwcmludChtZWFuaW5nKTtcbiAgICAgICAgbXNnRmluZ2VycHJpbnQgPSBhZGQ2NChyb2w2NChtc2dGaW5nZXJwcmludCwgMSksIG1lYW5pbmdGaW5nZXJwcmludCk7XG4gICAgfVxuICAgIGNvbnN0IGhpID0gbXNnRmluZ2VycHJpbnRbMF07XG4gICAgY29uc3QgbG8gPSBtc2dGaW5nZXJwcmludFsxXTtcbiAgICByZXR1cm4gd29yZHNUb0RlY2ltYWxTdHJpbmcoaGkgJiAweDdmZmZmZmZmLCBsbyk7XG59XG5mdW5jdGlvbiBoYXNoMzIodmlldywgbGVuZ3RoLCBjKSB7XG4gICAgbGV0IGEgPSAweDllMzc3OWI5LCBiID0gMHg5ZTM3NzliOTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGVuZCA9IGxlbmd0aCAtIDEyO1xuICAgIGZvciAoOyBpbmRleCA8PSBlbmQ7IGluZGV4ICs9IDEyKSB7XG4gICAgICAgIGEgKz0gdmlldy5nZXRVaW50MzIoaW5kZXgsIHRydWUpO1xuICAgICAgICBiICs9IHZpZXcuZ2V0VWludDMyKGluZGV4ICsgNCwgdHJ1ZSk7XG4gICAgICAgIGMgKz0gdmlldy5nZXRVaW50MzIoaW5kZXggKyA4LCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzID0gbWl4KGEsIGIsIGMpO1xuICAgICAgICBhID0gcmVzWzBdLCBiID0gcmVzWzFdLCBjID0gcmVzWzJdO1xuICAgIH1cbiAgICBjb25zdCByZW1haW5kZXIgPSBsZW5ndGggLSBpbmRleDtcbiAgICAvLyB0aGUgZmlyc3QgYnl0ZSBvZiBjIGlzIHJlc2VydmVkIGZvciB0aGUgbGVuZ3RoXG4gICAgYyArPSBsZW5ndGg7XG4gICAgaWYgKHJlbWFpbmRlciA+PSA0KSB7XG4gICAgICAgIGEgKz0gdmlldy5nZXRVaW50MzIoaW5kZXgsIHRydWUpO1xuICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICBpZiAocmVtYWluZGVyID49IDgpIHtcbiAgICAgICAgICAgIGIgKz0gdmlldy5nZXRVaW50MzIoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIC8vIFBhcnRpYWwgMzItYml0IHdvcmQgZm9yIGNcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPj0gOSkge1xuICAgICAgICAgICAgICAgIGMgKz0gdmlldy5nZXRVaW50OChpbmRleCsrKSA8PCA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+PSAxMCkge1xuICAgICAgICAgICAgICAgIGMgKz0gdmlldy5nZXRVaW50OChpbmRleCsrKSA8PCAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgYyArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspIDw8IDI0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFydGlhbCAzMi1iaXQgd29yZCBmb3IgYlxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+PSA1KSB7XG4gICAgICAgICAgICAgICAgYiArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbWFpbmRlciA+PSA2KSB7XG4gICAgICAgICAgICAgICAgYiArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspIDw8IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYWluZGVyID09PSA3KSB7XG4gICAgICAgICAgICAgICAgYiArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspIDw8IDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBQYXJ0aWFsIDMyLWJpdCB3b3JkIGZvciBhXG4gICAgICAgIGlmIChyZW1haW5kZXIgPj0gMSkge1xuICAgICAgICAgICAgYSArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW1haW5kZXIgPj0gMikge1xuICAgICAgICAgICAgYSArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspIDw8IDg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmRlciA9PT0gMykge1xuICAgICAgICAgICAgYSArPSB2aWV3LmdldFVpbnQ4KGluZGV4KyspIDw8IDE2O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaXgoYSwgYiwgYylbMl07XG59XG4vLyBjbGFuZy1mb3JtYXQgb2ZmXG5mdW5jdGlvbiBtaXgoYSwgYiwgYykge1xuICAgIGEgLT0gYjtcbiAgICBhIC09IGM7XG4gICAgYSBePSBjID4+PiAxMztcbiAgICBiIC09IGM7XG4gICAgYiAtPSBhO1xuICAgIGIgXj0gYSA8PCA4O1xuICAgIGMgLT0gYTtcbiAgICBjIC09IGI7XG4gICAgYyBePSBiID4+PiAxMztcbiAgICBhIC09IGI7XG4gICAgYSAtPSBjO1xuICAgIGEgXj0gYyA+Pj4gMTI7XG4gICAgYiAtPSBjO1xuICAgIGIgLT0gYTtcbiAgICBiIF49IGEgPDwgMTY7XG4gICAgYyAtPSBhO1xuICAgIGMgLT0gYjtcbiAgICBjIF49IGIgPj4+IDU7XG4gICAgYSAtPSBiO1xuICAgIGEgLT0gYztcbiAgICBhIF49IGMgPj4+IDM7XG4gICAgYiAtPSBjO1xuICAgIGIgLT0gYTtcbiAgICBiIF49IGEgPDwgMTA7XG4gICAgYyAtPSBhO1xuICAgIGMgLT0gYjtcbiAgICBjIF49IGIgPj4+IDE1O1xuICAgIHJldHVybiBbYSwgYiwgY107XG59XG4vLyBjbGFuZy1mb3JtYXQgb25cbi8vIFV0aWxzXG52YXIgRW5kaWFuO1xuKGZ1bmN0aW9uIChFbmRpYW4pIHtcbiAgICBFbmRpYW5bRW5kaWFuW1wiTGl0dGxlXCJdID0gMF0gPSBcIkxpdHRsZVwiO1xuICAgIEVuZGlhbltFbmRpYW5bXCJCaWdcIl0gPSAxXSA9IFwiQmlnXCI7XG59KShFbmRpYW4gfHwgKEVuZGlhbiA9IHt9KSk7XG5mdW5jdGlvbiBhZGQzMihhLCBiKSB7XG4gICAgcmV0dXJuIGFkZDMydG82NChhLCBiKVsxXTtcbn1cbmZ1bmN0aW9uIGFkZDMydG82NChhLCBiKSB7XG4gICAgY29uc3QgbG93ID0gKGEgJiAweGZmZmYpICsgKGIgJiAweGZmZmYpO1xuICAgIGNvbnN0IGhpZ2ggPSAoYSA+Pj4gMTYpICsgKGIgPj4+IDE2KSArIChsb3cgPj4+IDE2KTtcbiAgICByZXR1cm4gW2hpZ2ggPj4+IDE2LCAoaGlnaCA8PCAxNikgfCAobG93ICYgMHhmZmZmKV07XG59XG5mdW5jdGlvbiBhZGQ2NChhLCBiKSB7XG4gICAgY29uc3QgYWggPSBhWzBdLCBhbCA9IGFbMV07XG4gICAgY29uc3QgYmggPSBiWzBdLCBibCA9IGJbMV07XG4gICAgY29uc3QgcmVzdWx0ID0gYWRkMzJ0bzY0KGFsLCBibCk7XG4gICAgY29uc3QgY2FycnkgPSByZXN1bHRbMF07XG4gICAgY29uc3QgbCA9IHJlc3VsdFsxXTtcbiAgICBjb25zdCBoID0gYWRkMzIoYWRkMzIoYWgsIGJoKSwgY2FycnkpO1xuICAgIHJldHVybiBbaCwgbF07XG59XG4vLyBSb3RhdGUgYSAzMmIgbnVtYmVyIGxlZnQgYGNvdW50YCBwb3NpdGlvblxuZnVuY3Rpb24gcm9sMzIoYSwgY291bnQpIHtcbiAgICByZXR1cm4gKGEgPDwgY291bnQpIHwgKGEgPj4+ICgzMiAtIGNvdW50KSk7XG59XG4vLyBSb3RhdGUgYSA2NGIgbnVtYmVyIGxlZnQgYGNvdW50YCBwb3NpdGlvblxuZnVuY3Rpb24gcm9sNjQobnVtLCBjb3VudCkge1xuICAgIGNvbnN0IGhpID0gbnVtWzBdLCBsbyA9IG51bVsxXTtcbiAgICBjb25zdCBoID0gKGhpIDw8IGNvdW50KSB8IChsbyA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICBjb25zdCBsID0gKGxvIDw8IGNvdW50KSB8IChoaSA+Pj4gKDMyIC0gY291bnQpKTtcbiAgICByZXR1cm4gW2gsIGxdO1xufVxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzMzIoYnl0ZXMsIGVuZGlhbikge1xuICAgIGNvbnN0IHNpemUgPSAoYnl0ZXMubGVuZ3RoICsgMykgPj4+IDI7XG4gICAgY29uc3Qgd29yZHMzMiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHdvcmRzMzJbaV0gPSB3b3JkQXQoYnl0ZXMsIGkgKiA0LCBlbmRpYW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29yZHMzMjtcbn1cbmZ1bmN0aW9uIGJ5dGVBdChieXRlcywgaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPj0gYnl0ZXMubGVuZ3RoID8gMCA6IGJ5dGVzW2luZGV4XTtcbn1cbmZ1bmN0aW9uIHdvcmRBdChieXRlcywgaW5kZXgsIGVuZGlhbikge1xuICAgIGxldCB3b3JkID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSBFbmRpYW4uQmlnKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChieXRlcywgaW5kZXggKyBpKSA8PCAoMjQgLSA4ICogaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB3b3JkICs9IGJ5dGVBdChieXRlcywgaW5kZXggKyBpKSA8PCA4ICogaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd29yZDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc2hhcmVkIGV4cG9uZW50aWF0aW9uIHBvb2wgZm9yIGJhc2UtMjU2IGNvbXB1dGF0aW9ucy4gVGhpcyBzaGFyZWQgcG9vbCBwcm92aWRlcyBtZW1vaXplZFxuICogcG93ZXItb2YtMjU2IHJlc3VsdHMgd2l0aCBtZW1vaXplZCBwb3dlci1vZi10d28gY29tcHV0YXRpb25zIGZvciBlZmZpY2llbnQgbXVsdGlwbGljYXRpb24uXG4gKlxuICogRm9yIG91ciBwdXJwb3NlcywgdGhpcyBjYW4gYmUgc2FmZWx5IHN0b3JlZCBhcyBhIGdsb2JhbCB3aXRob3V0IG1lbW9yeSBjb25jZXJucy4gVGhlIHJlYXNvbiBpc1xuICogdGhhdCB3ZSBlbmNvZGUgdHdvIHdvcmRzLCBzbyBvbmx5IG5lZWQgdGhlIDB0aCAoZm9yIHRoZSBsb3cgd29yZCkgYW5kIDR0aCAoZm9yIHRoZSBoaWdoIHdvcmQpXG4gKiBleHBvbmVudC5cbiAqL1xuY29uc3QgYmFzZTI1NiA9IG5ldyBCaWdJbnRFeHBvbmVudGlhdGlvbigyNTYpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHR3byAzMi1iaXQgd29yZHMgYXMgYSBzaW5nbGUgZGVjaW1hbCBudW1iZXIuIFRoaXMgcmVxdWlyZXMgYSBiaWcgaW50ZWdlciBzdG9yYWdlXG4gKiBtb2RlbCBhcyBKUyBudW1iZXJzIGFyZSBub3QgYWNjdXJhdGUgZW5vdWdoIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IG51bWJlci5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL3d3dy5kYW52ay5vcmcvaGV4MmRlYy5odG1sXG4gKi9cbmZ1bmN0aW9uIHdvcmRzVG9EZWNpbWFsU3RyaW5nKGhpLCBsbykge1xuICAgIC8vIEVuY29kZSB0aGUgZm91ciBieXRlcyBpbiBsbyBpbiB0aGUgbG93ZXIgZGlnaXRzIG9mIHRoZSBkZWNpbWFsIG51bWJlci5cbiAgICAvLyBOb3RlOiB0aGUgbXVsdGlwbGljYXRpb24gcmVzdWx0cyBpbiBsbyBpdHNlbGYgYnV0IHJlcHJlc2VudGVkIGJ5IGEgYmlnIGludGVnZXIgdXNpbmcgaXRzXG4gICAgLy8gZGVjaW1hbCBkaWdpdHMuXG4gICAgY29uc3QgZGVjaW1hbCA9IGJhc2UyNTYudG9UaGVQb3dlck9mKDApLm11bHRpcGx5QnkobG8pO1xuICAgIC8vIEVuY29kZSB0aGUgZm91ciBieXRlcyBpbiBoaSBhYm92ZSB0aGUgZm91ciBsbyBieXRlcy4gbG8gaXMgYSBtYXhpbXVtIG9mICgyXjgpXjQsIHdoaWNoIGlzIHdoeVxuICAgIC8vIHRoaXMgbXVsdGlwbGljYXRpb24gZmFjdG9yIGlzIGFwcGxpZWQuXG4gICAgYmFzZTI1Ni50b1RoZVBvd2VyT2YoNCkubXVsdGlwbHlCeUFuZEFkZFRvKGhpLCBkZWNpbWFsKTtcbiAgICByZXR1cm4gZGVjaW1hbC50b1N0cmluZygpO1xufVxuXG4vLy8vIFR5cGVzXG52YXIgVHlwZU1vZGlmaWVyO1xuKGZ1bmN0aW9uIChUeXBlTW9kaWZpZXIpIHtcbiAgICBUeXBlTW9kaWZpZXJbVHlwZU1vZGlmaWVyW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgVHlwZU1vZGlmaWVyW1R5cGVNb2RpZmllcltcIkNvbnN0XCJdID0gMV0gPSBcIkNvbnN0XCI7XG59KShUeXBlTW9kaWZpZXIgfHwgKFR5cGVNb2RpZmllciA9IHt9KSk7XG5jbGFzcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcihtb2RpZmllcnMgPSBUeXBlTW9kaWZpZXIuTm9uZSkge1xuICAgICAgICB0aGlzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcbiAgICB9XG4gICAgaGFzTW9kaWZpZXIobW9kaWZpZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZGlmaWVycyAmIG1vZGlmaWVyKSAhPT0gMDtcbiAgICB9XG59XG52YXIgQnVpbHRpblR5cGVOYW1lO1xuKGZ1bmN0aW9uIChCdWlsdGluVHlwZU5hbWUpIHtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiRHluYW1pY1wiXSA9IDBdID0gXCJEeW5hbWljXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkJvb2xcIl0gPSAxXSA9IFwiQm9vbFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJTdHJpbmdcIl0gPSAyXSA9IFwiU3RyaW5nXCI7XG4gICAgQnVpbHRpblR5cGVOYW1lW0J1aWx0aW5UeXBlTmFtZVtcIkludFwiXSA9IDNdID0gXCJJbnRcIjtcbiAgICBCdWlsdGluVHlwZU5hbWVbQnVpbHRpblR5cGVOYW1lW1wiTnVtYmVyXCJdID0gNF0gPSBcIk51bWJlclwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJGdW5jdGlvblwiXSA9IDVdID0gXCJGdW5jdGlvblwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJJbmZlcnJlZFwiXSA9IDZdID0gXCJJbmZlcnJlZFwiO1xuICAgIEJ1aWx0aW5UeXBlTmFtZVtCdWlsdGluVHlwZU5hbWVbXCJOb25lXCJdID0gN10gPSBcIk5vbmVcIjtcbn0pKEJ1aWx0aW5UeXBlTmFtZSB8fCAoQnVpbHRpblR5cGVOYW1lID0ge30pKTtcbmNsYXNzIEJ1aWx0aW5UeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QnVpbHRpblR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgbW9kaWZpZXJzLCB0eXBlUGFyYW1zID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudHlwZVBhcmFtcyA9IHR5cGVQYXJhbXM7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQXJyYXlUeXBlIGV4dGVuZHMgVHlwZSB7XG4gICAgY29uc3RydWN0b3Iob2YsIG1vZGlmaWVycykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLm9mID0gb2Y7XG4gICAgfVxuICAgIHZpc2l0VHlwZSh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QXJyYXlUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIE1hcFR5cGUgZXh0ZW5kcyBUeXBlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZVR5cGUsIG1vZGlmaWVycykge1xuICAgICAgICBzdXBlcihtb2RpZmllcnMpO1xuICAgICAgICB0aGlzLnZhbHVlVHlwZSA9IHZhbHVlVHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICB2aXNpdFR5cGUodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdE1hcFR5cGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY29uc3QgRFlOQU1JQ19UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5EeW5hbWljKTtcbmNvbnN0IElORkVSUkVEX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLkluZmVycmVkKTtcbmNvbnN0IEJPT0xfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuQm9vbCk7XG5jb25zdCBJTlRfVFlQRSA9IG5ldyBCdWlsdGluVHlwZShCdWlsdGluVHlwZU5hbWUuSW50KTtcbmNvbnN0IE5VTUJFUl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5OdW1iZXIpO1xuY29uc3QgU1RSSU5HX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLlN0cmluZyk7XG5jb25zdCBGVU5DVElPTl9UWVBFID0gbmV3IEJ1aWx0aW5UeXBlKEJ1aWx0aW5UeXBlTmFtZS5GdW5jdGlvbik7XG5jb25zdCBOT05FX1RZUEUgPSBuZXcgQnVpbHRpblR5cGUoQnVpbHRpblR5cGVOYW1lLk5vbmUpO1xuLy8vLy8gRXhwcmVzc2lvbnNcbnZhciBVbmFyeU9wZXJhdG9yO1xuKGZ1bmN0aW9uIChVbmFyeU9wZXJhdG9yKSB7XG4gICAgVW5hcnlPcGVyYXRvcltVbmFyeU9wZXJhdG9yW1wiTWludXNcIl0gPSAwXSA9IFwiTWludXNcIjtcbiAgICBVbmFyeU9wZXJhdG9yW1VuYXJ5T3BlcmF0b3JbXCJQbHVzXCJdID0gMV0gPSBcIlBsdXNcIjtcbn0pKFVuYXJ5T3BlcmF0b3IgfHwgKFVuYXJ5T3BlcmF0b3IgPSB7fSkpO1xudmFyIEJpbmFyeU9wZXJhdG9yO1xuKGZ1bmN0aW9uIChCaW5hcnlPcGVyYXRvcikge1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiRXF1YWxzXCJdID0gMF0gPSBcIkVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTm90RXF1YWxzXCJdID0gMV0gPSBcIk5vdEVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiSWRlbnRpY2FsXCJdID0gMl0gPSBcIklkZW50aWNhbFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTm90SWRlbnRpY2FsXCJdID0gM10gPSBcIk5vdElkZW50aWNhbFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTWludXNcIl0gPSA0XSA9IFwiTWludXNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIlBsdXNcIl0gPSA1XSA9IFwiUGx1c1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiRGl2aWRlXCJdID0gNl0gPSBcIkRpdmlkZVwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTXVsdGlwbHlcIl0gPSA3XSA9IFwiTXVsdGlwbHlcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk1vZHVsb1wiXSA9IDhdID0gXCJNb2R1bG9cIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkFuZFwiXSA9IDldID0gXCJBbmRcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIk9yXCJdID0gMTBdID0gXCJPclwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiQml0d2lzZUFuZFwiXSA9IDExXSA9IFwiQml0d2lzZUFuZFwiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTG93ZXJcIl0gPSAxMl0gPSBcIkxvd2VyXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJMb3dlckVxdWFsc1wiXSA9IDEzXSA9IFwiTG93ZXJFcXVhbHNcIjtcbiAgICBCaW5hcnlPcGVyYXRvcltCaW5hcnlPcGVyYXRvcltcIkJpZ2dlclwiXSA9IDE0XSA9IFwiQmlnZ2VyXCI7XG4gICAgQmluYXJ5T3BlcmF0b3JbQmluYXJ5T3BlcmF0b3JbXCJCaWdnZXJFcXVhbHNcIl0gPSAxNV0gPSBcIkJpZ2dlckVxdWFsc1wiO1xuICAgIEJpbmFyeU9wZXJhdG9yW0JpbmFyeU9wZXJhdG9yW1wiTnVsbGlzaENvYWxlc2NlXCJdID0gMTZdID0gXCJOdWxsaXNoQ29hbGVzY2VcIjtcbn0pKEJpbmFyeU9wZXJhdG9yIHx8IChCaW5hcnlPcGVyYXRvciA9IHt9KSk7XG5mdW5jdGlvbiBudWxsU2FmZUlzRXF1aXZhbGVudChiYXNlLCBvdGhlcikge1xuICAgIGlmIChiYXNlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYmFzZSA9PSBvdGhlcjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UuaXNFcXVpdmFsZW50KG90aGVyKTtcbn1cbmZ1bmN0aW9uIGFyZUFsbEVxdWl2YWxlbnRQcmVkaWNhdGUoYmFzZSwgb3RoZXIsIGVxdWl2YWxlbnRQcmVkaWNhdGUpIHtcbiAgICBjb25zdCBsZW4gPSBiYXNlLmxlbmd0aDtcbiAgICBpZiAobGVuICE9PSBvdGhlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghZXF1aXZhbGVudFByZWRpY2F0ZShiYXNlW2ldLCBvdGhlcltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFyZUFsbEVxdWl2YWxlbnQoYmFzZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gYXJlQWxsRXF1aXZhbGVudFByZWRpY2F0ZShiYXNlLCBvdGhlciwgKGJhc2VFbGVtZW50LCBvdGhlckVsZW1lbnQpID0+IGJhc2VFbGVtZW50LmlzRXF1aXZhbGVudChvdGhlckVsZW1lbnQpKTtcbn1cbmNsYXNzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuIHx8IG51bGw7XG4gICAgfVxuICAgIHByb3AobmFtZSwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWRQcm9wRXhwcih0aGlzLCBuYW1lLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAga2V5KGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZEtleUV4cHIodGhpcywgaW5kZXgsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBjYWxsRm4ocGFyYW1zLCBzb3VyY2VTcGFuLCBwdXJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW52b2tlRnVuY3Rpb25FeHByKHRoaXMsIHBhcmFtcywgbnVsbCwgc291cmNlU3BhbiwgcHVyZSk7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlKHBhcmFtcywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEluc3RhbnRpYXRlRXhwcih0aGlzLCBwYXJhbXMsIHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBjb25kaXRpb25hbCh0cnVlQ2FzZSwgZmFsc2VDYXNlID0gbnVsbCwgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IENvbmRpdGlvbmFsRXhwcih0aGlzLCB0cnVlQ2FzZSwgZmFsc2VDYXNlLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgZXF1YWxzKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5FcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIG5vdEVxdWFscyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBpZGVudGljYWwocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbm90SWRlbnRpY2FsKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWwsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIG1pbnVzKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NaW51cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgcGx1cyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuUGx1cywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgZGl2aWRlKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5EaXZpZGUsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIG11bHRpcGx5KHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5NdWx0aXBseSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbW9kdWxvKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5Nb2R1bG8sIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGFuZChyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQW5kLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBiaXR3aXNlQW5kKHJocywgc291cmNlU3BhbiwgcGFyZW5zID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5CaXR3aXNlQW5kLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4sIHBhcmVucyk7XG4gICAgfVxuICAgIG9yKHJocywgc291cmNlU3Bhbikge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgbG93ZXIocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkxvd2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBsb3dlckVxdWFscyhyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuTG93ZXJFcXVhbHMsIHRoaXMsIHJocywgbnVsbCwgc291cmNlU3Bhbik7XG4gICAgfVxuICAgIGJpZ2dlcihyaHMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQmlnZ2VyLCB0aGlzLCByaHMsIG51bGwsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBiaWdnZXJFcXVhbHMocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscywgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgaXNCbGFuayhzb3VyY2VTcGFuKSB7XG4gICAgICAgIC8vIE5vdGU6IFdlIHVzZSBlcXVhbHMgYnkgcHVycG9zZSBoZXJlIHRvIGNvbXBhcmUgdG8gbnVsbCBhbmQgdW5kZWZpbmVkIGluIEpTLlxuICAgICAgICAvLyBXZSB1c2UgdGhlIHR5cGVkIG51bGwgdG8gYWxsb3cgc3RyaWN0TnVsbENoZWNrcyB0byBuYXJyb3cgdHlwZXMuXG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhUWVBFRF9OVUxMX0VYUFIsIHNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICBudWxsaXNoQ29hbGVzY2UocmhzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLk51bGxpc2hDb2FsZXNjZSwgdGhpcywgcmhzLCBudWxsLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdG9TdG10KCkge1xuICAgICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodGhpcywgbnVsbCk7XG4gICAgfVxufVxuY2xhc3MgUmVhZFZhckV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFJlYWRWYXJFeHByICYmIHRoaXMubmFtZSA9PT0gZS5uYW1lO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UmVhZFZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHNldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVmFyRXhwcih0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIFR5cGVvZkV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihleHByLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFR5cGVvZkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVHlwZW9mRXhwciAmJiBlLmV4cHIuaXNFcXVpdmFsZW50KHRoaXMuZXhwcik7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHIuaXNDb25zdGFudCgpO1xuICAgIH1cbn1cbmNsYXNzIFdyYXBwZWROb2RlRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgV3JhcHBlZE5vZGVFeHByICYmIHRoaXMubm9kZSA9PT0gZS5ub2RlO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0V3JhcHBlZE5vZGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFdyaXRlVmFyRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdmFsdWUudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZVZhckV4cHIgJiYgdGhpcy5uYW1lID09PSBlLm5hbWUgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZVZhckV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxuICAgIHRvRGVjbFN0bXQodHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjbGFyZVZhclN0bXQodGhpcy5uYW1lLCB0aGlzLnZhbHVlLCB0eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHRvQ29uc3REZWNsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0RlY2xTdG10KElORkVSUkVEX1RZUEUsIFN0bXRNb2RpZmllci5GaW5hbCk7XG4gICAgfVxufVxuY2xhc3MgV3JpdGVLZXlFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZXIsIGluZGV4LCB2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFdyaXRlS2V5RXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5pbmRleC5pc0VxdWl2YWxlbnQoZS5pbmRleCkgJiYgdGhpcy52YWx1ZS5pc0VxdWl2YWxlbnQoZS52YWx1ZSk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRXcml0ZUtleUV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgV3JpdGVQcm9wRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlY2VpdmVyLCBuYW1lLCB2YWx1ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlIHx8IHZhbHVlLnR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBXcml0ZVByb3BFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09IGUubmFtZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFdyaXRlUHJvcEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSW52b2tlRnVuY3Rpb25FeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZm4sIGFyZ3MsIHR5cGUsIHNvdXJjZVNwYW4sIHB1cmUgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLnB1cmUgPSBwdXJlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEludm9rZUZ1bmN0aW9uRXhwciAmJiB0aGlzLmZuLmlzRXF1aXZhbGVudChlLmZuKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmFyZ3MsIGUuYXJncykgJiYgdGhpcy5wdXJlID09PSBlLnB1cmU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRJbnZva2VGdW5jdGlvbkV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgVGFnZ2VkVGVtcGxhdGVFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodGFnLCB0ZW1wbGF0ZSwgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBUYWdnZWRUZW1wbGF0ZUV4cHIgJiYgdGhpcy50YWcuaXNFcXVpdmFsZW50KGUudGFnKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudFByZWRpY2F0ZSh0aGlzLnRlbXBsYXRlLmVsZW1lbnRzLCBlLnRlbXBsYXRlLmVsZW1lbnRzLCAoYSwgYikgPT4gYS50ZXh0ID09PSBiLnRleHQpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMudGVtcGxhdGUuZXhwcmVzc2lvbnMsIGUudGVtcGxhdGUuZXhwcmVzc2lvbnMpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEluc3RhbnRpYXRlRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGNsYXNzRXhwciwgYXJncywgdHlwZSwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5jbGFzc0V4cHIgPSBjbGFzc0V4cHI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgSW5zdGFudGlhdGVFeHByICYmIHRoaXMuY2xhc3NFeHByLmlzRXF1aXZhbGVudChlLmNsYXNzRXhwcikgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5hcmdzLCBlLmFyZ3MpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SW5zdGFudGlhdGVFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiB0aGlzLnZhbHVlID09PSBlLnZhbHVlO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBUZW1wbGF0ZUxpdGVyYWwge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCBleHByZXNzaW9ucykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG59XG5jbGFzcyBUZW1wbGF0ZUxpdGVyYWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzb3VyY2VTcGFuLCByYXdUZXh0KSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIC8vIElmIGByYXdUZXh0YCBpcyBub3QgcHJvdmlkZWQsIHRyeSB0byBleHRyYWN0IHRoZSByYXcgc3RyaW5nIGZyb20gaXRzXG4gICAgICAgIC8vIGFzc29jaWF0ZWQgYHNvdXJjZVNwYW5gLiBJZiB0aGF0IGlzIGFsc28gbm90IGF2YWlsYWJsZSwgXCJmYWtlXCIgdGhlIHJhd1xuICAgICAgICAvLyBzdHJpbmcgaW5zdGVhZCBieSBlc2NhcGluZyB0aGUgZm9sbG93aW5nIGNvbnRyb2wgc2VxdWVuY2VzOlxuICAgICAgICAvLyAtIFwiXFxcIiB3b3VsZCBvdGhlcndpc2UgaW5kaWNhdGUgdGhhdCB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3Rlci5cbiAgICAgICAgLy8gLSBcImBcIiBhbmQgXCIke1wiIGFyZSB0ZW1wbGF0ZSBzdHJpbmcgY29udHJvbCBzZXF1ZW5jZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgcHJlbWF0dXJlbHlcbiAgICAgICAgLy8gaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBlbGVtZW50LlxuICAgICAgICB0aGlzLnJhd1RleHQgPVxuICAgICAgICAgICAgcmF3VGV4dCA/PyBzb3VyY2VTcGFuPy50b1N0cmluZygpID8/IGVzY2FwZUZvclRlbXBsYXRlTGl0ZXJhbChlc2NhcGVTbGFzaGVzKHRleHQpKTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsUGllY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG59XG5jbGFzcyBQbGFjZWhvbGRlclBpZWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSBgUGxhY2Vob2xkZXJQaWVjZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dCB0aGUgbmFtZSBvZiB0aGlzIHBsYWNlaG9sZGVyIChlLmcuIGBQSF8xYCkuXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gdGhlIGxvY2F0aW9uIG9mIHRoaXMgcGxhY2Vob2xkZXIgaW4gaXRzIGxvY2FsaXplZCBtZXNzYWdlIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKiBAcGFyYW0gYXNzb2NpYXRlZE1lc3NhZ2UgcmVmZXJlbmNlIHRvIGFub3RoZXIgbWVzc2FnZSB0aGF0IHRoaXMgcGxhY2Vob2xkZXIgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgICAqIFRoZSBgYXNzb2NpYXRlZE1lc3NhZ2VgIGlzIG1haW5seSB1c2VkIHRvIHByb3ZpZGUgYSByZWxhdGlvbnNoaXAgdG8gYW4gSUNVIG1lc3NhZ2UgdGhhdCBoYXNcbiAgICAgKiBiZWVuIGV4dHJhY3RlZCBvdXQgZnJvbSB0aGUgbWVzc2FnZSBjb250YWluaW5nIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmFzc29jaWF0ZWRNZXNzYWdlID0gYXNzb2NpYXRlZE1lc3NhZ2U7XG4gICAgfVxufVxuY29uc3QgTUVBTklOR19TRVBBUkFUT1IkMSA9ICd8JztcbmNvbnN0IElEX1NFUEFSQVRPUiQxID0gJ0BAJztcbmNvbnN0IExFR0FDWV9JRF9JTkRJQ0FUT1IgPSAn4pCfJztcbmNsYXNzIExvY2FsaXplZFN0cmluZyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFCbG9jaywgbWVzc2FnZVBhcnRzLCBwbGFjZUhvbGRlck5hbWVzLCBleHByZXNzaW9ucywgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcihTVFJJTkdfVFlQRSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubWV0YUJsb2NrID0gbWV0YUJsb2NrO1xuICAgICAgICB0aGlzLm1lc3NhZ2VQYXJ0cyA9IG1lc3NhZ2VQYXJ0cztcbiAgICAgICAgdGhpcy5wbGFjZUhvbGRlck5hbWVzID0gcGxhY2VIb2xkZXJOYW1lcztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICAvLyByZXR1cm4gZSBpbnN0YW5jZW9mIExvY2FsaXplZFN0cmluZyAmJiB0aGlzLm1lc3NhZ2UgPT09IGUubWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TG9jYWxpemVkU3RyaW5nKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBtZXRhYCBhbmQgYG1lc3NhZ2VQYXJ0YCBpbnRvIFwiY29va2VkXCIgYW5kIFwicmF3XCIgc3RyaW5ncyB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICogaW4gYSBgJGxvY2FsaXplYCB0YWdnZWQgc3RyaW5nLiBUaGUgZm9ybWF0IG9mIHRoZSBtZXRhZGF0YSBpcyB0aGUgc2FtZSBhcyB0aGF0IHBhcnNlZCBieVxuICAgICAqIGBwYXJzZUkxOG5NZXRhKClgLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGEgVGhlIG1ldGFkYXRhIHRvIHNlcmlhbGl6ZVxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFydCBUaGUgZmlyc3QgcGFydCBvZiB0aGUgdGFnZ2VkIHN0cmluZ1xuICAgICAqL1xuICAgIHNlcmlhbGl6ZUkxOG5IZWFkKCkge1xuICAgICAgICBsZXQgbWV0YUJsb2NrID0gdGhpcy5tZXRhQmxvY2suZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgICAgIGlmICh0aGlzLm1ldGFCbG9jay5tZWFuaW5nKSB7XG4gICAgICAgICAgICBtZXRhQmxvY2sgPSBgJHt0aGlzLm1ldGFCbG9jay5tZWFuaW5nfSR7TUVBTklOR19TRVBBUkFUT1IkMX0ke21ldGFCbG9ja31gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFCbG9jay5jdXN0b21JZCkge1xuICAgICAgICAgICAgbWV0YUJsb2NrID0gYCR7bWV0YUJsb2NrfSR7SURfU0VQQVJBVE9SJDF9JHt0aGlzLm1ldGFCbG9jay5jdXN0b21JZH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFCbG9jay5sZWdhY3lJZHMpIHtcbiAgICAgICAgICAgIHRoaXMubWV0YUJsb2NrLmxlZ2FjeUlkcy5mb3JFYWNoKGxlZ2FjeUlkID0+IHtcbiAgICAgICAgICAgICAgICBtZXRhQmxvY2sgPSBgJHttZXRhQmxvY2t9JHtMRUdBQ1lfSURfSU5ESUNBVE9SfSR7bGVnYWN5SWR9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVDb29rZWRSYXdTdHJpbmcobWV0YUJsb2NrLCB0aGlzLm1lc3NhZ2VQYXJ0c1swXS50ZXh0LCB0aGlzLmdldE1lc3NhZ2VQYXJ0U291cmNlU3BhbigwKSk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2VQYXJ0U291cmNlU3BhbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VQYXJ0c1tpXT8uc291cmNlU3BhbiA/PyB0aGlzLnNvdXJjZVNwYW47XG4gICAgfVxuICAgIGdldFBsYWNlaG9sZGVyU291cmNlU3BhbihpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYWNlSG9sZGVyTmFtZXNbaV0/LnNvdXJjZVNwYW4gPz8gdGhpcy5leHByZXNzaW9uc1tpXT8uc291cmNlU3BhbiA/P1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VTcGFuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBwbGFjZWhvbGRlck5hbWVgIGFuZCBgbWVzc2FnZVBhcnRgIGludG8gXCJjb29rZWRcIiBhbmQgXCJyYXdcIiBzdHJpbmdzIHRoYXRcbiAgICAgKiBjYW4gYmUgdXNlZCBpbiBhIGAkbG9jYWxpemVgIHRhZ2dlZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBUaGUgZm9ybWF0IGlzIGA6PHBsYWNlaG9sZGVyLW5hbWU+W0BAPGFzc29jaWF0ZWQtaWQ+XTpgLlxuICAgICAqXG4gICAgICogVGhlIGBhc3NvY2lhdGVkLWlkYCBpcyB0aGUgbWVzc2FnZSBpZCBvZiB0aGUgKHVzdWFsbHkgYW4gSUNVKSBtZXNzYWdlIHRvIHdoaWNoIHRoaXMgcGxhY2Vob2xkZXJcbiAgICAgKiByZWZlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFydEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVzc2FnZSBwYXJ0IHRvIHNlcmlhbGl6ZS5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVJMThuVGVtcGxhdGVQYXJ0KHBhcnRJbmRleCkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2VIb2xkZXJOYW1lc1twYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgY29uc3QgbWVzc2FnZVBhcnQgPSB0aGlzLm1lc3NhZ2VQYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICBsZXQgbWV0YUJsb2NrID0gcGxhY2Vob2xkZXIudGV4dDtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmFzc29jaWF0ZWRNZXNzYWdlPy5sZWdhY3lJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtZXRhQmxvY2sgKz0gYCR7SURfU0VQQVJBVE9SJDF9JHtjb21wdXRlTXNnSWQocGxhY2Vob2xkZXIuYXNzb2NpYXRlZE1lc3NhZ2UubWVzc2FnZVN0cmluZywgcGxhY2Vob2xkZXIuYXNzb2NpYXRlZE1lc3NhZ2UubWVhbmluZyl9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlQ29va2VkUmF3U3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnQudGV4dCwgdGhpcy5nZXRNZXNzYWdlUGFydFNvdXJjZVNwYW4ocGFydEluZGV4KSk7XG4gICAgfVxufVxuY29uc3QgZXNjYXBlU2xhc2hlcyA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpO1xuY29uc3QgZXNjYXBlU3RhcnRpbmdDb2xvbiA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9eOi8sICdcXFxcOicpO1xuY29uc3QgZXNjYXBlQ29sb25zID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoLzovZywgJ1xcXFw6Jyk7XG5jb25zdCBlc2NhcGVGb3JUZW1wbGF0ZUxpdGVyYWwgPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvYC9nLCAnXFxcXGAnKS5yZXBsYWNlKC9cXCR7L2csICckXFxcXHsnKTtcbi8qKlxuICogQ3JlYXRlcyBhIGB7Y29va2VkLCByYXd9YCBvYmplY3QgZnJvbSB0aGUgYG1ldGFCbG9ja2AgYW5kIGBtZXNzYWdlUGFydGAuXG4gKlxuICogVGhlIGByYXdgIHRleHQgbXVzdCBoYXZlIHZhcmlvdXMgY2hhcmFjdGVyIHNlcXVlbmNlcyBlc2NhcGVkOlxuICogKiBcIlxcXCIgd291bGQgb3RoZXJ3aXNlIGluZGljYXRlIHRoYXQgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIuXG4gKiAqIFwiYFwiIGFuZCBcIiR7XCIgYXJlIHRlbXBsYXRlIHN0cmluZyBjb250cm9sIHNlcXVlbmNlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBwcmVtYXR1cmVseSBpbmRpY2F0ZVxuICogICB0aGUgZW5kIG9mIGEgbWVzc2FnZSBwYXJ0LlxuICogKiBcIjpcIiBpbnNpZGUgYSBtZXRhYmxvY2sgd291bGQgcHJlbWF0dXJlbHkgaW5kaWNhdGUgdGhlIGVuZCBvZiB0aGUgbWV0YWJsb2NrLlxuICogKiBcIjpcIiBhdCB0aGUgc3RhcnQgb2YgYSBtZXNzYWdlUGFydCB3aXRoIG5vIG1ldGFibG9jayB3b3VsZCBlcnJvbmVvdXNseSBpbmRpY2F0ZSB0aGUgc3RhcnQgb2YgYVxuICogICBtZXRhYmxvY2suXG4gKlxuICogQHBhcmFtIG1ldGFCbG9jayBBbnkgbWV0YWRhdGEgdGhhdCBzaG91bGQgYmUgcHJlcGVuZGVkIHRvIHRoZSBzdHJpbmdcbiAqIEBwYXJhbSBtZXNzYWdlUGFydCBUaGUgbWVzc2FnZSBwYXJ0IG9mIHRoZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29va2VkUmF3U3RyaW5nKG1ldGFCbG9jaywgbWVzc2FnZVBhcnQsIHJhbmdlKSB7XG4gICAgaWYgKG1ldGFCbG9jayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvb2tlZDogbWVzc2FnZVBhcnQsXG4gICAgICAgICAgICByYXc6IGVzY2FwZUZvclRlbXBsYXRlTGl0ZXJhbChlc2NhcGVTdGFydGluZ0NvbG9uKGVzY2FwZVNsYXNoZXMobWVzc2FnZVBhcnQpKSksXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb29rZWQ6IGA6JHttZXRhQmxvY2t9OiR7bWVzc2FnZVBhcnR9YCxcbiAgICAgICAgICAgIHJhdzogZXNjYXBlRm9yVGVtcGxhdGVMaXRlcmFsKGA6JHtlc2NhcGVDb2xvbnMoZXNjYXBlU2xhc2hlcyhtZXRhQmxvY2spKX06JHtlc2NhcGVTbGFzaGVzKG1lc3NhZ2VQYXJ0KX1gKSxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIEV4dGVybmFsRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0eXBlLCB0eXBlUGFyYW1zID0gbnVsbCwgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcih0eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGVQYXJhbXMgPSB0eXBlUGFyYW1zO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEV4dGVybmFsRXhwciAmJiB0aGlzLnZhbHVlLm5hbWUgPT09IGUudmFsdWUubmFtZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS5tb2R1bGVOYW1lID09PSBlLnZhbHVlLm1vZHVsZU5hbWUgJiYgdGhpcy52YWx1ZS5ydW50aW1lID09PSBlLnZhbHVlLnJ1bnRpbWU7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHRlcm5hbEV4cHIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXh0ZXJuYWxSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKG1vZHVsZU5hbWUsIG5hbWUsIHJ1bnRpbWUpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVOYW1lID0gbW9kdWxlTmFtZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZTtcbiAgICB9XG59XG5jbGFzcyBDb25kaXRpb25hbEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UgPSBudWxsLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUgfHwgdHJ1ZUNhc2UudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xuICAgICAgICB0aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENvbmRpdGlvbmFsRXhwciAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pICYmXG4gICAgICAgICAgICB0aGlzLnRydWVDYXNlLmlzRXF1aXZhbGVudChlLnRydWVDYXNlKSAmJiBudWxsU2FmZUlzRXF1aXZhbGVudCh0aGlzLmZhbHNlQ2FzZSwgZS5mYWxzZUNhc2UpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29uZGl0aW9uYWxFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIE5vdEV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoQk9PTF9UWVBFLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgTm90RXhwciAmJiB0aGlzLmNvbmRpdGlvbi5pc0VxdWl2YWxlbnQoZS5jb25kaXRpb24pO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm90RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBGblBhcmFtIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gbnVsbCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gcGFyYW0ubmFtZTtcbiAgICB9XG59XG5jbGFzcyBGdW5jdGlvbkV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMsIHN0YXRlbWVudHMsIHR5cGUsIHNvdXJjZVNwYW4sIG5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnN0YXRlbWVudHMgPSBzdGF0ZW1lbnRzO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEZ1bmN0aW9uRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFyYW1zLCBlLnBhcmFtcykgJiZcbiAgICAgICAgICAgIGFyZUFsbEVxdWl2YWxlbnQodGhpcy5zdGF0ZW1lbnRzLCBlLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RnVuY3Rpb25FeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0b0RlY2xTdG10KG5hbWUsIG1vZGlmaWVycykge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmVGdW5jdGlvblN0bXQobmFtZSwgdGhpcy5wYXJhbXMsIHRoaXMuc3RhdGVtZW50cywgdGhpcy50eXBlLCBtb2RpZmllcnMsIHRoaXMuc291cmNlU3Bhbik7XG4gICAgfVxufVxuY2xhc3MgVW5hcnlPcGVyYXRvckV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcGVyYXRvciwgZXhwciwgdHlwZSwgc291cmNlU3BhbiwgcGFyZW5zID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcih0eXBlIHx8IE5VTUJFUl9UWVBFLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgICAgICB0aGlzLnBhcmVucyA9IHBhcmVucztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBVbmFyeU9wZXJhdG9yRXhwciAmJiB0aGlzLm9wZXJhdG9yID09PSBlLm9wZXJhdG9yICYmXG4gICAgICAgICAgICB0aGlzLmV4cHIuaXNFcXVpdmFsZW50KGUuZXhwcik7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVbmFyeU9wZXJhdG9yRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBCaW5hcnlPcGVyYXRvckV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcGVyYXRvciwgbGhzLCByaHMsIHR5cGUsIHNvdXJjZVNwYW4sIHBhcmVucyA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSB8fCBsaHMudHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5yaHMgPSByaHM7XG4gICAgICAgIHRoaXMucGFyZW5zID0gcGFyZW5zO1xuICAgICAgICB0aGlzLmxocyA9IGxocztcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBCaW5hcnlPcGVyYXRvckV4cHIgJiYgdGhpcy5vcGVyYXRvciA9PT0gZS5vcGVyYXRvciAmJlxuICAgICAgICAgICAgdGhpcy5saHMuaXNFcXVpdmFsZW50KGUubGhzKSAmJiB0aGlzLnJocy5pc0VxdWl2YWxlbnQoZS5yaHMpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFJlYWRQcm9wRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKHJlY2VpdmVyLCBuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGlzRXF1aXZhbGVudChlKSB7XG4gICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZFByb3BFeHByICYmIHRoaXMucmVjZWl2ZXIuaXNFcXVpdmFsZW50KGUucmVjZWl2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09IGUubmFtZTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJlYWRQcm9wRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVQcm9wRXhwcih0aGlzLnJlY2VpdmVyLCB0aGlzLm5hbWUsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIFJlYWRLZXlFeHByIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZXIsIGluZGV4LCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBSZWFkS2V5RXhwciAmJiB0aGlzLnJlY2VpdmVyLmlzRXF1aXZhbGVudChlLnJlY2VpdmVyKSAmJlxuICAgICAgICAgICAgdGhpcy5pbmRleC5pc0VxdWl2YWxlbnQoZS5pbmRleCk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWFkS2V5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVLZXlFeHByKHRoaXMucmVjZWl2ZXIsIHRoaXMuaW5kZXgsIHZhbHVlLCBudWxsLCB0aGlzLnNvdXJjZVNwYW4pO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxBcnJheUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzLmV2ZXJ5KGUgPT4gZS5pc0NvbnN0YW50KCkpO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIExpdGVyYWxBcnJheUV4cHIgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmVudHJpZXMsIGUuZW50cmllcyk7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5RXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsTWFwRW50cnkge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUsIHF1b3RlZCkge1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnF1b3RlZCA9IHF1b3RlZDtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5ID09PSBlLmtleSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChlLnZhbHVlKTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsTWFwRXhwciBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGVudHJpZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgc3VwZXIodHlwZSwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMudmFsdWVUeXBlID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVUeXBlID0gdHlwZS52YWx1ZVR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBMaXRlcmFsTWFwRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMuZW50cmllcywgZS5lbnRyaWVzKTtcbiAgICB9XG4gICAgaXNDb25zdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcy5ldmVyeShlID0+IGUudmFsdWUuaXNDb25zdGFudCgpKTtcbiAgICB9XG4gICAgdmlzaXRFeHByZXNzaW9uKHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRMaXRlcmFsTWFwRXhwcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDb21tYUV4cHIgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJ0cywgc291cmNlU3Bhbikge1xuICAgICAgICBzdXBlcihwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS50eXBlLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoZSkge1xuICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIENvbW1hRXhwciAmJiBhcmVBbGxFcXVpdmFsZW50KHRoaXMucGFydHMsIGUucGFydHMpO1xuICAgIH1cbiAgICBpc0NvbnN0YW50KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvbih2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29tbWFFeHByKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNvbnN0IE5VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBudWxsLCBudWxsKTtcbmNvbnN0IFRZUEVEX05VTExfRVhQUiA9IG5ldyBMaXRlcmFsRXhwcihudWxsLCBJTkZFUlJFRF9UWVBFLCBudWxsKTtcbi8vLy8gU3RhdGVtZW50c1xudmFyIFN0bXRNb2RpZmllcjtcbihmdW5jdGlvbiAoU3RtdE1vZGlmaWVyKSB7XG4gICAgU3RtdE1vZGlmaWVyW1N0bXRNb2RpZmllcltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJGaW5hbFwiXSA9IDFdID0gXCJGaW5hbFwiO1xuICAgIFN0bXRNb2RpZmllcltTdG10TW9kaWZpZXJbXCJQcml2YXRlXCJdID0gMl0gPSBcIlByaXZhdGVcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiRXhwb3J0ZWRcIl0gPSA0XSA9IFwiRXhwb3J0ZWRcIjtcbiAgICBTdG10TW9kaWZpZXJbU3RtdE1vZGlmaWVyW1wiU3RhdGljXCJdID0gOF0gPSBcIlN0YXRpY1wiO1xufSkoU3RtdE1vZGlmaWVyIHx8IChTdG10TW9kaWZpZXIgPSB7fSkpO1xuY2xhc3MgTGVhZGluZ0NvbW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIG11bHRpbGluZSwgdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gbXVsdGlsaW5lO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTmV3bGluZSA9IHRyYWlsaW5nTmV3bGluZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpbGluZSA/IGAgJHt0aGlzLnRleHR9IGAgOiB0aGlzLnRleHQ7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NDb21tZW50IGV4dGVuZHMgTGVhZGluZ0NvbW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRhZ3MpIHtcbiAgICAgICAgc3VwZXIoJycsIC8qIG11bHRpbGluZSAqLyB0cnVlLCAvKiB0cmFpbGluZ05ld2xpbmUgKi8gdHJ1ZSk7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplVGFncyh0aGlzLnRhZ3MpO1xuICAgIH1cbn1cbmNsYXNzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IobW9kaWZpZXJzID0gU3RtdE1vZGlmaWVyLk5vbmUsIHNvdXJjZVNwYW4gPSBudWxsLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMubGVhZGluZ0NvbW1lbnRzID0gbGVhZGluZ0NvbW1lbnRzO1xuICAgIH1cbiAgICBoYXNNb2RpZmllcihtb2RpZmllcikge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kaWZpZXJzICYgbW9kaWZpZXIpICE9PSAwO1xuICAgIH1cbiAgICBhZGRMZWFkaW5nQ29tbWVudChsZWFkaW5nQ29tbWVudCkge1xuICAgICAgICB0aGlzLmxlYWRpbmdDb21tZW50cyA9IHRoaXMubGVhZGluZ0NvbW1lbnRzID8/IFtdO1xuICAgICAgICB0aGlzLmxlYWRpbmdDb21tZW50cy5wdXNoKGxlYWRpbmdDb21tZW50KTtcbiAgICB9XG59XG5jbGFzcyBEZWNsYXJlVmFyU3RtdCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHR5cGUsIG1vZGlmaWVycywgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKG1vZGlmaWVycywgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8ICh2YWx1ZSAmJiB2YWx1ZS50eXBlKSB8fCBudWxsO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIERlY2xhcmVWYXJTdG10ICYmIHRoaXMubmFtZSA9PT0gc3RtdC5uYW1lICYmXG4gICAgICAgICAgICAodGhpcy52YWx1ZSA/ICEhc3RtdC52YWx1ZSAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChzdG10LnZhbHVlKSA6ICFzdG10LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVWYXJTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIERlY2xhcmVGdW5jdGlvblN0bXQgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBhcmFtcywgc3RhdGVtZW50cywgdHlwZSwgbW9kaWZpZXJzLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpIHtcbiAgICAgICAgc3VwZXIobW9kaWZpZXJzLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zdGF0ZW1lbnRzID0gc3RhdGVtZW50cztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIERlY2xhcmVGdW5jdGlvblN0bXQgJiYgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnBhcmFtcywgc3RtdC5wYXJhbXMpICYmXG4gICAgICAgICAgICBhcmVBbGxFcXVpdmFsZW50KHRoaXMuc3RhdGVtZW50cywgc3RtdC5zdGF0ZW1lbnRzKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdERlY2xhcmVGdW5jdGlvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblN0YXRlbWVudCBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAgY29uc3RydWN0b3IoZXhwciwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKFN0bXRNb2RpZmllci5Ob25lLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpO1xuICAgICAgICB0aGlzLmV4cHIgPSBleHByO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQgJiYgdGhpcy5leHByLmlzRXF1aXZhbGVudChzdG10LmV4cHIpO1xuICAgIH1cbiAgICB2aXNpdFN0YXRlbWVudCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwcmVzc2lvblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgUmV0dXJuU3RhdGVtZW50IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3BhbiA9IG51bGwsIGxlYWRpbmdDb21tZW50cykge1xuICAgICAgICBzdXBlcihTdG10TW9kaWZpZXIuTm9uZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0VxdWl2YWxlbnQoc3RtdCkge1xuICAgICAgICByZXR1cm4gc3RtdCBpbnN0YW5jZW9mIFJldHVyblN0YXRlbWVudCAmJiB0aGlzLnZhbHVlLmlzRXF1aXZhbGVudChzdG10LnZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXRTdGF0ZW1lbnQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFJldHVyblN0bXQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSWZTdG10IGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25kaXRpb24sIHRydWVDYXNlLCBmYWxzZUNhc2UgPSBbXSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKSB7XG4gICAgICAgIHN1cGVyKFN0bXRNb2RpZmllci5Ob25lLCBzb3VyY2VTcGFuLCBsZWFkaW5nQ29tbWVudHMpO1xuICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvbjtcbiAgICAgICAgdGhpcy50cnVlQ2FzZSA9IHRydWVDYXNlO1xuICAgICAgICB0aGlzLmZhbHNlQ2FzZSA9IGZhbHNlQ2FzZTtcbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KHN0bXQpIHtcbiAgICAgICAgcmV0dXJuIHN0bXQgaW5zdGFuY2VvZiBJZlN0bXQgJiYgdGhpcy5jb25kaXRpb24uaXNFcXVpdmFsZW50KHN0bXQuY29uZGl0aW9uKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLnRydWVDYXNlLCBzdG10LnRydWVDYXNlKSAmJlxuICAgICAgICAgICAgYXJlQWxsRXF1aXZhbGVudCh0aGlzLmZhbHNlQ2FzZSwgc3RtdC5mYWxzZUNhc2UpO1xuICAgIH1cbiAgICB2aXNpdFN0YXRlbWVudCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWZTdG10KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSB7XG4gICAgdmlzaXRUeXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhc3QudHlwZSkge1xuICAgICAgICAgICAgYXN0LnR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0QnVpbHRpblR5cGUodHlwZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0RXhwcmVzc2lvblR5cGUodHlwZSwgY29udGV4dCkge1xuICAgICAgICB0eXBlLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHR5cGUudHlwZVBhcmFtcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHlwZS50eXBlUGFyYW1zLmZvckVhY2gocGFyYW0gPT4gdGhpcy52aXNpdFR5cGUocGFyYW0sIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0QXJyYXlUeXBlKHR5cGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUeXBlKHR5cGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdE1hcFR5cGUodHlwZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdFR5cGUodHlwZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0V3JhcHBlZE5vZGVFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFR5cGVvZkV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFJlYWRWYXJFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRXcml0ZVZhckV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlS2V5RXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0V3JpdGVQcm9wRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0SW52b2tlRnVuY3Rpb25FeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC50YWcudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnRlbXBsYXRlLmV4cHJlc3Npb25zLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0SW5zdGFudGlhdGVFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExvY2FsaXplZFN0cmluZyhhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0RXh0ZXJuYWxFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBpZiAoYXN0LnR5cGVQYXJhbXMpIHtcbiAgICAgICAgICAgIGFzdC50eXBlUGFyYW1zLmZvckVhY2godHlwZSA9PiB0eXBlLnZpc2l0VHlwZSh0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWxFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuY29uZGl0aW9uLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnRydWVDYXNlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LmZhbHNlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdE5vdEV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5jb25kaXRpb24udmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEV4cHJlc3Npb24oYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRGdW5jdGlvbkV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0VW5hcnlPcGVyYXRvckV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QubGhzLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFJlYWRQcm9wRXhwcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UmVhZEtleUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIGFzdC5pbmRleC52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RXhwcmVzc2lvbihhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXBFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBhc3QuZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4gZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q29tbWFFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LnBhcnRzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFeHByZXNzaW9uKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwcnMsIGNvbnRleHQpIHtcbiAgICAgICAgZXhwcnMuZm9yRWFjaChleHByID0+IGV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlVmFyU3RtdChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChzdG10LnZhbHVlKSB7XG4gICAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RtdC50eXBlKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnN0YXRlbWVudHMsIGNvbnRleHQpO1xuICAgICAgICBpZiAoc3RtdC50eXBlKSB7XG4gICAgICAgICAgICBzdG10LnR5cGUudmlzaXRUeXBlKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb25TdG10KHN0bXQsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdC5leHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHN0bXQ7XG4gICAgfVxuICAgIHZpc2l0UmV0dXJuU3RtdChzdG10LCBjb250ZXh0KSB7XG4gICAgICAgIHN0bXQudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gc3RtdDtcbiAgICB9XG4gICAgdmlzaXRJZlN0bXQoc3RtdCwgY29udGV4dCkge1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LmZhbHNlQ2FzZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBzdG10O1xuICAgIH1cbiAgICB2aXNpdEFsbFN0YXRlbWVudHMoc3RtdHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3RtdHMuZm9yRWFjaChzdG10ID0+IHN0bXQudmlzaXRTdGF0ZW1lbnQodGhpcywgY29udGV4dCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxlYWRpbmdDb21tZW50KHRleHQsIG11bHRpbGluZSA9IGZhbHNlLCB0cmFpbGluZ05ld2xpbmUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIG5ldyBMZWFkaW5nQ29tbWVudCh0ZXh0LCBtdWx0aWxpbmUsIHRyYWlsaW5nTmV3bGluZSk7XG59XG5mdW5jdGlvbiBqc0RvY0NvbW1lbnQodGFncyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBKU0RvY0NvbW1lbnQodGFncyk7XG59XG5mdW5jdGlvbiB2YXJpYWJsZShuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkVmFyRXhwcihuYW1lLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGltcG9ydEV4cHIoaWQsIHR5cGVQYXJhbXMgPSBudWxsLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBFeHRlcm5hbEV4cHIoaWQsIG51bGwsIHR5cGVQYXJhbXMsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gaW1wb3J0VHlwZShpZCwgdHlwZVBhcmFtcywgdHlwZU1vZGlmaWVycykge1xuICAgIHJldHVybiBpZCAhPSBudWxsID8gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihpZCwgdHlwZVBhcmFtcywgbnVsbCksIHR5cGVNb2RpZmllcnMpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb25UeXBlKGV4cHIsIHR5cGVNb2RpZmllcnMsIHR5cGVQYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25UeXBlKGV4cHIsIHR5cGVNb2RpZmllcnMsIHR5cGVQYXJhbXMpO1xufVxuZnVuY3Rpb24gdHlwZW9mRXhwcihleHByKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlb2ZFeHByKGV4cHIpO1xufVxuZnVuY3Rpb24gbGl0ZXJhbEFycih2YWx1ZXMsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxBcnJheUV4cHIodmFsdWVzLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWxNYXAodmFsdWVzLCB0eXBlID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcEV4cHIodmFsdWVzLm1hcChlID0+IG5ldyBMaXRlcmFsTWFwRW50cnkoZS5rZXksIGUudmFsdWUsIGUucXVvdGVkKSksIHR5cGUsIG51bGwpO1xufVxuZnVuY3Rpb24gdW5hcnkob3BlcmF0b3IsIGV4cHIsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IFVuYXJ5T3BlcmF0b3JFeHByKG9wZXJhdG9yLCBleHByLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIG5vdChleHByLCBzb3VyY2VTcGFuKSB7XG4gICAgcmV0dXJuIG5ldyBOb3RFeHByKGV4cHIsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gZm4ocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbkV4cHIocGFyYW1zLCBib2R5LCB0eXBlLCBzb3VyY2VTcGFuLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGlmU3RtdChjb25kaXRpb24sIHRoZW5DbGF1c2UsIGVsc2VDbGF1c2UsIHNvdXJjZVNwYW4sIGxlYWRpbmdDb21tZW50cykge1xuICAgIHJldHVybiBuZXcgSWZTdG10KGNvbmRpdGlvbiwgdGhlbkNsYXVzZSwgZWxzZUNsYXVzZSwgc291cmNlU3BhbiwgbGVhZGluZ0NvbW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHRhZ2dlZFRlbXBsYXRlKHRhZywgdGVtcGxhdGUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IFRhZ2dlZFRlbXBsYXRlRXhwcih0YWcsIHRlbXBsYXRlLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHR5cGUsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IExpdGVyYWxFeHByKHZhbHVlLCB0eXBlLCBzb3VyY2VTcGFuKTtcbn1cbmZ1bmN0aW9uIGxvY2FsaXplZFN0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0cywgcGxhY2Vob2xkZXJOYW1lcywgZXhwcmVzc2lvbnMsIHNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4gbmV3IExvY2FsaXplZFN0cmluZyhtZXRhQmxvY2ssIG1lc3NhZ2VQYXJ0cywgcGxhY2Vob2xkZXJOYW1lcywgZXhwcmVzc2lvbnMsIHNvdXJjZVNwYW4pO1xufVxuZnVuY3Rpb24gaXNOdWxsKGV4cCkge1xuICAgIHJldHVybiBleHAgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiBleHAudmFsdWUgPT09IG51bGw7XG59XG4vKlxuICogU2VyaWFsaXplcyBhIGBUYWdgIGludG8gYSBzdHJpbmcuXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGxpa2UgXCIgQGZvbyB7YmFyfSBiYXpcIiAobm90ZSB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIGJlZm9yZSBgQGZvb2ApLlxuICovXG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWcpIHtcbiAgICBsZXQgb3V0ID0gJyc7XG4gICAgaWYgKHRhZy50YWdOYW1lKSB7XG4gICAgICAgIG91dCArPSBgIEAke3RhZy50YWdOYW1lfWA7XG4gICAgfVxuICAgIGlmICh0YWcudGV4dCkge1xuICAgICAgICBpZiAodGFnLnRleHQubWF0Y2goL1xcL1xcKnxcXCpcXC8vKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU0RvYyB0ZXh0IGNhbm5vdCBjb250YWluIFwiLypcIiBhbmQgXCIqL1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICcgJyArIHRhZy50ZXh0LnJlcGxhY2UoL0AvZywgJ1xcXFxAJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUYWdzKHRhZ3MpIHtcbiAgICBpZiAodGFncy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAodGFncy5sZW5ndGggPT09IDEgJiYgdGFnc1swXS50YWdOYW1lICYmICF0YWdzWzBdLnRleHQpIHtcbiAgICAgICAgLy8gVGhlIEpTRE9DIGNvbW1lbnQgaXMgYSBzaW5nbGUgc2ltcGxlIHRhZzogZS5nIGAvKiogQHRhZ25hbWUgKi9gLlxuICAgICAgICByZXR1cm4gYCoke3RhZ1RvU3RyaW5nKHRhZ3NbMF0pfSBgO1xuICAgIH1cbiAgICBsZXQgb3V0ID0gJypcXG4nO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgb3V0ICs9ICcgKic7XG4gICAgICAgIC8vIElmIHRoZSB0YWdUb1N0cmluZyBpcyBtdWx0aS1saW5lLCBpbnNlcnQgXCIgKiBcIiBwcmVmaXhlcyBvbiBsaW5lcy5cbiAgICAgICAgb3V0ICs9IHRhZ1RvU3RyaW5nKHRhZykucmVwbGFjZSgvXFxuL2csICdcXG4gKiAnKTtcbiAgICAgICAgb3V0ICs9ICdcXG4nO1xuICAgIH1cbiAgICBvdXQgKz0gJyAnO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbnZhciBvdXRwdXRfYXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZXQgVHlwZU1vZGlmaWVyICgpIHsgcmV0dXJuIFR5cGVNb2RpZmllcjsgfSxcbiAgICBUeXBlOiBUeXBlLFxuICAgIGdldCBCdWlsdGluVHlwZU5hbWUgKCkgeyByZXR1cm4gQnVpbHRpblR5cGVOYW1lOyB9LFxuICAgIEJ1aWx0aW5UeXBlOiBCdWlsdGluVHlwZSxcbiAgICBFeHByZXNzaW9uVHlwZTogRXhwcmVzc2lvblR5cGUsXG4gICAgQXJyYXlUeXBlOiBBcnJheVR5cGUsXG4gICAgTWFwVHlwZTogTWFwVHlwZSxcbiAgICBEWU5BTUlDX1RZUEU6IERZTkFNSUNfVFlQRSxcbiAgICBJTkZFUlJFRF9UWVBFOiBJTkZFUlJFRF9UWVBFLFxuICAgIEJPT0xfVFlQRTogQk9PTF9UWVBFLFxuICAgIElOVF9UWVBFOiBJTlRfVFlQRSxcbiAgICBOVU1CRVJfVFlQRTogTlVNQkVSX1RZUEUsXG4gICAgU1RSSU5HX1RZUEU6IFNUUklOR19UWVBFLFxuICAgIEZVTkNUSU9OX1RZUEU6IEZVTkNUSU9OX1RZUEUsXG4gICAgTk9ORV9UWVBFOiBOT05FX1RZUEUsXG4gICAgZ2V0IFVuYXJ5T3BlcmF0b3IgKCkgeyByZXR1cm4gVW5hcnlPcGVyYXRvcjsgfSxcbiAgICBnZXQgQmluYXJ5T3BlcmF0b3IgKCkgeyByZXR1cm4gQmluYXJ5T3BlcmF0b3I7IH0sXG4gICAgbnVsbFNhZmVJc0VxdWl2YWxlbnQ6IG51bGxTYWZlSXNFcXVpdmFsZW50LFxuICAgIGFyZUFsbEVxdWl2YWxlbnQ6IGFyZUFsbEVxdWl2YWxlbnQsXG4gICAgRXhwcmVzc2lvbjogRXhwcmVzc2lvbixcbiAgICBSZWFkVmFyRXhwcjogUmVhZFZhckV4cHIsXG4gICAgVHlwZW9mRXhwcjogVHlwZW9mRXhwcixcbiAgICBXcmFwcGVkTm9kZUV4cHI6IFdyYXBwZWROb2RlRXhwcixcbiAgICBXcml0ZVZhckV4cHI6IFdyaXRlVmFyRXhwcixcbiAgICBXcml0ZUtleUV4cHI6IFdyaXRlS2V5RXhwcixcbiAgICBXcml0ZVByb3BFeHByOiBXcml0ZVByb3BFeHByLFxuICAgIEludm9rZUZ1bmN0aW9uRXhwcjogSW52b2tlRnVuY3Rpb25FeHByLFxuICAgIFRhZ2dlZFRlbXBsYXRlRXhwcjogVGFnZ2VkVGVtcGxhdGVFeHByLFxuICAgIEluc3RhbnRpYXRlRXhwcjogSW5zdGFudGlhdGVFeHByLFxuICAgIExpdGVyYWxFeHByOiBMaXRlcmFsRXhwcixcbiAgICBUZW1wbGF0ZUxpdGVyYWw6IFRlbXBsYXRlTGl0ZXJhbCxcbiAgICBUZW1wbGF0ZUxpdGVyYWxFbGVtZW50OiBUZW1wbGF0ZUxpdGVyYWxFbGVtZW50LFxuICAgIExpdGVyYWxQaWVjZTogTGl0ZXJhbFBpZWNlLFxuICAgIFBsYWNlaG9sZGVyUGllY2U6IFBsYWNlaG9sZGVyUGllY2UsXG4gICAgTG9jYWxpemVkU3RyaW5nOiBMb2NhbGl6ZWRTdHJpbmcsXG4gICAgRXh0ZXJuYWxFeHByOiBFeHRlcm5hbEV4cHIsXG4gICAgRXh0ZXJuYWxSZWZlcmVuY2U6IEV4dGVybmFsUmVmZXJlbmNlLFxuICAgIENvbmRpdGlvbmFsRXhwcjogQ29uZGl0aW9uYWxFeHByLFxuICAgIE5vdEV4cHI6IE5vdEV4cHIsXG4gICAgRm5QYXJhbTogRm5QYXJhbSxcbiAgICBGdW5jdGlvbkV4cHI6IEZ1bmN0aW9uRXhwcixcbiAgICBVbmFyeU9wZXJhdG9yRXhwcjogVW5hcnlPcGVyYXRvckV4cHIsXG4gICAgQmluYXJ5T3BlcmF0b3JFeHByOiBCaW5hcnlPcGVyYXRvckV4cHIsXG4gICAgUmVhZFByb3BFeHByOiBSZWFkUHJvcEV4cHIsXG4gICAgUmVhZEtleUV4cHI6IFJlYWRLZXlFeHByLFxuICAgIExpdGVyYWxBcnJheUV4cHI6IExpdGVyYWxBcnJheUV4cHIsXG4gICAgTGl0ZXJhbE1hcEVudHJ5OiBMaXRlcmFsTWFwRW50cnksXG4gICAgTGl0ZXJhbE1hcEV4cHI6IExpdGVyYWxNYXBFeHByLFxuICAgIENvbW1hRXhwcjogQ29tbWFFeHByLFxuICAgIE5VTExfRVhQUjogTlVMTF9FWFBSLFxuICAgIFRZUEVEX05VTExfRVhQUjogVFlQRURfTlVMTF9FWFBSLFxuICAgIGdldCBTdG10TW9kaWZpZXIgKCkgeyByZXR1cm4gU3RtdE1vZGlmaWVyOyB9LFxuICAgIExlYWRpbmdDb21tZW50OiBMZWFkaW5nQ29tbWVudCxcbiAgICBKU0RvY0NvbW1lbnQ6IEpTRG9jQ29tbWVudCxcbiAgICBTdGF0ZW1lbnQ6IFN0YXRlbWVudCxcbiAgICBEZWNsYXJlVmFyU3RtdDogRGVjbGFyZVZhclN0bXQsXG4gICAgRGVjbGFyZUZ1bmN0aW9uU3RtdDogRGVjbGFyZUZ1bmN0aW9uU3RtdCxcbiAgICBFeHByZXNzaW9uU3RhdGVtZW50OiBFeHByZXNzaW9uU3RhdGVtZW50LFxuICAgIFJldHVyblN0YXRlbWVudDogUmV0dXJuU3RhdGVtZW50LFxuICAgIElmU3RtdDogSWZTdG10LFxuICAgIFJlY3Vyc2l2ZUFzdFZpc2l0b3I6IFJlY3Vyc2l2ZUFzdFZpc2l0b3IkMSxcbiAgICBsZWFkaW5nQ29tbWVudDogbGVhZGluZ0NvbW1lbnQsXG4gICAganNEb2NDb21tZW50OiBqc0RvY0NvbW1lbnQsXG4gICAgdmFyaWFibGU6IHZhcmlhYmxlLFxuICAgIGltcG9ydEV4cHI6IGltcG9ydEV4cHIsXG4gICAgaW1wb3J0VHlwZTogaW1wb3J0VHlwZSxcbiAgICBleHByZXNzaW9uVHlwZTogZXhwcmVzc2lvblR5cGUsXG4gICAgdHlwZW9mRXhwcjogdHlwZW9mRXhwcixcbiAgICBsaXRlcmFsQXJyOiBsaXRlcmFsQXJyLFxuICAgIGxpdGVyYWxNYXA6IGxpdGVyYWxNYXAsXG4gICAgdW5hcnk6IHVuYXJ5LFxuICAgIG5vdDogbm90LFxuICAgIGZuOiBmbixcbiAgICBpZlN0bXQ6IGlmU3RtdCxcbiAgICB0YWdnZWRUZW1wbGF0ZTogdGFnZ2VkVGVtcGxhdGUsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbCxcbiAgICBsb2NhbGl6ZWRTdHJpbmc6IGxvY2FsaXplZFN0cmluZyxcbiAgICBpc051bGw6IGlzTnVsbFxufSk7XG5cbmNvbnN0IENPTlNUQU5UX1BSRUZJWCA9ICdfYyc7XG4vKipcbiAqIGBDb25zdGFudFBvb2xgIHRyaWVzIHRvIHJldXNlIGxpdGVyYWwgZmFjdG9yaWVzIHdoZW4gdHdvIG9yIG1vcmUgbGl0ZXJhbHMgYXJlIGlkZW50aWNhbC5cbiAqIFdlIGRldGVybWluZSB3aGV0aGVyIGxpdGVyYWxzIGFyZSBpZGVudGljYWwgYnkgY3JlYXRpbmcgYSBrZXkgb3V0IG9mIHRoZWlyIEFTVCB1c2luZyB0aGVcbiAqIGBLZXlWaXNpdG9yYC4gVGhpcyBjb25zdGFudCBpcyB1c2VkIHRvIHJlcGxhY2UgZHluYW1pYyBleHByZXNzaW9ucyB3aGljaCBjYW4ndCBiZSBzYWZlbHlcbiAqIGNvbnZlcnRlZCBpbnRvIGEga2V5LiBFLmcuIGdpdmVuIGFuIGV4cHJlc3Npb24gYHtmb286IGJhcigpfWAsIHNpbmNlIHdlIGRvbid0IGtub3cgd2hhdFxuICogdGhlIHJlc3VsdCBvZiBgYmFyYCB3aWxsIGJlLCB3ZSBjcmVhdGUgYSBrZXkgdGhhdCBsb29rcyBsaWtlIGB7Zm9vOiA8dW5rbm93bj59YC4gTm90ZVxuICogdGhhdCB3ZSB1c2UgYSB2YXJpYWJsZSwgcmF0aGVyIHRoYW4gc29tZXRoaW5nIGxpa2UgYG51bGxgIGluIG9yZGVyIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gKi9cbmNvbnN0IFVOS05PV05fVkFMVUVfS0VZID0gdmFyaWFibGUoJzx1bmtub3duPicpO1xuLyoqXG4gKiBDb250ZXh0IHRvIHVzZSB3aGVuIHByb2R1Y2luZyBhIGtleS5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgd2Ugc2VlIHRoZSBjb25zdGFudCBub3QgdGhlIHJlZmVyZW5jZSB2YXJpYWJsZSB3aGVuIHByb2R1Y2luZ1xuICogYSBrZXkuXG4gKi9cbmNvbnN0IEtFWV9DT05URVhUID0ge307XG4vKipcbiAqIEdlbmVyYWxseSBhbGwgcHJpbWl0aXZlIHZhbHVlcyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgYENvbnN0YW50UG9vbGAsIGJ1dCB0aGVyZSBpcyBhbiBleGNsdXNpb25cbiAqIGZvciBzdHJpbmdzIHRoYXQgcmVhY2ggYSBjZXJ0YWluIGxlbmd0aCB0aHJlc2hvbGQuIFRoaXMgY29uc3RhbnQgZGVmaW5lcyB0aGUgbGVuZ3RoIHRocmVzaG9sZCBmb3JcbiAqIHN0cmluZ3MuXG4gKi9cbmNvbnN0IFBPT0xfSU5DTFVTSU9OX0xFTkdUSF9USFJFU0hPTERfRk9SX1NUUklOR1MgPSA1MDtcbi8qKlxuICogQSBub2RlIHRoYXQgaXMgYSBwbGFjZS1ob2xkZXIgdGhhdCBhbGxvd3MgdGhlIG5vZGUgdG8gYmUgcmVwbGFjZWQgd2hlbiB0aGUgYWN0dWFsXG4gKiBub2RlIGlzIGtub3duLlxuICpcbiAqIFRoaXMgYWxsb3dzIHRoZSBjb25zdGFudCBwb29sIHRvIGNoYW5nZSBhbiBleHByZXNzaW9uIGZyb20gYSBkaXJlY3QgcmVmZXJlbmNlIHRvXG4gKiBhIGNvbnN0YW50IHRvIGEgc2hhcmVkIGNvbnN0YW50LiBJdCByZXR1cm5zIGEgZml4LXVwIG5vZGUgdGhhdCBpcyBsYXRlciBhbGxvd2VkIHRvXG4gKiBjaGFuZ2UgdGhlIHJlZmVyZW5jZWQgZXhwcmVzc2lvbi5cbiAqL1xuY2xhc3MgRml4dXBFeHByZXNzaW9uIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gICAgY29uc3RydWN0b3IocmVzb2x2ZWQpIHtcbiAgICAgICAgc3VwZXIocmVzb2x2ZWQudHlwZSk7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSByZXNvbHZlZDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IHJlc29sdmVkO1xuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICBpZiAoY29udGV4dCA9PT0gS0VZX0NPTlRFWFQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcHJvZHVjaW5nIGEga2V5IHdlIHdhbnQgdG8gdHJhdmVyc2UgdGhlIGNvbnN0YW50IG5vdCB0aGVcbiAgICAgICAgICAgIC8vIHZhcmlhYmxlIHVzZWQgdG8gcmVmZXIgdG8gaXQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZC52aXNpdEV4cHJlc3Npb24odmlzaXRvciwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNFcXVpdmFsZW50KGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24gJiYgdGhpcy5yZXNvbHZlZC5pc0VxdWl2YWxlbnQoZS5yZXNvbHZlZCk7XG4gICAgfVxuICAgIGlzQ29uc3RhbnQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmaXh1cChleHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBleHByZXNzaW9uO1xuICAgICAgICB0aGlzLnNoYXJlZCA9IHRydWU7XG4gICAgfVxufVxuLyoqXG4gKiBBIGNvbnN0YW50IHBvb2wgYWxsb3dzIGEgY29kZSBlbWl0dGVyIHRvIHNoYXJlIGNvbnN0YW50IGluIGFuIG91dHB1dCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb25zdGFudCBwb29sIGFsc28gc3VwcG9ydHMgc2hhcmluZyBhY2Nlc3MgdG8gaXZ5IGRlZmluaXRpb25zIHJlZmVyZW5jZXMuXG4gKi9cbmNsYXNzIENvbnN0YW50UG9vbCB7XG4gICAgY29uc3RydWN0b3IoaXNDbG9zdXJlQ29tcGlsZXJFbmFibGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3N1cmVDb21waWxlckVuYWJsZWQgPSBpc0Nsb3N1cmVDb21waWxlckVuYWJsZWQ7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmxpdGVyYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpdGVyYWxGYWN0b3JpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubmV4dE5hbWVJbmRleCA9IDA7XG4gICAgfVxuICAgIGdldENvbnN0TGl0ZXJhbChsaXRlcmFsLCBmb3JjZVNoYXJlZCkge1xuICAgICAgICBpZiAoKGxpdGVyYWwgaW5zdGFuY2VvZiBMaXRlcmFsRXhwciAmJiAhaXNMb25nU3RyaW5nTGl0ZXJhbChsaXRlcmFsKSkgfHxcbiAgICAgICAgICAgIGxpdGVyYWwgaW5zdGFuY2VvZiBGaXh1cEV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIC8vIERvIG5vIHB1dCBzaW1wbGUgbGl0ZXJhbHMgaW50byB0aGUgY29uc3RhbnQgcG9vbCBvciB0cnkgdG8gcHJvZHVjZSBhIGNvbnN0YW50IGZvciBhXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgdG8gYSBjb25zdGFudC5cbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2YobGl0ZXJhbCk7XG4gICAgICAgIGxldCBmaXh1cCA9IHRoaXMubGl0ZXJhbHMuZ2V0KGtleSk7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIWZpeHVwKSB7XG4gICAgICAgICAgICBmaXh1cCA9IG5ldyBGaXh1cEV4cHJlc3Npb24obGl0ZXJhbCk7XG4gICAgICAgICAgICB0aGlzLmxpdGVyYWxzLnNldChrZXksIGZpeHVwKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFuZXdWYWx1ZSAmJiAhZml4dXAuc2hhcmVkKSB8fCAobmV3VmFsdWUgJiYgZm9yY2VTaGFyZWQpKSB7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBleHByZXNzaW9uIHdpdGggYSB2YXJpYWJsZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZnJlc2hOYW1lKCk7XG4gICAgICAgICAgICBsZXQgZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGxldCB1c2FnZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc3VyZUNvbXBpbGVyRW5hYmxlZCAmJiBpc0xvbmdTdHJpbmdMaXRlcmFsKGxpdGVyYWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0cmluZyBsaXRlcmFscywgQ2xvc3VyZSB3aWxsICoqYWx3YXlzKiogaW5saW5lIHRoZSBzdHJpbmcgYXRcbiAgICAgICAgICAgICAgICAvLyAqKmFsbCoqIHVzYWdlcywgZHVwbGljYXRpbmcgaXQgZWFjaCB0aW1lLiBGb3IgbGFyZ2Ugc3RyaW5ncywgdGhpc1xuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJpbHkgYmxvYXRzIGJ1bmRsZSBzaXplLiBUbyB3b3JrIGFyb3VuZCB0aGlzIHJlc3RyaWN0aW9uLCB3ZVxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlIHN0cmluZyBpbiBhIGZ1bmN0aW9uLCBhbmQgY2FsbCB0aGF0IGZ1bmN0aW9uIGZvciBlYWNoIHVzYWdlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJpY2tzIENsb3N1cmUgaW50byB1c2luZyBpbmxpbmUgbG9naWMgZm9yIGZ1bmN0aW9ucyBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWxzLiBGdW5jdGlvbiBjYWxscyBhcmUgb25seSBpbmxpbmVkIGlmIHRoZSBib2R5IGlzIHNtYWxsXG4gICAgICAgICAgICAgICAgLy8gZW5vdWdoIHRvIGJlIHdvcnRoIGl0LiBCeSBkb2luZyB0aGlzLCB2ZXJ5IGxhcmdlIHN0cmluZ3Mgd2lsbCBiZVxuICAgICAgICAgICAgICAgIC8vIHNoYXJlZCBhY3Jvc3MgbXVsdGlwbGUgdXNhZ2VzLCByYXRoZXIgdGhhbiBkdXBsaWNhdGluZyB0aGUgc3RyaW5nIGF0XG4gICAgICAgICAgICAgICAgLy8gZWFjaCB1c2FnZSBzaXRlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgbXlTdHIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwidmVyeSB2ZXJ5IHZlcnkgbG9uZyBzdHJpbmdcIjsgfTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCB1c2FnZTEgPSBteVN0cigpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHVzYWdlMiA9IG15U3RyKCk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHZhcmlhYmxlKG5hbWUpLnNldChuZXcgRnVuY3Rpb25FeHByKFtdLCAvLyBQYXJhbXMuXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0ZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBuZXcgUmV0dXJuU3RhdGVtZW50KGxpdGVyYWwpLFxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICB1c2FnZSA9IHZhcmlhYmxlKG5hbWUpLmNhbGxGbihbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBKdXN0IGRlY2xhcmUgYW5kIHVzZSB0aGUgdmFyaWFibGUgZGlyZWN0bHksIHdpdGhvdXQgYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgLy8gaW5kaXJlY3Rpb24uIFRoaXMgc2F2ZXMgYSBmZXcgYnl0ZXMgYW5kIGF2b2lkcyBhbiB1bm5lY2Vzc2FyeSBjYWxsLlxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB2YXJpYWJsZShuYW1lKS5zZXQobGl0ZXJhbCk7XG4gICAgICAgICAgICAgICAgdXNhZ2UgPSB2YXJpYWJsZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGVtZW50cy5wdXNoKGRlZmluaXRpb24udG9EZWNsU3RtdChJTkZFUlJFRF9UWVBFLCBTdG10TW9kaWZpZXIuRmluYWwpKTtcbiAgICAgICAgICAgIGZpeHVwLmZpeHVwKHVzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZml4dXA7XG4gICAgfVxuICAgIGdldExpdGVyYWxGYWN0b3J5KGxpdGVyYWwpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcHVyZSBmdW5jdGlvbiB0aGF0IGJ1aWxkcyBhbiBhcnJheSBvZiBhIG1peCBvZiBjb25zdGFudCBhbmQgdmFyaWFibGUgZXhwcmVzc2lvbnNcbiAgICAgICAgaWYgKGxpdGVyYWwgaW5zdGFuY2VvZiBMaXRlcmFsQXJyYXlFeHByKSB7XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNGb3JLZXkgPSBsaXRlcmFsLmVudHJpZXMubWFwKGUgPT4gZS5pc0NvbnN0YW50KCkgPyBlIDogVU5LTk9XTl9WQUxVRV9LRVkpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlPZihsaXRlcmFsQXJyKGFyZ3VtZW50c0ZvcktleSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldExpdGVyYWxGYWN0b3J5KGtleSwgbGl0ZXJhbC5lbnRyaWVzLCBlbnRyaWVzID0+IGxpdGVyYWxBcnIoZW50cmllcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhwcmVzc2lvbkZvcktleSA9IGxpdGVyYWxNYXAobGl0ZXJhbC5lbnRyaWVzLm1hcChlID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBlLmtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZS52YWx1ZS5pc0NvbnN0YW50KCkgPyBlLnZhbHVlIDogVU5LTk9XTl9WQUxVRV9LRVksXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBlLnF1b3RlZFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMua2V5T2YoZXhwcmVzc2lvbkZvcktleSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGl0ZXJhbEZhY3Rvcnkoa2V5LCBsaXRlcmFsLmVudHJpZXMubWFwKGUgPT4gZS52YWx1ZSksIGVudHJpZXMgPT4gbGl0ZXJhbE1hcChlbnRyaWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleTogbGl0ZXJhbC5lbnRyaWVzW2luZGV4XS5rZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgcXVvdGVkOiBsaXRlcmFsLmVudHJpZXNbaW5kZXhdLnF1b3RlZFxuICAgICAgICAgICAgfSkpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldExpdGVyYWxGYWN0b3J5KGtleSwgdmFsdWVzLCByZXN1bHRNYXApIHtcbiAgICAgICAgbGV0IGxpdGVyYWxGYWN0b3J5ID0gdGhpcy5saXRlcmFsRmFjdG9yaWVzLmdldChrZXkpO1xuICAgICAgICBjb25zdCBsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyA9IHZhbHVlcy5maWx0ZXIoKGUgPT4gIWUuaXNDb25zdGFudCgpKSk7XG4gICAgICAgIGlmICghbGl0ZXJhbEZhY3RvcnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdEV4cHJlc3Npb25zID0gdmFsdWVzLm1hcCgoZSwgaW5kZXgpID0+IGUuaXNDb25zdGFudCgpID8gdGhpcy5nZXRDb25zdExpdGVyYWwoZSwgdHJ1ZSkgOiB2YXJpYWJsZShgYSR7aW5kZXh9YCkpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJlc3VsdEV4cHJlc3Npb25zLmZpbHRlcihpc1ZhcmlhYmxlKS5tYXAoZSA9PiBuZXcgRm5QYXJhbShlLm5hbWUsIERZTkFNSUNfVFlQRSkpO1xuICAgICAgICAgICAgY29uc3QgcHVyZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSBmbihwYXJhbWV0ZXJzLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXN1bHRNYXAocmVzdWx0RXhwcmVzc2lvbnMpKV0sIElORkVSUkVEX1RZUEUpO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuZnJlc2hOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlbWVudHMucHVzaCh2YXJpYWJsZShuYW1lKVxuICAgICAgICAgICAgICAgIC5zZXQocHVyZUZ1bmN0aW9uRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgLnRvRGVjbFN0bXQoSU5GRVJSRURfVFlQRSwgU3RtdE1vZGlmaWVyLkZpbmFsKSk7XG4gICAgICAgICAgICBsaXRlcmFsRmFjdG9yeSA9IHZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5saXRlcmFsRmFjdG9yaWVzLnNldChrZXksIGxpdGVyYWxGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsaXRlcmFsRmFjdG9yeSwgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZSBhIHVuaXF1ZSBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIG5hbWUgbWlnaHQgYmUgdW5pcXVlIGFtb25nIGRpZmZlcmVudCBwcmVmaXhlcyBpZiBhbnkgb2YgdGhlIHByZWZpeGVzIGVuZCBpblxuICAgICAqIGEgZGlnaXQgc28gdGhlIHByZWZpeCBzaG91bGQgYmUgYSBjb25zdGFudCBzdHJpbmcgKG5vdCBiYXNlZCBvbiB1c2VyIGlucHV0KSBhbmRcbiAgICAgKiBtdXN0IG5vdCBlbmQgaW4gYSBkaWdpdC5cbiAgICAgKi9cbiAgICB1bmlxdWVOYW1lKHByZWZpeCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fSR7dGhpcy5uZXh0TmFtZUluZGV4Kyt9YDtcbiAgICB9XG4gICAgZnJlc2hOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlxdWVOYW1lKENPTlNUQU5UX1BSRUZJWCk7XG4gICAgfVxuICAgIGtleU9mKGV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24udmlzaXRFeHByZXNzaW9uKG5ldyBLZXlWaXNpdG9yKCksIEtFWV9DT05URVhUKTtcbiAgICB9XG59XG4vKipcbiAqIFZpc2l0b3IgdXNlZCB0byBkZXRlcm1pbmUgaWYgMiBleHByZXNzaW9ucyBhcmUgZXF1aXZhbGVudCBhbmQgY2FuIGJlIHNoYXJlZCBpbiB0aGVcbiAqIGBDb25zdGFudFBvb2xgLlxuICpcbiAqIFdoZW4gdGhlIGlkIChzdHJpbmcpIGdlbmVyYXRlZCBieSB0aGUgdmlzaXRvciBpcyBlcXVhbCwgZXhwcmVzc2lvbnMgYXJlIGNvbnNpZGVyZWQgZXF1aXZhbGVudC5cbiAqL1xuY2xhc3MgS2V5VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlzaXRXcmFwcGVkTm9kZUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRXcml0ZVZhckV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRXcml0ZUtleUV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRXcml0ZVByb3BFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0SW52b2tlRnVuY3Rpb25FeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0VGFnZ2VkVGVtcGxhdGVFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0SW5zdGFudGlhdGVFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Q29uZGl0aW9uYWxFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Tm90RXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdEFzc2VydE5vdE51bGxFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Q2FzdEV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRGdW5jdGlvbkV4cHIgPSBpbnZhbGlkJDE7XG4gICAgICAgIHRoaXMudmlzaXRVbmFyeU9wZXJhdG9yRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdEJpbmFyeU9wZXJhdG9yRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFJlYWRQcm9wRXhwciA9IGludmFsaWQkMTtcbiAgICAgICAgdGhpcy52aXNpdFJlYWRLZXlFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0Q29tbWFFeHByID0gaW52YWxpZCQxO1xuICAgICAgICB0aGlzLnZpc2l0TG9jYWxpemVkU3RyaW5nID0gaW52YWxpZCQxO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxFeHByKGFzdCkge1xuICAgICAgICByZXR1cm4gYCR7dHlwZW9mIGFzdC52YWx1ZSA9PT0gJ3N0cmluZycgPyAnXCInICsgYXN0LnZhbHVlICsgJ1wiJyA6IGFzdC52YWx1ZX1gO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheUV4cHIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBgWyR7YXN0LmVudHJpZXMubWFwKGVudHJ5ID0+IGVudHJ5LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjb250ZXh0KSkuam9pbignLCcpfV1gO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXBFeHByKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBtYXBLZXkgPSAoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlID0gZW50cnkucXVvdGVkID8gJ1wiJyA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGAke3F1b3RlfSR7ZW50cnkua2V5fSR7cXVvdGV9YDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWFwRW50cnkgPSAoZW50cnkpID0+IGAke21hcEtleShlbnRyeSl9OiR7ZW50cnkudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpfWA7XG4gICAgICAgIHJldHVybiBgeyR7YXN0LmVudHJpZXMubWFwKG1hcEVudHJ5KS5qb2luKCcsJyl9YDtcbiAgICB9XG4gICAgdmlzaXRFeHRlcm5hbEV4cHIoYXN0KSB7XG4gICAgICAgIHJldHVybiBhc3QudmFsdWUubW9kdWxlTmFtZSA/IGBFWDoke2FzdC52YWx1ZS5tb2R1bGVOYW1lfToke2FzdC52YWx1ZS5uYW1lfWAgOlxuICAgICAgICAgICAgYEVYOiR7YXN0LnZhbHVlLnJ1bnRpbWUubmFtZX1gO1xuICAgIH1cbiAgICB2aXNpdFJlYWRWYXJFeHByKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGBWQVI6JHtub2RlLm5hbWV9YDtcbiAgICB9XG4gICAgdmlzaXRUeXBlb2ZFeHByKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGBUWVBFT0Y6JHtub2RlLmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGNvbnRleHQpfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52YWxpZCQxKGFyZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogVmlzaXRvciAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gZG9lc24ndCBoYW5kbGUgJHthcmcuY29uc3RydWN0b3IubmFtZX1gKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGUoZSkge1xuICAgIHJldHVybiBlIGluc3RhbmNlb2YgUmVhZFZhckV4cHI7XG59XG5mdW5jdGlvbiBpc0xvbmdTdHJpbmdMaXRlcmFsKGV4cHIpIHtcbiAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIExpdGVyYWxFeHByICYmIHR5cGVvZiBleHByLnZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBleHByLnZhbHVlLmxlbmd0aCA+PSBQT09MX0lOQ0xVU0lPTl9MRU5HVEhfVEhSRVNIT0xEX0ZPUl9TVFJJTkdTO1xufVxuXG5jb25zdCBDT1JFID0gJ0Bhbmd1bGFyL2NvcmUnO1xuY2xhc3MgSWRlbnRpZmllcnMge1xufVxuLyogTWV0aG9kcyAqL1xuSWRlbnRpZmllcnMuTkVXX01FVEhPRCA9ICdmYWN0b3J5JztcbklkZW50aWZpZXJzLlRSQU5TRk9STV9NRVRIT0QgPSAndHJhbnNmb3JtJztcbklkZW50aWZpZXJzLlBBVENIX0RFUFMgPSAncGF0Y2hlZERlcHMnO1xuSWRlbnRpZmllcnMuY29yZSA9IHsgbmFtZTogbnVsbCwgbW9kdWxlTmFtZTogQ09SRSB9O1xuLyogSW5zdHJ1Y3Rpb25zICovXG5JZGVudGlmaWVycy5uYW1lc3BhY2VIVE1MID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZUhUTUwnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5uYW1lc3BhY2VNYXRoTUwgPSB7IG5hbWU6ICfJtcm1bmFtZXNwYWNlTWF0aE1MJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMubmFtZXNwYWNlU1ZHID0geyBuYW1lOiAnybXJtW5hbWVzcGFjZVNWRycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmVsZW1lbnQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmVsZW1lbnRTdGFydCA9IHsgbmFtZTogJ8m1ybVlbGVtZW50U3RhcnQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbGVtZW50RW5kID0geyBuYW1lOiAnybXJtWVsZW1lbnRFbmQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hZHZhbmNlID0geyBuYW1lOiAnybXJtWFkdmFuY2UnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zeW50aGV0aWNIb3N0UHJvcGVydHkgPSB7IG5hbWU6ICfJtcm1c3ludGhldGljSG9zdFByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3ludGhldGljSG9zdExpc3RlbmVyID0geyBuYW1lOiAnybXJtXN5bnRoZXRpY0hvc3RMaXN0ZW5lcicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZSA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGUxJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMyA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNiA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1YXR0cmlidXRlSW50ZXJwb2xhdGU3JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtWF0dHJpYnV0ZUludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlViA9IHsgbmFtZTogJ8m1ybVhdHRyaWJ1dGVJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc1Byb3AgPSB7IG5hbWU6ICfJtcm1Y2xhc3NQcm9wJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lclN0YXJ0ID0geyBuYW1lOiAnybXJtWVsZW1lbnRDb250YWluZXJTdGFydCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJFbmQgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lckVuZCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXIgPSB7IG5hbWU6ICfJtcm1ZWxlbWVudENvbnRhaW5lcicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwID0geyBuYW1lOiAnybXJtXN0eWxlTWFwJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1c3R5bGVNYXBJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVzdHlsZU1hcEludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXN0eWxlTWFwSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXAgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXAnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMSA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGUyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNCA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU1JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNyA9IHsgbmFtZTogJ8m1ybVjbGFzc01hcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtWNsYXNzTWFwSW50ZXJwb2xhdGU4JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1Y2xhc3NNYXBJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3AgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlMScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTMgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXN0eWxlUHJvcEludGVycG9sYXRlNycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVzdHlsZVByb3BJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZVYgPSB7IG5hbWU6ICfJtcm1c3R5bGVQcm9wSW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMubmV4dENvbnRleHQgPSB7IG5hbWU6ICfJtcm1bmV4dENvbnRleHQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5yZXNldFZpZXcgPSB7IG5hbWU6ICfJtcm1cmVzZXRWaWV3JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMudGVtcGxhdGVDcmVhdGUgPSB7IG5hbWU6ICfJtcm1dGVtcGxhdGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0ID0geyBuYW1lOiAnybXJtXRleHQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5lbmFibGVCaW5kaW5ncyA9IHsgbmFtZTogJ8m1ybVlbmFibGVCaW5kaW5ncycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRpc2FibGVCaW5kaW5ncyA9IHsgbmFtZTogJ8m1ybVkaXNhYmxlQmluZGluZ3MnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5nZXRDdXJyZW50VmlldyA9IHsgbmFtZTogJ8m1ybVnZXRDdXJyZW50VmlldycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1ybV0ZXh0SW50ZXJwb2xhdGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUxID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUyID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTInLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU0ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU1ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU3ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU4ID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZTgnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXRleHRJbnRlcnBvbGF0ZVYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5yZXN0b3JlVmlldyA9IHsgbmFtZTogJ8m1ybVyZXN0b3JlVmlldycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjAgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uMCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjEgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uMScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjIgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjMgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uMycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjQgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjUgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjYgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjcgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uNycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvbjggPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uOCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnB1cmVGdW5jdGlvblYgPSB7IG5hbWU6ICfJtcm1cHVyZUZ1bmN0aW9uVicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnBpcGVCaW5kMSA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5waXBlQmluZDIgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmQyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucGlwZUJpbmQzID0geyBuYW1lOiAnybXJtXBpcGVCaW5kMycsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnBpcGVCaW5kNCA9IHsgbmFtZTogJ8m1ybVwaXBlQmluZDQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5waXBlQmluZFYgPSB7IG5hbWU6ICfJtcm1cGlwZUJpbmRWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaG9zdFByb3BlcnR5ID0geyBuYW1lOiAnybXJtWhvc3RQcm9wZXJ0eScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5ID0geyBuYW1lOiAnybXJtXByb3BlcnR5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTEgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMiA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlMicsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUzID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGUzJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTQgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNSA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlNScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU2ID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGU2JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTcgPSB7IG5hbWU6ICfJtcm1cHJvcGVydHlJbnRlcnBvbGF0ZTcnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlOCA9IHsgbmFtZTogJ8m1ybVwcm9wZXJ0eUludGVycG9sYXRlOCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGVWID0geyBuYW1lOiAnybXJtXByb3BlcnR5SW50ZXJwb2xhdGVWJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4biA9IHsgbmFtZTogJ8m1ybVpMThuJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4bkF0dHJpYnV0ZXMgPSB7IG5hbWU6ICfJtcm1aTE4bkF0dHJpYnV0ZXMnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5pMThuRXhwID0geyBuYW1lOiAnybXJtWkxOG5FeHAnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5pMThuU3RhcnQgPSB7IG5hbWU6ICfJtcm1aTE4blN0YXJ0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4bkVuZCA9IHsgbmFtZTogJ8m1ybVpMThuRW5kJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaTE4bkFwcGx5ID0geyBuYW1lOiAnybXJtWkxOG5BcHBseScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmkxOG5Qb3N0cHJvY2VzcyA9IHsgbmFtZTogJ8m1ybVpMThuUG9zdHByb2Nlc3MnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5waXBlID0geyBuYW1lOiAnybXJtXBpcGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9qZWN0aW9uID0geyBuYW1lOiAnybXJtXByb2plY3Rpb24nLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5wcm9qZWN0aW9uRGVmID0geyBuYW1lOiAnybXJtXByb2plY3Rpb25EZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5yZWZlcmVuY2UgPSB7IG5hbWU6ICfJtcm1cmVmZXJlbmNlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaW5qZWN0ID0geyBuYW1lOiAnybXJtWluamVjdCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmluamVjdEF0dHJpYnV0ZSA9IHsgbmFtZTogJ8m1ybVpbmplY3RBdHRyaWJ1dGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kaXJlY3RpdmVJbmplY3QgPSB7IG5hbWU6ICfJtcm1ZGlyZWN0aXZlSW5qZWN0JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuaW52YWxpZEZhY3RvcnkgPSB7IG5hbWU6ICfJtcm1aW52YWxpZEZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5pbnZhbGlkRmFjdG9yeURlcCA9IHsgbmFtZTogJ8m1ybVpbnZhbGlkRmFjdG9yeURlcCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnRlbXBsYXRlUmVmRXh0cmFjdG9yID0geyBuYW1lOiAnybXJtXRlbXBsYXRlUmVmRXh0cmFjdG9yJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZm9yd2FyZFJlZiA9IHsgbmFtZTogJ2ZvcndhcmRSZWYnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5yZXNvbHZlRm9yd2FyZFJlZiA9IHsgbmFtZTogJ3Jlc29sdmVGb3J3YXJkUmVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuybXJtWRlZmluZUluamVjdGFibGUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lSW5qZWN0YWJsZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVJbmplY3RhYmxlID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUluamVjdGFibGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5JbmplY3RhYmxlRGVjbGFyYXRpb24gPSB7IG5hbWU6ICfJtcm1SW5qZWN0YWJsZURlY2xhcmF0aW9uJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVzb2x2ZVdpbmRvdyA9IHsgbmFtZTogJ8m1ybVyZXNvbHZlV2luZG93JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVzb2x2ZURvY3VtZW50ID0geyBuYW1lOiAnybXJtXJlc29sdmVEb2N1bWVudCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnJlc29sdmVCb2R5ID0geyBuYW1lOiAnybXJtXJlc29sdmVCb2R5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVmaW5lQ29tcG9uZW50ID0geyBuYW1lOiAnybXJtWRlZmluZUNvbXBvbmVudCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVDb21wb25lbnQgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlQ29tcG9uZW50JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2V0Q29tcG9uZW50U2NvcGUgPSB7IG5hbWU6ICfJtcm1c2V0Q29tcG9uZW50U2NvcGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSA9IHtcbiAgICBuYW1lOiAnQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3knLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuVmlld0VuY2Fwc3VsYXRpb24gPSB7XG4gICAgbmFtZTogJ1ZpZXdFbmNhcHN1bGF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLkNvbXBvbmVudERlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6ICfJtcm1Q29tcG9uZW50RGVjbGFyYXRpb24nLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuSWRlbnRpZmllcnMuRmFjdG9yeURlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6ICfJtcm1RmFjdG9yeURlY2xhcmF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLmRlY2xhcmVGYWN0b3J5ID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUZhY3RvcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5GYWN0b3J5VGFyZ2V0ID0geyBuYW1lOiAnybXJtUZhY3RvcnlUYXJnZXQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kZWZpbmVEaXJlY3RpdmUgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lRGlyZWN0aXZlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVjbGFyZURpcmVjdGl2ZSA9IHsgbmFtZTogJ8m1ybVuZ0RlY2xhcmVEaXJlY3RpdmUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5EaXJlY3RpdmVEZWNsYXJhdGlvbiA9IHtcbiAgICBuYW1lOiAnybXJtURpcmVjdGl2ZURlY2xhcmF0aW9uJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLkluamVjdG9yRGVmID0geyBuYW1lOiAnybXJtUluamVjdG9yRGVmJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuSW5qZWN0b3JEZWNsYXJhdGlvbiA9IHsgbmFtZTogJ8m1ybVJbmplY3RvckRlY2xhcmF0aW9uJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVmaW5lSW5qZWN0b3IgPSB7IG5hbWU6ICfJtcm1ZGVmaW5lSW5qZWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5kZWNsYXJlSW5qZWN0b3IgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlSW5qZWN0b3InLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5OZ01vZHVsZURlY2xhcmF0aW9uID0ge1xuICAgIG5hbWU6ICfJtcm1TmdNb2R1bGVEZWNsYXJhdGlvbicsXG4gICAgbW9kdWxlTmFtZTogQ09SRSxcbn07XG5JZGVudGlmaWVycy5Nb2R1bGVXaXRoUHJvdmlkZXJzID0ge1xuICAgIG5hbWU6ICdNb2R1bGVXaXRoUHJvdmlkZXJzJyxcbiAgICBtb2R1bGVOYW1lOiBDT1JFLFxufTtcbklkZW50aWZpZXJzLmRlZmluZU5nTW9kdWxlID0geyBuYW1lOiAnybXJtWRlZmluZU5nTW9kdWxlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVjbGFyZU5nTW9kdWxlID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZU5nTW9kdWxlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2V0TmdNb2R1bGVTY29wZSA9IHsgbmFtZTogJ8m1ybVzZXROZ01vZHVsZVNjb3BlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucmVnaXN0ZXJOZ01vZHVsZVR5cGUgPSB7IG5hbWU6ICfJtcm1cmVnaXN0ZXJOZ01vZHVsZVR5cGUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5QaXBlRGVjbGFyYXRpb24gPSB7IG5hbWU6ICfJtcm1UGlwZURlY2xhcmF0aW9uJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVmaW5lUGlwZSA9IHsgbmFtZTogJ8m1ybVkZWZpbmVQaXBlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZGVjbGFyZVBpcGUgPSB7IG5hbWU6ICfJtcm1bmdEZWNsYXJlUGlwZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmRlY2xhcmVDbGFzc01ldGFkYXRhID0geyBuYW1lOiAnybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zZXRDbGFzc01ldGFkYXRhID0geyBuYW1lOiAnybVzZXRDbGFzc01ldGFkYXRhJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMucXVlcnlSZWZyZXNoID0geyBuYW1lOiAnybXJtXF1ZXJ5UmVmcmVzaCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnZpZXdRdWVyeSA9IHsgbmFtZTogJ8m1ybV2aWV3UXVlcnknLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5sb2FkUXVlcnkgPSB7IG5hbWU6ICfJtcm1bG9hZFF1ZXJ5JywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuY29udGVudFF1ZXJ5ID0geyBuYW1lOiAnybXJtWNvbnRlbnRRdWVyeScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLk5nT25DaGFuZ2VzRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVOZ09uQ2hhbmdlc0ZlYXR1cmUnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5Jbmhlcml0RGVmaW5pdGlvbkZlYXR1cmUgPSB7IG5hbWU6ICfJtcm1SW5oZXJpdERlZmluaXRpb25GZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuQ29weURlZmluaXRpb25GZWF0dXJlID0geyBuYW1lOiAnybXJtUNvcHlEZWZpbml0aW9uRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLlN0YW5kYWxvbmVGZWF0dXJlID0geyBuYW1lOiAnybXJtVN0YW5kYWxvbmVGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuUHJvdmlkZXJzRmVhdHVyZSA9IHsgbmFtZTogJ8m1ybVQcm92aWRlcnNGZWF0dXJlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuSG9zdERpcmVjdGl2ZXNGZWF0dXJlID0geyBuYW1lOiAnybXJtUhvc3REaXJlY3RpdmVzRmVhdHVyZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLmxpc3RlbmVyID0geyBuYW1lOiAnybXJtWxpc3RlbmVyJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuZ2V0SW5oZXJpdGVkRmFjdG9yeSA9IHtcbiAgICBuYW1lOiAnybXJtWdldEluaGVyaXRlZEZhY3RvcnknLFxuICAgIG1vZHVsZU5hbWU6IENPUkUsXG59O1xuLy8gc2FuaXRpemF0aW9uLXJlbGF0ZWQgZnVuY3Rpb25zXG5JZGVudGlmaWVycy5zYW5pdGl6ZUh0bWwgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVIdG1sJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVTdHlsZSA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVN0eWxlJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVJlc291cmNlVXJsJywgbW9kdWxlTmFtZTogQ09SRSB9O1xuSWRlbnRpZmllcnMuc2FuaXRpemVTY3JpcHQgPSB7IG5hbWU6ICfJtcm1c2FuaXRpemVTY3JpcHQnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy5zYW5pdGl6ZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVVybCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnNhbml0aXplVXJsT3JSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybVzYW5pdGl6ZVVybE9yUmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy50cnVzdENvbnN0YW50SHRtbCA9IHsgbmFtZTogJ8m1ybV0cnVzdENvbnN0YW50SHRtbCcsIG1vZHVsZU5hbWU6IENPUkUgfTtcbklkZW50aWZpZXJzLnRydXN0Q29uc3RhbnRSZXNvdXJjZVVybCA9IHsgbmFtZTogJ8m1ybV0cnVzdENvbnN0YW50UmVzb3VyY2VVcmwnLCBtb2R1bGVOYW1lOiBDT1JFIH07XG5JZGVudGlmaWVycy52YWxpZGF0ZUlmcmFtZUF0dHJpYnV0ZSA9IHsgbmFtZTogJ8m1ybV2YWxpZGF0ZUlmcmFtZUF0dHJpYnV0ZScsIG1vZHVsZU5hbWU6IENPUkUgfTtcblxuY29uc3QgREFTSF9DQVNFX1JFR0VYUCA9IC8tKyhbYS16MC05XSkvZztcbmZ1bmN0aW9uIGRhc2hDYXNlVG9DYW1lbENhc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZShEQVNIX0NBU0VfUkVHRVhQLCAoLi4ubSkgPT4gbVsxXS50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QXRDb2xvbihpbnB1dCwgZGVmYXVsdFZhbHVlcykge1xuICAgIHJldHVybiBfc3BsaXRBdChpbnB1dCwgJzonLCBkZWZhdWx0VmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHNwbGl0QXRQZXJpb2QoaW5wdXQsIGRlZmF1bHRWYWx1ZXMpIHtcbiAgICByZXR1cm4gX3NwbGl0QXQoaW5wdXQsICcuJywgZGVmYXVsdFZhbHVlcyk7XG59XG5mdW5jdGlvbiBfc3BsaXRBdChpbnB1dCwgY2hhcmFjdGVyLCBkZWZhdWx0VmFsdWVzKSB7XG4gICAgY29uc3QgY2hhcmFjdGVySW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXJhY3Rlcik7XG4gICAgaWYgKGNoYXJhY3RlckluZGV4ID09IC0xKVxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlcztcbiAgICByZXR1cm4gW2lucHV0LnNsaWNlKDAsIGNoYXJhY3RlckluZGV4KS50cmltKCksIGlucHV0LnNsaWNlKGNoYXJhY3RlckluZGV4ICsgMSkudHJpbSgpXTtcbn1cbmZ1bmN0aW9uIG5vVW5kZWZpbmVkKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2YWw7XG59XG5mdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiAke21zZ31gKTtcbn1cbi8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhIHNwZWNpYWwgbWVhbmluZyBpbiBSZWd1bGFyIEV4cHJlc3Npb25zXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbn1cbmZ1bmN0aW9uIHV0ZjhFbmNvZGUoc3RyKSB7XG4gICAgbGV0IGVuY29kZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBsZXQgY29kZVBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBkZWNvZGUgc3Vycm9nYXRlXG4gICAgICAgIC8vIHNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweGQ4MDAgJiYgY29kZVBvaW50IDw9IDB4ZGJmZiAmJiBzdHIubGVuZ3RoID4gKGluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpZiAobG93ID49IDB4ZGMwMCAmJiBsb3cgPD0gMHhkZmZmKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSAoKGNvZGVQb2ludCAtIDB4ZDgwMCkgPDwgMTApICsgbG93IC0gMHhkYzAwICsgMHgxMDAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4N2YpIHtcbiAgICAgICAgICAgIGVuY29kZWQucHVzaChjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGVQb2ludCA8PSAweDdmZikge1xuICAgICAgICAgICAgZW5jb2RlZC5wdXNoKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweGMwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkLnB1c2goKGNvZGVQb2ludCA+PiAxMikgfCAweGUwLCAoKGNvZGVQb2ludCA+PiA2KSAmIDB4M2YpIHwgMHg4MCwgKGNvZGVQb2ludCAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50IDw9IDB4MWZmZmZmKSB7XG4gICAgICAgICAgICBlbmNvZGVkLnB1c2goKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweGYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNmKSB8IDB4ODAsICgoY29kZVBvaW50ID4+IDYpICYgMHgzZikgfCAweDgwLCAoY29kZVBvaW50ICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0b2tlbi5tYXAoc3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgICBpZiAodG9rZW4gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJycgKyB0b2tlbjtcbiAgICB9XG4gICAgaWYgKHRva2VuLm92ZXJyaWRkZW5OYW1lKSB7XG4gICAgICAgIHJldHVybiBgJHt0b2tlbi5vdmVycmlkZGVuTmFtZX1gO1xuICAgIH1cbiAgICBpZiAodG9rZW4ubmFtZSkge1xuICAgICAgICByZXR1cm4gYCR7dG9rZW4ubmFtZX1gO1xuICAgIH1cbiAgICBpZiAoIXRva2VuLnRvU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgLy8gV0FSTklORzogZG8gbm90IHRyeSB0byBgSlNPTi5zdHJpbmdpZnkodG9rZW4pYCBoZXJlXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIzNDQwXG4gICAgY29uc3QgcmVzID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnICsgcmVzO1xuICAgIH1cbiAgICBjb25zdCBuZXdMaW5lSW5kZXggPSByZXMuaW5kZXhPZignXFxuJyk7XG4gICAgcmV0dXJuIG5ld0xpbmVJbmRleCA9PT0gLTEgPyByZXMgOiByZXMuc3Vic3RyaW5nKDAsIG5ld0xpbmVJbmRleCk7XG59XG5jbGFzcyBWZXJzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmdWxsKSB7XG4gICAgICAgIHRoaXMuZnVsbCA9IGZ1bGw7XG4gICAgICAgIGNvbnN0IHNwbGl0cyA9IGZ1bGwuc3BsaXQoJy4nKTtcbiAgICAgICAgdGhpcy5tYWpvciA9IHNwbGl0c1swXTtcbiAgICAgICAgdGhpcy5taW5vciA9IHNwbGl0c1sxXTtcbiAgICAgICAgdGhpcy5wYXRjaCA9IHNwbGl0cy5zbGljZSgyKS5qb2luKCcuJyk7XG4gICAgfVxufVxuLy8gQ2hlY2sgYGdsb2JhbGAgZmlyc3QsIGJlY2F1c2UgaW4gTm9kZSB0ZXN0cyBib3RoIGBnbG9iYWxgIGFuZCBgd2luZG93YCBtYXkgYmUgZGVmaW5lZCBhbmQgb3VyXG4vLyBgX2dsb2JhbGAgdmFyaWFibGUgc2hvdWxkIHBvaW50IHRvIHRoZSBOb2RlSlMgYGdsb2JhbGAgaW4gdGhhdCBjYXNlLiBOb3RlOiBUeXBlb2YvSW5zdGFuY2VvZlxuLy8gY2hlY2tzIGFyZSBjb25zaWRlcmVkIHNpZGUtZWZmZWN0cyBpbiBUZXJzZXIuIFdlIGV4cGxpY2l0bHkgbWFyayB0aGlzIGFzIHNpZGUtZWZmZWN0IGZyZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGVyc2VyL3RlcnNlci9pc3N1ZXMvMjUwLlxuY29uc3QgX2dsb2JhbCA9ICggLyogQF9fUFVSRV9fICovKCgpID0+ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cpIHx8XG4gICAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSAmJiBzZWxmKSkoKSk7XG5mdW5jdGlvbiBuZXdBcnJheShzaXplLCB2YWx1ZSkge1xuICAgIGNvbnN0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogUGFydGl0aW9ucyBhIGdpdmVuIGFycmF5IGludG8gMiBhcnJheXMsIGJhc2VkIG9uIGEgYm9vbGVhbiB2YWx1ZSByZXR1cm5lZCBieSB0aGUgY29uZGl0aW9uXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gYXJyIElucHV0IGFycmF5IHRoYXQgc2hvdWxkIGJlIHBhcnRpdGlvbmVkXG4gKiBAcGFyYW0gY29uZGl0aW9uRm4gQ29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvciBlYWNoIGl0ZW0gaW4gYSBnaXZlbiBhcnJheSBhbmQgcmV0dXJucyBhXG4gKiBib29sZWFuIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJ0aXRpb25BcnJheShhcnIsIGNvbmRpdGlvbkZuKSB7XG4gICAgY29uc3QgdHJ1dGh5ID0gW107XG4gICAgY29uc3QgZmFsc3kgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgIChjb25kaXRpb25GbihpdGVtKSA/IHRydXRoeSA6IGZhbHN5KS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xufVxuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXRcbmNvbnN0IFZFUlNJT04kMSA9IDM7XG5jb25zdCBKU19CNjRfUFJFRklYID0gJyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCc7XG5jbGFzcyBTb3VyY2VNYXBHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpbGUgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0Q29sMCA9IDA7XG4gICAgICAgIHRoaXMuaGFzTWFwcGluZ3MgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIGNvbnRlbnQgaXMgYG51bGxgIHdoZW4gdGhlIGNvbnRlbnQgaXMgZXhwZWN0ZWQgdG8gYmUgbG9hZGVkIHVzaW5nIHRoZSBVUkxcbiAgICBhZGRTb3VyY2UodXJsLCBjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQuc2V0KHVybCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZExpbmUoKSB7XG4gICAgICAgIHRoaXMubGluZXMucHVzaChbXSk7XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkTWFwcGluZyhjb2wwLCBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwLCBzb3VyY2VDb2wwKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50TGluZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGxpbmUgbXVzdCBiZSBhZGRlZCBiZWZvcmUgbWFwcGluZ3MgY2FuIGJlIGFkZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVVybCAhPSBudWxsICYmICF0aGlzLnNvdXJjZXNDb250ZW50Lmhhcyhzb3VyY2VVcmwpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc291cmNlIGZpbGUgXCIke3NvdXJjZVVybH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGNvbHVtbiBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUgbXVzdCBiZSBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2wwIDwgdGhpcy5sYXN0Q29sMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYXBwaW5nIHNob3VsZCBiZSBhZGRlZCBpbiBvdXRwdXQgb3JkZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlVXJsICYmIChzb3VyY2VMaW5lMCA9PSBudWxsIHx8IHNvdXJjZUNvbDAgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNvdXJjZSBsb2NhdGlvbiBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gYSBzb3VyY2UgdXJsIGlzIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNNYXBwaW5ncyA9IHRydWU7XG4gICAgICAgIHRoaXMubGFzdENvbDAgPSBjb2wwO1xuICAgICAgICB0aGlzLmN1cnJlbnRMaW5lLnB1c2goeyBjb2wwLCBzb3VyY2VVcmwsIHNvdXJjZUxpbmUwLCBzb3VyY2VDb2wwIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsIHN0cmlwIHRoaXMgZnJvbSBwdWJsaXNoZWQgZC50cyBmaWxlcyBkdWUgdG9cbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM2MjE2XG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lcy5zbGljZSgtMSlbMF07XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc01hcHBpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb3VyY2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc291cmNlc0NvbnRlbnQgPSBbXTtcbiAgICAgICAgQXJyYXkuZnJvbSh0aGlzLnNvdXJjZXNDb250ZW50LmtleXMoKSkuZm9yRWFjaCgodXJsLCBpKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2VzSW5kZXguc2V0KHVybCwgaSk7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2godXJsKTtcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LnB1c2godGhpcy5zb3VyY2VzQ29udGVudC5nZXQodXJsKSB8fCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBtYXBwaW5ncyA9ICcnO1xuICAgICAgICBsZXQgbGFzdENvbDAgPSAwO1xuICAgICAgICBsZXQgbGFzdFNvdXJjZUluZGV4ID0gMDtcbiAgICAgICAgbGV0IGxhc3RTb3VyY2VMaW5lMCA9IDA7XG4gICAgICAgIGxldCBsYXN0U291cmNlQ29sMCA9IDA7XG4gICAgICAgIHRoaXMubGluZXMuZm9yRWFjaChzZWdtZW50cyA9PiB7XG4gICAgICAgICAgICBsYXN0Q29sMCA9IDA7XG4gICAgICAgICAgICBtYXBwaW5ncyArPSBzZWdtZW50c1xuICAgICAgICAgICAgICAgIC5tYXAoc2VnbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgLy8gemVyby1iYXNlZCBzdGFydGluZyBjb2x1bW4gb2YgdGhlIGxpbmUgaW4gdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgICAgICAgICAgICAgbGV0IHNlZ0FzU3RyID0gdG9CYXNlNjRWTFEoc2VnbWVudC5jb2wwIC0gbGFzdENvbDApO1xuICAgICAgICAgICAgICAgIGxhc3RDb2wwID0gc2VnbWVudC5jb2wwO1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50LnNvdXJjZVVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHplcm8tYmFzZWQgaW5kZXggaW50byB0aGUg4oCcc291cmNlc+KAnSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0Jhc2U2NFZMUShzb3VyY2VzSW5kZXguZ2V0KHNlZ21lbnQuc291cmNlVXJsKSAtIGxhc3RTb3VyY2VJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VJbmRleCA9IHNvdXJjZXNJbmRleC5nZXQoc2VnbWVudC5zb3VyY2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgemVyby1iYXNlZCBzdGFydGluZyBsaW5lIGluIHRoZSBvcmlnaW5hbCBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgc2VnQXNTdHIgKz0gdG9CYXNlNjRWTFEoc2VnbWVudC5zb3VyY2VMaW5lMCAtIGxhc3RTb3VyY2VMaW5lMCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTb3VyY2VMaW5lMCA9IHNlZ21lbnQuc291cmNlTGluZTA7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB6ZXJvLWJhc2VkIHN0YXJ0aW5nIGNvbHVtbiBpbiB0aGUgb3JpZ2luYWwgc291cmNlXG4gICAgICAgICAgICAgICAgICAgIHNlZ0FzU3RyICs9IHRvQmFzZTY0VkxRKHNlZ21lbnQuc291cmNlQ29sMCAtIGxhc3RTb3VyY2VDb2wwKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFNvdXJjZUNvbDAgPSBzZWdtZW50LnNvdXJjZUNvbDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdBc1N0cjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywnKTtcbiAgICAgICAgICAgIG1hcHBpbmdzICs9ICc7JztcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gbWFwcGluZ3Muc2xpY2UoMCwgLTEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ2ZpbGUnOiB0aGlzLmZpbGUgfHwgJycsXG4gICAgICAgICAgICAndmVyc2lvbic6IFZFUlNJT04kMSxcbiAgICAgICAgICAgICdzb3VyY2VSb290JzogJycsXG4gICAgICAgICAgICAnc291cmNlcyc6IHNvdXJjZXMsXG4gICAgICAgICAgICAnc291cmNlc0NvbnRlbnQnOiBzb3VyY2VzQ29udGVudCxcbiAgICAgICAgICAgICdtYXBwaW5ncyc6IG1hcHBpbmdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b0pzQ29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTWFwcGluZ3MgPyAnLy8nICsgSlNfQjY0X1BSRUZJWCArIHRvQmFzZTY0U3RyaW5nKEpTT04uc3RyaW5naWZ5KHRoaXMsIG51bGwsIDApKSA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFN0cmluZyh2YWx1ZSkge1xuICAgIGxldCBiNjQgPSAnJztcbiAgICBjb25zdCBlbmNvZGVkID0gdXRmOEVuY29kZSh2YWx1ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDspIHtcbiAgICAgICAgY29uc3QgaTEgPSBlbmNvZGVkW2krK107XG4gICAgICAgIGNvbnN0IGkyID0gaSA8IGVuY29kZWQubGVuZ3RoID8gZW5jb2RlZFtpKytdIDogbnVsbDtcbiAgICAgICAgY29uc3QgaTMgPSBpIDwgZW5jb2RlZC5sZW5ndGggPyBlbmNvZGVkW2krK10gOiBudWxsO1xuICAgICAgICBiNjQgKz0gdG9CYXNlNjREaWdpdChpMSA+PiAyKTtcbiAgICAgICAgYjY0ICs9IHRvQmFzZTY0RGlnaXQoKChpMSAmIDMpIDw8IDQpIHwgKGkyID09PSBudWxsID8gMCA6IGkyID4+IDQpKTtcbiAgICAgICAgYjY0ICs9IGkyID09PSBudWxsID8gJz0nIDogdG9CYXNlNjREaWdpdCgoKGkyICYgMTUpIDw8IDIpIHwgKGkzID09PSBudWxsID8gMCA6IGkzID4+IDYpKTtcbiAgICAgICAgYjY0ICs9IGkyID09PSBudWxsIHx8IGkzID09PSBudWxsID8gJz0nIDogdG9CYXNlNjREaWdpdChpMyAmIDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIGI2NDtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VkxRKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZSA8IDAgPyAoKC12YWx1ZSkgPDwgMSkgKyAxIDogdmFsdWUgPDwgMTtcbiAgICBsZXQgb3V0ID0gJyc7XG4gICAgZG8ge1xuICAgICAgICBsZXQgZGlnaXQgPSB2YWx1ZSAmIDMxO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDU7XG4gICAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgICAgIGRpZ2l0ID0gZGlnaXQgfCAzMjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gdG9CYXNlNjREaWdpdChkaWdpdCk7XG4gICAgfSB3aGlsZSAodmFsdWUgPiAwKTtcbiAgICByZXR1cm4gb3V0O1xufVxuY29uc3QgQjY0X0RJR0lUUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbmZ1bmN0aW9uIHRvQmFzZTY0RGlnaXQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG9ubHkgZW5jb2RlIHZhbHVlIGluIHRoZSByYW5nZSBbMCwgNjNdYCk7XG4gICAgfVxuICAgIHJldHVybiBCNjRfRElHSVRTW3ZhbHVlXTtcbn1cblxuY29uc3QgX1NJTkdMRV9RVU9URV9FU0NBUEVfU1RSSU5HX1JFID0gLyd8XFxcXHxcXG58XFxyfFxcJC9nO1xuY29uc3QgX0xFR0FMX0lERU5USUZJRVJfUkUgPSAvXlskQS1aX11bMC05QS1aXyRdKiQvaTtcbmNvbnN0IF9JTkRFTlRfV0lUSCA9ICcgICc7XG5jbGFzcyBfRW1pdHRlZExpbmUge1xuICAgIGNvbnN0cnVjdG9yKGluZGVudCkge1xuICAgICAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICAgICAgdGhpcy5wYXJ0c0xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zcmNTcGFucyA9IFtdO1xuICAgIH1cbn1cbmNsYXNzIEVtaXR0ZXJWaXNpdG9yQ29udGV4dCB7XG4gICAgc3RhdGljIGNyZWF0ZVJvb3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1pdHRlclZpc2l0b3JDb250ZXh0KDApO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfaW5kZW50KSB7XG4gICAgICAgIHRoaXMuX2luZGVudCA9IF9pbmRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVzID0gW25ldyBfRW1pdHRlZExpbmUoX2luZGVudCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgKi9cbiAgICBnZXQgX2N1cnJlbnRMaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHByaW50bG4oZnJvbSwgbGFzdFBhcnQgPSAnJykge1xuICAgICAgICB0aGlzLnByaW50KGZyb20gfHwgbnVsbCwgbGFzdFBhcnQsIHRydWUpO1xuICAgIH1cbiAgICBsaW5lSXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgbGluZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRMaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGggKyB0aGlzLl9jdXJyZW50TGluZS5wYXJ0c0xlbmd0aDtcbiAgICB9XG4gICAgcHJpbnQoZnJvbSwgcGFydCwgbmV3TGluZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5wYXJ0c0xlbmd0aCArPSBwYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lLnNyY1NwYW5zLnB1c2goZnJvbSAmJiBmcm9tLnNvdXJjZVNwYW4gfHwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobmV3IF9FbWl0dGVkTGluZSh0aGlzLl9pbmRlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVFbXB0eUxhc3RMaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmNJbmRlbnQoKSB7XG4gICAgICAgIHRoaXMuX2luZGVudCsrO1xuICAgICAgICBpZiAodGhpcy5saW5lSXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZS5pbmRlbnQgPSB0aGlzLl9pbmRlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVjSW5kZW50KCkge1xuICAgICAgICB0aGlzLl9pbmRlbnQtLTtcbiAgICAgICAgaWYgKHRoaXMubGluZUlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmUuaW5kZW50ID0gdGhpcy5faW5kZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VMaW5lc1xuICAgICAgICAgICAgLm1hcChsID0+IGwucGFydHMubGVuZ3RoID4gMCA/IF9jcmVhdGVJbmRlbnQobC5pbmRlbnQpICsgbC5wYXJ0cy5qb2luKCcnKSA6ICcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICB0b1NvdXJjZU1hcEdlbmVyYXRvcihnZW5GaWxlUGF0aCwgc3RhcnRzQXRMaW5lID0gMCkge1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGdlbkZpbGVQYXRoKTtcbiAgICAgICAgbGV0IGZpcnN0T2Zmc2V0TWFwcGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZpcnN0T2Zmc2V0TWFwcGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGEgc2luZ2xlIHNwYWNlIHNvIHRoYXQgdG9vbHMgd29uJ3QgdHJ5IHRvIGxvYWQgdGhlIGZpbGUgZnJvbSBkaXNrLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGFyZSB1c2luZyB2aXJ0dWFsIHVybHMgbGlrZSBgbmc6Ly8vYCwgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGUgYSBjb250ZW50IGhlcmUuXG4gICAgICAgICAgICAgICAgbWFwLmFkZFNvdXJjZShnZW5GaWxlUGF0aCwgJyAnKS5hZGRNYXBwaW5nKDAsIGdlbkZpbGVQYXRoLCAwLCAwKTtcbiAgICAgICAgICAgICAgICBmaXJzdE9mZnNldE1hcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnRzQXRMaW5lOyBpKyspIHtcbiAgICAgICAgICAgIG1hcC5hZGRMaW5lKCk7XG4gICAgICAgICAgICBtYXBGaXJzdE9mZnNldElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VMaW5lcy5mb3JFYWNoKChsaW5lLCBsaW5lSWR4KSA9PiB7XG4gICAgICAgICAgICBtYXAuYWRkTGluZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3BhbnMgPSBsaW5lLnNyY1NwYW5zO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnBhcnRzO1xuICAgICAgICAgICAgbGV0IGNvbDAgPSBsaW5lLmluZGVudCAqIF9JTkRFTlRfV0lUSC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgc3BhbklkeCA9IDA7XG4gICAgICAgICAgICAvLyBza2lwIGxlYWRpbmcgcGFydHMgd2l0aG91dCBzb3VyY2Ugc3BhbnNcbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmICFzcGFuc1tzcGFuSWR4XSkge1xuICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNwYW5JZHgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIGxpbmVJZHggPT09IDAgJiYgY29sMCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpcnN0T2Zmc2V0TWFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hcEZpcnN0T2Zmc2V0SWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BhbiA9IHNwYW5zW3NwYW5JZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHNwYW4uc3RhcnQuZmlsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gc3Bhbi5zdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbCA9IHNwYW4uc3RhcnQuY29sO1xuICAgICAgICAgICAgICAgIG1hcC5hZGRTb3VyY2Uoc291cmNlLnVybCwgc291cmNlLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGRNYXBwaW5nKGNvbDAsIHNvdXJjZS51cmwsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbCk7XG4gICAgICAgICAgICAgICAgY29sMCArPSBwYXJ0c1tzcGFuSWR4XS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3BhbklkeCsrO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBwYXJ0cyB3aXRob3V0IHNwYW4gb3IgdGhlIHNhbWUgc3BhbiB0byB0aGUgcHJldmlvdXMgc2VnbWVudFxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGFuSWR4IDwgc3BhbnMubGVuZ3RoICYmIChzcGFuID09PSBzcGFuc1tzcGFuSWR4XSB8fCAhc3BhbnNbc3BhbklkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbDAgKz0gcGFydHNbc3BhbklkeF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBzcGFuSWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgc3Bhbk9mKGxpbmUsIGNvbHVtbikge1xuICAgICAgICBjb25zdCBlbWl0dGVkTGluZSA9IHRoaXMuX2xpbmVzW2xpbmVdO1xuICAgICAgICBpZiAoZW1pdHRlZExpbmUpIHtcbiAgICAgICAgICAgIGxldCBjb2x1bW5zTGVmdCA9IGNvbHVtbiAtIF9jcmVhdGVJbmRlbnQoZW1pdHRlZExpbmUuaW5kZW50KS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0SW5kZXggPSAwOyBwYXJ0SW5kZXggPCBlbWl0dGVkTGluZS5wYXJ0cy5sZW5ndGg7IHBhcnRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGVtaXR0ZWRMaW5lLnBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQubGVuZ3RoID4gY29sdW1uc0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVtaXR0ZWRMaW5lLnNyY1NwYW5zW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbHVtbnNMZWZ0IC09IHBhcnQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgc3RyaXAgdGhpcyBmcm9tIHB1Ymxpc2hlZCBkLnRzIGZpbGVzIGR1ZSB0b1xuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzYyMTZcbiAgICAgKi9cbiAgICBnZXQgc291cmNlTGluZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lcy5sZW5ndGggJiYgdGhpcy5fbGluZXNbdGhpcy5fbGluZXMubGVuZ3RoIC0gMV0ucGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGluZXMuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgICB9XG59XG5jbGFzcyBBYnN0cmFjdEVtaXR0ZXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfZXNjYXBlRG9sbGFySW5TdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuX2VzY2FwZURvbGxhckluU3RyaW5ncyA9IF9lc2NhcGVEb2xsYXJJblN0cmluZ3M7XG4gICAgfVxuICAgIHByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5sZWFkaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY29tbWVudCBvZiBzdG10LmxlYWRpbmdDb21tZW50cykge1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgaW5zdGFuY2VvZiBKU0RvY0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnQoc3RtdCwgYC8qJHtjb21tZW50LnRvU3RyaW5nKCl9Ki9gLCBjb21tZW50LnRyYWlsaW5nTmV3bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudC5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIGAvKiAke2NvbW1lbnQudGV4dH0gKi9gLCBjb21tZW50LnRyYWlsaW5nTmV3bGluZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50LnRleHQuc3BsaXQoJ1xcbicpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGAvLyAke2xpbmV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEV4cHJlc3Npb25TdG10KHN0bXQsIGN0eCkge1xuICAgICAgICB0aGlzLnByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCk7XG4gICAgICAgIHN0bXQuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0UmV0dXJuU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgdGhpcy5wcmludExlYWRpbmdDb21tZW50cyhzdG10LCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgYHJldHVybiBgKTtcbiAgICAgICAgc3RtdC52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgJzsnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0SWZTdG10KHN0bXQsIGN0eCkge1xuICAgICAgICB0aGlzLnByaW50TGVhZGluZ0NvbW1lbnRzKHN0bXQsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgaWYgKGApO1xuICAgICAgICBzdG10LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KHN0bXQsIGApIHtgKTtcbiAgICAgICAgY29uc3QgaGFzRWxzZUNhc2UgPSBzdG10LmZhbHNlQ2FzZSAhPSBudWxsICYmIHN0bXQuZmFsc2VDYXNlLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmIChzdG10LnRydWVDYXNlLmxlbmd0aCA8PSAxICYmICFoYXNFbHNlQ2FzZSkge1xuICAgICAgICAgICAgY3R4LnByaW50KHN0bXQsIGAgYCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsU3RhdGVtZW50cyhzdG10LnRydWVDYXNlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnJlbW92ZUVtcHR5TGFzdExpbmUoKTtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCBgIGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnByaW50bG4oKTtcbiAgICAgICAgICAgIGN0eC5pbmNJbmRlbnQoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQudHJ1ZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgICAgICBpZiAoaGFzRWxzZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgfSBlbHNlIHtgKTtcbiAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEFsbFN0YXRlbWVudHMoc3RtdC5mYWxzZUNhc2UsIGN0eCk7XG4gICAgICAgICAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlVmFyRXhwcihleHByLCBjdHgpIHtcbiAgICAgICAgY29uc3QgbGluZVdhc0VtcHR5ID0gY3R4LmxpbmVJc0VtcHR5KCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJygnKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoZXhwciwgYCR7ZXhwci5uYW1lfSA9IGApO1xuICAgICAgICBleHByLnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0V3JpdGVLZXlFeHByKGV4cHIsIGN0eCkge1xuICAgICAgICBjb25zdCBsaW5lV2FzRW1wdHkgPSBjdHgubGluZUlzRW1wdHkoKTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKCcpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIucmVjZWl2ZXIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgW2ApO1xuICAgICAgICBleHByLmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgYF0gPSBgKTtcbiAgICAgICAgZXhwci52YWx1ZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKCFsaW5lV2FzRW1wdHkpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyaXRlUHJvcEV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGNvbnN0IGxpbmVXYXNFbXB0eSA9IGN0eC5saW5lSXNFbXB0eSgpO1xuICAgICAgICBpZiAoIWxpbmVXYXNFbXB0eSkge1xuICAgICAgICAgICAgY3R4LnByaW50KGV4cHIsICcoJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwci5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsIGAuJHtleHByLm5hbWV9ID0gYCk7XG4gICAgICAgIGV4cHIudmFsdWUudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmICghbGluZVdhc0VtcHR5KSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRJbnZva2VGdW5jdGlvbkV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIuZm4udmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgKGApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoZXhwci5hcmdzLCBjdHgsICcsJyk7XG4gICAgICAgIGN0eC5wcmludChleHByLCBgKWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRUYWdnZWRUZW1wbGF0ZUV4cHIoZXhwciwgY3R4KSB7XG4gICAgICAgIGV4cHIudGFnLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoZXhwciwgJ2AnICsgZXhwci50ZW1wbGF0ZS5lbGVtZW50c1swXS5yYXdUZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBleHByLnRlbXBsYXRlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoZXhwciwgJyR7Jyk7XG4gICAgICAgICAgICBleHByLnRlbXBsYXRlLmV4cHJlc3Npb25zW2kgLSAxXS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgICAgIGN0eC5wcmludChleHByLCBgfSR7ZXhwci50ZW1wbGF0ZS5lbGVtZW50c1tpXS5yYXdUZXh0fWApO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludChleHByLCAnYCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBYnN0cmFjdCBlbWl0dGVyIGNhbm5vdCB2aXNpdCBXcmFwcGVkTm9kZUV4cHIuJyk7XG4gICAgfVxuICAgIHZpc2l0VHlwZW9mRXhwcihleHByLCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGV4cHIsICd0eXBlb2YgJyk7XG4gICAgICAgIGV4cHIuZXhwci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICB9XG4gICAgdmlzaXRSZWFkVmFyRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEluc3RhbnRpYXRlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgbmV3IGApO1xuICAgICAgICBhc3QuY2xhc3NFeHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgKGApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsRXhwcmVzc2lvbnMoYXN0LmFyZ3MsIGN0eCwgJywnKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYClgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhc3QudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBlc2NhcGVJZGVudGlmaWVyKHZhbHVlLCB0aGlzLl9lc2NhcGVEb2xsYXJJblN0cmluZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdExvY2FsaXplZFN0cmluZyhhc3QsIGN0eCkge1xuICAgICAgICBjb25zdCBoZWFkID0gYXN0LnNlcmlhbGl6ZUkxOG5IZWFkKCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICckbG9jYWxpemUgYCcgKyBoZWFkLnJhdyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXN0Lm1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgJyR7Jyk7XG4gICAgICAgICAgICBhc3QuZXhwcmVzc2lvbnNbaSAtIDFdLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYH0ke2FzdC5zZXJpYWxpemVJMThuVGVtcGxhdGVQYXJ0KGkpLnJhd31gKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJpbnQoYXN0LCAnYCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYChgKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJz8gJyk7XG4gICAgICAgIGFzdC50cnVlQ2FzZS52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJzogJyk7XG4gICAgICAgIGFzdC5mYWxzZUNhc2UudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGApYCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdE5vdEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJyEnKTtcbiAgICAgICAgYXN0LmNvbmRpdGlvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0VW5hcnlPcGVyYXRvckV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgbGV0IG9wU3RyO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBVbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVuYXJ5T3BlcmF0b3IuTWludXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnLSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvciAke2FzdC5vcGVyYXRvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN0LnBhcmVucylcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsIGAoYCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIG9wU3RyKTtcbiAgICAgICAgYXN0LmV4cHIudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGlmIChhc3QucGFyZW5zKVxuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYClgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5T3BlcmF0b3JFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGxldCBvcFN0cjtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuSWRlbnRpY2FsOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz09PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdEVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk5vdElkZW50aWNhbDpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICchPT0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5BbmQ6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnJiYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5CaXR3aXNlQW5kOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyYnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5PcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICd8fCc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLlBsdXM6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnKyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk1pbnVzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJy0nO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5EaXZpZGU6XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnLyc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5OlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJyonO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Nb2R1bG86XG4gICAgICAgICAgICAgICAgb3BTdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkxvd2VyOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJzwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFsczpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc8PSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEJpbmFyeU9wZXJhdG9yLkJpZ2dlcjpcbiAgICAgICAgICAgICAgICBvcFN0ciA9ICc+JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuQmlnZ2VyRXF1YWxzOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz49JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQmluYXJ5T3BlcmF0b3IuTnVsbGlzaENvYWxlc2NlOlxuICAgICAgICAgICAgICAgIG9wU3RyID0gJz8/JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wZXJhdG9yICR7YXN0Lm9wZXJhdG9yfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhc3QucGFyZW5zKVxuICAgICAgICAgICAgY3R4LnByaW50KGFzdCwgYChgKTtcbiAgICAgICAgYXN0Lmxocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYCAke29wU3RyfSBgKTtcbiAgICAgICAgYXN0LnJocy52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgaWYgKGFzdC5wYXJlbnMpXG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgKWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRSZWFkUHJvcEV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgYXN0LnJlY2VpdmVyLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgLmApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBhc3QubmFtZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFJlYWRLZXlFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGFzdC5yZWNlaXZlci52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFtgKTtcbiAgICAgICAgYXN0LmluZGV4LnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgXWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXlFeHByKGFzdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBbYCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxFeHByZXNzaW9ucyhhc3QuZW50cmllcywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgXWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsTWFwRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBge2ApO1xuICAgICAgICB0aGlzLnZpc2l0QWxsT2JqZWN0cyhlbnRyeSA9PiB7XG4gICAgICAgICAgICBjdHgucHJpbnQoYXN0LCBgJHtlc2NhcGVJZGVudGlmaWVyKGVudHJ5LmtleSwgdGhpcy5fZXNjYXBlRG9sbGFySW5TdHJpbmdzLCBlbnRyeS5xdW90ZWQpfTpgKTtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9LCBhc3QuZW50cmllcywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRDb21tYUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgJygnKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbEV4cHJlc3Npb25zKGFzdC5wYXJ0cywgY3R4LCAnLCcpO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCAnKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRBbGxFeHByZXNzaW9ucyhleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMoZXhwciA9PiBleHByLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpLCBleHByZXNzaW9ucywgY3R4LCBzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB2aXNpdEFsbE9iamVjdHMoaGFuZGxlciwgZXhwcmVzc2lvbnMsIGN0eCwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGxldCBpbmNyZW1lbnRlZEluZGVudCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmxpbmVMZW5ndGgoKSA+IDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBzZXBhcmF0b3IsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluY3JlbWVudGVkSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51YXRpb24gYXJlIG1hcmtlZCB3aXRoIGRvdWJsZSBpbmRlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRlZEluZGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5wcmludChudWxsLCBzZXBhcmF0b3IsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKGV4cHJlc3Npb25zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jcmVtZW50ZWRJbmRlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnRpbnVhdGlvbiBhcmUgbWFya2VkIHdpdGggZG91YmxlIGluZGVudC5cbiAgICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgICAgIGN0eC5kZWNJbmRlbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEFsbFN0YXRlbWVudHMoc3RhdGVtZW50cywgY3R4KSB7XG4gICAgICAgIHN0YXRlbWVudHMuZm9yRWFjaCgoc3RtdCkgPT4gc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjdHgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlc2NhcGVJZGVudGlmaWVyKGlucHV0LCBlc2NhcGVEb2xsYXIsIGFsd2F5c1F1b3RlID0gdHJ1ZSkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gaW5wdXQucmVwbGFjZShfU0lOR0xFX1FVT1RFX0VTQ0FQRV9TVFJJTkdfUkUsICguLi5tYXRjaCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hbMF0gPT0gJyQnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlRG9sbGFyID8gJ1xcXFwkJyA6ICckJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaFswXSA9PSAnXFxuJykge1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbMF0gPT0gJ1xccicpIHtcbiAgICAgICAgICAgIHJldHVybiAnXFxcXHInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBcXFxcJHttYXRjaFswXX1gO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcmVxdWlyZXNRdW90ZXMgPSBhbHdheXNRdW90ZSB8fCAhX0xFR0FMX0lERU5USUZJRVJfUkUudGVzdChib2R5KTtcbiAgICByZXR1cm4gcmVxdWlyZXNRdW90ZXMgPyBgJyR7Ym9keX0nYCA6IGJvZHk7XG59XG5mdW5jdGlvbiBfY3JlYXRlSW5kZW50KGNvdW50KSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICByZXMgKz0gX0lOREVOVF9XSVRIO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiB0eXBlV2l0aFBhcmFtZXRlcnModHlwZSwgbnVtUGFyYW1zKSB7XG4gICAgaWYgKG51bVBhcmFtcyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUodHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGFyYW1zOyBpKyspIHtcbiAgICAgICAgcGFyYW1zLnB1c2goRFlOQU1JQ19UWVBFKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJlc3Npb25UeXBlKHR5cGUsIHVuZGVmaW5lZCwgcGFyYW1zKTtcbn1cbmNvbnN0IEFOSU1BVEVfU1lNQk9MX1BSRUZJWCA9ICdAJztcbmZ1bmN0aW9uIHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUobmFtZSkge1xuICAgIHJldHVybiBgJHtBTklNQVRFX1NZTUJPTF9QUkVGSVh9JHtuYW1lfWA7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJOYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGAke0FOSU1BVEVfU1lNQk9MX1BSRUZJWH0ke25hbWV9LiR7cGhhc2V9YDtcbn1cbmZ1bmN0aW9uIGdldFNhZmVQcm9wZXJ0eUFjY2Vzc1N0cmluZyhhY2Nlc3NvciwgbmFtZSkge1xuICAgIGNvbnN0IGVzY2FwZWROYW1lID0gZXNjYXBlSWRlbnRpZmllcihuYW1lLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBlc2NhcGVkTmFtZSAhPT0gbmFtZSA/IGAke2FjY2Vzc29yfVske2VzY2FwZWROYW1lfV1gIDogYCR7YWNjZXNzb3J9LiR7bmFtZX1gO1xufVxuZnVuY3Rpb24gcHJlcGFyZVN5bnRoZXRpY0xpc3RlbmVyRnVuY3Rpb25OYW1lKG5hbWUsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGBhbmltYXRpb25fJHtuYW1lfV8ke3BoYXNlfWA7XG59XG5mdW5jdGlvbiBqaXRPbmx5R3VhcmRlZEV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiBndWFyZGVkRXhwcmVzc2lvbignbmdKaXRNb2RlJywgZXhwcik7XG59XG5mdW5jdGlvbiBkZXZPbmx5R3VhcmRlZEV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiBndWFyZGVkRXhwcmVzc2lvbignbmdEZXZNb2RlJywgZXhwcik7XG59XG5mdW5jdGlvbiBndWFyZGVkRXhwcmVzc2lvbihndWFyZCwgZXhwcikge1xuICAgIGNvbnN0IGd1YXJkRXhwciA9IG5ldyBFeHRlcm5hbEV4cHIoeyBuYW1lOiBndWFyZCwgbW9kdWxlTmFtZTogbnVsbCB9KTtcbiAgICBjb25zdCBndWFyZE5vdERlZmluZWQgPSBuZXcgQmluYXJ5T3BlcmF0b3JFeHByKEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbCwgbmV3IFR5cGVvZkV4cHIoZ3VhcmRFeHByKSwgbGl0ZXJhbCgndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGd1YXJkVW5kZWZpbmVkT3JUcnVlID0gbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgZ3VhcmROb3REZWZpbmVkLCBndWFyZEV4cHIsIC8qIHR5cGUgKi8gdW5kZWZpbmVkLCBcbiAgICAvKiBzb3VyY2VTcGFuICovIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuQW5kLCBndWFyZFVuZGVmaW5lZE9yVHJ1ZSwgZXhwcik7XG59XG5mdW5jdGlvbiB3cmFwUmVmZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBXcmFwcGVkTm9kZUV4cHIodmFsdWUpO1xuICAgIHJldHVybiB7IHZhbHVlOiB3cmFwcGVkLCB0eXBlOiB3cmFwcGVkIH07XG59XG5mdW5jdGlvbiByZWZzVG9BcnJheShyZWZzLCBzaG91bGRGb3J3YXJkRGVjbGFyZSkge1xuICAgIGNvbnN0IHZhbHVlcyA9IGxpdGVyYWxBcnIocmVmcy5tYXAocmVmID0+IHJlZi52YWx1ZSkpO1xuICAgIHJldHVybiBzaG91bGRGb3J3YXJkRGVjbGFyZSA/IGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudCh2YWx1ZXMpXSkgOiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKGV4cHJlc3Npb24sIGZvcndhcmRSZWYpIHtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCBmb3J3YXJkUmVmIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSBgTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbmAgdG8gYW4gYEV4cHJlc3Npb25gLCBwb3NzaWJseSB3cmFwcGluZyBpdHMgZXhwcmVzc2lvbiBpbiBhXG4gKiBgZm9yd2FyZFJlZigpYCBjYWxsLlxuICpcbiAqIElmIGBNYXliZUZvcndhcmRSZWZFeHByZXNzaW9uLmZvcndhcmRSZWZgIGlzIGBGb3J3YXJkUmVmSGFuZGxpbmcuVW53cmFwcGVkYCB0aGVuIHRoZSBleHByZXNzaW9uXG4gKiB3YXMgb3JpZ2luYWxseSB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAgY2FsbCB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nIGVhZ2VybHkgZXZhbHVhdGVkXG4gKiBpbiB0aGUgY29kZS5cbiAqXG4gKiBTZWUgYHBhY2thZ2VzL2NvbXBpbGVyLWNsaS9zcmMvbmd0c2MvYW5ub3RhdGlvbnMvc3JjL2luamVjdGFibGUudHNgIGFuZFxuICogYHBhY2thZ2VzL2NvbXBpbGVyL3NyYy9qaXRfY29tcGlsZXJfZmFjYWRlLnRzYCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKHsgZXhwcmVzc2lvbiwgZm9yd2FyZFJlZiB9KSB7XG4gICAgc3dpdGNoIChmb3J3YXJkUmVmKSB7XG4gICAgICAgIGNhc2UgMCAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZSAqLzpcbiAgICAgICAgY2FzZSAxIC8qIEZvcndhcmRSZWZIYW5kbGluZy5XcmFwcGVkICovOlxuICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIGNhc2UgMiAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuVW53cmFwcGVkICovOlxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlRm9yd2FyZFJlZihleHByZXNzaW9uKTtcbiAgICB9XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIGV4cHJlc3Npb24gdGhhdCBoYXMgdGhlIGdpdmVuIGBleHByYCB3cmFwcGVkIGluIHRoZSBmb2xsb3dpbmcgZm9ybTpcbiAqXG4gKiBgYGBcbiAqIGZvcndhcmRSZWYoKCkgPT4gZXhwcilcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUZvcndhcmRSZWYoZXhwcikge1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmZvcndhcmRSZWYpLmNhbGxGbihbZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGV4cHIpXSldKTtcbn1cblxudmFyIFIzRmFjdG9yeURlbGVnYXRlVHlwZTtcbihmdW5jdGlvbiAoUjNGYWN0b3J5RGVsZWdhdGVUeXBlKSB7XG4gICAgUjNGYWN0b3J5RGVsZWdhdGVUeXBlW1IzRmFjdG9yeURlbGVnYXRlVHlwZVtcIkNsYXNzXCJdID0gMF0gPSBcIkNsYXNzXCI7XG4gICAgUjNGYWN0b3J5RGVsZWdhdGVUeXBlW1IzRmFjdG9yeURlbGVnYXRlVHlwZVtcIkZ1bmN0aW9uXCJdID0gMV0gPSBcIkZ1bmN0aW9uXCI7XG59KShSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUgfHwgKFIzRmFjdG9yeURlbGVnYXRlVHlwZSA9IHt9KSk7XG52YXIgRmFjdG9yeVRhcmdldCQxO1xuKGZ1bmN0aW9uIChGYWN0b3J5VGFyZ2V0KSB7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiRGlyZWN0aXZlXCJdID0gMF0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJJbmplY3RhYmxlXCJdID0gMl0gPSBcIkluamVjdGFibGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJQaXBlXCJdID0gM10gPSBcIlBpcGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoRmFjdG9yeVRhcmdldCQxIHx8IChGYWN0b3J5VGFyZ2V0JDEgPSB7fSkpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBmYWN0b3J5IGZ1bmN0aW9uIGV4cHJlc3Npb24gZm9yIHRoZSBnaXZlbiBgUjNGYWN0b3J5TWV0YWRhdGFgLlxuICovXG5mdW5jdGlvbiBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKG1ldGEpIHtcbiAgICBjb25zdCB0ID0gdmFyaWFibGUoJ3QnKTtcbiAgICBsZXQgYmFzZUZhY3RvcnlWYXIgPSBudWxsO1xuICAgIC8vIFRoZSB0eXBlIHRvIGluc3RhbnRpYXRlIHZpYSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLiBJZiB0aGVyZSBpcyBubyBkZWxlZ2F0ZWQgZmFjdG9yeSwgbWVhbmluZ1xuICAgIC8vIHRoaXMgdHlwZSBpcyBhbHdheXMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uLCB0aGVuIHRoaXMgaXMgdGhlIHR5cGUtdG8tY3JlYXRlXG4gICAgLy8gcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICh0KSBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjdXJyZW50IHR5cGUgaWYgbm90LiBJZiB0aGVyZSBpcyBhXG4gICAgLy8gZGVsZWdhdGVkIGZhY3RvcnkgKHdoaWNoIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBjdXJyZW50IHR5cGUpIHRoZW4gdGhpcyBpcyBvbmx5IHRoZSB0eXBlLXRvLVxuICAgIC8vIGNyZWF0ZSBwYXJhbWV0ZXIgKHQpLlxuICAgIGNvbnN0IHR5cGVGb3JDdG9yID0gIWlzRGVsZWdhdGVkRmFjdG9yeU1ldGFkYXRhKG1ldGEpID9cbiAgICAgICAgbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihCaW5hcnlPcGVyYXRvci5PciwgdCwgbWV0YS5pbnRlcm5hbFR5cGUpIDpcbiAgICAgICAgdDtcbiAgICBsZXQgY3RvckV4cHIgPSBudWxsO1xuICAgIGlmIChtZXRhLmRlcHMgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlcmUgaXMgYSBjb25zdHJ1Y3RvciAoZWl0aGVyIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBkZWZpbmVkKS5cbiAgICAgICAgaWYgKG1ldGEuZGVwcyAhPT0gJ2ludmFsaWQnKSB7XG4gICAgICAgICAgICBjdG9yRXhwciA9IG5ldyBJbnN0YW50aWF0ZUV4cHIodHlwZUZvckN0b3IsIGluamVjdERlcGVuZGVuY2llcyhtZXRhLmRlcHMsIG1ldGEudGFyZ2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbnN0cnVjdG9yLCB1c2UgdGhlIGJhc2UgY2xhc3MnIGZhY3RvcnkgdG8gY29uc3RydWN0IHR5cGVGb3JDdG9yLlxuICAgICAgICBiYXNlRmFjdG9yeVZhciA9IHZhcmlhYmxlKGDJtSR7bWV0YS5uYW1lfV9CYXNlRmFjdG9yeWApO1xuICAgICAgICBjdG9yRXhwciA9IGJhc2VGYWN0b3J5VmFyLmNhbGxGbihbdHlwZUZvckN0b3JdKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIGxldCByZXRFeHByID0gbnVsbDtcbiAgICBmdW5jdGlvbiBtYWtlQ29uZGl0aW9uYWxGYWN0b3J5KG5vbkN0b3JFeHByKSB7XG4gICAgICAgIGNvbnN0IHIgPSB2YXJpYWJsZSgncicpO1xuICAgICAgICBib2R5LnB1c2goci5zZXQoTlVMTF9FWFBSKS50b0RlY2xTdG10KCkpO1xuICAgICAgICBjb25zdCBjdG9yU3RtdCA9IGN0b3JFeHByICE9PSBudWxsID8gci5zZXQoY3RvckV4cHIpLnRvU3RtdCgpIDpcbiAgICAgICAgICAgIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuaW52YWxpZEZhY3RvcnkpLmNhbGxGbihbXSkudG9TdG10KCk7XG4gICAgICAgIGJvZHkucHVzaChpZlN0bXQodCwgW2N0b3JTdG10XSwgW3Iuc2V0KG5vbkN0b3JFeHByKS50b1N0bXQoKV0pKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGlmIChpc0RlbGVnYXRlZEZhY3RvcnlNZXRhZGF0YShtZXRhKSkge1xuICAgICAgICAvLyBUaGlzIHR5cGUgaXMgY3JlYXRlZCB3aXRoIGEgZGVsZWdhdGVkIGZhY3RvcnkuIElmIGEgdHlwZSBwYXJhbWV0ZXIgaXMgbm90IHNwZWNpZmllZCwgY2FsbFxuICAgICAgICAvLyB0aGUgZmFjdG9yeSBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBkZWxlZ2F0ZUFyZ3MgPSBpbmplY3REZXBlbmRlbmNpZXMobWV0YS5kZWxlZ2F0ZURlcHMsIG1ldGEudGFyZ2V0KTtcbiAgICAgICAgLy8gRWl0aGVyIGNhbGwgYG5ldyBkZWxlZ2F0ZSguLi4pYCBvciBgZGVsZWdhdGUoLi4uKWAgZGVwZW5kaW5nIG9uIG1ldGEuZGVsZWdhdGVUeXBlLlxuICAgICAgICBjb25zdCBmYWN0b3J5RXhwciA9IG5ldyAobWV0YS5kZWxlZ2F0ZVR5cGUgPT09IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5DbGFzcyA/XG4gICAgICAgICAgICBJbnN0YW50aWF0ZUV4cHIgOlxuICAgICAgICAgICAgSW52b2tlRnVuY3Rpb25FeHByKShtZXRhLmRlbGVnYXRlLCBkZWxlZ2F0ZUFyZ3MpO1xuICAgICAgICByZXRFeHByID0gbWFrZUNvbmRpdGlvbmFsRmFjdG9yeShmYWN0b3J5RXhwcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXhwcmVzc2lvbkZhY3RvcnlNZXRhZGF0YShtZXRhKSkge1xuICAgICAgICAvLyBUT0RPKGFseGh1Yik6IGRlY2lkZSB3aGV0aGVyIHRvIGxvd2VyIHRoZSB2YWx1ZSBoZXJlIG9yIGluIHRoZSBjYWxsZXJcbiAgICAgICAgcmV0RXhwciA9IG1ha2VDb25kaXRpb25hbEZhY3RvcnkobWV0YS5leHByZXNzaW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldEV4cHIgPSBjdG9yRXhwcjtcbiAgICB9XG4gICAgaWYgKHJldEV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gY2Fubm90IGJlIGZvcm1lZCBzbyByZW5kZXIgYW4gYMm1ybVpbnZhbGlkRmFjdG9yeSgpYCBjYWxsLlxuICAgICAgICBib2R5LnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbnZhbGlkRmFjdG9yeSkuY2FsbEZuKFtdKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJhc2VGYWN0b3J5VmFyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgZmFjdG9yeSB1c2VzIGEgYmFzZSBmYWN0b3J5LCBzbyBjYWxsIGDJtcm1Z2V0SW5oZXJpdGVkRmFjdG9yeSgpYCB0byBjb21wdXRlIGl0LlxuICAgICAgICBjb25zdCBnZXRJbmhlcml0ZWRGYWN0b3J5Q2FsbCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZ2V0SW5oZXJpdGVkRmFjdG9yeSkuY2FsbEZuKFttZXRhLmludGVybmFsVHlwZV0pO1xuICAgICAgICAvLyBNZW1vaXplIHRoZSBiYXNlIGZhY3RvcnlGbjogYGJhc2VGYWN0b3J5IHx8IChiYXNlRmFjdG9yeSA9IMm1ybVnZXRJbmhlcml0ZWRGYWN0b3J5KC4uLikpYFxuICAgICAgICBjb25zdCBiYXNlRmFjdG9yeSA9IG5ldyBCaW5hcnlPcGVyYXRvckV4cHIoQmluYXJ5T3BlcmF0b3IuT3IsIGJhc2VGYWN0b3J5VmFyLCBiYXNlRmFjdG9yeVZhci5zZXQoZ2V0SW5oZXJpdGVkRmFjdG9yeUNhbGwpKTtcbiAgICAgICAgYm9keS5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQoYmFzZUZhY3RvcnkuY2FsbEZuKFt0eXBlRm9yQ3Rvcl0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIHN0cmFpZ2h0Zm9yd2FyZCBmYWN0b3J5LCBqdXN0IHJldHVybiBpdC5cbiAgICAgICAgYm9keS5wdXNoKG5ldyBSZXR1cm5TdGF0ZW1lbnQocmV0RXhwcikpO1xuICAgIH1cbiAgICBsZXQgZmFjdG9yeUZuID0gZm4oW25ldyBGblBhcmFtKCd0JywgRFlOQU1JQ19UWVBFKV0sIGJvZHksIElORkVSUkVEX1RZUEUsIHVuZGVmaW5lZCwgYCR7bWV0YS5uYW1lfV9GYWN0b3J5YCk7XG4gICAgaWYgKGJhc2VGYWN0b3J5VmFyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIGEgYmFzZSBmYWN0b3J5IHZhcmlhYmxlIHNvIHdyYXAgaXRzIGRlY2xhcmF0aW9uIGFsb25nIHdpdGggdGhlIGZhY3RvcnkgZnVuY3Rpb24gaW50b1xuICAgICAgICAvLyBhbiBJSUZFLlxuICAgICAgICBmYWN0b3J5Rm4gPSBmbihbXSwgW1xuICAgICAgICAgICAgbmV3IERlY2xhcmVWYXJTdG10KGJhc2VGYWN0b3J5VmFyLm5hbWUpLCBuZXcgUmV0dXJuU3RhdGVtZW50KGZhY3RvcnlGbilcbiAgICAgICAgXSkuY2FsbEZuKFtdLCAvKiBzb3VyY2VTcGFuICovIHVuZGVmaW5lZCwgLyogcHVyZSAqLyB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogZmFjdG9yeUZuLFxuICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgdHlwZTogY3JlYXRlRmFjdG9yeVR5cGUobWV0YSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlUeXBlKG1ldGEpIHtcbiAgICBjb25zdCBjdG9yRGVwc1R5cGUgPSBtZXRhLmRlcHMgIT09IG51bGwgJiYgbWV0YS5kZXBzICE9PSAnaW52YWxpZCcgPyBjcmVhdGVDdG9yRGVwc1R5cGUobWV0YS5kZXBzKSA6IE5PTkVfVFlQRTtcbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy5GYWN0b3J5RGVjbGFyYXRpb24sIFt0eXBlV2l0aFBhcmFtZXRlcnMobWV0YS50eXBlLnR5cGUsIG1ldGEudHlwZUFyZ3VtZW50Q291bnQpLCBjdG9yRGVwc1R5cGVdKSk7XG59XG5mdW5jdGlvbiBpbmplY3REZXBlbmRlbmNpZXMoZGVwcywgdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlcHMubWFwKChkZXAsIGluZGV4KSA9PiBjb21waWxlSW5qZWN0RGVwZW5kZW5jeShkZXAsIHRhcmdldCwgaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3REZXBlbmRlbmN5KGRlcCwgdGFyZ2V0LCBpbmRleCkge1xuICAgIC8vIEludGVycHJldCB0aGUgZGVwZW5kZW5jeSBhY2NvcmRpbmcgdG8gaXRzIHJlc29sdmVkIHR5cGUuXG4gICAgaWYgKGRlcC50b2tlbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbnZhbGlkRmFjdG9yeURlcCkuY2FsbEZuKFtsaXRlcmFsKGluZGV4KV0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXAuYXR0cmlidXRlTmFtZVR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGluamVjdGlvbiBmbGFncyBhY2NvcmRpbmcgdG8gdGhlIG1ldGFkYXRhLlxuICAgICAgICBjb25zdCBmbGFncyA9IDAgLyogSW5qZWN0RmxhZ3MuRGVmYXVsdCAqLyB8IChkZXAuc2VsZiA/IDIgLyogSW5qZWN0RmxhZ3MuU2VsZiAqLyA6IDApIHxcbiAgICAgICAgICAgIChkZXAuc2tpcFNlbGYgPyA0IC8qIEluamVjdEZsYWdzLlNraXBTZWxmICovIDogMCkgfCAoZGVwLmhvc3QgPyAxIC8qIEluamVjdEZsYWdzLkhvc3QgKi8gOiAwKSB8XG4gICAgICAgICAgICAoZGVwLm9wdGlvbmFsID8gOCAvKiBJbmplY3RGbGFncy5PcHRpb25hbCAqLyA6IDApIHxcbiAgICAgICAgICAgICh0YXJnZXQgPT09IEZhY3RvcnlUYXJnZXQkMS5QaXBlID8gMTYgLyogSW5qZWN0RmxhZ3MuRm9yUGlwZSAqLyA6IDApO1xuICAgICAgICAvLyBJZiB0aGlzIGRlcGVuZGVuY3kgaXMgb3B0aW9uYWwgb3Igb3RoZXJ3aXNlIGhhcyBub24tZGVmYXVsdCBmbGFncywgdGhlbiBhZGRpdGlvbmFsXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgZGVzY3JpYmluZyBob3cgdG8gaW5qZWN0IHRoZSBkZXBlbmRlbmN5IG11c3QgYmUgcGFzc2VkIHRvIHRoZSBpbmplY3QgZnVuY3Rpb25cbiAgICAgICAgLy8gdGhhdCdzIGJlaW5nIHVzZWQuXG4gICAgICAgIGxldCBmbGFnc1BhcmFtID0gKGZsYWdzICE9PSAwIC8qIEluamVjdEZsYWdzLkRlZmF1bHQgKi8gfHwgZGVwLm9wdGlvbmFsKSA/IGxpdGVyYWwoZmxhZ3MpIDogbnVsbDtcbiAgICAgICAgLy8gQnVpbGQgdXAgdGhlIGFyZ3VtZW50cyB0byB0aGUgaW5qZWN0Rm4gY2FsbC5cbiAgICAgICAgY29uc3QgaW5qZWN0QXJncyA9IFtkZXAudG9rZW5dO1xuICAgICAgICBpZiAoZmxhZ3NQYXJhbSkge1xuICAgICAgICAgICAgaW5qZWN0QXJncy5wdXNoKGZsYWdzUGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluamVjdEZuID0gZ2V0SW5qZWN0Rm4odGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoaW5qZWN0Rm4pLmNhbGxGbihpbmplY3RBcmdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSBgZGVwLmF0dHJpYnV0ZVR5cGVOYW1lYCB2YWx1ZSBpcyBkZWZpbmVkLCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIGFuIGBAQXR0cmlidXRlKClgXG4gICAgICAgIC8vIHR5cGUgZGVwZW5kZW5jeS4gRm9yIHRoZSBnZW5lcmF0ZWQgSlMgd2Ugc3RpbGwgd2FudCB0byB1c2UgdGhlIGBkZXAudG9rZW5gIHZhbHVlIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG5hbWUgZ2l2ZW4gZm9yIHRoZSBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nIGxpdGVyYWwuIEZvciBleGFtcGxlIGdpdmVuIGBAQXR0cmlidXRlKGZvbygpKWAsXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZ2VuZXJhdGUgYMm1ybVpbmplY3RBdHRyaWJ1dGUoZm9vKCkpYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGBkZXAuYXR0cmlidXRlVHlwZU5hbWVgIGlzIG9ubHkgYWN0dWFsbHkgdXNlZCAoaW4gYGNyZWF0ZUN0b3JEZXBUeXBlKClgKSB0byBnZW5lcmF0ZVxuICAgICAgICAvLyB0eXBpbmdzLlxuICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5pbmplY3RBdHRyaWJ1dGUpLmNhbGxGbihbZGVwLnRva2VuXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ3RvckRlcHNUeXBlKGRlcHMpIHtcbiAgICBsZXQgaGFzVHlwZXMgPSBmYWxzZTtcbiAgICBjb25zdCBhdHRyaWJ1dGVUeXBlcyA9IGRlcHMubWFwKGRlcCA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVDdG9yRGVwVHlwZShkZXApO1xuICAgICAgICBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaGFzVHlwZXMgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbChudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChoYXNUeXBlcykge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycihhdHRyaWJ1dGVUeXBlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE5PTkVfVFlQRTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDdG9yRGVwVHlwZShkZXApIHtcbiAgICBjb25zdCBlbnRyaWVzID0gW107XG4gICAgaWYgKGRlcC5hdHRyaWJ1dGVOYW1lVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdhdHRyaWJ1dGUnLCB2YWx1ZTogZGVwLmF0dHJpYnV0ZU5hbWVUeXBlLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAoZGVwLm9wdGlvbmFsKSB7XG4gICAgICAgIGVudHJpZXMucHVzaCh7IGtleTogJ29wdGlvbmFsJywgdmFsdWU6IGxpdGVyYWwodHJ1ZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGlmIChkZXAuaG9zdCkge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdob3N0JywgdmFsdWU6IGxpdGVyYWwodHJ1ZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGlmIChkZXAuc2VsZikge1xuICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6ICdzZWxmJywgdmFsdWU6IGxpdGVyYWwodHJ1ZSksIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGlmIChkZXAuc2tpcFNlbGYpIHtcbiAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiAnc2tpcFNlbGYnLCB2YWx1ZTogbGl0ZXJhbCh0cnVlKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXMubGVuZ3RoID4gMCA/IGxpdGVyYWxNYXAoZW50cmllcykgOiBudWxsO1xufVxuZnVuY3Rpb24gaXNEZWxlZ2F0ZWRGYWN0b3J5TWV0YWRhdGEobWV0YSkge1xuICAgIHJldHVybiBtZXRhLmRlbGVnYXRlVHlwZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNFeHByZXNzaW9uRmFjdG9yeU1ldGFkYXRhKG1ldGEpIHtcbiAgICByZXR1cm4gbWV0YS5leHByZXNzaW9uICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRJbmplY3RGbih0YXJnZXQpIHtcbiAgICBzd2l0Y2ggKHRhcmdldCkge1xuICAgICAgICBjYXNlIEZhY3RvcnlUYXJnZXQkMS5Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRmFjdG9yeVRhcmdldCQxLkRpcmVjdGl2ZTpcbiAgICAgICAgY2FzZSBGYWN0b3J5VGFyZ2V0JDEuUGlwZTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5kaXJlY3RpdmVJbmplY3Q7XG4gICAgICAgIGNhc2UgRmFjdG9yeVRhcmdldCQxLk5nTW9kdWxlOlxuICAgICAgICBjYXNlIEZhY3RvcnlUYXJnZXQkMS5JbmplY3RhYmxlOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmluamVjdDtcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBSMyBgTm9kZWAtbGlrZSB3cmFwcGVyIGZvciBhIHJhdyBgaHRtbC5Db21tZW50YCBub2RlLiBXZSBkbyBub3QgY3VycmVudGx5XG4gKiByZXF1aXJlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHZpc2l0b3IgZm9yIENvbW1lbnRzIGFzIHRoZXkgYXJlIG9ubHkgY29sbGVjdGVkIGF0XG4gKiB0aGUgdG9wLWxldmVsIG9mIHRoZSBSMyBBU1QsIGFuZCBvbmx5IGlmIGBSZW5kZXIzUGFyc2VPcHRpb25zWydjb2xsZWN0Q29tbWVudE5vZGVzJ11gXG4gKiBpcyB0cnVlLlxuICovXG5jbGFzcyBDb21tZW50JDEge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQoX3Zpc2l0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2aXNpdCgpIG5vdCBpbXBsZW1lbnRlZCBmb3IgQ29tbWVudCcpO1xuICAgIH1cbn1cbmNsYXNzIFRleHQkMyB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZFRleHQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJvdW5kVGV4dCh0aGlzKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSB0ZXh0IGF0dHJpYnV0ZSBpbiB0aGUgdGVtcGxhdGUuXG4gKlxuICogYHZhbHVlU3BhbmAgbWF5IG5vdCBiZSBwcmVzZW50IGluIGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlIGA8ZGl2IGE+PC9kaXY+YC5cbiAqIGBrZXlTcGFuYCBtYXkgYWxzbyBub3QgYmUgcHJlc2VudCBmb3Igc3ludGhldGljIGF0dHJpYnV0ZXMgZnJvbSBJQ1UgZXhwYW5zaW9ucy5cbiAqL1xuY2xhc3MgVGV4dEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dEF0dHJpYnV0ZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJvdW5kRWxlbWVudFByb3BlcnR5KHByb3AsIGkxOG4pIHtcbiAgICAgICAgaWYgKHByb3Aua2V5U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdGU6IGtleVNwYW4gbXVzdCBiZSBkZWZpbmVkIGZvciBib3VuZCBhdHRyaWJ1dGVzIGJ1dCB3YXMgbm90IGZvciAke3Byb3AubmFtZX06ICR7cHJvcC5zb3VyY2VTcGFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRBdHRyaWJ1dGUocHJvcC5uYW1lLCBwcm9wLnR5cGUsIHByb3Auc2VjdXJpdHlDb250ZXh0LCBwcm9wLnZhbHVlLCBwcm9wLnVuaXQsIHByb3Auc291cmNlU3BhbiwgcHJvcC5rZXlTcGFuLCBwcm9wLnZhbHVlU3BhbiwgaTE4bik7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEF0dHJpYnV0ZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBCb3VuZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBoYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBzb3VyY2VTcGFuLCBoYW5kbGVyU3Bhbiwga2V5U3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5waGFzZSA9IHBoYXNlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmhhbmRsZXJTcGFuID0gaGFuZGxlclNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFyc2VkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudHlwZSA9PT0gMCAvKiBQYXJzZWRFdmVudFR5cGUuUmVndWxhciAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICBjb25zdCBwaGFzZSA9IGV2ZW50LnR5cGUgPT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLyA/IGV2ZW50LnRhcmdldE9yUGhhc2UgOiBudWxsO1xuICAgICAgICBpZiAoZXZlbnQua2V5U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc3RhdGU6IGtleVNwYW4gbXVzdCBiZSBkZWZpbmVkIGZvciBib3VuZCBldmVudCBidXQgd2FzIG5vdCBmb3IgJHtldmVudC5uYW1lfTogJHtldmVudC5zb3VyY2VTcGFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFdmVudChldmVudC5uYW1lLCBldmVudC50eXBlLCBldmVudC5oYW5kbGVyLCB0YXJnZXQsIHBoYXNlLCBldmVudC5zb3VyY2VTcGFuLCBldmVudC5oYW5kbGVyU3BhbiwgZXZlbnQua2V5U3Bhbik7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRCb3VuZEV2ZW50KHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIEVsZW1lbnQkMSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXR0cmlidXRlcywgaW5wdXRzLCBvdXRwdXRzLCBjaGlsZHJlbiwgcmVmZXJlbmNlcywgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuc3RhcnRTb3VyY2VTcGFuID0gc3RhcnRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmVuZFNvdXJjZVNwYW4gPSBlbmRTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RWxlbWVudCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gdGFnTmFtZSBpcyB0aGUgbmFtZSBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQsIGlmIGFwcGxpY2FibGUuXG4gICAgLy8gYG51bGxgIGlzIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZXJlIGlzIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUgb24gYW4gYG5nLXRlbXBsYXRlYCBzb1xuICAgIC8vIHRoZSByZW5kZXJlciBjYW4gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBzeW50aGV0aWMgdGVtcGxhdGUgYW5kIHRoZSBvbmUgd3JpdHRlbiBpbiB0aGVcbiAgICAvLyBmaWxlLlxuICAgIHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGlucHV0cywgb3V0cHV0cywgdGVtcGxhdGVBdHRycywgY2hpbGRyZW4sIHJlZmVyZW5jZXMsIHZhcmlhYmxlcywgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWU7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuaW5wdXRzID0gaW5wdXRzO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlQXR0cnMgPSB0ZW1wbGF0ZUF0dHJzO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucmVmZXJlbmNlcyA9IHJlZmVyZW5jZXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVzID0gdmFyaWFibGVzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLnN0YXJ0U291cmNlU3BhbiA9IHN0YXJ0U291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRlbXBsYXRlKHRoaXMpO1xuICAgIH1cbn1cbmNsYXNzIENvbnRlbnQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBzb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ25nLWNvbnRlbnQnO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGVudCh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3Bhbikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VmFyaWFibGUodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRSZWZlcmVuY2UodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgSWN1JDEge1xuICAgIGNvbnN0cnVjdG9yKHZhcnMsIHBsYWNlaG9sZGVycywgc291cmNlU3BhbiwgaTE4bikge1xuICAgICAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IHBsYWNlaG9sZGVycztcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEljdSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBOdWxsVmlzaXRvciB7XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHsgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHsgfVxuICAgIHZpc2l0Q29udGVudChjb250ZW50KSB7IH1cbiAgICB2aXNpdFZhcmlhYmxlKHZhcmlhYmxlKSB7IH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHsgfVxuICAgIHZpc2l0VGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRCb3VuZFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRJY3UoaWN1KSB7IH1cbn1cbmNsYXNzIFJlY3Vyc2l2ZVZpc2l0b3IkMSB7XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuaW5wdXRzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBlbGVtZW50Lm91dHB1dHMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIGVsZW1lbnQucmVmZXJlbmNlcyk7XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS5hdHRyaWJ1dGVzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS5pbnB1dHMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLm91dHB1dHMpO1xuICAgICAgICB2aXNpdEFsbCQxKHRoaXMsIHRlbXBsYXRlLmNoaWxkcmVuKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCB0ZW1wbGF0ZS52YXJpYWJsZXMpO1xuICAgIH1cbiAgICB2aXNpdENvbnRlbnQoY29udGVudCkgeyB9XG4gICAgdmlzaXRWYXJpYWJsZSh2YXJpYWJsZSkgeyB9XG4gICAgdmlzaXRSZWZlcmVuY2UocmVmZXJlbmNlKSB7IH1cbiAgICB2aXNpdFRleHRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7IH1cbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlKGF0dHJpYnV0ZSkgeyB9XG4gICAgdmlzaXRCb3VuZEV2ZW50KGF0dHJpYnV0ZSkgeyB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0Qm91bmRUZXh0KHRleHQpIHsgfVxuICAgIHZpc2l0SWN1KGljdSkgeyB9XG59XG5jbGFzcyBUcmFuc2Zvcm1WaXNpdG9yIHtcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gdHJhbnNmb3JtQWxsKHRoaXMsIGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IG5ld0lucHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCBlbGVtZW50LmlucHV0cyk7XG4gICAgICAgIGNvbnN0IG5ld091dHB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5vdXRwdXRzKTtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IG5ld1JlZmVyZW5jZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgZWxlbWVudC5yZWZlcmVuY2VzKTtcbiAgICAgICAgaWYgKG5ld0F0dHJpYnV0ZXMgIT0gZWxlbWVudC5hdHRyaWJ1dGVzIHx8IG5ld0lucHV0cyAhPSBlbGVtZW50LmlucHV0cyB8fFxuICAgICAgICAgICAgbmV3T3V0cHV0cyAhPSBlbGVtZW50Lm91dHB1dHMgfHwgbmV3Q2hpbGRyZW4gIT0gZWxlbWVudC5jaGlsZHJlbiB8fFxuICAgICAgICAgICAgbmV3UmVmZXJlbmNlcyAhPSBlbGVtZW50LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCQxKGVsZW1lbnQubmFtZSwgbmV3QXR0cmlidXRlcywgbmV3SW5wdXRzLCBuZXdPdXRwdXRzLCBuZXdDaGlsZHJlbiwgbmV3UmVmZXJlbmNlcywgZWxlbWVudC5zb3VyY2VTcGFuLCBlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgZWxlbWVudC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmlzaXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLmF0dHJpYnV0ZXMpO1xuICAgICAgICBjb25zdCBuZXdJbnB1dHMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuaW5wdXRzKTtcbiAgICAgICAgY29uc3QgbmV3T3V0cHV0cyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS5vdXRwdXRzKTtcbiAgICAgICAgY29uc3QgbmV3VGVtcGxhdGVBdHRycyA9IHRyYW5zZm9ybUFsbCh0aGlzLCB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgY29uc3QgbmV3Q2hpbGRyZW4gPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUuY2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBuZXdSZWZlcmVuY2VzID0gdHJhbnNmb3JtQWxsKHRoaXMsIHRlbXBsYXRlLnJlZmVyZW5jZXMpO1xuICAgICAgICBjb25zdCBuZXdWYXJpYWJsZXMgPSB0cmFuc2Zvcm1BbGwodGhpcywgdGVtcGxhdGUudmFyaWFibGVzKTtcbiAgICAgICAgaWYgKG5ld0F0dHJpYnV0ZXMgIT0gdGVtcGxhdGUuYXR0cmlidXRlcyB8fCBuZXdJbnB1dHMgIT0gdGVtcGxhdGUuaW5wdXRzIHx8XG4gICAgICAgICAgICBuZXdPdXRwdXRzICE9IHRlbXBsYXRlLm91dHB1dHMgfHwgbmV3VGVtcGxhdGVBdHRycyAhPSB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzIHx8XG4gICAgICAgICAgICBuZXdDaGlsZHJlbiAhPSB0ZW1wbGF0ZS5jaGlsZHJlbiB8fCBuZXdSZWZlcmVuY2VzICE9IHRlbXBsYXRlLnJlZmVyZW5jZXMgfHxcbiAgICAgICAgICAgIG5ld1ZhcmlhYmxlcyAhPSB0ZW1wbGF0ZS52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVtcGxhdGUodGVtcGxhdGUudGFnTmFtZSwgbmV3QXR0cmlidXRlcywgbmV3SW5wdXRzLCBuZXdPdXRwdXRzLCBuZXdUZW1wbGF0ZUF0dHJzLCBuZXdDaGlsZHJlbiwgbmV3UmVmZXJlbmNlcywgbmV3VmFyaWFibGVzLCB0ZW1wbGF0ZS5zb3VyY2VTcGFuLCB0ZW1wbGF0ZS5zdGFydFNvdXJjZVNwYW4sIHRlbXBsYXRlLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFibGUodmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlO1xuICAgIH1cbiAgICB2aXNpdFJlZmVyZW5jZShyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICB9XG4gICAgdmlzaXRUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH1cbiAgICB2aXNpdEJvdW5kQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH1cbiAgICB2aXNpdEJvdW5kRXZlbnQoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgcmV0dXJuIGljdTtcbiAgICB9XG59XG5mdW5jdGlvbiB2aXNpdEFsbCQxKHZpc2l0b3IsIG5vZGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKHZpc2l0b3IudmlzaXQpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gdmlzaXRvci52aXNpdChub2RlKSB8fCBub2RlLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBub2RlLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQWxsKHZpc2l0b3IsIG5vZGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5vZGUudmlzaXQodmlzaXRvcik7XG4gICAgICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXdOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBuZXdOb2RlICE9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkID8gcmVzdWx0IDogbm9kZXM7XG59XG5cbmNsYXNzIE1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBub2RlcyBtZXNzYWdlIEFTVFxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlcnMgbWFwcyBwbGFjZWhvbGRlciBuYW1lcyB0byBzdGF0aWMgY29udGVudCBhbmQgdGhlaXIgc291cmNlIHNwYW5zXG4gICAgICogQHBhcmFtIHBsYWNlaG9sZGVyVG9NZXNzYWdlIG1hcHMgcGxhY2Vob2xkZXIgbmFtZXMgdG8gbWVzc2FnZXMgKHVzZWQgZm9yIG5lc3RlZCBJQ1UgbWVzc2FnZXMpXG4gICAgICogQHBhcmFtIG1lYW5pbmdcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gY3VzdG9tSWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlcywgcGxhY2Vob2xkZXJzLCBwbGFjZWhvbGRlclRvTWVzc2FnZSwgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMgPSBwbGFjZWhvbGRlcnM7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2UgPSBwbGFjZWhvbGRlclRvTWVzc2FnZTtcbiAgICAgICAgdGhpcy5tZWFuaW5nID0gbWVhbmluZztcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmN1c3RvbUlkID0gY3VzdG9tSWQ7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmN1c3RvbUlkO1xuICAgICAgICAvKiogVGhlIGlkcyB0byB1c2UgaWYgdGhlcmUgYXJlIG5vIGN1c3RvbSBpZCBhbmQgaWYgYGkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXRgIGlzIG5vdCBlbXB0eSAqL1xuICAgICAgICB0aGlzLmxlZ2FjeUlkcyA9IFtdO1xuICAgICAgICB0aGlzLm1lc3NhZ2VTdHJpbmcgPSBzZXJpYWxpemVNZXNzYWdlKHRoaXMubm9kZXMpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBmaWxlUGF0aDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5maWxlLnVybCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUgKyAxLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbDogbm9kZXNbMF0uc291cmNlU3Bhbi5zdGFydC5jb2wgKyAxLFxuICAgICAgICAgICAgICAgICAgICBlbmRMaW5lOiBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXS5zb3VyY2VTcGFuLmVuZC5saW5lICsgMSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sOiBub2Rlc1swXS5zb3VyY2VTcGFuLnN0YXJ0LmNvbCArIDFcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgVGV4dCQyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIFRPRE8odmljYik6IGRvIHdlIHJlYWxseSBuZWVkIHRoaXMgbm9kZSAodnMgYW4gYXJyYXkpID9cbmNsYXNzIENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Q29udGFpbmVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEljdSB7XG4gICAgY29uc3RydWN0b3IoZXhwcmVzc2lvbiwgdHlwZSwgY2FzZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0SWN1KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFRhZ1BsYWNlaG9sZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGF0dHJzLCBzdGFydE5hbWUsIGNsb3NlTmFtZSwgY2hpbGRyZW4sIGlzVm9pZCwgXG4gICAgLy8gVE9ETyBzb3VyY2VTcGFuIHNob3VsZCBjb3ZlciBhbGwgKHdlIG5lZWQgYSBzdGFydFNvdXJjZVNwYW4gYW5kIGVuZFNvdXJjZVNwYW4pXG4gICAgc291cmNlU3Bhbiwgc3RhcnRTb3VyY2VTcGFuLCBlbmRTb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuc3RhcnROYW1lID0gc3RhcnROYW1lO1xuICAgICAgICB0aGlzLmNsb3NlTmFtZSA9IGNsb3NlTmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmlzVm9pZCA9IGlzVm9pZDtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWdQbGFjZWhvbGRlcih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQbGFjZWhvbGRlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIG5hbWUsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UGxhY2Vob2xkZXIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgSWN1UGxhY2Vob2xkZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBuYW1lLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEljdVBsYWNlaG9sZGVyKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIENsb25lIHRoZSBBU1RcbmNsYXNzIENsb25lVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDIodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuLm1hcChuID0+IG4udmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IENvbnRhaW5lcihjaGlsZHJlbiwgY29udGFpbmVyLnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKGtleSA9PiBjYXNlc1trZXldID0gaWN1LmNhc2VzW2tleV0udmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICBjb25zdCBtc2cgPSBuZXcgSWN1KGljdS5leHByZXNzaW9uLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgbXNnLmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGljdS5leHByZXNzaW9uUGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAobiA9PiBuLnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWdQbGFjZWhvbGRlcihwaC50YWcsIHBoLmF0dHJzLCBwaC5zdGFydE5hbWUsIHBoLmNsb3NlTmFtZSwgY2hpbGRyZW4sIHBoLmlzVm9pZCwgcGguc291cmNlU3BhbiwgcGguc3RhcnRTb3VyY2VTcGFuLCBwaC5lbmRTb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKHBoLnZhbHVlLCBwaC5uYW1lLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG4vLyBWaXNpdCBhbGwgdGhlIG5vZGVzIHJlY3Vyc2l2ZWx5XG5jbGFzcyBSZWN1cnNlVmlzaXRvciB7XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICBpY3UuY2FzZXNba10udmlzaXQodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHBoLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7IH1cbn1cbi8qKlxuICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIHRoZSBMb2NhbGl6ZSBiYWNrdGljayBzdHJpbmcgZm9ybWF0IHRoYXQgd291bGQgYXBwZWFyIGluIGNvbXBpbGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZU5vZGVzKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBMb2NhbGl6ZU1lc3NhZ2VTdHJpbmdWaXNpdG9yKCk7XG4gICAgY29uc3Qgc3RyID0gbWVzc2FnZU5vZGVzLm1hcChuID0+IG4udmlzaXQodmlzaXRvcikpLmpvaW4oJycpO1xuICAgIHJldHVybiBzdHI7XG59XG5jbGFzcyBMb2NhbGl6ZU1lc3NhZ2VTdHJpbmdWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIGNvbnN0IHN0ckNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoKGspID0+IGAke2t9IHske2ljdS5jYXNlc1trXS52aXNpdCh0aGlzKX19YCk7XG4gICAgICAgIHJldHVybiBgeyR7aWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlcn0sICR7aWN1LnR5cGV9LCAke3N0ckNhc2VzLmpvaW4oJyAnKX19YDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBgeyQke3BoLnN0YXJ0TmFtZX19JHtjaGlsZHJlbn17JCR7cGguY2xvc2VOYW1lfX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiBgeyQke3BoLm5hbWV9fWA7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIGB7JCR7cGgubmFtZX19YDtcbiAgICB9XG59XG5cbmNsYXNzIFNlcmlhbGl6ZXIge1xuICAgIC8vIENyZWF0ZXMgYSBuYW1lIG1hcHBlciwgc2VlIGBQbGFjZWhvbGRlck1hcHBlcmBcbiAgICAvLyBSZXR1cm5pbmcgYG51bGxgIG1lYW5zIHRoYXQgbm8gbmFtZSBtYXBwaW5nIGlzIHVzZWQuXG4gICAgY3JlYXRlTmFtZU1hcHBlcihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKlxuICogQSBzaW1wbGUgbWFwcGVyIHRoYXQgdGFrZSBhIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBhbiBpbnRlcm5hbCBuYW1lIHRvIGEgcHVibGljIG5hbWVcbiAqL1xuY2xhc3MgU2ltcGxlUGxhY2Vob2xkZXJNYXBwZXIgZXh0ZW5kcyBSZWN1cnNlVmlzaXRvciB7XG4gICAgLy8gY3JlYXRlIGEgbWFwcGluZyBmcm9tIHRoZSBtZXNzYWdlXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbWFwTmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hcE5hbWUgPSBtYXBOYW1lO1xuICAgICAgICB0aGlzLmludGVybmFsVG9QdWJsaWMgPSB7fTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZCA9IHt9O1xuICAgICAgICB0aGlzLnB1YmxpY1RvSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxUb1B1YmxpYy5oYXNPd25Qcm9wZXJ0eShpbnRlcm5hbE5hbWUpID9cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIHRvSW50ZXJuYWxOYW1lKHB1YmxpY05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljVG9JbnRlcm5hbC5oYXNPd25Qcm9wZXJ0eShwdWJsaWNOYW1lKSA/IHRoaXMucHVibGljVG9JbnRlcm5hbFtwdWJsaWNOYW1lXSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLnN0YXJ0TmFtZSk7XG4gICAgICAgIHN1cGVyLnZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLmNsb3NlTmFtZSk7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdFBsYWNlaG9sZGVyTmFtZShwaC5uYW1lKTtcbiAgICB9XG4gICAgdmlzaXRJY3VQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0UGxhY2Vob2xkZXJOYW1lKHBoLm5hbWUpO1xuICAgIH1cbiAgICAvLyBYTUIgcGxhY2Vob2xkZXJzIGNvdWxkIG9ubHkgY29udGFpbnMgQS1aLCAwLTkgYW5kIF9cbiAgICB2aXNpdFBsYWNlaG9sZGVyTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICAgICAgaWYgKCFpbnRlcm5hbE5hbWUgfHwgdGhpcy5pbnRlcm5hbFRvUHVibGljLmhhc093blByb3BlcnR5KGludGVybmFsTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHVibGljTmFtZSA9IHRoaXMubWFwTmFtZShpbnRlcm5hbE5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wdWJsaWNUb0ludGVybmFsLmhhc093blByb3BlcnR5KHB1YmxpY05hbWUpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgWE1CIHdoZW4gaXQgaGFzIGFscmVhZHkgYmVlbiB1c2VkXG4gICAgICAgICAgICBjb25zdCBuZXh0SWQgPSB0aGlzLnB1YmxpY1RvTmV4dElkW3B1YmxpY05hbWVdO1xuICAgICAgICAgICAgdGhpcy5wdWJsaWNUb05leHRJZFtwdWJsaWNOYW1lXSA9IG5leHRJZCArIDE7XG4gICAgICAgICAgICBwdWJsaWNOYW1lID0gYCR7cHVibGljTmFtZX1fJHtuZXh0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVibGljVG9OZXh0SWRbcHVibGljTmFtZV0gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxUb1B1YmxpY1tpbnRlcm5hbE5hbWVdID0gcHVibGljTmFtZTtcbiAgICAgICAgdGhpcy5wdWJsaWNUb0ludGVybmFsW3B1YmxpY05hbWVdID0gaW50ZXJuYWxOYW1lO1xuICAgIH1cbn1cblxuY2xhc3MgX1Zpc2l0b3IkMiB7XG4gICAgdmlzaXRUYWcodGFnKSB7XG4gICAgICAgIGNvbnN0IHN0ckF0dHJzID0gdGhpcy5fc2VyaWFsaXplQXR0cmlidXRlcyh0YWcuYXR0cnMpO1xuICAgICAgICBpZiAodGFnLmNoaWxkcmVuLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYDwke3RhZy5uYW1lfSR7c3RyQXR0cnN9Lz5gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ckNoaWxkcmVuID0gdGFnLmNoaWxkcmVuLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgICAgICByZXR1cm4gYDwke3RhZy5uYW1lfSR7c3RyQXR0cnN9PiR7c3RyQ2hpbGRyZW4uam9pbignJyl9PC8ke3RhZy5uYW1lfT5gO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dC52YWx1ZTtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJhdGlvbihkZWNsKSB7XG4gICAgICAgIHJldHVybiBgPD94bWwke3RoaXMuX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoZGVjbC5hdHRycyl9ID8+YDtcbiAgICB9XG4gICAgX3NlcmlhbGl6ZUF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgICAgICAgY29uc3Qgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykubWFwKChuYW1lKSA9PiBgJHtuYW1lfT1cIiR7YXR0cnNbbmFtZV19XCJgKS5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBzdHJBdHRycy5sZW5ndGggPiAwID8gJyAnICsgc3RyQXR0cnMgOiAnJztcbiAgICB9XG4gICAgdmlzaXREb2N0eXBlKGRvY3R5cGUpIHtcbiAgICAgICAgcmV0dXJuIGA8IURPQ1RZUEUgJHtkb2N0eXBlLnJvb3RUYWd9IFtcXG4ke2RvY3R5cGUuZHRkfVxcbl0+YDtcbiAgICB9XG59XG5jb25zdCBfdmlzaXRvciA9IG5ldyBfVmlzaXRvciQyKCk7XG5mdW5jdGlvbiBzZXJpYWxpemUobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiBub2RlLnZpc2l0KF92aXNpdG9yKSkuam9pbignJyk7XG59XG5jbGFzcyBEZWNsYXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodW5lc2NhcGVkQXR0cnMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh1bmVzY2FwZWRBdHRycykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5hdHRyc1trXSA9IGVzY2FwZVhtbCh1bmVzY2FwZWRBdHRyc1trXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RGVjbGFyYXRpb24odGhpcyk7XG4gICAgfVxufVxuY2xhc3MgRG9jdHlwZSB7XG4gICAgY29uc3RydWN0b3Iocm9vdFRhZywgZHRkKSB7XG4gICAgICAgIHRoaXMucm9vdFRhZyA9IHJvb3RUYWc7XG4gICAgICAgIHRoaXMuZHRkID0gZHRkO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RG9jdHlwZSh0aGlzKTtcbiAgICB9XG59XG5jbGFzcyBUYWcge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHVuZXNjYXBlZEF0dHJzID0ge30sIGNoaWxkcmVuID0gW10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHVuZXNjYXBlZEF0dHJzKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF0dHJzW2tdID0gZXNjYXBlWG1sKHVuZXNjYXBlZEF0dHJzW2tdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRUYWcodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgVGV4dCQxIHtcbiAgICBjb25zdHJ1Y3Rvcih1bmVzY2FwZWRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZXNjYXBlWG1sKHVuZXNjYXBlZFZhbHVlKTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRleHQodGhpcyk7XG4gICAgfVxufVxuY2xhc3MgQ1IgZXh0ZW5kcyBUZXh0JDEge1xuICAgIGNvbnN0cnVjdG9yKHdzID0gMCkge1xuICAgICAgICBzdXBlcihgXFxuJHtuZXcgQXJyYXkod3MgKyAxKS5qb2luKCcgJyl9YCk7XG4gICAgfVxufVxuY29uc3QgX0VTQ0FQRURfQ0hBUlMgPSBbXG4gICAgWy8mL2csICcmYW1wOyddLFxuICAgIFsvXCIvZywgJyZxdW90OyddLFxuICAgIFsvJy9nLCAnJmFwb3M7J10sXG4gICAgWy88L2csICcmbHQ7J10sXG4gICAgWy8+L2csICcmZ3Q7J10sXG5dO1xuLy8gRXNjYXBlIGBfRVNDQVBFRF9DSEFSU2AgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gdGV4dCB3aXRoIGVuY29kZWQgZW50aXRpZXNcbmZ1bmN0aW9uIGVzY2FwZVhtbCh0ZXh0KSB7XG4gICAgcmV0dXJuIF9FU0NBUEVEX0NIQVJTLnJlZHVjZSgodGV4dCwgZW50cnkpID0+IHRleHQucmVwbGFjZShlbnRyeVswXSwgZW50cnlbMV0pLCB0ZXh0KTtcbn1cblxuY29uc3QgX01FU1NBR0VTX1RBRyA9ICdtZXNzYWdlYnVuZGxlJztcbmNvbnN0IF9NRVNTQUdFX1RBRyA9ICdtc2cnO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQzID0gJ3BoJztcbmNvbnN0IF9FWEFNUExFX1RBRyA9ICdleCc7XG5jb25zdCBfU09VUkNFX1RBRyQyID0gJ3NvdXJjZSc7XG5jb25zdCBfRE9DVFlQRSA9IGA8IUVMRU1FTlQgbWVzc2FnZWJ1bmRsZSAobXNnKSo+XG48IUFUVExJU1QgbWVzc2FnZWJ1bmRsZSBjbGFzcyBDREFUQSAjSU1QTElFRD5cblxuPCFFTEVNRU5UIG1zZyAoI1BDREFUQXxwaHxzb3VyY2UpKj5cbjwhQVRUTElTVCBtc2cgaWQgQ0RBVEEgI0lNUExJRUQ+XG48IUFUVExJU1QgbXNnIHNlcSBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgbmFtZSBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgZGVzYyBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgbWVhbmluZyBDREFUQSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgb2Jzb2xldGUgKG9ic29sZXRlKSAjSU1QTElFRD5cbjwhQVRUTElTVCBtc2cgeG1sOnNwYWNlIChkZWZhdWx0fHByZXNlcnZlKSBcImRlZmF1bHRcIj5cbjwhQVRUTElTVCBtc2cgaXNfaGlkZGVuIENEQVRBICNJTVBMSUVEPlxuXG48IUVMRU1FTlQgc291cmNlICgjUENEQVRBKT5cblxuPCFFTEVNRU5UIHBoICgjUENEQVRBfGV4KSo+XG48IUFUVExJU1QgcGggbmFtZSBDREFUQSAjUkVRVUlSRUQ+XG5cbjwhRUxFTUVOVCBleCAoI1BDREFUQSk+YDtcbmNsYXNzIFhtYiBleHRlbmRzIFNlcmlhbGl6ZXIge1xuICAgIHdyaXRlKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgZXhhbXBsZVZpc2l0b3IgPSBuZXcgRXhhbXBsZVZpc2l0b3IoKTtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBfVmlzaXRvciQxKCk7XG4gICAgICAgIGxldCByb290Tm9kZSA9IG5ldyBUYWcoX01FU1NBR0VTX1RBRyk7XG4gICAgICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHsgaWQ6IG1lc3NhZ2UuaWQgfTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbJ2Rlc2MnXSA9IG1lc3NhZ2UuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbJ21lYW5pbmcnXSA9IG1lc3NhZ2UubWVhbmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzb3VyY2VUYWdzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgc291cmNlVGFncy5wdXNoKG5ldyBUYWcoX1NPVVJDRV9UQUckMiwge30sIFtuZXcgVGV4dCQxKGAke3NvdXJjZS5maWxlUGF0aH06JHtzb3VyY2Uuc3RhcnRMaW5lfSR7c291cmNlLmVuZExpbmUgIT09IHNvdXJjZS5zdGFydExpbmUgPyAnLCcgKyBzb3VyY2UuZW5kTGluZSA6ICcnfWApXSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigyKSwgbmV3IFRhZyhfTUVTU0FHRV9UQUcsIGF0dHJzLCBbLi4uc291cmNlVGFncywgLi4udmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcyldKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByb290Tm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBDUigpKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksXG4gICAgICAgICAgICBuZXcgQ1IoKSxcbiAgICAgICAgICAgIG5ldyBEb2N0eXBlKF9NRVNTQUdFU19UQUcsIF9ET0NUWVBFKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICAgICAgZXhhbXBsZVZpc2l0b3IuYWRkRGVmYXVsdEV4YW1wbGVzKHJvb3ROb2RlKSxcbiAgICAgICAgICAgIG5ldyBDUigpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgbG9hZChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGlnZXN0KG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcihtZXNzYWdlLCB0b1B1YmxpY05hbWUpO1xuICAgIH1cbn1cbmNsYXNzIF9WaXNpdG9yJDEge1xuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IFRleHQkMSh0ZXh0LnZhbHVlKV07XG4gICAgfVxuICAgIHZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGRyZW4uZm9yRWFjaCgobm9kZSkgPT4gbm9kZXMucHVzaCguLi5ub2RlLnZpc2l0KHRoaXMpKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gW25ldyBUZXh0JDEoYHske2ljdS5leHByZXNzaW9uUGxhY2Vob2xkZXJ9LCAke2ljdS50eXBlfSwgYCldO1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMShgJHtjfSB7YCksIC4uLmljdS5jYXNlc1tjXS52aXNpdCh0aGlzKSwgbmV3IFRleHQkMShgfSBgKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYH1gKSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBzdGFydFRhZ0FzVGV4dCA9IG5ldyBUZXh0JDEoYDwke3BoLnRhZ30+YCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0RXggPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtzdGFydFRhZ0FzVGV4dF0pO1xuICAgICAgICAvLyBUQyByZXF1aXJlcyBQSCB0byBoYXZlIGEgbm9uIGVtcHR5IEVYLCBhbmQgdXNlcyB0aGUgdGV4dCBub2RlIHRvIHNob3cgdGhlIFwib3JpZ2luYWxcIiB2YWx1ZS5cbiAgICAgICAgY29uc3Qgc3RhcnRUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQzLCB7IG5hbWU6IHBoLnN0YXJ0TmFtZSB9LCBbc3RhcnRFeCwgc3RhcnRUYWdBc1RleHRdKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgLy8gdm9pZCB0YWdzIGhhdmUgbm8gY2hpbGRyZW4gbm9yIGNsb3NpbmcgdGFnc1xuICAgICAgICAgICAgcmV0dXJuIFtzdGFydFRhZ1BoXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZVRhZ0FzVGV4dCA9IG5ldyBUZXh0JDEoYDwvJHtwaC50YWd9PmApO1xuICAgICAgICBjb25zdCBjbG9zZUV4ID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbY2xvc2VUYWdBc1RleHRdKTtcbiAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgIGNvbnN0IGNsb3NlVGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMywgeyBuYW1lOiBwaC5jbG9zZU5hbWUgfSwgW2Nsb3NlRXgsIGNsb3NlVGFnQXNUZXh0XSk7XG4gICAgICAgIHJldHVybiBbc3RhcnRUYWdQaCwgLi4udGhpcy5zZXJpYWxpemUocGguY2hpbGRyZW4pLCBjbG9zZVRhZ1BoXTtcbiAgICB9XG4gICAgdmlzaXRQbGFjZWhvbGRlcihwaCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0aW9uQXNUZXh0ID0gbmV3IFRleHQkMShge3ske3BoLnZhbHVlfX19YCk7XG4gICAgICAgIC8vIEV4YW1wbGUgdGFnIG5lZWRzIHRvIGJlIG5vdC1lbXB0eSBmb3IgVEMuXG4gICAgICAgIGNvbnN0IGV4VGFnID0gbmV3IFRhZyhfRVhBTVBMRV9UQUcsIHt9LCBbaW50ZXJwb2xhdGlvbkFzVGV4dF0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gVEMgcmVxdWlyZXMgUEggdG8gaGF2ZSBhIG5vbiBlbXB0eSBFWCwgYW5kIHVzZXMgdGhlIHRleHQgbm9kZSB0byBzaG93IHRoZSBcIm9yaWdpbmFsXCIgdmFsdWUuXG4gICAgICAgICAgICBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMywgeyBuYW1lOiBwaC5uYW1lIH0sIFtleFRhZywgaW50ZXJwb2xhdGlvbkFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaWN1RXhwcmVzc2lvbiA9IHBoLnZhbHVlLmV4cHJlc3Npb247XG4gICAgICAgIGNvbnN0IGljdVR5cGUgPSBwaC52YWx1ZS50eXBlO1xuICAgICAgICBjb25zdCBpY3VDYXNlcyA9IE9iamVjdC5rZXlzKHBoLnZhbHVlLmNhc2VzKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZSArICcgey4uLn0nKS5qb2luKCcgJyk7XG4gICAgICAgIGNvbnN0IGljdUFzVGV4dCA9IG5ldyBUZXh0JDEoYHske2ljdUV4cHJlc3Npb259LCAke2ljdVR5cGV9LCAke2ljdUNhc2VzfX1gKTtcbiAgICAgICAgY29uc3QgZXhUYWcgPSBuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtpY3VBc1RleHRdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFRDIHJlcXVpcmVzIFBIIHRvIGhhdmUgYSBub24gZW1wdHkgRVgsIGFuZCB1c2VzIHRoZSB0ZXh0IG5vZGUgdG8gc2hvdyB0aGUgXCJvcmlnaW5hbFwiIHZhbHVlLlxuICAgICAgICAgICAgbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDMsIHsgbmFtZTogcGgubmFtZSB9LCBbZXhUYWcsIGljdUFzVGV4dF0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KC4uLm5vZGVzLm1hcChub2RlID0+IG5vZGUudmlzaXQodGhpcykpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkaWdlc3QobWVzc2FnZSkge1xuICAgIHJldHVybiBkZWNpbWFsRGlnZXN0KG1lc3NhZ2UpO1xufVxuLy8gVEMgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIG5vbi1lbXB0eSBleGFtcGxlIG9uIHBsYWNlaG9sZGVyc1xuY2xhc3MgRXhhbXBsZVZpc2l0b3Ige1xuICAgIGFkZERlZmF1bHRFeGFtcGxlcyhub2RlKSB7XG4gICAgICAgIG5vZGUudmlzaXQodGhpcyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB2aXNpdFRhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDMpIHtcbiAgICAgICAgICAgIGlmICghdGFnLmNoaWxkcmVuIHx8IHRhZy5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4VGV4dCA9IG5ldyBUZXh0JDEodGFnLmF0dHJzWyduYW1lJ10gfHwgJy4uLicpO1xuICAgICAgICAgICAgICAgIHRhZy5jaGlsZHJlbiA9IFtuZXcgVGFnKF9FWEFNUExFX1RBRywge30sIFtleFRleHRdKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFnLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0YWcuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdERlY2xhcmF0aW9uKGRlY2wpIHsgfVxuICAgIHZpc2l0RG9jdHlwZShkb2N0eXBlKSB7IH1cbn1cbi8vIFhNQi9YVEIgcGxhY2Vob2xkZXJzIGNhbiBvbmx5IGNvbnRhaW4gQS1aLCAwLTkgYW5kIF9cbmZ1bmN0aW9uIHRvUHVibGljTmFtZShpbnRlcm5hbE5hbWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWxOYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvW15BLVowLTlfXS9nLCAnXycpO1xufVxuXG4vKiBDbG9zdXJlIHZhcmlhYmxlcyBob2xkaW5nIG1lc3NhZ2VzIG11c3QgYmUgbmFtZWQgYE1TR19bQS1aMC05XStgICovXG5jb25zdCBDTE9TVVJFX1RSQU5TTEFUSU9OX1ZBUl9QUkVGSVggPSAnTVNHXyc7XG4vKipcbiAqIFByZWZpeCBmb3Igbm9uLWBnb29nLmdldE1zZ2AgaTE4bi1yZWxhdGVkIHZhcnMuXG4gKiBOb3RlOiB0aGUgcHJlZml4IHVzZXMgbG93ZXJjYXNlIGNoYXJhY3RlcnMgaW50ZW50aW9uYWxseSBkdWUgdG8gYSBDbG9zdXJlIGJlaGF2aW9yIHRoYXRcbiAqIGNvbnNpZGVycyB2YXJpYWJsZXMgbGlrZSBgSTE4Tl8wYCBhcyBjb25zdGFudHMgYW5kIHRocm93cyBhbiBlcnJvciB3aGVuIHRoZWlyIHZhbHVlIGNoYW5nZXMuXG4gKi9cbmNvbnN0IFRSQU5TTEFUSU9OX1ZBUl9QUkVGSVggPSAnaTE4bl8nO1xuLyoqIE5hbWUgb2YgdGhlIGkxOG4gYXR0cmlidXRlcyAqKi9cbmNvbnN0IEkxOE5fQVRUUiA9ICdpMThuJztcbmNvbnN0IEkxOE5fQVRUUl9QUkVGSVggPSAnaTE4bi0nO1xuLyoqIFByZWZpeCBvZiB2YXIgZXhwcmVzc2lvbnMgdXNlZCBpbiBJQ1VzICovXG5jb25zdCBJMThOX0lDVV9WQVJfUFJFRklYID0gJ1ZBUl8nO1xuLyoqIFByZWZpeCBvZiBJQ1UgZXhwcmVzc2lvbnMgZm9yIHBvc3QgcHJvY2Vzc2luZyAqL1xuY29uc3QgSTE4Tl9JQ1VfTUFQUElOR19QUkVGSVggPSAnSTE4Tl9FWFBfJztcbi8qKiBQbGFjZWhvbGRlciB3cmFwcGVyIGZvciBpMThuIGV4cHJlc3Npb25zICoqL1xuY29uc3QgSTE4Tl9QTEFDRUhPTERFUl9TWU1CT0wgPSAn77+9JztcbmZ1bmN0aW9uIGlzSTE4bkF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT09IEkxOE5fQVRUUiB8fCBuYW1lLnN0YXJ0c1dpdGgoSTE4Tl9BVFRSX1BSRUZJWCk7XG59XG5mdW5jdGlvbiBpc0kxOG5Sb290Tm9kZShtZXRhKSB7XG4gICAgcmV0dXJuIG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlO1xufVxuZnVuY3Rpb24gaXNTaW5nbGVJMThuSWN1KG1ldGEpIHtcbiAgICByZXR1cm4gaXNJMThuUm9vdE5vZGUobWV0YSkgJiYgbWV0YS5ub2Rlcy5sZW5ndGggPT09IDEgJiYgbWV0YS5ub2Rlc1swXSBpbnN0YW5jZW9mIEljdTtcbn1cbmZ1bmN0aW9uIGhhc0kxOG5NZXRhKG5vZGUpIHtcbiAgICByZXR1cm4gISFub2RlLmkxOG47XG59XG5mdW5jdGlvbiBoYXNJMThuQXR0cnMoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmF0dHJzLnNvbWUoKGF0dHIpID0+IGlzSTE4bkF0dHJpYnV0ZShhdHRyLm5hbWUpKTtcbn1cbmZ1bmN0aW9uIGljdUZyb21JMThuTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2Uubm9kZXNbMF07XG59XG5mdW5jdGlvbiB3cmFwSTE4blBsYWNlaG9sZGVyKGNvbnRlbnQsIGNvbnRleHRJZCA9IDApIHtcbiAgICBjb25zdCBibG9ja0lkID0gY29udGV4dElkID4gMCA/IGA6JHtjb250ZXh0SWR9YCA6ICcnO1xuICAgIHJldHVybiBgJHtJMThOX1BMQUNFSE9MREVSX1NZTUJPTH0ke2NvbnRlbnR9JHtibG9ja0lkfSR7STE4Tl9QTEFDRUhPTERFUl9TWU1CT0x9YDtcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlSTE4bkJvdW5kU3RyaW5nKHN0cmluZ3MsIGJpbmRpbmdTdGFydEluZGV4ID0gMCwgY29udGV4dElkID0gMCkge1xuICAgIGlmICghc3RyaW5ncy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBsZXQgYWNjID0gJyc7XG4gICAgY29uc3QgbGFzdElkeCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJZHg7IGkrKykge1xuICAgICAgICBhY2MgKz0gYCR7c3RyaW5nc1tpXX0ke3dyYXBJMThuUGxhY2Vob2xkZXIoYmluZGluZ1N0YXJ0SW5kZXggKyBpLCBjb250ZXh0SWQpfWA7XG4gICAgfVxuICAgIGFjYyArPSBzdHJpbmdzW2xhc3RJZHhdO1xuICAgIHJldHVybiBhY2M7XG59XG5mdW5jdGlvbiBnZXRTZXFOdW1iZXJHZW5lcmF0b3Ioc3RhcnRzQXQgPSAwKSB7XG4gICAgbGV0IGN1cnJlbnQgPSBzdGFydHNBdDtcbiAgICByZXR1cm4gKCkgPT4gY3VycmVudCsrO1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXJzVG9QYXJhbXMocGxhY2Vob2xkZXJzKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgcGxhY2Vob2xkZXJzLmZvckVhY2goKHZhbHVlcywga2V5KSA9PiB7XG4gICAgICAgIHBhcmFtc1trZXldID0gbGl0ZXJhbCh2YWx1ZXMubGVuZ3RoID4gMSA/IGBbJHt2YWx1ZXMuam9pbignfCcpfV1gIDogdmFsdWVzWzBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gdXBkYXRlUGxhY2Vob2xkZXJNYXAobWFwLCBuYW1lLCAuLi52YWx1ZXMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gbWFwLmdldChuYW1lKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2goLi4udmFsdWVzKTtcbiAgICBtYXAuc2V0KG5hbWUsIGN1cnJlbnQpO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVCb3VuZFRleHRQbGFjZWhvbGRlcnMobWV0YSwgYmluZGluZ1N0YXJ0SW5kZXggPSAwLCBjb250ZXh0SWQgPSAwKSB7XG4gICAgY29uc3Qgc3RhcnRJZHggPSBiaW5kaW5nU3RhcnRJbmRleDtcbiAgICBjb25zdCBwbGFjZWhvbGRlcnMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgbm9kZSA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlID8gbWV0YS5ub2Rlcy5maW5kKG5vZGUgPT4gbm9kZSBpbnN0YW5jZW9mIENvbnRhaW5lcikgOiBtZXRhO1xuICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGVcbiAgICAgICAgICAgIC5jaGlsZHJlblxuICAgICAgICAgICAgLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkIGluc3RhbmNlb2YgUGxhY2Vob2xkZXIpXG4gICAgICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHdyYXBJMThuUGxhY2Vob2xkZXIoc3RhcnRJZHggKyBpZHgsIGNvbnRleHRJZCk7XG4gICAgICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcChwbGFjZWhvbGRlcnMsIGNoaWxkLm5hbWUsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVycztcbn1cbi8qKlxuICogRm9ybWF0IHRoZSBwbGFjZWhvbGRlciBuYW1lcyBpbiBhIG1hcCBvZiBwbGFjZWhvbGRlcnMgdG8gZXhwcmVzc2lvbnMuXG4gKlxuICogVGhlIHBsYWNlaG9sZGVyIG5hbWVzIGFyZSBjb252ZXJ0ZWQgZnJvbSBcImludGVybmFsXCIgZm9ybWF0IChlLmcuIGBTVEFSVF9UQUdfRElWXzFgKSB0byBcImV4dGVybmFsXCJcbiAqIGZvcm1hdCAoZS5nLiBgc3RhcnRUYWdEaXZfMWApLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgQSBtYXAgb2YgcGxhY2Vob2xkZXIgbmFtZXMgdG8gZXhwcmVzc2lvbnMuXG4gKiBAcGFyYW0gdXNlQ2FtZWxDYXNlIHdoZXRoZXIgdG8gY2FtZWxDYXNlIHRoZSBwbGFjZWhvbGRlciBuYW1lIHdoZW4gZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIEEgbmV3IG1hcCBvZiBmb3JtYXR0ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gZXhwcmVzc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWVzSW5NYXAocGFyYW1zID0ge30sIHVzZUNhbWVsQ2FzZSkge1xuICAgIGNvbnN0IF9wYXJhbXMgPSB7fTtcbiAgICBpZiAocGFyYW1zICYmIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChrZXkgPT4gX3BhcmFtc1tmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lKGtleSwgdXNlQ2FtZWxDYXNlKV0gPSBwYXJhbXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBfcGFyYW1zO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBpbnRlcm5hbCBwbGFjZWhvbGRlciBuYW1lcyB0byBwdWJsaWMtZmFjaW5nIGZvcm1hdFxuICogKGZvciBleGFtcGxlIHRvIHVzZSBpbiBnb29nLmdldE1zZyBjYWxsKS5cbiAqIEV4YW1wbGU6IGBTVEFSVF9UQUdfRElWXzFgIGlzIGNvbnZlcnRlZCB0byBgc3RhcnRUYWdEaXZfMWAuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIHBsYWNlaG9sZGVyIG5hbWUgdGhhdCBzaG91bGQgYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgcGxhY2Vob2xkZXIgbmFtZVxuICovXG5mdW5jdGlvbiBmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lKG5hbWUsIHVzZUNhbWVsQ2FzZSA9IHRydWUpIHtcbiAgICBjb25zdCBwdWJsaWNOYW1lID0gdG9QdWJsaWNOYW1lKG5hbWUpO1xuICAgIGlmICghdXNlQ2FtZWxDYXNlKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNOYW1lO1xuICAgIH1cbiAgICBjb25zdCBjaHVua3MgPSBwdWJsaWNOYW1lLnNwbGl0KCdfJyk7XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgbm8gXCJfXCIgZm91bmQgLSBqdXN0IGxvd2VyY2FzZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgbGV0IHBvc3RmaXg7XG4gICAgLy8gZWplY3QgbGFzdCBlbGVtZW50IGlmIGl0J3MgYSBudW1iZXJcbiAgICBpZiAoL15cXGQrJC8udGVzdChjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICBwb3N0Zml4ID0gY2h1bmtzLnBvcCgpO1xuICAgIH1cbiAgICBsZXQgcmF3ID0gY2h1bmtzLnNoaWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICByYXcgKz0gY2h1bmtzLm1hcChjID0+IGMuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCkpLmpvaW4oJycpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdGZpeCA/IGAke3Jhd31fJHtwb3N0Zml4fWAgOiByYXc7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHByZWZpeCBmb3IgdHJhbnNsYXRpb24gY29uc3QgbmFtZS5cbiAqXG4gKiBAcGFyYW0gZXh0cmEgQWRkaXRpb25hbCBsb2NhbCBwcmVmaXggdGhhdCBzaG91bGQgYmUgaW5qZWN0ZWQgaW50byB0cmFuc2xhdGlvbiB2YXIgbmFtZVxuICogQHJldHVybnMgQ29tcGxldGUgdHJhbnNsYXRpb24gY29uc3QgcHJlZml4XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uQ29uc3RQcmVmaXgoZXh0cmEpIHtcbiAgICByZXR1cm4gYCR7Q0xPU1VSRV9UUkFOU0xBVElPTl9WQVJfUFJFRklYfSR7ZXh0cmF9YC50b1VwcGVyQ2FzZSgpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBBU1QgdG8gZGVjbGFyZSBhIHZhcmlhYmxlLiBFLmcuIGB2YXIgSTE4Tl8xO2AuXG4gKiBAcGFyYW0gdmFyaWFibGUgdGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGRlY2xhcmUuXG4gKi9cbmZ1bmN0aW9uIGRlY2xhcmVJMThuVmFyaWFibGUodmFyaWFibGUpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmVWYXJTdG10KHZhcmlhYmxlLm5hbWUsIHVuZGVmaW5lZCwgSU5GRVJSRURfVFlQRSwgdW5kZWZpbmVkLCB2YXJpYWJsZS5zb3VyY2VTcGFuKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBvYmplY3Qga2V5IGNvbnRhaW5zIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycywgdGh1cyB0aGUga2V5IHNob3VsZCBiZSB3cmFwcGVkIGluXG4gKiBxdW90ZXMuIE5vdGU6IHdlIGRvIG5vdCB3cmFwIGFsbCBrZXlzIGludG8gcXVvdGVzLCBhcyBpdCBtYXkgaGF2ZSBpbXBhY3Qgb24gbWluaWZpY2F0aW9uIGFuZCBtYXlcbiAqIGJvdCB3b3JrIGluIHNvbWUgY2FzZXMgd2hlbiBvYmplY3Qga2V5cyBhcmUgbWFuZ2xlZCBieSBtaW5pZmllci5cbiAqXG4gKiBUT0RPKEZXLTExMzYpOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLCB3ZSBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgb2Ygd29ya2luZyB3aXRoXG4gKiBpbnB1dHMgdGhhdCBjb250YWluIHBvdGVudGlhbGx5IHVuc2FmZSBjaGFycy5cbiAqL1xuY29uc3QgVU5TQUZFX09CSkVDVF9LRVlfTkFNRV9SRUdFWFAgPSAvWy0uXS87XG4vKiogTmFtZSBvZiB0aGUgdGVtcG9yYXJ5IHRvIHVzZSBkdXJpbmcgZGF0YSBiaW5kaW5nICovXG5jb25zdCBURU1QT1JBUllfTkFNRSA9ICdfdCc7XG4vKiogTmFtZSBvZiB0aGUgY29udGV4dCBwYXJhbWV0ZXIgcGFzc2VkIGludG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiAqL1xuY29uc3QgQ09OVEVYVF9OQU1FID0gJ2N0eCc7XG4vKiogTmFtZSBvZiB0aGUgUmVuZGVyRmxhZyBwYXNzZWQgaW50byBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG5jb25zdCBSRU5ERVJfRkxBR1MgPSAncmYnO1xuLyoqIFRoZSBwcmVmaXggcmVmZXJlbmNlIHZhcmlhYmxlcyAqL1xuY29uc3QgUkVGRVJFTkNFX1BSRUZJWCA9ICdfcic7XG4vKiogVGhlIG5hbWUgb2YgdGhlIGltcGxpY2l0IGNvbnRleHQgcmVmZXJlbmNlICovXG5jb25zdCBJTVBMSUNJVF9SRUZFUkVOQ0UgPSAnJGltcGxpY2l0Jztcbi8qKiBOb24gYmluZGFibGUgYXR0cmlidXRlIG5hbWUgKiovXG5jb25zdCBOT05fQklOREFCTEVfQVRUUiA9ICduZ05vbkJpbmRhYmxlJztcbi8qKiBOYW1lIGZvciB0aGUgdmFyaWFibGUga2VlcGluZyB0cmFjayBvZiB0aGUgY29udGV4dCByZXR1cm5lZCBieSBgybXJtXJlc3RvcmVWaWV3YC4gKi9cbmNvbnN0IFJFU1RPUkVEX1ZJRVdfQ09OVEVYVF9OQU1FID0gJ3Jlc3RvcmVkQ3R4Jztcbi8qKlxuICogTWF4aW11bSBsZW5ndGggb2YgYSBzaW5nbGUgaW5zdHJ1Y3Rpb24gY2hhaW4uIEJlY2F1c2Ugb3VyIG91dHB1dCBBU1QgdXNlcyByZWN1cnNpb24sIHdlJ3JlXG4gKiBsaW1pdGVkIGluIGhvdyBtYW55IGV4cHJlc3Npb25zIHdlIGNhbiBuZXN0IGJlZm9yZSB3ZSByZWFjaCB0aGUgY2FsbCBzdGFjayBsaW1pdC4gVGhpc1xuICogbGVuZ3RoIGlzIHNldCB2ZXJ5IGNvbnNlcnZhdGl2ZWx5IGluIG9yZGVyIHRvIHJlZHVjZSB0aGUgY2hhbmNlIG9mIHByb2JsZW1zLlxuICovXG5jb25zdCBNQVhfQ0hBSU5fTEVOR1RIID0gNTAwO1xuLyoqIEluc3RydWN0aW9ucyB0aGF0IHN1cHBvcnQgY2hhaW5pbmcuICovXG5jb25zdCBDSEFJTkFCTEVfSU5TVFJVQ1RJT05TID0gbmV3IFNldChbXG4gICAgSWRlbnRpZmllcnMuZWxlbWVudCxcbiAgICBJZGVudGlmaWVycy5lbGVtZW50U3RhcnQsXG4gICAgSWRlbnRpZmllcnMuZWxlbWVudEVuZCxcbiAgICBJZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyLFxuICAgIElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJTdGFydCxcbiAgICBJZGVudGlmaWVycy5lbGVtZW50Q29udGFpbmVyRW5kLFxuICAgIElkZW50aWZpZXJzLmkxOG5FeHAsXG4gICAgSWRlbnRpZmllcnMubGlzdGVuZXIsXG4gICAgSWRlbnRpZmllcnMuY2xhc3NQcm9wLFxuICAgIElkZW50aWZpZXJzLnN5bnRoZXRpY0hvc3RMaXN0ZW5lcixcbiAgICBJZGVudGlmaWVycy5ob3N0UHJvcGVydHksXG4gICAgSWRlbnRpZmllcnMuc3ludGhldGljSG9zdFByb3BlcnR5LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUxLFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUyLFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUzLFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU0LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU1LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU2LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU3LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU4LFxuICAgIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGVWLFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZSxcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTEsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUyLFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlMyxcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTQsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU1LFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNixcbiAgICBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTcsXG4gICAgSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU4LFxuICAgIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlVixcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3AsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGUxLFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlMixcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTMsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU0LFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNSxcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTYsXG4gICAgSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU3LFxuICAgIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlOCxcbiAgICBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZVYsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlLFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTEsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMixcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUzLFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTQsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNSxcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU2LFxuICAgIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTcsXG4gICAgSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlOCxcbiAgICBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGVWLFxuXSk7XG4vKiogR2VuZXJhdGVzIGEgY2FsbCB0byBhIHNpbmdsZSBpbnN0cnVjdGlvbi4gKi9cbmZ1bmN0aW9uIGludm9rZUluc3RydWN0aW9uKHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIocmVmZXJlbmNlLCBudWxsLCBzcGFuKS5jYWxsRm4ocGFyYW1zLCBzcGFuKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhbGxvY2F0b3IgZm9yIGEgdGVtcG9yYXJ5IHZhcmlhYmxlLlxuICpcbiAqIEEgdmFyaWFibGUgZGVjbGFyYXRpb24gaXMgYWRkZWQgdG8gdGhlIHN0YXRlbWVudHMgdGhlIGZpcnN0IHRpbWUgdGhlIGFsbG9jYXRvciBpcyBpbnZva2VkLlxuICovXG5mdW5jdGlvbiB0ZW1wb3JhcnlBbGxvY2F0b3Ioc3RhdGVtZW50cywgbmFtZSkge1xuICAgIGxldCB0ZW1wID0gbnVsbDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgRGVjbGFyZVZhclN0bXQoVEVNUE9SQVJZX05BTUUsIHVuZGVmaW5lZCwgRFlOQU1JQ19UWVBFKSk7XG4gICAgICAgICAgICB0ZW1wID0gdmFyaWFibGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludmFsaWQoYXJnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiBWaXNpdG9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBkb2Vzbid0IGhhbmRsZSAke2FyZy5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuZnVuY3Rpb24gYXNMaXRlcmFsKHZhbHVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsQXJyKHZhbHVlLm1hcChhc0xpdGVyYWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpdGVyYWwodmFsdWUsIElORkVSUkVEX1RZUEUpO1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwoa2V5cywga2VlcERlY2xhcmVkKSB7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGtleXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG1hcFRvRXhwcmVzc2lvbihrZXlzLCBrZWVwRGVjbGFyZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hcFRvRXhwcmVzc2lvbihtYXAsIGtlZXBEZWNsYXJlZCkge1xuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG1hcCkubWFwKGtleSA9PiB7XG4gICAgICAgIC8vIGNhbm9uaWNhbCBzeW50YXg6IGBkaXJQcm9wOiBwdWJsaWNQcm9wYFxuICAgICAgICBjb25zdCB2YWx1ZSA9IG1hcFtrZXldO1xuICAgICAgICBsZXQgZGVjbGFyZWROYW1lO1xuICAgICAgICBsZXQgcHVibGljTmFtZTtcbiAgICAgICAgbGV0IG1pbmlmaWVkTmFtZTtcbiAgICAgICAgbGV0IG5lZWRzRGVjbGFyZWROYW1lO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIFtwdWJsaWNOYW1lLCBkZWNsYXJlZE5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBtaW5pZmllZE5hbWUgPSBrZXk7XG4gICAgICAgICAgICBuZWVkc0RlY2xhcmVkTmFtZSA9IHB1YmxpY05hbWUgIT09IGRlY2xhcmVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbmlmaWVkTmFtZSA9IGRlY2xhcmVkTmFtZSA9IGtleTtcbiAgICAgICAgICAgIHB1YmxpY05hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIG5lZWRzRGVjbGFyZWROYW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogbWluaWZpZWROYW1lLFxuICAgICAgICAgICAgLy8gcHV0IHF1b3RlcyBhcm91bmQga2V5cyB0aGF0IGNvbnRhaW4gcG90ZW50aWFsbHkgdW5zYWZlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgIHF1b3RlZDogVU5TQUZFX09CSkVDVF9LRVlfTkFNRV9SRUdFWFAudGVzdChtaW5pZmllZE5hbWUpLFxuICAgICAgICAgICAgdmFsdWU6IChrZWVwRGVjbGFyZWQgJiYgbmVlZHNEZWNsYXJlZE5hbWUpID9cbiAgICAgICAgICAgICAgICBsaXRlcmFsQXJyKFthc0xpdGVyYWwocHVibGljTmFtZSksIGFzTGl0ZXJhbChkZWNsYXJlZE5hbWUpXSkgOlxuICAgICAgICAgICAgICAgIGFzTGl0ZXJhbChwdWJsaWNOYW1lKVxuICAgICAgICB9O1xuICAgIH0pKTtcbn1cbi8qKlxuICogIFJlbW92ZSB0cmFpbGluZyBudWxsIG5vZGVzIGFzIHRoZXkgYXJlIGltcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpIHtcbiAgICB3aGlsZSAoaXNOdWxsKHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcGFyYW1ldGVycy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBnZXRRdWVyeVByZWRpY2F0ZShxdWVyeSwgY29uc3RhbnRQb29sKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnkucHJlZGljYXRlKSkge1xuICAgICAgICBsZXQgcHJlZGljYXRlID0gW107XG4gICAgICAgIHF1ZXJ5LnByZWRpY2F0ZS5mb3JFYWNoKChzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgLy8gRWFjaCBpdGVtIGluIHByZWRpY2F0ZXMgYXJyYXkgbWF5IGNvbnRhaW4gc3RyaW5ncyB3aXRoIGNvbW1hLXNlcGFyYXRlZCByZWZzXG4gICAgICAgICAgICAvLyAoZm9yIGV4LiAncmVmLCByZWYxLCAuLi4sIHJlZk4nKSwgdGh1cyB3ZSBleHRyYWN0IGluZGl2aWR1YWwgcmVmcyBhbmQgc3RvcmUgdGhlbVxuICAgICAgICAgICAgLy8gYXMgc2VwYXJhdGUgYXJyYXkgZW50aXRpZXNcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHNlbGVjdG9yLnNwbGl0KCcsJykubWFwKHRva2VuID0+IGxpdGVyYWwodG9rZW4udHJpbSgpKSk7XG4gICAgICAgICAgICBwcmVkaWNhdGUucHVzaCguLi5zZWxlY3RvcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnN0YW50UG9vbC5nZXRDb25zdExpdGVyYWwobGl0ZXJhbEFycihwcmVkaWNhdGUpLCB0cnVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRoZSBvcmlnaW5hbCBwcmVkaWNhdGUgbWF5IGhhdmUgYmVlbiB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAgY2FsbC5cbiAgICAgICAgc3dpdGNoIChxdWVyeS5wcmVkaWNhdGUuZm9yd2FyZFJlZikge1xuICAgICAgICAgICAgY2FzZSAwIC8qIEZvcndhcmRSZWZIYW5kbGluZy5Ob25lICovOlxuICAgICAgICAgICAgY2FzZSAyIC8qIEZvcndhcmRSZWZIYW5kbGluZy5VbndyYXBwZWQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5LnByZWRpY2F0ZS5leHByZXNzaW9uO1xuICAgICAgICAgICAgY2FzZSAxIC8qIEZvcndhcmRSZWZIYW5kbGluZy5XcmFwcGVkICovOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlc29sdmVGb3J3YXJkUmVmKS5jYWxsRm4oW3F1ZXJ5LnByZWRpY2F0ZS5leHByZXNzaW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gZm9yIGFuIG9iamVjdCBsaXRlcmFsIHVzZWQgZHVyaW5nIGNvZGVnZW4gb2YgZGVmaW5pdGlvbiBvYmplY3RzLiBUaGUgZ2VuZXJpY1xuICogdHlwZSBgVGAgYWxsb3dzIHRvIHJlZmVyZW5jZSBhIGRvY3VtZW50ZWQgdHlwZSBvZiB0aGUgZ2VuZXJhdGVkIHN0cnVjdHVyZSwgc3VjaCB0aGF0IHRoZVxuICogcHJvcGVydHkgbmFtZXMgdGhhdCBhcmUgc2V0IGNhbiBiZSByZXNvbHZlZCB0byB0aGVpciBkb2N1bWVudGVkIGRlY2xhcmF0aW9uLlxuICovXG5jbGFzcyBEZWZpbml0aW9uTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvTGl0ZXJhbE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxNYXAodGhpcy52YWx1ZXMpO1xuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdCBhIG1hcCBvZiBwcm9wZXJ0aWVzIHRvIHZhbHVlcyBmb3IgYSBnaXZlbiBlbGVtZW50IG9yIHRlbXBsYXRlIG5vZGUsIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiBieSB0aGUgZGlyZWN0aXZlIG1hdGNoaW5nIG1hY2hpbmVyeS5cbiAqXG4gKiBAcGFyYW0gZWxPclRwbCB0aGUgZWxlbWVudCBvciB0ZW1wbGF0ZSBpbiBxdWVzdGlvblxuICogQHJldHVybiBhbiBvYmplY3Qgc2V0IHVwIGZvciBkaXJlY3RpdmUgbWF0Y2hpbmcuIEZvciBhdHRyaWJ1dGVzIG9uIHRoZSBlbGVtZW50L3RlbXBsYXRlLCB0aGlzXG4gKiBvYmplY3QgbWFwcyBhIHByb3BlcnR5IG5hbWUgdG8gaXRzIChzdGF0aWMpIHZhbHVlLiBGb3IgYW55IGJpbmRpbmdzLCB0aGlzIG1hcCBzaW1wbHkgbWFwcyB0aGVcbiAqIHByb3BlcnR5IG5hbWUgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRBdHRyc0ZvckRpcmVjdGl2ZU1hdGNoaW5nKGVsT3JUcGwpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzTWFwID0ge307XG4gICAgaWYgKGVsT3JUcGwgaW5zdGFuY2VvZiBUZW1wbGF0ZSAmJiBlbE9yVHBsLnRhZ05hbWUgIT09ICduZy10ZW1wbGF0ZScpIHtcbiAgICAgICAgZWxPclRwbC50ZW1wbGF0ZUF0dHJzLmZvckVhY2goYSA9PiBhdHRyaWJ1dGVzTWFwW2EubmFtZV0gPSAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbE9yVHBsLmF0dHJpYnV0ZXMuZm9yRWFjaChhID0+IHtcbiAgICAgICAgICAgIGlmICghaXNJMThuQXR0cmlidXRlKGEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzTWFwW2EubmFtZV0gPSBhLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWxPclRwbC5pbnB1dHMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNNYXBbaS5uYW1lXSA9ICcnO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxPclRwbC5vdXRwdXRzLmZvckVhY2gobyA9PiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzTWFwW28ubmFtZV0gPSAnJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGVzTWFwO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkIHRvIGJlIHBhc3NlZCB0byBhIGdlbmVyYXRlZCBpbnN0cnVjdGlvbiBpbiB0aGUgY2FzZSBvZlxuICogaW50ZXJwb2xhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBpbnRlcnBvbGF0aW9uIGFzdFxuICovXG5mdW5jdGlvbiBnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSB7XG4gICAgY29uc3QgeyBleHByZXNzaW9ucywgc3RyaW5ncyB9ID0gaW50ZXJwb2xhdGlvbjtcbiAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAxICYmIHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnRlcnBvbGF0aW9uIGhhcyBvbmUgaW50ZXJwb2xhdGVkIHZhbHVlLCBidXQgdGhlIHByZWZpeCBhbmQgc3VmZml4IGFyZSBib3RoIGVtcHR5XG4gICAgICAgIC8vIHN0cmluZ3MsIHdlIG9ubHkgcGFzcyBvbmUgYXJndW1lbnQsIHRvIGEgc3BlY2lhbCBpbnN0cnVjdGlvbiBsaWtlIGBwcm9wZXJ0eUludGVycG9sYXRlYCBvclxuICAgICAgICAvLyBgdGV4dEludGVycG9sYXRlYC5cbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbnMubGVuZ3RoICsgc3RyaW5ncy5sZW5ndGg7XG4gICAgfVxufVxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIGZpbmFsIGluc3RydWN0aW9uIGNhbGwgc3RhdGVtZW50cyBiYXNlZCBvbiB0aGUgcGFzc2VkIGluIGNvbmZpZ3VyYXRpb24uXG4gKiBXaWxsIHRyeSB0byBjaGFpbiBpbnN0cnVjdGlvbnMgYXMgbXVjaCBhcyBwb3NzaWJsZSwgaWYgY2hhaW5pbmcgaXMgc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBnZXRJbnN0cnVjdGlvblN0YXRlbWVudHMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIGxldCBwZW5kaW5nRXhwcmVzc2lvbiA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdFeHByZXNzaW9uVHlwZSA9IG51bGw7XG4gICAgbGV0IGNoYWluTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGFyYW1zID0gKHR5cGVvZiBjdXJyZW50LnBhcmFtc09yRm4gPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LnBhcmFtc09yRm4oKSA6IGN1cnJlbnQucGFyYW1zT3JGbikgPz9cbiAgICAgICAgICAgIFtdO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBBcnJheS5pc0FycmF5KHJlc29sdmVkUGFyYW1zKSA/IHJlc29sdmVkUGFyYW1zIDogW3Jlc29sdmVkUGFyYW1zXTtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAvLyBhbmQgaXQgY2FuIGJlIGNoYWluZWQsIGFkZCBhbm90aGVyIGNhbGwgdG8gdGhlIGNoYWluLlxuICAgICAgICBpZiAoY2hhaW5MZW5ndGggPCBNQVhfQ0hBSU5fTEVOR1RIICYmIHBlbmRpbmdFeHByZXNzaW9uVHlwZSA9PT0gY3VycmVudC5yZWZlcmVuY2UgJiZcbiAgICAgICAgICAgIENIQUlOQUJMRV9JTlNUUlVDVElPTlMuaGFzKHBlbmRpbmdFeHByZXNzaW9uVHlwZSkpIHtcbiAgICAgICAgICAgIC8vIFdlJ2xsIGFsd2F5cyBoYXZlIGEgcGVuZGluZyBleHByZXNzaW9uIHdoZW4gdGhlcmUncyBhIHBlbmRpbmcgZXhwcmVzc2lvbiB0eXBlLlxuICAgICAgICAgICAgcGVuZGluZ0V4cHJlc3Npb24gPSBwZW5kaW5nRXhwcmVzc2lvbi5jYWxsRm4ocGFyYW1zLCBwZW5kaW5nRXhwcmVzc2lvbi5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIGNoYWluTGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ0V4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocGVuZGluZ0V4cHJlc3Npb24udG9TdG10KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ0V4cHJlc3Npb24gPSBpbnZva2VJbnN0cnVjdGlvbihjdXJyZW50LnNwYW4sIGN1cnJlbnQucmVmZXJlbmNlLCBwYXJhbXMpO1xuICAgICAgICAgICAgcGVuZGluZ0V4cHJlc3Npb25UeXBlID0gY3VycmVudC5yZWZlcmVuY2U7XG4gICAgICAgICAgICBjaGFpbkxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2luY2UgdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24gYWRkcyB0aGUgcHJldmlvdXMgb25lIHRvIHRoZSBzdGF0ZW1lbnRzLFxuICAgIC8vIHdlIG1heSBiZSBsZWZ0IHdpdGggdGhlIGZpbmFsIG9uZSBhdCB0aGUgZW5kIHRoYXQgaXMgc3RpbGwgcGVuZGluZy5cbiAgICBpZiAocGVuZGluZ0V4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKHBlbmRpbmdFeHByZXNzaW9uLnRvU3RtdCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVJbmplY3RhYmxlKG1ldGEsIHJlc29sdmVGb3J3YXJkUmVmcykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGNvbnN0IGZhY3RvcnlNZXRhID0ge1xuICAgICAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgICAgIHR5cGU6IG1ldGEudHlwZSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBtZXRhLmludGVybmFsVHlwZSxcbiAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IG1ldGEudHlwZUFyZ3VtZW50Q291bnQsXG4gICAgICAgIGRlcHM6IFtdLFxuICAgICAgICB0YXJnZXQ6IEZhY3RvcnlUYXJnZXQkMS5JbmplY3RhYmxlLFxuICAgIH07XG4gICAgaWYgKG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBtZXRhLnVzZUNsYXNzIGhhcyB0d28gbW9kZXMgb2Ygb3BlcmF0aW9uLiBFaXRoZXIgZGVwcyBhcmUgc3BlY2lmaWVkLCBpbiB3aGljaCBjYXNlIGBuZXdgIGlzXG4gICAgICAgIC8vIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIGNsYXNzIHdpdGggZGVwZW5kZW5jaWVzIGluamVjdGVkLCBvciBkZXBzIGFyZSBub3Qgc3BlY2lmaWVkIGFuZFxuICAgICAgICAvLyB0aGUgZmFjdG9yeSBvZiB0aGUgY2xhc3MgaXMgdXNlZCB0byBpbnN0YW50aWF0ZSBpdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQSBzcGVjaWFsIGNhc2UgZXhpc3RzIGZvciB1c2VDbGFzczogVHlwZSB3aGVyZSBUeXBlIGlzIHRoZSBpbmplY3RhYmxlIHR5cGUgaXRzZWxmIGFuZCBub1xuICAgICAgICAvLyBkZXBzIGFyZSBzcGVjaWZpZWQsIGluIHdoaWNoIGNhc2UgJ3VzZUNsYXNzJyBpcyBlZmZlY3RpdmVseSBpZ25vcmVkLlxuICAgICAgICBjb25zdCB1c2VDbGFzc09uU2VsZiA9IG1ldGEudXNlQ2xhc3MuZXhwcmVzc2lvbi5pc0VxdWl2YWxlbnQobWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgICAgICBsZXQgZGVwcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG1ldGEuZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZXBzID0gbWV0YS5kZXBzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZhY3Rvcnk6ICgpID0+IG5ldyBtZXRhLnVzZUNsYXNzKC4uLmRlcHMpXG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICAgICAgICAgICAgICAuLi5mYWN0b3J5TWV0YSxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZTogbWV0YS51c2VDbGFzcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlRGVwczogZGVwcyxcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZVR5cGU6IFIzRmFjdG9yeURlbGVnYXRlVHlwZS5DbGFzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVzZUNsYXNzT25TZWxmKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKGZhY3RvcnlNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBkZWxlZ2F0ZVRvRmFjdG9yeShtZXRhLnR5cGUudmFsdWUsIG1ldGEudXNlQ2xhc3MuZXhwcmVzc2lvbiwgcmVzb2x2ZUZvcndhcmRSZWZzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhLnVzZUZhY3RvcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobWV0YS5kZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgIC4uLmZhY3RvcnlNZXRhLFxuICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBtZXRhLnVzZUZhY3RvcnksXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVEZXBzOiBtZXRhLmRlcHMgfHwgW10sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBSM0ZhY3RvcnlEZWxlZ2F0ZVR5cGUuRnVuY3Rpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmbihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobWV0YS51c2VGYWN0b3J5LmNhbGxGbihbXSkpXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS51c2VWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdGU6IGl0J3Mgc2FmZSB0byB1c2UgYG1ldGEudXNlVmFsdWVgIGluc3RlYWQgb2YgdGhlIGBVU0VfVkFMVUUgaW4gbWV0YWAgY2hlY2sgdXNlZCBmb3JcbiAgICAgICAgLy8gY2xpZW50IGNvZGUgYmVjYXVzZSBtZXRhLnVzZVZhbHVlIGlzIGFuIEV4cHJlc3Npb24gd2hpY2ggd2lsbCBiZSBkZWZpbmVkIGV2ZW4gaWYgdGhlIGFjdHVhbFxuICAgICAgICAvLyB2YWx1ZSBpcyB1bmRlZmluZWQuXG4gICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4uZmFjdG9yeU1ldGEsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBtZXRhLnVzZVZhbHVlLmV4cHJlc3Npb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChtZXRhLnVzZUV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXNlRXhpc3RpbmcgaXMgYW4gYGluamVjdGAgY2FsbCBvbiB0aGUgZXhpc3RpbmcgdG9rZW4uXG4gICAgICAgIHJlc3VsdCA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4uZmFjdG9yeU1ldGEsXG4gICAgICAgICAgICBleHByZXNzaW9uOiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmluamVjdCkuY2FsbEZuKFttZXRhLnVzZUV4aXN0aW5nLmV4cHJlc3Npb25dKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzOiBbXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGRlbGVnYXRlVG9GYWN0b3J5KG1ldGEudHlwZS52YWx1ZSwgbWV0YS5pbnRlcm5hbFR5cGUsIHJlc29sdmVGb3J3YXJkUmVmcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdG9rZW4gPSBtZXRhLmludGVybmFsVHlwZTtcbiAgICBjb25zdCBpbmplY3RhYmxlUHJvcHMgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ3Rva2VuJywgdG9rZW4pO1xuICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ2ZhY3RvcnknLCByZXN1bHQuZXhwcmVzc2lvbik7XG4gICAgLy8gT25seSBnZW5lcmF0ZSBwcm92aWRlZEluIHByb3BlcnR5IGlmIGl0IGhhcyBhIG5vbi1udWxsIHZhbHVlXG4gICAgaWYgKG1ldGEucHJvdmlkZWRJbi5leHByZXNzaW9uLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGluamVjdGFibGVQcm9wcy5zZXQoJ3Byb3ZpZGVkSW4nLCBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS5wcm92aWRlZEluKSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLsm1ybVkZWZpbmVJbmplY3RhYmxlKVxuICAgICAgICAuY2FsbEZuKFtpbmplY3RhYmxlUHJvcHMudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGV4cHJlc3Npb24sXG4gICAgICAgIHR5cGU6IGNyZWF0ZUluamVjdGFibGVUeXBlKG1ldGEpLFxuICAgICAgICBzdGF0ZW1lbnRzOiByZXN1bHQuc3RhdGVtZW50cyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0YWJsZVR5cGUobWV0YSkge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy5JbmplY3RhYmxlRGVjbGFyYXRpb24sIFt0eXBlV2l0aFBhcmFtZXRlcnMobWV0YS50eXBlLnR5cGUsIG1ldGEudHlwZUFyZ3VtZW50Q291bnQpXSkpO1xufVxuZnVuY3Rpb24gZGVsZWdhdGVUb0ZhY3RvcnkodHlwZSwgaW50ZXJuYWxUeXBlLCB1bndyYXBGb3J3YXJkUmVmcykge1xuICAgIGlmICh0eXBlLm5vZGUgPT09IGludGVybmFsVHlwZS5ub2RlKSB7XG4gICAgICAgIC8vIFRoZSB0eXBlcyBhcmUgdGhlIHNhbWUsIHNvIHdlIGNhbiBzaW1wbHkgZGVsZWdhdGUgZGlyZWN0bHkgdG8gdGhlIHR5cGUncyBmYWN0b3J5LlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gZmFjdG9yeTogdHlwZS7JtWZhY1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgcmV0dXJuIGludGVybmFsVHlwZS5wcm9wKCfJtWZhYycpO1xuICAgIH1cbiAgICBpZiAoIXVud3JhcEZvcndhcmRSZWZzKSB7XG4gICAgICAgIC8vIFRoZSB0eXBlIGlzIG5vdCB3cmFwcGVkIGluIGEgYGZvcndhcmRSZWYoKWAsIHNvIHdlIGNyZWF0ZSBhIHNpbXBsZSBmYWN0b3J5IGZ1bmN0aW9uIHRoYXRcbiAgICAgICAgLy8gYWNjZXB0cyBhIHN1Yi10eXBlIGFzIGFuIGFyZ3VtZW50LlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gZmFjdG9yeTogZnVuY3Rpb24odCkgeyByZXR1cm4gaW50ZXJuYWxUeXBlLsm1ZmFjKHQpOyB9XG4gICAgICAgIC8vIGBgYFxuICAgICAgICByZXR1cm4gY3JlYXRlRmFjdG9yeUZ1bmN0aW9uKGludGVybmFsVHlwZSk7XG4gICAgfVxuICAgIC8vIFRoZSBpbnRlcm5hbFR5cGUgaXMgYWN0dWFsbHkgd3JhcHBlZCBpbiBhIGBmb3J3YXJkUmVmKClgIHNvIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGF0IGJlZm9yZVxuICAgIC8vIGNhbGxpbmcgaXRzIGZhY3RvcnkuXG4gICAgLy8gYGBgXG4gICAgLy8gZmFjdG9yeTogZnVuY3Rpb24odCkgeyByZXR1cm4gY29yZS5yZXNvbHZlRm9yd2FyZFJlZih0eXBlKS7JtWZhYyh0KTsgfVxuICAgIC8vIGBgYFxuICAgIGNvbnN0IHVud3JhcHBlZFR5cGUgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlc29sdmVGb3J3YXJkUmVmKS5jYWxsRm4oW2ludGVybmFsVHlwZV0pO1xuICAgIHJldHVybiBjcmVhdGVGYWN0b3J5RnVuY3Rpb24odW53cmFwcGVkVHlwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5RnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiBmbihbbmV3IEZuUGFyYW0oJ3QnLCBEWU5BTUlDX1RZUEUpXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQodHlwZS5wcm9wKCfJtWZhYycpLmNhbGxGbihbdmFyaWFibGUoJ3QnKV0pKV0pO1xufVxuXG5jb25zdCBVTlVTQUJMRV9JTlRFUlBPTEFUSU9OX1JFR0VYUFMgPSBbXG4gICAgL15cXHMqJC8sXG4gICAgL1s8Pl0vLFxuICAgIC9eW3t9XSQvLFxuICAgIC8mKCN8W2Etel0pL2ksXG4gICAgL15cXC9cXC8vLCAvLyBjb21tZW50XG5dO1xuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoaWRlbnRpZmllciwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcke2lkZW50aWZpZXJ9JyB0byBiZSBhbiBhcnJheSwgW3N0YXJ0LCBlbmRdLmApO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdmFsdWVbMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHZhbHVlWzFdO1xuICAgICAgICAvLyBDaGVjayBmb3IgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2xzXG4gICAgICAgIFVOVVNBQkxFX0lOVEVSUE9MQVRJT05fUkVHRVhQUy5mb3JFYWNoKHJlZ2V4cCA9PiB7XG4gICAgICAgICAgICBpZiAocmVnZXhwLnRlc3Qoc3RhcnQpIHx8IHJlZ2V4cC50ZXN0KGVuZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFsnJHtzdGFydH0nLCAnJHtlbmR9J10gY29udGFpbnMgdW51c2FibGUgaW50ZXJwb2xhdGlvbiBzeW1ib2wuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgSW50ZXJwb2xhdGlvbkNvbmZpZyB7XG4gICAgc3RhdGljIGZyb21BcnJheShtYXJrZXJzKSB7XG4gICAgICAgIGlmICghbWFya2Vycykge1xuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUc7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SW50ZXJwb2xhdGlvblN5bWJvbHMoJ2ludGVycG9sYXRpb24nLCBtYXJrZXJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKG1hcmtlcnNbMF0sIG1hcmtlcnNbMV0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxufVxuY29uc3QgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRyA9IG5ldyBJbnRlcnBvbGF0aW9uQ29uZmlnKCd7eycsICd9fScpO1xuXG5jb25zdCAkRU9GID0gMDtcbmNvbnN0ICRCU1BBQ0UgPSA4O1xuY29uc3QgJFRBQiA9IDk7XG5jb25zdCAkTEYgPSAxMDtcbmNvbnN0ICRWVEFCID0gMTE7XG5jb25zdCAkRkYgPSAxMjtcbmNvbnN0ICRDUiA9IDEzO1xuY29uc3QgJFNQQUNFID0gMzI7XG5jb25zdCAkQkFORyA9IDMzO1xuY29uc3QgJERRID0gMzQ7XG5jb25zdCAkSEFTSCA9IDM1O1xuY29uc3QgJCQgPSAzNjtcbmNvbnN0ICRQRVJDRU5UID0gMzc7XG5jb25zdCAkQU1QRVJTQU5EID0gMzg7XG5jb25zdCAkU1EgPSAzOTtcbmNvbnN0ICRMUEFSRU4gPSA0MDtcbmNvbnN0ICRSUEFSRU4gPSA0MTtcbmNvbnN0ICRTVEFSID0gNDI7XG5jb25zdCAkUExVUyA9IDQzO1xuY29uc3QgJENPTU1BID0gNDQ7XG5jb25zdCAkTUlOVVMgPSA0NTtcbmNvbnN0ICRQRVJJT0QgPSA0NjtcbmNvbnN0ICRTTEFTSCA9IDQ3O1xuY29uc3QgJENPTE9OID0gNTg7XG5jb25zdCAkU0VNSUNPTE9OID0gNTk7XG5jb25zdCAkTFQgPSA2MDtcbmNvbnN0ICRFUSA9IDYxO1xuY29uc3QgJEdUID0gNjI7XG5jb25zdCAkUVVFU1RJT04gPSA2MztcbmNvbnN0ICQwID0gNDg7XG5jb25zdCAkNyA9IDU1O1xuY29uc3QgJDkgPSA1NztcbmNvbnN0ICRBID0gNjU7XG5jb25zdCAkRSA9IDY5O1xuY29uc3QgJEYgPSA3MDtcbmNvbnN0ICRYID0gODg7XG5jb25zdCAkWiA9IDkwO1xuY29uc3QgJExCUkFDS0VUID0gOTE7XG5jb25zdCAkQkFDS1NMQVNIID0gOTI7XG5jb25zdCAkUkJSQUNLRVQgPSA5MztcbmNvbnN0ICRDQVJFVCA9IDk0O1xuY29uc3QgJF8gPSA5NTtcbmNvbnN0ICRhID0gOTc7XG5jb25zdCAkYiA9IDk4O1xuY29uc3QgJGUgPSAxMDE7XG5jb25zdCAkZiA9IDEwMjtcbmNvbnN0ICRuID0gMTEwO1xuY29uc3QgJHIgPSAxMTQ7XG5jb25zdCAkdCA9IDExNjtcbmNvbnN0ICR1ID0gMTE3O1xuY29uc3QgJHYgPSAxMTg7XG5jb25zdCAkeCA9IDEyMDtcbmNvbnN0ICR6ID0gMTIyO1xuY29uc3QgJExCUkFDRSA9IDEyMztcbmNvbnN0ICRCQVIgPSAxMjQ7XG5jb25zdCAkUkJSQUNFID0gMTI1O1xuY29uc3QgJE5CU1AgPSAxNjA7XG5jb25zdCAkUElQRSA9IDEyNDtcbmNvbnN0ICRUSUxEQSA9IDEyNjtcbmNvbnN0ICRBVCA9IDY0O1xuY29uc3QgJEJUID0gOTY7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSAkVEFCICYmIGNvZGUgPD0gJFNQQUNFKSB8fCAoY29kZSA9PSAkTkJTUCk7XG59XG5mdW5jdGlvbiBpc0RpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ5O1xufVxuZnVuY3Rpb24gaXNBc2NpaUxldHRlcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gJGEgJiYgY29kZSA8PSAkeiB8fCBjb2RlID49ICRBICYmIGNvZGUgPD0gJFo7XG59XG5mdW5jdGlvbiBpc0FzY2lpSGV4RGlnaXQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJGYgfHwgY29kZSA+PSAkQSAmJiBjb2RlIDw9ICRGIHx8IGlzRGlnaXQoY29kZSk7XG59XG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkTEYgfHwgY29kZSA9PT0gJENSO1xufVxuZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gJDAgPD0gY29kZSAmJiBjb2RlIDw9ICQ3O1xufVxuZnVuY3Rpb24gaXNRdW90ZShjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09ICRTUSB8fCBjb2RlID09PSAkRFEgfHwgY29kZSA9PT0gJEJUO1xufVxuXG5jbGFzcyBQYXJzZUxvY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlLCBvZmZzZXQsIGxpbmUsIGNvbCkge1xuICAgICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQgIT0gbnVsbCA/IGAke3RoaXMuZmlsZS51cmx9QCR7dGhpcy5saW5lfToke3RoaXMuY29sfWAgOiB0aGlzLmZpbGUudXJsO1xuICAgIH1cbiAgICBtb3ZlQnkoZGVsdGEpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5maWxlLmNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgICAgIGxldCBjb2wgPSB0aGlzLmNvbDtcbiAgICAgICAgd2hpbGUgKG9mZnNldCA+IDAgJiYgZGVsdGEgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIGRlbHRhKys7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoY2ggPT0gJExGKSB7XG4gICAgICAgICAgICAgICAgbGluZS0tO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yTGluZSA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgb2Zmc2V0IC0gMSkubGFzdEluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZSgkTEYpKTtcbiAgICAgICAgICAgICAgICBjb2wgPSBwcmlvckxpbmUgPiAwID8gb2Zmc2V0IC0gcHJpb3JMaW5lIDogb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGxlbiAmJiBkZWx0YSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgZGVsdGEtLTtcbiAgICAgICAgICAgIGlmIChjaCA9PSAkTEYpIHtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VMb2NhdGlvbih0aGlzLmZpbGUsIG9mZnNldCwgbGluZSwgY29sKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHRoZSBzb3VyY2UgYXJvdW5kIHRoZSBsb2NhdGlvblxuICAgIC8vIFVwIHRvIGBtYXhDaGFyc2Agb3IgYG1heExpbmVzYCBvbiBlYWNoIHNpZGUgb2YgdGhlIGxvY2F0aW9uXG4gICAgZ2V0Q29udGV4dChtYXhDaGFycywgbWF4TGluZXMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuZmlsZS5jb250ZW50O1xuICAgICAgICBsZXQgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGFydE9mZnNldCA+IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGxldCBjdHhMaW5lcyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoY3R4Q2hhcnMgPCBtYXhDaGFycyAmJiBzdGFydE9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbc3RhcnRPZmZzZXRdID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgrK2N0eExpbmVzID09IG1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eENoYXJzID0gMDtcbiAgICAgICAgICAgIGN0eExpbmVzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjdHhDaGFycyA8IG1heENoYXJzICYmIGVuZE9mZnNldCA8IGNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICAgICAgICAgIGN0eENoYXJzKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbZW5kT2Zmc2V0XSA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKytjdHhMaW5lcyA9PSBtYXhMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGJlZm9yZTogY29udGVudC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIHRoaXMub2Zmc2V0KSxcbiAgICAgICAgICAgICAgICBhZnRlcjogY29udGVudC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIGVuZE9mZnNldCArIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVNvdXJjZUZpbGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRlbnQsIHVybCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVNvdXJjZVNwYW4ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCBzcGFucyBvZiB0b2tlbnMvbm9kZXMgY2FwdHVyZWQgZHVyaW5nXG4gICAgICogbGV4aW5nL3BhcnNpbmcgb2YgdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydFxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGUgc3RhcnQgb2YgdGhlIHNwYW4gKGhhdmluZyBza2lwcGVkIGxlYWRpbmcgdHJpdmlhKS5cbiAgICAgKiBTa2lwcGluZyBsZWFkaW5nIHRyaXZpYSBtYWtlcyBzb3VyY2Utc3BhbnMgbW9yZSBcInVzZXIgZnJpZW5kbHlcIiwgc2luY2UgdGhpbmdzIGxpa2UgSFRNTFxuICAgICAqIGVsZW1lbnRzIHdpbGwgYXBwZWFyIHRvIGJlZ2luIGF0IHRoZSBzdGFydCBvZiB0aGUgb3BlbmluZyB0YWcsIHJhdGhlciB0aGFuIGF0IHRoZSBzdGFydCBvZiBhbnlcbiAgICAgKiBsZWFkaW5nIHRyaXZpYSwgd2hpY2ggY291bGQgaW5jbHVkZSBuZXdsaW5lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGVuZCBvZiB0aGUgc3Bhbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmdWxsU3RhcnRcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHRva2VuIHdpdGhvdXQgc2tpcHBpbmcgdGhlIGxlYWRpbmcgdHJpdmlhLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0b29saW5nIHRoYXQgc3BsaXRzIHRva2VucyBmdXJ0aGVyLCBzdWNoIGFzIGV4dHJhY3RpbmcgQW5ndWxhciBpbnRlcnBvbGF0aW9uc1xuICAgICAqIGZyb20gdGV4dCB0b2tlbnMuIFN1Y2ggdG9vbGluZyBjcmVhdGVzIG5ldyBzb3VyY2Utc3BhbnMgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIHRva2VuJ3NcbiAgICAgKiBzb3VyY2Utc3Bhbi4gSWYgbGVhZGluZyB0cml2aWEgY2hhcmFjdGVycyBoYXZlIGJlZW4gc2tpcHBlZCB0aGVuIHRoZSBuZXcgc291cmNlLXNwYW5zIG1heSBiZVxuICAgICAqIGluY29ycmVjdGx5IG9mZnNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXRhaWxzXG4gICAgICogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiAoc3VjaCBhcyBpZGVudGlmaWVyIG5hbWVzKSB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNwYW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgZnVsbFN0YXJ0ID0gc3RhcnQsIGRldGFpbHMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgICAgIHRoaXMuZnVsbFN0YXJ0ID0gZnVsbFN0YXJ0O1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQuZmlsZS5jb250ZW50LnN1YnN0cmluZyh0aGlzLnN0YXJ0Lm9mZnNldCwgdGhpcy5lbmQub2Zmc2V0KTtcbiAgICB9XG59XG52YXIgUGFyc2VFcnJvckxldmVsO1xuKGZ1bmN0aW9uIChQYXJzZUVycm9yTGV2ZWwpIHtcbiAgICBQYXJzZUVycm9yTGV2ZWxbUGFyc2VFcnJvckxldmVsW1wiV0FSTklOR1wiXSA9IDBdID0gXCJXQVJOSU5HXCI7XG4gICAgUGFyc2VFcnJvckxldmVsW1BhcnNlRXJyb3JMZXZlbFtcIkVSUk9SXCJdID0gMV0gPSBcIkVSUk9SXCI7XG59KShQYXJzZUVycm9yTGV2ZWwgfHwgKFBhcnNlRXJyb3JMZXZlbCA9IHt9KSk7XG5jbGFzcyBQYXJzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBtc2csIGxldmVsID0gUGFyc2VFcnJvckxldmVsLkVSUk9SKSB7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMubXNnID0gbXNnO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIGNvbnRleHR1YWxNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsIDMpO1xuICAgICAgICByZXR1cm4gY3R4ID8gYCR7dGhpcy5tc2d9IChcIiR7Y3R4LmJlZm9yZX1bJHtQYXJzZUVycm9yTGV2ZWxbdGhpcy5sZXZlbF19IC0+XSR7Y3R4LmFmdGVyfVwiKWAgOlxuICAgICAgICAgICAgdGhpcy5tc2c7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gdGhpcy5zcGFuLmRldGFpbHMgPyBgLCAke3RoaXMuc3Bhbi5kZXRhaWxzfWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29udGV4dHVhbE1lc3NhZ2UoKX06ICR7dGhpcy5zcGFuLnN0YXJ0fSR7ZGV0YWlsc31gO1xuICAgIH1cbn1cbi8qKlxuICogR2VuZXJhdGVzIFNvdXJjZSBTcGFuIG9iamVjdCBmb3IgYSBnaXZlbiBSMyBUeXBlIGZvciBKSVQgbW9kZS5cbiAqXG4gKiBAcGFyYW0ga2luZCBDb21wb25lbnQgb3IgRGlyZWN0aXZlLlxuICogQHBhcmFtIHR5cGVOYW1lIG5hbWUgb2YgdGhlIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKiBAcGFyYW0gc291cmNlVXJsIHJlZmVyZW5jZSB0byBDb21wb25lbnQgb3IgRGlyZWN0aXZlIHNvdXJjZS5cbiAqIEByZXR1cm5zIGluc3RhbmNlIG9mIFBhcnNlU291cmNlU3BhbiB0aGF0IHJlcHJlc2VudCBhIGdpdmVuIENvbXBvbmVudCBvciBEaXJlY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIHIzSml0VHlwZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgIGNvbnN0IHNvdXJjZUZpbGVOYW1lID0gYGluICR7a2luZH0gJHt0eXBlTmFtZX0gaW4gJHtzb3VyY2VVcmx9YDtcbiAgICBjb25zdCBzb3VyY2VGaWxlID0gbmV3IFBhcnNlU291cmNlRmlsZSgnJywgc291cmNlRmlsZU5hbWUpO1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKG5ldyBQYXJzZUxvY2F0aW9uKHNvdXJjZUZpbGUsIC0xLCAtMSwgLTEpLCBuZXcgUGFyc2VMb2NhdGlvbihzb3VyY2VGaWxlLCAtMSwgLTEsIC0xKSk7XG59XG5sZXQgX2Fub255bW91c1R5cGVJbmRleCA9IDA7XG5mdW5jdGlvbiBpZGVudGlmaWVyTmFtZShjb21waWxlSWRlbnRpZmllcikge1xuICAgIGlmICghY29tcGlsZUlkZW50aWZpZXIgfHwgIWNvbXBpbGVJZGVudGlmaWVyLnJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmID0gY29tcGlsZUlkZW50aWZpZXIucmVmZXJlbmNlO1xuICAgIGlmIChyZWZbJ19fYW5vbnltb3VzVHlwZSddKSB7XG4gICAgICAgIHJldHVybiByZWZbJ19fYW5vbnltb3VzVHlwZSddO1xuICAgIH1cbiAgICBpZiAocmVmWydfX2ZvcndhcmRfcmVmX18nXSkge1xuICAgICAgICAvLyBXZSBkbyBub3Qgd2FudCB0byB0cnkgdG8gc3RyaW5naWZ5IGEgYGZvcndhcmRSZWYoKWAgZnVuY3Rpb24gYmVjYXVzZSB0aGF0IHdvdWxkIGNhdXNlIHRoZVxuICAgICAgICAvLyBpbm5lciBmdW5jdGlvbiB0byBiZSBldmFsdWF0ZWQgdG9vIGVhcmx5LCBkZWZlYXRpbmcgdGhlIHdob2xlIHBvaW50IG9mIHRoZSBgZm9yd2FyZFJlZmAuXG4gICAgICAgIHJldHVybiAnX19mb3J3YXJkX3JlZl9fJztcbiAgICB9XG4gICAgbGV0IGlkZW50aWZpZXIgPSBzdHJpbmdpZnkocmVmKTtcbiAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCcoJykgPj0gMCkge1xuICAgICAgICAvLyBjYXNlOiBhbm9ueW1vdXMgZnVuY3Rpb25zIVxuICAgICAgICBpZGVudGlmaWVyID0gYGFub255bW91c18ke19hbm9ueW1vdXNUeXBlSW5kZXgrK31gO1xuICAgICAgICByZWZbJ19fYW5vbnltb3VzVHlwZSddID0gaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlkZW50aWZpZXIgPSBzYW5pdGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xufVxuZnVuY3Rpb24gc2FuaXRpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKC9cXFcvZywgJ18nKTtcbn1cblxuLyoqXG4gKiBJbiBUeXBlU2NyaXB0LCB0YWdnZWQgdGVtcGxhdGUgZnVuY3Rpb25zIGV4cGVjdCBhIFwidGVtcGxhdGUgb2JqZWN0XCIsIHdoaWNoIGlzIGFuIGFycmF5IG9mXG4gKiBcImNvb2tlZFwiIHN0cmluZ3MgcGx1cyBhIGByYXdgIHByb3BlcnR5IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgXCJyYXdcIiBzdHJpbmdzLiBUaGlzIGlzXG4gKiB0eXBpY2FsbHkgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIGNhbGxlZCBgX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpYCwgYnV0IGl0IG1heSBub3RcbiAqIGJlIGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLlxuICpcbiAqIFRoaXMgaXMgYSBKYXZhU2NyaXB0IHBvbHlmaWxsIHRoYXQgdXNlcyBfX21ha2VUZW1wbGF0ZU9iamVjdCB3aGVuIGl0J3MgYXZhaWxhYmxlLCBidXQgb3RoZXJ3aXNlXG4gKiBjcmVhdGVzIGFuIGlubGluZSBoZWxwZXIgd2l0aCB0aGUgc2FtZSBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIEluIHRoZSBpbmxpbmUgZnVuY3Rpb24sIGlmIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIGlzIGF2YWlsYWJsZSB3ZSB1c2UgdGhhdCB0byBhdHRhY2ggdGhlIGByYXdgXG4gKiBhcnJheS5cbiAqL1xuY29uc3QgbWFrZVRlbXBsYXRlT2JqZWN0UG9seWZpbGwgPSAnKHRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTp0fSk6ZS5yYXc9dCxlfSknO1xuY2xhc3MgQWJzdHJhY3RKc0VtaXR0ZXJWaXNpdG9yIGV4dGVuZHMgQWJzdHJhY3RFbWl0dGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGZhbHNlKTtcbiAgICB9XG4gICAgdmlzaXRXcmFwcGVkTm9kZUV4cHIoYXN0LCBjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW1pdCBhIFdyYXBwZWROb2RlRXhwciBpbiBKYXZhc2NyaXB0LicpO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVWYXJTdG10KHN0bXQsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoc3RtdCwgYHZhciAke3N0bXQubmFtZX1gKTtcbiAgICAgICAgaWYgKHN0bXQudmFsdWUpIHtcbiAgICAgICAgICAgIGN0eC5wcmludChzdG10LCAnID0gJyk7XG4gICAgICAgICAgICBzdG10LnZhbHVlLnZpc2l0RXhwcmVzc2lvbih0aGlzLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcmludGxuKHN0bXQsIGA7YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFRhZ2dlZFRlbXBsYXRlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvbnZvbHV0ZWQgcGllY2Ugb2YgY29kZSBpcyBlZmZlY3RpdmVseSB0aGUgZG93bmxldmVsbGVkIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHRhZ2AuLi5gXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyB3aGljaCBpcyBlZmZlY3RpdmVseSBsaWtlOlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gdGFnKF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSwgZXhwcmVzc2lvbjEsIGV4cHJlc3Npb24yLCAuLi4pO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBhc3QudGVtcGxhdGUuZWxlbWVudHM7XG4gICAgICAgIGFzdC50YWcudmlzaXRFeHByZXNzaW9uKHRoaXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGAoJHttYWtlVGVtcGxhdGVPYmplY3RQb2x5ZmlsbH0oYCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGBbJHtlbGVtZW50cy5tYXAocGFydCA9PiBlc2NhcGVJZGVudGlmaWVyKHBhcnQudGV4dCwgZmFsc2UpKS5qb2luKCcsICcpfV0sIGApO1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgWyR7ZWxlbWVudHMubWFwKHBhcnQgPT4gZXNjYXBlSWRlbnRpZmllcihwYXJ0LnJhd1RleHQsIGZhbHNlKSkuam9pbignLCAnKX1dKWApO1xuICAgICAgICBhc3QudGVtcGxhdGUuZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcsICcpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEZ1bmN0aW9uRXhwcihhc3QsIGN0eCkge1xuICAgICAgICBjdHgucHJpbnQoYXN0LCBgZnVuY3Rpb24ke2FzdC5uYW1lID8gJyAnICsgYXN0Lm5hbWUgOiAnJ30oYCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0UGFyYW1zKGFzdC5wYXJhbXMsIGN0eCk7XG4gICAgICAgIGN0eC5wcmludGxuKGFzdCwgYCkge2ApO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKGFzdC5zdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjdHguZGVjSW5kZW50KCk7XG4gICAgICAgIGN0eC5wcmludChhc3QsIGB9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdERlY2xhcmVGdW5jdGlvblN0bXQoc3RtdCwgY3R4KSB7XG4gICAgICAgIGN0eC5wcmludChzdG10LCBgZnVuY3Rpb24gJHtzdG10Lm5hbWV9KGApO1xuICAgICAgICB0aGlzLl92aXNpdFBhcmFtcyhzdG10LnBhcmFtcywgY3R4KTtcbiAgICAgICAgY3R4LnByaW50bG4oc3RtdCwgYCkge2ApO1xuICAgICAgICBjdHguaW5jSW5kZW50KCk7XG4gICAgICAgIHRoaXMudmlzaXRBbGxTdGF0ZW1lbnRzKHN0bXQuc3RhdGVtZW50cywgY3R4KTtcbiAgICAgICAgY3R4LmRlY0luZGVudCgpO1xuICAgICAgICBjdHgucHJpbnRsbihzdG10LCBgfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRMb2NhbGl6ZWRTdHJpbmcoYXN0LCBjdHgpIHtcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb252b2x1dGVkIHBpZWNlIG9mIGNvZGUgaXMgZWZmZWN0aXZlbHkgdGhlIGRvd25sZXZlbGxlZCBlcXVpdmFsZW50IG9mXG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUgYC4uLmBcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGxpa2U6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyAkbG9jYWxpemUoX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpLCBleHByZXNzaW9uMSwgZXhwcmVzc2lvbjIsIC4uLik7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICBjdHgucHJpbnQoYXN0LCBgJGxvY2FsaXplKCR7bWFrZVRlbXBsYXRlT2JqZWN0UG9seWZpbGx9KGApO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFthc3Quc2VyaWFsaXplSTE4bkhlYWQoKV07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXN0Lm1lc3NhZ2VQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcGFydHMucHVzaChhc3Quc2VyaWFsaXplSTE4blRlbXBsYXRlUGFydChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFske3BhcnRzLm1hcChwYXJ0ID0+IGVzY2FwZUlkZW50aWZpZXIocGFydC5jb29rZWQsIGZhbHNlKSkuam9pbignLCAnKX1dLCBgKTtcbiAgICAgICAgY3R4LnByaW50KGFzdCwgYFske3BhcnRzLm1hcChwYXJ0ID0+IGVzY2FwZUlkZW50aWZpZXIocGFydC5yYXcsIGZhbHNlKSkuam9pbignLCAnKX1dKWApO1xuICAgICAgICBhc3QuZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHtcbiAgICAgICAgICAgIGN0eC5wcmludChhc3QsICcsICcpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbi52aXNpdEV4cHJlc3Npb24odGhpcywgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5wcmludChhc3QsICcpJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfdmlzaXRQYXJhbXMocGFyYW1zLCBjdHgpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbE9iamVjdHMocGFyYW0gPT4gY3R4LnByaW50KG51bGwsIHBhcmFtLm5hbWUpLCBwYXJhbXMsIGN0eCwgJywnKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogQSBtb2R1bGUgdG8gZmFjaWxpdGF0ZSB1c2Ugb2YgYSBUcnVzdGVkIFR5cGVzIHBvbGljeSB3aXRoaW4gdGhlIEpJVFxuICogY29tcGlsZXIuIEl0IGxhemlseSBjb25zdHJ1Y3RzIHRoZSBUcnVzdGVkIFR5cGVzIHBvbGljeSwgcHJvdmlkaW5nIGhlbHBlclxuICogdXRpbGl0aWVzIGZvciBwcm9tb3Rpbmcgc3RyaW5ncyB0byBUcnVzdGVkIFR5cGVzLiBXaGVuIFRydXN0ZWQgVHlwZXMgYXJlIG5vdFxuICogYXZhaWxhYmxlLCBzdHJpbmdzIGFyZSB1c2VkIGFzIGEgZmFsbGJhY2suXG4gKiBAc2VjdXJpdHkgQWxsIHVzZSBvZiB0aGlzIG1vZHVsZSBpcyBzZWN1cml0eS1zZW5zaXRpdmUgYW5kIHNob3VsZCBnbyB0aHJvdWdoXG4gKiBzZWN1cml0eSByZXZpZXcuXG4gKi9cbi8qKlxuICogVGhlIFRydXN0ZWQgVHlwZXMgcG9saWN5LCBvciBudWxsIGlmIFRydXN0ZWQgVHlwZXMgYXJlIG5vdFxuICogZW5hYmxlZC9zdXBwb3J0ZWQsIG9yIHVuZGVmaW5lZCBpZiB0aGUgcG9saWN5IGhhcyBub3QgYmVlbiBjcmVhdGVkIHlldC5cbiAqL1xubGV0IHBvbGljeTtcbi8qKlxuICogUmV0dXJucyB0aGUgVHJ1c3RlZCBUeXBlcyBwb2xpY3ksIG9yIG51bGwgaWYgVHJ1c3RlZCBUeXBlcyBhcmUgbm90XG4gKiBlbmFibGVkL3N1cHBvcnRlZC4gVGhlIGZpcnN0IGNhbGwgdG8gdGhpcyBmdW5jdGlvbiB3aWxsIGNyZWF0ZSB0aGUgcG9saWN5LlxuICovXG5mdW5jdGlvbiBnZXRQb2xpY3koKSB7XG4gICAgaWYgKHBvbGljeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvbGljeSA9IG51bGw7XG4gICAgICAgIGlmIChfZ2xvYmFsLnRydXN0ZWRUeXBlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwb2xpY3kgPVxuICAgICAgICAgICAgICAgICAgICBfZ2xvYmFsLnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3koJ2FuZ3VsYXIjdW5zYWZlLWppdCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVNjcmlwdDogKHMpID0+IHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kgdGhyb3dzIGlmIGNhbGxlZCB3aXRoIGEgbmFtZSB0aGF0IGlzXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkLCBldmVuIGluIHJlcG9ydC1vbmx5IG1vZGUuIFVudGlsIHRoZSBBUEkgY2hhbmdlcyxcbiAgICAgICAgICAgICAgICAvLyBjYXRjaCB0aGUgZXJyb3Igbm90IHRvIGJyZWFrIHRoZSBhcHBsaWNhdGlvbnMgZnVuY3Rpb25hbGx5LiBJbiBzdWNoXG4gICAgICAgICAgICAgICAgLy8gY2FzZXMsIHRoZSBjb2RlIHdpbGwgZmFsbCBiYWNrIHRvIHVzaW5nIHN0cmluZ3MuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvbGljeTtcbn1cbi8qKlxuICogVW5zYWZlbHkgcHJvbW90ZSBhIHN0cmluZyB0byBhIFRydXN0ZWRTY3JpcHQsIGZhbGxpbmcgYmFjayB0byBzdHJpbmdzIHdoZW5cbiAqIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBhdmFpbGFibGUuXG4gKiBAc2VjdXJpdHkgSW4gcGFydGljdWxhciwgaXQgbXVzdCBiZSBhc3N1cmVkIHRoYXQgdGhlIHByb3ZpZGVkIHN0cmluZyB3aWxsXG4gKiBuZXZlciBjYXVzZSBhbiBYU1MgdnVsbmVyYWJpbGl0eSBpZiB1c2VkIGluIGEgY29udGV4dCB0aGF0IHdpbGwgYmVcbiAqIGludGVycHJldGVkIGFuZCBleGVjdXRlZCBhcyBhIHNjcmlwdCBieSBhIGJyb3dzZXIsIGUuZy4gd2hlbiBjYWxsaW5nIGV2YWwuXG4gKi9cbmZ1bmN0aW9uIHRydXN0ZWRTY3JpcHRGcm9tU3RyaW5nKHNjcmlwdCkge1xuICAgIHJldHVybiBnZXRQb2xpY3koKT8uY3JlYXRlU2NyaXB0KHNjcmlwdCkgfHwgc2NyaXB0O1xufVxuLyoqXG4gKiBVbnNhZmVseSBjYWxsIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3RvciB3aXRoIHRoZSBnaXZlbiBzdHJpbmcgYXJndW1lbnRzLlxuICogQHNlY3VyaXR5IFRoaXMgaXMgYSBzZWN1cml0eS1zZW5zaXRpdmUgZnVuY3Rpb247IGFueSB1c2Ugb2YgdGhpcyBmdW5jdGlvblxuICogbXVzdCBnbyB0aHJvdWdoIHNlY3VyaXR5IHJldmlldy4gSW4gcGFydGljdWxhciwgaXQgbXVzdCBiZSBhc3N1cmVkIHRoYXQgaXRcbiAqIGlzIG9ubHkgY2FsbGVkIGZyb20gdGhlIEpJVCBjb21waWxlciwgYXMgdXNlIGluIG90aGVyIGNvZGUgY2FuIGxlYWQgdG8gWFNTXG4gKiB2dWxuZXJhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIG5ld1RydXN0ZWRGdW5jdGlvbkZvckpJVCguLi5hcmdzKSB7XG4gICAgaWYgKCFfZ2xvYmFsLnRydXN0ZWRUeXBlcykge1xuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IFRydXN0ZWQgVHlwZXMsIGZhbGwgYmFjayB0byB0aGUgbW9zdFxuICAgICAgICAvLyBzdHJhaWdodGZvcndhcmQgaW1wbGVtZW50YXRpb246XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oLi4uYXJncyk7XG4gICAgfVxuICAgIC8vIENocm9tZSBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBwYXNzaW5nIFRydXN0ZWRTY3JpcHQgdG8gdGhlIEZ1bmN0aW9uXG4gICAgLy8gY29uc3RydWN0b3IuIFRoZSBmb2xsb3dpbmcgaW1wbGVtZW50cyB0aGUgd29ya2Fyb3VuZCBwcm9wb3NlZCBvbiB0aGUgcGFnZVxuICAgIC8vIGJlbG93LCB3aGVyZSB0aGUgQ2hyb21pdW0gYnVnIGlzIGFsc28gcmVmZXJlbmNlZDpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdzNjL3dlYmFwcHNlYy10cnVzdGVkLXR5cGVzL3dpa2kvVHJ1c3RlZC1UeXBlcy1mb3ItZnVuY3Rpb24tY29uc3RydWN0b3JcbiAgICBjb25zdCBmbkFyZ3MgPSBhcmdzLnNsaWNlKDAsIC0xKS5qb2luKCcsJyk7XG4gICAgY29uc3QgZm5Cb2R5ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGJvZHkgPSBgKGZ1bmN0aW9uIGFub255bW91cygke2ZuQXJnc31cbikgeyAke2ZuQm9keX1cbn0pYDtcbiAgICAvLyBVc2luZyBldmFsIGRpcmVjdGx5IGNvbmZ1c2VzIHRoZSBjb21waWxlciBhbmQgcHJldmVudHMgdGhpcyBtb2R1bGUgZnJvbVxuICAgIC8vIGJlaW5nIHN0cmlwcGVkIG91dCBvZiBKUyBiaW5hcmllcyBldmVuIGlmIG5vdCB1c2VkLiBUaGUgZ2xvYmFsWydldmFsJ11cbiAgICAvLyBpbmRpcmVjdGlvbiBmaXhlcyB0aGF0LlxuICAgIGNvbnN0IGZuID0gX2dsb2JhbFsnZXZhbCddKHRydXN0ZWRTY3JpcHRGcm9tU3RyaW5nKGJvZHkpKTtcbiAgICBpZiAoZm4uYmluZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFdvcmthcm91bmQgZm9yIGEgYnJvd3NlciBidWcgdGhhdCBvbmx5IGV4aXN0cyBpbiBDaHJvbWUgODMsIHdoZXJlIHBhc3NpbmdcbiAgICAgICAgLy8gYSBUcnVzdGVkU2NyaXB0IHRvIGV2YWwganVzdCByZXR1cm5zIHRoZSBUcnVzdGVkU2NyaXB0IGJhY2sgd2l0aG91dFxuICAgICAgICAvLyBldmFsdWF0aW5nIGl0LiBJbiB0aGF0IGNhc2UsIGZhbGwgYmFjayB0byB0aGUgbW9zdCBzdHJhaWdodGZvcndhcmRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb246XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oLi4uYXJncyk7XG4gICAgfVxuICAgIC8vIFRvIGNvbXBsZXRlbHkgbWltaWMgdGhlIGJlaGF2aW9yIG9mIGNhbGxpbmcgXCJuZXcgRnVuY3Rpb25cIiwgdHdvIG1vcmVcbiAgICAvLyB0aGluZ3MgbmVlZCB0byBoYXBwZW46XG4gICAgLy8gMS4gU3RyaW5naWZ5aW5nIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBpdHMgc291cmNlIGNvZGVcbiAgICBmbi50b1N0cmluZyA9ICgpID0+IGJvZHk7XG4gICAgLy8gMi4gV2hlbiBjYWxsaW5nIHRoZSByZXN1bHRpbmcgZnVuY3Rpb24sIGB0aGlzYCBzaG91bGQgcmVmZXIgdG8gYGdsb2JhbGBcbiAgICByZXR1cm4gZm4uYmluZChfZ2xvYmFsKTtcbiAgICAvLyBXaGVuIFRydXN0ZWQgVHlwZXMgc3VwcG9ydCBpbiBGdW5jdGlvbiBjb25zdHJ1Y3RvcnMgaXMgd2lkZWx5IGF2YWlsYWJsZSxcbiAgICAvLyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgc2ltcGxpZmllZCB0bzpcbiAgICAvLyByZXR1cm4gbmV3IEZ1bmN0aW9uKC4uLmFyZ3MubWFwKGEgPT4gdHJ1c3RlZFNjcmlwdEZyb21TdHJpbmcoYSkpKTtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0byBtYW5hZ2UgdGhlIGV2YWx1YXRpb24gb2YgSklUIGdlbmVyYXRlZCBjb2RlLlxuICovXG5jbGFzcyBKaXRFdmFsdWF0b3Ige1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvdXJjZVVybCBUaGUgVVJMIG9mIHRoZSBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gc3RhdGVtZW50cyBBbiBhcnJheSBvZiBBbmd1bGFyIHN0YXRlbWVudCBBU1Qgbm9kZXMgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEBwYXJhbSByZWZSZXNvbHZlciBSZXNvbHZlcyBgby5FeHRlcm5hbFJlZmVyZW5jZWBzIGludG8gdmFsdWVzLlxuICAgICAqIEBwYXJhbSBjcmVhdGVTb3VyY2VNYXBzIElmIHRydWUgdGhlbiBjcmVhdGUgYSBzb3VyY2UtbWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGUgYW5kIGluY2x1ZGUgaXRcbiAgICAgKiBpbmxpbmUgYXMgYSBzb3VyY2UtbWFwIGNvbW1lbnQuXG4gICAgICogQHJldHVybnMgQSBtYXAgb2YgYWxsIHRoZSB2YXJpYWJsZXMgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLlxuICAgICAqL1xuICAgIGV2YWx1YXRlU3RhdGVtZW50cyhzb3VyY2VVcmwsIHN0YXRlbWVudHMsIHJlZlJlc29sdmVyLCBjcmVhdGVTb3VyY2VNYXBzKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBKaXRFbWl0dGVyVmlzaXRvcihyZWZSZXNvbHZlcik7XG4gICAgICAgIGNvbnN0IGN0eCA9IEVtaXR0ZXJWaXNpdG9yQ29udGV4dC5jcmVhdGVSb290KCk7XG4gICAgICAgIC8vIEVuc3VyZSBnZW5lcmF0ZWQgY29kZSBpcyBpbiBzdHJpY3QgbW9kZVxuICAgICAgICBpZiAoc3RhdGVtZW50cy5sZW5ndGggPiAwICYmICFpc1VzZVN0cmljdFN0YXRlbWVudChzdGF0ZW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgICAgICAgICBsaXRlcmFsKCd1c2Ugc3RyaWN0JykudG9TdG10KCksXG4gICAgICAgICAgICAgICAgLi4uc3RhdGVtZW50cyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29udmVydGVyLnZpc2l0QWxsU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBjdHgpO1xuICAgICAgICBjb252ZXJ0ZXIuY3JlYXRlUmV0dXJuU3RtdChjdHgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUNvZGUoc291cmNlVXJsLCBjdHgsIGNvbnZlcnRlci5nZXRBcmdzKCksIGNyZWF0ZVNvdXJjZU1hcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmFsdWF0ZSBhIHBpZWNlIG9mIEpJVCBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gc291cmNlVXJsIFRoZSBVUkwgb2YgdGhpcyBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKiBAcGFyYW0gY3R4IEEgY29udGV4dCBvYmplY3QgdGhhdCBjb250YWlucyBhbiBBU1Qgb2YgdGhlIGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAqIEBwYXJhbSB2YXJzIEEgbWFwIGNvbnRhaW5pbmcgdGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgdmFyaWFibGVzIHRoYXQgdGhlIGV2YWx1YXRlZCBjb2RlIG1pZ2h0XG4gICAgICogcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBjcmVhdGVTb3VyY2VNYXAgSWYgdHJ1ZSB0aGVuIGNyZWF0ZSBhIHNvdXJjZS1tYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZSBhbmQgaW5jbHVkZSBpdFxuICAgICAqIGlubGluZSBhcyBhIHNvdXJjZS1tYXAgY29tbWVudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGNvZGUuXG4gICAgICovXG4gICAgZXZhbHVhdGVDb2RlKHNvdXJjZVVybCwgY3R4LCB2YXJzLCBjcmVhdGVTb3VyY2VNYXApIHtcbiAgICAgICAgbGV0IGZuQm9keSA9IGBcInVzZSBzdHJpY3RcIjske2N0eC50b1NvdXJjZSgpfVxcbi8vIyBzb3VyY2VVUkw9JHtzb3VyY2VVcmx9YDtcbiAgICAgICAgY29uc3QgZm5BcmdOYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCBmbkFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGFyZ05hbWUgaW4gdmFycykge1xuICAgICAgICAgICAgZm5BcmdWYWx1ZXMucHVzaCh2YXJzW2FyZ05hbWVdKTtcbiAgICAgICAgICAgIGZuQXJnTmFtZXMucHVzaChhcmdOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlYXRlU291cmNlTWFwKSB7XG4gICAgICAgICAgICAvLyB1c2luZyBgbmV3IEZ1bmN0aW9uKC4uLilgIGdlbmVyYXRlcyBhIGhlYWRlciwgMSBsaW5lIG9mIG5vIGFyZ3VtZW50cywgMiBsaW5lcyBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEUuZy4gYGBgXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBhbm9ueW1vdXMoYSxiLGNcbiAgICAgICAgICAgIC8vIC8qKi8pIHsgLi4uIH1gYGBcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gaGFyZCBjb2RlIHRoaXMgZmFjdCwgc28gd2UgYXV0byBkZXRlY3QgaXQgdmlhIGFuIGVtcHR5IGZ1bmN0aW9uIGZpcnN0LlxuICAgICAgICAgICAgY29uc3QgZW1wdHlGbiA9IG5ld1RydXN0ZWRGdW5jdGlvbkZvckpJVCguLi5mbkFyZ05hbWVzLmNvbmNhdCgncmV0dXJuIG51bGw7JykpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJMaW5lcyA9IGVtcHR5Rm4uc2xpY2UoMCwgZW1wdHlGbi5pbmRleE9mKCdyZXR1cm4gbnVsbDsnKSkuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmbkJvZHkgKz0gYFxcbiR7Y3R4LnRvU291cmNlTWFwR2VuZXJhdG9yKHNvdXJjZVVybCwgaGVhZGVyTGluZXMpLnRvSnNDb21tZW50KCl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbiA9IG5ld1RydXN0ZWRGdW5jdGlvbkZvckpJVCguLi5mbkFyZ05hbWVzLmNvbmNhdChmbkJvZHkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKGZuLCBmbkFyZ1ZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBKSVQgZ2VuZXJhdGVkIGZ1bmN0aW9uIGJ5IGNhbGxpbmcgaXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiB0ZXN0cyB0byBjYXB0dXJlIHRoZSBmdW5jdGlvbnMgdGhhdCBhcmUgZ2VuZXJhdGVkXG4gICAgICogYnkgdGhpcyBgSml0RXZhbHVhdG9yYCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmbiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXG4gICAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBiZWluZyBleGVjdXRlZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBleGVjdXRlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBleGVjdXRlRnVuY3Rpb24oZm4sIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgIH1cbn1cbi8qKlxuICogQW4gQW5ndWxhciBBU1QgdmlzaXRvciB0aGF0IGNvbnZlcnRzIEFTVCBub2RlcyBpbnRvIGV4ZWN1dGFibGUgSmF2YVNjcmlwdCBjb2RlLlxuICovXG5jbGFzcyBKaXRFbWl0dGVyVmlzaXRvciBleHRlbmRzIEFic3RyYWN0SnNFbWl0dGVyVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IocmVmUmVzb2x2ZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWZSZXNvbHZlciA9IHJlZlJlc29sdmVyO1xuICAgICAgICB0aGlzLl9ldmFsQXJnTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fZXZhbEFyZ1ZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzID0gW107XG4gICAgfVxuICAgIGNyZWF0ZVJldHVyblN0bXQoY3R4KSB7XG4gICAgICAgIGNvbnN0IHN0bXQgPSBuZXcgUmV0dXJuU3RhdGVtZW50KG5ldyBMaXRlcmFsTWFwRXhwcih0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLm1hcChyZXN1bHRWYXIgPT4gbmV3IExpdGVyYWxNYXBFbnRyeShyZXN1bHRWYXIsIHZhcmlhYmxlKHJlc3VsdFZhciksIGZhbHNlKSkpKTtcbiAgICAgICAgc3RtdC52aXNpdFN0YXRlbWVudCh0aGlzLCBjdHgpO1xuICAgIH1cbiAgICBnZXRBcmdzKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ldmFsQXJnTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLl9ldmFsQXJnTmFtZXNbaV1dID0gdGhpcy5fZXZhbEFyZ1ZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB2aXNpdEV4dGVybmFsRXhwcihhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHRoaXMucmVmUmVzb2x2ZXIucmVzb2x2ZUV4dGVybmFsUmVmZXJlbmNlKGFzdC52YWx1ZSksIGN0eCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdFdyYXBwZWROb2RlRXhwcihhc3QsIGN0eCkge1xuICAgICAgICB0aGlzLl9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIGFzdC5ub2RlLCBjdHgpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlVmFyU3RtdChzdG10LCBjdHgpIHtcbiAgICAgICAgaWYgKHN0bXQuaGFzTW9kaWZpZXIoU3RtdE1vZGlmaWVyLkV4cG9ydGVkKSkge1xuICAgICAgICAgICAgdGhpcy5fZXZhbEV4cG9ydGVkVmFycy5wdXNoKHN0bXQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0RGVjbGFyZVZhclN0bXQoc3RtdCwgY3R4KTtcbiAgICB9XG4gICAgdmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGN0eCkge1xuICAgICAgICBpZiAoc3RtdC5oYXNNb2RpZmllcihTdG10TW9kaWZpZXIuRXhwb3J0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmFsRXhwb3J0ZWRWYXJzLnB1c2goc3RtdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIudmlzaXREZWNsYXJlRnVuY3Rpb25TdG10KHN0bXQsIGN0eCk7XG4gICAgfVxuICAgIF9lbWl0UmVmZXJlbmNlVG9FeHRlcm5hbChhc3QsIHZhbHVlLCBjdHgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5fZXZhbEFyZ1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkID09PSAtMSkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLl9ldmFsQXJnVmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX2V2YWxBcmdWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gaWRlbnRpZmllck5hbWUoeyByZWZlcmVuY2U6IHZhbHVlIH0pIHx8ICd2YWwnO1xuICAgICAgICAgICAgdGhpcy5fZXZhbEFyZ05hbWVzLnB1c2goYGppdF8ke25hbWV9XyR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByaW50KGFzdCwgdGhpcy5fZXZhbEFyZ05hbWVzW2lkXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNVc2VTdHJpY3RTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YXRlbWVudC5pc0VxdWl2YWxlbnQobGl0ZXJhbCgndXNlIHN0cmljdCcpLnRvU3RtdCgpKTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZUluamVjdG9yKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBpZiAobWV0YS5wcm92aWRlcnMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3Byb3ZpZGVycycsIG1ldGEucHJvdmlkZXJzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaW1wb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpbXBvcnRzJywgbGl0ZXJhbEFycihtZXRhLmltcG9ydHMpKTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVmaW5lSW5qZWN0b3IpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgY29uc3QgdHlwZSA9IGNyZWF0ZUluamVjdG9yVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3JUeXBlKG1ldGEpIHtcbiAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25UeXBlKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSW5qZWN0b3JEZWNsYXJhdGlvbiwgW25ldyBFeHByZXNzaW9uVHlwZShtZXRhLnR5cGUudHlwZSldKSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgYENvbXBpbGVSZWZsZWN0b3JgIHdoaWNoIHJlc29sdmVzIHJlZmVyZW5jZXMgdG8gQGFuZ3VsYXIvY29yZVxuICogc3ltYm9scyBhdCBydW50aW1lLCBhY2NvcmRpbmcgdG8gYSBjb25zdW1lci1wcm92aWRlZCBtYXBwaW5nLlxuICpcbiAqIE9ubHkgc3VwcG9ydHMgYHJlc29sdmVFeHRlcm5hbFJlZmVyZW5jZWAsIGFsbCBvdGhlciBtZXRob2RzIHRocm93LlxuICovXG5jbGFzcyBSM0ppdFJlZmxlY3RvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICByZXNvbHZlRXh0ZXJuYWxSZWZlcmVuY2UocmVmKSB7XG4gICAgICAgIC8vIFRoaXMgcmVmbGVjdG9yIG9ubHkgaGFuZGxlcyBAYW5ndWxhci9jb3JlIGltcG9ydHMuXG4gICAgICAgIGlmIChyZWYubW9kdWxlTmFtZSAhPT0gJ0Bhbmd1bGFyL2NvcmUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXNvbHZlIGV4dGVybmFsIHJlZmVyZW5jZSB0byAke3JlZi5tb2R1bGVOYW1lfSwgb25seSByZWZlcmVuY2VzIHRvIEBhbmd1bGFyL2NvcmUgYXJlIHN1cHBvcnRlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29udGV4dC5oYXNPd25Qcm9wZXJ0eShyZWYubmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gdmFsdWUgcHJvdmlkZWQgZm9yIEBhbmd1bGFyL2NvcmUgc3ltYm9sICcke3JlZi5uYW1lfScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dFtyZWYubmFtZV07XG4gICAgfVxufVxuXG4vKipcbiAqIEhvdyB0aGUgc2VsZWN0b3Igc2NvcGUgb2YgYW4gTmdNb2R1bGUgKGl0cyBkZWNsYXJhdGlvbnMsIGltcG9ydHMsIGFuZCBleHBvcnRzKSBzaG91bGQgYmUgZW1pdHRlZFxuICogYXMgYSBwYXJ0IG9mIHRoZSBOZ01vZHVsZSBkZWZpbml0aW9uLlxuICovXG52YXIgUjNTZWxlY3RvclNjb3BlTW9kZTtcbihmdW5jdGlvbiAoUjNTZWxlY3RvclNjb3BlTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGRlY2xhcmF0aW9ucyBpbmxpbmUgaW50byB0aGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIG9wdGlvbiBpcyB1c2VmdWwgaW4gY2VydGFpbiBjb250ZXh0cyB3aGVyZSBpdCdzIGtub3duIHRoYXQgSklUIHN1cHBvcnQgaXMgcmVxdWlyZWQuIFRoZVxuICAgICAqIHRyYWRlb2ZmIGhlcmUgaXMgdGhhdCB0aGlzIGVtaXQgc3R5bGUgcHJldmVudHMgZGlyZWN0aXZlcyBhbmQgcGlwZXMgZnJvbSBiZWluZyB0cmVlLXNoYWtlbiBpZlxuICAgICAqIHRoZXkgYXJlIHVudXNlZCwgYnV0IHRoZSBOZ01vZHVsZSBpcyB1c2VkLlxuICAgICAqL1xuICAgIFIzU2VsZWN0b3JTY29wZU1vZGVbUjNTZWxlY3RvclNjb3BlTW9kZVtcIklubGluZVwiXSA9IDBdID0gXCJJbmxpbmVcIjtcbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBkZWNsYXJhdGlvbnMgdXNpbmcgYSBzaWRlIGVmZmVjdGZ1bCBmdW5jdGlvbiBjYWxsLCBgybXJtXNldE5nTW9kdWxlU2NvcGVgLCB0aGF0IGlzXG4gICAgICogZ3VhcmRlZCB3aXRoIHRoZSBgbmdKaXRNb2RlYCBmbGFnLlxuICAgICAqXG4gICAgICogVGhpcyBmb3JtIG9mIGVtaXQgc3VwcG9ydHMgSklUIGFuZCBjYW4gYmUgb3B0aW1pemVkIGF3YXkgaWYgdGhlIGBuZ0ppdE1vZGVgIGZsYWcgaXMgc2V0IHRvXG4gICAgICogZmFsc2UsIHdoaWNoIGFsbG93cyB1bnVzZWQgZGlyZWN0aXZlcyBhbmQgcGlwZXMgdG8gYmUgdHJlZS1zaGFrZW4uXG4gICAgICovXG4gICAgUjNTZWxlY3RvclNjb3BlTW9kZVtSM1NlbGVjdG9yU2NvcGVNb2RlW1wiU2lkZUVmZmVjdFwiXSA9IDFdID0gXCJTaWRlRWZmZWN0XCI7XG4gICAgLyoqXG4gICAgICogRG9uJ3QgZ2VuZXJhdGUgc2VsZWN0b3Igc2NvcGVzIGF0IGFsbC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb250ZXh0cyB3aGVyZSBKSVQgc3VwcG9ydCBpcyBrbm93biB0byBiZSB1bm5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBSM1NlbGVjdG9yU2NvcGVNb2RlW1IzU2VsZWN0b3JTY29wZU1vZGVbXCJPbWl0XCJdID0gMl0gPSBcIk9taXRcIjtcbn0pKFIzU2VsZWN0b3JTY29wZU1vZGUgfHwgKFIzU2VsZWN0b3JTY29wZU1vZGUgPSB7fSkpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYW4gYFIzTmdNb2R1bGVEZWZgIGZvciB0aGUgZ2l2ZW4gYFIzTmdNb2R1bGVNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVOZ01vZHVsZShtZXRhKSB7XG4gICAgY29uc3QgeyBhZGphY2VudFR5cGUsIGludGVybmFsVHlwZSwgYm9vdHN0cmFwLCBkZWNsYXJhdGlvbnMsIGltcG9ydHMsIGV4cG9ydHMsIHNjaGVtYXMsIGNvbnRhaW5zRm9yd2FyZERlY2xzLCBzZWxlY3RvclNjb3BlTW9kZSwgaWQgfSA9IG1ldGE7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAoYm9vdHN0cmFwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIHJlZnNUb0FycmF5KGJvb3RzdHJhcCwgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdG9yU2NvcGVNb2RlID09PSBSM1NlbGVjdG9yU2NvcGVNb2RlLklubGluZSkge1xuICAgICAgICAvLyBJZiByZXF1ZXN0ZWQgdG8gZW1pdCBzY29wZSBpbmZvcm1hdGlvbiBpbmxpbmUsIHBhc3MgdGhlIGBkZWNsYXJhdGlvbnNgLCBgaW1wb3J0c2AgYW5kXG4gICAgICAgIC8vIGBleHBvcnRzYCB0byB0aGUgYMm1ybVkZWZpbmVOZ01vZHVsZSgpYCBjYWxsIGRpcmVjdGx5LlxuICAgICAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCByZWZzVG9BcnJheShkZWNsYXJhdGlvbnMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ltcG9ydHMnLCByZWZzVG9BcnJheShpbXBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRzJywgcmVmc1RvQXJyYXkoZXhwb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWxlY3RvclNjb3BlTW9kZSA9PT0gUjNTZWxlY3RvclNjb3BlTW9kZS5TaWRlRWZmZWN0KSB7XG4gICAgICAgIC8vIEluIHRoaXMgbW9kZSwgc2NvcGUgaW5mb3JtYXRpb24gaXMgbm90IHBhc3NlZCBpbnRvIGDJtcm1ZGVmaW5lTmdNb2R1bGVgIGFzIGl0XG4gICAgICAgIC8vIHdvdWxkIHByZXZlbnQgdHJlZS1zaGFraW5nIG9mIHRoZSBkZWNsYXJhdGlvbnMsIGltcG9ydHMgYW5kIGV4cG9ydHMgcmVmZXJlbmNlcy4gSW5zdGVhZCwgaXQnc1xuICAgICAgICAvLyBwYXRjaGVkIG9udG8gdGhlIE5nTW9kdWxlIGRlZmluaXRpb24gd2l0aCBhIGDJtcm1c2V0TmdNb2R1bGVTY29wZWAgY2FsbCB0aGF0J3MgZ3VhcmRlZCBieSB0aGVcbiAgICAgICAgLy8gYG5nSml0TW9kZWAgZmxhZy5cbiAgICAgICAgY29uc3Qgc2V0TmdNb2R1bGVTY29wZUNhbGwgPSBnZW5lcmF0ZVNldE5nTW9kdWxlU2NvcGVDYWxsKG1ldGEpO1xuICAgICAgICBpZiAoc2V0TmdNb2R1bGVTY29wZUNhbGwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChzZXROZ01vZHVsZVNjb3BlQ2FsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFNlbGVjdG9yIHNjb3BlIGVtaXQgd2FzIG5vdCByZXF1ZXN0ZWQsIHNvIHNraXAgaXQuXG4gICAgfVxuICAgIGlmIChzY2hlbWFzICE9PSBudWxsICYmIHNjaGVtYXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2NoZW1hcycsIGxpdGVyYWxBcnIoc2NoZW1hcy5tYXAocmVmID0+IHJlZi52YWx1ZSkpKTtcbiAgICB9XG4gICAgaWYgKGlkICE9PSBudWxsKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpZCcsIGlkKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSBzaWRlLWVmZmVjdGZ1bCBjYWxsIHRvIHJlZ2lzdGVyIHRoaXMgTmdNb2R1bGUgYnkgaXRzIGlkLCBhcyBwZXIgdGhlIHNlbWFudGljcyBvZlxuICAgICAgICAvLyBOZ01vZHVsZSBpZHMuXG4gICAgICAgIHN0YXRlbWVudHMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlZ2lzdGVyTmdNb2R1bGVUeXBlKS5jYWxsRm4oW2FkamFjZW50VHlwZSwgaWRdKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlZmluZU5nTW9kdWxlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVOZ01vZHVsZVR5cGUobWV0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50cyB9O1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gSklUIG1vZGUgdG8gZ2VuZXJhdGUgdGhlIGNhbGwgdG8gYMm1ybVkZWZpbmVOZ01vZHVsZSgpYCBmcm9tIGEgY2FsbCB0b1xuICogYMm1ybVuZ0RlY2xhcmVOZ01vZHVsZSgpYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZU5nTW9kdWxlRGVjbGFyYXRpb25FeHByZXNzaW9uKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS50eXBlKSk7XG4gICAgaWYgKG1ldGEuYm9vdHN0cmFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2Jvb3RzdHJhcCcsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5ib290c3RyYXApKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY2xhcmF0aW9ucycsIG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS5kZWNsYXJhdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaW1wb3J0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpbXBvcnRzJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLmltcG9ydHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZXhwb3J0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdleHBvcnRzJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLmV4cG9ydHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuc2NoZW1hcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdzY2hlbWFzJywgbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLnNjaGVtYXMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaWQnLCBuZXcgV3JhcHBlZE5vZGVFeHByKG1ldGEuaWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVmaW5lTmdNb2R1bGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTmdNb2R1bGVUeXBlKHsgdHlwZTogbW9kdWxlVHlwZSwgZGVjbGFyYXRpb25zLCBleHBvcnRzLCBpbXBvcnRzLCBpbmNsdWRlSW1wb3J0VHlwZXMsIHB1YmxpY0RlY2xhcmF0aW9uVHlwZXMgfSkge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvblR5cGUoaW1wb3J0RXhwcihJZGVudGlmaWVycy5OZ01vZHVsZURlY2xhcmF0aW9uLCBbXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShtb2R1bGVUeXBlLnR5cGUpLFxuICAgICAgICBwdWJsaWNEZWNsYXJhdGlvblR5cGVzID09PSBudWxsID8gdHVwbGVUeXBlT2YoZGVjbGFyYXRpb25zKSA6XG4gICAgICAgICAgICB0dXBsZU9mVHlwZXMocHVibGljRGVjbGFyYXRpb25UeXBlcyksXG4gICAgICAgIGluY2x1ZGVJbXBvcnRUeXBlcyA/IHR1cGxlVHlwZU9mKGltcG9ydHMpIDogTk9ORV9UWVBFLFxuICAgICAgICB0dXBsZVR5cGVPZihleHBvcnRzKSxcbiAgICBdKSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGNhbGwgdG8gYMm1ybVzZXROZ01vZHVsZVNjb3BlYCB3aXRoIGFsbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24gc28gdGhhdCB0aGVcbiAqIHRyYW5zaXRpdmUgbW9kdWxlIHNjb3BlIGNhbiBiZSBjb21wdXRlZCBkdXJpbmcgcnVudGltZSBpbiBKSVQgbW9kZS4gVGhpcyBjYWxsIGlzIG1hcmtlZCBwdXJlXG4gKiBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZXMgdG8gZGVjbGFyYXRpb25zLCBpbXBvcnRzIGFuZCBleHBvcnRzIG1heSBiZSBlbGlkZWQgY2F1c2luZyB0aGVzZVxuICogc3ltYm9scyB0byBiZWNvbWUgdHJlZS1zaGFrZWFibGUuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2V0TmdNb2R1bGVTY29wZUNhbGwobWV0YSkge1xuICAgIGNvbnN0IHsgYWRqYWNlbnRUeXBlOiBtb2R1bGVUeXBlLCBkZWNsYXJhdGlvbnMsIGltcG9ydHMsIGV4cG9ydHMsIGNvbnRhaW5zRm9yd2FyZERlY2xzIH0gPSBtZXRhO1xuICAgIGNvbnN0IHNjb3BlTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBpZiAoZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NvcGVNYXAuc2V0KCdkZWNsYXJhdGlvbnMnLCByZWZzVG9BcnJheShkZWNsYXJhdGlvbnMsIGNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChpbXBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NvcGVNYXAuc2V0KCdpbXBvcnRzJywgcmVmc1RvQXJyYXkoaW1wb3J0cywgY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY29wZU1hcC5zZXQoJ2V4cG9ydHMnLCByZWZzVG9BcnJheShleHBvcnRzLCBjb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoc2NvcGVNYXAudmFsdWVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIHNldE5nTW9kdWxlU2NvcGUoLi4uKVxuICAgIGNvbnN0IGZuQ2FsbCA9IG5ldyBJbnZva2VGdW5jdGlvbkV4cHIoXG4gICAgLyogZm4gKi8gaW1wb3J0RXhwcihJZGVudGlmaWVycy5zZXROZ01vZHVsZVNjb3BlKSwgXG4gICAgLyogYXJncyAqLyBbbW9kdWxlVHlwZSwgc2NvcGVNYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICAvLyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLilcbiAgICBjb25zdCBndWFyZGVkQ2FsbCA9IGppdE9ubHlHdWFyZGVkRXhwcmVzc2lvbihmbkNhbGwpO1xuICAgIC8vIGZ1bmN0aW9uKCkgeyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLik7IH1cbiAgICBjb25zdCBpaWZlID0gbmV3IEZ1bmN0aW9uRXhwcihcbiAgICAvKiBwYXJhbXMgKi8gW10sIFxuICAgIC8qIHN0YXRlbWVudHMgKi8gW2d1YXJkZWRDYWxsLnRvU3RtdCgpXSk7XG4gICAgLy8gKGZ1bmN0aW9uKCkgeyAobmdKaXRNb2RlIGd1YXJkKSAmJiBzZXROZ01vZHVsZVNjb3BlKC4uLik7IH0pKClcbiAgICBjb25zdCBpaWZlQ2FsbCA9IG5ldyBJbnZva2VGdW5jdGlvbkV4cHIoXG4gICAgLyogZm4gKi8gaWlmZSwgXG4gICAgLyogYXJncyAqLyBbXSk7XG4gICAgcmV0dXJuIGlpZmVDYWxsLnRvU3RtdCgpO1xufVxuZnVuY3Rpb24gdHVwbGVUeXBlT2YoZXhwKSB7XG4gICAgY29uc3QgdHlwZXMgPSBleHAubWFwKHJlZiA9PiB0eXBlb2ZFeHByKHJlZi50eXBlKSk7XG4gICAgcmV0dXJuIGV4cC5sZW5ndGggPiAwID8gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycih0eXBlcykpIDogTk9ORV9UWVBFO1xufVxuZnVuY3Rpb24gdHVwbGVPZlR5cGVzKHR5cGVzKSB7XG4gICAgY29uc3QgdHlwZW9mVHlwZXMgPSB0eXBlcy5tYXAodHlwZSA9PiB0eXBlb2ZFeHByKHR5cGUpKTtcbiAgICByZXR1cm4gdHlwZXMubGVuZ3RoID4gMCA/IGV4cHJlc3Npb25UeXBlKGxpdGVyYWxBcnIodHlwZW9mVHlwZXMpKSA6IE5PTkVfVFlQRTtcbn1cblxuZnVuY3Rpb24gY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwVmFsdWVzID0gW107XG4gICAgLy8gZS5nLiBgbmFtZTogJ215UGlwZSdgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAnbmFtZScsIHZhbHVlOiBsaXRlcmFsKG1ldGFkYXRhLnBpcGVOYW1lKSwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAvLyBlLmcuIGB0eXBlOiBNeVBpcGVgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAndHlwZScsIHZhbHVlOiBtZXRhZGF0YS50eXBlLnZhbHVlLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIC8vIGUuZy4gYHB1cmU6IHRydWVgXG4gICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAncHVyZScsIHZhbHVlOiBsaXRlcmFsKG1ldGFkYXRhLnB1cmUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIGlmIChtZXRhZGF0YS5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcFZhbHVlcy5wdXNoKHsga2V5OiAnc3RhbmRhbG9uZScsIHZhbHVlOiBsaXRlcmFsKHRydWUpLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjb25zdCBleHByZXNzaW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWZpbmVQaXBlKS5jYWxsRm4oW2xpdGVyYWxNYXAoZGVmaW5pdGlvbk1hcFZhbHVlcyldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVQaXBlVHlwZShtZXRhZGF0YSk7XG4gICAgcmV0dXJuIHsgZXhwcmVzc2lvbiwgdHlwZSwgc3RhdGVtZW50czogW10gfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBpcGVUeXBlKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLlBpcGVEZWNsYXJhdGlvbiwgW1xuICAgICAgICB0eXBlV2l0aFBhcmFtZXRlcnMobWV0YWRhdGEudHlwZS50eXBlLCBtZXRhZGF0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIG5ldyBFeHByZXNzaW9uVHlwZShuZXcgTGl0ZXJhbEV4cHIobWV0YWRhdGEucGlwZU5hbWUpKSxcbiAgICAgICAgbmV3IEV4cHJlc3Npb25UeXBlKG5ldyBMaXRlcmFsRXhwcihtZXRhZGF0YS5pc1N0YW5kYWxvbmUpKSxcbiAgICBdKSk7XG59XG5cbnZhciBSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQ7XG4oZnVuY3Rpb24gKFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZCkge1xuICAgIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmRbXCJEaXJlY3RpdmVcIl0gPSAwXSA9IFwiRGlyZWN0aXZlXCI7XG4gICAgUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kW1IzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtcIlBpcGVcIl0gPSAxXSA9IFwiUGlwZVwiO1xuICAgIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZFtSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmRbXCJOZ01vZHVsZVwiXSA9IDJdID0gXCJOZ01vZHVsZVwiO1xufSkoUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kIHx8IChSM1RlbXBsYXRlRGVwZW5kZW5jeUtpbmQgPSB7fSkpO1xuXG5jbGFzcyBQYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuZXJyTG9jYXRpb24gPSBlcnJMb2NhdGlvbjtcbiAgICAgICAgdGhpcy5jdHhMb2NhdGlvbiA9IGN0eExvY2F0aW9uO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgUGFyc2VyIEVycm9yOiAke21lc3NhZ2V9ICR7ZXJyTG9jYXRpb259IFske2lucHV0fV0gaW4gJHtjdHhMb2NhdGlvbn1gO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlU3BhbiB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbiAgICB0b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGFic29sdXRlT2Zmc2V0ICsgdGhpcy5zdGFydCwgYWJzb2x1dGVPZmZzZXQgKyB0aGlzLmVuZCk7XG4gICAgfVxufVxuY2xhc3MgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBcbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBsb2NhdGlvbiBvZiB0aGUgZXhwcmVzc2lvbiBBU1QgaW4gYSBzb3VyY2UgY29kZSBmaWxlLlxuICAgICAqL1xuICAgIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnQVNUJztcbiAgICB9XG59XG5jbGFzcyBBU1RXaXRoTmFtZSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMubmFtZVNwYW4gPSBuYW1lU3BhbjtcbiAgICB9XG59XG5jbGFzcyBFbXB0eUV4cHIgZXh0ZW5kcyBBU1Qge1xuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5jbGFzcyBJbXBsaWNpdFJlY2VpdmVyIGV4dGVuZHMgQVNUIHtcbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEltcGxpY2l0UmVjZWl2ZXIodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNlaXZlciB3aGVuIHNvbWV0aGluZyBpcyBhY2Nlc3NlZCB0aHJvdWdoIGB0aGlzYCAoZS5nLiBgdGhpcy5mb29gKS4gTm90ZSB0aGF0IHRoaXMgY2xhc3NcbiAqIGluaGVyaXRzIGZyb20gYEltcGxpY2l0UmVjZWl2ZXJgLCBiZWNhdXNlIGFjY2Vzc2luZyBzb21ldGhpbmcgdGhyb3VnaCBgdGhpc2AgaXMgdHJlYXRlZCB0aGVcbiAqIHNhbWUgYXMgYWNjZXNzaW5nIGl0IGltcGxpY2l0bHkgaW5zaWRlIG9mIGFuIEFuZ3VsYXIgdGVtcGxhdGUgKGUuZy4gYFthdHRyLnRpdGxlXT1cInRoaXMudGl0bGVcImBcbiAqIGlzIHRoZSBzYW1lIGFzIGBbYXR0ci50aXRsZV09XCJ0aXRsZVwiYC4pLiBJbmhlcml0aW5nIGFsbG93cyBmb3IgdGhlIGB0aGlzYCBhY2Nlc3NlcyB0byBiZSB0cmVhdGVkXG4gKiB0aGUgc2FtZSBhcyBpbXBsaWNpdCBvbmVzLCBleGNlcHQgZm9yIGEgY291cGxlIG9mIGV4Y2VwdGlvbnMgbGlrZSBgJGV2ZW50YCBhbmQgYCRhbnlgLlxuICogVE9ETzogd2Ugc2hvdWxkIGZpbmQgYSB3YXkgZm9yIHRoaXMgY2xhc3Mgbm90IHRvIGV4dGVuZCBmcm9tIGBJbXBsaWNpdFJlY2VpdmVyYCBpbiB0aGUgZnV0dXJlLlxuICovXG5jbGFzcyBUaGlzUmVjZWl2ZXIgZXh0ZW5kcyBJbXBsaWNpdFJlY2VpdmVyIHtcbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFRoaXNSZWNlaXZlcj8uKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8qKlxuICogTXVsdGlwbGUgZXhwcmVzc2lvbnMgc2VwYXJhdGVkIGJ5IGEgc2VtaWNvbG9uLlxuICovXG5jbGFzcyBDaGFpbiBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDaGFpbih0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDb25kaXRpb25hbCBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgY29uZGl0aW9uLCB0cnVlRXhwLCBmYWxzZUV4cCkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5jb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIHRoaXMudHJ1ZUV4cCA9IHRydWVFeHA7XG4gICAgICAgIHRoaXMuZmFsc2VFeHAgPSBmYWxzZUV4cDtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRDb25kaXRpb25hbCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eVJlYWQgZXh0ZW5kcyBBU1RXaXRoTmFtZSB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFByb3BlcnR5UmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcm9wZXJ0eVdyaXRlIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuLCByZWNlaXZlciwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQcm9wZXJ0eVdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIFNhZmVQcm9wZXJ0eVJlYWQgZXh0ZW5kcyBBU1RXaXRoTmFtZSB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4sIHJlY2VpdmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5hbWVTcGFuKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVQcm9wZXJ0eVJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgS2V5ZWRSZWFkIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwga2V5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEtleWVkUmVhZCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBTYWZlS2V5ZWRSZWFkIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwga2V5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdFNhZmVLZXllZFJlYWQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgS2V5ZWRXcml0ZSBleHRlbmRzIEFTVCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgcmVjZWl2ZXIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRLZXllZFdyaXRlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIEJpbmRpbmdQaXBlIGV4dGVuZHMgQVNUV2l0aE5hbWUge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cCwgbmFtZSwgYXJncywgbmFtZVNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3BhbiwgbmFtZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cCA9IGV4cDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRQaXBlKHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxQcmltaXRpdmUgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbFByaW1pdGl2ZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBMaXRlcmFsQXJyYXkgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbEFycmF5KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIExpdGVyYWxNYXAgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGtleXMsIHZhbHVlcykge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0TGl0ZXJhbE1hcCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBJbnRlcnBvbGF0aW9uIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBzdHJpbmdzLCBleHByZXNzaW9ucykge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEludGVycG9sYXRpb24odGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgQmluYXJ5IGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCBvcGVyYXRpb24sIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG9wZXJhdGlvbjtcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zLCBgVW5hcnlgIGluaGVyaXRzIGZyb20gYEJpbmFyeWAgYW5kIG1pbWljcyB0aGUgYmluYXJ5IEFTVFxuICogbm9kZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHVzZWQuIFRoaXMgaW5oZXJpdGFuY2UgcmVsYXRpb24gY2FuIGJlIGRlbGV0ZWQgaW4gc29tZSBmdXR1cmUgbWFqb3IsXG4gKiBhZnRlciBjb25zdW1lcnMgaGF2ZSBiZWVuIGdpdmVuIGEgY2hhbmNlIHRvIGZ1bGx5IHN1cHBvcnQgVW5hcnkuXG4gKi9cbmNsYXNzIFVuYXJ5IGV4dGVuZHMgQmluYXJ5IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5hcnkgbWludXMgZXhwcmVzc2lvbiBcIi14XCIsIHJlcHJlc2VudGVkIGFzIGBCaW5hcnlgIHVzaW5nIFwiMCAtIHhcIi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTWludXMoc3Bhbiwgc291cmNlU3BhbiwgZXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFVuYXJ5KHNwYW4sIHNvdXJjZVNwYW4sICctJywgZXhwciwgJy0nLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzb3VyY2VTcGFuLCAwKSwgZXhwcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB1bmFyeSBwbHVzIGV4cHJlc3Npb24gXCIreFwiLCByZXByZXNlbnRlZCBhcyBgQmluYXJ5YCB1c2luZyBcInggLSAwXCIuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVBsdXMoc3Bhbiwgc291cmNlU3BhbiwgZXhwcikge1xuICAgICAgICByZXR1cm4gbmV3IFVuYXJ5KHNwYW4sIHNvdXJjZVNwYW4sICcrJywgZXhwciwgJy0nLCBleHByLCBuZXcgTGl0ZXJhbFByaW1pdGl2ZShzcGFuLCBzb3VyY2VTcGFuLCAwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1cmluZyB0aGUgZGVwcmVjYXRpb24gcGVyaW9kIHRoaXMgY29uc3RydWN0b3IgaXMgcHJpdmF0ZSwgdG8gYXZvaWQgY29uc3VtZXJzIGZyb20gY3JlYXRpbmdcbiAgICAgKiBhIGBVbmFyeWAgd2l0aCB0aGUgZmFsbGJhY2sgcHJvcGVydGllcyBmb3IgYEJpbmFyeWAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3Bhbiwgb3BlcmF0b3IsIGV4cHIsIGJpbmFyeU9wLCBiaW5hcnlMZWZ0LCBiaW5hcnlSaWdodCkge1xuICAgICAgICBzdXBlcihzcGFuLCBzb3VyY2VTcGFuLCBiaW5hcnlPcCwgYmluYXJ5TGVmdCwgYmluYXJ5UmlnaHQpO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHRoaXMuZXhwciA9IGV4cHI7XG4gICAgICAgIC8vIFJlZGVjbGFyZSB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBpbmhlcml0ZWQgZnJvbSBgQmluYXJ5YCBhcyBgbmV2ZXJgLCBhcyBjb25zdW1lcnMgc2hvdWxkIG5vdFxuICAgICAgICAvLyBkZXBlbmQgb24gdGhlc2UgZmllbGRzIHdoZW4gb3BlcmF0aW5nIG9uIGBVbmFyeWAuXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XG4gICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLnZpc2l0VW5hcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRVbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdEJpbmFyeSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBQcmVmaXhOb3QgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0UHJlZml4Tm90KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIE5vbk51bGxBc3NlcnQgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIGV4cHJlc3Npb24pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0Tm9uTnVsbEFzc2VydCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBDYWxsIGV4dGVuZHMgQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBzb3VyY2VTcGFuLCByZWNlaXZlciwgYXJncywgYXJndW1lbnRTcGFuKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4pO1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuYXJndW1lbnRTcGFuID0gYXJndW1lbnRTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENhbGwodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgU2FmZUNhbGwgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhcmd1bWVudFNwYW4pIHtcbiAgICAgICAgc3VwZXIoc3Bhbiwgc291cmNlU3Bhbik7XG4gICAgICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICAgICAgdGhpcy5hcmd1bWVudFNwYW4gPSBhcmd1bWVudFNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0U2FmZUNhbGwodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWNvcmRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiBhIHRleHQgc3BhbiBpbiBhIHNvdXJjZSBmaWxlLCB3aGVyZSBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgdGhlXG4gKiBzdGFydGluZyBhbmQgZW5kaW5nIGJ5dGUgb2Zmc2V0cywgcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdGV4dCBzcGFuIGluIGEgc291cmNlIGZpbGUuXG4gKi9cbmNsYXNzIEFic29sdXRlU291cmNlU3BhbiB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgIH1cbn1cbmNsYXNzIEFTVFdpdGhTb3VyY2UgZXh0ZW5kcyBBU1Qge1xuICAgIGNvbnN0cnVjdG9yKGFzdCwgc291cmNlLCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGVycm9ycykge1xuICAgICAgICBzdXBlcihuZXcgUGFyc2VTcGFuKDAsIHNvdXJjZSA9PT0gbnVsbCA/IDAgOiBzb3VyY2UubGVuZ3RoKSwgbmV3IEFic29sdXRlU291cmNlU3BhbihhYnNvbHV0ZU9mZnNldCwgc291cmNlID09PSBudWxsID8gYWJzb2x1dGVPZmZzZXQgOiBhYnNvbHV0ZU9mZnNldCArIHNvdXJjZS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5hc3QgPSBhc3Q7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0ID0gbnVsbCkge1xuICAgICAgICBpZiAodmlzaXRvci52aXNpdEFTVFdpdGhTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0QVNUV2l0aFNvdXJjZSh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hc3QudmlzaXQodmlzaXRvciwgY29udGV4dCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5zb3VyY2V9IGluICR7dGhpcy5sb2NhdGlvbn1gO1xuICAgIH1cbn1cbmNsYXNzIFZhcmlhYmxlQmluZGluZyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNvdXJjZVNwYW4gZW50aXJlIHNwYW4gb2YgdGhlIGJpbmRpbmcuXG4gICAgICogQHBhcmFtIGtleSBuYW1lIG9mIHRoZSBMSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKiBAcGFyYW0gdmFsdWUgb3B0aW9uYWwgdmFsdWUgZm9yIHRoZSBSSFMgYWxvbmcgd2l0aCBpdHMgc3Bhbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbkJpbmRpbmcge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIGVudGlyZSBzcGFuIG9mIHRoZSBiaW5kaW5nLlxuICAgICAqIEBwYXJhbSBrZXkgYmluZGluZyBuYW1lLCBsaWtlIG5nRm9yT2YsIG5nRm9yVHJhY2tCeSwgbmdJZiwgYWxvbmcgd2l0aCBpdHNcbiAgICAgKiBzcGFuLiBOb3RlIHRoYXQgdGhlIGxlbmd0aCBvZiB0aGUgc3BhbiBtYXkgbm90IGJlIHRoZSBzYW1lIGFzXG4gICAgICogYGtleS5zb3VyY2UubGVuZ3RoYC4gRm9yIGV4YW1wbGUsXG4gICAgICogMS4ga2V5LnNvdXJjZSA9IG5nRm9yLCBrZXkuc3BhbiBpcyBmb3IgXCJuZ0ZvclwiXG4gICAgICogMi4ga2V5LnNvdXJjZSA9IG5nRm9yT2YsIGtleS5zcGFuIGlzIGZvciBcIm9mXCJcbiAgICAgKiAzLiBrZXkuc291cmNlID0gbmdGb3JUcmFja0J5LCBrZXkuc3BhbiBpcyBmb3IgXCJ0cmFja0J5XCJcbiAgICAgKiBAcGFyYW0gdmFsdWUgb3B0aW9uYWwgZXhwcmVzc2lvbiBmb3IgdGhlIFJIUy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuY2xhc3MgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgdmlzaXQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3QgdmlzaXRzIGV2ZXJ5IG5vZGUuXG4gICAgICAgIC8vIENsYXNzZXMgdGhhdCBleHRlbmQgUmVjdXJzaXZlQXN0VmlzaXRvciBzaG91bGQgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyB0byBzZWxlY3RpdmVseSB2aXNpdCB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICAgIGFzdC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRVbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZXhwciwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0QmluYXJ5KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5sZWZ0LCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmlnaHQsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdENoYWluKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmNvbmRpdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnRydWVFeHAsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5mYWxzZUV4cCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QuZXhwLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmtleSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0S2V5ZWRXcml0ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5rZXksIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC52YWx1ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucywgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QudmFsdWVzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRQcmVmaXhOb3QoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy52aXNpdChhc3QudmFsdWUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LnJlY2VpdmVyLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnZpc2l0KGFzdC5yZWNlaXZlciwgY29udGV4dCk7XG4gICAgICAgIHRoaXMudmlzaXQoYXN0LmtleSwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRTYWZlQ2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52aXNpdChhc3QucmVjZWl2ZXIsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgQXN0VmlzaXRvciBpbnRlcmZhY2UsIGp1c3QgYSBoZWxwZXIgbWV0aG9kXG4gICAgdmlzaXRBbGwoYXN0cywgY29udGV4dCkge1xuICAgICAgICBmb3IgKGNvbnN0IGFzdCBvZiBhc3RzKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KGFzdCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBBc3RUcmFuc2Zvcm1lciB7XG4gICAgdmlzaXRJbXBsaWNpdFJlY2VpdmVyKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFRoaXNSZWNlaXZlcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEludGVycG9sYXRpb24oYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3Quc3RyaW5ncywgdGhpcy52aXNpdEFsbChhc3QuZXhwcmVzc2lvbnMpKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QudmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlXcml0ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3QubmFtZSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVQcm9wZXJ0eVJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QubmFtZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0Lm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxBcnJheShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsQXJyYXkoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucykpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5rZXlzLCB0aGlzLnZpc2l0QWxsKGFzdC52YWx1ZXMpKTtcbiAgICB9XG4gICAgdmlzaXRVbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVQbHVzKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHIudmlzaXQodGhpcykpO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFVuYXJ5LmNyZWF0ZU1pbnVzKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cHIudmlzaXQodGhpcykpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdW5hcnkgb3BlcmF0b3IgJHthc3Qub3BlcmF0b3J9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRCaW5hcnkoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm9wZXJhdGlvbiwgYXN0LmxlZnQudmlzaXQodGhpcyksIGFzdC5yaWdodC52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0UHJlZml4Tm90KGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5leHByZXNzaW9uLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXROb25OdWxsQXNzZXJ0KGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vbk51bGxBc3NlcnQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIHZpc2l0Q29uZGl0aW9uYWwoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpLCBhc3QudHJ1ZUV4cC52aXNpdCh0aGlzKSwgYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmRpbmdQaXBlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmV4cC52aXNpdCh0aGlzKSwgYXN0Lm5hbWUsIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpLCBhc3QubmFtZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIGFzdC5rZXkudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdEtleWVkV3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgYXN0LmtleS52aXNpdCh0aGlzKSwgYXN0LnZhbHVlLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRDYWxsKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IENhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyksIHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpLCBhc3QuYXJndW1lbnRTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRTYWZlQ2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKSwgdGhpcy52aXNpdEFsbChhc3QuYXJncyksIGFzdC5hcmd1bWVudFNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEFsbChhc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFzdHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc1tpXSA9IGFzdHNbaV0udmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdmlzaXRDaGFpbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFpbihhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKSk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUtleWVkUmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpLCBhc3Qua2V5LnZpc2l0KHRoaXMpKTtcbiAgICB9XG59XG4vLyBBIHRyYW5zZm9ybWVyIHRoYXQgb25seSBjcmVhdGVzIG5ldyBub2RlcyBpZiB0aGUgdHJhbnNmb3JtZXIgbWFrZXMgYSBjaGFuZ2Ugb3Jcbi8vIGEgY2hhbmdlIGlzIG1hZGUgYSBjaGlsZCBub2RlLlxuY2xhc3MgQXN0TWVtb3J5RWZmaWNpZW50VHJhbnNmb3JtZXIge1xuICAgIHZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0SW50ZXJwb2xhdGlvbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0cmluZ3MsIGV4cHJlc3Npb25zKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChyZWNlaXZlciAhPT0gYXN0LnJlY2VpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BlcnR5UmVhZChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGFzdC5uYW1lU3BhbiwgcmVjZWl2ZXIsIGFzdC5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFzdC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgdmFsdWUgIT09IGFzdC52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eVdyaXRlKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVyID0gYXN0LnJlY2VpdmVyLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlUHJvcGVydHlSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm5hbWVTcGFuLCByZWNlaXZlciwgYXN0Lm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zICE9PSBhc3QuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52aXNpdEFsbChhc3QudmFsdWVzKTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPT0gYXN0LnZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsTWFwKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0LmtleXMsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRVbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwciA9IGFzdC5leHByLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAoZXhwciAhPT0gYXN0LmV4cHIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYXN0Lm9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVQbHVzKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcik7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVNaW51cyhhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cHIpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1bmFyeSBvcGVyYXRvciAke2FzdC5vcGVyYXRvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IGFzdC5sZWZ0LnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCByaWdodCA9IGFzdC5yaWdodC52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGxlZnQgIT09IGFzdC5sZWZ0IHx8IHJpZ2h0ICE9PSBhc3QucmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmluYXJ5KGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXN0Lm9wZXJhdGlvbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0UHJlZml4Tm90KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYXN0LmV4cHJlc3Npb24udmlzaXQodGhpcyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uICE9PSBhc3QuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcmVmaXhOb3QoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBhc3QuZXhwcmVzc2lvbi52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24gIT09IGFzdC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vbk51bGxBc3NlcnQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjb25kaXRpb24gPSBhc3QuY29uZGl0aW9uLnZpc2l0KHRoaXMpO1xuICAgICAgICBjb25zdCB0cnVlRXhwID0gYXN0LnRydWVFeHAudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGZhbHNlRXhwID0gYXN0LmZhbHNlRXhwLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAoY29uZGl0aW9uICE9PSBhc3QuY29uZGl0aW9uIHx8IHRydWVFeHAgIT09IGFzdC50cnVlRXhwIHx8IGZhbHNlRXhwICE9PSBhc3QuZmFsc2VFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZGl0aW9uYWwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBjb25kaXRpb24sIHRydWVFeHAsIGZhbHNlRXhwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFBpcGUoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGFzdC5leHAudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKGV4cCAhPT0gYXN0LmV4cCB8fCBhcmdzICE9PSBhc3QuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nUGlwZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIGV4cCwgYXN0Lm5hbWUsIGFyZ3MsIGFzdC5uYW1lU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRLZXllZFJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3Qga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKG9iaiAhPT0gYXN0LnJlY2VpdmVyIHx8IGtleSAhPT0gYXN0LmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLZXllZFJlYWQoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBvYmosIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRLZXllZFdyaXRlKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBvYmogPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGtleSA9IGFzdC5rZXkudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXN0LnZhbHVlLnZpc2l0KHRoaXMpO1xuICAgICAgICBpZiAob2JqICE9PSBhc3QucmVjZWl2ZXIgfHwga2V5ICE9PSBhc3Qua2V5IHx8IHZhbHVlICE9PSBhc3QudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZShhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG4gICAgdmlzaXRBbGwoYXN0cykge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgbGV0IG1vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXN0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBhc3RzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbC52aXNpdCh0aGlzKTtcbiAgICAgICAgICAgIHJlc1tpXSA9IHZhbHVlO1xuICAgICAgICAgICAgbW9kaWZpZWQgPSBtb2RpZmllZCB8fCB2YWx1ZSAhPT0gb3JpZ2luYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkID8gcmVzIDogYXN0cztcbiAgICB9XG4gICAgdmlzaXRDaGFpbihhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSB0aGlzLnZpc2l0QWxsKGFzdC5leHByZXNzaW9ucyk7XG4gICAgICAgIGlmIChleHByZXNzaW9ucyAhPT0gYXN0LmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoYWluKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgZXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXIudmlzaXQodGhpcyk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnZpc2l0QWxsKGFzdC5hcmdzKTtcbiAgICAgICAgaWYgKHJlY2VpdmVyICE9PSBhc3QucmVjZWl2ZXIgfHwgYXJncyAhPT0gYXN0LmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhc3QuYXJndW1lbnRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFNhZmVDYWxsKGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMudmlzaXRBbGwoYXN0LmFyZ3MpO1xuICAgICAgICBpZiAocmVjZWl2ZXIgIT09IGFzdC5yZWNlaXZlciB8fCBhcmdzICE9PSBhc3QuYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlQ2FsbChhc3Quc3BhbiwgYXN0LnNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhc3QuYXJndW1lbnRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cbiAgICB2aXNpdFNhZmVLZXllZFJlYWQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IGFzdC5yZWNlaXZlci52aXNpdCh0aGlzKTtcbiAgICAgICAgY29uc3Qga2V5ID0gYXN0LmtleS52aXNpdCh0aGlzKTtcbiAgICAgICAgaWYgKG9iaiAhPT0gYXN0LnJlY2VpdmVyIHx8IGtleSAhPT0gYXN0LmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTYWZlS2V5ZWRSZWFkKGFzdC5zcGFuLCBhc3Quc291cmNlU3Bhbiwgb2JqLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxufVxuLy8gQmluZGluZ3NcbmNsYXNzIFBhcnNlZFByb3BlcnR5IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBleHByZXNzaW9uLCB0eXBlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5rZXlTcGFuID0ga2V5U3BhbjtcbiAgICAgICAgdGhpcy52YWx1ZVNwYW4gPSB2YWx1ZVNwYW47XG4gICAgICAgIHRoaXMuaXNMaXRlcmFsID0gdGhpcy50eXBlID09PSBQYXJzZWRQcm9wZXJ0eVR5cGUuTElURVJBTF9BVFRSO1xuICAgICAgICB0aGlzLmlzQW5pbWF0aW9uID0gdGhpcy50eXBlID09PSBQYXJzZWRQcm9wZXJ0eVR5cGUuQU5JTUFUSU9OO1xuICAgIH1cbn1cbnZhciBQYXJzZWRQcm9wZXJ0eVR5cGU7XG4oZnVuY3Rpb24gKFBhcnNlZFByb3BlcnR5VHlwZSkge1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBQYXJzZWRQcm9wZXJ0eVR5cGVbUGFyc2VkUHJvcGVydHlUeXBlW1wiTElURVJBTF9BVFRSXCJdID0gMV0gPSBcIkxJVEVSQUxfQVRUUlwiO1xuICAgIFBhcnNlZFByb3BlcnR5VHlwZVtQYXJzZWRQcm9wZXJ0eVR5cGVbXCJBTklNQVRJT05cIl0gPSAyXSA9IFwiQU5JTUFUSU9OXCI7XG59KShQYXJzZWRQcm9wZXJ0eVR5cGUgfHwgKFBhcnNlZFByb3BlcnR5VHlwZSA9IHt9KSk7XG5jbGFzcyBQYXJzZWRFdmVudCB7XG4gICAgLy8gUmVndWxhciBldmVudHMgaGF2ZSBhIHRhcmdldFxuICAgIC8vIEFuaW1hdGlvbiBldmVudHMgaGF2ZSBhIHBoYXNlXG4gICAgY29uc3RydWN0b3IobmFtZSwgdGFyZ2V0T3JQaGFzZSwgdHlwZSwgaGFuZGxlciwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIGtleVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50YXJnZXRPclBoYXNlID0gdGFyZ2V0T3JQaGFzZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5oYW5kbGVyU3BhbiA9IGhhbmRsZXJTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2VkVmFyaWFibGUgcmVwcmVzZW50cyBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uIGluIGEgbWljcm9zeW50YXggZXhwcmVzc2lvbi5cbiAqL1xuY2xhc3MgUGFyc2VkVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNvdXJjZVNwYW4gPSBzb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmtleVNwYW4gPSBrZXlTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlU3BhbiA9IHZhbHVlU3BhbjtcbiAgICB9XG59XG5jbGFzcyBCb3VuZEVsZW1lbnRQcm9wZXJ0eSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgc2VjdXJpdHlDb250ZXh0LCB2YWx1ZSwgdW5pdCwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VjdXJpdHlDb250ZXh0ID0gc2VjdXJpdHlDb250ZXh0O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgIH1cbn1cblxuY2xhc3MgRXZlbnRIYW5kbGVyVmFycyB7XG59XG5FdmVudEhhbmRsZXJWYXJzLmV2ZW50ID0gdmFyaWFibGUoJyRldmVudCcpO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBBU1QgaW50byBhbiBleGVjdXRhYmxlIG91dHB1dCBBU1QsIGFzc3VtaW5nIHRoZSBleHByZXNzaW9uIGlzXG4gKiB1c2VkIGluIGFuIGFjdGlvbiBiaW5kaW5nIChlLmcuIGFuIGV2ZW50IGhhbmRsZXIpLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0QWN0aW9uQmluZGluZyhsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBhY3Rpb24sIGJpbmRpbmdJZCwgYmFzZVNvdXJjZVNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcywgZ2xvYmFscykge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKGdsb2JhbHMpO1xuICAgIH1cbiAgICBjb25zdCBhY3Rpb25XaXRob3V0QnVpbHRpbnMgPSBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnMoe1xuICAgICAgICBjcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXI6IChhcmdDb3VudCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90ZTogbm8gY2FjaGluZyBmb3IgbGl0ZXJhbCBhcnJheXMgaW4gYWN0aW9ucy5cbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gbGl0ZXJhbEFycihhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlTGl0ZXJhbE1hcENvbnZlcnRlcjogKGtleXMpID0+IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IG5vIGNhY2hpbmcgZm9yIGxpdGVyYWwgbWFwcyBpbiBhY3Rpb25zLlxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0ga2V5cy5tYXAoKGssIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogay5rZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlZDogay5xdW90ZWQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsTWFwKGVudHJpZXMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlUGlwZUNvbnZlcnRlcjogKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCBTdGF0ZTogQWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgdG8gY29udGFpbiBwaXBlcy4gUGlwZTogJHtuYW1lfWApO1xuICAgICAgICB9XG4gICAgfSwgYWN0aW9uKTtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9Bc3RUb0lyVmlzaXRvcihsb2NhbFJlc29sdmVyLCBpbXBsaWNpdFJlY2VpdmVyLCBiaW5kaW5nSWQsIC8qIHN1cHBvcnRzSW50ZXJwb2xhdGlvbiAqLyBmYWxzZSwgYmFzZVNvdXJjZVNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcyk7XG4gICAgY29uc3QgYWN0aW9uU3RtdHMgPSBbXTtcbiAgICBmbGF0dGVuU3RhdGVtZW50cyhhY3Rpb25XaXRob3V0QnVpbHRpbnMudmlzaXQodmlzaXRvciwgX01vZGUuU3RhdGVtZW50KSwgYWN0aW9uU3RtdHMpO1xuICAgIHByZXBlbmRUZW1wb3JhcnlEZWNscyh2aXNpdG9yLnRlbXBvcmFyeUNvdW50LCBiaW5kaW5nSWQsIGFjdGlvblN0bXRzKTtcbiAgICBpZiAodmlzaXRvci51c2VzSW1wbGljaXRSZWNlaXZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyLm5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluZGV4ID0gYWN0aW9uU3RtdHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdEluZGV4ID49IDApIHtcbiAgICAgICAgY29uc3QgbGFzdFN0YXRlbWVudCA9IGFjdGlvblN0bXRzW2xhc3RJbmRleF07XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBleHByZXNzaW9uIHN0YXRlbWVudCBpcyByZXR1cm5lZFxuICAgICAgICBpZiAobGFzdFN0YXRlbWVudCBpbnN0YW5jZW9mIEV4cHJlc3Npb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIGFjdGlvblN0bXRzW2xhc3RJbmRleF0gPSBuZXcgUmV0dXJuU3RhdGVtZW50KGxhc3RTdGF0ZW1lbnQuZXhwcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdGlvblN0bXRzO1xufVxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5QmluZGluZ0J1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIHJldHVybiBjb252ZXJ0QnVpbHRpbnMoY29udmVydGVyRmFjdG9yeSwgYXN0KTtcbn1cbmNsYXNzIENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHN0bXRzLCBjdXJyVmFsRXhwcikge1xuICAgICAgICB0aGlzLnN0bXRzID0gc3RtdHM7XG4gICAgICAgIHRoaXMuY3VyclZhbEV4cHIgPSBjdXJyVmFsRXhwcjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBleHByZXNzaW9uIEFTVCBpbnRvIGFuIGV4ZWN1dGFibGUgb3V0cHV0IEFTVCwgYXNzdW1pbmcgdGhlIGV4cHJlc3Npb25cbiAqIGlzIHVzZWQgaW4gcHJvcGVydHkgYmluZGluZy4gVGhlIGV4cHJlc3Npb24gaGFzIHRvIGJlIHByZXByb2Nlc3NlZCB2aWFcbiAqIGBjb252ZXJ0UHJvcGVydHlCaW5kaW5nQnVpbHRpbnNgLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGV4cHJlc3Npb25XaXRob3V0QnVpbHRpbnMsIGJpbmRpbmdJZCkge1xuICAgIGlmICghbG9jYWxSZXNvbHZlcikge1xuICAgICAgICBsb2NhbFJlc29sdmVyID0gbmV3IERlZmF1bHRMb2NhbFJlc29sdmVyKCk7XG4gICAgfVxuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgLyogc3VwcG9ydHNJbnRlcnBvbGF0aW9uICovIGZhbHNlKTtcbiAgICBjb25zdCBvdXRwdXRFeHByID0gZXhwcmVzc2lvbldpdGhvdXRCdWlsdGlucy52aXNpdCh2aXNpdG9yLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICBjb25zdCBzdG10cyA9IGdldFN0YXRlbWVudHNGcm9tVmlzaXRvcih2aXNpdG9yLCBiaW5kaW5nSWQpO1xuICAgIGlmICh2aXNpdG9yLnVzZXNJbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgIGxvY2FsUmVzb2x2ZXIubm90aWZ5SW1wbGljaXRSZWNlaXZlclVzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbnZlcnRQcm9wZXJ0eUJpbmRpbmdSZXN1bHQoc3RtdHMsIG91dHB1dEV4cHIpO1xufVxuLyoqXG4gKiBHaXZlbiBzb21lIGV4cHJlc3Npb24sIHN1Y2ggYXMgYSBiaW5kaW5nIG9yIGludGVycG9sYXRpb24gZXhwcmVzc2lvbiwgYW5kIGEgY29udGV4dCBleHByZXNzaW9uIHRvXG4gKiBsb29rIHZhbHVlcyB1cCBvbiwgdmlzaXQgZWFjaCBmYWNldCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiByZXNvbHZpbmcgdmFsdWVzIGZyb20gdGhlIGNvbnRleHRcbiAqIGV4cHJlc3Npb24gc3VjaCB0aGF0IGEgbGlzdCBvZiBhcmd1bWVudHMgY2FuIGJlIGRlcml2ZWQgZnJvbSB0aGUgZm91bmQgdmFsdWVzIHRoYXQgY2FuIGJlIHVzZWQgYXNcbiAqIGFyZ3VtZW50cyB0byBhbiBleHRlcm5hbCB1cGRhdGUgaW5zdHJ1Y3Rpb24uXG4gKlxuICogQHBhcmFtIGxvY2FsUmVzb2x2ZXIgVGhlIHJlc29sdmVyIHRvIHVzZSB0byBsb29rIHVwIGV4cHJlc3Npb25zIGJ5IG5hbWUgYXBwcm9wcmlhdGVseVxuICogQHBhcmFtIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIHRoZSBjb250ZXh0IHZhcmlhYmxlIHVzZWQgdG8gY3JlYXRlXG4gKiB0aGUgZmluYWwgYXJndW1lbnQgZXhwcmVzc2lvbnNcbiAqIEBwYXJhbSBleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCBUaGUgZXhwcmVzc2lvbiB0byB2aXNpdCB0byBmaWd1cmUgb3V0IHdoYXQgdmFsdWVzIG5lZWQgdG9cbiAqIGJlIHJlc29sdmVkIGFuZCB3aGF0IGFyZ3VtZW50cyBsaXN0IHRvIGJ1aWxkLlxuICogQHBhcmFtIGJpbmRpbmdJZCBBIG5hbWUgcHJlZml4IHVzZWQgdG8gY3JlYXRlIHRlbXBvcmFyeSB2YXJpYWJsZSBuYW1lcyBpZiB0aGV5J3JlIG5lZWRlZCBmb3IgdGhlXG4gKiBhcmd1bWVudHMgZ2VuZXJhdGVkXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBleHByZXNzaW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIHRvIGluc3RydWN0aW9uIGV4cHJlc3Npb25zIGxpa2VcbiAqIGBvLmltcG9ydEV4cHIoUjMucHJvcGVydHlJbnRlcnBvbGF0ZSkuY2FsbEZuKHJlc3VsdClgXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRVcGRhdGVBcmd1bWVudHMobG9jYWxSZXNvbHZlciwgY29udGV4dFZhcmlhYmxlRXhwcmVzc2lvbiwgZXhwcmVzc2lvbldpdGhBcmd1bWVudHNUb0V4dHJhY3QsIGJpbmRpbmdJZCkge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0FzdFRvSXJWaXNpdG9yKGxvY2FsUmVzb2x2ZXIsIGNvbnRleHRWYXJpYWJsZUV4cHJlc3Npb24sIGJpbmRpbmdJZCwgLyogc3VwcG9ydHNJbnRlcnBvbGF0aW9uICovIHRydWUpO1xuICAgIGNvbnN0IG91dHB1dEV4cHIgPSB2aXNpdG9yLnZpc2l0SW50ZXJwb2xhdGlvbihleHByZXNzaW9uV2l0aEFyZ3VtZW50c1RvRXh0cmFjdCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgaWYgKHZpc2l0b3IudXNlc0ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgbG9jYWxSZXNvbHZlci5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0bXRzID0gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCk7XG4gICAgY29uc3QgYXJncyA9IG91dHB1dEV4cHIuYXJncztcbiAgICByZXR1cm4geyBzdG10cywgYXJncyB9O1xufVxuZnVuY3Rpb24gZ2V0U3RhdGVtZW50c0Zyb21WaXNpdG9yKHZpc2l0b3IsIGJpbmRpbmdJZCkge1xuICAgIGNvbnN0IHN0bXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdG9yLnRlbXBvcmFyeUNvdW50OyBpKyspIHtcbiAgICAgICAgc3RtdHMucHVzaCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXRzO1xufVxuZnVuY3Rpb24gY29udmVydEJ1aWx0aW5zKGNvbnZlcnRlckZhY3RvcnksIGFzdCkge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0J1aWx0aW5Bc3RDb252ZXJ0ZXIoY29udmVydGVyRmFjdG9yeSk7XG4gICAgcmV0dXJuIGFzdC52aXNpdCh2aXNpdG9yKTtcbn1cbmZ1bmN0aW9uIHRlbXBvcmFyeU5hbWUoYmluZGluZ0lkLCB0ZW1wb3JhcnlOdW1iZXIpIHtcbiAgICByZXR1cm4gYHRtcF8ke2JpbmRpbmdJZH1fJHt0ZW1wb3JhcnlOdW1iZXJ9YDtcbn1cbmZ1bmN0aW9uIHRlbXBvcmFyeURlY2xhcmF0aW9uKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBEZWNsYXJlVmFyU3RtdCh0ZW1wb3JhcnlOYW1lKGJpbmRpbmdJZCwgdGVtcG9yYXJ5TnVtYmVyKSk7XG59XG5mdW5jdGlvbiBwcmVwZW5kVGVtcG9yYXJ5RGVjbHModGVtcG9yYXJ5Q291bnQsIGJpbmRpbmdJZCwgc3RhdGVtZW50cykge1xuICAgIGZvciAobGV0IGkgPSB0ZW1wb3JhcnlDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YXRlbWVudHMudW5zaGlmdCh0ZW1wb3JhcnlEZWNsYXJhdGlvbihiaW5kaW5nSWQsIGkpKTtcbiAgICB9XG59XG52YXIgX01vZGU7XG4oZnVuY3Rpb24gKF9Nb2RlKSB7XG4gICAgX01vZGVbX01vZGVbXCJTdGF0ZW1lbnRcIl0gPSAwXSA9IFwiU3RhdGVtZW50XCI7XG4gICAgX01vZGVbX01vZGVbXCJFeHByZXNzaW9uXCJdID0gMV0gPSBcIkV4cHJlc3Npb25cIjtcbn0pKF9Nb2RlIHx8IChfTW9kZSA9IHt9KSk7XG5mdW5jdGlvbiBlbnN1cmVTdGF0ZW1lbnRNb2RlKG1vZGUsIGFzdCkge1xuICAgIGlmIChtb2RlICE9PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHN0YXRlbWVudCwgYnV0IHNhdyAke2FzdH1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVFeHByZXNzaW9uTW9kZShtb2RlLCBhc3QpIHtcbiAgICBpZiAobW9kZSAhPT0gX01vZGUuRXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIGV4cHJlc3Npb24sIGJ1dCBzYXcgJHthc3R9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgZXhwcikge1xuICAgIGlmIChtb2RlID09PSBfTW9kZS5TdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGV4cHIudG9TdG10KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG59XG5jbGFzcyBfQnVpbHRpbkFzdENvbnZlcnRlciBleHRlbmRzIEFzdFRyYW5zZm9ybWVyIHtcbiAgICBjb25zdHJ1Y3RvcihfY29udmVydGVyRmFjdG9yeSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5ID0gX2NvbnZlcnRlckZhY3Rvcnk7XG4gICAgfVxuICAgIHZpc2l0UGlwZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFthc3QuZXhwLCAuLi5hc3QuYXJnc10ubWFwKGFzdCA9PiBhc3QudmlzaXQodGhpcywgY29udGV4dCkpO1xuICAgICAgICByZXR1cm4gbmV3IEJ1aWx0aW5GdW5jdGlvbkNhbGwoYXN0LnNwYW4sIGFzdC5zb3VyY2VTcGFuLCBhcmdzLCB0aGlzLl9jb252ZXJ0ZXJGYWN0b3J5LmNyZWF0ZVBpcGVDb252ZXJ0ZXIoYXN0Lm5hbWUsIGFyZ3MubGVuZ3RoKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXN0LmV4cHJlc3Npb25zLm1hcChhc3QgPT4gYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsQXJyYXlDb252ZXJ0ZXIoYXN0LmV4cHJlc3Npb25zLmxlbmd0aCkpO1xuICAgIH1cbiAgICB2aXNpdExpdGVyYWxNYXAoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBhc3QudmFsdWVzLm1hcChhc3QgPT4gYXN0LnZpc2l0KHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFzdC5zcGFuLCBhc3Quc291cmNlU3BhbiwgYXJncywgdGhpcy5fY29udmVydGVyRmFjdG9yeS5jcmVhdGVMaXRlcmFsTWFwQ29udmVydGVyKGFzdC5rZXlzKSk7XG4gICAgfVxufVxuY2xhc3MgX0FzdFRvSXJWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfbG9jYWxSZXNvbHZlciwgX2ltcGxpY2l0UmVjZWl2ZXIsIGJpbmRpbmdJZCwgc3VwcG9ydHNJbnRlcnBvbGF0aW9uLCBiYXNlU291cmNlU3BhbiwgaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIgPSBfbG9jYWxSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlciA9IF9pbXBsaWNpdFJlY2VpdmVyO1xuICAgICAgICB0aGlzLmJpbmRpbmdJZCA9IGJpbmRpbmdJZDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0ludGVycG9sYXRpb24gPSBzdXBwb3J0c0ludGVycG9sYXRpb247XG4gICAgICAgIHRoaXMuYmFzZVNvdXJjZVNwYW4gPSBiYXNlU291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMgPSBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXM7XG4gICAgICAgIHRoaXMuX25vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3Jlc3VsdE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRlbXBvcmFyeSA9IDA7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnVzZXNJbXBsaWNpdFJlY2VpdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIHZpc2l0VW5hcnkoYXN0LCBtb2RlKSB7XG4gICAgICAgIGxldCBvcDtcbiAgICAgICAgc3dpdGNoIChhc3Qub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIG9wID0gVW5hcnlPcGVyYXRvci5QbHVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgb3AgPSBVbmFyeU9wZXJhdG9yLk1pbnVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdG9yICR7YXN0Lm9wZXJhdG9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBuZXcgVW5hcnlPcGVyYXRvckV4cHIob3AsIHRoaXMuX3Zpc2l0KGFzdC5leHByLCBfTW9kZS5FeHByZXNzaW9uKSwgdW5kZWZpbmVkLCB0aGlzLmNvbnZlcnRTb3VyY2VTcGFuKGFzdC5zcGFuKSkpO1xuICAgIH1cbiAgICB2aXNpdEJpbmFyeShhc3QsIG1vZGUpIHtcbiAgICAgICAgbGV0IG9wO1xuICAgICAgICBzd2l0Y2ggKGFzdC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuUGx1cztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTWludXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk11bHRpcGx5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5EaXZpZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk1vZHVsbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkFuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLk9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuRXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIG9wID0gQmluYXJ5T3BlcmF0b3IuTm90RXF1YWxzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLklkZW50aWNhbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Ob3RJZGVudGljYWw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkxvd2VyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5CaWdnZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICAgICAgb3AgPSBCaW5hcnlPcGVyYXRvci5Mb3dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICBvcCA9IEJpbmFyeU9wZXJhdG9yLkJpZ2dlckVxdWFscztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJz8/JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0TnVsbGlzaENvYWxlc2NlKGFzdCwgbW9kZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3BlcmF0aW9uICR7YXN0Lm9wZXJhdGlvbn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbmV3IEJpbmFyeU9wZXJhdG9yRXhwcihvcCwgdGhpcy5fdmlzaXQoYXN0LmxlZnQsIF9Nb2RlLkV4cHJlc3Npb24pLCB0aGlzLl92aXNpdChhc3QucmlnaHQsIF9Nb2RlLkV4cHJlc3Npb24pLCB1bmRlZmluZWQsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfVxuICAgIHZpc2l0Q2hhaW4oYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZVN0YXRlbWVudE1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbGwoYXN0LmV4cHJlc3Npb25zLCBtb2RlKTtcbiAgICB9XG4gICAgdmlzaXRDb25kaXRpb25hbChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl92aXNpdChhc3QuY29uZGl0aW9uLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHZhbHVlLmNvbmRpdGlvbmFsKHRoaXMuX3Zpc2l0KGFzdC50cnVlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5fdmlzaXQoYXN0LmZhbHNlRXhwLCBfTW9kZS5FeHByZXNzaW9uKSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpKTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgc3RhdGU6IFBpcGVzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zLiBQaXBlOiAke2FzdC5uYW1lfWApO1xuICAgIH1cbiAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0LCBtb2RlKSB7XG4gICAgICAgIGVuc3VyZUV4cHJlc3Npb25Nb2RlKG1vZGUsIGFzdCk7XG4gICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5faW1wbGljaXRSZWNlaXZlcjtcbiAgICB9XG4gICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0SW1wbGljaXRSZWNlaXZlcihhc3QsIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdEludGVycG9sYXRpb24oYXN0LCBtb2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0ludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBpbnRlcnBvbGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlRXhwcmVzc2lvbk1vZGUobW9kZSwgYXN0KTtcbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3Quc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChsaXRlcmFsKGFzdC5zdHJpbmdzW2ldKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb25zW2ldLCBfTW9kZS5FeHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKGxpdGVyYWwoYXN0LnN0cmluZ3NbYXN0LnN0cmluZ3MubGVuZ3RoIC0gMV0pKTtcbiAgICAgICAgLy8gSWYgd2UncmUgZGVhbGluZyB3aXRoIGFuIGludGVycG9sYXRpb24gb2YgMSB2YWx1ZSB3aXRoIGFuIGVtcHR5IHByZWZpeCBhbmQgc3VmZml4LCByZWR1Y2UgdGhlXG4gICAgICAgIC8vIGFyZ3MgcmV0dXJuZWQgdG8ganVzdCB0aGUgdmFsdWUsIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcGFzcyBpdCB0byBhIHNwZWNpYWwgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBhc3Quc3RyaW5ncztcbiAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBTaW5nbGUgYXJndW1lbnQgaW50ZXJwb2xhdGUgaW5zdHJ1Y3Rpb25zLlxuICAgICAgICAgICAgYXJncyA9IFthcmdzWzFdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuZXhwcmVzc2lvbnMubGVuZ3RoID49IDkpIHtcbiAgICAgICAgICAgIC8vIDkgb3IgbW9yZSBhcmd1bWVudHMgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGBpbnRlcnBvbGF0ZVZgLXN0eWxlIGluc3RydWN0aW9ucywgd2hpY2ggYWNjZXB0XG4gICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBhcmd1bWVudHNcbiAgICAgICAgICAgIGFyZ3MgPSBbbGl0ZXJhbEFycihhcmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihhcmdzKTtcbiAgICB9XG4gICAgdmlzaXRLZXllZFJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmlzaXQoYXN0LnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKS5rZXkodGhpcy5fdmlzaXQoYXN0LmtleSwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEtleWVkV3JpdGUoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuX3Zpc2l0KGFzdC5rZXksIF9Nb2RlLkV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3Zpc2l0KGFzdC52YWx1ZSwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChvYmogPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsUmVzb2x2ZXIubWF5YmVSZXN0b3JlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb252ZXJ0VG9TdGF0ZW1lbnRJZk5lZWRlZChtb2RlLCBvYmoua2V5KGtleSkuc2V0KHZhbHVlKSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCwgbW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgU3RhdGU6IGxpdGVyYWwgYXJyYXlzIHNob3VsZCBoYXZlIGJlZW4gY29udmVydGVkIGludG8gZnVuY3Rpb25zYCk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QsIG1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIFN0YXRlOiBsaXRlcmFsIG1hcHMgc2hvdWxkIGhhdmUgYmVlbiBjb252ZXJ0ZWQgaW50byBmdW5jdGlvbnNgKTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCwgbW9kZSkge1xuICAgICAgICAvLyBGb3IgbGl0ZXJhbCB2YWx1ZXMgb2YgbnVsbCwgdW5kZWZpbmVkLCB0cnVlLCBvciBmYWxzZSBhbGxvdyB0eXBlIGludGVyZmVyZW5jZVxuICAgICAgICAvLyB0byBpbmZlciB0aGUgdHlwZS5cbiAgICAgICAgY29uc3QgdHlwZSA9IGFzdC52YWx1ZSA9PT0gbnVsbCB8fCBhc3QudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBhc3QudmFsdWUgPT09IHRydWUgfHwgYXN0LnZhbHVlID09PSB0cnVlID9cbiAgICAgICAgICAgIElORkVSUkVEX1RZUEUgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgbGl0ZXJhbChhc3QudmFsdWUsIHR5cGUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKSk7XG4gICAgfVxuICAgIF9nZXRMb2NhbChuYW1lLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxSZXNvbHZlci5nbG9iYWxzPy5oYXMobmFtZSkgJiYgcmVjZWl2ZXIgaW5zdGFuY2VvZiBUaGlzUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFJlc29sdmVyLmdldExvY2FsKG5hbWUpO1xuICAgIH1cbiAgICB2aXNpdFByZWZpeE5vdChhc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIG5vdCh0aGlzLl92aXNpdChhc3QuZXhwcmVzc2lvbiwgX01vZGUuRXhwcmVzc2lvbikpKTtcbiAgICB9XG4gICAgdmlzaXROb25OdWxsQXNzZXJ0KGFzdCwgbW9kZSkge1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGhpcy5fdmlzaXQoYXN0LmV4cHJlc3Npb24sIF9Nb2RlLkV4cHJlc3Npb24pKTtcbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnRNb3N0U2FmZSA9IHRoaXMubGVmdE1vc3RTYWZlTm9kZShhc3QpO1xuICAgICAgICBpZiAobGVmdE1vc3RTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlciA9IHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICBjb25zdCByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZXIgPT09IHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSwgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW1wbGljaXRSZWNlaXZlckFjY2Vzcyhhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjZWl2ZXIucHJvcChhc3QubmFtZSwgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRQcm9wZXJ0eVdyaXRlKGFzdCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZWNlaXZlciA9IHRoaXMuX3Zpc2l0KGFzdC5yZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHByZXZVc2VzSW1wbGljaXRSZWNlaXZlciA9IHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgIGxldCB2YXJFeHByID0gbnVsbDtcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbEV4cHIgPSB0aGlzLl9nZXRMb2NhbChhc3QubmFtZSwgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIGlmIChsb2NhbEV4cHIpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxFeHByIGluc3RhbmNlb2YgUmVhZFByb3BFeHByKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsb2NhbCB2YXJpYWJsZSBpcyBhIHByb3BlcnR5IHJlYWQgZXhwcmVzc2lvbiwgaXQncyBhIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhICdjb250ZXh0LnByb3BlcnR5JyB2YWx1ZSBhbmQgd2lsbCBiZSB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdyaXRlIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHZhckV4cHIgPSBsb2NhbEV4cHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIFwidXNlc0ltcGxpY2l0UmVjZWl2ZXJcIiBzdGF0ZSBzaW5jZSB0aGUgaW1wbGljaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjZWl2ZXIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBhIHJlc29sdmVkIGxvY2FsIGV4cHJlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXNlc0ltcGxpY2l0UmVjZWl2ZXIgPSBwcmV2VXNlc0ltcGxpY2l0UmVjZWl2ZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkSW1wbGljaXRSZWNlaXZlckFjY2Vzcyhhc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgaXQncyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoYXN0LnZhbHVlIGluc3RhbmNlb2YgUHJvcGVydHlSZWFkKSA/IGFzdC52YWx1ZS5uYW1lIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhc3NpZ24gdmFsdWUgXCIke3ZhbHVlfVwiIHRvIHRlbXBsYXRlIHZhcmlhYmxlIFwiJHtyZWNlaXZlcn1cIi4gVGVtcGxhdGUgdmFyaWFibGVzIGFyZSByZWFkLW9ubHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGxvY2FsIGV4cHJlc3Npb24gY291bGQgYmUgcHJvZHVjZWQsIHVzZSB0aGUgb3JpZ2luYWwgcmVjZWl2ZXInc1xuICAgICAgICAvLyBwcm9wZXJ0eSBhcyB0aGUgdGFyZ2V0LlxuICAgICAgICBpZiAodmFyRXhwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyRXhwciA9IHJlY2VpdmVyLnByb3AoYXN0Lm5hbWUsIHRoaXMuY29udmVydFNvdXJjZVNwYW4oYXN0LnNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdmFyRXhwci5zZXQodGhpcy5fdmlzaXQoYXN0LnZhbHVlLCBfTW9kZS5FeHByZXNzaW9uKSkpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVQcm9wZXJ0eVJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdFNhZmVLZXllZFJlYWQoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICB2aXNpdEFsbChhc3RzLCBtb2RlKSB7XG4gICAgICAgIHJldHVybiBhc3RzLm1hcChhc3QgPT4gdGhpcy5fdmlzaXQoYXN0LCBtb2RlKSk7XG4gICAgfVxuICAgIHZpc2l0Q2FsbChhc3QsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbGVmdE1vc3RTYWZlID0gdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCk7XG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgbGVmdE1vc3RTYWZlLCBtb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gdGhpcy52aXNpdEFsbChhc3QuYXJncywgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBCdWlsdGluRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgYXN0LmNvbnZlcnRlcihjb252ZXJ0ZWRBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjZWl2ZXIgPSBhc3QucmVjZWl2ZXI7XG4gICAgICAgIGlmIChyZWNlaXZlciBpbnN0YW5jZW9mIFByb3BlcnR5UmVhZCAmJlxuICAgICAgICAgICAgcmVjZWl2ZXIucmVjZWl2ZXIgaW5zdGFuY2VvZiBJbXBsaWNpdFJlY2VpdmVyICYmXG4gICAgICAgICAgICAhKHJlY2VpdmVyLnJlY2VpdmVyIGluc3RhbmNlb2YgVGhpc1JlY2VpdmVyKSAmJiByZWNlaXZlci5uYW1lID09PSAnJGFueScpIHtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWRBcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjYWxsIHRvICRhbnksIGV4cGVjdGVkIDEgYXJndW1lbnQgYnV0IHJlY2VpdmVkICR7Y29udmVydGVkQXJncy5sZW5ndGggfHwgJ25vbmUnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRUb1N0YXRlbWVudElmTmVlZGVkKG1vZGUsIGNvbnZlcnRlZEFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLl92aXNpdChyZWNlaXZlciwgX01vZGUuRXhwcmVzc2lvbilcbiAgICAgICAgICAgIC5jYWxsRm4oY29udmVydGVkQXJncywgdGhpcy5jb252ZXJ0U291cmNlU3Bhbihhc3Quc3BhbikpO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY2FsbCk7XG4gICAgfVxuICAgIHZpc2l0U2FmZUNhbGwoYXN0LCBtb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRTYWZlQWNjZXNzKGFzdCwgdGhpcy5sZWZ0TW9zdFNhZmVOb2RlKGFzdCksIG1vZGUpO1xuICAgIH1cbiAgICBfdmlzaXQoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3Jlc3VsdE1hcC5nZXQoYXN0KTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHRoaXMsIG1vZGUpO1xuICAgIH1cbiAgICBjb252ZXJ0U2FmZUFjY2Vzcyhhc3QsIGxlZnRNb3N0U2FmZSwgbW9kZSkge1xuICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiBjb250YWlucyBhIHNhZmUgYWNjZXNzIG5vZGUgb24gdGhlIGxlZnQgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvXG4gICAgICAgIC8vIGFuIGV4cHJlc3Npb24gdGhhdCBndWFyZHMgdGhlIGFjY2VzcyB0byB0aGUgbWVtYmVyIGJ5IGNoZWNraW5nIHRoZSByZWNlaXZlciBmb3IgYmxhbmsuIEFzXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBwcm9jZWVkcyBmcm9tIGxlZnQgdG8gcmlnaHQsIHRoZSBsZWZ0IG1vc3QgcGFydCBvZiB0aGUgZXhwcmVzc2lvbiBtdXN0IGJlIGd1YXJkZWRcbiAgICAgICAgLy8gZmlyc3QgYnV0LCBiZWNhdXNlIG1lbWJlciBhY2Nlc3MgaXMgbGVmdCBhc3NvY2lhdGl2ZSwgdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGV4cHJlc3Npb24gaXMgYXRcbiAgICAgICAgLy8gdGhlIHRvcCBvZiB0aGUgQVNULiBUaGUgZGVzaXJlZCByZXN1bHQgcmVxdWlyZXMgbGlmdGluZyBhIGNvcHkgb2YgdGhlIGxlZnQgcGFydCBvZiB0aGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbiB1cCB0byB0ZXN0IGl0IGZvciBibGFuayBiZWZvcmUgZ2VuZXJhdGluZyB0aGUgdW5ndWFyZGVkIHZlcnNpb24uXG4gICAgICAgIC8vIENvbnNpZGVyLCBmb3IgZXhhbXBsZSB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb246IGE/LmIuYz8uZC5lXG4gICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiB0aGUgYXN0OlxuICAgICAgICAvLyAgICAgICAgIC5cbiAgICAgICAgLy8gICAgICAgIC8gXFxcbiAgICAgICAgLy8gICAgICAgPy4gICBlXG4gICAgICAgIC8vICAgICAgLyAgXFxcbiAgICAgICAgLy8gICAgIC4gICAgZFxuICAgICAgICAvLyAgICAvIFxcXG4gICAgICAgIC8vICAgPy4gIGNcbiAgICAgICAgLy8gIC8gIFxcXG4gICAgICAgIC8vIGEgICAgYlxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHRyZWUgc2hvdWxkIGJlIGdlbmVyYXRlZDpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIC8tLS0tID8gLS0tLVxcXG4gICAgICAgIC8vICAgICAgIC8gICAgICB8ICAgICAgXFxcbiAgICAgICAgLy8gICAgIGEgICAvLS0tID8gLS0tXFwgIG51bGxcbiAgICAgICAgLy8gICAgICAgIC8gICAgIHwgICAgIFxcXG4gICAgICAgIC8vICAgICAgIC4gICAgICAuICAgICBudWxsXG4gICAgICAgIC8vICAgICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgICAuICBjICAgLiAgIGVcbiAgICAgICAgLy8gICAgLyBcXCAgICAvIFxcXG4gICAgICAgIC8vICAgYSAgIGIgIC4gICBkXG4gICAgICAgIC8vICAgICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgICAgLiAgIGNcbiAgICAgICAgLy8gICAgICAgLyBcXFxuICAgICAgICAvLyAgICAgIGEgICBiXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHRoZSBmaXJzdCBndWFyZCBjb25kaXRpb24gaXMgdGhlIGxlZnQgaGFuZCBvZiB0aGUgbGVmdCBtb3N0IHNhZmUgYWNjZXNzIG5vZGVcbiAgICAgICAgLy8gd2hpY2ggY29tZXMgaW4gYXMgbGVmdE1vc3RTYWZlIHRvIHRoaXMgcm91dGluZS5cbiAgICAgICAgbGV0IGd1YXJkZWRFeHByZXNzaW9uID0gdGhpcy5fdmlzaXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgbGV0IHRlbXBvcmFyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNUZW1wb3JhcnlJblNhZmVBY2Nlc3MobGVmdE1vc3RTYWZlLnJlY2VpdmVyKSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gaGFzIG1ldGhvZCBjYWxscyBvciBwaXBlcyB0aGVuIHdlIG5lZWQgdG8gc2F2ZSB0aGUgcmVzdWx0IGludG8gYVxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIGF2b2lkIGNhbGxpbmcgc3RhdGVmdWwgb3IgaW1wdXJlIGNvZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgICAgICB0ZW1wb3JhcnkgPSB0aGlzLmFsbG9jYXRlVGVtcG9yYXJ5KCk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgcmVzdWx0IGluIHRoZSB0ZW1wb3JhcnkgdmFyaWFibGVcbiAgICAgICAgICAgIGd1YXJkZWRFeHByZXNzaW9uID0gdGVtcG9yYXJ5LnNldChndWFyZGVkRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAvLyBFbnN1cmUgYWxsIGZ1cnRoZXIgcmVmZXJlbmNlcyB0byB0aGUgZ3VhcmRlZCBleHByZXNzaW9uIHJlZmVyIHRvIHRoZSB0ZW1wb3JhcnkgaW5zdGVhZC5cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdE1hcC5zZXQobGVmdE1vc3RTYWZlLnJlY2VpdmVyLCB0ZW1wb3JhcnkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGd1YXJkZWRFeHByZXNzaW9uLmlzQmxhbmsoKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgYXN0IHRvIGFuIHVuZ3VhcmRlZCBhY2Nlc3MgdG8gdGhlIHJlY2VpdmVyJ3MgbWVtYmVyLiBUaGUgbWFwIHdpbGwgc3Vic3RpdHV0ZVxuICAgICAgICAvLyBsZWZ0TW9zdE5vZGUgd2l0aCBpdHMgdW5ndWFyZGVkIHZlcnNpb24gaW4gdGhlIGNhbGwgdG8gYHRoaXMudmlzaXQoKWAuXG4gICAgICAgIGlmIChsZWZ0TW9zdFNhZmUgaW5zdGFuY2VvZiBTYWZlQ2FsbCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZU1hcC5zZXQobGVmdE1vc3RTYWZlLCBuZXcgQ2FsbChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnNvdXJjZVNwYW4sIGxlZnRNb3N0U2FmZS5yZWNlaXZlciwgbGVmdE1vc3RTYWZlLmFyZ3MsIGxlZnRNb3N0U2FmZS5hcmd1bWVudFNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0TW9zdFNhZmUgaW5zdGFuY2VvZiBTYWZlS2V5ZWRSZWFkKSB7XG4gICAgICAgICAgICB0aGlzLl9ub2RlTWFwLnNldChsZWZ0TW9zdFNhZmUsIG5ldyBLZXllZFJlYWQobGVmdE1vc3RTYWZlLnNwYW4sIGxlZnRNb3N0U2FmZS5zb3VyY2VTcGFuLCBsZWZ0TW9zdFNhZmUucmVjZWl2ZXIsIGxlZnRNb3N0U2FmZS5rZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25vZGVNYXAuc2V0KGxlZnRNb3N0U2FmZSwgbmV3IFByb3BlcnR5UmVhZChsZWZ0TW9zdFNhZmUuc3BhbiwgbGVmdE1vc3RTYWZlLnNvdXJjZVNwYW4sIGxlZnRNb3N0U2FmZS5uYW1lU3BhbiwgbGVmdE1vc3RTYWZlLnJlY2VpdmVyLCBsZWZ0TW9zdFNhZmUubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdGhlIG5vZGUgbm93IHdpdGhvdXQgdGhlIGd1YXJkZWQgbWVtYmVyIGFjY2Vzcy5cbiAgICAgICAgY29uc3QgYWNjZXNzID0gdGhpcy5fdmlzaXQoYXN0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtYXBwaW5nLiBUaGlzIGlzIG5vdCBzdHJpY3RseSByZXF1aXJlZCBhcyB0aGUgY29udmVydGVyIG9ubHkgdHJhdmVyc2VzIGVhY2ggbm9kZVxuICAgICAgICAvLyBvbmNlIGJ1dCBpcyBzYWZlciBpZiB0aGUgY29udmVyc2lvbiBpcyBjaGFuZ2VkIHRvIHRyYXZlcnNlIHRoZSBub2RlcyBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgdGhpcy5fbm9kZU1hcC5kZWxldGUobGVmdE1vc3RTYWZlKTtcbiAgICAgICAgLy8gSWYgd2UgYWxsb2NhdGVkIGEgdGVtcG9yYXJ5LCByZWxlYXNlIGl0LlxuICAgICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm9kdWNlIHRoZSBjb25kaXRpb25hbFxuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgY29uZGl0aW9uLmNvbmRpdGlvbmFsKE5VTExfRVhQUiwgYWNjZXNzKSk7XG4gICAgfVxuICAgIGNvbnZlcnROdWxsaXNoQ29hbGVzY2UoYXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl92aXNpdChhc3QubGVmdCwgX01vZGUuRXhwcmVzc2lvbik7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fdmlzaXQoYXN0LnJpZ2h0LCBfTW9kZS5FeHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5ID0gdGhpcy5hbGxvY2F0ZVRlbXBvcmFyeSgpO1xuICAgICAgICB0aGlzLnJlbGVhc2VUZW1wb3JhcnkodGVtcG9yYXJ5KTtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIGZvbGxvd2luZyBleHByZXNzaW9uLiBJdCBpcyBpZGVudGljYWwgdG8gaG93IFRTXG4gICAgICAgIC8vIHRyYW5zcGlsZXMgYmluYXJ5IGV4cHJlc3Npb25zIHdpdGggYSBudWxsaXNoIGNvYWxlc2Npbmcgb3BlcmF0b3IuXG4gICAgICAgIC8vIGxldCB0ZW1wO1xuICAgICAgICAvLyAodGVtcCA9IGEpICE9PSBudWxsICYmIHRlbXAgIT09IHVuZGVmaW5lZCA/IHRlbXAgOiBiO1xuICAgICAgICByZXR1cm4gY29udmVydFRvU3RhdGVtZW50SWZOZWVkZWQobW9kZSwgdGVtcG9yYXJ5LnNldChsZWZ0KVxuICAgICAgICAgICAgLm5vdElkZW50aWNhbChOVUxMX0VYUFIpXG4gICAgICAgICAgICAuYW5kKHRlbXBvcmFyeS5ub3RJZGVudGljYWwobGl0ZXJhbCh1bmRlZmluZWQpKSlcbiAgICAgICAgICAgIC5jb25kaXRpb25hbCh0ZW1wb3JhcnksIHJpZ2h0KSk7XG4gICAgfVxuICAgIC8vIEdpdmVuIGFuIGV4cHJlc3Npb24gb2YgdGhlIGZvcm0gYT8uYi5jPy5kLmUgdGhlbiB0aGUgbGVmdCBtb3N0IHNhZmUgbm9kZSBpc1xuICAgIC8vIHRoZSAoYT8uYikuIFRoZSAuIGFuZCA/LiBhcmUgbGVmdCBhc3NvY2lhdGl2ZSB0aHVzIGNhbiBiZSByZXdyaXR0ZW4gYXM6XG4gICAgLy8gKCgoKGE/LmMpLmIpLmMpPy5kKS5lLiBUaGlzIHJldHVybnMgdGhlIG1vc3QgZGVlcGx5IG5lc3RlZCBzYWZlIHJlYWQgb3JcbiAgICAvLyBzYWZlIG1ldGhvZCBjYWxsIGFzIHRoaXMgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW5pdGlhbGx5IHRvOlxuICAgIC8vICAgYSA9PSBudWxsID8gbnVsbCA6IGEuYy5iLmM/LmQuZVxuICAgIC8vIHRoZW4gdG86XG4gICAgLy8gICBhID09IG51bGwgPyBudWxsIDogYS5iLmMgPT0gbnVsbCA/IG51bGwgOiBhLmIuYy5kLmVcbiAgICBsZWZ0TW9zdFNhZmVOb2RlKGFzdCkge1xuICAgICAgICBjb25zdCB2aXNpdCA9ICh2aXNpdG9yLCBhc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbm9kZU1hcC5nZXQoYXN0KSB8fCBhc3QpLnZpc2l0KHZpc2l0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXN0LnZpc2l0KHtcbiAgICAgICAgICAgIHZpc2l0VW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRCaW5hcnkoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRDaGFpbihhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Q2FsbChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVDYWxsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRUaGlzUmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRJbnRlcnBvbGF0aW9uKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRXcml0ZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxBcnJheShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxNYXAoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRMaXRlcmFsUHJpbWl0aXZlKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UGlwZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdE5vbk51bGxBc3NlcnQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LnJlY2VpdmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QucmVjZWl2ZXIpIHx8IGFzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFNhZmVLZXllZFJlYWQoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0KHRoaXMsIGFzdC5yZWNlaXZlcikgfHwgYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0cnVlIG9mIHRoZSBBU1QgaW5jbHVkZXMgYSBtZXRob2Qgb3IgYSBwaXBlIGluZGljYXRpbmcgdGhhdCwgaWYgdGhlXG4gICAgLy8gZXhwcmVzc2lvbiBpcyB1c2VkIGFzIHRoZSB0YXJnZXQgb2YgYSBzYWZlIHByb3BlcnR5IG9yIG1ldGhvZCBhY2Nlc3MgdGhlblxuICAgIC8vIHRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBzdG9yZWQgaW50byBhIHRlbXBvcmFyeSB2YXJpYWJsZS5cbiAgICBuZWVkc1RlbXBvcmFyeUluU2FmZUFjY2Vzcyhhc3QpIHtcbiAgICAgICAgY29uc3QgdmlzaXQgPSAodmlzaXRvciwgYXN0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXN0ICYmICh0aGlzLl9ub2RlTWFwLmdldChhc3QpIHx8IGFzdCkudmlzaXQodmlzaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZpc2l0U29tZSA9ICh2aXNpdG9yLCBhc3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhc3Quc29tZShhc3QgPT4gdmlzaXQodmlzaXRvciwgYXN0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhc3QudmlzaXQoe1xuICAgICAgICAgICAgdmlzaXRVbmFyeShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0QmluYXJ5KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QubGVmdCkgfHwgdmlzaXQodGhpcywgYXN0LnJpZ2h0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENoYWluKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENvbmRpdGlvbmFsKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdCh0aGlzLCBhc3QuY29uZGl0aW9uKSB8fCB2aXNpdCh0aGlzLCBhc3QudHJ1ZUV4cCkgfHwgdmlzaXQodGhpcywgYXN0LmZhbHNlRXhwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdENhbGwoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlQ2FsbChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEltcGxpY2l0UmVjZWl2ZXIoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0VGhpc1JlY2VpdmVyKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEludGVycG9sYXRpb24oYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0U29tZSh0aGlzLCBhc3QuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0S2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdEtleWVkV3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbEFycmF5KGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0TGl0ZXJhbE1hcChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdExpdGVyYWxQcmltaXRpdmUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UGlwZShhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByZWZpeE5vdChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0Tm9uTnVsbEFzc2VydChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQodGhpcywgYXN0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0UHJvcGVydHlSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2aXNpdFByb3BlcnR5V3JpdGUoYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc2l0U2FmZVByb3BlcnR5UmVhZChhc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmlzaXRTYWZlS2V5ZWRSZWFkKGFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFsbG9jYXRlVGVtcG9yYXJ5KCkge1xuICAgICAgICBjb25zdCB0ZW1wTnVtYmVyID0gdGhpcy5fY3VycmVudFRlbXBvcmFyeSsrO1xuICAgICAgICB0aGlzLnRlbXBvcmFyeUNvdW50ID0gTWF0aC5tYXgodGhpcy5fY3VycmVudFRlbXBvcmFyeSwgdGhpcy50ZW1wb3JhcnlDb3VudCk7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZFZhckV4cHIodGVtcG9yYXJ5TmFtZSh0aGlzLmJpbmRpbmdJZCwgdGVtcE51bWJlcikpO1xuICAgIH1cbiAgICByZWxlYXNlVGVtcG9yYXJ5KHRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5LS07XG4gICAgICAgIGlmICh0ZW1wb3JhcnkubmFtZSAhPSB0ZW1wb3JhcnlOYW1lKHRoaXMuYmluZGluZ0lkLCB0aGlzLl9jdXJyZW50VGVtcG9yYXJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wb3JhcnkgJHt0ZW1wb3JhcnkubmFtZX0gcmVsZWFzZWQgb3V0IG9mIG9yZGVyYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhYnNvbHV0ZSBgUGFyc2VTb3VyY2VTcGFuYCBmcm9tIHRoZSByZWxhdGl2ZSBgUGFyc2VTcGFuYC5cbiAgICAgKlxuICAgICAqIGBQYXJzZVNwYW5gIG9iamVjdHMgYXJlIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKiBUaGlzIG1ldGhvZCBjb252ZXJ0cyB0aGVzZSB0byBmdWxsIGBQYXJzZVNvdXJjZVNwYW5gIG9iamVjdHMgdGhhdFxuICAgICAqIHNob3cgd2hlcmUgdGhlIHNwYW4gaXMgd2l0aGluIHRoZSBvdmVyYWxsIHNvdXJjZSBmaWxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNwYW4gdGhlIHJlbGF0aXZlIHNwYW4gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyBhIGBQYXJzZVNvdXJjZVNwYW5gIGZvciB0aGUgZ2l2ZW4gc3BhbiBvciBudWxsIGlmIG5vXG4gICAgICogYGJhc2VTb3VyY2VTcGFuYCB3YXMgcHJvdmlkZWQgdG8gdGhpcyBjbGFzcy5cbiAgICAgKi9cbiAgICBjb252ZXJ0U291cmNlU3BhbihzcGFuKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VTb3VyY2VTcGFuKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuYmFzZVNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHNwYW4uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5iYXNlU291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoc3Bhbi5lbmQpO1xuICAgICAgICAgICAgY29uc3QgZnVsbFN0YXJ0ID0gdGhpcy5iYXNlU291cmNlU3Bhbi5mdWxsU3RhcnQubW92ZUJ5KHNwYW4uc3RhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oc3RhcnQsIGVuZCwgZnVsbFN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBBZGRzIHRoZSBuYW1lIG9mIGFuIEFTVCB0byB0aGUgbGlzdCBvZiBpbXBsaWNpdCByZWNlaXZlciBhY2Nlc3Nlcy4gKi9cbiAgICBhZGRJbXBsaWNpdFJlY2VpdmVyQWNjZXNzKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wbGljaXRSZWNlaXZlckFjY2Vzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmltcGxpY2l0UmVjZWl2ZXJBY2Nlc3Nlcy5hZGQobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBmbGF0dGVuU3RhdGVtZW50cyhhcmcsIG91dHB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgYXJnLmZvckVhY2goKGVudHJ5KSA9PiBmbGF0dGVuU3RhdGVtZW50cyhlbnRyeSwgb3V0cHV0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChhcmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb3BlcmF0aW9uJyk7XG59XG5jbGFzcyBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIobnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuaXNDb25zdGFudCA9IHVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLmlzRXF1aXZhbGVudCA9IHVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLnZpc2l0RXhwcmVzc2lvbiA9IHVuc3VwcG9ydGVkO1xuICAgIH1cbn1cbmNsYXNzIERlZmF1bHRMb2NhbFJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3RvcihnbG9iYWxzKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgfVxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7IH1cbiAgICBtYXliZVJlc3RvcmVWaWV3KCkgeyB9XG4gICAgZ2V0TG9jYWwobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gRXZlbnRIYW5kbGVyVmFycy5ldmVudC5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gRXZlbnRIYW5kbGVyVmFycy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBCdWlsdGluRnVuY3Rpb25DYWxsIGV4dGVuZHMgQ2FsbCB7XG4gICAgY29uc3RydWN0b3Ioc3Bhbiwgc291cmNlU3BhbiwgYXJncywgY29udmVydGVyKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHNvdXJjZVNwYW4sIG5ldyBFbXB0eUV4cHIoc3Bhbiwgc291cmNlU3BhbiksIGFyZ3MsIG51bGwpO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlcjtcbiAgICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09IFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgPT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vXG4vLyAgICAgICAgRE8gTk9UIEVESVQgVEhJUyBMSVNUIE9GIFNFQ1VSSVRZIFNFTlNJVElWRSBQUk9QRVJUSUVTIFdJVEhPVVQgQSBTRUNVUklUWSBSRVZJRVchXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjaCBvdXQgdG8gbXByb2JzdCBmb3IgZGV0YWlscy5cbi8vXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vKiogTWFwIGZyb20gdGFnTmFtZXxwcm9wZXJ0eU5hbWUgdG8gU2VjdXJpdHlDb250ZXh0LiBQcm9wZXJ0aWVzIGFwcGx5aW5nIHRvIGFsbCB0YWdzIHVzZSAnKicuICovXG5sZXQgX1NFQ1VSSVRZX1NDSEVNQTtcbmZ1bmN0aW9uIFNFQ1VSSVRZX1NDSEVNQSgpIHtcbiAgICBpZiAoIV9TRUNVUklUWV9TQ0hFTUEpIHtcbiAgICAgICAgX1NFQ1VSSVRZX1NDSEVNQSA9IHt9O1xuICAgICAgICAvLyBDYXNlIGlzIGluc2lnbmlmaWNhbnQgYmVsb3csIGFsbCBlbGVtZW50IGFuZCBhdHRyaWJ1dGUgbmFtZXMgYXJlIGxvd2VyLWNhc2VkIGZvciBsb29rdXAuXG4gICAgICAgIHJlZ2lzdGVyQ29udGV4dChTZWN1cml0eUNvbnRleHQuSFRNTCwgW1xuICAgICAgICAgICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICAgICAgICAgJyp8aW5uZXJIVE1MJyxcbiAgICAgICAgICAgICcqfG91dGVySFRNTCcsXG4gICAgICAgIF0pO1xuICAgICAgICByZWdpc3RlckNvbnRleHQoU2VjdXJpdHlDb250ZXh0LlNUWUxFLCBbJyp8c3R5bGUnXSk7XG4gICAgICAgIC8vIE5COiBubyBTQ1JJUFQgY29udGV4dHMgaGVyZSwgdGhleSBhcmUgbmV2ZXIgYWxsb3dlZCBkdWUgdG8gdGhlIHBhcnNlciBzdHJpcHBpbmcgdGhlbS5cbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5VUkwsIFtcbiAgICAgICAgICAgICcqfGZvcm1BY3Rpb24nLFxuICAgICAgICAgICAgJ2FyZWF8aHJlZicsXG4gICAgICAgICAgICAnYXJlYXxwaW5nJyxcbiAgICAgICAgICAgICdhdWRpb3xzcmMnLFxuICAgICAgICAgICAgJ2F8aHJlZicsXG4gICAgICAgICAgICAnYXxwaW5nJyxcbiAgICAgICAgICAgICdibG9ja3F1b3RlfGNpdGUnLFxuICAgICAgICAgICAgJ2JvZHl8YmFja2dyb3VuZCcsXG4gICAgICAgICAgICAnZGVsfGNpdGUnLFxuICAgICAgICAgICAgJ2Zvcm18YWN0aW9uJyxcbiAgICAgICAgICAgICdpbWd8c3JjJyxcbiAgICAgICAgICAgICdpbnB1dHxzcmMnLFxuICAgICAgICAgICAgJ2luc3xjaXRlJyxcbiAgICAgICAgICAgICdxfGNpdGUnLFxuICAgICAgICAgICAgJ3NvdXJjZXxzcmMnLFxuICAgICAgICAgICAgJ3RyYWNrfHNyYycsXG4gICAgICAgICAgICAndmlkZW98cG9zdGVyJyxcbiAgICAgICAgICAgICd2aWRlb3xzcmMnLFxuICAgICAgICBdKTtcbiAgICAgICAgcmVnaXN0ZXJDb250ZXh0KFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIFtcbiAgICAgICAgICAgICdhcHBsZXR8Y29kZScsXG4gICAgICAgICAgICAnYXBwbGV0fGNvZGViYXNlJyxcbiAgICAgICAgICAgICdiYXNlfGhyZWYnLFxuICAgICAgICAgICAgJ2VtYmVkfHNyYycsXG4gICAgICAgICAgICAnZnJhbWV8c3JjJyxcbiAgICAgICAgICAgICdoZWFkfHByb2ZpbGUnLFxuICAgICAgICAgICAgJ2h0bWx8bWFuaWZlc3QnLFxuICAgICAgICAgICAgJ2lmcmFtZXxzcmMnLFxuICAgICAgICAgICAgJ2xpbmt8aHJlZicsXG4gICAgICAgICAgICAnbWVkaWF8c3JjJyxcbiAgICAgICAgICAgICdvYmplY3R8Y29kZWJhc2UnLFxuICAgICAgICAgICAgJ29iamVjdHxkYXRhJyxcbiAgICAgICAgICAgICdzY3JpcHR8c3JjJyxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBfU0VDVVJJVFlfU0NIRU1BO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJDb250ZXh0KGN0eCwgc3BlY3MpIHtcbiAgICBmb3IgKGNvbnN0IHNwZWMgb2Ygc3BlY3MpXG4gICAgICAgIF9TRUNVUklUWV9TQ0hFTUFbc3BlYy50b0xvd2VyQ2FzZSgpXSA9IGN0eDtcbn1cbi8qKlxuICogVGhlIHNldCBvZiBzZWN1cml0eS1zZW5zaXRpdmUgYXR0cmlidXRlcyBvZiBhbiBgPGlmcmFtZT5gIHRoYXQgKm11c3QqIGJlXG4gKiBhcHBsaWVkIGFzIGEgc3RhdGljIGF0dHJpYnV0ZSBvbmx5LiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgc2VjdXJpdHktc2Vuc2l0aXZlXG4gKiBhdHRyaWJ1dGVzIGFyZSB0YWtlbiBpbnRvIGFjY291bnQgd2hpbGUgY3JlYXRpbmcgYW4gaW5zdGFuY2Ugb2YgYW4gYDxpZnJhbWU+YFxuICogYXQgcnVudGltZS5cbiAqXG4gKiBOb3RlOiBhdm9pZCB1c2luZyB0aGlzIHNldCBkaXJlY3RseSwgdXNlIHRoZSBgaXNJZnJhbWVTZWN1cml0eVNlbnNpdGl2ZUF0dHJgIGZ1bmN0aW9uXG4gKiBpbiB0aGUgY29kZSBpbnN0ZWFkLlxuICovXG5jb25zdCBJRlJBTUVfU0VDVVJJVFlfU0VOU0lUSVZFX0FUVFJTID0gbmV3IFNldChbJ3NhbmRib3gnLCAnYWxsb3cnLCAnYWxsb3dmdWxsc2NyZWVuJywgJ3JlZmVycmVycG9saWN5JywgJ2NzcCcsICdmZXRjaHByaW9yaXR5J10pO1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIGdpdmVuIGF0dHJpYnV0ZSBuYW1lIG1pZ2h0IHJlcHJlc2VudCBhIHNlY3VyaXR5LXNlbnNpdGl2ZVxuICogYXR0cmlidXRlIG9mIGFuIDxpZnJhbWU+LlxuICovXG5mdW5jdGlvbiBpc0lmcmFtZVNlY3VyaXR5U2Vuc2l0aXZlQXR0cihhdHRyTmFtZSkge1xuICAgIC8vIFRoZSBgc2V0QXR0cmlidXRlYCBET00gQVBJIGlzIGNhc2UtaW5zZW5zaXRpdmUsIHNvIHdlIGxvd2VyY2FzZSB0aGUgdmFsdWVcbiAgICAvLyBiZWZvcmUgY2hlY2tpbmcgaXQgYWdhaW5zdCBhIGtub3duIHNlY3VyaXR5LXNlbnNpdGl2ZSBhdHRyaWJ1dGVzLlxuICAgIHJldHVybiBJRlJBTUVfU0VDVVJJVFlfU0VOU0lUSVZFX0FUVFJTLmhhcyhhdHRyTmFtZS50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHNldCBjb250YWlucyBhbGwga2V5d29yZHMgdGhhdCBjYW4gYmUgdXNlZCBpbiB0aGUgYW5pbWF0aW9uIGNzcyBzaG9ydGhhbmRcbiAqIHByb3BlcnR5IGFuZCBpcyB1c2VkIGR1cmluZyB0aGUgc2NvcGluZyBvZiBrZXlmcmFtZXMgdG8gbWFrZSBzdXJlIHN1Y2gga2V5d29yZHNcbiAqIGFyZSBub3QgbW9kaWZpZWQuXG4gKi9cbmNvbnN0IGFuaW1hdGlvbktleXdvcmRzID0gbmV3IFNldChbXG4gICAgLy8gZ2xvYmFsIHZhbHVlc1xuICAgICdpbmhlcml0JywgJ2luaXRpYWwnLCAncmV2ZXJ0JywgJ3Vuc2V0JyxcbiAgICAvLyBhbmltYXRpb24tZGlyZWN0aW9uXG4gICAgJ2FsdGVybmF0ZScsICdhbHRlcm5hdGUtcmV2ZXJzZScsICdub3JtYWwnLCAncmV2ZXJzZScsXG4gICAgLy8gYW5pbWF0aW9uLWZpbGwtbW9kZVxuICAgICdiYWNrd2FyZHMnLCAnYm90aCcsICdmb3J3YXJkcycsICdub25lJyxcbiAgICAvLyBhbmltYXRpb24tcGxheS1zdGF0ZVxuICAgICdwYXVzZWQnLCAncnVubmluZycsXG4gICAgLy8gYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblxuICAgICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1pbi1vdXQnLCAnZWFzZS1vdXQnLCAnbGluZWFyJywgJ3N0ZXAtc3RhcnQnLCAnc3RlcC1lbmQnLFxuICAgIC8vIGBzdGVwcygpYCBmdW5jdGlvblxuICAgICdlbmQnLCAnanVtcC1ib3RoJywgJ2p1bXAtZW5kJywgJ2p1bXAtbm9uZScsICdqdW1wLXN0YXJ0JywgJ3N0YXJ0J1xuXSk7XG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgY2xhc3MgaGFzIGl0cyBvcmlnaW4gZnJvbSBhIHBvcnQgb2Ygc2hhZG93Q1NTIGZyb20gd2ViY29tcG9uZW50cy5qcyB0byBUeXBlU2NyaXB0LlxuICogSXQgaGFzIHNpbmNlIGRpdmVyZ2UgaW4gbWFueSB3YXlzIHRvIHRhaWxvciBBbmd1bGFyJ3MgbmVlZHMuXG4gKlxuICogU291cmNlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvNGVmZWNkN2UwZS9zcmMvU2hhZG93Q1NTL1NoYWRvd0NTUy5qc1xuICpcbiAqIFRoZSBvcmlnaW5hbCBmaWxlIGxldmVsIGNvbW1lbnQgaXMgcmVwcm9kdWNlZCBiZWxvd1xuICovXG4vKlxuICBUaGlzIGlzIGEgbGltaXRlZCBzaGltIGZvciBTaGFkb3dET00gY3NzIHN0eWxpbmcuXG4gIGh0dHBzOi8vZHZjcy53My5vcmcvaGcvd2ViY29tcG9uZW50cy9yYXctZmlsZS90aXAvc3BlYy9zaGFkb3cvaW5kZXguaHRtbCNzdHlsZXNcblxuICBUaGUgaW50ZW50aW9uIGhlcmUgaXMgdG8gc3VwcG9ydCBvbmx5IHRoZSBzdHlsaW5nIGZlYXR1cmVzIHdoaWNoIGNhbiBiZVxuICByZWxhdGl2ZWx5IHNpbXBseSBpbXBsZW1lbnRlZC4gVGhlIGdvYWwgaXMgdG8gYWxsb3cgdXNlcnMgdG8gYXZvaWQgdGhlXG4gIG1vc3Qgb2J2aW91cyBwaXRmYWxscyBhbmQgZG8gc28gd2l0aG91dCBjb21wcm9taXNpbmcgcGVyZm9ybWFuY2Ugc2lnbmlmaWNhbnRseS5cbiAgRm9yIFNoYWRvd0RPTSBzdHlsaW5nIHRoYXQncyBub3QgY292ZXJlZCBoZXJlLCBhIHNldCBvZiBiZXN0IHByYWN0aWNlc1xuICBjYW4gYmUgcHJvdmlkZWQgdGhhdCBzaG91bGQgYWxsb3cgdXNlcnMgdG8gYWNjb21wbGlzaCBtb3JlIGNvbXBsZXggc3R5bGluZy5cblxuICBUaGUgZm9sbG93aW5nIGlzIGEgbGlzdCBvZiBzcGVjaWZpYyBTaGFkb3dET00gc3R5bGluZyBmZWF0dXJlcyBhbmQgYSBicmllZlxuICBkaXNjdXNzaW9uIG9mIHRoZSBhcHByb2FjaCB1c2VkIHRvIHNoaW0uXG5cbiAgU2hpbW1lZCBmZWF0dXJlczpcblxuICAqIDpob3N0LCA6aG9zdC1jb250ZXh0OiBTaGFkb3dET00gYWxsb3dzIHN0eWxpbmcgb2YgdGhlIHNoYWRvd1Jvb3QncyBob3N0XG4gIGVsZW1lbnQgdXNpbmcgdGhlIDpob3N0IHJ1bGUuIFRvIHNoaW0gdGhpcyBmZWF0dXJlLCB0aGUgOmhvc3Qgc3R5bGVzIGFyZVxuICByZWZvcm1hdHRlZCBhbmQgcHJlZml4ZWQgd2l0aCBhIGdpdmVuIHNjb3BlIG5hbWUgYW5kIHByb21vdGVkIHRvIGFcbiAgZG9jdW1lbnQgbGV2ZWwgc3R5bGVzaGVldC5cbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiAuZm9vLCBhIHJ1bGUgbGlrZSB0aGlzOlxuXG4gICAgOmhvc3Qge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gIGJlY29tZXM6XG5cbiAgICAuZm9vIHtcbiAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICB9XG5cbiAgKiBlbmNhcHN1bGF0aW9uOiBTdHlsZXMgZGVmaW5lZCB3aXRoaW4gU2hhZG93RE9NLCBhcHBseSBvbmx5IHRvXG4gIGRvbSBpbnNpZGUgdGhlIFNoYWRvd0RPTS5cbiAgVGhlIHNlbGVjdG9ycyBhcmUgc2NvcGVkIGJ5IGFkZGluZyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3Igc3VmZml4IHRvIGVhY2hcbiAgc2ltcGxlIHNlbGVjdG9yIHRoYXQgY29udGFpbnMgdGhlIGhvc3QgZWxlbWVudCB0YWcgbmFtZS4gRWFjaCBlbGVtZW50XG4gIGluIHRoZSBlbGVtZW50J3MgU2hhZG93RE9NIHRlbXBsYXRlIGlzIGFsc28gZ2l2ZW4gdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgVGh1cywgdGhlc2UgcnVsZXMgbWF0Y2ggb25seSBlbGVtZW50cyB0aGF0IGhhdmUgdGhlIHNjb3BlIGF0dHJpYnV0ZS5cbiAgRm9yIGV4YW1wbGUsIGdpdmVuIGEgc2NvcGUgbmFtZSBvZiB4LWZvbywgYSBydWxlIGxpa2UgdGhpczpcblxuICAgIGRpdiB7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB9XG5cbiAgYmVjb21lczpcblxuICAgIGRpdlt4LWZvb10ge1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgfVxuXG4gIE5vdGUgdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBkeW5hbWljYWxseSBhZGRlZCB0byBhIHNjb3BlIG11c3QgaGF2ZSB0aGUgc2NvcGVcbiAgc2VsZWN0b3IgYWRkZWQgdG8gdGhlbSBtYW51YWxseS5cblxuICAqIHVwcGVyL2xvd2VyIGJvdW5kIGVuY2Fwc3VsYXRpb246IFN0eWxlcyB3aGljaCBhcmUgZGVmaW5lZCBvdXRzaWRlIGFcbiAgc2hhZG93Um9vdCBzaG91bGQgbm90IGNyb3NzIHRoZSBTaGFkb3dET00gYm91bmRhcnkgYW5kIHNob3VsZCBub3QgYXBwbHlcbiAgaW5zaWRlIGEgc2hhZG93Um9vdC5cblxuICBUaGlzIHN0eWxpbmcgYmVoYXZpb3IgaXMgbm90IGVtdWxhdGVkLiBTb21lIHBvc3NpYmxlIHdheXMgdG8gZG8gdGhpcyB0aGF0XG4gIHdlcmUgcmVqZWN0ZWQgZHVlIHRvIGNvbXBsZXhpdHkgYW5kL29yIHBlcmZvcm1hbmNlIGNvbmNlcm5zIGluY2x1ZGU6ICgxKSByZXNldFxuICBldmVyeSBwb3NzaWJsZSBwcm9wZXJ0eSBmb3IgZXZlcnkgcG9zc2libGUgc2VsZWN0b3IgZm9yIGEgZ2l2ZW4gc2NvcGUgbmFtZTtcbiAgKDIpIHJlLWltcGxlbWVudCBjc3MgaW4gamF2YXNjcmlwdC5cblxuICBBcyBhbiBhbHRlcm5hdGl2ZSwgdXNlcnMgc2hvdWxkIG1ha2Ugc3VyZSB0byB1c2Ugc2VsZWN0b3JzXG4gIHNwZWNpZmljIHRvIHRoZSBzY29wZSBpbiB3aGljaCB0aGV5IGFyZSB3b3JraW5nLlxuXG4gICogOjpkaXN0cmlidXRlZDogVGhpcyBiZWhhdmlvciBpcyBub3QgZW11bGF0ZWQuIEl0J3Mgb2Z0ZW4gbm90IG5lY2Vzc2FyeVxuICB0byBzdHlsZSB0aGUgY29udGVudHMgb2YgYSBzcGVjaWZpYyBpbnNlcnRpb24gcG9pbnQgYW5kIGluc3RlYWQsIGRlc2NlbmRhbnRzXG4gIG9mIHRoZSBob3N0IGVsZW1lbnQgY2FuIGJlIHN0eWxlZCBzZWxlY3RpdmVseS4gVXNlcnMgY2FuIGFsc28gY3JlYXRlIGFuXG4gIGV4dHJhIG5vZGUgYXJvdW5kIGFuIGluc2VydGlvbiBwb2ludCBhbmQgc3R5bGUgdGhhdCBub2RlJ3MgY29udGVudHNcbiAgdmlhIGRlc2NlbmRlbnQgc2VsZWN0b3JzLiBGb3IgZXhhbXBsZSwgd2l0aCBhIHNoYWRvd1Jvb3QgbGlrZSB0aGlzOlxuXG4gICAgPHN0eWxlPlxuICAgICAgOjpjb250ZW50KGRpdikge1xuICAgICAgICBiYWNrZ3JvdW5kOiByZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8Y29udGVudD48L2NvbnRlbnQ+XG5cbiAgY291bGQgYmVjb21lOlxuXG4gICAgPHN0eWxlPlxuICAgICAgLyAqQHBvbHlmaWxsIC5jb250ZW50LWNvbnRhaW5lciBkaXYgKiAvXG4gICAgICA6OmNvbnRlbnQoZGl2KSB7XG4gICAgICAgIGJhY2tncm91bmQ6IHJlZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50LWNvbnRhaW5lclwiPlxuICAgICAgPGNvbnRlbnQ+PC9jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gIE5vdGUgdGhlIHVzZSBvZiBAcG9seWZpbGwgaW4gdGhlIGNvbW1lbnQgYWJvdmUgYSBTaGFkb3dET00gc3BlY2lmaWMgc3R5bGVcbiAgZGVjbGFyYXRpb24uIFRoaXMgaXMgYSBkaXJlY3RpdmUgdG8gdGhlIHN0eWxpbmcgc2hpbSB0byB1c2UgdGhlIHNlbGVjdG9yXG4gIGluIGNvbW1lbnRzIGluIGxpZXUgb2YgdGhlIG5leHQgc2VsZWN0b3Igd2hlbiBydW5uaW5nIHVuZGVyIHBvbHlmaWxsLlxuKi9cbmNsYXNzIFNoYWRvd0NzcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBleHRyYXBvbGF0ZSB0aGUgcG9zc2libGUga2V5ZnJhbWVzIGZyb20gYW5cbiAgICAgICAgICogYW5pbWF0aW9uIGRlY2xhcmF0aW9uICh3aXRoIHBvc3NpYmx5IG11bHRpcGxlIGFuaW1hdGlvbiBkZWZpbml0aW9ucylcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgZGl2aWRlZCBpbiB0aHJlZSBwYXJ0c1xuICAgICAgICAgKiAgLSAoXnxcXHMrKVxuICAgICAgICAgKiAgICBzaW1wbHkgY2FwdHVyZXMgaG93IG1hbnkgKGlmIGFueSkgbGVhZGluZyB3aGl0ZXNwYWNlcyBhcmUgcHJlc2VudFxuICAgICAgICAgKiAgLSAoPzooPzooWydcIl0pKCg/OlxcXFxcXFxcfFxcXFxcXDJ8KD8hXFwyKS4pKylcXDIpfCgtP1tBLVphLXpdW1xcd1xcLV0qKSlcbiAgICAgICAgICogICAgY2FwdHVyZXMgdHdvIGRpZmZlcmVudCBwb3NzaWJsZSBrZXlmcmFtZXMsIG9uZXMgd2hpY2ggYXJlIHF1b3RlZCBvciBvbmVzIHdoaWNoIGFyZSB2YWxpZCBjc3NcbiAgICAgICAgICogaWRlbnRzIChjdXN0b20gcHJvcGVydGllcyBleGNsdWRlZClcbiAgICAgICAgICogIC0gKD89WyxcXHM7XXwkKVxuICAgICAgICAgKiAgICBzaW1wbHkgbWF0Y2hlcyB0aGUgZW5kIG9mIHRoZSBwb3NzaWJsZSBrZXlmcmFtZSwgdmFsaWQgZW5kaW5ncyBhcmU6IGEgY29tbWEsIGEgc3BhY2UsIGFcbiAgICAgICAgICogc2VtaWNvbG9uIG9yIHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uRGVjbGFyYXRpb25LZXlmcmFtZXNSZSA9IC8oXnxcXHMrKSg/Oig/OihbJ1wiXSkoKD86XFxcXFxcXFx8XFxcXFxcMnwoPyFcXDIpLikrKVxcMil8KC0/W0EtWmEtel1bXFx3XFwtXSopKSg/PVssXFxzXXwkKS9nO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFNoaW0gc29tZSBjc3NUZXh0IHdpdGggdGhlIGdpdmVuIHNlbGVjdG9yLiBSZXR1cm5zIGNzc1RleHQgdGhhdCBjYW4gYmUgaW5jbHVkZWQgaW4gdGhlIGRvY3VtZW50XG4gICAgICpcbiAgICAgKiBUaGUgc2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIHRoZSBob3N0LFxuICAgICAqIFRoZSBob3N0U2VsZWN0b3IgaXMgdGhlIGF0dHJpYnV0ZSBhZGRlZCB0byB0aGUgaG9zdCBpdHNlbGYuXG4gICAgICovXG4gICAgc2hpbUNzc1RleHQoY3NzVGV4dCwgc2VsZWN0b3IsIGhvc3RTZWxlY3RvciA9ICcnKSB7XG4gICAgICAgIGNvbnN0IGNvbW1lbnRzV2l0aEhhc2ggPSBleHRyYWN0Q29tbWVudHNXaXRoSGFzaChjc3NUZXh0KTtcbiAgICAgICAgY3NzVGV4dCA9IHN0cmlwQ29tbWVudHMoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnREaXJlY3RpdmVzKGNzc1RleHQpO1xuICAgICAgICBjb25zdCBzY29wZWRDc3NUZXh0ID0gdGhpcy5fc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gW3Njb3BlZENzc1RleHQsIC4uLmNvbW1lbnRzV2l0aEhhc2hdLmpvaW4oJ1xcbicpO1xuICAgIH1cbiAgICBfaW5zZXJ0RGlyZWN0aXZlcyhjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnRQb2x5ZmlsbFJ1bGVzSW5Dc3NUZXh0KGNzc1RleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIHN0eWxlcyB0byBhZGQgc2NvcGUgdG8ga2V5ZnJhbWVzLlxuICAgICAqXG4gICAgICogTW9kaWZ5IGJvdGggdGhlIG5hbWVzIG9mIHRoZSBrZXlmcmFtZXMgZGVmaW5lZCBpbiB0aGUgY29tcG9uZW50IHN0eWxlcyBhbmQgYWxzbyB0aGUgY3NzXG4gICAgICogYW5pbWF0aW9uIHJ1bGVzIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBBbmltYXRpb24gcnVsZXMgdXNpbmcga2V5ZnJhbWVzIGRlZmluZWQgZWxzZXdoZXJlIGFyZSBub3QgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIGdsb2JhbGx5XG4gICAgICogZGVmaW5lZCBrZXlmcmFtZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIGNzczpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC5ib3gge1xuICAgICAqICAgYW5pbWF0aW9uOiBib3gtYW5pbWF0aW9uIDFzIGZvcndhcmRzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBrZXlmcmFtZXMgYm94LWFuaW1hdGlvbiB7XG4gICAgICogICB0byB7XG4gICAgICogICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIHRvIHRoaXM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAuYm94IHtcbiAgICAgKiAgIGFuaW1hdGlvbjogc2NvcGVOYW1lX2JveC1hbmltYXRpb24gMXMgZm9yd2FyZHM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQGtleWZyYW1lcyBzY29wZU5hbWVfYm94LWFuaW1hdGlvbiB7XG4gICAgICogICB0byB7XG4gICAgICogICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjc3NUZXh0IHRoZSBjb21wb25lbnQncyBjc3MgdGV4dCB0aGF0IG5lZWRzIHRvIGJlIHNjb3BlZC5cbiAgICAgKiBAcGFyYW0gc2NvcGVTZWxlY3RvciB0aGUgY29tcG9uZW50J3Mgc2NvcGUgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgc2NvcGVkIGNzcyB0ZXh0LlxuICAgICAqL1xuICAgIF9zY29wZUtleWZyYW1lc1JlbGF0ZWRDc3MoY3NzVGV4dCwgc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB1bnNjb3BlZEtleWZyYW1lc1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3Qgc2NvcGVkS2V5ZnJhbWVzQ3NzVGV4dCA9IHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBydWxlID0+IHRoaXMuX3Njb3BlTG9jYWxLZXlmcmFtZURlY2xhcmF0aW9ucyhydWxlLCBzY29wZVNlbGVjdG9yLCB1bnNjb3BlZEtleWZyYW1lc1NldCkpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc1J1bGVzKHNjb3BlZEtleWZyYW1lc0Nzc1RleHQsIHJ1bGUgPT4gdGhpcy5fc2NvcGVBbmltYXRpb25SdWxlKHJ1bGUsIHNjb3BlU2VsZWN0b3IsIHVuc2NvcGVkS2V5ZnJhbWVzU2V0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjb3BlcyBsb2NhbCBrZXlmcmFtZXMgbmFtZXMsIHJldHVybmluZyB0aGUgdXBkYXRlZCBjc3MgcnVsZSBhbmQgaXQgYWxzb1xuICAgICAqIGFkZHMgdGhlIG9yaWdpbmFsIGtleWZyYW1lIG5hbWUgdG8gYSBwcm92aWRlZCBzZXQgdG8gY29sbGVjdCBhbGwga2V5ZnJhbWVzIG5hbWVzXG4gICAgICogc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgdXNlZCB0byBzY29wZSB0aGUgYW5pbWF0aW9uIHJ1bGVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGl0IHRha2VzIGEgcnVsZSBzdWNoIGFzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQGtleWZyYW1lcyBib3gtYW5pbWF0aW9uIHtcbiAgICAgKiAgIHRvIHtcbiAgICAgKiAgICAgYmFja2dyb3VuZC1jb2xvcjogZ3JlZW47XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYW5kIHJldHVybnM6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBAa2V5ZnJhbWVzIHNjb3BlTmFtZV9ib3gtYW5pbWF0aW9uIHtcbiAgICAgKiAgIHRvIHtcbiAgICAgKiAgICAgYmFja2dyb3VuZC1jb2xvcjogZ3JlZW47XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIGFuZCBhcyBhIHNpZGUgZWZmZWN0IGl0IGFkZHMgXCJib3gtYW5pbWF0aW9uXCIgdG8gdGhlIGB1bnNjb3BlZEtleWZyYW1lc1NldGAgc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3NzUnVsZSB0aGUgY3NzIHJ1bGUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gc2NvcGVTZWxlY3RvciB0aGUgY29tcG9uZW50J3Mgc2NvcGUgc2VsZWN0b3IuXG4gICAgICogQHBhcmFtIHVuc2NvcGVkS2V5ZnJhbWVzU2V0IHRoZSBzZXQgb2YgdW5zY29wZWQga2V5ZnJhbWVzIG5hbWVzICh3aGljaCBjYW4gYmVcbiAgICAgKiBtb2RpZmllZCBhcyBhIHNpZGUgZWZmZWN0KVxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIGNzcyBydWxlIG1vZGlmaWVkIHdpdGggdGhlIHNjb3BlZCBrZXlmcmFtZXMgbmFtZS5cbiAgICAgKi9cbiAgICBfc2NvcGVMb2NhbEtleWZyYW1lRGVjbGFyYXRpb25zKHJ1bGUsIHNjb3BlU2VsZWN0b3IsIHVuc2NvcGVkS2V5ZnJhbWVzU2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5ydWxlLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHJ1bGUuc2VsZWN0b3IucmVwbGFjZSgvKF5AKD86LXdlYmtpdC0pP2tleWZyYW1lcyg/OlxccyspKShbJ1wiXT8pKC4rKVxcMihcXHMqKSQvLCAoXywgc3RhcnQsIHF1b3RlLCBrZXlmcmFtZU5hbWUsIGVuZFNwYWNlcykgPT4ge1xuICAgICAgICAgICAgICAgIHVuc2NvcGVkS2V5ZnJhbWVzU2V0LmFkZCh1bmVzY2FwZVF1b3RlcyhrZXlmcmFtZU5hbWUsIHF1b3RlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3N0YXJ0fSR7cXVvdGV9JHtzY29wZVNlbGVjdG9yfV8ke2tleWZyYW1lTmFtZX0ke3F1b3RlfSR7ZW5kU3BhY2VzfWA7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBzY29wZSBhIGtleWZyYW1lcyBuYW1lIChvYnRhaW5lZCBmcm9tIGFuIGFuaW1hdGlvbiBkZWNsYXJhdGlvbilcbiAgICAgKiB1c2luZyBhbiBleGlzdGluZyBzZXQgb2YgdW5zY29wZWRLZXlmcmFtZXMgbmFtZXMgdG8gZGlzY2VybiBpZiB0aGUgc2NvcGluZyBuZWVkcyB0byBiZVxuICAgICAqIHBlcmZvcm1lZCAoa2V5ZnJhbWVzIG5hbWVzIG9mIGtleWZyYW1lcyBub3QgZGVmaW5lZCBpbiB0aGUgY29tcG9uZW50J3MgY3NzIG5lZWQgbm90IHRvIGJlXG4gICAgICogc2NvcGVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlmcmFtZSB0aGUga2V5ZnJhbWVzIG5hbWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHNjb3BlU2VsZWN0b3IgdGhlIGNvbXBvbmVudCdzIHNjb3BlIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB1bnNjb3BlZEtleWZyYW1lc1NldCB0aGUgc2V0IG9mIHVuc2NvcGVkIGtleWZyYW1lcyBuYW1lcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBzY29wZWQgbmFtZSBvZiB0aGUga2V5ZnJhbWUsIG9yIHRoZSBvcmlnaW5hbCBuYW1lIGlzIHRoZSBuYW1lIG5lZWQgbm90IHRvIGJlXG4gICAgICogc2NvcGVkLlxuICAgICAqL1xuICAgIF9zY29wZUFuaW1hdGlvbktleWZyYW1lKGtleWZyYW1lLCBzY29wZVNlbGVjdG9yLCB1bnNjb3BlZEtleWZyYW1lc1NldCkge1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWUucmVwbGFjZSgvXihcXHMqKShbJ1wiXT8pKC4rPylcXDIoXFxzKikkLywgKF8sIHNwYWNlczEsIHF1b3RlLCBuYW1lLCBzcGFjZXMyKSA9PiB7XG4gICAgICAgICAgICBuYW1lID0gYCR7dW5zY29wZWRLZXlmcmFtZXNTZXQuaGFzKHVuZXNjYXBlUXVvdGVzKG5hbWUsIHF1b3RlKSkgPyBzY29wZVNlbGVjdG9yICsgJ18nIDogJyd9JHtuYW1lfWA7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3BhY2VzMX0ke3F1b3RlfSR7bmFtZX0ke3F1b3RlfSR7c3BhY2VzMn1gO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NvcGUgYW4gYW5pbWF0aW9uIHJ1bGUgc28gdGhhdCB0aGUga2V5ZnJhbWVzIG1lbnRpb25lZCBpbiBzdWNoIHJ1bGVcbiAgICAgKiBhcmUgc2NvcGVkIGlmIGRlZmluZWQgaW4gdGhlIGNvbXBvbmVudCdzIGNzcyBhbmQgbGVmdCB1bnRvdWNoZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogSXQgY2FuIHNjb3BlIHZhbHVlcyBvZiBib3RoIHRoZSAnYW5pbWF0aW9uJyBhbmQgJ2FuaW1hdGlvbi1uYW1lJyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGUgY3NzIHJ1bGUgdG8gc2NvcGUuXG4gICAgICogQHBhcmFtIHNjb3BlU2VsZWN0b3IgdGhlIGNvbXBvbmVudCdzIHNjb3BlIHNlbGVjdG9yLlxuICAgICAqIEBwYXJhbSB1bnNjb3BlZEtleWZyYW1lc1NldCB0aGUgc2V0IG9mIHVuc2NvcGVkIGtleWZyYW1lcyBuYW1lcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSB1cGRhdGVkIGNzcyBydWxlLlxuICAgICAqKi9cbiAgICBfc2NvcGVBbmltYXRpb25SdWxlKHJ1bGUsIHNjb3BlU2VsZWN0b3IsIHVuc2NvcGVkS2V5ZnJhbWVzU2V0KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gcnVsZS5jb250ZW50LnJlcGxhY2UoLygoPzpefFxccyt8OykoPzotd2Via2l0LSk/YW5pbWF0aW9uKD86XFxzKik6KD86XFxzKikpKFteO10rKS9nLCAoXywgc3RhcnQsIGFuaW1hdGlvbkRlY2xhcmF0aW9ucykgPT4gc3RhcnQgK1xuICAgICAgICAgICAgYW5pbWF0aW9uRGVjbGFyYXRpb25zLnJlcGxhY2UodGhpcy5fYW5pbWF0aW9uRGVjbGFyYXRpb25LZXlmcmFtZXNSZSwgKG9yaWdpbmFsLCBsZWFkaW5nU3BhY2VzLCBxdW90ZSA9ICcnLCBxdW90ZWROYW1lLCBub25RdW90ZWROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke2xlYWRpbmdTcGFjZXN9JHt0aGlzLl9zY29wZUFuaW1hdGlvbktleWZyYW1lKGAke3F1b3RlfSR7cXVvdGVkTmFtZX0ke3F1b3RlfWAsIHNjb3BlU2VsZWN0b3IsIHVuc2NvcGVkS2V5ZnJhbWVzU2V0KX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbktleXdvcmRzLmhhcyhub25RdW90ZWROYW1lKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtsZWFkaW5nU3BhY2VzfSR7dGhpcy5fc2NvcGVBbmltYXRpb25LZXlmcmFtZShub25RdW90ZWROYW1lLCBzY29wZVNlbGVjdG9yLCB1bnNjb3BlZEtleWZyYW1lc1NldCl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoLygoPzpefFxccyt8OykoPzotd2Via2l0LSk/YW5pbWF0aW9uLW5hbWUoPzpcXHMqKTooPzpcXHMqKSkoW147XSspL2csIChfbWF0Y2gsIHN0YXJ0LCBjb21tYVNlcGFyYXRlZEtleWZyYW1lcykgPT4gYCR7c3RhcnR9JHtjb21tYVNlcGFyYXRlZEtleWZyYW1lcy5zcGxpdCgnLCcpXG4gICAgICAgICAgICAubWFwKChrZXlmcmFtZSkgPT4gdGhpcy5fc2NvcGVBbmltYXRpb25LZXlmcmFtZShrZXlmcmFtZSwgc2NvcGVTZWxlY3RvciwgdW5zY29wZWRLZXlmcmFtZXNTZXQpKVxuICAgICAgICAgICAgLmpvaW4oJywnKX1gKTtcbiAgICAgICAgcmV0dXJuIHsgLi4ucnVsZSwgY29udGVudCB9O1xuICAgIH1cbiAgICAvKlxuICAgICAqIFByb2Nlc3Mgc3R5bGVzIHRvIGNvbnZlcnQgbmF0aXZlIFNoYWRvd0RPTSBydWxlcyB0aGF0IHdpbGwgdHJpcFxuICAgICAqIHVwIHRoZSBjc3MgcGFyc2VyOyB3ZSByZWx5IG9uIGRlY29yYXRpbmcgdGhlIHN0eWxlc2hlZXQgd2l0aCBpbmVydCBydWxlcy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIHBvbHlmaWxsLW5leHQtc2VsZWN0b3IgeyBjb250ZW50OiAnOmhvc3QgbWVudS1pdGVtJzsgfVxuICAgICAqIDo6Y29udGVudCBtZW51LWl0ZW0ge1xuICAgICAqXG4gICAgICogdG8gdGhpczpcbiAgICAgKlxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0ge1xuICAgICAqXG4gICAgICoqL1xuICAgIF9pbnNlcnRQb2x5ZmlsbERpcmVjdGl2ZXNJbkNzc1RleHQoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb250ZW50TmV4dFNlbGVjdG9yUmUsIGZ1bmN0aW9uICguLi5tKSB7XG4gICAgICAgICAgICByZXR1cm4gbVsyXSArICd7JztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gYWRkIHJ1bGVzIHdoaWNoIHdpbGwgb25seSBhcHBseSB1bmRlciB0aGUgcG9seWZpbGxcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3ZSBjb252ZXJ0IHRoaXMgcnVsZTpcbiAgICAgKlxuICAgICAqIHBvbHlmaWxsLXJ1bGUge1xuICAgICAqICAgY29udGVudDogJzpob3N0IG1lbnUtaXRlbSc7XG4gICAgICogLi4uXG4gICAgICogfVxuICAgICAqXG4gICAgICogdG8gdGhpczpcbiAgICAgKlxuICAgICAqIHNjb3BlTmFtZSBtZW51LWl0ZW0gey4uLn1cbiAgICAgKlxuICAgICAqKi9cbiAgICBfaW5zZXJ0UG9seWZpbGxSdWxlc0luQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbnRlbnRSdWxlUmUsICguLi5tKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gbVswXS5yZXBsYWNlKG1bMV0sICcnKS5yZXBsYWNlKG1bMl0sICcnKTtcbiAgICAgICAgICAgIHJldHVybiBtWzRdICsgcnVsZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qIEVuc3VyZSBzdHlsZXMgYXJlIHNjb3BlZC4gUHNldWRvLXNjb3BpbmcgdGFrZXMgYSBydWxlIGxpa2U6XG4gICAgICpcbiAgICAgKiAgLmZvbyB7Li4uIH1cbiAgICAgKlxuICAgICAqICBhbmQgY29udmVydHMgdGhpcyB0b1xuICAgICAqXG4gICAgICogIHNjb3BlTmFtZSAuZm9vIHsgLi4uIH1cbiAgICAgKi9cbiAgICBfc2NvcGVDc3NUZXh0KGNzc1RleHQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCB1bnNjb3BlZFJ1bGVzID0gdGhpcy5fZXh0cmFjdFVuc2NvcGVkUnVsZXNGcm9tQ3NzVGV4dChjc3NUZXh0KTtcbiAgICAgICAgLy8gcmVwbGFjZSA6aG9zdCBhbmQgOmhvc3QtY29udGV4dCAtc2hhZG93Y3NzaG9zdCBhbmQgLXNoYWRvd2Nzc2hvc3QgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9pbnNlcnRQb2x5ZmlsbEhvc3RJbkNzc1RleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0Q29sb25Ib3N0KGNzc1RleHQpO1xuICAgICAgICBjc3NUZXh0ID0gdGhpcy5fY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLl9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpO1xuICAgICAgICBpZiAoc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHRoaXMuX3Njb3BlS2V5ZnJhbWVzUmVsYXRlZENzcyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yKTtcbiAgICAgICAgICAgIGNzc1RleHQgPSB0aGlzLl9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNzc1RleHQgPSBjc3NUZXh0ICsgJ1xcbicgKyB1bnNjb3BlZFJ1bGVzO1xuICAgICAgICByZXR1cm4gY3NzVGV4dC50cmltKCk7XG4gICAgfVxuICAgIC8qXG4gICAgICogUHJvY2VzcyBzdHlsZXMgdG8gYWRkIHJ1bGVzIHdoaWNoIHdpbGwgb25seSBhcHBseSB1bmRlciB0aGUgcG9seWZpbGxcbiAgICAgKiBhbmQgZG8gbm90IHByb2Nlc3MgdmlhIENTU09NLiAoQ1NTT00gaXMgZGVzdHJ1Y3RpdmUgdG8gcnVsZXMgb24gcmFyZVxuICAgICAqIG9jY2FzaW9ucywgZS5nLiAtd2Via2l0LWNhbGMgb24gU2FmYXJpLilcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2UgY29udmVydCB0aGlzIHJ1bGU6XG4gICAgICpcbiAgICAgKiBAcG9seWZpbGwtdW5zY29wZWQtcnVsZSB7XG4gICAgICogICBjb250ZW50OiAnbWVudS1pdGVtJztcbiAgICAgKiAuLi4gfVxuICAgICAqXG4gICAgICogdG8gdGhpczpcbiAgICAgKlxuICAgICAqIG1lbnUtaXRlbSB7Li4ufVxuICAgICAqXG4gICAgICoqL1xuICAgIF9leHRyYWN0VW5zY29wZWRSdWxlc0Zyb21Dc3NUZXh0KGNzc1RleHQpIHtcbiAgICAgICAgbGV0IHIgPSAnJztcbiAgICAgICAgbGV0IG07XG4gICAgICAgIF9jc3NDb250ZW50VW5zY29wZWRSdWxlUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKChtID0gX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZS5leGVjKGNzc1RleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZSA9IG1bMF0ucmVwbGFjZShtWzJdLCAnJykucmVwbGFjZShtWzFdLCBtWzRdKTtcbiAgICAgICAgICAgIHIgKz0gcnVsZSArICdcXG5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICAvKlxuICAgICAqIGNvbnZlcnQgYSBydWxlIGxpa2UgOmhvc3QoLmZvbykgPiAuYmFyIHsgfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiA+IC5iYXJcbiAgICAgKi9cbiAgICBfY29udmVydENvbG9uSG9zdChjc3NUZXh0KSB7XG4gICAgICAgIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoX2Nzc0NvbG9uSG9zdFJlLCAoXywgaG9zdFNlbGVjdG9ycywgb3RoZXJTZWxlY3RvcnMpID0+IHtcbiAgICAgICAgICAgIGlmIChob3N0U2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVkU2VsZWN0b3JzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgaG9zdFNlbGVjdG9yQXJyYXkgPSBob3N0U2VsZWN0b3JzLnNwbGl0KCcsJykubWFwKHAgPT4gcC50cmltKCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdFNlbGVjdG9yIG9mIGhvc3RTZWxlY3RvckFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaG9zdFNlbGVjdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZFNlbGVjdG9yID0gX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvciArIGhvc3RTZWxlY3Rvci5yZXBsYWNlKF9wb2x5ZmlsbEhvc3QsICcnKSArIG90aGVyU2VsZWN0b3JzO1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0ZWRTZWxlY3RvcnMucHVzaChjb252ZXJ0ZWRTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJ0ZWRTZWxlY3RvcnMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IgKyBvdGhlclNlbGVjdG9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogY29udmVydCBhIHJ1bGUgbGlrZSA6aG9zdC1jb250ZXh0KC5mb28pID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIHRvXG4gICAgICpcbiAgICAgKiAuZm9vPHNjb3BlTmFtZT4gPiAuYmFyLCAuZm9vIDxzY29wZU5hbWU+ID4gLmJhciB7IH1cbiAgICAgKlxuICAgICAqIGFuZFxuICAgICAqXG4gICAgICogOmhvc3QtY29udGV4dCguZm9vOmhvc3QpIC5iYXIgeyAuLi4gfVxuICAgICAqXG4gICAgICogdG9cbiAgICAgKlxuICAgICAqIC5mb288c2NvcGVOYW1lPiAuYmFyIHsgLi4uIH1cbiAgICAgKi9cbiAgICBfY29udmVydENvbG9uSG9zdENvbnRleHQoY3NzVGV4dCkge1xuICAgICAgICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKF9jc3NDb2xvbkhvc3RDb250ZXh0UmVHbG9iYWwsIHNlbGVjdG9yVGV4dCA9PiB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGNhcHR1cmVkIGEgc2VsZWN0b3IgdGhhdCBjb250YWlucyBhIGA6aG9zdC1jb250ZXh0YCBydWxlLlxuICAgICAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYDpob3N0LWNvbnRleHRgIG1heSBjb250YWluIGEgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2Ygc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy8gRWFjaCBjb250ZXh0IHNlbGVjdG9yIGdyb3VwIHdpbGwgY29udGFpbiBhIGxpc3Qgb2YgaG9zdC1jb250ZXh0IHNlbGVjdG9ycyB0aGF0IG11c3QgbWF0Y2hcbiAgICAgICAgICAgIC8vIGFuIGFuY2VzdG9yIG9mIHRoZSBob3N0LlxuICAgICAgICAgICAgLy8gKE5vcm1hbGx5IGBjb250ZXh0U2VsZWN0b3JHcm91cHNgIHdpbGwgb25seSBjb250YWluIGEgc2luZ2xlIGFycmF5IG9mIGNvbnRleHQgc2VsZWN0b3JzLilcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTZWxlY3Rvckdyb3VwcyA9IFtbXV07XG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIGA6aG9zdC1jb250ZXh0YCBpbiB0aGlzIHNlbGVjdG9yIHNvIGBzZWxlY3RvclRleHRgIGNvdWxkIGxvb2sgbGlrZTpcbiAgICAgICAgICAgIC8vIGA6aG9zdC1jb250ZXh0KC5vbmUpOmhvc3QtY29udGV4dCgudHdvKWAuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGBfY3NzQ29sb25Ib3N0Q29udGV4dFJlYCBvdmVyIGFuZCBvdmVyIHVudGlsIHdlIGhhdmUgZXh0cmFjdGVkIGFsbCB0aGVcbiAgICAgICAgICAgIC8vIGA6aG9zdC1jb250ZXh0YCBzZWxlY3RvcnMgZnJvbSB0aGlzIHNlbGVjdG9yLlxuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gX2Nzc0NvbG9uSG9zdENvbnRleHRSZS5leGVjKHNlbGVjdG9yVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBgbWF0Y2hgID0gWyc6aG9zdC1jb250ZXh0KDxzZWxlY3RvcnM+KTxyZXN0PicsIDxzZWxlY3RvcnM+LCA8cmVzdD5dXG4gICAgICAgICAgICAgICAgLy8gVGhlIGA8c2VsZWN0b3JzPmAgY291bGQgYWN0dWFsbHkgYmUgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdDogYDpob3N0LWNvbnRleHQoLm9uZSwgLnR3bylgLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHRTZWxlY3RvcnMgPSAobWF0Y2hbMV0gPz8gJycpLnRyaW0oKS5zcGxpdCgnLCcpLm1hcChtID0+IG0udHJpbSgpKS5maWx0ZXIobSA9PiBtICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgLy8gV2UgbXVzdCBkdXBsaWNhdGUgdGhlIGN1cnJlbnQgc2VsZWN0b3IgZ3JvdXAgZm9yIGVhY2ggb2YgdGhlc2UgbmV3IHNlbGVjdG9ycy5cbiAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSBpZiB0aGUgY3VycmVudCBncm91cHMgYXJlOlxuICAgICAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgICAgICAgICAvLyAgIFsnYScsICdiJywgJ2MnXSxcbiAgICAgICAgICAgICAgICAvLyAgIFsneCcsICd5JywgJ3onXSxcbiAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAgICAgLy8gQW5kIHdlIGhhdmUgYSBuZXcgc2V0IG9mIGNvbW1hIHNlcGFyYXRlZCBzZWxlY3RvcnM6IGA6aG9zdC1jb250ZXh0KG0sbilgIHRoZW4gdGhlIG5ld1xuICAgICAgICAgICAgICAgIC8vIGdyb3VwcyBhcmU6XG4gICAgICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICAgICAgICAgIC8vICAgWydhJywgJ2InLCAnYycsICdtJ10sXG4gICAgICAgICAgICAgICAgLy8gICBbJ3gnLCAneScsICd6JywgJ20nXSxcbiAgICAgICAgICAgICAgICAvLyAgIFsnYScsICdiJywgJ2MnLCAnbiddLFxuICAgICAgICAgICAgICAgIC8vICAgWyd4JywgJ3knLCAneicsICduJ10sXG4gICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRTZWxlY3Rvckdyb3Vwc0xlbmd0aCA9IGNvbnRleHRTZWxlY3Rvckdyb3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgcmVwZWF0R3JvdXBzKGNvbnRleHRTZWxlY3Rvckdyb3VwcywgbmV3Q29udGV4dFNlbGVjdG9ycy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Q29udGV4dFNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbnRleHRTZWxlY3Rvckdyb3Vwc0xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0U2VsZWN0b3JHcm91cHNbaiArIChpICogY29udGV4dFNlbGVjdG9yR3JvdXBzTGVuZ3RoKV0ucHVzaChuZXdDb250ZXh0U2VsZWN0b3JzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGBzZWxlY3RvclRleHRgIGFuZCBzZWUgcmVwZWF0IHRvIHNlZSBpZiB0aGVyZSBhcmUgbW9yZSBgOmhvc3QtY29udGV4dGBzLlxuICAgICAgICAgICAgICAgIHNlbGVjdG9yVGV4dCA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGNvbnRleHQgc2VsZWN0b3JzIG5vdyBtdXN0IGJlIGNvbWJpbmVkIHdpdGggZWFjaCBvdGhlciB0byBjYXB0dXJlIGFsbCB0aGUgcG9zc2libGVcbiAgICAgICAgICAgIC8vIHNlbGVjdG9ycyB0aGF0IGA6aG9zdC1jb250ZXh0YCBjYW4gbWF0Y2guIFNlZSBgY29tYmluZUhvc3RDb250ZXh0U2VsZWN0b3JzKClgIGZvciBtb3JlXG4gICAgICAgICAgICAvLyBpbmZvIGFib3V0IGhvdyB0aGlzIGlzIGRvbmUuXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dFNlbGVjdG9yR3JvdXBzXG4gICAgICAgICAgICAgICAgLm1hcChjb250ZXh0U2VsZWN0b3JzID0+IGNvbWJpbmVIb3N0Q29udGV4dFNlbGVjdG9ycyhjb250ZXh0U2VsZWN0b3JzLCBzZWxlY3RvclRleHQpKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBDb252ZXJ0IGNvbWJpbmF0b3JzIGxpa2UgOjpzaGFkb3cgYW5kIHBzZXVkby1lbGVtZW50cyBsaWtlIDo6Y29udGVudFxuICAgICAqIGJ5IHJlcGxhY2luZyB3aXRoIHNwYWNlLlxuICAgICAqL1xuICAgIF9jb252ZXJ0U2hhZG93RE9NU2VsZWN0b3JzKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIF9zaGFkb3dET01TZWxlY3RvcnNSZS5yZWR1Y2UoKHJlc3VsdCwgcGF0dGVybikgPT4gcmVzdWx0LnJlcGxhY2UocGF0dGVybiwgJyAnKSwgY3NzVGV4dCk7XG4gICAgfVxuICAgIC8vIGNoYW5nZSBhIHNlbGVjdG9yIGxpa2UgJ2RpdicgdG8gJ25hbWUgZGl2J1xuICAgIF9zY29wZVNlbGVjdG9ycyhjc3NUZXh0LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCAocnVsZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3RvcjtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gcnVsZS5jb250ZW50O1xuICAgICAgICAgICAgaWYgKHJ1bGUuc2VsZWN0b3JbMF0gIT09ICdAJykge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gdGhpcy5fc2NvcGVTZWxlY3RvcihydWxlLnNlbGVjdG9yLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAbWVkaWEnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BzdXBwb3J0cycpIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZG9jdW1lbnQnKSB8fCBydWxlLnNlbGVjdG9yLnN0YXJ0c1dpdGgoJ0BsYXllcicpIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAY29udGFpbmVyJykpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fc2NvcGVTZWxlY3RvcnMocnVsZS5jb250ZW50LCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAZm9udC1mYWNlJykgfHwgcnVsZS5zZWxlY3Rvci5zdGFydHNXaXRoKCdAcGFnZScpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuX3N0cmlwU2NvcGluZ1NlbGVjdG9ycyhydWxlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhIGNzcyB0ZXh0IHRoYXQgaXMgd2l0aGluIGEgcnVsZSB0aGF0IHNob3VsZCBub3QgY29udGFpbiBzY29wZSBzZWxlY3RvcnMgYnkgc2ltcGx5XG4gICAgICogcmVtb3ZpbmcgdGhlbSEgQW4gZXhhbXBsZSBvZiBzdWNoIGEgcnVsZSBpcyBgQGZvbnQtZmFjZWAuXG4gICAgICpcbiAgICAgKiBgQGZvbnQtZmFjZWAgcnVsZXMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHNlbGVjdG9ycy4gTm9yIGNhbiB0aGV5IGJlIG5lc3RlZCB1bmRlciBhIHNlbGVjdG9yLlxuICAgICAqIE5vcm1hbGx5IHRoaXMgd291bGQgYmUgYSBzeW50YXggZXJyb3IgYnkgdGhlIGF1dGhvciBvZiB0aGUgc3R5bGVzLiBCdXQgaW4gc29tZSByYXJlIGNhc2VzLCBzdWNoXG4gICAgICogYXMgaW1wb3J0aW5nIHN0eWxlcyBmcm9tIGEgbGlicmFyeSwgYW5kIGFwcGx5aW5nIGA6aG9zdCA6Om5nLWRlZXBgIHRvIHRoZSBpbXBvcnRlZCBzdHlsZXMsIHdlXG4gICAgICogY2FuIGVuZCB1cCB3aXRoIGJyb2tlbiBjc3MgaWYgdGhlIGltcG9ydGVkIHN0eWxlcyBoYXBwZW4gdG8gY29udGFpbiBAZm9udC1mYWNlIHJ1bGVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA6aG9zdCA6Om5nLWRlZXAge1xuICAgICAqICAgaW1wb3J0ICdzb21lL2xpYi9jb250YWluaW5nL2ZvbnQtZmFjZSc7XG4gICAgICogfVxuICAgICAqXG4gICAgICogU2ltaWxhciBsb2dpYyBhcHBsaWVzIHRvIGBAcGFnZWAgcnVsZXMgd2hpY2ggY2FuIGNvbnRhaW4gYSBwYXJ0aWN1bGFyIHNldCBvZiBwcm9wZXJ0aWVzLFxuICAgICAqIGFzIHdlbGwgYXMgc29tZSBzcGVjaWZpYyBhdC1ydWxlcy4gU2luY2UgdGhleSBjYW4ndCBiZSBlbmNhcHN1bGF0ZWQsIHdlIGhhdmUgdG8gc3RyaXBcbiAgICAgKiBhbnkgc2NvcGluZyBzZWxlY3RvcnMgZnJvbSB0aGVtLiBGb3IgbW9yZSBpbmZvcm1hdGlvbjogaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1wYWdlLTNcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBfc3RyaXBTY29waW5nU2VsZWN0b3JzKGNzc1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSdWxlcyhjc3NUZXh0LCBydWxlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gcnVsZS5zZWxlY3Rvci5yZXBsYWNlKF9zaGFkb3dEZWVwU2VsZWN0b3JzLCAnICcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAnICcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDc3NSdWxlKHNlbGVjdG9yLCBydWxlLmNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Njb3BlU2VsZWN0b3Ioc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3Iuc3BsaXQoJywnKVxuICAgICAgICAgICAgLm1hcChwYXJ0ID0+IHBhcnQudHJpbSgpLnNwbGl0KF9zaGFkb3dEZWVwU2VsZWN0b3JzKSlcbiAgICAgICAgICAgIC5tYXAoKGRlZXBQYXJ0cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgW3NoYWxsb3dQYXJ0LCAuLi5vdGhlclBhcnRzXSA9IGRlZXBQYXJ0cztcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5U2NvcGUgPSAoc2hhbGxvd1BhcnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcHBseVNlbGVjdG9yU2NvcGUoc2hhbGxvd1BhcnQsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhbGxvd1BhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbYXBwbHlTY29wZShzaGFsbG93UGFydCksIC4uLm90aGVyUGFydHNdLmpvaW4oJyAnKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICBfc2VsZWN0b3JOZWVkc1Njb3Bpbmcoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgcmUgPSB0aGlzLl9tYWtlU2NvcGVNYXRjaGVyKHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gIXJlLnRlc3Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBfbWFrZVNjb3BlTWF0Y2hlcihzY29wZVNlbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGxyZSA9IC9cXFsvZztcbiAgICAgICAgY29uc3QgcnJlID0gL1xcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGxyZSwgJ1xcXFxbJykucmVwbGFjZShycmUsICdcXFxcXScpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXignICsgc2NvcGVTZWxlY3RvciArICcpJyArIF9zZWxlY3RvclJlU3VmZml4LCAnbScpO1xuICAgIH1cbiAgICAvLyBzY29wZSB2aWEgbmFtZSBhbmQgW2lzPW5hbWVdXG4gICAgX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShzZWxlY3Rvciwgc2NvcGVTZWxlY3RvciwgaG9zdFNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQgYnJvd3NlciwgdGhlIGxhc3RJbmRleCBpcyBub3QgcmVzZXQgd2hlbiB0aGUgcmVnZXggaXMgdXNlZCBpbiBTdHJpbmcucmVwbGFjZSgpXG4gICAgICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoX3BvbHlmaWxsSG9zdFJlLnRlc3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlQnkgPSBgWyR7aG9zdFNlbGVjdG9yfV1gO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvclJlLCAoaG5jLCBzZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8oW146XSopKDoqKSguKikvLCAoXywgYmVmb3JlLCBjb2xvbiwgYWZ0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJlZm9yZSArIHJlcGxhY2VCeSArIGNvbG9uICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKF9wb2x5ZmlsbEhvc3RSZSwgcmVwbGFjZUJ5ICsgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVTZWxlY3RvciArICcgJyArIHNlbGVjdG9yO1xuICAgIH1cbiAgICAvLyByZXR1cm4gYSBzZWxlY3RvciB3aXRoIFtuYW1lXSBzdWZmaXggb24gZWFjaCBzaW1wbGUgc2VsZWN0b3JcbiAgICAvLyBlLmcuIC5mb28uYmFyID4gLnpvdCBiZWNvbWVzIC5mb29bbmFtZV0uYmFyW25hbWVdID4gLnpvdFtuYW1lXSAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBseVNlbGVjdG9yU2NvcGUoc2VsZWN0b3IsIHNjb3BlU2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBpc1JlID0gL1xcW2lzPShbXlxcXV0qKVxcXS9nO1xuICAgICAgICBzY29wZVNlbGVjdG9yID0gc2NvcGVTZWxlY3Rvci5yZXBsYWNlKGlzUmUsIChfLCAuLi5wYXJ0cykgPT4gcGFydHNbMF0pO1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9ICdbJyArIHNjb3BlU2VsZWN0b3IgKyAnXSc7XG4gICAgICAgIGNvbnN0IF9zY29wZVNlbGVjdG9yUGFydCA9IChwKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2NvcGVkUCA9IHAudHJpbSgpO1xuICAgICAgICAgICAgaWYgKCFzY29wZWRQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHAuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVkUCA9IHRoaXMuX2FwcGx5U2ltcGxlU2VsZWN0b3JTY29wZShwLCBzY29wZVNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIDpob3N0IHNpbmNlIGl0IHNob3VsZCBiZSB1bm5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBwLnJlcGxhY2UoX3BvbHlmaWxsSG9zdFJlLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gdC5tYXRjaCgvKFteOl0qKSg6KikoLiopLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZWRQID0gbWF0Y2hlc1sxXSArIGF0dHJOYW1lICsgbWF0Y2hlc1syXSArIG1hdGNoZXNbM107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkUDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2FmZUNvbnRlbnQgPSBuZXcgU2FmZVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgc2VsZWN0b3IgPSBzYWZlQ29udGVudC5jb250ZW50KCk7XG4gICAgICAgIGxldCBzY29wZWRTZWxlY3RvciA9ICcnO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIGNvbnN0IHNlcCA9IC8oIHw+fFxcK3x+KD8hPSkpXFxzKi9nO1xuICAgICAgICAvLyBJZiBhIHNlbGVjdG9yIGFwcGVhcnMgYmVmb3JlIDpob3N0IGl0IHNob3VsZCBub3QgYmUgc2hpbW1lZCBhcyBpdFxuICAgICAgICAvLyBtYXRjaGVzIG9uIGFuY2VzdG9yIGVsZW1lbnRzIGFuZCBub3Qgb24gZWxlbWVudHMgaW4gdGhlIGhvc3QncyBzaGFkb3dcbiAgICAgICAgLy8gYDpob3N0LWNvbnRleHQoZGl2KWAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gYC1zaGFkb3djc3Nob3N0LW5vLWNvbWJpbmF0b3JkaXYsIGRpdiAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYFxuICAgICAgICAvLyB0aGUgYGRpdmAgaXMgbm90IHBhcnQgb2YgdGhlIGNvbXBvbmVudCBpbiB0aGUgMm5kIHNlbGVjdG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBzY29wZWQuXG4gICAgICAgIC8vIEhpc3RvcmljYWxseSBgY29tcG9uZW50LXRhZzpob3N0YCB3YXMgbWF0Y2hpbmcgdGhlIGNvbXBvbmVudCBzbyB3ZSBhbHNvIHdhbnQgdG8gcHJlc2VydmVcbiAgICAgICAgLy8gdGhpcyBiZWhhdmlvciB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcyAoaXQgc2hvdWxkIG5vdCBtYXRjaCkuXG4gICAgICAgIC8vIFRoZSBiZWhhdmlvciBzaG91bGQgYmU6XG4gICAgICAgIC8vIC0gYHRhZzpob3N0YCAtPiBgdGFnW2hdYCAodGhpcyBpcyB0byBhdm9pZCBicmVha2luZyBsZWdhY3kgYXBwcywgc2hvdWxkIG5vdCBtYXRjaCBhbnl0aGluZylcbiAgICAgICAgLy8gLSBgdGFnIDpob3N0YCAtPiBgdGFnIFtoXWAgKGB0YWdgIGlzIG5vdCBzY29wZWQgYmVjYXVzZSBpdCdzIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgICAgIC8vICAgYDpob3N0LWNvbnRleHQodGFnKWApXG4gICAgICAgIGNvbnN0IGhhc0hvc3QgPSBzZWxlY3Rvci5pbmRleE9mKF9wb2x5ZmlsbEhvc3ROb0NvbWJpbmF0b3IpID4gLTE7XG4gICAgICAgIC8vIE9ubHkgc2NvcGUgcGFydHMgYWZ0ZXIgdGhlIGZpcnN0IGAtc2hhZG93Y3NzaG9zdC1uby1jb21iaW5hdG9yYCB3aGVuIGl0IGlzIHByZXNlbnRcbiAgICAgICAgbGV0IHNob3VsZFNjb3BlID0gIWhhc0hvc3Q7XG4gICAgICAgIHdoaWxlICgocmVzID0gc2VwLmV4ZWMoc2VsZWN0b3IpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gcmVzWzFdO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnNsaWNlKHN0YXJ0SW5kZXgsIHJlcy5pbmRleCkudHJpbSgpO1xuICAgICAgICAgICAgLy8gQSBzcGFjZSBmb2xsb3dpbmcgYW4gZXNjYXBlZCBoZXggdmFsdWUgYW5kIGZvbGxvd2VkIGJ5IGFub3RoZXIgaGV4IGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gKGllOiBcIi5cXGZjIGJlclwiIGZvciBcIi7DvGJlclwiKSBpcyBub3QgYSBzZXBhcmF0b3IgYmV0d2VlbiAyIHNlbGVjdG9yc1xuICAgICAgICAgICAgLy8gYWxzbyBrZWVwIGluIG1pbmQgdGhhdCBiYWNrc2xhc2hlcyBhcmUgcmVwbGFjZWQgYnkgYSBwbGFjZWhvbGRlciBieSBTYWZlU2VsZWN0b3JcbiAgICAgICAgICAgIC8vIFRoZXNlIGVzY2FwZWQgc2VsZWN0b3JzIGhhcHBlbiBmb3IgZXhhbXBsZSB3aGVuIGVzYnVpbGQgcnVucyB3aXRoIG9wdGltaXphdGlvbi5taW5pZnkuXG4gICAgICAgICAgICBpZiAocGFydC5tYXRjaChfcGxhY2Vob2xkZXJSZSkgJiYgc2VsZWN0b3JbcmVzLmluZGV4ICsgMV0/Lm1hdGNoKC9bYS1mQS1GXFxkXS8pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRTY29wZSA9IHNob3VsZFNjb3BlIHx8IHBhcnQuaW5kZXhPZihfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yKSA+IC0xO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVkUGFydCA9IHNob3VsZFNjb3BlID8gX3Njb3BlU2VsZWN0b3JQYXJ0KHBhcnQpIDogcGFydDtcbiAgICAgICAgICAgIHNjb3BlZFNlbGVjdG9yICs9IGAke3Njb3BlZFBhcnR9ICR7c2VwYXJhdG9yfSBgO1xuICAgICAgICAgICAgc3RhcnRJbmRleCA9IHNlcC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydCA9IHNlbGVjdG9yLnN1YnN0cmluZyhzdGFydEluZGV4KTtcbiAgICAgICAgc2hvdWxkU2NvcGUgPSBzaG91bGRTY29wZSB8fCBwYXJ0LmluZGV4T2YoX3BvbHlmaWxsSG9zdE5vQ29tYmluYXRvcikgPiAtMTtcbiAgICAgICAgc2NvcGVkU2VsZWN0b3IgKz0gc2hvdWxkU2NvcGUgPyBfc2NvcGVTZWxlY3RvclBhcnQocGFydCkgOiBwYXJ0O1xuICAgICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlcnMgd2l0aCB0aGVpciBvcmlnaW5hbCB2YWx1ZXNcbiAgICAgICAgcmV0dXJuIHNhZmVDb250ZW50LnJlc3RvcmUoc2NvcGVkU2VsZWN0b3IpO1xuICAgIH1cbiAgICBfaW5zZXJ0UG9seWZpbGxIb3N0SW5Dc3NUZXh0KHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKF9jb2xvbkhvc3RDb250ZXh0UmUsIF9wb2x5ZmlsbEhvc3RDb250ZXh0KVxuICAgICAgICAgICAgLnJlcGxhY2UoX2NvbG9uSG9zdFJlLCBfcG9seWZpbGxIb3N0KTtcbiAgICB9XG59XG5jbGFzcyBTYWZlU2VsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJzID0gW107XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBSZXBsYWNlcyBhdHRyaWJ1dGUgc2VsZWN0b3JzIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAgICAvLyBUaGUgV1MgaW4gW2F0dHI9XCJ2YSBsdWVcIl0gd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIGEgc2VsZWN0b3Igc2VwYXJhdG9yLlxuICAgICAgICBzZWxlY3RvciA9IHRoaXMuX2VzY2FwZVJlZ2V4TWF0Y2hlcyhzZWxlY3RvciwgLyhcXFtbXlxcXV0qXFxdKS9nKTtcbiAgICAgICAgLy8gQ1NTIGFsbG93cyBmb3IgY2VydGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMgdG8gYmUgdXNlZCBpbiBzZWxlY3RvcnMgaWYgdGhleSdyZSBlc2NhcGVkLlxuICAgICAgICAvLyBFLmcuIGAuZm9vOmJsdWVgIHdvbid0IG1hdGNoIGEgY2xhc3MgY2FsbGVkIGBmb286Ymx1ZWAsIGJlY2F1c2UgdGhlIGNvbG9uIGRlbm90ZXMgYVxuICAgICAgICAvLyBwc2V1ZG8tY2xhc3MsIGJ1dCB3cml0aW5nIGAuZm9vXFw6Ymx1ZWAgd2lsbCBtYXRjaCwgYmVjYXVzZSB0aGUgY29sb24gd2FzIGVzY2FwZWQuXG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIGVzY2FwZSBzZXF1ZW5jZXMgKGBcXGAgZm9sbG93ZWQgYnkgYSBjaGFyYWN0ZXIpIHdpdGggYSBwbGFjZWhvbGRlciBzb1xuICAgICAgICAvLyB0aGF0IG91ciBoYW5kbGluZyBvZiBwc2V1ZG8tc2VsZWN0b3JzIGRvZXNuJ3QgbWVzcyB3aXRoIHRoZW0uXG4gICAgICAgIHNlbGVjdG9yID0gdGhpcy5fZXNjYXBlUmVnZXhNYXRjaGVzKHNlbGVjdG9yLCAvKFxcXFwuKS9nKTtcbiAgICAgICAgLy8gUmVwbGFjZXMgdGhlIGV4cHJlc3Npb24gaW4gYDpudGgtY2hpbGQoMm4gKyAxKWAgd2l0aCBhIHBsYWNlaG9sZGVyLlxuICAgICAgICAvLyBXUyBhbmQgXCIrXCIgd291bGQgb3RoZXJ3aXNlIGJlIGludGVycHJldGVkIGFzIHNlbGVjdG9yIHNlcGFyYXRvcnMuXG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBzZWxlY3Rvci5yZXBsYWNlKC8oOm50aC1bLVxcd10rKShcXChbXildK1xcKSkvZywgKF8sIHBzZXVkbywgZXhwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlQnkgPSBgX19waC0ke3RoaXMuaW5kZXh9X19gO1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMucHVzaChleHApO1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICAgICAgcmV0dXJuIHBzZXVkbyArIHJlcGxhY2VCeTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc3RvcmUoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9wbGFjZWhvbGRlclJlLCAoX3BoLCBpbmRleCkgPT4gdGhpcy5wbGFjZWhvbGRlcnNbK2luZGV4XSk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN1YnN0cmluZ3MgdGhhdCBtYXRjaCBhIHJlZ2V4IHdpdGhpbiBhXG4gICAgICogc3BlY2lhbCBzdHJpbmcgKGUuZy4gYF9fcGgtMF9fYCwgYF9fcGgtMV9fYCwgZXRjKS5cbiAgICAgKi9cbiAgICBfZXNjYXBlUmVnZXhNYXRjaGVzKGNvbnRlbnQsIHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZShwYXR0ZXJuLCAoXywga2VlcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZUJ5ID0gYF9fcGgtJHt0aGlzLmluZGV4fV9fYDtcbiAgICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXJzLnB1c2goa2VlcCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUJ5O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBfY3NzQ29udGVudE5leHRTZWxlY3RvclJlID0gL3BvbHlmaWxsLW5leHQtc2VsZWN0b3JbXn1dKmNvbnRlbnQ6W1xcc10qPyhbJ1wiXSkoLio/KVxcMVs7XFxzXSp9KFtee10qPyl7L2dpbTtcbmNvbnN0IF9jc3NDb250ZW50UnVsZVJlID0gLyhwb2x5ZmlsbC1ydWxlKVtefV0qKGNvbnRlbnQ6W1xcc10qKFsnXCJdKSguKj8pXFwzKVs7XFxzXSpbXn1dKn0vZ2ltO1xuY29uc3QgX2Nzc0NvbnRlbnRVbnNjb3BlZFJ1bGVSZSA9IC8ocG9seWZpbGwtdW5zY29wZWQtcnVsZSlbXn1dKihjb250ZW50OltcXHNdKihbJ1wiXSkoLio/KVxcMylbO1xcc10qW159XSp9L2dpbTtcbmNvbnN0IF9wb2x5ZmlsbEhvc3QgPSAnLXNoYWRvd2Nzc2hvc3QnO1xuLy8gbm90ZTogOmhvc3QtY29udGV4dCBwcmUtcHJvY2Vzc2VkIHRvIC1zaGFkb3djc3Nob3N0Y29udGV4dC5cbmNvbnN0IF9wb2x5ZmlsbEhvc3RDb250ZXh0ID0gJy1zaGFkb3djc3Njb250ZXh0JztcbmNvbnN0IF9wYXJlblN1ZmZpeCA9ICcoPzpcXFxcKCgnICtcbiAgICAnKD86XFxcXChbXikoXSpcXFxcKXxbXikoXSopKz8nICtcbiAgICAnKVxcXFwpKT8oW14se10qKSc7XG5jb25zdCBfY3NzQ29sb25Ib3N0UmUgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3QgKyBfcGFyZW5TdWZmaXgsICdnaW0nKTtcbmNvbnN0IF9jc3NDb2xvbkhvc3RDb250ZXh0UmVHbG9iYWwgPSBuZXcgUmVnRXhwKF9wb2x5ZmlsbEhvc3RDb250ZXh0ICsgX3BhcmVuU3VmZml4LCAnZ2ltJyk7XG5jb25zdCBfY3NzQ29sb25Ib3N0Q29udGV4dFJlID0gbmV3IFJlZ0V4cChfcG9seWZpbGxIb3N0Q29udGV4dCArIF9wYXJlblN1ZmZpeCwgJ2ltJyk7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yID0gX3BvbHlmaWxsSG9zdCArICctbm8tY29tYmluYXRvcic7XG5jb25zdCBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yUmUgPSAvLXNoYWRvd2Nzc2hvc3Qtbm8tY29tYmluYXRvcihbXlxcc10qKS87XG5jb25zdCBfc2hhZG93RE9NU2VsZWN0b3JzUmUgPSBbXG4gICAgLzo6c2hhZG93L2csXG4gICAgLzo6Y29udGVudC9nLFxuICAgIC8vIERlcHJlY2F0ZWQgc2VsZWN0b3JzXG4gICAgL1xcL3NoYWRvdy1kZWVwXFwvL2csXG4gICAgL1xcL3NoYWRvd1xcLy9nLFxuXTtcbi8vIFRoZSBkZWVwIGNvbWJpbmF0b3IgaXMgZGVwcmVjYXRlZCBpbiB0aGUgQ1NTIHNwZWNcbi8vIFN1cHBvcnQgZm9yIGA+Pj5gLCBgZGVlcGAsIGA6Om5nLWRlZXBgIGlzIHRoZW4gYWxzbyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL3B1bGwvMTc2NzdcbmNvbnN0IF9zaGFkb3dEZWVwU2VsZWN0b3JzID0gLyg/Oj4+Pil8KD86XFwvZGVlcFxcLyl8KD86OjpuZy1kZWVwKS9nO1xuY29uc3QgX3NlbGVjdG9yUmVTdWZmaXggPSAnKFs+XFxcXHN+K1suLHs6XVtcXFxcc1xcXFxTXSopPyQnO1xuY29uc3QgX3BvbHlmaWxsSG9zdFJlID0gLy1zaGFkb3djc3Nob3N0L2dpbTtcbmNvbnN0IF9jb2xvbkhvc3RSZSA9IC86aG9zdC9naW07XG5jb25zdCBfY29sb25Ib3N0Q29udGV4dFJlID0gLzpob3N0LWNvbnRleHQvZ2ltO1xuY29uc3QgX2NvbW1lbnRSZSA9IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2c7XG5jb25zdCBfcGxhY2Vob2xkZXJSZSA9IC9fX3BoLShcXGQrKV9fL2c7XG5mdW5jdGlvbiBzdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoX2NvbW1lbnRSZSwgJycpO1xufVxuY29uc3QgX2NvbW1lbnRXaXRoSGFzaFJlID0gL1xcL1xcKlxccyojXFxzKnNvdXJjZShNYXBwaW5nKT9VUkw9W1xcc1xcU10rP1xcKlxcLy9nO1xuZnVuY3Rpb24gZXh0cmFjdENvbW1lbnRzV2l0aEhhc2goaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQubWF0Y2goX2NvbW1lbnRXaXRoSGFzaFJlKSB8fCBbXTtcbn1cbmNvbnN0IEJMT0NLX1BMQUNFSE9MREVSID0gJyVCTE9DSyUnO1xuY29uc3QgX3J1bGVSZSA9IC8oXFxzKikoW147XFx7XFx9XSs/KShcXHMqKSgoPzp7JUJMT0NLJX0/XFxzKjs/KXwoPzpcXHMqOykpL2c7XG5jb25zdCBDT05URU5UX1BBSVJTID0gbmV3IE1hcChbWyd7JywgJ30nXV0pO1xuY29uc3QgQ09NTUFfSU5fUExBQ0VIT0xERVIgPSAnJUNPTU1BX0lOX1BMQUNFSE9MREVSJSc7XG5jb25zdCBTRU1JX0lOX1BMQUNFSE9MREVSID0gJyVTRU1JX0lOX1BMQUNFSE9MREVSJSc7XG5jb25zdCBDT0xPTl9JTl9QTEFDRUhPTERFUiA9ICclQ09MT05fSU5fUExBQ0VIT0xERVIlJztcbmNvbnN0IF9jc3NDb21tYUluUGxhY2Vob2xkZXJSZUdsb2JhbCA9IG5ldyBSZWdFeHAoQ09NTUFfSU5fUExBQ0VIT0xERVIsICdnJyk7XG5jb25zdCBfY3NzU2VtaUluUGxhY2Vob2xkZXJSZUdsb2JhbCA9IG5ldyBSZWdFeHAoU0VNSV9JTl9QTEFDRUhPTERFUiwgJ2cnKTtcbmNvbnN0IF9jc3NDb2xvbkluUGxhY2Vob2xkZXJSZUdsb2JhbCA9IG5ldyBSZWdFeHAoQ09MT05fSU5fUExBQ0VIT0xERVIsICdnJyk7XG5jbGFzcyBDc3NSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3RvciwgY29udGVudCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1J1bGVzKGlucHV0LCBydWxlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBlc2NhcGVkID0gZXNjYXBlSW5TdHJpbmdzKGlucHV0KTtcbiAgICBjb25zdCBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzID0gZXNjYXBlQmxvY2tzKGVzY2FwZWQsIENPTlRFTlRfUEFJUlMsIEJMT0NLX1BMQUNFSE9MREVSKTtcbiAgICBsZXQgbmV4dEJsb2NrSW5kZXggPSAwO1xuICAgIGNvbnN0IGVzY2FwZWRSZXN1bHQgPSBpbnB1dFdpdGhFc2NhcGVkQmxvY2tzLmVzY2FwZWRTdHJpbmcucmVwbGFjZShfcnVsZVJlLCAoLi4ubSkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IG1bMl07XG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgICAgIGxldCBzdWZmaXggPSBtWzRdO1xuICAgICAgICBsZXQgY29udGVudFByZWZpeCA9ICcnO1xuICAgICAgICBpZiAoc3VmZml4ICYmIHN1ZmZpeC5zdGFydHNXaXRoKCd7JyArIEJMT0NLX1BMQUNFSE9MREVSKSkge1xuICAgICAgICAgICAgY29udGVudCA9IGlucHV0V2l0aEVzY2FwZWRCbG9ja3MuYmxvY2tzW25leHRCbG9ja0luZGV4KytdO1xuICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZyhCTE9DS19QTEFDRUhPTERFUi5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGNvbnRlbnRQcmVmaXggPSAneyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVDYWxsYmFjayhuZXcgQ3NzUnVsZShzZWxlY3RvciwgY29udGVudCkpO1xuICAgICAgICByZXR1cm4gYCR7bVsxXX0ke3J1bGUuc2VsZWN0b3J9JHttWzNdfSR7Y29udGVudFByZWZpeH0ke3J1bGUuY29udGVudH0ke3N1ZmZpeH1gO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmVzY2FwZUluU3RyaW5ncyhlc2NhcGVkUmVzdWx0KTtcbn1cbmNsYXNzIFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzIHtcbiAgICBjb25zdHJ1Y3Rvcihlc2NhcGVkU3RyaW5nLCBibG9ja3MpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkU3RyaW5nID0gZXNjYXBlZFN0cmluZztcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfVxufVxuZnVuY3Rpb24gZXNjYXBlQmxvY2tzKGlucHV0LCBjaGFyUGFpcnMsIHBsYWNlaG9sZGVyKSB7XG4gICAgY29uc3QgcmVzdWx0UGFydHMgPSBbXTtcbiAgICBjb25zdCBlc2NhcGVkQmxvY2tzID0gW107XG4gICAgbGV0IG9wZW5DaGFyQ291bnQgPSAwO1xuICAgIGxldCBub25CbG9ja1N0YXJ0SW5kZXggPSAwO1xuICAgIGxldCBibG9ja1N0YXJ0SW5kZXggPSAtMTtcbiAgICBsZXQgb3BlbkNoYXI7XG4gICAgbGV0IGNsb3NlQ2hhcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICAgICAgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXIgPT09IGNsb3NlQ2hhcikge1xuICAgICAgICAgICAgb3BlbkNoYXJDb3VudC0tO1xuICAgICAgICAgICAgaWYgKG9wZW5DaGFyQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goaW5wdXQuc3Vic3RyaW5nKGJsb2NrU3RhcnRJbmRleCwgaSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFBhcnRzLnB1c2gocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgIG5vbkJsb2NrU3RhcnRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYmxvY2tTdGFydEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgb3BlbkNoYXIgPSBjbG9zZUNoYXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gb3BlbkNoYXIpIHtcbiAgICAgICAgICAgIG9wZW5DaGFyQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcGVuQ2hhckNvdW50ID09PSAwICYmIGNoYXJQYWlycy5oYXMoY2hhcikpIHtcbiAgICAgICAgICAgIG9wZW5DaGFyID0gY2hhcjtcbiAgICAgICAgICAgIGNsb3NlQ2hhciA9IGNoYXJQYWlycy5nZXQoY2hhcik7XG4gICAgICAgICAgICBvcGVuQ2hhckNvdW50ID0gMTtcbiAgICAgICAgICAgIGJsb2NrU3RhcnRJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgcmVzdWx0UGFydHMucHVzaChpbnB1dC5zdWJzdHJpbmcobm9uQmxvY2tTdGFydEluZGV4LCBibG9ja1N0YXJ0SW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2tTdGFydEluZGV4ICE9PSAtMSkge1xuICAgICAgICBlc2NhcGVkQmxvY2tzLnB1c2goaW5wdXQuc3Vic3RyaW5nKGJsb2NrU3RhcnRJbmRleCkpO1xuICAgICAgICByZXN1bHRQYXJ0cy5wdXNoKHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdFBhcnRzLnB1c2goaW5wdXQuc3Vic3RyaW5nKG5vbkJsb2NrU3RhcnRJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmluZ1dpdGhFc2NhcGVkQmxvY2tzKHJlc3VsdFBhcnRzLmpvaW4oJycpLCBlc2NhcGVkQmxvY2tzKTtcbn1cbi8qKlxuICogT2JqZWN0IGNvbnRhaW5pbmcgYXMga2V5cyBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIHN1YnN0aXR1dGVkIGJ5IHBsYWNlaG9sZGVyc1xuICogd2hlbiBmb3VuZCBpbiBzdHJpbmdzIGR1cmluZyB0aGUgY3NzIHRleHQgcGFyc2luZywgYW5kIGFzIHZhbHVlcyB0aGUgcmVzcGVjdGl2ZVxuICogcGxhY2Vob2xkZXJzXG4gKi9cbmNvbnN0IEVTQ0FQRV9JTl9TVFJJTkdfTUFQID0ge1xuICAgICc7JzogU0VNSV9JTl9QTEFDRUhPTERFUixcbiAgICAnLCc6IENPTU1BX0lOX1BMQUNFSE9MREVSLFxuICAgICc6JzogQ09MT05fSU5fUExBQ0VIT0xERVJcbn07XG4vKipcbiAqIFBhcnNlIHRoZSBwcm92aWRlZCBjc3MgdGV4dCBhbmQgaW5zaWRlIHN0cmluZ3MgKG1lYW5pbmcsIGluc2lkZSBwYWlycyBvZiB1bmVzY2FwZWQgc2luZ2xlIG9yXG4gKiBkb3VibGUgcXVvdGVzKSByZXBsYWNlIHNwZWNpZmljIGNoYXJhY3RlcnMgd2l0aCB0aGVpciByZXNwZWN0aXZlIHBsYWNlaG9sZGVycyBhcyBpbmRpY2F0ZWRcbiAqIGJ5IHRoZSBgRVNDQVBFX0lOX1NUUklOR19NQVBgIG1hcC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBjb252ZXJ0IHRoZSB0ZXh0XG4gKiAgYGFuaW1hdGlvbjogXCJteS1hbmltOmF0XFxcImlvblwiIDFzO2BcbiAqIHRvXG4gKiAgYGFuaW1hdGlvbjogXCJteS1hbmltJUNPTE9OX0lOX1BMQUNFSE9MREVSJWF0XFxcImlvblwiIDFzO2BcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byByZW1vdmUgdGhlIG1lYW5pbmcgb2Ygc29tZSBjaGFyYWN0ZXJzIHdoZW4gZm91bmQgaW5zaWRlIHN0cmluZ3NcbiAqIChmb3IgZXhhbXBsZSBgO2AgaW5kaWNhdGVzIHRoZSBlbmQgb2YgYSBjc3MgZGVjbGFyYXRpb24sIGAsYCB0aGUgc2VxdWVuY2Ugb2YgdmFsdWVzIGFuZCBgOmAgdGhlXG4gKiBkaXZpc2lvbiBiZXR3ZWVuIHByb3BlcnR5IGFuZCB2YWx1ZSBkdXJpbmcgYSBkZWNsYXJhdGlvbiwgbm9uZSBvZiB0aGVzZSBtZWFuaW5ncyBhcHBseSB3aGVuIHN1Y2hcbiAqIGNoYXJhY3RlcnMgYXJlIHdpdGhpbiBzdHJpbmdzIGFuZCBzbyBpbiBvcmRlciB0byBwcmV2ZW50IHBhcnNpbmcgaXNzdWVzIHRoZXkgbmVlZCB0byBiZSByZXBsYWNlZFxuICogd2l0aCBwbGFjZWhvbGRlciB0ZXh0IGZvciB0aGUgZHVyYXRpb24gb2YgdGhlIGNzcyBtYW5pcHVsYXRpb24gcHJvY2VzcykuXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBvcmlnaW5hbCBjc3MgdGV4dC5cbiAqXG4gKiBAcmV0dXJucyB0aGUgY3NzIHRleHQgd2l0aCBzcGVjaWZpYyBjaGFyYWN0ZXJzIGluIHN0cmluZ3MgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzLlxuICoqL1xuZnVuY3Rpb24gZXNjYXBlSW5TdHJpbmdzKGlucHV0KSB7XG4gICAgbGV0IHJlc3VsdCA9IGlucHV0O1xuICAgIGxldCBjdXJyZW50UXVvdGVDaGFyID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gcmVzdWx0W2ldO1xuICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1b3RlQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGluZGV4IGkgaXMgaW5zaWRlIGEgcXVvdGVkIHN1Yi1zdHJpbmdcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gY3VycmVudFF1b3RlQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVvdGVDaGFyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gRVNDQVBFX0lOX1NUUklOR19NQVBbY2hhcl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0LnN1YnN0cigwLCBpKX0ke3BsYWNlaG9sZGVyfSR7cmVzdWx0LnN1YnN0cihpICsgMSl9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcGxhY2Vob2xkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICdcXCcnIHx8IGNoYXIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVvdGVDaGFyID0gY2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXBsYWNlIGluIGEgc3RyaW5nIGFsbCBvY2N1cnJlbmNlcyBvZiBrZXlzIGluIHRoZSBgRVNDQVBFX0lOX1NUUklOR19NQVBgIG1hcCB3aXRoIHRoZWlyXG4gKiBvcmlnaW5hbCByZXByZXNlbnRhdGlvbiwgdGhpcyBpcyBzaW1wbHkgdXNlZCB0byByZXZlcnQgdGhlIGNoYW5nZXMgYXBwbGllZCBieSB0aGVcbiAqIGVzY2FwZUluU3RyaW5ncyBmdW5jdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZSBpdCByZXZlcnRzIHRoZSB0ZXh0OlxuICogIGBhbmltYXRpb246IFwibXktYW5pbSVDT0xPTl9JTl9QTEFDRUhPTERFUiVhdFxcXCJpb25cIiAxcztgXG4gKiB0byBpdCdzIG9yaWdpbmFsIGZvcm0gb2Y6XG4gKiAgYGFuaW1hdGlvbjogXCJteS1hbmltOmF0XFxcImlvblwiIDFzO2BcbiAqXG4gKiBOb3RlOiBGb3IgdGhlIHNha2Ugb2Ygc2ltcGxpY2l0eSB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoYXQgdGhlIHBsYWNlaG9sZGVycyBhcmVcbiAqIGFjdHVhbGx5IGluc2lkZSBzdHJpbmdzIGFzIGl0IHdvdWxkIGFueXdheSBiZSBleHRyZW1lbHkgdW5saWtlbHkgdG8gZmluZCB0aGVtIG91dHNpZGUgb2Ygc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgdGhlIGNzcyB0ZXh0IGNvbnRhaW5pbmcgdGhlIHBsYWNlaG9sZGVycy5cbiAqXG4gKiBAcmV0dXJucyB0aGUgY3NzIHRleHQgd2l0aG91dCB0aGUgcGxhY2Vob2xkZXJzLlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZUluU3RyaW5ncyhpbnB1dCkge1xuICAgIGxldCByZXN1bHQgPSBpbnB1dC5yZXBsYWNlKF9jc3NDb21tYUluUGxhY2Vob2xkZXJSZUdsb2JhbCwgJywnKTtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShfY3NzU2VtaUluUGxhY2Vob2xkZXJSZUdsb2JhbCwgJzsnKTtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShfY3NzQ29sb25JblBsYWNlaG9sZGVyUmVHbG9iYWwsICc6Jyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogVW5lc2NhcGUgYWxsIHF1b3RlcyBwcmVzZW50IGluIGEgc3RyaW5nLCBidXQgb25seSBpZiB0aGUgc3RyaW5nIHdhcyBhY3R1YWxseSBhbHJlYWR5XG4gKiBxdW90ZWQuXG4gKlxuICogVGhpcyBnZW5lcmF0ZXMgYSBcImNhbm9uaWNhbFwiIHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ3Mgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWF0Y2ggc3RyaW5nc1xuICogd2hpY2ggd291bGQgb3RoZXJ3aXNlIG9ubHkgZGlmZmVyIGJlY2F1c2Ugb2YgZGlmZmVyZW50bHkgZXNjYXBlZCBxdW90ZXMuXG4gKlxuICogRm9yIGV4YW1wbGUgaXQgY29udmVydHMgdGhlIHN0cmluZyAoYXNzdW1lZCB0byBiZSBxdW90ZWQpOlxuICogIGB0aGlzIFxcXFxcImlzXFxcXFwiIGEgXFxcXCdcXFxcXFxcXCd0ZXN0YFxuICogdG86XG4gKiAgYHRoaXMgXCJpc1wiIGEgJ1xcXFxcXFxcJ3Rlc3RgXG4gKiAobm90ZSB0aGF0IHRoZSBsYXR0ZXIgYmFja3NsYXNoZXMgYXJlIG5vdCByZW1vdmVkIGFzIHRoZXkgYXJlIG5vdCBhY3R1YWxseSBlc2NhcGluZyB0aGUgc2luZ2xlXG4gKiBxdW90ZSlcbiAqXG4gKlxuICogQHBhcmFtIGlucHV0IHRoZSBzdHJpbmcgcG9zc2libHkgY29udGFpbmluZyBlc2NhcGVkIHF1b3Rlcy5cbiAqIEBwYXJhbSBpc1F1b3RlZCBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3RyaW5nIHdhcyBxdW90ZWQgaW5zaWRlIGEgYmlnZ2VyIHN0cmluZyAoaWYgbm90XG4gKiB0aGVuIGl0IG1lYW5zIHRoYXQgaXQgZG9lc24ndCByZXByZXNlbnQgYW4gaW5uZXIgc3RyaW5nIGFuZCB0aHVzIG5vIHVuZXNjYXBpbmcgaXMgcmVxdWlyZWQpXG4gKlxuICogQHJldHVybnMgdGhlIHN0cmluZyBpbiB0aGUgXCJjYW5vbmljYWxcIiByZXByZXNlbnRhdGlvbiB3aXRob3V0IGVzY2FwZWQgcXVvdGVzLlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZVF1b3RlcyhzdHIsIGlzUXVvdGVkKSB7XG4gICAgcmV0dXJuICFpc1F1b3RlZCA/IHN0ciA6IHN0ci5yZXBsYWNlKC8oKD86XnxbXlxcXFxdKSg/OlxcXFxcXFxcKSopXFxcXCg/PVsnXCJdKS9nLCAnJDEnKTtcbn1cbi8qKlxuICogQ29tYmluZSB0aGUgYGNvbnRleHRTZWxlY3RvcnNgIHdpdGggdGhlIGBob3N0TWFya2VyYCBhbmQgdGhlIGBvdGhlclNlbGVjdG9yc2BcbiAqIHRvIGNyZWF0ZSBhIHNlbGVjdG9yIHRoYXQgbWF0Y2hlcyB0aGUgc2FtZSBhcyBgOmhvc3QtY29udGV4dCgpYC5cbiAqXG4gKiBHaXZlbiBhIHNpbmdsZSBjb250ZXh0IHNlbGVjdG9yIGBBYCB3ZSBuZWVkIHRvIG91dHB1dCBzZWxlY3RvcnMgdGhhdCBtYXRjaCBvbiB0aGUgaG9zdCBhbmQgYXMgYW5cbiAqIGFuY2VzdG9yIG9mIHRoZSBob3N0OlxuICpcbiAqIGBgYFxuICogQSA8aG9zdE1hcmtlcj4sIEE8aG9zdE1hcmtlcj4ge31cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjb250ZXh0IHNlbGVjdG9yIHdlIGFsc28gaGF2ZSB0byBjcmVhdGUgY29tYmluYXRpb25zIG9mIHRob3NlXG4gKiBzZWxlY3RvcnMgd2l0aCBlYWNoIG90aGVyLiBGb3IgZXhhbXBsZSBpZiB0aGVyZSBhcmUgYEFgIGFuZCBgQmAgc2VsZWN0b3JzIHRoZSBvdXRwdXQgaXM6XG4gKlxuICogYGBgXG4gKiBBQjxob3N0TWFya2VyPiwgQUIgPGhvc3RNYXJrZXI+LCBBIEI8aG9zdE1hcmtlcj4sXG4gKiBCIEE8aG9zdE1hcmtlcj4sIEEgQiA8aG9zdE1hcmtlcj4sIEIgQSA8aG9zdE1hcmtlcj4ge31cbiAqIGBgYFxuICpcbiAqIEFuZCBzbyBvbi4uLlxuICpcbiAqIEBwYXJhbSBob3N0TWFya2VyIHRoZSBzdHJpbmcgdGhhdCBzZWxlY3RzIHRoZSBob3N0IGVsZW1lbnQuXG4gKiBAcGFyYW0gY29udGV4dFNlbGVjdG9ycyBhbiBhcnJheSBvZiBjb250ZXh0IHNlbGVjdG9ycyB0aGF0IHdpbGwgYmUgY29tYmluZWQuXG4gKiBAcGFyYW0gb3RoZXJTZWxlY3RvcnMgdGhlIHJlc3Qgb2YgdGhlIHNlbGVjdG9ycyB0aGF0IGFyZSBub3QgY29udGV4dCBzZWxlY3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVIb3N0Q29udGV4dFNlbGVjdG9ycyhjb250ZXh0U2VsZWN0b3JzLCBvdGhlclNlbGVjdG9ycykge1xuICAgIGNvbnN0IGhvc3RNYXJrZXIgPSBfcG9seWZpbGxIb3N0Tm9Db21iaW5hdG9yO1xuICAgIF9wb2x5ZmlsbEhvc3RSZS5sYXN0SW5kZXggPSAwOyAvLyByZXNldCB0aGUgcmVnZXggdG8gZW5zdXJlIHdlIGdldCBhbiBhY2N1cmF0ZSB0ZXN0XG4gICAgY29uc3Qgb3RoZXJTZWxlY3RvcnNIYXNIb3N0ID0gX3BvbHlmaWxsSG9zdFJlLnRlc3Qob3RoZXJTZWxlY3RvcnMpO1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBjb250ZXh0IHNlbGVjdG9ycyB0aGVuIGp1c3Qgb3V0cHV0IGEgaG9zdCBtYXJrZXJcbiAgICBpZiAoY29udGV4dFNlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGhvc3RNYXJrZXIgKyBvdGhlclNlbGVjdG9ycztcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWQgPSBbY29udGV4dFNlbGVjdG9ycy5wb3AoKSB8fCAnJ107XG4gICAgd2hpbGUgKGNvbnRleHRTZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBjb21iaW5lZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNvbnRleHRTZWxlY3RvciA9IGNvbnRleHRTZWxlY3RvcnMucG9wKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2VsZWN0b3JzID0gY29tYmluZWRbaV07XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBzZWxlY3RvciBhcyBhIGRlc2NlbmRhbnQgb2YgdGhlIHByZXZpb3VzIHNlbGVjdG9yc1xuICAgICAgICAgICAgY29tYmluZWRbbGVuZ3RoICogMiArIGldID0gcHJldmlvdXNTZWxlY3RvcnMgKyAnICcgKyBjb250ZXh0U2VsZWN0b3I7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5ldyBzZWxlY3RvciBhcyBhbiBhbmNlc3RvciBvZiB0aGUgcHJldmlvdXMgc2VsZWN0b3JzXG4gICAgICAgICAgICBjb21iaW5lZFtsZW5ndGggKyBpXSA9IGNvbnRleHRTZWxlY3RvciArICcgJyArIHByZXZpb3VzU2VsZWN0b3JzO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgc2VsZWN0b3IgdG8gYWN0IG9uIHRoZSBzYW1lIGVsZW1lbnQgYXMgdGhlIHByZXZpb3VzIHNlbGVjdG9yc1xuICAgICAgICAgICAgY29tYmluZWRbaV0gPSBjb250ZXh0U2VsZWN0b3IgKyBwcmV2aW91c1NlbGVjdG9ycztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5hbGx5IGNvbm5lY3QgdGhlIHNlbGVjdG9yIHRvIHRoZSBgaG9zdE1hcmtlcmBzOiBlaXRoZXIgYWN0aW5nIGRpcmVjdGx5IG9uIHRoZSBob3N0XG4gICAgLy8gKEE8aG9zdE1hcmtlcj4pIG9yIGFzIGFuIGFuY2VzdG9yIChBIDxob3N0TWFya2VyPikuXG4gICAgcmV0dXJuIGNvbWJpbmVkXG4gICAgICAgIC5tYXAocyA9PiBvdGhlclNlbGVjdG9yc0hhc0hvc3QgP1xuICAgICAgICBgJHtzfSR7b3RoZXJTZWxlY3RvcnN9YCA6XG4gICAgICAgIGAke3N9JHtob3N0TWFya2VyfSR7b3RoZXJTZWxlY3RvcnN9LCAke3N9ICR7aG9zdE1hcmtlcn0ke290aGVyU2VsZWN0b3JzfWApXG4gICAgICAgIC5qb2luKCcsJyk7XG59XG4vKipcbiAqIE11dGF0ZSB0aGUgZ2l2ZW4gYGdyb3Vwc2AgYXJyYXkgc28gdGhhdCB0aGVyZSBhcmUgYG11bHRpcGxlc2AgY2xvbmVzIG9mIHRoZSBvcmlnaW5hbCBhcnJheVxuICogc3RvcmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGByZXBlYXRHcm91cHMoW2EsIGJdLCAzKWAgd2lsbCByZXN1bHQgaW4gYFthLCBiLCBhLCBiLCBhLCBiXWAgLSBidXQgaW1wb3J0YW50bHkgdGhlXG4gKiBuZXdseSBhZGRlZCBncm91cHMgd2lsbCBiZSBjbG9uZXMgb2YgdGhlIG9yaWdpbmFsLlxuICpcbiAqIEBwYXJhbSBncm91cHMgQW4gYXJyYXkgb2YgZ3JvdXBzIG9mIHN0cmluZ3MgdGhhdCB3aWxsIGJlIHJlcGVhdGVkLiBUaGlzIGFycmF5IGlzIG11dGF0ZWRcbiAqICAgICBpbi1wbGFjZS5cbiAqIEBwYXJhbSBtdWx0aXBsZXMgVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgY3VycmVudCBncm91cHMgc2hvdWxkIGFwcGVhci5cbiAqL1xuZnVuY3Rpb24gcmVwZWF0R3JvdXBzKGdyb3VwcywgbXVsdGlwbGVzKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ3JvdXBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG11bHRpcGxlczsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGdyb3Vwc1tqICsgKGkgKiBsZW5ndGgpXSA9IGdyb3Vwc1tqXS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgc3R5bGUgYW5kIGNvbnZlcnRzIGl0IGludG8gb2JqZWN0IGxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHZhbHVlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBzdHlsZSBhcyB1c2VkIGluIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZSBpbiBIVE1MLlxuICogICBFeGFtcGxlOiBgY29sb3I6IHJlZDsgaGVpZ2h0OiBhdXRvYC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0eWxlIHByb3BlcnR5IG5hbWUgYW5kIHZhbHVlIHBhaXJzLCBlLmcuIGBbJ2NvbG9yJywgJ3JlZCcsICdoZWlnaHQnLFxuICogJ2F1dG8nXWBcbiAqL1xuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICAvLyB3ZSB1c2UgYSBzdHJpbmcgYXJyYXkgaGVyZSBpbnN0ZWFkIG9mIGEgc3RyaW5nIG1hcFxuICAgIC8vIGJlY2F1c2UgYSBzdHJpbmctbWFwIGlzIG5vdCBndWFyYW50ZWVkIHRvIHJldGFpbiB0aGVcbiAgICAvLyBvcmRlciBvZiB0aGUgZW50cmllcyB3aGVyZWFzIGEgc3RyaW5nIGFycmF5IGNhbiBiZVxuICAgIC8vIGNvbnN0cnVjdGVkIGluIGEgW2tleSwgdmFsdWUsIGtleSwgdmFsdWVdIGZvcm1hdC5cbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHBhcmVuRGVwdGggPSAwO1xuICAgIGxldCBxdW90ZSA9IDAgLyogQ2hhci5RdW90ZU5vbmUgKi87XG4gICAgbGV0IHZhbHVlU3RhcnQgPSAwO1xuICAgIGxldCBwcm9wU3RhcnQgPSAwO1xuICAgIGxldCBjdXJyZW50UHJvcCA9IG51bGw7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB2YWx1ZS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgNDAgLyogQ2hhci5PcGVuUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MSAvKiBDaGFyLkNsb3NlUGFyZW4gKi86XG4gICAgICAgICAgICAgICAgcGFyZW5EZXB0aC0tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOSAvKiBDaGFyLlF1b3RlU2luZ2xlICovOlxuICAgICAgICAgICAgICAgIC8vIHZhbHVlU3RhcnQgbmVlZHMgdG8gYmUgdGhlcmUgc2luY2UgcHJvcCB2YWx1ZXMgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHF1b3RlcyBpbiBDU1NcbiAgICAgICAgICAgICAgICBpZiAocXVvdGUgPT09IDAgLyogQ2hhci5RdW90ZU5vbmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAzOSAvKiBDaGFyLlF1b3RlU2luZ2xlICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChxdW90ZSA9PT0gMzkgLyogQ2hhci5RdW90ZVNpbmdsZSAqLyAmJiB2YWx1ZS5jaGFyQ29kZUF0KGkgLSAxKSAhPT0gOTIgLyogQ2hhci5CYWNrU2xhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSAwIC8qIENoYXIuUXVvdGVOb25lICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzQgLyogQ2hhci5RdW90ZURvdWJsZSAqLzpcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGxvZ2ljIGFzIGFib3ZlXG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlID09PSAwIC8qIENoYXIuUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMzQgLyogQ2hhci5RdW90ZURvdWJsZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocXVvdGUgPT09IDM0IC8qIENoYXIuUXVvdGVEb3VibGUgKi8gJiYgdmFsdWUuY2hhckNvZGVBdChpIC0gMSkgIT09IDkyIC8qIENoYXIuQmFja1NsYXNoICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gMCAvKiBDaGFyLlF1b3RlTm9uZSAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU4IC8qIENoYXIuQ29sb24gKi86XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UHJvcCAmJiBwYXJlbkRlcHRoID09PSAwICYmIHF1b3RlID09PSAwIC8qIENoYXIuUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wID0gaHlwaGVuYXRlKHZhbHVlLnN1YnN0cmluZyhwcm9wU3RhcnQsIGkgLSAxKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU5IC8qIENoYXIuU2VtaWNvbG9uICovOlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcCAmJiB2YWx1ZVN0YXJ0ID4gMCAmJiBwYXJlbkRlcHRoID09PSAwICYmIHF1b3RlID09PSAwIC8qIENoYXIuUXVvdGVOb25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVmFsID0gdmFsdWUuc3Vic3RyaW5nKHZhbHVlU3RhcnQsIGkgLSAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKGN1cnJlbnRQcm9wLCBzdHlsZVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BTdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UHJvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50UHJvcCAmJiB2YWx1ZVN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVmFsID0gdmFsdWUuc2xpY2UodmFsdWVTdGFydCkudHJpbSgpO1xuICAgICAgICBzdHlsZXMucHVzaChjdXJyZW50UHJvcCwgc3R5bGVWYWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gaHlwaGVuYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC9bYS16XVtBLVpdL2csIHYgPT4ge1xuICAgICAgICByZXR1cm4gdi5jaGFyQXQoMCkgKyAnLScgKyB2LmNoYXJBdCgxKTtcbiAgICB9KVxuICAgICAgICAudG9Mb3dlckNhc2UoKTtcbn1cblxuY29uc3QgSU1QT1JUQU5UX0ZMQUcgPSAnIWltcG9ydGFudCc7XG4vKipcbiAqIE1pbmltdW0gYW1vdW50IG9mIGJpbmRpbmcgc2xvdHMgcmVxdWlyZWQgaW4gdGhlIHJ1bnRpbWUgZm9yIHN0eWxlL2NsYXNzIGJpbmRpbmdzLlxuICpcbiAqIFN0eWxpbmcgaW4gQW5ndWxhciB1c2VzIHVwIHR3byBzbG90cyBpbiB0aGUgcnVudGltZSBMVmlldy9URGF0YSBkYXRhIHN0cnVjdHVyZXMgdG9cbiAqIHJlY29yZCBiaW5kaW5nIGRhdGEsIHByb3BlcnR5IGluZm9ybWF0aW9uIGFuZCBtZXRhZGF0YS5cbiAqXG4gKiBXaGVuIGEgYmluZGluZyBpcyByZWdpc3RlcmVkIGl0IHdpbGwgcGxhY2UgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgYExWaWV3YDpcbiAqXG4gKiBzbG90IDEpIGJpbmRpbmcgdmFsdWVcbiAqIHNsb3QgMikgY2FjaGVkIHZhbHVlIChhbGwgb3RoZXIgdmFsdWVzIGNvbGxlY3RlZCBiZWZvcmUgaXQgaW4gc3RyaW5nIGZvcm0pXG4gKlxuICogV2hlbiBhIGJpbmRpbmcgaXMgcmVnaXN0ZXJlZCBpdCB3aWxsIHBsYWNlIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb24gaW4gdGhlIGBURGF0YWA6XG4gKlxuICogc2xvdCAxKSBwcm9wIG5hbWVcbiAqIHNsb3QgMikgYmluZGluZyBpbmRleCB0aGF0IHBvaW50cyB0byB0aGUgcHJldmlvdXMgc3R5bGUvY2xhc3MgYmluZGluZyAoYW5kIHNvbWUgZXh0cmEgY29uZmlnXG4gKiB2YWx1ZXMpXG4gKlxuICogTGV0J3MgaW1hZ2luZSB3ZSBoYXZlIGEgYmluZGluZyB0aGF0IGxvb2tzIGxpa2Ugc286XG4gKlxuICogYGBgXG4gKiA8ZGl2IFtzdHlsZS53aWR0aF09XCJ4XCIgW3N0eWxlLmhlaWdodF09XCJ5XCI+XG4gKiBgYGBcbiAqXG4gKiBPdXIgYExWaWV3YCBhbmQgYFREYXRhYCBkYXRhLXN0cnVjdHVyZXMgbG9vayBsaWtlIHNvOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIExWaWV3ID0gW1xuICogICAvLyAuLi5cbiAqICAgeCwgLy8gdmFsdWUgb2YgeFxuICogICBcIndpZHRoOiB4XCIsXG4gKlxuICogICB5LCAvLyB2YWx1ZSBvZiB5XG4gKiAgIFwid2lkdGg6IHg7IGhlaWdodDogeVwiLFxuICogICAvLyAuLi5cbiAqIF07XG4gKlxuICogVERhdGEgPSBbXG4gKiAgIC8vIC4uLlxuICogICBcIndpZHRoXCIsIC8vIGJpbmRpbmcgc2xvdCAyMFxuICogICAwLFxuICpcbiAqICAgXCJoZWlnaHRcIixcbiAqICAgMjAsXG4gKiAgIC8vIC4uLlxuICogXTtcbiAqIGBgYFxuICpcbiAqICovXG5jb25zdCBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEID0gMjtcbi8qKlxuICogUHJvZHVjZXMgY3JlYXRpb24vdXBkYXRlIGluc3RydWN0aW9ucyBmb3IgYWxsIHN0eWxpbmcgYmluZGluZ3MgKGNsYXNzIGFuZCBzdHlsZSlcbiAqXG4gKiBJdCBhbHNvIHByb2R1Y2VzIHRoZSBjcmVhdGlvbiBpbnN0cnVjdGlvbiB0byByZWdpc3RlciBhbGwgaW5pdGlhbCBzdHlsaW5nIHZhbHVlc1xuICogKHdoaWNoIGFyZSBhbGwgdGhlIHN0YXRpYyBjbGFzcz1cIi4uLlwiIGFuZCBzdHlsZT1cIi4uLlwiIGF0dHJpYnV0ZSB2YWx1ZXMgdGhhdCBleGlzdFxuICogb24gYW4gZWxlbWVudCB3aXRoaW4gYSB0ZW1wbGF0ZSkuXG4gKlxuICogVGhlIGJ1aWxkZXIgY2xhc3MgYmVsb3cgaGFuZGxlcyBwcm9kdWNpbmcgaW5zdHJ1Y3Rpb25zIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICpcbiAqIC0gU3RhdGljIHN0eWxlL2NsYXNzIGF0dHJpYnV0ZXMgKHN0eWxlPVwiLi4uXCIgYW5kIGNsYXNzPVwiLi4uXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgbWFwIGJpbmRpbmdzIChbc3R5bGVdPVwibWFwXCIgYW5kIFtjbGFzc109XCJtYXB8c3RyaW5nXCIpXG4gKiAtIER5bmFtaWMgc3R5bGUvY2xhc3MgcHJvcGVydHkgYmluZGluZ3MgKFtzdHlsZS5wcm9wXT1cImV4cFwiIGFuZCBbY2xhc3MubmFtZV09XCJleHBcIilcbiAqXG4gKiBEdWUgdG8gdGhlIGNvbXBsZXggcmVsYXRpb25zaGlwIG9mIGFsbCBvZiB0aGVzZSBjYXNlcywgdGhlIGluc3RydWN0aW9ucyBnZW5lcmF0ZWRcbiAqIGZvciB0aGVzZSBhdHRyaWJ1dGVzL3Byb3BlcnRpZXMvYmluZGluZ3MgbXVzdCBiZSBkb25lIHNvIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBUaGVcbiAqIG9yZGVyIHdoaWNoIHRoZXNlIG11c3QgYmUgZ2VuZXJhdGVkIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogaWYgKGNyZWF0ZU1vZGUpIHtcbiAqICAgc3R5bGluZyguLi4pXG4gKiB9XG4gKiBpZiAodXBkYXRlTW9kZSkge1xuICogICBzdHlsZU1hcCguLi4pXG4gKiAgIGNsYXNzTWFwKC4uLilcbiAqICAgc3R5bGVQcm9wKC4uLilcbiAqICAgY2xhc3NQcm9wKC4uLilcbiAqIH1cbiAqXG4gKiBUaGUgY3JlYXRpb24vdXBkYXRlIG1ldGhvZHMgd2l0aGluIHRoZSBidWlsZGVyIGNsYXNzIHByb2R1Y2UgdGhlc2UgaW5zdHJ1Y3Rpb25zLlxuICovXG5jbGFzcyBTdHlsaW5nQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoX2RpcmVjdGl2ZUV4cHIpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aXZlRXhwciA9IF9kaXJlY3RpdmVFeHByO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdGF0aWMgc3R5bGluZyB2YWx1ZXMgcHJlc2VudCAqL1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzdHlsaW5nIGJpbmRpbmdzIHByZXNlbnRcbiAgICAgICAgICogIChpLmUuIGBbc3R5bGVdYCwgYFtjbGFzc11gLCBgW3N0eWxlLnByb3BdYCBvciBgW2NsYXNzLm5hbWVdYClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNCaW5kaW5nc1dpdGhQaXBlcyA9IGZhbHNlO1xuICAgICAgICAvKiogdGhlIGlucHV0IGZvciBbY2xhc3NdIChpZiBpdCBleGlzdHMpICovXG4gICAgICAgIHRoaXMuX2NsYXNzTWFwSW5wdXQgPSBudWxsO1xuICAgICAgICAvKiogdGhlIGlucHV0IGZvciBbc3R5bGVdIChpZiBpdCBleGlzdHMpICovXG4gICAgICAgIHRoaXMuX3N0eWxlTWFwSW5wdXQgPSBudWxsO1xuICAgICAgICAvKiogYW4gYXJyYXkgb2YgZWFjaCBbc3R5bGUucHJvcF0gaW5wdXQgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMgPSBudWxsO1xuICAgICAgICAvKiogYW4gYXJyYXkgb2YgZWFjaCBbY2xhc3MubmFtZV0gaW5wdXQgKi9cbiAgICAgICAgdGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0U3R5bGluZ0lucHV0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgPSBudWxsO1xuICAgICAgICAvLyBtYXBzIGFyZSB1c2VkIGluc3RlYWQgb2YgaGFzaCBtYXBzIGJlY2F1c2UgYSBNYXAgd2lsbFxuICAgICAgICAvLyByZXRhaW4gdGhlIG9yZGVyaW5nIG9mIHRoZSBrZXlzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiBlYWNoIHN0eWxlIGJpbmRpbmcgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIChlLmcuIGA8ZGl2IFtzdHlsZS53aWR0aF09XCJ3XCIgW3N0eWxlLmhlaWdodF09XCJoXCI+YCBpbXBsaWVzXG4gICAgICAgICAqIHRoYXQgYHdpZHRoPTBgIGFuZCBgaGVpZ2h0PTFgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3R5bGVzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBsb2NhdGlvbiBvZiBlYWNoIGNsYXNzIGJpbmRpbmcgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgICAqIChlLmcuIGA8ZGl2IFtjbGFzcy5iaWddPVwiYlwiIFtjbGFzcy5oaWRkZW5dPVwiaFwiPmAgaW1wbGllc1xuICAgICAgICAgKiB0aGF0IGBiaWc9MGAgYW5kIGBoaWRkZW49MWApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jbGFzc2VzSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZ2l2ZW4gaW5wdXQgdG8gdGhlIHN0eWxpbmcgYnVpbGRlciB0byBiZSBsYXRlciB1c2VkIHdoZW4gcHJvZHVjaW5nIEFPVCBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIGNvZGUgYmVsb3cgd2lsbCBvbmx5IGFjY2VwdCB0aGUgaW5wdXQgaWYgaXQgaXMgc29tZWhvdyB0aWVkIHRvIHN0eWxpbmcgKHdoZXRoZXIgaXQgYmVcbiAgICAgKiBzdHlsZS9jbGFzcyBiaW5kaW5ncyBvciBzdGF0aWMgc3R5bGUvY2xhc3MgYXR0cmlidXRlcykuXG4gICAgICovXG4gICAgcmVnaXN0ZXJCb3VuZElucHV0KGlucHV0KSB7XG4gICAgICAgIC8vIFthdHRyLnN0eWxlXSBvciBbYXR0ci5jbGFzc10gYXJlIHNraXBwZWQgaW4gdGhlIGNvZGUgYmVsb3csXG4gICAgICAgIC8vIHRoZXkgc2hvdWxkIG5vdCBiZSB0cmVhdGVkIGFzIHN0eWxpbmctYmFzZWQgYmluZGluZ3Mgc2luY2VcbiAgICAgICAgLy8gdGhleSBhcmUgaW50ZW5kZWQgdG8gYmUgd3JpdHRlbiBkaXJlY3RseSB0byB0aGUgYXR0ciBhbmRcbiAgICAgICAgLy8gd2lsbCB0aGVyZWZvcmUgc2tpcCBhbGwgc3R5bGUvY2xhc3MgcmVzb2x1dGlvbiB0aGF0IGlzIHByZXNlbnRcbiAgICAgICAgLy8gd2l0aCBzdHlsZT1cIlwiLCBbc3R5bGVdPVwiXCIgYW5kIFtzdHlsZS5wcm9wXT1cIlwiLCBjbGFzcz1cIlwiLFxuICAgICAgICAvLyBbY2xhc3MucHJvcF09XCJcIi4gW2NsYXNzXT1cIlwiIGFzc2lnbm1lbnRzXG4gICAgICAgIGxldCBiaW5kaW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5hbWUgPSBpbnB1dC5uYW1lO1xuICAgICAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBCaW5kaW5nVHlwZS5Qcm9wZXJ0eSAqLzpcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5yZWdpc3RlcklucHV0QmFzZWRPbk5hbWUobmFtZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzIC8qIEJpbmRpbmdUeXBlLlN0eWxlICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyU3R5bGVJbnB1dChuYW1lLCBmYWxzZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4sIGlucHV0LnVuaXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyIC8qIEJpbmRpbmdUeXBlLkNsYXNzICovOlxuICAgICAgICAgICAgICAgIGJpbmRpbmcgPSB0aGlzLnJlZ2lzdGVyQ2xhc3NJbnB1dChuYW1lLCBmYWxzZSwgaW5wdXQudmFsdWUsIGlucHV0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICByZWdpc3RlcklucHV0QmFzZWRPbk5hbWUobmFtZSwgZXhwcmVzc2lvbiwgc291cmNlU3Bhbikge1xuICAgICAgICBsZXQgYmluZGluZyA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIDYpO1xuICAgICAgICBjb25zdCBpc1N0eWxlID0gbmFtZSA9PT0gJ3N0eWxlJyB8fCBwcmVmaXggPT09ICdzdHlsZS4nIHx8IHByZWZpeCA9PT0gJ3N0eWxlISc7XG4gICAgICAgIGNvbnN0IGlzQ2xhc3MgPSAhaXNTdHlsZSAmJiAobmFtZSA9PT0gJ2NsYXNzJyB8fCBwcmVmaXggPT09ICdjbGFzcy4nIHx8IHByZWZpeCA9PT0gJ2NsYXNzIScpO1xuICAgICAgICBpZiAoaXNTdHlsZSB8fCBpc0NsYXNzKSB7XG4gICAgICAgICAgICBjb25zdCBpc01hcEJhc2VkID0gbmFtZS5jaGFyQXQoNSkgIT09ICcuJzsgLy8gc3R5bGUucHJvcCBvciBjbGFzcy5wcm9wIG1ha2VzIHRoaXMgYSBub1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBuYW1lLnNsaWNlKGlzTWFwQmFzZWQgPyA1IDogNik7IC8vIHRoZSBkb3QgZXhwbGFpbnMgd2h5IHRoZXJlJ3MgYSArMVxuICAgICAgICAgICAgaWYgKGlzU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nID0gdGhpcy5yZWdpc3RlclN0eWxlSW5wdXQocHJvcGVydHksIGlzTWFwQmFzZWQsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZyA9IHRoaXMucmVnaXN0ZXJDbGFzc0lucHV0KHByb3BlcnR5LCBpc01hcEJhc2VkLCBleHByZXNzaW9uLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICB9XG4gICAgcmVnaXN0ZXJTdHlsZUlucHV0KG5hbWUsIGlzTWFwQmFzZWQsIHZhbHVlLCBzb3VyY2VTcGFuLCBzdWZmaXgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBjYXNlLXNlbnNpdGl2ZSBzbyB3ZSBzaG91bGRuJ3Qgbm9ybWFsaXplIHRoZW0uXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy12YXJpYWJsZXMtMS8jZGVmaW5pbmctdmFyaWFibGVzXG4gICAgICAgIGlmICghaXNDc3NDdXN0b21Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BlcnR5LCBoYXNPdmVycmlkZUZsYWcsIHN1ZmZpeDogYmluZGluZ1N1ZmZpeCB9ID0gcGFyc2VQcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgc3VmZml4ID0gdHlwZW9mIHN1ZmZpeCA9PT0gJ3N0cmluZycgJiYgc3VmZml4Lmxlbmd0aCAhPT0gMCA/IHN1ZmZpeCA6IGJpbmRpbmdTdWZmaXg7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0geyBuYW1lOiBwcm9wZXJ0eSwgc3VmZml4OiBzdWZmaXgsIHZhbHVlLCBzb3VyY2VTcGFuLCBoYXNPdmVycmlkZUZsYWcgfTtcbiAgICAgICAgaWYgKGlzTWFwQmFzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlTWFwSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICh0aGlzLl9zaW5nbGVTdHlsZUlucHV0cyA9IHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzIHx8IFtdKS5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIHJlZ2lzdGVySW50b01hcCh0aGlzLl9zdHlsZXNJbmRleCwgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RTdHlsaW5nSW5wdXQgPSBlbnRyeTtcbiAgICAgICAgdGhpcy5fZmlyc3RTdHlsaW5nSW5wdXQgPSB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCB8fCBlbnRyeTtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JQaXBlcyh2YWx1ZSk7XG4gICAgICAgIHRoaXMuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2xhc3NJbnB1dChuYW1lLCBpc01hcEJhc2VkLCB2YWx1ZSwgc291cmNlU3Bhbikge1xuICAgICAgICBpZiAoaXNFbXB0eUV4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHByb3BlcnR5LCBoYXNPdmVycmlkZUZsYWcgfSA9IHBhcnNlUHJvcGVydHkobmFtZSk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0geyBuYW1lOiBwcm9wZXJ0eSwgdmFsdWUsIHNvdXJjZVNwYW4sIGhhc092ZXJyaWRlRmxhZywgc3VmZml4OiBudWxsIH07XG4gICAgICAgIGlmIChpc01hcEJhc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc01hcElucHV0ID0gZW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMgPSB0aGlzLl9zaW5nbGVDbGFzc0lucHV0cyB8fCBbXSkucHVzaChlbnRyeSk7XG4gICAgICAgICAgICByZWdpc3RlckludG9NYXAodGhpcy5fY2xhc3Nlc0luZGV4LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbGFzdFN0eWxpbmdJbnB1dCA9IGVudHJ5O1xuICAgICAgICB0aGlzLl9maXJzdFN0eWxpbmdJbnB1dCA9IHRoaXMuX2ZpcnN0U3R5bGluZ0lucHV0IHx8IGVudHJ5O1xuICAgICAgICB0aGlzLl9jaGVja0ZvclBpcGVzKHZhbHVlKTtcbiAgICAgICAgdGhpcy5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgX2NoZWNrRm9yUGlwZXModmFsdWUpIHtcbiAgICAgICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIEFTVFdpdGhTb3VyY2UpICYmICh2YWx1ZS5hc3QgaW5zdGFuY2VvZiBCaW5kaW5nUGlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQmluZGluZ3NXaXRoUGlwZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZWxlbWVudCdzIHN0YXRpYyBzdHlsZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIHN0eWxlIHN0cmluZyAoZS5nLiBgd2lkdGg6MTAwcHg7IGhlaWdodDoyMDBweDtgKVxuICAgICAqL1xuICAgIHJlZ2lzdGVyU3R5bGVBdHRyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxTdHlsZVZhbHVlcyA9IHBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5faGFzSW5pdGlhbFZhbHVlcyA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZWxlbWVudCdzIHN0YXRpYyBjbGFzcyBzdHJpbmcgdmFsdWUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgdGhlIGNsYXNzTmFtZSBzdHJpbmcgKGUuZy4gYGRpc2FibGVkIGdvbGQgem9vbWApXG4gICAgICovXG4gICAgcmVnaXN0ZXJDbGFzc0F0dHIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzVmFsdWVzID0gdmFsdWUudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xuICAgICAgICB0aGlzLl9oYXNJbml0aWFsVmFsdWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhbGwgc3R5bGluZy1yZWxhdGVkIGV4cHJlc3Npb25zIHRvIHRoZSBwcm92aWRlZCBhdHRycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRycyBhbiBleGlzdGluZyBhcnJheSB3aGVyZSBlYWNoIG9mIHRoZSBzdHlsaW5nIGV4cHJlc3Npb25zXG4gICAgICogd2lsbCBiZSBpbnNlcnRlZCBpbnRvLlxuICAgICAqL1xuICAgIHBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyhhdHRycykge1xuICAgICAgICAvLyBbQ0xBU1NfTUFSS0VSLCAnZm9vJywgJ2JhcicsICdiYXonIC4uLl1cbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCgxIC8qIEF0dHJpYnV0ZU1hcmtlci5DbGFzc2VzICovKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luaXRpYWxDbGFzc1ZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2gobGl0ZXJhbCh0aGlzLl9pbml0aWFsQ2xhc3NWYWx1ZXNbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBbU1RZTEVfTUFSS0VSLCAnd2lkdGgnLCAnMjAwcHgnLCAnaGVpZ2h0JywgJzEwMHB4JywgLi4uXVxuICAgICAgICBpZiAodGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXR0cnMucHVzaChsaXRlcmFsKDIgLyogQXR0cmlidXRlTWFya2VyLlN0eWxlcyAqLykpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKGxpdGVyYWwodGhpcy5faW5pdGlhbFN0eWxlVmFsdWVzW2ldKSwgbGl0ZXJhbCh0aGlzLl9pbml0aWFsU3R5bGVWYWx1ZXNbaSArIDFdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGluc3RydWN0aW9uIHdpdGggYWxsIHRoZSBleHByZXNzaW9ucyBhbmQgcGFyYW1ldGVycyBmb3IgYGVsZW1lbnRIb3N0QXR0cnNgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGdlbmVyYXRpb24gY29kZSBiZWxvdyBpcyB1c2VkIGZvciBwcm9kdWNpbmcgdGhlIEFPVCBzdGF0ZW1lbnQgY29kZSB3aGljaCBpc1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciByZWdpc3RlcmluZyBpbml0aWFsIHN0eWxlcyAod2l0aGluIGEgZGlyZWN0aXZlIGhvc3RCaW5kaW5ncycgY3JlYXRpb24gYmxvY2spLFxuICAgICAqIGFzIHdlbGwgYXMgYW55IG9mIHRoZSBwcm92aWRlZCBhdHRyaWJ1dGUgdmFsdWVzLCB0byB0aGUgZGlyZWN0aXZlIGhvc3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBhc3NpZ25Ib3N0QXR0cnMoYXR0cnMsIGRlZmluaXRpb25NYXApIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGl2ZUV4cHIgJiYgKGF0dHJzLmxlbmd0aCB8fCB0aGlzLl9oYXNJbml0aWFsVmFsdWVzKSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1bGF0ZUluaXRpYWxTdHlsaW5nQXR0cnMoYXR0cnMpO1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2hvc3RBdHRycycsIGxpdGVyYWxBcnIoYXR0cnMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYW4gaW5zdHJ1Y3Rpb24gd2l0aCBhbGwgdGhlIGV4cHJlc3Npb25zIGFuZCBwYXJhbWV0ZXJzIGZvciBgY2xhc3NNYXBgLlxuICAgICAqXG4gICAgICogVGhlIGluc3RydWN0aW9uIGRhdGEgd2lsbCBjb250YWluIGFsbCBleHByZXNzaW9ucyBmb3IgYGNsYXNzTWFwYCB0byBmdW5jdGlvblxuICAgICAqIHdoaWNoIGluY2x1ZGVzIHRoZSBgW2NsYXNzXWAgZXhwcmVzc2lvbiBwYXJhbXMuXG4gICAgICovXG4gICAgYnVpbGRDbGFzc01hcEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGFzc01hcElucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCB0cnVlLCB0aGlzLl9jbGFzc01hcElucHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGluc3RydWN0aW9uIHdpdGggYWxsIHRoZSBleHByZXNzaW9ucyBhbmQgcGFyYW1ldGVycyBmb3IgYHN0eWxlTWFwYC5cbiAgICAgKlxuICAgICAqIFRoZSBpbnN0cnVjdGlvbiBkYXRhIHdpbGwgY29udGFpbiBhbGwgZXhwcmVzc2lvbnMgZm9yIGBzdHlsZU1hcGAgdG8gZnVuY3Rpb25cbiAgICAgKiB3aGljaCBpbmNsdWRlcyB0aGUgYFtzdHlsZV1gIGV4cHJlc3Npb24gcGFyYW1zLlxuICAgICAqL1xuICAgIGJ1aWxkU3R5bGVNYXBJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBpZiAodGhpcy5fc3R5bGVNYXBJbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkTWFwQmFzZWRJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlciwgZmFsc2UsIHRoaXMuX3N0eWxlTWFwSW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfYnVpbGRNYXBCYXNlZEluc3RydWN0aW9uKHZhbHVlQ29udmVydGVyLCBpc0NsYXNzQmFzZWQsIHN0eWxpbmdJbnB1dCkge1xuICAgICAgICAvLyBlYWNoIHN0eWxpbmcgYmluZGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIExWaWV3XG4gICAgICAgIC8vIG1hcC1iYXNlZCBiaW5kaW5ncyBhbGxvY2F0ZSB0d28gc2xvdHM6IG9uZSBmb3IgdGhlXG4gICAgICAgIC8vIHByZXZpb3VzIGJpbmRpbmcgdmFsdWUgYW5kIGFub3RoZXIgZm9yIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyBjbGFzc05hbWUgb3Igc3R5bGUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAgICBsZXQgdG90YWxCaW5kaW5nU2xvdHNSZXF1aXJlZCA9IE1JTl9TVFlMSU5HX0JJTkRJTkdfU0xPVFNfUkVRVUlSRUQ7XG4gICAgICAgIC8vIHRoZXNlIHZhbHVlcyBtdXN0IGJlIG91dHNpZGUgb2YgdGhlIHVwZGF0ZSBibG9jayBzbyB0aGF0IHRoZXkgY2FuXG4gICAgICAgIC8vIGJlIGV2YWx1YXRlZCAodGhlIEFTVCB2aXNpdCBjYWxsKSBkdXJpbmcgY3JlYXRpb24gdGltZSBzbyB0aGF0IGFueVxuICAgICAgICAvLyBwaXBlcyBjYW4gYmUgcGlja2VkIHVwIGluIHRpbWUgYmVmb3JlIHRoZSB0ZW1wbGF0ZSBpcyBidWlsdFxuICAgICAgICBjb25zdCBtYXBWYWx1ZSA9IHN0eWxpbmdJbnB1dC52YWx1ZS52aXNpdCh2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIGxldCByZWZlcmVuY2U7XG4gICAgICAgIGlmIChtYXBWYWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgKz0gbWFwVmFsdWUuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgcmVmZXJlbmNlID0gaXNDbGFzc0Jhc2VkID8gZ2V0Q2xhc3NNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihtYXBWYWx1ZSkgOlxuICAgICAgICAgICAgICAgIGdldFN0eWxlTWFwSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24obWFwVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmZXJlbmNlID0gaXNDbGFzc0Jhc2VkID8gSWRlbnRpZmllcnMuY2xhc3NNYXAgOiBJZGVudGlmaWVycy5zdHlsZU1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgY2FsbHM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRzSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3Bhbjogc3R5bGluZ0lucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIGFsbG9jYXRlQmluZGluZ1Nsb3RzOiB0b3RhbEJpbmRpbmdTbG90c1JlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IChjb252ZXJ0Rm4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRSZXN1bHQgPSBjb252ZXJ0Rm4obWFwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gQXJyYXkuaXNBcnJheShjb252ZXJ0UmVzdWx0KSA/IGNvbnZlcnRSZXN1bHQgOiBbY29udmVydFJlc3VsdF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2J1aWxkU2luZ2xlSW5wdXRzKHJlZmVyZW5jZSwgaW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgZ2V0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb25GbiwgaXNDbGFzc0Jhc2VkKSB7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0luc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2luc3RydWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQudmFsdWUudmlzaXQodmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZUZvckNhbGwgPSByZWZlcmVuY2U7XG4gICAgICAgICAgICAvLyBlYWNoIHN0eWxpbmcgYmluZGluZyB2YWx1ZSBpcyBzdG9yZWQgaW4gdGhlIExWaWV3XG4gICAgICAgICAgICAvLyBidXQgdGhlcmUgYXJlIHR3byB2YWx1ZXMgc3RvcmVkIGZvciBlYWNoIGJpbmRpbmc6XG4gICAgICAgICAgICAvLyAgIDEpIHRoZSB2YWx1ZSBpdHNlbGZcbiAgICAgICAgICAgIC8vICAgMikgYW4gaW50ZXJtZWRpYXRlIHZhbHVlIChjb25jYXRlbmF0aW9uIG9mIHN0eWxlIHVwIHRvIHRoaXMgcG9pbnQpLlxuICAgICAgICAgICAgLy8gICAgICBXZSBuZWVkIHRvIHN0b3JlIHRoZSBpbnRlcm1lZGlhdGUgdmFsdWUgc28gdGhhdCB3ZSBkb24ndCBhbGxvY2F0ZVxuICAgICAgICAgICAgLy8gICAgICB0aGUgc3RyaW5ncyBvbiBlYWNoIENELlxuICAgICAgICAgICAgbGV0IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgPSBNSU5fU1RZTElOR19CSU5ESU5HX1NMT1RTX1JFUVVJUkVEO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQgKz0gdmFsdWUuZXhwcmVzc2lvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZUZvckNhbGwgPSBnZXRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbkZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsID0ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgYWxsb2NhdGVCaW5kaW5nU2xvdHM6IHRvdGFsQmluZGluZ1Nsb3RzUmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNJbnRlcnBvbGF0aW9uOiAhIWdldEludGVycG9sYXRpb25FeHByZXNzaW9uRm4sXG4gICAgICAgICAgICAgICAgcGFyYW1zOiAoY29udmVydEZuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhcmFtcyA9PiBzdHlsaW5nUHJvcChwcm9wTmFtZSwgdmFsdWUsIHN1ZmZpeClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0UmVzdWx0ID0gY29udmVydEZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udmVydFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKC4uLmNvbnZlcnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goY29udmVydFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gW3N0eWxlLnByb3BdIGJpbmRpbmdzIG1heSB1c2Ugc3VmZml4IHZhbHVlcyAoZS5nLiBweCwgZW0sIGV0Yy4uLiksIHRoZXJlZm9yZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhhdCBpcyBkZXRlY3RlZCB0aGVuIHdlIG5lZWQgdG8gcGFzcyB0aGF0IGluIGFzIGFuIG9wdGlvbmFsIHBhcmFtLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ2xhc3NCYXNlZCAmJiBpbnB1dC5zdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwoaW5wdXQuc3VmZml4KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSWYgd2UgZW5kZWQgdXAgZ2VuZXJhdGluZyBhIGNhbGwgdG8gdGhlIHNhbWUgaW5zdHJ1Y3Rpb24gYXMgdGhlIHByZXZpb3VzIHN0eWxpbmcgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjaGFpbiB0aGUgY2FsbHMgdG9nZXRoZXIgc2FmZWx5IHRvIHNhdmUgc29tZSBieXRlcywgb3RoZXJ3aXNlIHdlIGhhdmUgdG8gZ2VuZXJhdGVcbiAgICAgICAgICAgIC8vIGEgc2VwYXJhdGUgaW5zdHJ1Y3Rpb24gY2FsbC4gVGhpcyBpcyBwcmltYXJpbHkgYSBjb25jZXJuIHdpdGggaW50ZXJwb2xhdGlvbiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAgIC8vIHdoZXJlIHdlIG1heSBzdGFydCBvZmYgd2l0aCBvbmUgYHJlZmVyZW5jZWAsIGJ1dCBlbmQgdXAgdXNpbmcgYW5vdGhlciBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBpbnRlcnBvbGF0aW9ucy5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c0luc3RydWN0aW9uICYmIHByZXZpb3VzSW5zdHJ1Y3Rpb24ucmVmZXJlbmNlID09PSByZWZlcmVuY2VGb3JDYWxsKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNJbnN0cnVjdGlvbi5jYWxscy5wdXNoKGNhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goeyByZWZlcmVuY2U6IHJlZmVyZW5jZUZvckNhbGwsIGNhbGxzOiBbY2FsbF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBfYnVpbGRDbGFzc0lucHV0cyh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlQ2xhc3NJbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNpbmdsZUlucHV0cyhJZGVudGlmaWVycy5jbGFzc1Byb3AsIHRoaXMuX3NpbmdsZUNsYXNzSW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBfYnVpbGRTdHlsZUlucHV0cyh2YWx1ZUNvbnZlcnRlcikge1xuICAgICAgICBpZiAodGhpcy5fc2luZ2xlU3R5bGVJbnB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9idWlsZFNpbmdsZUlucHV0cyhJZGVudGlmaWVycy5zdHlsZVByb3AsIHRoaXMuX3NpbmdsZVN0eWxlSW5wdXRzLCB2YWx1ZUNvbnZlcnRlciwgZ2V0U3R5bGVQcm9wSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYWxsIGluc3RydWN0aW9ucyB3aGljaCBjb250YWluIHRoZSBleHByZXNzaW9ucyB0aGF0IHdpbGwgYmUgcGxhY2VkXG4gICAgICogaW50byB0aGUgdXBkYXRlIGJsb2NrIG9mIGEgdGVtcGxhdGUgZnVuY3Rpb24gb3IgYSBkaXJlY3RpdmUgaG9zdEJpbmRpbmdzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGJ1aWxkVXBkYXRlTGV2ZWxJbnN0cnVjdGlvbnModmFsdWVDb252ZXJ0ZXIpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgICAgIGlmICh0aGlzLmhhc0JpbmRpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZU1hcEluc3RydWN0aW9uID0gdGhpcy5idWlsZFN0eWxlTWFwSW5zdHJ1Y3Rpb24odmFsdWVDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKHN0eWxlTWFwSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMucHVzaChzdHlsZU1hcEluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTWFwSW5zdHJ1Y3Rpb24gPSB0aGlzLmJ1aWxkQ2xhc3NNYXBJbnN0cnVjdGlvbih2YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAoY2xhc3NNYXBJbnN0cnVjdGlvbikge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKGNsYXNzTWFwSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4udGhpcy5fYnVpbGRTdHlsZUlucHV0cyh2YWx1ZUNvbnZlcnRlcikpO1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goLi4udGhpcy5fYnVpbGRDbGFzc0lucHV0cyh2YWx1ZUNvbnZlcnRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJJbnRvTWFwKG1hcCwga2V5KSB7XG4gICAgaWYgKCFtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbWFwLnNldChrZXksIG1hcC5zaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVByb3BlcnR5KG5hbWUpIHtcbiAgICBsZXQgaGFzT3ZlcnJpZGVGbGFnID0gZmFsc2U7XG4gICAgY29uc3Qgb3ZlcnJpZGVJbmRleCA9IG5hbWUuaW5kZXhPZihJTVBPUlRBTlRfRkxBRyk7XG4gICAgaWYgKG92ZXJyaWRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgIG5hbWUgPSBvdmVycmlkZUluZGV4ID4gMCA/IG5hbWUuc3Vic3RyaW5nKDAsIG92ZXJyaWRlSW5kZXgpIDogJyc7XG4gICAgICAgIGhhc092ZXJyaWRlRmxhZyA9IHRydWU7XG4gICAgfVxuICAgIGxldCBzdWZmaXggPSBudWxsO1xuICAgIGxldCBwcm9wZXJ0eSA9IG5hbWU7XG4gICAgY29uc3QgdW5pdEluZGV4ID0gbmFtZS5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmICh1bml0SW5kZXggPiAwKSB7XG4gICAgICAgIHN1ZmZpeCA9IG5hbWUuc2xpY2UodW5pdEluZGV4ICsgMSk7XG4gICAgICAgIHByb3BlcnR5ID0gbmFtZS5zdWJzdHJpbmcoMCwgdW5pdEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcHJvcGVydHksIHN1ZmZpeCwgaGFzT3ZlcnJpZGVGbGFnIH07XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgY2xhc3MgbWFwLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3NNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuY2xhc3NNYXA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmNsYXNzTWFwSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuY2xhc3NNYXBJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5jbGFzc01hcEludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgc3R5bGUgbWFwLlxuICogQHBhcmFtIGludGVycG9sYXRpb24gQW4gSW50ZXJwb2xhdGlvbiBBU1RcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVNYXBJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVNYXA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlTWFwSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVNYXBJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZU1hcEludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgc3R5bGUgcHJvcC5cbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlUHJvcEludGVycG9sYXRpb25FeHByZXNzaW9uKGludGVycG9sYXRpb24pIHtcbiAgICBzd2l0Y2ggKGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKGludGVycG9sYXRpb24pKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3A7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTI7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU1O1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5zdHlsZVByb3BJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuc3R5bGVQcm9wSW50ZXJwb2xhdGU4O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnN0eWxlUHJvcEludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gQ1NTIHByb3BlcnR5LlxuICogU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXZhcmlhYmxlcy0xXG4gKi9cbmZ1bmN0aW9uIGlzQ3NzQ3VzdG9tUHJvcGVydHkobmFtZSkge1xuICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoJy0tJyk7XG59XG5mdW5jdGlvbiBpc0VtcHR5RXhwcmVzc2lvbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgQVNUV2l0aFNvdXJjZSkge1xuICAgICAgICBhc3QgPSBhc3QuYXN0O1xuICAgIH1cbiAgICByZXR1cm4gYXN0IGluc3RhbmNlb2YgRW1wdHlFeHByO1xufVxuXG52YXIgVG9rZW5UeXBlO1xuKGZ1bmN0aW9uIChUb2tlblR5cGUpIHtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiQ2hhcmFjdGVyXCJdID0gMF0gPSBcIkNoYXJhY3RlclwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJJZGVudGlmaWVyXCJdID0gMV0gPSBcIklkZW50aWZpZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiUHJpdmF0ZUlkZW50aWZpZXJcIl0gPSAyXSA9IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiS2V5d29yZFwiXSA9IDNdID0gXCJLZXl3b3JkXCI7XG4gICAgVG9rZW5UeXBlW1Rva2VuVHlwZVtcIlN0cmluZ1wiXSA9IDRdID0gXCJTdHJpbmdcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiT3BlcmF0b3JcIl0gPSA1XSA9IFwiT3BlcmF0b3JcIjtcbiAgICBUb2tlblR5cGVbVG9rZW5UeXBlW1wiTnVtYmVyXCJdID0gNl0gPSBcIk51bWJlclwiO1xuICAgIFRva2VuVHlwZVtUb2tlblR5cGVbXCJFcnJvclwiXSA9IDddID0gXCJFcnJvclwiO1xufSkoVG9rZW5UeXBlIHx8IChUb2tlblR5cGUgPSB7fSkpO1xuY29uc3QgS0VZV09SRFMgPSBbJ3ZhcicsICdsZXQnLCAnYXMnLCAnbnVsbCcsICd1bmRlZmluZWQnLCAndHJ1ZScsICdmYWxzZScsICdpZicsICdlbHNlJywgJ3RoaXMnXTtcbmNsYXNzIExleGVyIHtcbiAgICB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBuZXcgX1NjYW5uZXIodGV4dCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB3aGlsZSAodG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgdG9rZW4gPSBzY2FubmVyLnNjYW5Ub2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBlbmQsIHR5cGUsIG51bVZhbHVlLCBzdHJWYWx1ZSkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bVZhbHVlID0gbnVtVmFsdWU7XG4gICAgICAgIHRoaXMuc3RyVmFsdWUgPSBzdHJWYWx1ZTtcbiAgICB9XG4gICAgaXNDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5DaGFyYWN0ZXIgJiYgdGhpcy5udW1WYWx1ZSA9PSBjb2RlO1xuICAgIH1cbiAgICBpc051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuTnVtYmVyO1xuICAgIH1cbiAgICBpc1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuU3RyaW5nO1xuICAgIH1cbiAgICBpc09wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLk9wZXJhdG9yICYmIHRoaXMuc3RyVmFsdWUgPT0gb3BlcmF0b3I7XG4gICAgfVxuICAgIGlzSWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuSWRlbnRpZmllcjtcbiAgICB9XG4gICAgaXNQcml2YXRlSWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuUHJpdmF0ZUlkZW50aWZpZXI7XG4gICAgfVxuICAgIGlzS2V5d29yZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZDtcbiAgICB9XG4gICAgaXNLZXl3b3JkTGV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2xldCc7XG4gICAgfVxuICAgIGlzS2V5d29yZEFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2FzJztcbiAgICB9XG4gICAgaXNLZXl3b3JkTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICdudWxsJztcbiAgICB9XG4gICAgaXNLZXl3b3JkVW5kZWZpbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGlzS2V5d29yZFRydWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gVG9rZW5UeXBlLktleXdvcmQgJiYgdGhpcy5zdHJWYWx1ZSA9PSAndHJ1ZSc7XG4gICAgfVxuICAgIGlzS2V5d29yZEZhbHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5LZXl3b3JkICYmIHRoaXMuc3RyVmFsdWUgPT0gJ2ZhbHNlJztcbiAgICB9XG4gICAgaXNLZXl3b3JkVGhpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuS2V5d29yZCAmJiB0aGlzLnN0clZhbHVlID09ICd0aGlzJztcbiAgICB9XG4gICAgaXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSBUb2tlblR5cGUuRXJyb3I7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IFRva2VuVHlwZS5OdW1iZXIgPyB0aGlzLm51bVZhbHVlIDogLTE7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuQ2hhcmFjdGVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLktleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5PcGVyYXRvcjpcbiAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLlByaXZhdGVJZGVudGlmaWVyOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuU3RyaW5nOlxuICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuRXJyb3I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyVmFsdWU7XG4gICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBuZXdDaGFyYWN0ZXJUb2tlbihpbmRleCwgZW5kLCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCBjb2RlLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbn1cbmZ1bmN0aW9uIG5ld0lkZW50aWZpZXJUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuSWRlbnRpZmllciwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdQcml2YXRlSWRlbnRpZmllclRva2VuKGluZGV4LCBlbmQsIHRleHQpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIFRva2VuVHlwZS5Qcml2YXRlSWRlbnRpZmllciwgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdLZXl3b3JkVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLktleXdvcmQsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3T3BlcmF0b3JUb2tlbihpbmRleCwgZW5kLCB0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuT3BlcmF0b3IsIDAsIHRleHQpO1xufVxuZnVuY3Rpb24gbmV3U3RyaW5nVG9rZW4oaW5kZXgsIGVuZCwgdGV4dCkge1xuICAgIHJldHVybiBuZXcgVG9rZW4oaW5kZXgsIGVuZCwgVG9rZW5UeXBlLlN0cmluZywgMCwgdGV4dCk7XG59XG5mdW5jdGlvbiBuZXdOdW1iZXJUb2tlbihpbmRleCwgZW5kLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbihpbmRleCwgZW5kLCBUb2tlblR5cGUuTnVtYmVyLCBuLCAnJyk7XG59XG5mdW5jdGlvbiBuZXdFcnJvclRva2VuKGluZGV4LCBlbmQsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKGluZGV4LCBlbmQsIFRva2VuVHlwZS5FcnJvciwgMCwgbWVzc2FnZSk7XG59XG5jb25zdCBFT0YgPSBuZXcgVG9rZW4oLTEsIC0xLCBUb2tlblR5cGUuQ2hhcmFjdGVyLCAwLCAnJyk7XG5jbGFzcyBfU2Nhbm5lciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLnBlZWsgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgYWR2YW5jZSgpIHtcbiAgICAgICAgdGhpcy5wZWVrID0gKyt0aGlzLmluZGV4ID49IHRoaXMubGVuZ3RoID8gJEVPRiA6IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgc2NhblRva2VuKCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQsIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBsZXQgcGVlayA9IHRoaXMucGVlaywgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UuXG4gICAgICAgIHdoaWxlIChwZWVrIDw9ICRTUEFDRSkge1xuICAgICAgICAgICAgaWYgKCsraW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcGVlayA9ICRFT0Y7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWVrID0gaW5wdXQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZWVrID0gcGVlaztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaWRlbnRpZmllcnMgYW5kIG51bWJlcnMuXG4gICAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChwZWVrKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5JZGVudGlmaWVyKCk7XG4gICAgICAgIGlmIChpc0RpZ2l0KHBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk51bWJlcihpbmRleCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaW5kZXg7XG4gICAgICAgIHN3aXRjaCAocGVlaykge1xuICAgICAgICAgICAgY2FzZSAkUEVSSU9EOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RpZ2l0KHRoaXMucGVlaykgPyB0aGlzLnNjYW5OdW1iZXIoc3RhcnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hhcmFjdGVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsICRQRVJJT0QpO1xuICAgICAgICAgICAgY2FzZSAkTFBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkUlBBUkVOOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkUkJSQUNFOlxuICAgICAgICAgICAgY2FzZSAkTEJSQUNLRVQ6XG4gICAgICAgICAgICBjYXNlICRSQlJBQ0tFVDpcbiAgICAgICAgICAgIGNhc2UgJENPTU1BOlxuICAgICAgICAgICAgY2FzZSAkQ09MT046XG4gICAgICAgICAgICBjYXNlICRTRU1JQ09MT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkNoYXJhY3RlcihzdGFydCwgcGVlayk7XG4gICAgICAgICAgICBjYXNlICRTUTpcbiAgICAgICAgICAgIGNhc2UgJERROlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5TdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJEhBU0g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblByaXZhdGVJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICBjYXNlICRQTFVTOlxuICAgICAgICAgICAgY2FzZSAkTUlOVVM6XG4gICAgICAgICAgICBjYXNlICRTVEFSOlxuICAgICAgICAgICAgY2FzZSAkU0xBU0g6XG4gICAgICAgICAgICBjYXNlICRQRVJDRU5UOlxuICAgICAgICAgICAgY2FzZSAkQ0FSRVQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Nhbk9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspKTtcbiAgICAgICAgICAgIGNhc2UgJFFVRVNUSU9OOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5RdWVzdGlvbihzdGFydCk7XG4gICAgICAgICAgICBjYXNlICRMVDpcbiAgICAgICAgICAgIGNhc2UgJEdUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsIFN0cmluZy5mcm9tQ2hhckNvZGUocGVlayksICRFUSwgJz0nKTtcbiAgICAgICAgICAgIGNhc2UgJEJBTkc6XG4gICAgICAgICAgICBjYXNlICRFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspLCAkRVEsICc9JywgJEVRLCAnPScpO1xuICAgICAgICAgICAgY2FzZSAkQU1QRVJTQU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5Db21wbGV4T3BlcmF0b3Ioc3RhcnQsICcmJywgJEFNUEVSU0FORCwgJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJEJBUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCAnfCcsICRCQVIsICd8Jyk7XG4gICAgICAgICAgICBjYXNlICROQlNQOlxuICAgICAgICAgICAgICAgIHdoaWxlIChpc1doaXRlc3BhY2UodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhblRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBbJHtTdHJpbmcuZnJvbUNoYXJDb2RlKHBlZWspfV1gLCAwKTtcbiAgICB9XG4gICAgc2NhbkNoYXJhY3RlcihzdGFydCwgY29kZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXJhY3RlclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBjb2RlKTtcbiAgICB9XG4gICAgc2Nhbk9wZXJhdG9yKHN0YXJ0LCBzdHIpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2tlbml6ZSBhIDIvMyBjaGFyIGxvbmcgb3BlcmF0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBzdGFydCBpbmRleCBpbiB0aGUgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSBvbmUgZmlyc3Qgc3ltYm9sIChhbHdheXMgcGFydCBvZiB0aGUgb3BlcmF0b3IpXG4gICAgICogQHBhcmFtIHR3b0NvZGUgY29kZSBwb2ludCBmb3IgdGhlIHNlY29uZCBzeW1ib2xcbiAgICAgKiBAcGFyYW0gdHdvIHNlY29uZCBzeW1ib2wgKHBhcnQgb2YgdGhlIG9wZXJhdG9yIHdoZW4gdGhlIHNlY29uZCBjb2RlIHBvaW50IG1hdGNoZXMpXG4gICAgICogQHBhcmFtIHRocmVlQ29kZSBjb2RlIHBvaW50IGZvciB0aGUgdGhpcmQgc3ltYm9sXG4gICAgICogQHBhcmFtIHRocmVlIHRoaXJkIHN5bWJvbCAocGFydCBvZiB0aGUgb3BlcmF0b3Igd2hlbiBwcm92aWRlZCBhbmQgbWF0Y2hlcyBzb3VyY2UgZXhwcmVzc2lvbilcbiAgICAgKi9cbiAgICBzY2FuQ29tcGxleE9wZXJhdG9yKHN0YXJ0LCBvbmUsIHR3b0NvZGUsIHR3bywgdGhyZWVDb2RlLCB0aHJlZSkge1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgbGV0IHN0ciA9IG9uZTtcbiAgICAgICAgaWYgKHRoaXMucGVlayA9PSB0d29Db2RlKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHN0ciArPSB0d287XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRocmVlQ29kZSAhPSBudWxsICYmIHRoaXMucGVlayA9PSB0aHJlZUNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgc3RyICs9IHRocmVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPcGVyYXRvclRva2VuKHN0YXJ0LCB0aGlzLmluZGV4LCBzdHIpO1xuICAgIH1cbiAgICBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgd2hpbGUgKGlzSWRlbnRpZmllclBhcnQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIHJldHVybiBLRVlXT1JEUy5pbmRleE9mKHN0cikgPiAtMSA/IG5ld0tleXdvcmRUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKSA6XG4gICAgICAgICAgICBuZXdJZGVudGlmaWVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHN0cik7XG4gICAgfVxuICAgIC8qKiBTY2FucyBhbiBFQ01BU2NyaXB0IHByaXZhdGUgaWRlbnRpZmllci4gKi9cbiAgICBzY2FuUHJpdmF0ZUlkZW50aWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyU3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIFsjXScsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNJZGVudGlmaWVyUGFydCh0aGlzLnBlZWspKVxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJOYW1lID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gbmV3UHJpdmF0ZUlkZW50aWZpZXJUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgaWRlbnRpZmllck5hbWUpO1xuICAgIH1cbiAgICBzY2FuTnVtYmVyKHN0YXJ0KSB7XG4gICAgICAgIGxldCBzaW1wbGUgPSAodGhpcy5pbmRleCA9PT0gc3RhcnQpO1xuICAgICAgICBsZXQgaGFzU2VwYXJhdG9ycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gU2tpcCBpbml0aWFsIGRpZ2l0LlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlZWsgPT09ICRfKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VwYXJhdG9ycyBhcmUgb25seSB2YWxpZCB3aGVuIHRoZXkncmUgc3Vycm91bmRlZCBieSBkaWdpdHMuIEUuZy4gYDFfMF8xYCBpc1xuICAgICAgICAgICAgICAgIC8vIHZhbGlkIHdoaWxlIGBfMTAxYCBhbmQgYDEwMV9gIGFyZSBub3QuIFRoZSBzZXBhcmF0b3IgY2FuJ3QgYmUgbmV4dCB0byB0aGUgZGVjaW1hbFxuICAgICAgICAgICAgICAgIC8vIHBvaW50IG9yIGFub3RoZXIgc2VwYXJhdG9yIGVpdGhlci4gTm90ZSB0aGF0IGl0J3MgdW5saWtlbHkgdGhhdCB3ZSdsbCBoaXQgYSBjYXNlIHdoZXJlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVuZGVyc2NvcmUgaXMgYXQgdGhlIHN0YXJ0LCBiZWNhdXNlIHRoYXQncyBhIHZhbGlkIGlkZW50aWZpZXIgYW5kIGl0IHdpbGwgYmUgcGlja2VkXG4gICAgICAgICAgICAgICAgLy8gdXAgZWFybGllciBpbiB0aGUgcGFyc2luZy4gV2UgdmFsaWRhdGUgZm9yIGl0IGFueXdheSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RpZ2l0KHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4IC0gMSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc0RpZ2l0KHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIG51bWVyaWMgc2VwYXJhdG9yJywgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc1NlcGFyYXRvcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09PSAkUEVSSU9EKSB7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0V4cG9uZW50U3RhcnQodGhpcy5wZWVrKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0V4cG9uZW50U2lnbih0aGlzLnBlZWspKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGlnaXQodGhpcy5wZWVrKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgZXhwb25lbnQnLCAtMSk7XG4gICAgICAgICAgICAgICAgc2ltcGxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHIgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICAgIGlmIChoYXNTZXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzaW1wbGUgPyBwYXJzZUludEF1dG9SYWRpeChzdHIpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgICAgICByZXR1cm4gbmV3TnVtYmVyVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgc2NhblN0cmluZygpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMucGVlaztcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIFNraXAgaW5pdGlhbCBxdW90ZS5cbiAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICBsZXQgbWFya2VyID0gdGhpcy5pbmRleDtcbiAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgICAgICB3aGlsZSAodGhpcy5wZWVrICE9IHF1b3RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrID09ICRCQUNLU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgICAgICAgbGV0IHVuZXNjYXBlZENvZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7IC8vIG11dGF0ZXMgdGhpcy5wZWVrXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzZWUgbWljcm9zb2Z0L1R5cGVTY3JpcHQjOTk5OFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlZWsgPT0gJHUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyYWN0ZXIgaGV4IGNvZGUgZm9yIHVuaWNvZGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBpbnB1dC5zdWJzdHJpbmcodGhpcy5pbmRleCArIDEsIHRoaXMuaW5kZXggKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eWzAtOWEtZl0rJC9pLnRlc3QoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHBhcnNlSW50KGhleCwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoYEludmFsaWQgdW5pY29kZSBlc2NhcGUgW1xcXFx1JHtoZXh9XWAsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkQ29kZSA9IHVuZXNjYXBlKHRoaXMucGVlayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmVzY2FwZWRDb2RlKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wZWVrID09ICRFT0YpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcignVW50ZXJtaW5hdGVkIHF1b3RlJywgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gaW5wdXQuc3Vic3RyaW5nKG1hcmtlciwgdGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBTa2lwIHRlcm1pbmF0aW5nIHF1b3RlLlxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nVG9rZW4oc3RhcnQsIHRoaXMuaW5kZXgsIGJ1ZmZlciArIGxhc3QpO1xuICAgIH1cbiAgICBzY2FuUXVlc3Rpb24oc3RhcnQpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgIGxldCBzdHIgPSAnPyc7XG4gICAgICAgIC8vIEVpdGhlciBgYSA/PyBiYCBvciAnYT8uYicuXG4gICAgICAgIGlmICh0aGlzLnBlZWsgPT09ICRRVUVTVElPTiB8fCB0aGlzLnBlZWsgPT09ICRQRVJJT0QpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBlZWsgPT09ICRQRVJJT0QgPyAnLicgOiAnPyc7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3BlcmF0b3JUb2tlbihzdGFydCwgdGhpcy5pbmRleCwgc3RyKTtcbiAgICB9XG4gICAgZXJyb3IobWVzc2FnZSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIG5ld0Vycm9yVG9rZW4ocG9zaXRpb24sIHRoaXMuaW5kZXgsIGBMZXhlciBFcnJvcjogJHttZXNzYWdlfSBhdCBjb2x1bW4gJHtwb3NpdGlvbn0gaW4gZXhwcmVzc2lvbiBbJHt0aGlzLmlucHV0fV1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gICAgcmV0dXJuICgkYSA8PSBjb2RlICYmIGNvZGUgPD0gJHopIHx8ICgkQSA8PSBjb2RlICYmIGNvZGUgPD0gJFopIHx8XG4gICAgICAgIChjb2RlID09ICRfKSB8fCAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IF9TY2FubmVyKGlucHV0KTtcbiAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KHNjYW5uZXIucGVlaykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB3aGlsZSAoc2Nhbm5lci5wZWVrICE9PSAkRU9GKSB7XG4gICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChzY2FubmVyLnBlZWspKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBzY2FubmVyLmFkdmFuY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNvZGUpIHtcbiAgICByZXR1cm4gaXNBc2NpaUxldHRlcihjb2RlKSB8fCBpc0RpZ2l0KGNvZGUpIHx8IChjb2RlID09ICRfKSB8fFxuICAgICAgICAoY29kZSA9PSAkJCk7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U3RhcnQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09ICRlIHx8IGNvZGUgPT0gJEU7XG59XG5mdW5jdGlvbiBpc0V4cG9uZW50U2lnbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT0gJE1JTlVTIHx8IGNvZGUgPT0gJFBMVVM7XG59XG5mdW5jdGlvbiB1bmVzY2FwZShjb2RlKSB7XG4gICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgIGNhc2UgJG46XG4gICAgICAgICAgICByZXR1cm4gJExGO1xuICAgICAgICBjYXNlICRmOlxuICAgICAgICAgICAgcmV0dXJuICRGRjtcbiAgICAgICAgY2FzZSAkcjpcbiAgICAgICAgICAgIHJldHVybiAkQ1I7XG4gICAgICAgIGNhc2UgJHQ6XG4gICAgICAgICAgICByZXR1cm4gJFRBQjtcbiAgICAgICAgY2FzZSAkdjpcbiAgICAgICAgICAgIHJldHVybiAkVlRBQjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50QXV0b1JhZGl4KHRleHQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBwYXJzZUludCh0ZXh0KTtcbiAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBsaXRlcmFsIHdoZW4gcGFyc2luZyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmNsYXNzIFNwbGl0SW50ZXJwb2xhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgZXhwcmVzc2lvbnMsIG9mZnNldHMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IGV4cHJlc3Npb25zO1xuICAgICAgICB0aGlzLm9mZnNldHMgPSBvZmZzZXRzO1xuICAgIH1cbn1cbmNsYXNzIFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZUJpbmRpbmdzLCB3YXJuaW5ncywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGVCaW5kaW5ncyA9IHRlbXBsYXRlQmluZGluZ3M7XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxufVxuY2xhc3MgUGFyc2VyJDEge1xuICAgIGNvbnN0cnVjdG9yKF9sZXhlcikge1xuICAgICAgICB0aGlzLl9sZXhlciA9IF9sZXhlcjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB9XG4gICAgcGFyc2VBY3Rpb24oaW5wdXQsIGlzQXNzaWdubWVudEV2ZW50LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrTm9JbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHNvdXJjZVRvTGV4KTtcbiAgICAgICAgbGV0IGZsYWdzID0gMSAvKiBQYXJzZUZsYWdzLkFjdGlvbiAqLztcbiAgICAgICAgaWYgKGlzQXNzaWdubWVudEV2ZW50KSB7XG4gICAgICAgICAgICBmbGFncyB8PSAyIC8qIFBhcnNlRmxhZ3MuQXNzaWdubWVudEV2ZW50ICovO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzdCA9IG5ldyBfUGFyc2VBU1QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCBmbGFncywgdGhpcy5lcnJvcnMsIDApLnBhcnNlQ2hhaW4oKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBwYXJzZUJpbmRpbmcoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nQXN0KGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UoYXN0LCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIGNoZWNrU2ltcGxlRXhwcmVzc2lvbihhc3QpIHtcbiAgICAgICAgY29uc3QgY2hlY2tlciA9IG5ldyBTaW1wbGVFeHByZXNzaW9uQ2hlY2tlcigpO1xuICAgICAgICBhc3QudmlzaXQoY2hlY2tlcik7XG4gICAgICAgIHJldHVybiBjaGVja2VyLmVycm9ycztcbiAgICB9XG4gICAgcGFyc2VTaW1wbGVCaW5kaW5nKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRpb25Db25maWcgPSBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHKSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX3BhcnNlQmluZGluZ0FzdChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCBpbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gdGhpcy5jaGVja1NpbXBsZUV4cHJlc3Npb24oYXN0KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgSG9zdCBiaW5kaW5nIGV4cHJlc3Npb24gY2Fubm90IGNvbnRhaW4gJHtlcnJvcnMuam9pbignICcpfWAsIGlucHV0LCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBfcmVwb3J0RXJyb3IobWVzc2FnZSwgaW5wdXQsIGVyckxvY2F0aW9uLCBjdHhMb2NhdGlvbikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZXJFcnJvcihtZXNzYWdlLCBpbnB1dCwgZXJyTG9jYXRpb24sIGN0eExvY2F0aW9uKSk7XG4gICAgfVxuICAgIF9wYXJzZUJpbmRpbmdBc3QoaW5wdXQsIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICB0aGlzLl9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBjb25zdCBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoaW5wdXQpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLl9sZXhlci50b2tlbml6ZShzb3VyY2VUb0xleCk7XG4gICAgICAgIHJldHVybiBuZXcgX1BhcnNlQVNUKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRva2VucywgMCAvKiBQYXJzZUZsYWdzLk5vbmUgKi8sIHRoaXMuZXJyb3JzLCAwKVxuICAgICAgICAgICAgLnBhcnNlQ2hhaW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgbWljcm9zeW50YXggdGVtcGxhdGUgZXhwcmVzc2lvbiBhbmQgcmV0dXJuIGEgbGlzdCBvZiBiaW5kaW5ncyBvclxuICAgICAqIHBhcnNpbmcgZXJyb3JzIGluIGNhc2UgdGhlIGdpdmVuIGV4cHJlc3Npb24gaXMgaW52YWxpZC5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLFxuICAgICAqIGBgYFxuICAgICAqICAgPGRpdiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPlxuICAgICAqICAgICAgICAgXiAgICAgIF4gYWJzb2x1dGVWYWx1ZU9mZnNldCBmb3IgYHRlbXBsYXRlVmFsdWVgXG4gICAgICogICAgICAgICBhYnNvbHV0ZUtleU9mZnNldCBmb3IgYHRlbXBsYXRlS2V5YFxuICAgICAqIGBgYFxuICAgICAqIGNvbnRhaW5zIHRocmVlIGJpbmRpbmdzOlxuICAgICAqIDEuIG5nRm9yIC0+IG51bGxcbiAgICAgKiAyLiBpdGVtIC0+IE5nRm9yT2ZDb250ZXh0LiRpbXBsaWNpdFxuICAgICAqIDMuIG5nRm9yT2YgLT4gaXRlbXNcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYXBwYXJlbnQgZnJvbSB0aGUgZGUtc3VnYXJlZCB0ZW1wbGF0ZTpcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtaXRlbSBbbmdGb3JPZl09XCJpdGVtc1wiPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRlbXBsYXRlS2V5IG5hbWUgb2YgZGlyZWN0aXZlLCB3aXRob3V0IHRoZSAqIHByZWZpeC4gRm9yIGV4YW1wbGU6IG5nSWYsIG5nRm9yXG4gICAgICogQHBhcmFtIHRlbXBsYXRlVmFsdWUgUkhTIG9mIHRoZSBtaWNyb3N5bnRheCBhdHRyaWJ1dGVcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVVcmwgdGVtcGxhdGUgZmlsZW5hbWUgaWYgaXQncyBleHRlcm5hbCwgY29tcG9uZW50IGZpbGVuYW1lIGlmIGl0J3MgaW5saW5lXG4gICAgICogQHBhcmFtIGFic29sdXRlS2V5T2Zmc2V0IHN0YXJ0IG9mIHRoZSBgdGVtcGxhdGVLZXlgXG4gICAgICogQHBhcmFtIGFic29sdXRlVmFsdWVPZmZzZXQgc3RhcnQgb2YgdGhlIGB0ZW1wbGF0ZVZhbHVlYFxuICAgICAqL1xuICAgIHBhcnNlVGVtcGxhdGVCaW5kaW5ncyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVVcmwsIGFic29sdXRlS2V5T2Zmc2V0LCBhYnNvbHV0ZVZhbHVlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuX2xleGVyLnRva2VuaXplKHRlbXBsYXRlVmFsdWUpO1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlQVNUKHRlbXBsYXRlVmFsdWUsIHRlbXBsYXRlVXJsLCBhYnNvbHV0ZVZhbHVlT2Zmc2V0LCB0b2tlbnMsIDAgLyogUGFyc2VGbGFncy5Ob25lICovLCB0aGlzLmVycm9ycywgMCAvKiByZWxhdGl2ZSBvZmZzZXQgKi8pO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh7XG4gICAgICAgICAgICBzb3VyY2U6IHRlbXBsYXRlS2V5LFxuICAgICAgICAgICAgc3BhbjogbmV3IEFic29sdXRlU291cmNlU3BhbihhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVLZXlPZmZzZXQgKyB0ZW1wbGF0ZUtleS5sZW5ndGgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRlZFRva2VucywgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyB9ID0gdGhpcy5zcGxpdEludGVycG9sYXRpb24oaW5wdXQsIGxvY2F0aW9uLCBpbnRlcnBvbGF0ZWRUb2tlbnMsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb25Ob2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uVGV4dCA9IGV4cHJlc3Npb25zW2ldLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VUb0xleCA9IHRoaXMuX3N0cmlwQ29tbWVudHMoZXhwcmVzc2lvblRleHQpO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gbmV3IF9QYXJzZUFTVChpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIDAgLyogUGFyc2VGbGFncy5Ob25lICovLCB0aGlzLmVycm9ycywgb2Zmc2V0c1tpXSlcbiAgICAgICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICAgICAgZXhwcmVzc2lvbk5vZGVzLnB1c2goYXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcnBvbGF0aW9uQXN0KHN0cmluZ3MubWFwKHMgPT4gcy50ZXh0KSwgZXhwcmVzc2lvbk5vZGVzLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBgcGFyc2VJbnRlcnBvbGF0aW9uYCwgYnV0IHRyZWF0cyB0aGUgcHJvdmlkZWQgc3RyaW5nIGFzIGEgc2luZ2xlIGV4cHJlc3Npb25cbiAgICAgKiBlbGVtZW50IHRoYXQgd291bGQgbm9ybWFsbHkgYXBwZWFyIHdpdGhpbiB0aGUgaW50ZXJwb2xhdGlvbiBwcmVmaXggYW5kIHN1ZmZpeCAoYHt7YCBhbmQgYH19YCkuXG4gICAgICogVGhpcyBpcyB1c2VkIGZvciBwYXJzaW5nIHRoZSBzd2l0Y2ggZXhwcmVzc2lvbiBpbiBJQ1VzLlxuICAgICAqL1xuICAgIHBhcnNlSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbiwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZVRvTGV4ID0gdGhpcy5fc3RyaXBDb21tZW50cyhleHByZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5fbGV4ZXIudG9rZW5pemUoc291cmNlVG9MZXgpO1xuICAgICAgICBjb25zdCBhc3QgPSBuZXcgX1BhcnNlQVNUKGV4cHJlc3Npb24sIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCwgdG9rZW5zLCAwIC8qIFBhcnNlRmxhZ3MuTm9uZSAqLywgdGhpcy5lcnJvcnMsIDApXG4gICAgICAgICAgICAucGFyc2VDaGFpbigpO1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gWycnLCAnJ107IC8vIFRoZSBwcmVmaXggYW5kIHN1ZmZpeCBzdHJpbmdzIGFyZSBib3RoIGVtcHR5XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUludGVycG9sYXRpb25Bc3Qoc3RyaW5ncywgW2FzdF0sIGV4cHJlc3Npb24sIGxvY2F0aW9uLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgfVxuICAgIGNyZWF0ZUludGVycG9sYXRpb25Bc3Qoc3RyaW5ncywgZXhwcmVzc2lvbnMsIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uKHNwYW4sIHNwYW4udG9BYnNvbHV0ZShhYnNvbHV0ZU9mZnNldCksIHN0cmluZ3MsIGV4cHJlc3Npb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGludGVycG9sYXRpb24sIGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGEgc3RyaW5nIG9mIHRleHQgaW50byBcInJhd1wiIHRleHQgc2VnbWVudHMgYW5kIGV4cHJlc3Npb25zIHByZXNlbnQgaW4gaW50ZXJwb2xhdGlvbnMgaW5cbiAgICAgKiB0aGUgc3RyaW5nLlxuICAgICAqIFJldHVybnMgYG51bGxgIGlmIHRoZXJlIGFyZSBubyBpbnRlcnBvbGF0aW9ucywgb3RoZXJ3aXNlIGFcbiAgICAgKiBgU3BsaXRJbnRlcnBvbGF0aW9uYCB3aXRoIHNwbGl0cyB0aGF0IGxvb2sgbGlrZVxuICAgICAqICAgPHJhdyB0ZXh0PiA8ZXhwcmVzc2lvbj4gPHJhdyB0ZXh0PiAuLi4gPHJhdyB0ZXh0PiA8ZXhwcmVzc2lvbj4gPHJhdyB0ZXh0PlxuICAgICAqL1xuICAgIHNwbGl0SW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIGludGVycG9sYXRlZFRva2VucywgaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gW107XG4gICAgICAgIGNvbnN0IGlucHV0VG9UZW1wbGF0ZUluZGV4TWFwID0gaW50ZXJwb2xhdGVkVG9rZW5zID8gZ2V0SW5kZXhNYXBGb3JPcmlnaW5hbFRlbXBsYXRlKGludGVycG9sYXRlZFRva2VucykgOiBudWxsO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBhdEludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgbGV0IGV4dGVuZExhc3RTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHsgc3RhcnQ6IGludGVycFN0YXJ0LCBlbmQ6IGludGVycEVuZCB9ID0gaW50ZXJwb2xhdGlvbkNvbmZpZztcbiAgICAgICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghYXRJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgdW50aWwgc3RhcnRpbmcge3tcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgaSA9IGlucHV0LmluZGV4T2YoaW50ZXJwU3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaW5wdXQuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goeyB0ZXh0LCBzdGFydCwgZW5kOiBpIH0pO1xuICAgICAgICAgICAgICAgIGF0SW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSBmcm9tIHN0YXJ0aW5nIHt7IHRvIGVuZGluZyB9fSB3aGlsZSBpZ25vcmluZyBjb250ZW50IGluc2lkZSBxdW90ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByU3RhcnQgPSBmdWxsU3RhcnQgKyBpbnRlcnBTdGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwckVuZCA9IHRoaXMuX2dldEludGVycG9sYXRpb25FbmRJbmRleChpbnB1dCwgaW50ZXJwRW5kLCBleHByU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChleHByRW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VsZCBub3QgZmluZCB0aGUgZW5kIG9mIHRoZSBpbnRlcnBvbGF0aW9uOyBkbyBub3QgcGFyc2UgYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGVhZCB3ZSBzaG91bGQgZXh0ZW5kIHRoZSBjb250ZW50IG9uIHRoZSBsYXN0IHJhdyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIGF0SW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRMYXN0U3RyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxFbmQgPSBleHByRW5kICsgaW50ZXJwRW5kLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gaW5wdXQuc3Vic3RyaW5nKGV4cHJTdGFydCwgZXhwckVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcignQmxhbmsgZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGludGVycG9sYXRlZCBzdHJpbmdzJywgaW5wdXQsIGBhdCBjb2x1bW4gJHtpfSBpbmAsIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaCh7IHRleHQsIHN0YXJ0OiBmdWxsU3RhcnQsIGVuZDogZnVsbEVuZCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluT3JpZ2luYWxUZW1wbGF0ZSA9IGlucHV0VG9UZW1wbGF0ZUluZGV4TWFwPy5nZXQoZnVsbFN0YXJ0KSA/PyBmdWxsU3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhcnRJbk9yaWdpbmFsVGVtcGxhdGUgKyBpbnRlcnBTdGFydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaSA9IGZ1bGxFbmQ7XG4gICAgICAgICAgICAgICAgYXRJbnRlcnBvbGF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhdEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBub3cgYXQgYSB0ZXh0IHNlY3Rpb24sIGFkZCB0aGUgcmVtYWluaW5nIGNvbnRlbnQgYXMgYSByYXcgc3RyaW5nLlxuICAgICAgICAgICAgaWYgKGV4dGVuZExhc3RTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IHN0cmluZ3Nbc3RyaW5ncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBwaWVjZS50ZXh0ICs9IGlucHV0LnN1YnN0cmluZyhpKTtcbiAgICAgICAgICAgICAgICBwaWVjZS5lbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goeyB0ZXh0OiBpbnB1dC5zdWJzdHJpbmcoaSksIHN0YXJ0OiBpLCBlbmQ6IGlucHV0Lmxlbmd0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNwbGl0SW50ZXJwb2xhdGlvbihzdHJpbmdzLCBleHByZXNzaW9ucywgb2Zmc2V0cyk7XG4gICAgfVxuICAgIHdyYXBMaXRlcmFsUHJpbWl0aXZlKGlucHV0LCBsb2NhdGlvbiwgYWJzb2x1dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IG5ldyBQYXJzZVNwYW4oMCwgaW5wdXQgPT0gbnVsbCA/IDAgOiBpbnB1dC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVFdpdGhTb3VyY2UobmV3IExpdGVyYWxQcmltaXRpdmUoc3Bhbiwgc3Bhbi50b0Fic29sdXRlKGFic29sdXRlT2Zmc2V0KSwgaW5wdXQpLCBpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICAgIF9zdHJpcENvbW1lbnRzKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9jb21tZW50U3RhcnQoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaSAhPSBudWxsID8gaW5wdXQuc3Vic3RyaW5nKDAsIGkpIDogaW5wdXQ7XG4gICAgfVxuICAgIF9jb21tZW50U3RhcnQoaW5wdXQpIHtcbiAgICAgICAgbGV0IG91dGVyUXVvdGUgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGlucHV0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICRTTEFTSCAmJiBuZXh0Q2hhciA9PSAkU0xBU0ggJiYgb3V0ZXJRdW90ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgaWYgKG91dGVyUXVvdGUgPT09IGNoYXIpIHtcbiAgICAgICAgICAgICAgICBvdXRlclF1b3RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG91dGVyUXVvdGUgPT0gbnVsbCAmJiBpc1F1b3RlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgb3V0ZXJRdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9jaGVja05vSW50ZXJwb2xhdGlvbihpbnB1dCwgbG9jYXRpb24sIHsgc3RhcnQsIGVuZCB9KSB7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gLTE7XG4gICAgICAgIGxldCBlbmRJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGNvbnN0IGNoYXJJbmRleCBvZiB0aGlzLl9mb3JFYWNoVW5xdW90ZWRDaGFyKGlucHV0LCAwKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBjaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSB0aGlzLl9nZXRJbnRlcnBvbGF0aW9uRW5kSW5kZXgoaW5wdXQsIGVuZCwgY2hhckluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPiAtMSAmJiBlbmRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgR290IGludGVycG9sYXRpb24gKCR7c3RhcnR9JHtlbmR9KSB3aGVyZSBleHByZXNzaW9uIHdhcyBleHBlY3RlZGAsIGlucHV0LCBgYXQgY29sdW1uICR7c3RhcnRJbmRleH0gaW5gLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBlbmQgb2YgYW4gaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uXG4gICAgICogd2hpbGUgaWdub3JpbmcgY29tbWVudHMgYW5kIHF1b3RlZCBjb250ZW50LlxuICAgICAqL1xuICAgIF9nZXRJbnRlcnBvbGF0aW9uRW5kSW5kZXgoaW5wdXQsIGV4cHJlc3Npb25FbmQsIHN0YXJ0KSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhckluZGV4IG9mIHRoaXMuX2ZvckVhY2hVbnF1b3RlZENoYXIoaW5wdXQsIHN0YXJ0KSkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoZXhwcmVzc2lvbkVuZCwgY2hhckluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFySW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RoaW5nIGVsc2UgaW4gdGhlIGV4cHJlc3Npb24gbWF0dGVycyBhZnRlciB3ZSd2ZVxuICAgICAgICAgICAgLy8gaGl0IGEgY29tbWVudCBzbyBsb29rIGRpcmVjdGx5IGZvciB0aGUgZW5kIHRva2VuLlxuICAgICAgICAgICAgaWYgKGlucHV0LnN0YXJ0c1dpdGgoJy8vJywgY2hhckluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dC5pbmRleE9mKGV4cHJlc3Npb25FbmQsIGNoYXJJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0b3IgdXNlZCB0byBpdGVyYXRlIG92ZXIgdGhlIGNoYXJhY3RlciBpbmRleGVzIG9mIGEgc3RyaW5nIHRoYXQgYXJlIG91dHNpZGUgb2YgcXVvdGVzLlxuICAgICAqIEBwYXJhbSBpbnB1dCBTdHJpbmcgdG8gbG9vcCB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSBzdGFydCBJbmRleCB3aXRoaW4gdGhlIHN0cmluZyBhdCB3aGljaCB0byBzdGFydC5cbiAgICAgKi9cbiAgICAqX2ZvckVhY2hVbnF1b3RlZENoYXIoaW5wdXQsIHN0YXJ0KSB7XG4gICAgICAgIGxldCBjdXJyZW50UXVvdGUgPSBudWxsO1xuICAgICAgICBsZXQgZXNjYXBlQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGlucHV0W2ldO1xuICAgICAgICAgICAgLy8gU2tpcCB0aGUgY2hhcmFjdGVycyBpbnNpZGUgcXVvdGVzLiBOb3RlIHRoYXQgd2Ugb25seSBjYXJlIGFib3V0IHRoZSBvdXRlci1tb3N0XG4gICAgICAgICAgICAvLyBxdW90ZXMgbWF0Y2hpbmcgdXAgYW5kIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgZXNjYXBlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoaXNRdW90ZShpbnB1dC5jaGFyQ29kZUF0KGkpKSAmJiAoY3VycmVudFF1b3RlID09PSBudWxsIHx8IGN1cnJlbnRRdW90ZSA9PT0gY2hhcikgJiZcbiAgICAgICAgICAgICAgICBlc2NhcGVDb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVvdGUgPSBjdXJyZW50UXVvdGUgPT09IG51bGwgPyBjaGFyIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRRdW90ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NhcGVDb3VudCA9IGNoYXIgPT09ICdcXFxcJyA/IGVzY2FwZUNvdW50ICsgMSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogRGVzY3JpYmVzIGEgc3RhdGVmdWwgY29udGV4dCBhbiBleHByZXNzaW9uIHBhcnNlciBpcyBpbi4gKi9cbnZhciBQYXJzZUNvbnRleHRGbGFncztcbihmdW5jdGlvbiAoUGFyc2VDb250ZXh0RmxhZ3MpIHtcbiAgICBQYXJzZUNvbnRleHRGbGFnc1tQYXJzZUNvbnRleHRGbGFnc1tcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIEEgV3JpdGFibGUgY29udGV4dCBpcyBvbmUgaW4gd2hpY2ggYSB2YWx1ZSBtYXkgYmUgd3JpdHRlbiB0byBhbiBsdmFsdWUuXG4gICAgICogRm9yIGV4YW1wbGUsIGFmdGVyIHdlIHNlZSBhIHByb3BlcnR5IGFjY2Vzcywgd2UgbWF5IGV4cGVjdCBhIHdyaXRlIHRvIHRoZVxuICAgICAqIHByb3BlcnR5IHZpYSB0aGUgXCI9XCIgb3BlcmF0b3IuXG4gICAgICogICBwcm9wXG4gICAgICogICAgICAgIF4gcG9zc2libGUgXCI9XCIgYWZ0ZXJcbiAgICAgKi9cbiAgICBQYXJzZUNvbnRleHRGbGFnc1tQYXJzZUNvbnRleHRGbGFnc1tcIldyaXRhYmxlXCJdID0gMV0gPSBcIldyaXRhYmxlXCI7XG59KShQYXJzZUNvbnRleHRGbGFncyB8fCAoUGFyc2VDb250ZXh0RmxhZ3MgPSB7fSkpO1xuY2xhc3MgX1BhcnNlQVNUIHtcbiAgICBjb25zdHJ1Y3RvcihpbnB1dCwgbG9jYXRpb24sIGFic29sdXRlT2Zmc2V0LCB0b2tlbnMsIHBhcnNlRmxhZ3MsIGVycm9ycywgb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICB0aGlzLmFic29sdXRlT2Zmc2V0ID0gYWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLnBhcnNlRmxhZ3MgPSBwYXJzZUZsYWdzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZCA9IDA7XG4gICAgICAgIHRoaXMucmJyYWNlc0V4cGVjdGVkID0gMDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gUGFyc2VDb250ZXh0RmxhZ3MuTm9uZTtcbiAgICAgICAgLy8gQ2FjaGUgb2YgZXhwcmVzc2lvbiBzdGFydCBhbmQgaW5wdXQgaW5kZWNlcyB0byB0aGUgYWJzb2x1dGUgc291cmNlIHNwYW4gdGhleSBtYXAgdG8sIHVzZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBjcmVhdGluZyBzdXBlcmZsdW91cyBzb3VyY2Ugc3BhbnMgaW4gYHNvdXJjZVNwYW5gLlxuICAgICAgICAvLyBBIHNlcmlhbCBvZiB0aGUgZXhwcmVzc2lvbiBzdGFydCBhbmQgaW5wdXQgaW5kZXggaXMgdXNlZCBmb3IgbWFwcGluZyBiZWNhdXNlIGJvdGggYXJlIHN0YXRlZnVsXG4gICAgICAgIC8vIGFuZCBtYXkgY2hhbmdlIGZvciBzdWJzZXF1ZW50IGV4cHJlc3Npb25zIHZpc2l0ZWQgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBwZWVrKG9mZnNldCkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5pbmRleCArIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vuc1tpXSA6IEVPRjtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlZWsoMCk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIGFsbCB0aGUgcGFyc2VyIGlucHV0IGhhcyBiZWVuIHByb2Nlc3NlZC4gKi9cbiAgICBnZXQgYXRFT0YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIG5leHQgdG9rZW4gdG8gYmUgcHJvY2Vzc2VkLCBvciB0aGUgZW5kIG9mIHRoZSBsYXN0IHRva2VuIGlmIGFsbCBoYXZlIGJlZW5cbiAgICAgKiBwcm9jZXNzZWQuXG4gICAgICovXG4gICAgZ2V0IGlucHV0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0RU9GID8gdGhpcy5jdXJyZW50RW5kSW5kZXggOiB0aGlzLm5leHQuaW5kZXggKyB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5kIGluZGV4IG9mIHRoZSBsYXN0IHByb2Nlc3NlZCB0b2tlbiwgb3IgdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCB0b2tlbiBpZiBub25lIGhhdmUgYmVlblxuICAgICAqIHByb2Nlc3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY3VycmVudEVuZEluZGV4KCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGN1clRva2VuID0gdGhpcy5wZWVrKC0xKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJUb2tlbi5lbmQgKyB0aGlzLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyB0b2tlbnMgaGF2ZSBiZWVuIHByb2Nlc3NlZCB5ZXQ7IHJldHVybiB0aGUgbmV4dCB0b2tlbidzIHN0YXJ0IG9yIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHRva2VuLlxuICAgICAgICBpZiAodGhpcy50b2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5sZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmluZGV4ICsgdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFic29sdXRlIG9mZnNldCBvZiB0aGUgc3RhcnQgb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICovXG4gICAgZ2V0IGN1cnJlbnRBYnNvbHV0ZU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyB0aGlzLmlucHV0SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgYFBhcnNlU3BhbmAgZnJvbSBgc3RhcnRgIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIChvciB0byBgYXJ0aWZpY2lhbEVuZEluZGV4YCBpZlxuICAgICAqIHByb3ZpZGVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydCBQb3NpdGlvbiBmcm9tIHdoaWNoIHRoZSBgUGFyc2VTcGFuYCB3aWxsIHN0YXJ0LlxuICAgICAqIEBwYXJhbSBhcnRpZmljaWFsRW5kSW5kZXggT3B0aW9uYWwgZW5kaW5nIGluZGV4IHRvIGJlIHVzZWQgaWYgcHJvdmlkZWQgKGFuZCBpZiBncmVhdGVyIHRoYW4gdGhlXG4gICAgICogICAgIG5hdHVyYWwgZW5kaW5nIGluZGV4KVxuICAgICAqL1xuICAgIHNwYW4oc3RhcnQsIGFydGlmaWNpYWxFbmRJbmRleCkge1xuICAgICAgICBsZXQgZW5kSW5kZXggPSB0aGlzLmN1cnJlbnRFbmRJbmRleDtcbiAgICAgICAgaWYgKGFydGlmaWNpYWxFbmRJbmRleCAhPT0gdW5kZWZpbmVkICYmIGFydGlmaWNpYWxFbmRJbmRleCA+IHRoaXMuY3VycmVudEVuZEluZGV4KSB7XG4gICAgICAgICAgICBlbmRJbmRleCA9IGFydGlmaWNpYWxFbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBzb21lIHVudXN1YWwgcGFyc2luZyBzY2VuYXJpb3MgKGxpa2Ugd2hlbiBjZXJ0YWluIHRva2VucyBhcmUgbWlzc2luZyBhbmQgYW4gYEVtcHR5RXhwcmAgaXNcbiAgICAgICAgLy8gYmVpbmcgY3JlYXRlZCksIHRoZSBjdXJyZW50IHRva2VuIG1heSBhbHJlYWR5IGJlIGFkdmFuY2VkIGJleW9uZCB0aGUgYGN1cnJlbnRFbmRJbmRleGAuIFRoaXNcbiAgICAgICAgLy8gYXBwZWFycyB0byBiZSBhIGRlZXAtc2VhdGVkIHBhcnNlciBidWcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFzIGEgd29ya2Fyb3VuZCBmb3Igbm93LCBzd2FwIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMgdG8gZW5zdXJlIGEgdmFsaWQgYFBhcnNlU3BhbmAuXG4gICAgICAgIC8vIFRPRE8oYWx4aHViKTogZml4IHRoZSBidWcgdXBzdHJlYW0gaW4gdGhlIHBhcnNlciBzdGF0ZSwgYW5kIHJlbW92ZSB0aGlzIHdvcmthcm91bmQuXG4gICAgICAgIGlmIChzdGFydCA+IGVuZEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBlbmRJbmRleDtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlU3BhbihzdGFydCwgZW5kSW5kZXgpO1xuICAgIH1cbiAgICBzb3VyY2VTcGFuKHN0YXJ0LCBhcnRpZmljaWFsRW5kSW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsID0gYCR7c3RhcnR9QCR7dGhpcy5pbnB1dEluZGV4fToke2FydGlmaWNpYWxFbmRJbmRleH1gO1xuICAgICAgICBpZiAoIXRoaXMuc291cmNlU3BhbkNhY2hlLmhhcyhzZXJpYWwpKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVNwYW5DYWNoZS5zZXQoc2VyaWFsLCB0aGlzLnNwYW4oc3RhcnQsIGFydGlmaWNpYWxFbmRJbmRleCkudG9BYnNvbHV0ZSh0aGlzLmFic29sdXRlT2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlU3BhbkNhY2hlLmdldChzZXJpYWwpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICB0aGlzLmluZGV4Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgaW4gdGhlIHByb3ZpZGVkIGNvbnRleHQuXG4gICAgICovXG4gICAgd2l0aENvbnRleHQoY29udGV4dCwgY2IpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0IHw9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHJldCA9IGNiKCk7XG4gICAgICAgIHRoaXMuY29udGV4dCBePSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBjb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0LmlzQ2hhcmFjdGVyKGNvZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlZWtLZXl3b3JkTGV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZExldCgpO1xuICAgIH1cbiAgICBwZWVrS2V5d29yZEFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0LmlzS2V5d29yZEFzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWVzIGFuIGV4cGVjdGVkIGNoYXJhY3Rlciwgb3RoZXJ3aXNlIGVtaXRzIGFuIGVycm9yIGFib3V0IHRoZSBtaXNzaW5nIGV4cGVjdGVkIGNoYXJhY3RlclxuICAgICAqIGFuZCBza2lwcyBvdmVyIHRoZSB0b2tlbiBzdHJlYW0gdW50aWwgcmVhY2hpbmcgYSByZWNvdmVyYWJsZSBwb2ludC5cbiAgICAgKlxuICAgICAqIFNlZSBgdGhpcy5lcnJvcmAgYW5kIGB0aGlzLnNraXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgZXhwZWN0Q2hhcmFjdGVyKGNvZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKGNvZGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVycm9yKGBNaXNzaW5nIGV4cGVjdGVkICR7U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKX1gKTtcbiAgICB9XG4gICAgY29uc3VtZU9wdGlvbmFsT3BlcmF0b3Iob3ApIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc09wZXJhdG9yKG9wKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBlY3RPcGVyYXRvcihvcGVyYXRvcikge1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcihvcGVyYXRvcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZXJyb3IoYE1pc3NpbmcgZXhwZWN0ZWQgb3BlcmF0b3IgJHtvcGVyYXRvcn1gKTtcbiAgICB9XG4gICAgcHJldHR5UHJpbnRUb2tlbih0b2spIHtcbiAgICAgICAgcmV0dXJuIHRvayA9PT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiBgdG9rZW4gJHt0b2t9YDtcbiAgICB9XG4gICAgZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgaWYgKCFuLmlzSWRlbnRpZmllcigpICYmICFuLmlzS2V5d29yZCgpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1ByaXZhdGVJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKG4sICdleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoYFVuZXhwZWN0ZWQgJHt0aGlzLnByZXR0eVByaW50VG9rZW4obil9LCBleHBlY3RlZCBpZGVudGlmaWVyIG9yIGtleXdvcmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBleHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5leHQ7XG4gICAgICAgIGlmICghbi5pc0lkZW50aWZpZXIoKSAmJiAhbi5pc0tleXdvcmQoKSAmJiAhbi5pc1N0cmluZygpKSB7XG4gICAgICAgICAgICBpZiAobi5pc1ByaXZhdGVJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKG4sICdleHBlY3RlZCBpZGVudGlmaWVyLCBrZXl3b3JkIG9yIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCAke3RoaXMucHJldHR5UHJpbnRUb2tlbihuKX0sIGV4cGVjdGVkIGlkZW50aWZpZXIsIGtleXdvcmQsIG9yIHN0cmluZ2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH1cbiAgICBwYXJzZUNoYWluKCkge1xuICAgICAgICBjb25zdCBleHBycyA9IFtdO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgZXhwcnMucHVzaChleHByKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkU0VNSUNPTE9OKSkge1xuICAgICAgICAgICAgICAgIGlmICghKHRoaXMucGFyc2VGbGFncyAmIDEgLyogUGFyc2VGbGFncy5BY3Rpb24gKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ0JpbmRpbmcgZXhwcmVzc2lvbiBjYW5ub3QgY29udGFpbiBjaGFpbmVkIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRTRU1JQ09MT04pKSB7XG4gICAgICAgICAgICAgICAgfSAvLyByZWFkIGFsbCBzZW1pY29sb25zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4IDwgdGhpcy50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCB0b2tlbiAnJHt0aGlzLm5leHR9J2ApO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgZXJyb3JgIGNhbGwgYWJvdmUgd2lsbCBza2lwIGFoZWFkIHRvIHRoZSBuZXh0IHJlY292ZXJ5IHBvaW50IGluIGFuIGF0dGVtcHQgdG9cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHBhcnQgb2YgdGhlIGV4cHJlc3Npb24sIGJ1dCB0aGF0IG1pZ2h0IGJlIHRoZSB0b2tlbiB3ZSBzdGFydGVkIGZyb20gd2hpY2ggd2lsbFxuICAgICAgICAgICAgICAgIC8vIGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcC4gSWYgdGhhdCdzIHRoZSBjYXNlLCBicmVhayB0aGUgbG9vcCBhc3N1bWluZyB0aGF0IHdlIGNhbid0XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgZnVydGhlci5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gZXJyb3JJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBubyBleHByZXNzaW9ucyBzbyBjcmVhdGUgYW4gZW1wdHkgZXhwcmVzc2lvbiB0aGF0IHNwYW5zIHRoZSBlbnRpcmUgaW5wdXQgbGVuZ3RoXG4gICAgICAgICAgICBjb25zdCBhcnRpZmljaWFsU3RhcnQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IGFydGlmaWNpYWxFbmQgPSB0aGlzLm9mZnNldCArIHRoaXMuaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKGFydGlmaWNpYWxTdGFydCwgYXJ0aWZpY2lhbEVuZCksIHRoaXMuc291cmNlU3BhbihhcnRpZmljaWFsU3RhcnQsIGFydGlmaWNpYWxFbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwcnMubGVuZ3RoID09IDEpXG4gICAgICAgICAgICByZXR1cm4gZXhwcnNbMF07XG4gICAgICAgIHJldHVybiBuZXcgQ2hhaW4odGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgZXhwcnMpO1xuICAgIH1cbiAgICBwYXJzZVBpcGUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJ3wnKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyc2VGbGFncyAmIDEgLyogUGFyc2VGbGFncy5BY3Rpb24gKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdDYW5ub3QgaGF2ZSBhIHBpcGUgaW4gYW4gYWN0aW9uIGV4cHJlc3Npb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lU3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVJZCA9IHRoaXMuZXhwZWN0SWRlbnRpZmllck9yS2V5d29yZCgpO1xuICAgICAgICAgICAgICAgIGxldCBuYW1lU3BhbjtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbFNwYW5FbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lU3BhbiA9IHRoaXMuc291cmNlU3BhbihuYW1lU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gdmFsaWQgaWRlbnRpZmllciB3YXMgZm91bmQsIHNvIHdlJ2xsIGFzc3VtZSBhbiBlbXB0eSBwaXBlIG5hbWUgKCcnKS5cbiAgICAgICAgICAgICAgICAgICAgbmFtZUlkID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIG1heSBoYXZlIGJlZW4gd2hpdGVzcGFjZSBwcmVzZW50IGJldHdlZW4gdGhlIHBpcGUgY2hhcmFjdGVyIGFuZCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyB0b2tlbiBpbiB0aGUgc2VxdWVuY2UgKG9yIHRoZSBlbmQgb2YgaW5wdXQpLiBXZSB3YW50IHRvIHRyYWNrIHRoaXMgd2hpdGVzcGFjZSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgQmluZGluZ1BpcGVgIHdlIHByb2R1Y2UgY292ZXJzIG5vdCBqdXN0IHRoZSBwaXBlIGNoYXJhY3RlciwgYnV0IGFueSB0cmFpbGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZXNwYWNlIGJleW9uZCBpdC4gQW5vdGhlciB3YXkgb2YgdGhpbmtpbmcgYWJvdXQgdGhpcyBpcyB0aGF0IHRoZSB6ZXJvLWxlbmd0aCBuYW1lXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFzc3VtZWQgdG8gYmUgYXQgdGhlIGVuZCBvZiBhbnkgd2hpdGVzcGFjZSBiZXlvbmQgdGhlIHBpcGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHB1c2ggdGhlIGVuZCBvZiB0aGUgYFBhcnNlU3BhbmAgZm9yIHRoaXMgcGlwZSBhbGwgdGhlIHdheSB1cCB0byB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBuZXh0IHRva2VuLCBvciB1bnRpbCB0aGUgZW5kIG9mIGlucHV0IGlmIHRoZSBuZXh0IHRva2VuIGlzIEVPRi5cbiAgICAgICAgICAgICAgICAgICAgZnVsbFNwYW5FbmQgPSB0aGlzLm5leHQuaW5kZXggIT09IC0xID8gdGhpcy5uZXh0LmluZGV4IDogdGhpcy5pbnB1dC5sZW5ndGggKyB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGBuYW1lU3BhbmAgZm9yIGFuIGVtcHR5IHBpcGUgbmFtZSBpcyB6ZXJvLWxlbmd0aCBhdCB0aGUgZW5kIG9mIGFueSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJleW9uZCB0aGUgcGlwZSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgIG5hbWVTcGFuID0gbmV3IFBhcnNlU3BhbihmdWxsU3BhbkVuZCwgZnVsbFNwYW5FbmQpLnRvQWJzb2x1dGUodGhpcy5hYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2godGhpcy5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBhZGRpdGlvbmFsIGV4cHJlc3Npb25zIGJleW9uZCB0aGUgbmFtZSwgdGhlbiB0aGUgYXJ0aWZpY2lhbCBlbmQgZm9yIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lIGlzIG5vIGxvbmdlciByZWxldmFudC5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEJpbmRpbmdQaXBlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCwgZnVsbFNwYW5FbmQpLCByZXN1bHQsIG5hbWVJZCwgYXJncywgbmFtZVNwYW4pO1xuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignfCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICB9XG4gICAgcGFyc2VDb25kaXRpb25hbCgpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsT3IoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJz8nKSkge1xuICAgICAgICAgICAgY29uc3QgeWVzID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIGxldCBubztcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5pbnB1dC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiAke2V4cHJlc3Npb259IHJlcXVpcmVzIGFsbCAzIGV4cHJlc3Npb25zYCk7XG4gICAgICAgICAgICAgICAgbm8gPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm8gPSB0aGlzLnBhcnNlUGlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25kaXRpb25hbCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQsIHllcywgbm8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUxvZ2ljYWxPcigpIHtcbiAgICAgICAgLy8gJ3x8J1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCd8fCcpKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VMb2dpY2FsQW5kKCk7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksICd8fCcsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlTG9naWNhbEFuZCgpIHtcbiAgICAgICAgLy8gJyYmJ1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VOdWxsaXNoQ29hbGVzY2luZygpO1xuICAgICAgICB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignJiYnKSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnBhcnNlTnVsbGlzaENvYWxlc2NpbmcoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJyYmJywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VOdWxsaXNoQ29hbGVzY2luZygpIHtcbiAgICAgICAgLy8gJz8/J1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VFcXVhbGl0eSgpO1xuICAgICAgICB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPz8nKSkge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnBhcnNlRXF1YWxpdHkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgJz8/JywgcmVzdWx0LCByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcGFyc2VFcXVhbGl0eSgpIHtcbiAgICAgICAgLy8gJz09JywnIT0nLCc9PT0nLCchPT0nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZVJlbGF0aW9uYWwoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz09PSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHRoaXMucGFyc2VSZWxhdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlUmVsYXRpb25hbCgpIHtcbiAgICAgICAgLy8gJzwnLCAnPicsICc8PScsICc+PSdcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlQWRkaXRpdmUoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLm5leHQuc3RyVmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5wYXJzZUFkZGl0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlQWRkaXRpdmUoKSB7XG4gICAgICAgIC8vICcrJywgJy0nXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5wYXJzZU11bHRpcGxpY2F0aXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCaW5hcnkodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgb3BlcmF0b3IsIHJlc3VsdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBhcnNlTXVsdGlwbGljYXRpdmUoKSB7XG4gICAgICAgIC8vICcqJywgJyUnLCAnLydcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgIHdoaWxlICh0aGlzLm5leHQudHlwZSA9PSBUb2tlblR5cGUuT3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5uZXh0LnN0clZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQmluYXJ5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG9wZXJhdG9yLCByZXN1bHQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZVByZWZpeCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC50eXBlID09IFRva2VuVHlwZS5PcGVyYXRvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMubmV4dC5zdHJWYWx1ZTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVQbHVzKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlUHJlZml4KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVbmFyeS5jcmVhdGVNaW51cyh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZVByZWZpeCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByZWZpeE5vdCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2FsbENoYWluKCk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbENoYWluKCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFBFUklPRCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlQWNjZXNzTWVtYmVyKHJlc3VsdCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsT3BlcmF0b3IoJz8uJykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExQQVJFTikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNhbGwocmVzdWx0LCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VLZXllZFJlYWRPcldyaXRlKHJlc3VsdCwgc3RhcnQsIHRydWUpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXIocmVzdWx0LCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJExCUkFDS0VUKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VLZXllZFJlYWRPcldyaXRlKHJlc3VsdCwgc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUNhbGwocmVzdWx0LCBzdGFydCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignIScpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IE5vbk51bGxBc3NlcnQodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VQcmltYXJ5KCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRMUEFSRU4pKSB7XG4gICAgICAgICAgICB0aGlzLnJwYXJlbnNFeHBlY3RlZCsrO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVBpcGUoKTtcbiAgICAgICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkLS07XG4gICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZE51bGwoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFVuZGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRUcnVlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsUHJpbWl0aXZlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0tleXdvcmRGYWxzZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzS2V5d29yZFRoaXMoKSkge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRoaXNSZWNlaXZlcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICB0aGlzLnJicmFja2V0c0V4cGVjdGVkKys7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucGFyc2VFeHByZXNzaW9uTGlzdCgkUkJSQUNLRVQpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2tldHNFeHBlY3RlZC0tO1xuICAgICAgICAgICAgdGhpcy5leHBlY3RDaGFyYWN0ZXIoJFJCUkFDS0VUKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbEFycmF5KHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJExCUkFDRSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubmV4dC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBY2Nlc3NNZW1iZXIobmV3IEltcGxpY2l0UmVjZWl2ZXIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSksIHN0YXJ0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzTnVtYmVyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5uZXh0LnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbFByaW1pdGl2ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5uZXh0LmlzU3RyaW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpdGVyYWxWYWx1ZSA9IHRoaXMubmV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpdGVyYWxQcmltaXRpdmUodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbGl0ZXJhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5leHQuaXNQcml2YXRlSWRlbnRpZmllcigpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvckZvclByaXZhdGVJZGVudGlmaWVyKHRoaXMubmV4dCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgZXhwcmVzc2lvbjogJHt0aGlzLmlucHV0fWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGBVbmV4cGVjdGVkIHRva2VuICR7dGhpcy5uZXh0fWApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUV4cHIodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VFeHByZXNzaW9uTGlzdCh0ZXJtaW5hdG9yKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV4dC5pc0NoYXJhY3Rlcih0ZXJtaW5hdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRoaXMucGFyc2VQaXBlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuY29uc3VtZU9wdGlvbmFsQ2hhcmFjdGVyKCRDT01NQSkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwYXJzZUxpdGVyYWxNYXAoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkTEJSQUNFKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkUkJSQUNFKSkge1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHRoaXMuaW5wdXRJbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBxdW90ZWQgPSB0aGlzLm5leHQuaXNTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmV4cGVjdElkZW50aWZpZXJPcktleXdvcmRPclN0cmluZygpO1xuICAgICAgICAgICAgICAgIGtleXMucHVzaCh7IGtleSwgcXVvdGVkIH0pO1xuICAgICAgICAgICAgICAgIC8vIFByb3BlcnRpZXMgd2l0aCBxdW90ZWQga2V5cyBjYW4ndCB1c2UgdGhlIHNob3J0aGFuZCBzeW50YXguXG4gICAgICAgICAgICAgICAgaWYgKHF1b3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkQ09MT04pO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTE9OKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW4oa2V5U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VTcGFuID0gdGhpcy5zb3VyY2VTcGFuKGtleVN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gobmV3IFByb3BlcnR5UmVhZChzcGFuLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBuZXcgSW1wbGljaXRSZWNlaXZlcihzcGFuLCBzb3VyY2VTcGFuKSwga2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm5leHQuaXNDaGFyYWN0ZXIoJFJCUkFDRSkpO1xuICAgICAgICAgICAgdGhpcy5yYnJhY2VzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGl0ZXJhbE1hcCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBrZXlzLCB2YWx1ZXMpO1xuICAgIH1cbiAgICBwYXJzZUFjY2Vzc01lbWJlcihyZWFkUmVjZWl2ZXIsIHN0YXJ0LCBpc1NhZmUpIHtcbiAgICAgICAgY29uc3QgbmFtZVN0YXJ0ID0gdGhpcy5pbnB1dEluZGV4O1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMud2l0aENvbnRleHQoUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkKCkgPz8gJyc7XG4gICAgICAgICAgICBpZiAoaWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciBmb3IgcHJvcGVydHkgYWNjZXNzYCwgcmVhZFJlY2VpdmVyLnNwYW4uZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5hbWVTcGFuID0gdGhpcy5zb3VyY2VTcGFuKG5hbWVTdGFydCk7XG4gICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZU9wdGlvbmFsQXNzaWdubWVudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVGhlIFxcJz8uXFwnIG9wZXJhdG9yIGNhbm5vdCBiZSB1c2VkIGluIHRoZSBhc3NpZ25tZW50Jyk7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXIgPSBuZXcgU2FmZVByb3BlcnR5UmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCBuYW1lU3BhbiwgcmVhZFJlY2VpdmVyLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxBc3NpZ25tZW50KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnBhcnNlRmxhZ3MgJiAxIC8qIFBhcnNlRmxhZ3MuQWN0aW9uICovKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdCaW5kaW5ncyBjYW5ub3QgY29udGFpbiBhc3NpZ25tZW50cycpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5RXhwcih0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoKTtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9IG5ldyBQcm9wZXJ0eVdyaXRlKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIG5hbWVTcGFuLCByZWFkUmVjZWl2ZXIsIGlkLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlciA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBQcm9wZXJ0eVJlYWQodGhpcy5zcGFuKHN0YXJ0KSwgdGhpcy5zb3VyY2VTcGFuKHN0YXJ0KSwgbmFtZVNwYW4sIHJlYWRSZWNlaXZlciwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9XG4gICAgcGFyc2VDYWxsKHJlY2VpdmVyLCBzdGFydCwgaXNTYWZlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3VtZW50U3RhcnQgPSB0aGlzLmlucHV0SW5kZXg7XG4gICAgICAgIHRoaXMucnBhcmVuc0V4cGVjdGVkKys7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhcnNlQ2FsbEFyZ3VtZW50cygpO1xuICAgICAgICBjb25zdCBhcmd1bWVudFNwYW4gPSB0aGlzLnNwYW4oYXJndW1lbnRTdGFydCwgdGhpcy5pbnB1dEluZGV4KS50b0Fic29sdXRlKHRoaXMuYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB0aGlzLmV4cGVjdENoYXJhY3RlcigkUlBBUkVOKTtcbiAgICAgICAgdGhpcy5ycGFyZW5zRXhwZWN0ZWQtLTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbihzdGFydCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpO1xuICAgICAgICByZXR1cm4gaXNTYWZlID8gbmV3IFNhZmVDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhcmd1bWVudFNwYW4pIDpcbiAgICAgICAgICAgIG5ldyBDYWxsKHNwYW4sIHNvdXJjZVNwYW4sIHJlY2VpdmVyLCBhcmdzLCBhcmd1bWVudFNwYW4pO1xuICAgIH1cbiAgICBjb25zdW1lT3B0aW9uYWxBc3NpZ25tZW50KCkge1xuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgYXNzaWdubWVudCBldmVudHMgKG9yaWdpbmF0aW5nIGZyb20gdHdvLXdheS1iaW5kaW5nIGFrYSBiYW5hbmEtaW4tYS1ib3ggc3ludGF4KSxcbiAgICAgICAgLy8gaXQgaXMgdmFsaWQgZm9yIHRoZSBwcmltYXJ5IGV4cHJlc3Npb24gdG8gYmUgdGVybWluYXRlZCBieSB0aGUgbm9uLW51bGwgb3BlcmF0b3IuIFRoaXNcbiAgICAgICAgLy8gcHJpbWFyeSBleHByZXNzaW9uIGlzIHN1YnN0aXR1dGVkIGFzIExIUyBvZiB0aGUgYXNzaWdubWVudCBvcGVyYXRvciB0byBhY2hpZXZlXG4gICAgICAgIC8vIHR3by13YXktYmluZGluZywgc3VjaCB0aGF0IHRoZSBMSFMgY291bGQgYmUgdGhlIG5vbi1udWxsIG9wZXJhdG9yLiBUaGUgZ3JhbW1hciBkb2Vzbid0XG4gICAgICAgIC8vIG5hdHVyYWxseSBhbGxvdyBmb3IgdGhpcyBzeW50YXgsIHNvIGFzc2lnbm1lbnQgZXZlbnRzIGFyZSBwYXJzZWQgc3BlY2lhbGx5LlxuICAgICAgICBpZiAoKHRoaXMucGFyc2VGbGFncyAmIDIgLyogUGFyc2VGbGFncy5Bc3NpZ25tZW50RXZlbnQgKi8pICYmIHRoaXMubmV4dC5pc09wZXJhdG9yKCchJykgJiZcbiAgICAgICAgICAgIHRoaXMucGVlaygxKS5pc09wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHNraXAgb3ZlciB0aGUgISBvcGVyYXRvci5cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgLy8gVGhlbiBza2lwIG92ZXIgdGhlID0gb3BlcmF0b3IsIHRvIGZ1bGx5IGNvbnN1bWUgdGhlIG9wdGlvbmFsIGFzc2lnbm1lbnQgb3BlcmF0b3IuXG4gICAgICAgICAgICB0aGlzLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9Jyk7XG4gICAgfVxuICAgIHBhcnNlQ2FsbEFyZ3VtZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dC5pc0NoYXJhY3RlcigkUlBBUkVOKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25hbHMgPSBbXTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcG9zaXRpb25hbHMucHVzaCh0aGlzLnBhcnNlUGlwZSgpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKSk7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbmFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGlkZW50aWZpZXIsIGEga2V5d29yZCwgYSBzdHJpbmcgd2l0aCBhbiBvcHRpb25hbCBgLWAgaW4gYmV0d2VlbixcbiAgICAgKiBhbmQgcmV0dXJucyB0aGUgc3RyaW5nIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNvdXJjZSBzcGFuLlxuICAgICAqL1xuICAgIGV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBsZXQgb3BlcmF0b3JGb3VuZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuY3VycmVudEFic29sdXRlT2Zmc2V0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5leHBlY3RJZGVudGlmaWVyT3JLZXl3b3JkT3JTdHJpbmcoKTtcbiAgICAgICAgICAgIG9wZXJhdG9yRm91bmQgPSB0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCctJyk7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JGb3VuZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG9wZXJhdG9yRm91bmQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiByZXN1bHQsXG4gICAgICAgICAgICBzcGFuOiBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHN0YXJ0LCBzdGFydCArIHJlc3VsdC5sZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBtaWNyb3N5bnRheCB0ZW1wbGF0ZSBleHByZXNzaW9uIGFuZCByZXR1cm4gYSBsaXN0IG9mIGJpbmRpbmdzIG9yXG4gICAgICogcGFyc2luZyBlcnJvcnMgaW4gY2FzZSB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsXG4gICAgICogYGBgXG4gICAgICogICA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpOyB0cmFja0J5OiBmdW5jXCI+XG4gICAgICogYGBgXG4gICAgICogY29udGFpbnMgZml2ZSBiaW5kaW5nczpcbiAgICAgKiAxLiBuZ0ZvciAtPiBudWxsXG4gICAgICogMi4gaXRlbSAtPiBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRcbiAgICAgKiAzLiBuZ0Zvck9mIC0+IGl0ZW1zXG4gICAgICogNC4gaSAtPiBOZ0Zvck9mQ29udGV4dC5pbmRleFxuICAgICAqIDUuIG5nRm9yVHJhY2tCeSAtPiBmdW5jXG4gICAgICpcbiAgICAgKiBGb3IgYSBmdWxsIGRlc2NyaXB0aW9uIG9mIHRoZSBtaWNyb3N5bnRheCBncmFtbWFyLCBzZWVcbiAgICAgKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9taGV2ZXJ5L2QzNTMwMjk0Y2ZmMmU0YTFiM2ZlMTVmZjc1ZDA4ODU1XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVLZXkgbmFtZSBvZiB0aGUgbWljcm9zeW50YXggZGlyZWN0aXZlLCBsaWtlIG5nSWYsIG5nRm9yLFxuICAgICAqIHdpdGhvdXQgdGhlICosIGFsb25nIHdpdGggaXRzIGFic29sdXRlIHNwYW4uXG4gICAgICovXG4gICAgcGFyc2VUZW1wbGF0ZUJpbmRpbmdzKHRlbXBsYXRlS2V5KSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIFRoZSBmaXJzdCBiaW5kaW5nIGlzIGZvciB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZlxuICAgICAgICAvLyBJbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiLCBrZXkgPSBcIm5nRm9yXCIsIHZhbHVlID0gbnVsbFxuICAgICAgICAvLyBJbiAqbmdJZj1cImNvbmQgfCBwaXBlXCIsIGtleSA9IFwibmdJZlwiLCB2YWx1ZSA9IFwiY29uZCB8IHBpcGVcIlxuICAgICAgICBiaW5kaW5ncy5wdXNoKC4uLnRoaXMucGFyc2VEaXJlY3RpdmVLZXl3b3JkQmluZGluZ3ModGVtcGxhdGVLZXkpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHN0YXJ0cyB3aXRoICdsZXQnLCB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZSBkZWNsYXJhdGlvblxuICAgICAgICAgICAgY29uc3QgbGV0QmluZGluZyA9IHRoaXMucGFyc2VMZXRCaW5kaW5nKCk7XG4gICAgICAgICAgICBpZiAobGV0QmluZGluZykge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2gobGV0QmluZGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUd28gcG9zc2libGUgY2FzZXMgaGVyZSwgZWl0aGVyIGB2YWx1ZSBcImFzXCIga2V5YCBvclxuICAgICAgICAgICAgICAgIC8vIFwiZGlyZWN0aXZlLWtleXdvcmQgZXhwcmVzc2lvblwiLiBXZSBkb24ndCBrbm93IHdoaWNoIGNhc2UsIGJ1dCBib3RoXG4gICAgICAgICAgICAgICAgLy8gXCJ2YWx1ZVwiIGFuZCBcImRpcmVjdGl2ZS1rZXl3b3JkXCIgYXJlIHRlbXBsYXRlIGJpbmRpbmcga2V5LCBzbyBjb25zdW1lXG4gICAgICAgICAgICAgICAgLy8gdGhlIGtleSBmaXJzdC5cbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmV4cGVjdFRlbXBsYXRlQmluZGluZ0tleSgpO1xuICAgICAgICAgICAgICAgIC8vIFBlZWsgYXQgdGhlIG5leHQgdG9rZW4sIGlmIGl0IGlzIFwiYXNcIiB0aGVuIHRoaXMgbXVzdCBiZSB2YXJpYWJsZVxuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmF0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUga2V5IG11c3QgYmUgYSBkaXJlY3RpdmUga2V5d29yZCwgbGlrZSBcIm9mXCIuIFRyYW5zZm9ybVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUga2V5IHRvIGFjdHVhbCBrZXkuIEVnLiBvZiAtPiBuZ0Zvck9mLCB0cmFja0J5IC0+IG5nRm9yVHJhY2tCeVxuICAgICAgICAgICAgICAgICAgICBrZXkuc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlS2V5LnNvdXJjZSArIGtleS5zb3VyY2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaCguLi50aGlzLnBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQmluZGluZ1BhcnNlUmVzdWx0KGJpbmRpbmdzLCBbXSAvKiB3YXJuaW5ncyAqLywgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICBwYXJzZUtleWVkUmVhZE9yV3JpdGUocmVjZWl2ZXIsIHN0YXJ0LCBpc1NhZmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQrKztcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VQaXBlKCk7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgRW1wdHlFeHByKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihgS2V5IGFjY2VzcyBjYW5ub3QgYmUgZW1wdHlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQtLTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0Q2hhcmFjdGVyKCRSQlJBQ0tFVCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lT3B0aW9uYWxPcGVyYXRvcignPScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2FmZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdUaGUgXFwnPy5cXCcgb3BlcmF0b3IgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGFzc2lnbm1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgS2V5ZWRXcml0ZSh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FmZSA/IG5ldyBTYWZlS2V5ZWRSZWFkKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCksIHJlY2VpdmVyLCBrZXkpIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3IEtleWVkUmVhZCh0aGlzLnNwYW4oc3RhcnQpLCB0aGlzLnNvdXJjZVNwYW4oc3RhcnQpLCByZWNlaXZlciwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlFeHByKHRoaXMuc3BhbihzdGFydCksIHRoaXMuc291cmNlU3BhbihzdGFydCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYSBkaXJlY3RpdmUga2V5d29yZCwgZm9sbG93ZWQgYnkgYSBtYW5kYXRvcnkgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgXCJvZiBpdGVtc1wiLCBcInRyYWNrQnk6IGZ1bmNcIi5cbiAgICAgKiBUaGUgYmluZGluZ3MgYXJlOiBuZ0Zvck9mIC0+IGl0ZW1zLCBuZ0ZvclRyYWNrQnkgLT4gZnVuY1xuICAgICAqIFRoZXJlIGNvdWxkIGJlIGFuIG9wdGlvbmFsIFwiYXNcIiBiaW5kaW5nIHRoYXQgZm9sbG93cyB0aGUgZXhwcmVzc2lvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zIHwgc2xpY2U6MDoxIGFzIGNvbGxlY3Rpb25cIi5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgXl4gXl5eXl5eXl5eXl5eXl5eXl4gXl5eXl5eXl5eXl5eXlxuICAgICAqICAgICAgICAgICAgICAga2V5d29yZCAgICBib3VuZCB0YXJnZXQgICBvcHRpb25hbCAnYXMnIGJpbmRpbmdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgYmluZGluZyBrZXksIGZvciBleGFtcGxlLCBuZ0ZvciwgbmdJZiwgbmdGb3JPZiwgYWxvbmcgd2l0aCBpdHNcbiAgICAgKiBhYnNvbHV0ZSBzcGFuLlxuICAgICAqL1xuICAgIHBhcnNlRGlyZWN0aXZlS2V5d29yZEJpbmRpbmdzKGtleSkge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnN1bWVPcHRpb25hbENoYXJhY3RlcigkQ09MT04pOyAvLyB0cmFja0J5OiB0cmFja0J5RnVuY3Rpb25cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCk7XG4gICAgICAgIGxldCBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIC8vIFRoZSBiaW5kaW5nIGNvdWxkIG9wdGlvbmFsbHkgYmUgZm9sbG93ZWQgYnkgXCJhc1wiLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgLy8gKm5nSWY9XCJjb25kIHwgcGlwZSBhcyB4XCIuIEluIHRoaXMgY2FzZSwgdGhlIGtleSBpbiB0aGUgXCJhc1wiIGJpbmRpbmdcbiAgICAgICAgLy8gaXMgXCJ4XCIgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdGVtcGxhdGUga2V5IGl0c2VsZiAoXCJuZ0lmXCIpLiBOb3RlIHRoYXQgdGhlXG4gICAgICAgIC8vICdrZXknIGluIHRoZSBjdXJyZW50IGNvbnRleHQgbm93IGJlY29tZXMgdGhlIFwidmFsdWVcIiBpbiB0aGUgbmV4dCBiaW5kaW5nLlxuICAgICAgICBjb25zdCBhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXNCaW5kaW5nKGtleSk7XG4gICAgICAgIGlmICghYXNCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgICAgICBzcGFuRW5kID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4oa2V5LnNwYW4uc3RhcnQsIHNwYW5FbmQpO1xuICAgICAgICBiaW5kaW5ncy5wdXNoKG5ldyBFeHByZXNzaW9uQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKSk7XG4gICAgICAgIGlmIChhc0JpbmRpbmcpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goYXNCaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmluZGluZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZXhwcmVzc2lvbiBBU1QgZm9yIHRoZSBib3VuZCB0YXJnZXQgb2YgYSBkaXJlY3RpdmUga2V5d29yZFxuICAgICAqIGJpbmRpbmcuIEZvciBleGFtcGxlLFxuICAgICAqIGBgYFxuICAgICAqICAgKm5nSWY9XCJjb25kaXRpb24gfCBwaXBlXCJcbiAgICAgKiAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eIGJvdW5kIHRhcmdldCBmb3IgXCJuZ0lmXCJcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgXl5eXl4gYm91bmQgdGFyZ2V0IGZvciBcIm5nRm9yT2ZcIlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldERpcmVjdGl2ZUJvdW5kVGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0ID09PSBFT0YgfHwgdGhpcy5wZWVrS2V5d29yZEFzKCkgfHwgdGhpcy5wZWVrS2V5d29yZExldCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3QgPSB0aGlzLnBhcnNlUGlwZSgpOyAvLyBleGFtcGxlOiBcImNvbmRpdGlvbiB8IGFzeW5jXCJcbiAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBhc3Quc3BhbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RXaXRoU291cmNlKGFzdCwgdmFsdWUsIHRoaXMubG9jYXRpb24sIHRoaXMuYWJzb2x1dGVPZmZzZXQgKyBzdGFydCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJpbmRpbmcgZm9yIGEgdmFyaWFibGUgZGVjbGFyZWQgdXNpbmcgYGFzYC4gTm90ZSB0aGF0IHRoZSBvcmRlclxuICAgICAqIG9mIHRoZSBrZXktdmFsdWUgcGFpciBpbiB0aGlzIGRlY2xhcmF0aW9uIGlzIHJldmVyc2VkLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBpbmRleCBhcyBpXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eICAgIF5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICAgIGtleVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIG5hbWUgb2YgdGhlIHZhbHVlIGluIHRoZSBkZWNsYXJhdGlvbiwgXCJuZ0lmXCIgaW4gdGhlIGV4YW1wbGVcbiAgICAgKiBhYm92ZSwgYWxvbmcgd2l0aCBpdHMgYWJzb2x1dGUgc3Bhbi5cbiAgICAgKi9cbiAgICBwYXJzZUFzQmluZGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRBcygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkdmFuY2UoKTsgLy8gY29uc3VtZSB0aGUgJ2FzJyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIHRoaXMuY29uc3VtZVN0YXRlbWVudFRlcm1pbmF0b3IoKTtcbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBBYnNvbHV0ZVNvdXJjZVNwYW4odmFsdWUuc3Bhbi5zdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiaW5kaW5nIGZvciBhIHZhcmlhYmxlIGRlY2xhcmVkIHVzaW5nIGBsZXRgLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBgYGBcbiAgICAgKiAgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zOyBsZXQgaT1pbmRleDtcIlxuICAgICAqICAgICAgICAgICBeXl5eXl5eXiAgICAgICAgICAgXl5eXl5eXl5eXl5cbiAgICAgKiBgYGBcbiAgICAgKiBJbiB0aGUgZmlyc3QgYmluZGluZywgYGl0ZW1gIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC4kaW1wbGljaXRgLlxuICAgICAqIEluIHRoZSBzZWNvbmQgYmluZGluZywgYGlgIGlzIGJvdW5kIHRvIGBOZ0Zvck9mQ29udGV4dC5pbmRleGAuXG4gICAgICovXG4gICAgcGFyc2VMZXRCaW5kaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMucGVla0tleXdvcmRMZXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BhblN0YXJ0ID0gdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQ7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpOyAvLyBjb25zdW1lIHRoZSAnbGV0JyBrZXl3b3JkXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXhwZWN0VGVtcGxhdGVCaW5kaW5nS2V5KCk7XG4gICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbnN1bWVPcHRpb25hbE9wZXJhdG9yKCc9JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5leHBlY3RUZW1wbGF0ZUJpbmRpbmdLZXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN1bWVTdGF0ZW1lbnRUZXJtaW5hdG9yKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKHNwYW5TdGFydCwgdGhpcy5jdXJyZW50QWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlQmluZGluZyhzb3VyY2VTcGFuLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSB0aGUgb3B0aW9uYWwgc3RhdGVtZW50IHRlcm1pbmF0b3I6IHNlbWljb2xvbiBvciBjb21tYS5cbiAgICAgKi9cbiAgICBjb25zdW1lU3RhdGVtZW50VGVybWluYXRvcigpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJFNFTUlDT0xPTikgfHwgdGhpcy5jb25zdW1lT3B0aW9uYWxDaGFyYWN0ZXIoJENPTU1BKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBhbmQgc2tpcHMgb3ZlciB0aGUgdG9rZW4gc3RyZWFtIHVudGlsIHJlYWNoaW5nIGEgcmVjb3ZlcmFibGUgcG9pbnQuIFNlZVxuICAgICAqIGB0aGlzLnNraXBgIGZvciBtb3JlIGRldGFpbHMgb24gdG9rZW4gc2tpcHBpbmcuXG4gICAgICovXG4gICAgZXJyb3IobWVzc2FnZSwgaW5kZXggPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFBhcnNlckVycm9yKG1lc3NhZ2UsIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KGluZGV4KSwgdGhpcy5sb2NhdGlvbikpO1xuICAgICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gICAgbG9jYXRpb25UZXh0KGluZGV4ID0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gbnVsbClcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IHRoaXMudG9rZW5zLmxlbmd0aCkgPyBgYXQgY29sdW1uICR7dGhpcy50b2tlbnNbaW5kZXhdLmluZGV4ICsgMX0gaW5gIDpcbiAgICAgICAgICAgIGBhdCB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkcyBhbiBlcnJvciBmb3IgYW4gdW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXIgYmVpbmcgZGlzY292ZXJlZC5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVG9rZW4gcmVwcmVzZW50aW5nIGEgcHJpdmF0ZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSBleHRyYU1lc3NhZ2UgT3B0aW9uYWwgYWRkaXRpb25hbCBtZXNzYWdlIGJlaW5nIGFwcGVuZGVkIHRvIHRoZSBlcnJvci5cbiAgICAgKi9cbiAgICBfcmVwb3J0RXJyb3JGb3JQcml2YXRlSWRlbnRpZmllcih0b2tlbiwgZXh0cmFNZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgUHJpdmF0ZSBpZGVudGlmaWVycyBhcmUgbm90IHN1cHBvcnRlZC4gVW5leHBlY3RlZCBwcml2YXRlIGlkZW50aWZpZXI6ICR7dG9rZW59YDtcbiAgICAgICAgaWYgKGV4dHJhTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGAsICR7ZXh0cmFNZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcnJvciByZWNvdmVyeSBzaG91bGQgc2tpcCB0b2tlbnMgdW50aWwgaXQgZW5jb3VudGVycyBhIHJlY292ZXJ5IHBvaW50LlxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBhcmUgdHJlYXRlZCBhcyB1bmNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gZW5kIG9mIGlucHV0XG4gICAgICogICAtICc7JyAocGFyc2VDaGFpbigpIGlzIGFsd2F5cyB0aGUgcm9vdCBwcm9kdWN0aW9uLCBhbmQgaXQgZXhwZWN0cyBhICc7JylcbiAgICAgKiAgIC0gJ3wnIChzaW5jZSBwaXBlcyBtYXkgYmUgY2hhaW5lZCBhbmQgZWFjaCBwaXBlIGV4cHJlc3Npb24gbWF5IGJlIHRyZWF0ZWQgaW5kZXBlbmRlbnRseSlcbiAgICAgKlxuICAgICAqIFRoZSBmb2xsb3dpbmcgYXJlIGNvbmRpdGlvbmFsIHJlY292ZXJ5IHBvaW50czpcbiAgICAgKiAgIC0gJyknLCAnfScsICddJyBpZiBvbmUgb2YgY2FsbGluZyBwcm9kdWN0aW9ucyBpcyBleHBlY3Rpbmcgb25lIG9mIHRoZXNlIHN5bWJvbHNcbiAgICAgKiAgICAgLSBUaGlzIGFsbG93cyBza2lwKCkgdG8gcmVjb3ZlciBmcm9tIGVycm9ycyBzdWNoIGFzICcoYS4pICsgMScgYWxsb3dpbmcgbW9yZSBvZiB0aGUgQVNUIHRvXG4gICAgICogICAgICAgYmUgcmV0YWluZWQgKGl0IGRvZXNuJ3Qgc2tpcCBhbnkgdG9rZW5zIGFzIHRoZSAnKScgaXMgcmV0YWluZWQgYmVjYXVzZSBvZiB0aGUgJygnIGJlZ2luc1xuICAgICAqICAgICAgIGFuICcoJyA8ZXhwcj4gJyknIHByb2R1Y3Rpb24pLlxuICAgICAqICAgICAgIFRoZSByZWNvdmVyeSBwb2ludHMgb2YgZ3JvdXBpbmcgc3ltYm9scyBtdXN0IGJlIGNvbmRpdGlvbmFsIGFzIHRoZXkgbXVzdCBiZSBza2lwcGVkIGlmXG4gICAgICogICAgICAgbm9uZSBvZiB0aGUgY2FsbGluZyBwcm9kdWN0aW9ucyBhcmUgbm90IGV4cGVjdGluZyB0aGUgY2xvc2luZyB0b2tlbiBlbHNlIHdlIHdpbGwgbmV2ZXJcbiAgICAgKiAgICAgICBtYWtlIHByb2dyZXNzIGluIHRoZSBjYXNlIG9mIGFuIGV4dHJhbmVvdXMgZ3JvdXAgY2xvc2luZyBzeW1ib2wgKHN1Y2ggYXMgYSBzdHJheSAnKScpLlxuICAgICAqICAgICAgIFRoYXQgaXMsIHdlIHNraXAgYSBjbG9zaW5nIHN5bWJvbCBpZiB3ZSBhcmUgbm90IGluIGEgZ3JvdXBpbmcgcHJvZHVjdGlvbi5cbiAgICAgKiAgIC0gJz0nIGluIGEgYFdyaXRhYmxlYCBjb250ZXh0XG4gICAgICogICAgIC0gSW4gdGhpcyBjb250ZXh0LCB3ZSBhcmUgYWJsZSB0byByZWNvdmVyIGFmdGVyIHNlZWluZyB0aGUgYD1gIG9wZXJhdG9yLCB3aGljaFxuICAgICAqICAgICAgIHNpZ25hbHMgdGhlIHByZXNlbmNlIG9mIGFuIGluZGVwZW5kZW50IHJ2YWx1ZSBleHByZXNzaW9uIGZvbGxvd2luZyB0aGUgYD1gIG9wZXJhdG9yLlxuICAgICAqXG4gICAgICogSWYgYSBwcm9kdWN0aW9uIGV4cGVjdHMgb25lIG9mIHRoZXNlIHRva2VuIGl0IGluY3JlbWVudHMgdGhlIGNvcnJlc3BvbmRpbmcgbmVzdGluZyBjb3VudCxcbiAgICAgKiBhbmQgdGhlbiBkZWNyZW1lbnRzIGl0IGp1c3QgcHJpb3IgdG8gY2hlY2tpbmcgaWYgdGhlIHRva2VuIGlzIGluIHRoZSBpbnB1dC5cbiAgICAgKi9cbiAgICBza2lwKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgd2hpbGUgKHRoaXMuaW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggJiYgIW4uaXNDaGFyYWN0ZXIoJFNFTUlDT0xPTikgJiZcbiAgICAgICAgICAgICFuLmlzT3BlcmF0b3IoJ3wnKSAmJiAodGhpcy5ycGFyZW5zRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUlBBUkVOKSkgJiZcbiAgICAgICAgICAgICh0aGlzLnJicmFjZXNFeHBlY3RlZCA8PSAwIHx8ICFuLmlzQ2hhcmFjdGVyKCRSQlJBQ0UpKSAmJlxuICAgICAgICAgICAgKHRoaXMucmJyYWNrZXRzRXhwZWN0ZWQgPD0gMCB8fCAhbi5pc0NoYXJhY3RlcigkUkJSQUNLRVQpKSAmJlxuICAgICAgICAgICAgKCEodGhpcy5jb250ZXh0ICYgUGFyc2VDb250ZXh0RmxhZ3MuV3JpdGFibGUpIHx8ICFuLmlzT3BlcmF0b3IoJz0nKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQuaXNFcnJvcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VyRXJyb3IodGhpcy5uZXh0LnRvU3RyaW5nKCksIHRoaXMuaW5wdXQsIHRoaXMubG9jYXRpb25UZXh0KCksIHRoaXMubG9jYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbiA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbXBsZUV4cHJlc3Npb25DaGVja2VyIGV4dGVuZHMgUmVjdXJzaXZlQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHZpc2l0UGlwZSgpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCgncGlwZXMnKTtcbiAgICB9XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSByZWFsIG9mZnNldCBpbiB0aGUgb3JpZ2luYWwgdGVtcGxhdGUgZm9yIGluZGV4ZXMgaW4gYW4gaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBCZWNhdXNlIHRlbXBsYXRlcyBjYW4gaGF2ZSBlbmNvZGVkIEhUTUwgZW50aXRpZXMgYW5kIHRoZSBpbnB1dCBwYXNzZWQgdG8gdGhlIHBhcnNlciBhdCB0aGlzIHN0YWdlXG4gKiBvZiB0aGUgY29tcGlsZXIgaXMgdGhlIF9kZWNvZGVkXyB2YWx1ZSwgd2UgbmVlZCB0byBjb21wdXRlIHRoZSByZWFsIG9mZnNldCB1c2luZyB0aGUgb3JpZ2luYWxcbiAqIGVuY29kZWQgdmFsdWVzIGluIHRoZSBpbnRlcnBvbGF0ZWQgdG9rZW5zLiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IGEgc3BlY2lhbCBjYXNlIGhhbmRsaW5nIGZvclxuICogYE1sUGFyc2VyVG9rZW5UeXBlLkVOQ09ERURfRU5USVRZYCB0b2tlbiB0eXBlcy4gQWxsIG90aGVyIGludGVycG9sYXRlZCB0b2tlbnMgYXJlIGV4cGVjdGVkIHRvXG4gKiBoYXZlIHBhcnRzIHdoaWNoIGV4YWN0bHkgbWF0Y2ggdGhlIGlucHV0IHN0cmluZyBmb3IgcGFyc2luZyB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGVkVG9rZW5zIFRoZSB0b2tlbnMgZm9yIHRoZSBpbnRlcnBvbGF0ZWQgdmFsdWUuXG4gKlxuICogQHJldHVybnMgQSBtYXAgb2YgaW5kZXggbG9jYXRpb25zIGluIHRoZSBkZWNvZGVkIHRlbXBsYXRlIHRvIGluZGV4ZXMgaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGdldEluZGV4TWFwRm9yT3JpZ2luYWxUZW1wbGF0ZShpbnRlcnBvbGF0ZWRUb2tlbnMpIHtcbiAgICBsZXQgb2Zmc2V0TWFwID0gbmV3IE1hcCgpO1xuICAgIGxldCBjb25zdW1lZEluT3JpZ2luYWxUZW1wbGF0ZSA9IDA7XG4gICAgbGV0IGNvbnN1bWVkSW5JbnB1dCA9IDA7XG4gICAgbGV0IHRva2VuSW5kZXggPSAwO1xuICAgIHdoaWxlICh0b2tlbkluZGV4IDwgaW50ZXJwb2xhdGVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VG9rZW4gPSBpbnRlcnBvbGF0ZWRUb2tlbnNbdG9rZW5JbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gOSAvKiBNbFBhcnNlclRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLykge1xuICAgICAgICAgICAgY29uc3QgW2RlY29kZWQsIGVuY29kZWRdID0gY3VycmVudFRva2VuLnBhcnRzO1xuICAgICAgICAgICAgY29uc3VtZWRJbk9yaWdpbmFsVGVtcGxhdGUgKz0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdW1lZEluSW5wdXQgKz0gZGVjb2RlZC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGhPZlBhcnRzID0gY3VycmVudFRva2VuLnBhcnRzLnJlZHVjZSgoc3VtLCBjdXJyZW50KSA9PiBzdW0gKyBjdXJyZW50Lmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBjb25zdW1lZEluSW5wdXQgKz0gbGVuZ3RoT2ZQYXJ0cztcbiAgICAgICAgICAgIGNvbnN1bWVkSW5PcmlnaW5hbFRlbXBsYXRlICs9IGxlbmd0aE9mUGFydHM7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0TWFwLnNldChjb25zdW1lZEluSW5wdXQsIGNvbnN1bWVkSW5PcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgICAgdG9rZW5JbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0TWFwO1xufVxuXG5jbGFzcyBOb2RlV2l0aEkxOG4ge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZVNwYW4sIGkxOG4pIHtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICB9XG59XG5jbGFzcyBUZXh0IGV4dGVuZHMgTm9kZVdpdGhJMThuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgc291cmNlU3BhbiwgdG9rZW5zLCBpMThuKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0VGV4dCh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBFeHBhbnNpb24gZXh0ZW5kcyBOb2RlV2l0aEkxOG4ge1xuICAgIGNvbnN0cnVjdG9yKHN3aXRjaFZhbHVlLCB0eXBlLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWVTb3VyY2VTcGFuLCBpMThuKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB0aGlzLnN3aXRjaFZhbHVlID0gc3dpdGNoVmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICAgICAgdGhpcy5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4gPSBzd2l0Y2hWYWx1ZVNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFeHBhbnNpb24odGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRXhwYW5zaW9uQ2FzZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU291cmNlU3BhbiwgZXhwU291cmNlU3Bhbikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuc291cmNlU3BhbiA9IHNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTb3VyY2VTcGFuID0gdmFsdWVTb3VyY2VTcGFuO1xuICAgICAgICB0aGlzLmV4cFNvdXJjZVNwYW4gPSBleHBTb3VyY2VTcGFuO1xuICAgIH1cbiAgICB2aXNpdCh2aXNpdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLnZpc2l0RXhwYW5zaW9uQ2FzZSh0aGlzLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBOb2RlV2l0aEkxOG4ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHZhbHVlVG9rZW5zLCBpMThuKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMua2V5U3BhbiA9IGtleVNwYW47XG4gICAgICAgIHRoaXMudmFsdWVTcGFuID0gdmFsdWVTcGFuO1xuICAgICAgICB0aGlzLnZhbHVlVG9rZW5zID0gdmFsdWVUb2tlbnM7XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRBdHRyaWJ1dGUodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuY2xhc3MgRWxlbWVudCBleHRlbmRzIE5vZGVXaXRoSTE4biB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXR0cnMsIGNoaWxkcmVuLCBzb3VyY2VTcGFuLCBzdGFydFNvdXJjZVNwYW4sIGVuZFNvdXJjZVNwYW4gPSBudWxsLCBpMThuKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5zdGFydFNvdXJjZVNwYW4gPSBzdGFydFNvdXJjZVNwYW47XG4gICAgICAgIHRoaXMuZW5kU291cmNlU3BhbiA9IGVuZFNvdXJjZVNwYW47XG4gICAgfVxuICAgIHZpc2l0KHZpc2l0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IudmlzaXRFbGVtZW50KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbn1cbmNsYXNzIENvbW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zb3VyY2VTcGFuID0gc291cmNlU3BhbjtcbiAgICB9XG4gICAgdmlzaXQodmlzaXRvciwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdmlzaXRvci52aXNpdENvbW1lbnQodGhpcywgY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmlzaXRBbGwodmlzaXRvciwgbm9kZXMsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgdmlzaXQgPSB2aXNpdG9yLnZpc2l0ID9cbiAgICAgICAgKGFzdCkgPT4gdmlzaXRvci52aXNpdChhc3QsIGNvbnRleHQpIHx8IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KSA6XG4gICAgICAgIChhc3QpID0+IGFzdC52aXNpdCh2aXNpdG9yLCBjb250ZXh0KTtcbiAgICBub2Rlcy5mb3JFYWNoKGFzdCA9PiB7XG4gICAgICAgIGNvbnN0IGFzdFJlc3VsdCA9IHZpc2l0KGFzdCk7XG4gICAgICAgIGlmIChhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzdFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgUmVjdXJzaXZlVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB2aXNpdEVsZW1lbnQoYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihjb250ZXh0LCB2aXNpdCA9PiB7XG4gICAgICAgICAgICB2aXNpdChhc3QuYXR0cnMpO1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRUZXh0KGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRDb21tZW50KGFzdCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oYXN0LCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Q2hpbGRyZW4oY29udGV4dCwgdmlzaXQgPT4ge1xuICAgICAgICAgICAgdmlzaXQoYXN0LmNhc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShhc3QsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q2hpbGRyZW4oY29udGV4dCwgY2IpIHtcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgbGV0IHQgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiB2aXNpdChjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh2aXNpdEFsbCh0LCBjaGlsZHJlbiwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGNiKHZpc2l0KTtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIHJlc3VsdHMpO1xuICAgIH1cbn1cblxudmFyIFRhZ0NvbnRlbnRUeXBlO1xuKGZ1bmN0aW9uIChUYWdDb250ZW50VHlwZSkge1xuICAgIFRhZ0NvbnRlbnRUeXBlW1RhZ0NvbnRlbnRUeXBlW1wiUkFXX1RFWFRcIl0gPSAwXSA9IFwiUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIkVTQ0FQQUJMRV9SQVdfVEVYVFwiXSA9IDFdID0gXCJFU0NBUEFCTEVfUkFXX1RFWFRcIjtcbiAgICBUYWdDb250ZW50VHlwZVtUYWdDb250ZW50VHlwZVtcIlBBUlNBQkxFX0RBVEFcIl0gPSAyXSA9IFwiUEFSU0FCTEVfREFUQVwiO1xufSkoVGFnQ29udGVudFR5cGUgfHwgKFRhZ0NvbnRlbnRUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHNwbGl0TnNOYW1lKGVsZW1lbnROYW1lKSB7XG4gICAgaWYgKGVsZW1lbnROYW1lWzBdICE9ICc6Jykge1xuICAgICAgICByZXR1cm4gW251bGwsIGVsZW1lbnROYW1lXTtcbiAgICB9XG4gICAgY29uc3QgY29sb25JbmRleCA9IGVsZW1lbnROYW1lLmluZGV4T2YoJzonLCAxKTtcbiAgICBpZiAoY29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmb3JtYXQgXCIke2VsZW1lbnROYW1lfVwiIGV4cGVjdGluZyBcIjpuYW1lc3BhY2U6bmFtZVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudE5hbWUuc2xpY2UoMSwgY29sb25JbmRleCksIGVsZW1lbnROYW1lLnNsaWNlKGNvbG9uSW5kZXggKyAxKV07XG59XG4vLyBgPG5nLWNvbnRhaW5lcj5gIHRhZ3Mgd29yayB0aGUgc2FtZSByZWdhcmRsZXNzIHRoZSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGlzTmdDb250YWluZXIodGFnTmFtZSkge1xuICAgIHJldHVybiBzcGxpdE5zTmFtZSh0YWdOYW1lKVsxXSA9PT0gJ25nLWNvbnRhaW5lcic7XG59XG4vLyBgPG5nLWNvbnRlbnQ+YCB0YWdzIHdvcmsgdGhlIHNhbWUgcmVnYXJkbGVzcyB0aGUgbmFtZXNwYWNlXG5mdW5jdGlvbiBpc05nQ29udGVudCh0YWdOYW1lKSB7XG4gICAgcmV0dXJuIHNwbGl0TnNOYW1lKHRhZ05hbWUpWzFdID09PSAnbmctY29udGVudCc7XG59XG4vLyBgPG5nLXRlbXBsYXRlPmAgdGFncyB3b3JrIHRoZSBzYW1lIHJlZ2FyZGxlc3MgdGhlIG5hbWVzcGFjZVxuZnVuY3Rpb24gaXNOZ1RlbXBsYXRlKHRhZ05hbWUpIHtcbiAgICByZXR1cm4gc3BsaXROc05hbWUodGFnTmFtZSlbMV0gPT09ICduZy10ZW1wbGF0ZSc7XG59XG5mdW5jdGlvbiBnZXROc1ByZWZpeChmdWxsTmFtZSkge1xuICAgIHJldHVybiBmdWxsTmFtZSA9PT0gbnVsbCA/IG51bGwgOiBzcGxpdE5zTmFtZShmdWxsTmFtZSlbMF07XG59XG5mdW5jdGlvbiBtZXJnZU5zQW5kTmFtZShwcmVmaXgsIGxvY2FsTmFtZSkge1xuICAgIHJldHVybiBwcmVmaXggPyBgOiR7cHJlZml4fToke2xvY2FsTmFtZX1gIDogbG9jYWxOYW1lO1xufVxuXG5jbGFzcyBFbGVtZW50U2NoZW1hUmVnaXN0cnkge1xufVxuXG5jb25zdCBCT09MRUFOID0gJ2Jvb2xlYW4nO1xuY29uc3QgTlVNQkVSID0gJ251bWJlcic7XG5jb25zdCBTVFJJTkcgPSAnc3RyaW5nJztcbmNvbnN0IE9CSkVDVCA9ICdvYmplY3QnO1xuLyoqXG4gKiBUaGlzIGFycmF5IHJlcHJlc2VudHMgdGhlIERPTSBzY2hlbWEuIEl0IGVuY29kZXMgaW5oZXJpdGFuY2UsIHByb3BlcnRpZXMsIGFuZCBldmVudHMuXG4gKlxuICogIyMgT3ZlcnZpZXdcbiAqXG4gKiBFYWNoIGxpbmUgcmVwcmVzZW50cyBvbmUga2luZCBvZiBlbGVtZW50LiBUaGUgYGVsZW1lbnRfaW5oZXJpdGFuY2VgIGFuZCBwcm9wZXJ0aWVzIGFyZSBqb2luZWRcbiAqIHVzaW5nIGBlbGVtZW50X2luaGVyaXRhbmNlfHByb3BlcnRpZXNgIHN5bnRheC5cbiAqXG4gKiAjIyBFbGVtZW50IEluaGVyaXRhbmNlXG4gKlxuICogVGhlIGBlbGVtZW50X2luaGVyaXRhbmNlYCBjYW4gYmUgZnVydGhlciBzdWJkaXZpZGVkIGFzIGBlbGVtZW50MSxlbGVtZW50MiwuLi5ecGFyZW50RWxlbWVudGAuXG4gKiBIZXJlIHRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIGFyZSBzZXBhcmF0ZWQgYnkgYCxgIChjb21tYXMpLiBFdmVyeSBlbGVtZW50IGluIHRoZSBsaXN0XG4gKiBoYXMgaWRlbnRpY2FsIHByb3BlcnRpZXMuXG4gKlxuICogQW4gYGVsZW1lbnRgIG1heSBpbmhlcml0IGFkZGl0aW9uYWwgcHJvcGVydGllcyBmcm9tIGBwYXJlbnRFbGVtZW50YCBJZiBubyBgXnBhcmVudEVsZW1lbnRgIGlzXG4gKiBzcGVjaWZpZWQgdGhlbiBgXCJcImAgKGJsYW5rKSBlbGVtZW50IGlzIGFzc3VtZWQuXG4gKlxuICogTk9URTogVGhlIGJsYW5rIGVsZW1lbnQgaW5oZXJpdHMgZnJvbSByb290IGBbRWxlbWVudF1gIGVsZW1lbnQsIHRoZSBzdXBlciBlbGVtZW50IG9mIGFsbFxuICogZWxlbWVudHMuXG4gKlxuICogTk9URSBhbiBlbGVtZW50IHByZWZpeCBzdWNoIGFzIGA6c3ZnOmAgaGFzIG5vIHNwZWNpYWwgbWVhbmluZyB0byB0aGUgc2NoZW1hLlxuICpcbiAqICMjIFByb3BlcnRpZXNcbiAqXG4gKiBFYWNoIGVsZW1lbnQgaGFzIGEgc2V0IG9mIHByb3BlcnRpZXMgc2VwYXJhdGVkIGJ5IGAsYCAoY29tbWFzKS4gRWFjaCBwcm9wZXJ0eSBjYW4gYmUgcHJlZml4ZWRcbiAqIGJ5IGEgc3BlY2lhbCBjaGFyYWN0ZXIgZGVzaWduYXRpbmcgaXRzIHR5cGU6XG4gKlxuICogLSAobm8gcHJlZml4KTogcHJvcGVydHkgaXMgYSBzdHJpbmcuXG4gKiAtIGAqYDogcHJvcGVydHkgcmVwcmVzZW50cyBhbiBldmVudC5cbiAqIC0gYCFgOiBwcm9wZXJ0eSBpcyBhIGJvb2xlYW4uXG4gKiAtIGAjYDogcHJvcGVydHkgaXMgYSBudW1iZXIuXG4gKiAtIGAlYDogcHJvcGVydHkgaXMgYW4gb2JqZWN0LlxuICpcbiAqICMjIFF1ZXJ5XG4gKlxuICogVGhlIGNsYXNzIGNyZWF0ZXMgYW4gaW50ZXJuYWwgc3F1YXMgcmVwcmVzZW50YXRpb24gd2hpY2ggYWxsb3dzIHRvIGVhc2lseSBhbnN3ZXIgdGhlIHF1ZXJ5IG9mXG4gKiBpZiBhIGdpdmVuIHByb3BlcnR5IGV4aXN0IG9uIGEgZ2l2ZW4gZWxlbWVudC5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCB5ZXQgc3VwcG9ydCBxdWVyeWluZyBmb3IgdHlwZXMgb3IgZXZlbnRzLlxuICogTk9URTogVGhpcyBzY2hlbWEgaXMgYXV0byBleHRyYWN0ZWQgZnJvbSBgc2NoZW1hX2V4dHJhY3Rvci50c2AgbG9jYXRlZCBpbiB0aGUgdGVzdCBmb2xkZXIsXG4gKiAgICAgICBzZWUgZG9tX2VsZW1lbnRfc2NoZW1hX3JlZ2lzdHJ5X3NwZWMudHNcbiAqL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT0gUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICAgLSAgUyBUIE8gUCAgIC0gIFMgVCBPIFAgICAtICBTIFQgTyBQICA9PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICBETyBOT1QgRURJVCBUSElTIERPTSBTQ0hFTUEgV0lUSE9VVCBBIFNFQ1VSSVRZIFJFVklFVyFcbi8vXG4vLyBOZXdseSBhZGRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgc2VjdXJpdHkgcmV2aWV3ZWQgYW5kIGFzc2lnbmVkIGFuIGFwcHJvcHJpYXRlIFNlY3VyaXR5Q29udGV4dCBpblxuLy8gZG9tX3NlY3VyaXR5X3NjaGVtYS50cy4gUmVhY2ggb3V0IHRvIG1wcm9ic3QgJiByamFtZXQgZm9yIGRldGFpbHMuXG4vL1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgU0NIRU1BID0gW1xuICAgICdbRWxlbWVudF18dGV4dENvbnRlbnQsJWFyaWFBdG9taWMsJWFyaWFBdXRvQ29tcGxldGUsJWFyaWFCdXN5LCVhcmlhQ2hlY2tlZCwlYXJpYUNvbENvdW50LCVhcmlhQ29sSW5kZXgsJWFyaWFDb2xTcGFuLCVhcmlhQ3VycmVudCwlYXJpYURlc2NyaXB0aW9uLCVhcmlhRGlzYWJsZWQsJWFyaWFFeHBhbmRlZCwlYXJpYUhhc1BvcHVwLCVhcmlhSGlkZGVuLCVhcmlhS2V5U2hvcnRjdXRzLCVhcmlhTGFiZWwsJWFyaWFMZXZlbCwlYXJpYUxpdmUsJWFyaWFNb2RhbCwlYXJpYU11bHRpTGluZSwlYXJpYU11bHRpU2VsZWN0YWJsZSwlYXJpYU9yaWVudGF0aW9uLCVhcmlhUGxhY2Vob2xkZXIsJWFyaWFQb3NJblNldCwlYXJpYVByZXNzZWQsJWFyaWFSZWFkT25seSwlYXJpYVJlbGV2YW50LCVhcmlhUmVxdWlyZWQsJWFyaWFSb2xlRGVzY3JpcHRpb24sJWFyaWFSb3dDb3VudCwlYXJpYVJvd0luZGV4LCVhcmlhUm93U3BhbiwlYXJpYVNlbGVjdGVkLCVhcmlhU2V0U2l6ZSwlYXJpYVNvcnQsJWFyaWFWYWx1ZU1heCwlYXJpYVZhbHVlTWluLCVhcmlhVmFsdWVOb3csJWFyaWFWYWx1ZVRleHQsJWNsYXNzTGlzdCxjbGFzc05hbWUsZWxlbWVudFRpbWluZyxpZCxpbm5lckhUTUwsKmJlZm9yZWNvcHksKmJlZm9yZWN1dCwqYmVmb3JlcGFzdGUsKmZ1bGxzY3JlZW5jaGFuZ2UsKmZ1bGxzY3JlZW5lcnJvciwqc2VhcmNoLCp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlLCp3ZWJraXRmdWxsc2NyZWVuZXJyb3Isb3V0ZXJIVE1MLCVwYXJ0LCNzY3JvbGxMZWZ0LCNzY3JvbGxUb3Asc2xvdCcgK1xuICAgICAgICAvKiBhZGRlZCBtYW51YWxseSB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VzICovXG4gICAgICAgICcsKm1lc3NhZ2UsKm1vemZ1bGxzY3JlZW5jaGFuZ2UsKm1vemZ1bGxzY3JlZW5lcnJvciwqbW96cG9pbnRlcmxvY2tjaGFuZ2UsKm1venBvaW50ZXJsb2NrZXJyb3IsKndlYmdsY29udGV4dGNyZWF0aW9uZXJyb3IsKndlYmdsY29udGV4dGxvc3QsKndlYmdsY29udGV4dHJlc3RvcmVkJyxcbiAgICAnW0hUTUxFbGVtZW50XV5bRWxlbWVudF18YWNjZXNzS2V5LGF1dG9jYXBpdGFsaXplLCFhdXRvZm9jdXMsY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLGVudGVyS2V5SGludCwhaGlkZGVuLGlubmVyVGV4dCxpbnB1dE1vZGUsbGFuZyxub25jZSwqYWJvcnQsKmFuaW1hdGlvbmVuZCwqYW5pbWF0aW9uaXRlcmF0aW9uLCphbmltYXRpb25zdGFydCwqYXV4Y2xpY2ssKmJlZm9yZXhyc2VsZWN0LCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpmb3JtZGF0YSwqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcG9pbnRlcmNhbmNlbCwqcG9pbnRlcmRvd24sKnBvaW50ZXJlbnRlciwqcG9pbnRlcmxlYXZlLCpwb2ludGVybW92ZSwqcG9pbnRlcm91dCwqcG9pbnRlcm92ZXIsKnBvaW50ZXJyYXd1cGRhdGUsKnBvaW50ZXJ1cCwqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VjdXJpdHlwb2xpY3l2aW9sYXRpb24sKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3Rpb25jaGFuZ2UsKnNlbGVjdHN0YXJ0LCpzbG90Y2hhbmdlLCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdHJhbnNpdGlvbmNhbmNlbCwqdHJhbnNpdGlvbmVuZCwqdHJhbnNpdGlvbnJ1biwqdHJhbnNpdGlvbnN0YXJ0LCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmtpdGFuaW1hdGlvbmVuZCwqd2Via2l0YW5pbWF0aW9uaXRlcmF0aW9uLCp3ZWJraXRhbmltYXRpb25zdGFydCwqd2Via2l0dHJhbnNpdGlvbmVuZCwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZSx2aXJ0dWFsS2V5Ym9hcmRQb2xpY3knLFxuICAgICdhYmJyLGFkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiLGJkaSxiZG8sY2l0ZSxjb250ZW50LGNvZGUsZGQsZGZuLGR0LGVtLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaGdyb3VwLGksa2JkLG1haW4sbWFyayxuYXYsbm9zY3JpcHQscmIscnAscnQscnRjLHJ1YnkscyxzYW1wLHNlY3Rpb24sc21hbGwsc3Ryb25nLHN1YixzdXAsdSx2YXIsd2JyXltIVE1MRWxlbWVudF18YWNjZXNzS2V5LGF1dG9jYXBpdGFsaXplLCFhdXRvZm9jdXMsY29udGVudEVkaXRhYmxlLGRpciwhZHJhZ2dhYmxlLGVudGVyS2V5SGludCwhaGlkZGVuLGlubmVyVGV4dCxpbnB1dE1vZGUsbGFuZyxub25jZSwqYWJvcnQsKmFuaW1hdGlvbmVuZCwqYW5pbWF0aW9uaXRlcmF0aW9uLCphbmltYXRpb25zdGFydCwqYXV4Y2xpY2ssKmJlZm9yZXhyc2VsZWN0LCpibHVyLCpjYW5jZWwsKmNhbnBsYXksKmNhbnBsYXl0aHJvdWdoLCpjaGFuZ2UsKmNsaWNrLCpjbG9zZSwqY29udGV4dG1lbnUsKmNvcHksKmN1ZWNoYW5nZSwqY3V0LCpkYmxjbGljaywqZHJhZywqZHJhZ2VuZCwqZHJhZ2VudGVyLCpkcmFnbGVhdmUsKmRyYWdvdmVyLCpkcmFnc3RhcnQsKmRyb3AsKmR1cmF0aW9uY2hhbmdlLCplbXB0aWVkLCplbmRlZCwqZXJyb3IsKmZvY3VzLCpmb3JtZGF0YSwqZ290cG9pbnRlcmNhcHR1cmUsKmlucHV0LCppbnZhbGlkLCprZXlkb3duLCprZXlwcmVzcywqa2V5dXAsKmxvYWQsKmxvYWRlZGRhdGEsKmxvYWRlZG1ldGFkYXRhLCpsb2Fkc3RhcnQsKmxvc3Rwb2ludGVyY2FwdHVyZSwqbW91c2Vkb3duLCptb3VzZWVudGVyLCptb3VzZWxlYXZlLCptb3VzZW1vdmUsKm1vdXNlb3V0LCptb3VzZW92ZXIsKm1vdXNldXAsKm1vdXNld2hlZWwsKnBhc3RlLCpwYXVzZSwqcGxheSwqcGxheWluZywqcG9pbnRlcmNhbmNlbCwqcG9pbnRlcmRvd24sKnBvaW50ZXJlbnRlciwqcG9pbnRlcmxlYXZlLCpwb2ludGVybW92ZSwqcG9pbnRlcm91dCwqcG9pbnRlcm92ZXIsKnBvaW50ZXJyYXd1cGRhdGUsKnBvaW50ZXJ1cCwqcHJvZ3Jlc3MsKnJhdGVjaGFuZ2UsKnJlc2V0LCpyZXNpemUsKnNjcm9sbCwqc2VjdXJpdHlwb2xpY3l2aW9sYXRpb24sKnNlZWtlZCwqc2Vla2luZywqc2VsZWN0LCpzZWxlY3Rpb25jaGFuZ2UsKnNlbGVjdHN0YXJ0LCpzbG90Y2hhbmdlLCpzdGFsbGVkLCpzdWJtaXQsKnN1c3BlbmQsKnRpbWV1cGRhdGUsKnRvZ2dsZSwqdHJhbnNpdGlvbmNhbmNlbCwqdHJhbnNpdGlvbmVuZCwqdHJhbnNpdGlvbnJ1biwqdHJhbnNpdGlvbnN0YXJ0LCp2b2x1bWVjaGFuZ2UsKndhaXRpbmcsKndlYmtpdGFuaW1hdGlvbmVuZCwqd2Via2l0YW5pbWF0aW9uaXRlcmF0aW9uLCp3ZWJraXRhbmltYXRpb25zdGFydCwqd2Via2l0dHJhbnNpdGlvbmVuZCwqd2hlZWwsb3V0ZXJUZXh0LCFzcGVsbGNoZWNrLCVzdHlsZSwjdGFiSW5kZXgsdGl0bGUsIXRyYW5zbGF0ZSx2aXJ0dWFsS2V5Ym9hcmRQb2xpY3knLFxuICAgICdtZWRpYV5bSFRNTEVsZW1lbnRdfCFhdXRvcGxheSwhY29udHJvbHMsJWNvbnRyb2xzTGlzdCwlY3Jvc3NPcmlnaW4sI2N1cnJlbnRUaW1lLCFkZWZhdWx0TXV0ZWQsI2RlZmF1bHRQbGF5YmFja1JhdGUsIWRpc2FibGVSZW1vdGVQbGF5YmFjaywhbG9vcCwhbXV0ZWQsKmVuY3J5cHRlZCwqd2FpdGluZ2ZvcmtleSwjcGxheWJhY2tSYXRlLHByZWxvYWQsIXByZXNlcnZlc1BpdGNoLHNyYywlc3JjT2JqZWN0LCN2b2x1bWUnLFxuICAgICc6c3ZnOl5bSFRNTEVsZW1lbnRdfCFhdXRvZm9jdXMsbm9uY2UsKmFib3J0LCphbmltYXRpb25lbmQsKmFuaW1hdGlvbml0ZXJhdGlvbiwqYW5pbWF0aW9uc3RhcnQsKmF1eGNsaWNrLCpiZWZvcmV4cnNlbGVjdCwqYmx1ciwqY2FuY2VsLCpjYW5wbGF5LCpjYW5wbGF5dGhyb3VnaCwqY2hhbmdlLCpjbGljaywqY2xvc2UsKmNvbnRleHRtZW51LCpjb3B5LCpjdWVjaGFuZ2UsKmN1dCwqZGJsY2xpY2ssKmRyYWcsKmRyYWdlbmQsKmRyYWdlbnRlciwqZHJhZ2xlYXZlLCpkcmFnb3ZlciwqZHJhZ3N0YXJ0LCpkcm9wLCpkdXJhdGlvbmNoYW5nZSwqZW1wdGllZCwqZW5kZWQsKmVycm9yLCpmb2N1cywqZm9ybWRhdGEsKmdvdHBvaW50ZXJjYXB0dXJlLCppbnB1dCwqaW52YWxpZCwqa2V5ZG93biwqa2V5cHJlc3MsKmtleXVwLCpsb2FkLCpsb2FkZWRkYXRhLCpsb2FkZWRtZXRhZGF0YSwqbG9hZHN0YXJ0LCpsb3N0cG9pbnRlcmNhcHR1cmUsKm1vdXNlZG93biwqbW91c2VlbnRlciwqbW91c2VsZWF2ZSwqbW91c2Vtb3ZlLCptb3VzZW91dCwqbW91c2VvdmVyLCptb3VzZXVwLCptb3VzZXdoZWVsLCpwYXN0ZSwqcGF1c2UsKnBsYXksKnBsYXlpbmcsKnBvaW50ZXJjYW5jZWwsKnBvaW50ZXJkb3duLCpwb2ludGVyZW50ZXIsKnBvaW50ZXJsZWF2ZSwqcG9pbnRlcm1vdmUsKnBvaW50ZXJvdXQsKnBvaW50ZXJvdmVyLCpwb2ludGVycmF3dXBkYXRlLCpwb2ludGVydXAsKnByb2dyZXNzLCpyYXRlY2hhbmdlLCpyZXNldCwqcmVzaXplLCpzY3JvbGwsKnNlY3VyaXR5cG9saWN5dmlvbGF0aW9uLCpzZWVrZWQsKnNlZWtpbmcsKnNlbGVjdCwqc2VsZWN0aW9uY2hhbmdlLCpzZWxlY3RzdGFydCwqc2xvdGNoYW5nZSwqc3RhbGxlZCwqc3VibWl0LCpzdXNwZW5kLCp0aW1ldXBkYXRlLCp0b2dnbGUsKnRyYW5zaXRpb25jYW5jZWwsKnRyYW5zaXRpb25lbmQsKnRyYW5zaXRpb25ydW4sKnRyYW5zaXRpb25zdGFydCwqdm9sdW1lY2hhbmdlLCp3YWl0aW5nLCp3ZWJraXRhbmltYXRpb25lbmQsKndlYmtpdGFuaW1hdGlvbml0ZXJhdGlvbiwqd2Via2l0YW5pbWF0aW9uc3RhcnQsKndlYmtpdHRyYW5zaXRpb25lbmQsKndoZWVsLCVzdHlsZSwjdGFiSW5kZXgnLFxuICAgICc6c3ZnOmdyYXBoaWNzXjpzdmc6fCcsXG4gICAgJzpzdmc6YW5pbWF0aW9uXjpzdmc6fCpiZWdpbiwqZW5kLCpyZXBlYXQnLFxuICAgICc6c3ZnOmdlb21ldHJ5Xjpzdmc6fCcsXG4gICAgJzpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbl46c3ZnOnwnLFxuICAgICc6c3ZnOmdyYWRpZW50Xjpzdmc6fCcsXG4gICAgJzpzdmc6dGV4dENvbnRlbnReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOnRleHRQb3NpdGlvbmluZ146c3ZnOnRleHRDb250ZW50fCcsXG4gICAgJ2FeW0hUTUxFbGVtZW50XXxjaGFyc2V0LGNvb3Jkcyxkb3dubG9hZCxoYXNoLGhvc3QsaG9zdG5hbWUsaHJlZixocmVmbGFuZyxuYW1lLHBhc3N3b3JkLHBhdGhuYW1lLHBpbmcscG9ydCxwcm90b2NvbCxyZWZlcnJlclBvbGljeSxyZWwsJXJlbExpc3QscmV2LHNlYXJjaCxzaGFwZSx0YXJnZXQsdGV4dCx0eXBlLHVzZXJuYW1lJyxcbiAgICAnYXJlYV5bSFRNTEVsZW1lbnRdfGFsdCxjb29yZHMsZG93bmxvYWQsaGFzaCxob3N0LGhvc3RuYW1lLGhyZWYsIW5vSHJlZixwYXNzd29yZCxwYXRobmFtZSxwaW5nLHBvcnQscHJvdG9jb2wscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHNlYXJjaCxzaGFwZSx0YXJnZXQsdXNlcm5hbWUnLFxuICAgICdhdWRpb15tZWRpYXwnLFxuICAgICdicl5bSFRNTEVsZW1lbnRdfGNsZWFyJyxcbiAgICAnYmFzZV5bSFRNTEVsZW1lbnRdfGhyZWYsdGFyZ2V0JyxcbiAgICAnYm9keV5bSFRNTEVsZW1lbnRdfGFMaW5rLGJhY2tncm91bmQsYmdDb2xvcixsaW5rLCphZnRlcnByaW50LCpiZWZvcmVwcmludCwqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCptZXNzYWdlZXJyb3IsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHRleHQsdkxpbmsnLFxuICAgICdidXR0b25eW0hUTUxFbGVtZW50XXwhZGlzYWJsZWQsZm9ybUFjdGlvbixmb3JtRW5jdHlwZSxmb3JtTWV0aG9kLCFmb3JtTm9WYWxpZGF0ZSxmb3JtVGFyZ2V0LG5hbWUsdHlwZSx2YWx1ZScsXG4gICAgJ2NhbnZhc15bSFRNTEVsZW1lbnRdfCNoZWlnaHQsI3dpZHRoJyxcbiAgICAnY29udGVudF5bSFRNTEVsZW1lbnRdfHNlbGVjdCcsXG4gICAgJ2RsXltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICdkYXRhXltIVE1MRWxlbWVudF18dmFsdWUnLFxuICAgICdkYXRhbGlzdF5bSFRNTEVsZW1lbnRdfCcsXG4gICAgJ2RldGFpbHNeW0hUTUxFbGVtZW50XXwhb3BlbicsXG4gICAgJ2RpYWxvZ15bSFRNTEVsZW1lbnRdfCFvcGVuLHJldHVyblZhbHVlJyxcbiAgICAnZGlyXltIVE1MRWxlbWVudF18IWNvbXBhY3QnLFxuICAgICdkaXZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2VtYmVkXltIVE1MRWxlbWVudF18YWxpZ24saGVpZ2h0LG5hbWUsc3JjLHR5cGUsd2lkdGgnLFxuICAgICdmaWVsZHNldF5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxuYW1lJyxcbiAgICAnZm9udF5bSFRNTEVsZW1lbnRdfGNvbG9yLGZhY2Usc2l6ZScsXG4gICAgJ2Zvcm1eW0hUTUxFbGVtZW50XXxhY2NlcHRDaGFyc2V0LGFjdGlvbixhdXRvY29tcGxldGUsZW5jb2RpbmcsZW5jdHlwZSxtZXRob2QsbmFtZSwhbm9WYWxpZGF0ZSx0YXJnZXQnLFxuICAgICdmcmFtZV5bSFRNTEVsZW1lbnRdfGZyYW1lQm9yZGVyLGxvbmdEZXNjLG1hcmdpbkhlaWdodCxtYXJnaW5XaWR0aCxuYW1lLCFub1Jlc2l6ZSxzY3JvbGxpbmcsc3JjJyxcbiAgICAnZnJhbWVzZXReW0hUTUxFbGVtZW50XXxjb2xzLCphZnRlcnByaW50LCpiZWZvcmVwcmludCwqYmVmb3JldW5sb2FkLCpibHVyLCplcnJvciwqZm9jdXMsKmhhc2hjaGFuZ2UsKmxhbmd1YWdlY2hhbmdlLCpsb2FkLCptZXNzYWdlLCptZXNzYWdlZXJyb3IsKm9mZmxpbmUsKm9ubGluZSwqcGFnZWhpZGUsKnBhZ2VzaG93LCpwb3BzdGF0ZSwqcmVqZWN0aW9uaGFuZGxlZCwqcmVzaXplLCpzY3JvbGwsKnN0b3JhZ2UsKnVuaGFuZGxlZHJlamVjdGlvbiwqdW5sb2FkLHJvd3MnLFxuICAgICdocl5bSFRNTEVsZW1lbnRdfGFsaWduLGNvbG9yLCFub1NoYWRlLHNpemUsd2lkdGgnLFxuICAgICdoZWFkXltIVE1MRWxlbWVudF18JyxcbiAgICAnaDEsaDIsaDMsaDQsaDUsaDZeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ2h0bWxeW0hUTUxFbGVtZW50XXx2ZXJzaW9uJyxcbiAgICAnaWZyYW1lXltIVE1MRWxlbWVudF18YWxpZ24sYWxsb3csIWFsbG93RnVsbHNjcmVlbiwhYWxsb3dQYXltZW50UmVxdWVzdCxjc3AsZnJhbWVCb3JkZXIsaGVpZ2h0LGxvYWRpbmcsbG9uZ0Rlc2MsbWFyZ2luSGVpZ2h0LG1hcmdpbldpZHRoLG5hbWUscmVmZXJyZXJQb2xpY3ksJXNhbmRib3gsc2Nyb2xsaW5nLHNyYyxzcmNkb2Msd2lkdGgnLFxuICAgICdpbWdeW0hUTUxFbGVtZW50XXxhbGlnbixhbHQsYm9yZGVyLCVjcm9zc09yaWdpbixkZWNvZGluZywjaGVpZ2h0LCNoc3BhY2UsIWlzTWFwLGxvYWRpbmcsbG9uZ0Rlc2MsbG93c3JjLG5hbWUscmVmZXJyZXJQb2xpY3ksc2l6ZXMsc3JjLHNyY3NldCx1c2VNYXAsI3ZzcGFjZSwjd2lkdGgnLFxuICAgICdpbnB1dF5bSFRNTEVsZW1lbnRdfGFjY2VwdCxhbGlnbixhbHQsYXV0b2NvbXBsZXRlLCFjaGVja2VkLCFkZWZhdWx0Q2hlY2tlZCxkZWZhdWx0VmFsdWUsZGlyTmFtZSwhZGlzYWJsZWQsJWZpbGVzLGZvcm1BY3Rpb24sZm9ybUVuY3R5cGUsZm9ybU1ldGhvZCwhZm9ybU5vVmFsaWRhdGUsZm9ybVRhcmdldCwjaGVpZ2h0LCFpbmNyZW1lbnRhbCwhaW5kZXRlcm1pbmF0ZSxtYXgsI21heExlbmd0aCxtaW4sI21pbkxlbmd0aCwhbXVsdGlwbGUsbmFtZSxwYXR0ZXJuLHBsYWNlaG9sZGVyLCFyZWFkT25seSwhcmVxdWlyZWQsc2VsZWN0aW9uRGlyZWN0aW9uLCNzZWxlY3Rpb25FbmQsI3NlbGVjdGlvblN0YXJ0LCNzaXplLHNyYyxzdGVwLHR5cGUsdXNlTWFwLHZhbHVlLCV2YWx1ZUFzRGF0ZSwjdmFsdWVBc051bWJlciwjd2lkdGgnLFxuICAgICdsaV5bSFRNTEVsZW1lbnRdfHR5cGUsI3ZhbHVlJyxcbiAgICAnbGFiZWxeW0hUTUxFbGVtZW50XXxodG1sRm9yJyxcbiAgICAnbGVnZW5kXltIVE1MRWxlbWVudF18YWxpZ24nLFxuICAgICdsaW5rXltIVE1MRWxlbWVudF18YXMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRpc2FibGVkLGhyZWYsaHJlZmxhbmcsaW1hZ2VTaXplcyxpbWFnZVNyY3NldCxpbnRlZ3JpdHksbWVkaWEscmVmZXJyZXJQb2xpY3kscmVsLCVyZWxMaXN0LHJldiwlc2l6ZXMsdGFyZ2V0LHR5cGUnLFxuICAgICdtYXBeW0hUTUxFbGVtZW50XXxuYW1lJyxcbiAgICAnbWFycXVlZV5bSFRNTEVsZW1lbnRdfGJlaGF2aW9yLGJnQ29sb3IsZGlyZWN0aW9uLGhlaWdodCwjaHNwYWNlLCNsb29wLCNzY3JvbGxBbW91bnQsI3Njcm9sbERlbGF5LCF0cnVlU3BlZWQsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ21lbnVeW0hUTUxFbGVtZW50XXwhY29tcGFjdCcsXG4gICAgJ21ldGFeW0hUTUxFbGVtZW50XXxjb250ZW50LGh0dHBFcXVpdixtZWRpYSxuYW1lLHNjaGVtZScsXG4gICAgJ21ldGVyXltIVE1MRWxlbWVudF18I2hpZ2gsI2xvdywjbWF4LCNtaW4sI29wdGltdW0sI3ZhbHVlJyxcbiAgICAnaW5zLGRlbF5bSFRNTEVsZW1lbnRdfGNpdGUsZGF0ZVRpbWUnLFxuICAgICdvbF5bSFRNTEVsZW1lbnRdfCFjb21wYWN0LCFyZXZlcnNlZCwjc3RhcnQsdHlwZScsXG4gICAgJ29iamVjdF5bSFRNTEVsZW1lbnRdfGFsaWduLGFyY2hpdmUsYm9yZGVyLGNvZGUsY29kZUJhc2UsY29kZVR5cGUsZGF0YSwhZGVjbGFyZSxoZWlnaHQsI2hzcGFjZSxuYW1lLHN0YW5kYnksdHlwZSx1c2VNYXAsI3ZzcGFjZSx3aWR0aCcsXG4gICAgJ29wdGdyb3VwXltIVE1MRWxlbWVudF18IWRpc2FibGVkLGxhYmVsJyxcbiAgICAnb3B0aW9uXltIVE1MRWxlbWVudF18IWRlZmF1bHRTZWxlY3RlZCwhZGlzYWJsZWQsbGFiZWwsIXNlbGVjdGVkLHRleHQsdmFsdWUnLFxuICAgICdvdXRwdXReW0hUTUxFbGVtZW50XXxkZWZhdWx0VmFsdWUsJWh0bWxGb3IsbmFtZSx2YWx1ZScsXG4gICAgJ3BeW0hUTUxFbGVtZW50XXxhbGlnbicsXG4gICAgJ3BhcmFtXltIVE1MRWxlbWVudF18bmFtZSx0eXBlLHZhbHVlLHZhbHVlVHlwZScsXG4gICAgJ3BpY3R1cmVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdwcmVeW0hUTUxFbGVtZW50XXwjd2lkdGgnLFxuICAgICdwcm9ncmVzc15bSFRNTEVsZW1lbnRdfCNtYXgsI3ZhbHVlJyxcbiAgICAncSxibG9ja3F1b3RlLGNpdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICdzY3JpcHReW0hUTUxFbGVtZW50XXwhYXN5bmMsY2hhcnNldCwlY3Jvc3NPcmlnaW4sIWRlZmVyLGV2ZW50LGh0bWxGb3IsaW50ZWdyaXR5LCFub01vZHVsZSwlcmVmZXJyZXJQb2xpY3ksc3JjLHRleHQsdHlwZScsXG4gICAgJ3NlbGVjdF5bSFRNTEVsZW1lbnRdfGF1dG9jb21wbGV0ZSwhZGlzYWJsZWQsI2xlbmd0aCwhbXVsdGlwbGUsbmFtZSwhcmVxdWlyZWQsI3NlbGVjdGVkSW5kZXgsI3NpemUsdmFsdWUnLFxuICAgICdzbG90XltIVE1MRWxlbWVudF18bmFtZScsXG4gICAgJ3NvdXJjZV5bSFRNTEVsZW1lbnRdfCNoZWlnaHQsbWVkaWEsc2l6ZXMsc3JjLHNyY3NldCx0eXBlLCN3aWR0aCcsXG4gICAgJ3NwYW5eW0hUTUxFbGVtZW50XXwnLFxuICAgICdzdHlsZV5bSFRNTEVsZW1lbnRdfCFkaXNhYmxlZCxtZWRpYSx0eXBlJyxcbiAgICAnY2FwdGlvbl5bSFRNTEVsZW1lbnRdfGFsaWduJyxcbiAgICAndGgsdGReW0hUTUxFbGVtZW50XXxhYmJyLGFsaWduLGF4aXMsYmdDb2xvcixjaCxjaE9mZiwjY29sU3BhbixoZWFkZXJzLGhlaWdodCwhbm9XcmFwLCNyb3dTcGFuLHNjb3BlLHZBbGlnbix3aWR0aCcsXG4gICAgJ2NvbCxjb2xncm91cF5bSFRNTEVsZW1lbnRdfGFsaWduLGNoLGNoT2ZmLCNzcGFuLHZBbGlnbix3aWR0aCcsXG4gICAgJ3RhYmxlXltIVE1MRWxlbWVudF18YWxpZ24sYmdDb2xvcixib3JkZXIsJWNhcHRpb24sY2VsbFBhZGRpbmcsY2VsbFNwYWNpbmcsZnJhbWUscnVsZXMsc3VtbWFyeSwldEZvb3QsJXRIZWFkLHdpZHRoJyxcbiAgICAndHJeW0hUTUxFbGVtZW50XXxhbGlnbixiZ0NvbG9yLGNoLGNoT2ZmLHZBbGlnbicsXG4gICAgJ3Rmb290LHRoZWFkLHRib2R5XltIVE1MRWxlbWVudF18YWxpZ24sY2gsY2hPZmYsdkFsaWduJyxcbiAgICAndGVtcGxhdGVeW0hUTUxFbGVtZW50XXwnLFxuICAgICd0ZXh0YXJlYV5bSFRNTEVsZW1lbnRdfGF1dG9jb21wbGV0ZSwjY29scyxkZWZhdWx0VmFsdWUsZGlyTmFtZSwhZGlzYWJsZWQsI21heExlbmd0aCwjbWluTGVuZ3RoLG5hbWUscGxhY2Vob2xkZXIsIXJlYWRPbmx5LCFyZXF1aXJlZCwjcm93cyxzZWxlY3Rpb25EaXJlY3Rpb24sI3NlbGVjdGlvbkVuZCwjc2VsZWN0aW9uU3RhcnQsdmFsdWUsd3JhcCcsXG4gICAgJ3RpbWVeW0hUTUxFbGVtZW50XXxkYXRlVGltZScsXG4gICAgJ3RpdGxlXltIVE1MRWxlbWVudF18dGV4dCcsXG4gICAgJ3RyYWNrXltIVE1MRWxlbWVudF18IWRlZmF1bHQsa2luZCxsYWJlbCxzcmMsc3JjbGFuZycsXG4gICAgJ3VsXltIVE1MRWxlbWVudF18IWNvbXBhY3QsdHlwZScsXG4gICAgJ3Vua25vd25eW0hUTUxFbGVtZW50XXwnLFxuICAgICd2aWRlb15tZWRpYXwhZGlzYWJsZVBpY3R1cmVJblBpY3R1cmUsI2hlaWdodCwqZW50ZXJwaWN0dXJlaW5waWN0dXJlLCpsZWF2ZXBpY3R1cmVpbnBpY3R1cmUsIXBsYXlzSW5saW5lLHBvc3Rlciwjd2lkdGgnLFxuICAgICc6c3ZnOmFeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmFuaW1hdGVeOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzphbmltYXRlTW90aW9uXjpzdmc6YW5pbWF0aW9ufCcsXG4gICAgJzpzdmc6YW5pbWF0ZVRyYW5zZm9ybV46c3ZnOmFuaW1hdGlvbnwnLFxuICAgICc6c3ZnOmNpcmNsZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6Y2xpcFBhdGheOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlZnNeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmRlc2NeOnN2Zzp8JyxcbiAgICAnOnN2ZzpkaXNjYXJkXjpzdmc6fCcsXG4gICAgJzpzdmc6ZWxsaXBzZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6ZmVCbGVuZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlQ29sb3JNYXRyaXheOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbXBvbmVudFRyYW5zZmVyXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVDb21wb3NpdGVeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUNvbnZvbHZlTWF0cml4Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEaWZmdXNlTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZURpc3BsYWNlbWVudE1hcF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRGlzdGFudExpZ2h0Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVEcm9wU2hhZG93Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVGbG9vZF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlRnVuY0FeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVGdW5jQl46c3ZnOmNvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb258JyxcbiAgICAnOnN2ZzpmZUZ1bmNHXjpzdmc6Y29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbnwnLFxuICAgICc6c3ZnOmZlRnVuY1JeOnN2Zzpjb21wb25lbnRUcmFuc2ZlckZ1bmN0aW9ufCcsXG4gICAgJzpzdmc6ZmVHYXVzc2lhbkJsdXJeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZUltYWdlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNZXJnZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlTWVyZ2VOb2RlXjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVNb3JwaG9sb2d5Xjpzdmc6fCcsXG4gICAgJzpzdmc6ZmVPZmZzZXReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVBvaW50TGlnaHReOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwZWN1bGFyTGlnaHRpbmdeOnN2Zzp8JyxcbiAgICAnOnN2ZzpmZVNwb3RMaWdodF46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVGlsZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZlVHVyYnVsZW5jZV46c3ZnOnwnLFxuICAgICc6c3ZnOmZpbHRlcl46c3ZnOnwnLFxuICAgICc6c3ZnOmZvcmVpZ25PYmplY3ReOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmdeOnN2ZzpncmFwaGljc3wnLFxuICAgICc6c3ZnOmltYWdlXjpzdmc6Z3JhcGhpY3N8ZGVjb2RpbmcnLFxuICAgICc6c3ZnOmxpbmVeOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOmxpbmVhckdyYWRpZW50Xjpzdmc6Z3JhZGllbnR8JyxcbiAgICAnOnN2ZzptcGF0aF46c3ZnOnwnLFxuICAgICc6c3ZnOm1hcmtlcl46c3ZnOnwnLFxuICAgICc6c3ZnOm1hc2teOnN2Zzp8JyxcbiAgICAnOnN2ZzptZXRhZGF0YV46c3ZnOnwnLFxuICAgICc6c3ZnOnBhdGheOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnBhdHRlcm5eOnN2Zzp8JyxcbiAgICAnOnN2Zzpwb2x5Z29uXjpzdmc6Z2VvbWV0cnl8JyxcbiAgICAnOnN2Zzpwb2x5bGluZV46c3ZnOmdlb21ldHJ5fCcsXG4gICAgJzpzdmc6cmFkaWFsR3JhZGllbnReOnN2ZzpncmFkaWVudHwnLFxuICAgICc6c3ZnOnJlY3ReOnN2ZzpnZW9tZXRyeXwnLFxuICAgICc6c3ZnOnN2Z146c3ZnOmdyYXBoaWNzfCNjdXJyZW50U2NhbGUsI3pvb21BbmRQYW4nLFxuICAgICc6c3ZnOnNjcmlwdF46c3ZnOnx0eXBlJyxcbiAgICAnOnN2ZzpzZXReOnN2ZzphbmltYXRpb258JyxcbiAgICAnOnN2ZzpzdG9wXjpzdmc6fCcsXG4gICAgJzpzdmc6c3R5bGVeOnN2Zzp8IWRpc2FibGVkLG1lZGlhLHRpdGxlLHR5cGUnLFxuICAgICc6c3ZnOnN3aXRjaF46c3ZnOmdyYXBoaWNzfCcsXG4gICAgJzpzdmc6c3ltYm9sXjpzdmc6fCcsXG4gICAgJzpzdmc6dHNwYW5eOnN2Zzp0ZXh0UG9zaXRpb25pbmd8JyxcbiAgICAnOnN2Zzp0ZXh0Xjpzdmc6dGV4dFBvc2l0aW9uaW5nfCcsXG4gICAgJzpzdmc6dGV4dFBhdGheOnN2Zzp0ZXh0Q29udGVudHwnLFxuICAgICc6c3ZnOnRpdGxlXjpzdmc6fCcsXG4gICAgJzpzdmc6dXNlXjpzdmc6Z3JhcGhpY3N8JyxcbiAgICAnOnN2Zzp2aWV3Xjpzdmc6fCN6b29tQW5kUGFuJyxcbiAgICAnZGF0YV5bSFRNTEVsZW1lbnRdfHZhbHVlJyxcbiAgICAna2V5Z2VuXltIVE1MRWxlbWVudF18IWF1dG9mb2N1cyxjaGFsbGVuZ2UsIWRpc2FibGVkLGZvcm0sa2V5dHlwZSxuYW1lJyxcbiAgICAnbWVudWl0ZW1eW0hUTUxFbGVtZW50XXx0eXBlLGxhYmVsLGljb24sIWRpc2FibGVkLCFjaGVja2VkLHJhZGlvZ3JvdXAsIWRlZmF1bHQnLFxuICAgICdzdW1tYXJ5XltIVE1MRWxlbWVudF18JyxcbiAgICAndGltZV5bSFRNTEVsZW1lbnRdfGRhdGVUaW1lJyxcbiAgICAnOnN2ZzpjdXJzb3JeOnN2Zzp8Jyxcbl07XG5jb25zdCBfQVRUUl9UT19QUk9QID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh7XG4gICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgICAnZm9ybWFjdGlvbic6ICdmb3JtQWN0aW9uJyxcbiAgICAnaW5uZXJIdG1sJzogJ2lubmVySFRNTCcsXG4gICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxufSkpO1xuLy8gSW52ZXJ0IF9BVFRSX1RPX1BST1AuXG5jb25zdCBfUFJPUF9UT19BVFRSID0gQXJyYXkuZnJvbShfQVRUUl9UT19QUk9QKS5yZWR1Y2UoKGludmVydGVkLCBbcHJvcGVydHlOYW1lLCBhdHRyaWJ1dGVOYW1lXSkgPT4ge1xuICAgIGludmVydGVkLnNldChwcm9wZXJ0eU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgIHJldHVybiBpbnZlcnRlZDtcbn0sIG5ldyBNYXAoKSk7XG5jbGFzcyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkgZXh0ZW5kcyBFbGVtZW50U2NoZW1hUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zY2hlbWEgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdlIGRvbid0IGFsbG93IGJpbmRpbmcgdG8gZXZlbnRzIGZvciBzZWN1cml0eSByZWFzb25zLiBBbGxvd2luZyBldmVudCBiaW5kaW5ncyB3b3VsZCBhbG1vc3RcbiAgICAgICAgLy8gY2VydGFpbmx5IGludHJvZHVjZSBiYWQgWFNTIHZ1bG5lcmFiaWxpdGllcy4gSW5zdGVhZCwgd2Ugc3RvcmUgZXZlbnRzIGluIGEgc2VwYXJhdGUgc2NoZW1hLlxuICAgICAgICB0aGlzLl9ldmVudFNjaGVtYSA9IG5ldyBNYXA7XG4gICAgICAgIFNDSEVNQS5mb3JFYWNoKGVuY29kZWRUeXBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBldmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBjb25zdCBbc3RyVHlwZSwgc3RyUHJvcGVydGllc10gPSBlbmNvZGVkVHlwZS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHN0clByb3BlcnRpZXMuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGNvbnN0IFt0eXBlTmFtZXMsIHN1cGVyTmFtZV0gPSBzdHJUeXBlLnNwbGl0KCdeJyk7XG4gICAgICAgICAgICB0eXBlTmFtZXMuc3BsaXQoJywnKS5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2NoZW1hLnNldCh0YWcudG9Mb3dlckNhc2UoKSwgdHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRTY2hlbWEuc2V0KHRhZy50b0xvd2VyQ2FzZSgpLCBldmVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdXBlclR5cGUgPSBzdXBlck5hbWUgJiYgdGhpcy5fc2NoZW1hLmdldChzdXBlck5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvcCwgdmFsdWVdIG9mIHN1cGVyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlLnNldChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3VwZXJFdmVudCBvZiB0aGlzLl9ldmVudFNjaGVtYS5nZXQoc3VwZXJOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQoc3VwZXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocHJvcGVydHlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5hZGQocHJvcGVydHkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuc2V0KHByb3BlcnR5LnN1YnN0cmluZygxKSwgQk9PTEVBTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLnNldChwcm9wZXJ0eS5zdWJzdHJpbmcoMSksIE5VTUJFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLnNldChwcm9wZXJ0eS5zdWJzdHJpbmcoMSksIE9CSkVDVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUuc2V0KHByb3BlcnR5LCBTVFJJTkcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNQcm9wZXJ0eSh0YWdOYW1lLCBwcm9wTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFNZXRhcy5zb21lKChzY2hlbWEpID0+IHNjaGVtYS5uYW1lID09PSBDVVNUT01fRUxFTUVOVFNfU0NIRU1BLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdGVsbCBub3cgYXMgd2UgZG9uJ3Qga25vdyB3aGljaCBwcm9wZXJ0aWVzIGEgY3VzdG9tIGVsZW1lbnQgd2lsbCBnZXRcbiAgICAgICAgICAgICAgICAvLyBvbmNlIGl0IGlzIGluc3RhbnRpYXRlZFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQcm9wZXJ0aWVzID0gdGhpcy5fc2NoZW1hLmdldCh0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8IHRoaXMuX3NjaGVtYS5nZXQoJ3Vua25vd24nKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRQcm9wZXJ0aWVzLmhhcyhwcm9wTmFtZSk7XG4gICAgfVxuICAgIGhhc0VsZW1lbnQodGFnTmFtZSwgc2NoZW1hTWV0YXMpIHtcbiAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IE5PX0VSUk9SU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNOZ0NvbnRhaW5lcih0YWdOYW1lKSB8fCBpc05nQ29udGVudCh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYU1ldGFzLnNvbWUoKHNjaGVtYSkgPT4gc2NoZW1hLm5hbWUgPT09IENVU1RPTV9FTEVNRU5UU19TQ0hFTUEubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbnkgY3VzdG9tIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjaGVtYS5oYXModGFnTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2VjdXJpdHlDb250ZXh0IHJldHVybnMgdGhlIHNlY3VyaXR5IGNvbnRleHQgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gRE9NIHRhZy5cbiAgICAgKlxuICAgICAqIFRhZyBhbmQgcHJvcGVydHkgbmFtZSBhcmUgc3RhdGljYWxseSBrbm93biBhbmQgY2Fubm90IGNoYW5nZSBhdCBydW50aW1lLCBpLmUuIGl0IGlzIG5vdFxuICAgICAqIHBvc3NpYmxlIHRvIGJpbmQgYSB2YWx1ZSBpbnRvIGEgY2hhbmdpbmcgYXR0cmlidXRlIG9yIHRhZyBuYW1lLlxuICAgICAqXG4gICAgICogVGhlIGZpbHRlcmluZyBpcyBiYXNlZCBvbiBhIGxpc3Qgb2YgYWxsb3dlZCB0YWdzfGF0dHJpYnV0ZXMuIEFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzY2hlbWFcbiAgICAgKiBhYm92ZSBhcmUgYXNzdW1lZCB0byBoYXZlIHRoZSAnTk9ORScgc2VjdXJpdHkgY29udGV4dCwgaS5lLiB0aGF0IHRoZXkgYXJlIHNhZmUgaW5lcnRcbiAgICAgKiBzdHJpbmcgdmFsdWVzLiBPbmx5IHNwZWNpZmljIHdlbGwga25vd24gYXR0YWNrIHZlY3RvcnMgYXJlIGFzc2lnbmVkIHRoZWlyIGFwcHJvcHJpYXRlIGNvbnRleHQuXG4gICAgICovXG4gICAgc2VjdXJpdHlDb250ZXh0KHRhZ05hbWUsIHByb3BOYW1lLCBpc0F0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoaXNBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIE5COiBGb3Igc2VjdXJpdHkgcHVycG9zZXMsIHVzZSB0aGUgbWFwcGVkIHByb3BlcnR5IG5hbWUsIG5vdCB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAgICAgICAgICBwcm9wTmFtZSA9IHRoaXMuZ2V0TWFwcGVkUHJvcE5hbWUocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjb21wYXJpc29ucyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgc28gdGhhdCBjYXNlIGRpZmZlcmVuY2VzIGJldHdlZW4gYXR0cmlidXRlIGFuZFxuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lcyBkbyBub3QgaGF2ZSBhIHNlY3VyaXR5IGltcGFjdC5cbiAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcHJvcE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgY3R4ID0gU0VDVVJJVFlfU0NIRU1BKClbdGFnTmFtZSArICd8JyArIHByb3BOYW1lXTtcbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgfVxuICAgICAgICBjdHggPSBTRUNVUklUWV9TQ0hFTUEoKVsnKnwnICsgcHJvcE5hbWVdO1xuICAgICAgICByZXR1cm4gY3R4ID8gY3R4IDogU2VjdXJpdHlDb250ZXh0Lk5PTkU7XG4gICAgfVxuICAgIGdldE1hcHBlZFByb3BOYW1lKHByb3BOYW1lKSB7XG4gICAgICAgIHJldHVybiBfQVRUUl9UT19QUk9QLmdldChwcm9wTmFtZSkgPz8gcHJvcE5hbWU7XG4gICAgfVxuICAgIGdldERlZmF1bHRDb21wb25lbnRFbGVtZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICduZy1jb21wb25lbnQnO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdvbicpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgQmluZGluZyB0byBldmVudCBwcm9wZXJ0eSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmAgK1xuICAgICAgICAgICAgICAgIGBcXG5JZiAnJHtuYW1lfScgaXMgYSBkaXJlY3RpdmUgaW5wdXQsIG1ha2Ugc3VyZSB0aGUgZGlyZWN0aXZlIGlzIGltcG9ydGVkIGJ5IHRoZWAgK1xuICAgICAgICAgICAgICAgIGAgY3VycmVudCBtb2R1bGUuYDtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCBtc2c6IG1zZyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ29uJykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBCaW5kaW5nIHRvIGV2ZW50IGF0dHJpYnV0ZSAnJHtuYW1lfScgaXMgZGlzYWxsb3dlZCBmb3Igc2VjdXJpdHkgcmVhc29ucywgYCArXG4gICAgICAgICAgICAgICAgYHBsZWFzZSB1c2UgKCR7bmFtZS5zbGljZSgyKX0pPS4uLmA7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogdHJ1ZSwgbXNnOiBtc2cgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFsbEtub3duRWxlbWVudE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9zY2hlbWEua2V5cygpKTtcbiAgICB9XG4gICAgYWxsS25vd25BdHRyaWJ1dGVzT2ZFbGVtZW50KHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BlcnRpZXMgPSB0aGlzLl9zY2hlbWEuZ2V0KHRhZ05hbWUudG9Mb3dlckNhc2UoKSkgfHwgdGhpcy5fc2NoZW1hLmdldCgndW5rbm93bicpO1xuICAgICAgICAvLyBDb252ZXJ0IHByb3BlcnRpZXMgdG8gYXR0cmlidXRlcy5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudFByb3BlcnRpZXMua2V5cygpKS5tYXAocHJvcCA9PiBfUFJPUF9UT19BVFRSLmdldChwcm9wKSA/PyBwcm9wKTtcbiAgICB9XG4gICAgYWxsS25vd25FdmVudHNPZkVsZW1lbnQodGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9ldmVudFNjaGVtYS5nZXQodGFnTmFtZS50b0xvd2VyQ2FzZSgpKSA/PyBbXSk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUFuaW1hdGlvblN0eWxlUHJvcGVydHkocHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGRhc2hDYXNlVG9DYW1lbENhc2UocHJvcE5hbWUpO1xuICAgIH1cbiAgICBub3JtYWxpemVBbmltYXRpb25TdHlsZVZhbHVlKGNhbWVsQ2FzZVByb3AsIHVzZXJQcm92aWRlZFByb3AsIHZhbCkge1xuICAgICAgICBsZXQgdW5pdCA9ICcnO1xuICAgICAgICBjb25zdCBzdHJWYWwgPSB2YWwudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIGxldCBlcnJvck1zZyA9IG51bGw7XG4gICAgICAgIGlmIChfaXNQaXhlbERpbWVuc2lvblN0eWxlKGNhbWVsQ2FzZVByb3ApICYmIHZhbCAhPT0gMCAmJiB2YWwgIT09ICcwJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxBbmRTdWZmaXhNYXRjaCA9IHZhbC5tYXRjaCgvXlsrLV0/W1xcZFxcLl0rKFthLXpdKikkLyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbEFuZFN1ZmZpeE1hdGNoICYmIHZhbEFuZFN1ZmZpeE1hdGNoWzFdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTXNnID0gYFBsZWFzZSBwcm92aWRlIGEgQ1NTIHVuaXQgdmFsdWUgZm9yICR7dXNlclByb3ZpZGVkUHJvcH06JHt2YWx9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVycm9yTXNnLCB2YWx1ZTogc3RyVmFsICsgdW5pdCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9pc1BpeGVsRGltZW5zaW9uU3R5bGUocHJvcCkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgIGNhc2UgJ21pbldpZHRoJzpcbiAgICAgICAgY2FzZSAnbWluSGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWF4V2lkdGgnOlxuICAgICAgICBjYXNlICdtYXhIZWlnaHQnOlxuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBjYXNlICdmb250U2l6ZSc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVXaWR0aCc6XG4gICAgICAgIGNhc2UgJ291dGxpbmVPZmZzZXQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nVG9wJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ0xlZnQnOlxuICAgICAgICBjYXNlICdwYWRkaW5nQm90dG9tJzpcbiAgICAgICAgY2FzZSAncGFkZGluZ1JpZ2h0JzpcbiAgICAgICAgY2FzZSAnbWFyZ2luVG9wJzpcbiAgICAgICAgY2FzZSAnbWFyZ2luTGVmdCc6XG4gICAgICAgIGNhc2UgJ21hcmdpbkJvdHRvbSc6XG4gICAgICAgIGNhc2UgJ21hcmdpblJpZ2h0JzpcbiAgICAgICAgY2FzZSAnYm9yZGVyUmFkaXVzJzpcbiAgICAgICAgY2FzZSAnYm9yZGVyV2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJUb3BXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlckxlZnRXaWR0aCc6XG4gICAgICAgIGNhc2UgJ2JvcmRlclJpZ2h0V2lkdGgnOlxuICAgICAgICBjYXNlICdib3JkZXJCb3R0b21XaWR0aCc6XG4gICAgICAgIGNhc2UgJ3RleHRJbmRlbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5jbGFzcyBIdG1sVGFnRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBjbG9zZWRCeUNoaWxkcmVuLCBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeCwgY29udGVudFR5cGUgPSBUYWdDb250ZW50VHlwZS5QQVJTQUJMRV9EQVRBLCBjbG9zZWRCeVBhcmVudCA9IGZhbHNlLCBpc1ZvaWQgPSBmYWxzZSwgaWdub3JlRmlyc3RMZiA9IGZhbHNlLCBwcmV2ZW50TmFtZXNwYWNlSW5oZXJpdGFuY2UgPSBmYWxzZSwgY2FuU2VsZkNsb3NlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5Q2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jbG9zZWRCeVBhcmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoY2xvc2VkQnlDaGlsZHJlbiAmJiBjbG9zZWRCeUNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW4uZm9yRWFjaCh0YWdOYW1lID0+IHRoaXMuY2xvc2VkQnlDaGlsZHJlblt0YWdOYW1lXSA9IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNWb2lkID0gaXNWb2lkO1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gY2xvc2VkQnlQYXJlbnQgfHwgaXNWb2lkO1xuICAgICAgICB0aGlzLmltcGxpY2l0TmFtZXNwYWNlUHJlZml4ID0gaW1wbGljaXROYW1lc3BhY2VQcmVmaXggfHwgbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICB0aGlzLmlnbm9yZUZpcnN0TGYgPSBpZ25vcmVGaXJzdExmO1xuICAgICAgICB0aGlzLnByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZSA9IHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZTtcbiAgICAgICAgdGhpcy5jYW5TZWxmQ2xvc2UgPSBjYW5TZWxmQ2xvc2UgPz8gaXNWb2lkO1xuICAgIH1cbiAgICBpc0Nsb3NlZEJ5Q2hpbGQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZvaWQgfHwgbmFtZS50b0xvd2VyQ2FzZSgpIGluIHRoaXMuY2xvc2VkQnlDaGlsZHJlbjtcbiAgICB9XG4gICAgZ2V0Q29udGVudFR5cGUocHJlZml4KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5jb250ZW50VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlVHlwZSA9IHByZWZpeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50VHlwZVtwcmVmaXhdO1xuICAgICAgICAgICAgcmV0dXJuIG92ZXJyaWRlVHlwZSA/PyB0aGlzLmNvbnRlbnRUeXBlLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFR5cGU7XG4gICAgfVxufVxubGV0IERFRkFVTFRfVEFHX0RFRklOSVRJT047XG4vLyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNvcHRpb25hbC10YWdzXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IGZ1bGx5IGNvbmZvcm0gdG8gdGhlIEhUTUw1IHNwZWMuXG5sZXQgVEFHX0RFRklOSVRJT05TO1xuZnVuY3Rpb24gZ2V0SHRtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIGlmICghVEFHX0RFRklOSVRJT05TKSB7XG4gICAgICAgIERFRkFVTFRfVEFHX0RFRklOSVRJT04gPSBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjYW5TZWxmQ2xvc2U6IHRydWUgfSk7XG4gICAgICAgIFRBR19ERUZJTklUSU9OUyA9IHtcbiAgICAgICAgICAgICdiYXNlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ21ldGEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnYXJlYSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdlbWJlZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdsaW5rJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ2ltZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdpbnB1dCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdwYXJhbSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdocic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdicic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlzVm9pZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdzb3VyY2UnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAndHJhY2snOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnd2JyJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaXNWb2lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3AnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIGNsb3NlZEJ5Q2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdibG9ja3F1b3RlJywgJ2RpdicsICdkbCcsICdmaWVsZHNldCcsXG4gICAgICAgICAgICAgICAgICAgICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsXG4gICAgICAgICAgICAgICAgICAgICdoNicsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ21haW4nLCAnbmF2JywgJ29sJyxcbiAgICAgICAgICAgICAgICAgICAgJ3AnLCAncHJlJywgJ3NlY3Rpb24nLCAndGFibGUnLCAndWwnXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBjbG9zZWRCeVBhcmVudDogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGhlYWQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10gfSksXG4gICAgICAgICAgICAndGJvZHknOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3Rib2R5JywgJ3Rmb290J10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3Rmb290JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0Ym9keSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICd0cic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsndHInXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAndGQnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3RkJywgJ3RoJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3RoJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWyd0ZCcsICd0aCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdjb2wnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpc1ZvaWQ6IHRydWUgfSksXG4gICAgICAgICAgICAnc3ZnJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgaW1wbGljaXROYW1lc3BhY2VQcmVmaXg6ICdzdmcnIH0pLFxuICAgICAgICAgICAgJ2ZvcmVpZ25PYmplY3QnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oe1xuICAgICAgICAgICAgICAgIC8vIFVzdWFsbHkgdGhlIGltcGxpY2l0IG5hbWVzcGFjZSBoZXJlIHdvdWxkIGJlIHJlZHVuZGFudCBzaW5jZSBpdCB3aWxsIGJlIGluaGVyaXRlZCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcmVudCBgc3ZnYCwgYnV0IHdlIGhhdmUgdG8gZG8gaXQgZm9yIGBmb3JlaWduT2JqZWN0YCwgYmVjYXVzZSB0aGUgd2F5IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBpcyB0aGF0IHRoZSBwYXJlbnQgbm9kZSBvZiBhbiBlbmQgdGFnIGlzIGl0cyBvd24gc3RhcnQgdGFnIHdoaWNoIG1lYW5zIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgYHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZWAgb24gYGZvcmVpZ25PYmplY3RgIHdvdWxkIGhhdmUgaXQgZGVmYXVsdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbXBsaWNpdCBuYW1lc3BhY2Ugd2hpY2ggaXMgYGh0bWxgLCB1bmxlc3Mgc3BlY2lmaWVkIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAgICBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ3N2ZycsXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBwcmV2ZW50IGNoaWxkcmVuIG9mIGZvcmVpZ25PYmplY3QgZnJvbSBpbmhlcml0aW5nIGl0cyBuYW1lc3BhY2UsIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgcG9pbnQgb2YgdGhlIGVsZW1lbnQgaXMgdG8gYWxsb3cgbm9kZXMgZnJvbSBvdGhlciBuYW1lc3BhY2VzIHRvIGJlIGluc2VydGVkLlxuICAgICAgICAgICAgICAgIHByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ21hdGgnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBpbXBsaWNpdE5hbWVzcGFjZVByZWZpeDogJ21hdGgnIH0pLFxuICAgICAgICAgICAgJ2xpJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydsaSddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdkdCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSB9KSxcbiAgICAgICAgICAgICdkZCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnZHQnLCAnZGQnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAncmInOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ3JiJywgJ3J0JywgJ3J0YycsICdycCddLCBjbG9zZWRCeVBhcmVudDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICdydCc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnQnLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3J0Yyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsncmInLCAncnRjJywgJ3JwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3JwJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY2xvc2VkQnlDaGlsZHJlbjogWydyYicsICdydCcsICdydGMnLCAncnAnXSwgY2xvc2VkQnlQYXJlbnQ6IHRydWUgfSksXG4gICAgICAgICAgICAnb3B0Z3JvdXAnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjbG9zZWRCeUNoaWxkcmVuOiBbJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ29wdGlvbic6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNsb3NlZEJ5Q2hpbGRyZW46IFsnb3B0aW9uJywgJ29wdGdyb3VwJ10sIGNsb3NlZEJ5UGFyZW50OiB0cnVlIH0pLFxuICAgICAgICAgICAgJ3ByZSc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnbGlzdGluZyc6IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGlnbm9yZUZpcnN0TGY6IHRydWUgfSksXG4gICAgICAgICAgICAnc3R5bGUnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuUkFXX1RFWFQgfSksXG4gICAgICAgICAgICAnc2NyaXB0JzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHsgY29udGVudFR5cGU6IFRhZ0NvbnRlbnRUeXBlLlJBV19URVhUIH0pLFxuICAgICAgICAgICAgJ3RpdGxlJzogbmV3IEh0bWxUYWdEZWZpbml0aW9uKHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYnJvd3NlciBzdXBwb3J0cyB0d28gc2VwYXJhdGUgYHRpdGxlYCB0YWdzIHdoaWNoIGhhdmUgdG8gdXNlXG4gICAgICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgY29udGVudCB0eXBlOiBgSFRNTFRpdGxlRWxlbWVudGAgYW5kIGBTVkdUaXRsZUVsZW1lbnRgXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IHsgZGVmYXVsdDogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBzdmc6IFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEEgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAndGV4dGFyZWEnOiBuZXcgSHRtbFRhZ0RlZmluaXRpb24oeyBjb250ZW50VHlwZTogVGFnQ29udGVudFR5cGUuRVNDQVBBQkxFX1JBV19URVhULCBpZ25vcmVGaXJzdExmOiB0cnVlIH0pLFxuICAgICAgICB9O1xuICAgICAgICBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCkuYWxsS25vd25FbGVtZW50TmFtZXMoKS5mb3JFYWNoKGtub3duVGFnTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoIVRBR19ERUZJTklUSU9OUy5oYXNPd25Qcm9wZXJ0eShrbm93blRhZ05hbWUpICYmIGdldE5zUHJlZml4KGtub3duVGFnTmFtZSkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBUQUdfREVGSU5JVElPTlNba25vd25UYWdOYW1lXSA9IG5ldyBIdG1sVGFnRGVmaW5pdGlvbih7IGNhblNlbGZDbG9zZTogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBXZSBoYXZlIHRvIG1ha2UgYm90aCBhIGNhc2Utc2Vuc2l0aXZlIGFuZCBhIGNhc2UtaW5zZW5zaXRpdmUgbG9va3VwLCBiZWNhdXNlXG4gICAgLy8gSFRNTCB0YWcgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUsIHdoZXJlYXMgc29tZSBTVkcgdGFncyBhcmUgY2FzZSBzZW5zaXRpdmUuXG4gICAgcmV0dXJuIFRBR19ERUZJTklUSU9OU1t0YWdOYW1lXSA/PyBUQUdfREVGSU5JVElPTlNbdGFnTmFtZS50b0xvd2VyQ2FzZSgpXSA/P1xuICAgICAgICBERUZBVUxUX1RBR19ERUZJTklUSU9OO1xufVxuXG4vLyBNYXBwaW5nIGJldHdlZW4gYWxsIEhUTUwgZW50aXR5IG5hbWVzIGFuZCB0aGVpciB1bmljb2RlIHJlcHJlc2VudGF0aW9uLlxuLy8gR2VuZXJhdGVkIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZW50aXRpZXMuanNvbiBieSBzdHJpcHBpbmdcbi8vIHRoZSBgJmAgYW5kIGA7YCBmcm9tIHRoZSBrZXlzIGFuZCByZW1vdmluZyB0aGUgZHVwbGljYXRlcy5cbi8vIHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUxL3N5bnRheC5odG1sI25hbWVkLWNoYXJhY3Rlci1yZWZlcmVuY2VzXG5jb25zdCBOQU1FRF9FTlRJVElFUyA9IHtcbiAgICAnQUVsaWcnOiAnXFx1MDBDNicsXG4gICAgJ0FNUCc6ICdcXHUwMDI2JyxcbiAgICAnYW1wJzogJ1xcdTAwMjYnLFxuICAgICdBYWN1dGUnOiAnXFx1MDBDMScsXG4gICAgJ0FicmV2ZSc6ICdcXHUwMTAyJyxcbiAgICAnQWNpcmMnOiAnXFx1MDBDMicsXG4gICAgJ0FjeSc6ICdcXHUwNDEwJyxcbiAgICAnQWZyJzogJ1xcdUQ4MzVcXHVERDA0JyxcbiAgICAnQWdyYXZlJzogJ1xcdTAwQzAnLFxuICAgICdBbHBoYSc6ICdcXHUwMzkxJyxcbiAgICAnQW1hY3InOiAnXFx1MDEwMCcsXG4gICAgJ0FuZCc6ICdcXHUyQTUzJyxcbiAgICAnQW9nb24nOiAnXFx1MDEwNCcsXG4gICAgJ0FvcGYnOiAnXFx1RDgzNVxcdUREMzgnLFxuICAgICdBcHBseUZ1bmN0aW9uJzogJ1xcdTIwNjEnLFxuICAgICdhZic6ICdcXHUyMDYxJyxcbiAgICAnQXJpbmcnOiAnXFx1MDBDNScsXG4gICAgJ2FuZ3N0JzogJ1xcdTAwQzUnLFxuICAgICdBc2NyJzogJ1xcdUQ4MzVcXHVEQzlDJyxcbiAgICAnQXNzaWduJzogJ1xcdTIyNTQnLFxuICAgICdjb2xvbmUnOiAnXFx1MjI1NCcsXG4gICAgJ2NvbG9uZXEnOiAnXFx1MjI1NCcsXG4gICAgJ0F0aWxkZSc6ICdcXHUwMEMzJyxcbiAgICAnQXVtbCc6ICdcXHUwMEM0JyxcbiAgICAnQmFja3NsYXNoJzogJ1xcdTIyMTYnLFxuICAgICdzZXRtaW51cyc6ICdcXHUyMjE2JyxcbiAgICAnc2V0bW4nOiAnXFx1MjIxNicsXG4gICAgJ3NtYWxsc2V0bWludXMnOiAnXFx1MjIxNicsXG4gICAgJ3NzZXRtbic6ICdcXHUyMjE2JyxcbiAgICAnQmFydic6ICdcXHUyQUU3JyxcbiAgICAnQmFyd2VkJzogJ1xcdTIzMDYnLFxuICAgICdkb3VibGViYXJ3ZWRnZSc6ICdcXHUyMzA2JyxcbiAgICAnQmN5JzogJ1xcdTA0MTEnLFxuICAgICdCZWNhdXNlJzogJ1xcdTIyMzUnLFxuICAgICdiZWNhdXMnOiAnXFx1MjIzNScsXG4gICAgJ2JlY2F1c2UnOiAnXFx1MjIzNScsXG4gICAgJ0Jlcm5vdWxsaXMnOiAnXFx1MjEyQycsXG4gICAgJ0JzY3InOiAnXFx1MjEyQycsXG4gICAgJ2Jlcm5vdSc6ICdcXHUyMTJDJyxcbiAgICAnQmV0YSc6ICdcXHUwMzkyJyxcbiAgICAnQmZyJzogJ1xcdUQ4MzVcXHVERDA1JyxcbiAgICAnQm9wZic6ICdcXHVEODM1XFx1REQzOScsXG4gICAgJ0JyZXZlJzogJ1xcdTAyRDgnLFxuICAgICdicmV2ZSc6ICdcXHUwMkQ4JyxcbiAgICAnQnVtcGVxJzogJ1xcdTIyNEUnLFxuICAgICdIdW1wRG93bkh1bXAnOiAnXFx1MjI0RScsXG4gICAgJ2J1bXAnOiAnXFx1MjI0RScsXG4gICAgJ0NIY3knOiAnXFx1MDQyNycsXG4gICAgJ0NPUFknOiAnXFx1MDBBOScsXG4gICAgJ2NvcHknOiAnXFx1MDBBOScsXG4gICAgJ0NhY3V0ZSc6ICdcXHUwMTA2JyxcbiAgICAnQ2FwJzogJ1xcdTIyRDInLFxuICAgICdDYXBpdGFsRGlmZmVyZW50aWFsRCc6ICdcXHUyMTQ1JyxcbiAgICAnREQnOiAnXFx1MjE0NScsXG4gICAgJ0NheWxleXMnOiAnXFx1MjEyRCcsXG4gICAgJ0Nmcic6ICdcXHUyMTJEJyxcbiAgICAnQ2Nhcm9uJzogJ1xcdTAxMEMnLFxuICAgICdDY2VkaWwnOiAnXFx1MDBDNycsXG4gICAgJ0NjaXJjJzogJ1xcdTAxMDgnLFxuICAgICdDY29uaW50JzogJ1xcdTIyMzAnLFxuICAgICdDZG90JzogJ1xcdTAxMEEnLFxuICAgICdDZWRpbGxhJzogJ1xcdTAwQjgnLFxuICAgICdjZWRpbCc6ICdcXHUwMEI4JyxcbiAgICAnQ2VudGVyRG90JzogJ1xcdTAwQjcnLFxuICAgICdjZW50ZXJkb3QnOiAnXFx1MDBCNycsXG4gICAgJ21pZGRvdCc6ICdcXHUwMEI3JyxcbiAgICAnQ2hpJzogJ1xcdTAzQTcnLFxuICAgICdDaXJjbGVEb3QnOiAnXFx1MjI5OScsXG4gICAgJ29kb3QnOiAnXFx1MjI5OScsXG4gICAgJ0NpcmNsZU1pbnVzJzogJ1xcdTIyOTYnLFxuICAgICdvbWludXMnOiAnXFx1MjI5NicsXG4gICAgJ0NpcmNsZVBsdXMnOiAnXFx1MjI5NScsXG4gICAgJ29wbHVzJzogJ1xcdTIyOTUnLFxuICAgICdDaXJjbGVUaW1lcyc6ICdcXHUyMjk3JyxcbiAgICAnb3RpbWVzJzogJ1xcdTIyOTcnLFxuICAgICdDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOiAnXFx1MjIzMicsXG4gICAgJ2N3Y29uaW50JzogJ1xcdTIyMzInLFxuICAgICdDbG9zZUN1cmx5RG91YmxlUXVvdGUnOiAnXFx1MjAxRCcsXG4gICAgJ3JkcXVvJzogJ1xcdTIwMUQnLFxuICAgICdyZHF1b3InOiAnXFx1MjAxRCcsXG4gICAgJ0Nsb3NlQ3VybHlRdW90ZSc6ICdcXHUyMDE5JyxcbiAgICAncnNxdW8nOiAnXFx1MjAxOScsXG4gICAgJ3JzcXVvcic6ICdcXHUyMDE5JyxcbiAgICAnQ29sb24nOiAnXFx1MjIzNycsXG4gICAgJ1Byb3BvcnRpb24nOiAnXFx1MjIzNycsXG4gICAgJ0NvbG9uZSc6ICdcXHUyQTc0JyxcbiAgICAnQ29uZ3J1ZW50JzogJ1xcdTIyNjEnLFxuICAgICdlcXVpdic6ICdcXHUyMjYxJyxcbiAgICAnQ29uaW50JzogJ1xcdTIyMkYnLFxuICAgICdEb3VibGVDb250b3VySW50ZWdyYWwnOiAnXFx1MjIyRicsXG4gICAgJ0NvbnRvdXJJbnRlZ3JhbCc6ICdcXHUyMjJFJyxcbiAgICAnY29uaW50JzogJ1xcdTIyMkUnLFxuICAgICdvaW50JzogJ1xcdTIyMkUnLFxuICAgICdDb3BmJzogJ1xcdTIxMDInLFxuICAgICdjb21wbGV4ZXMnOiAnXFx1MjEwMicsXG4gICAgJ0NvcHJvZHVjdCc6ICdcXHUyMjEwJyxcbiAgICAnY29wcm9kJzogJ1xcdTIyMTAnLFxuICAgICdDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzogJ1xcdTIyMzMnLFxuICAgICdhd2NvbmludCc6ICdcXHUyMjMzJyxcbiAgICAnQ3Jvc3MnOiAnXFx1MkEyRicsXG4gICAgJ0NzY3InOiAnXFx1RDgzNVxcdURDOUUnLFxuICAgICdDdXAnOiAnXFx1MjJEMycsXG4gICAgJ0N1cENhcCc6ICdcXHUyMjREJyxcbiAgICAnYXN5bXBlcSc6ICdcXHUyMjREJyxcbiAgICAnRERvdHJhaGQnOiAnXFx1MjkxMScsXG4gICAgJ0RKY3knOiAnXFx1MDQwMicsXG4gICAgJ0RTY3knOiAnXFx1MDQwNScsXG4gICAgJ0RaY3knOiAnXFx1MDQwRicsXG4gICAgJ0RhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnZGRhZ2dlcic6ICdcXHUyMDIxJyxcbiAgICAnRGFycic6ICdcXHUyMUExJyxcbiAgICAnRGFzaHYnOiAnXFx1MkFFNCcsXG4gICAgJ0RvdWJsZUxlZnRUZWUnOiAnXFx1MkFFNCcsXG4gICAgJ0RjYXJvbic6ICdcXHUwMTBFJyxcbiAgICAnRGN5JzogJ1xcdTA0MTQnLFxuICAgICdEZWwnOiAnXFx1MjIwNycsXG4gICAgJ25hYmxhJzogJ1xcdTIyMDcnLFxuICAgICdEZWx0YSc6ICdcXHUwMzk0JyxcbiAgICAnRGZyJzogJ1xcdUQ4MzVcXHVERDA3JyxcbiAgICAnRGlhY3JpdGljYWxBY3V0ZSc6ICdcXHUwMEI0JyxcbiAgICAnYWN1dGUnOiAnXFx1MDBCNCcsXG4gICAgJ0RpYWNyaXRpY2FsRG90JzogJ1xcdTAyRDknLFxuICAgICdkb3QnOiAnXFx1MDJEOScsXG4gICAgJ0RpYWNyaXRpY2FsRG91YmxlQWN1dGUnOiAnXFx1MDJERCcsXG4gICAgJ2RibGFjJzogJ1xcdTAyREQnLFxuICAgICdEaWFjcml0aWNhbEdyYXZlJzogJ1xcdTAwNjAnLFxuICAgICdncmF2ZSc6ICdcXHUwMDYwJyxcbiAgICAnRGlhY3JpdGljYWxUaWxkZSc6ICdcXHUwMkRDJyxcbiAgICAndGlsZGUnOiAnXFx1MDJEQycsXG4gICAgJ0RpYW1vbmQnOiAnXFx1MjJDNCcsXG4gICAgJ2RpYW0nOiAnXFx1MjJDNCcsXG4gICAgJ2RpYW1vbmQnOiAnXFx1MjJDNCcsXG4gICAgJ0RpZmZlcmVudGlhbEQnOiAnXFx1MjE0NicsXG4gICAgJ2RkJzogJ1xcdTIxNDYnLFxuICAgICdEb3BmJzogJ1xcdUQ4MzVcXHVERDNCJyxcbiAgICAnRG90JzogJ1xcdTAwQTgnLFxuICAgICdEb3VibGVEb3QnOiAnXFx1MDBBOCcsXG4gICAgJ2RpZSc6ICdcXHUwMEE4JyxcbiAgICAndW1sJzogJ1xcdTAwQTgnLFxuICAgICdEb3REb3QnOiAnXFx1MjBEQycsXG4gICAgJ0RvdEVxdWFsJzogJ1xcdTIyNTAnLFxuICAgICdkb3RlcSc6ICdcXHUyMjUwJyxcbiAgICAnZXNkb3QnOiAnXFx1MjI1MCcsXG4gICAgJ0RvdWJsZURvd25BcnJvdyc6ICdcXHUyMUQzJyxcbiAgICAnRG93bmFycm93JzogJ1xcdTIxRDMnLFxuICAgICdkQXJyJzogJ1xcdTIxRDMnLFxuICAgICdEb3VibGVMZWZ0QXJyb3cnOiAnXFx1MjFEMCcsXG4gICAgJ0xlZnRhcnJvdyc6ICdcXHUyMUQwJyxcbiAgICAnbEFycic6ICdcXHUyMUQwJyxcbiAgICAnRG91YmxlTGVmdFJpZ2h0QXJyb3cnOiAnXFx1MjFENCcsXG4gICAgJ0xlZnRyaWdodGFycm93JzogJ1xcdTIxRDQnLFxuICAgICdoQXJyJzogJ1xcdTIxRDQnLFxuICAgICdpZmYnOiAnXFx1MjFENCcsXG4gICAgJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnOiAnXFx1MjdGOCcsXG4gICAgJ0xvbmdsZWZ0YXJyb3cnOiAnXFx1MjdGOCcsXG4gICAgJ3hsQXJyJzogJ1xcdTI3RjgnLFxuICAgICdEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnOiAnXFx1MjdGQScsXG4gICAgJ0xvbmdsZWZ0cmlnaHRhcnJvdyc6ICdcXHUyN0ZBJyxcbiAgICAneGhBcnInOiAnXFx1MjdGQScsXG4gICAgJ0RvdWJsZUxvbmdSaWdodEFycm93JzogJ1xcdTI3RjknLFxuICAgICdMb25ncmlnaHRhcnJvdyc6ICdcXHUyN0Y5JyxcbiAgICAneHJBcnInOiAnXFx1MjdGOScsXG4gICAgJ0RvdWJsZVJpZ2h0QXJyb3cnOiAnXFx1MjFEMicsXG4gICAgJ0ltcGxpZXMnOiAnXFx1MjFEMicsXG4gICAgJ1JpZ2h0YXJyb3cnOiAnXFx1MjFEMicsXG4gICAgJ3JBcnInOiAnXFx1MjFEMicsXG4gICAgJ0RvdWJsZVJpZ2h0VGVlJzogJ1xcdTIyQTgnLFxuICAgICd2RGFzaCc6ICdcXHUyMkE4JyxcbiAgICAnRG91YmxlVXBBcnJvdyc6ICdcXHUyMUQxJyxcbiAgICAnVXBhcnJvdyc6ICdcXHUyMUQxJyxcbiAgICAndUFycic6ICdcXHUyMUQxJyxcbiAgICAnRG91YmxlVXBEb3duQXJyb3cnOiAnXFx1MjFENScsXG4gICAgJ1VwZG93bmFycm93JzogJ1xcdTIxRDUnLFxuICAgICd2QXJyJzogJ1xcdTIxRDUnLFxuICAgICdEb3VibGVWZXJ0aWNhbEJhcic6ICdcXHUyMjI1JyxcbiAgICAncGFyJzogJ1xcdTIyMjUnLFxuICAgICdwYXJhbGxlbCc6ICdcXHUyMjI1JyxcbiAgICAnc2hvcnRwYXJhbGxlbCc6ICdcXHUyMjI1JyxcbiAgICAnc3Bhcic6ICdcXHUyMjI1JyxcbiAgICAnRG93bkFycm93JzogJ1xcdTIxOTMnLFxuICAgICdTaG9ydERvd25BcnJvdyc6ICdcXHUyMTkzJyxcbiAgICAnZGFycic6ICdcXHUyMTkzJyxcbiAgICAnZG93bmFycm93JzogJ1xcdTIxOTMnLFxuICAgICdEb3duQXJyb3dCYXInOiAnXFx1MjkxMycsXG4gICAgJ0Rvd25BcnJvd1VwQXJyb3cnOiAnXFx1MjFGNScsXG4gICAgJ2R1YXJyJzogJ1xcdTIxRjUnLFxuICAgICdEb3duQnJldmUnOiAnXFx1MDMxMScsXG4gICAgJ0Rvd25MZWZ0UmlnaHRWZWN0b3InOiAnXFx1Mjk1MCcsXG4gICAgJ0Rvd25MZWZ0VGVlVmVjdG9yJzogJ1xcdTI5NUUnLFxuICAgICdEb3duTGVmdFZlY3Rvcic6ICdcXHUyMUJEJyxcbiAgICAnbGVmdGhhcnBvb25kb3duJzogJ1xcdTIxQkQnLFxuICAgICdsaGFyZCc6ICdcXHUyMUJEJyxcbiAgICAnRG93bkxlZnRWZWN0b3JCYXInOiAnXFx1Mjk1NicsXG4gICAgJ0Rvd25SaWdodFRlZVZlY3Rvcic6ICdcXHUyOTVGJyxcbiAgICAnRG93blJpZ2h0VmVjdG9yJzogJ1xcdTIxQzEnLFxuICAgICdyaGFyZCc6ICdcXHUyMUMxJyxcbiAgICAncmlnaHRoYXJwb29uZG93bic6ICdcXHUyMUMxJyxcbiAgICAnRG93blJpZ2h0VmVjdG9yQmFyJzogJ1xcdTI5NTcnLFxuICAgICdEb3duVGVlJzogJ1xcdTIyQTQnLFxuICAgICd0b3AnOiAnXFx1MjJBNCcsXG4gICAgJ0Rvd25UZWVBcnJvdyc6ICdcXHUyMUE3JyxcbiAgICAnbWFwc3RvZG93bic6ICdcXHUyMUE3JyxcbiAgICAnRHNjcic6ICdcXHVEODM1XFx1REM5RicsXG4gICAgJ0RzdHJvayc6ICdcXHUwMTEwJyxcbiAgICAnRU5HJzogJ1xcdTAxNEEnLFxuICAgICdFVEgnOiAnXFx1MDBEMCcsXG4gICAgJ0VhY3V0ZSc6ICdcXHUwMEM5JyxcbiAgICAnRWNhcm9uJzogJ1xcdTAxMUEnLFxuICAgICdFY2lyYyc6ICdcXHUwMENBJyxcbiAgICAnRWN5JzogJ1xcdTA0MkQnLFxuICAgICdFZG90JzogJ1xcdTAxMTYnLFxuICAgICdFZnInOiAnXFx1RDgzNVxcdUREMDgnLFxuICAgICdFZ3JhdmUnOiAnXFx1MDBDOCcsXG4gICAgJ0VsZW1lbnQnOiAnXFx1MjIwOCcsXG4gICAgJ2luJzogJ1xcdTIyMDgnLFxuICAgICdpc2luJzogJ1xcdTIyMDgnLFxuICAgICdpc2ludic6ICdcXHUyMjA4JyxcbiAgICAnRW1hY3InOiAnXFx1MDExMicsXG4gICAgJ0VtcHR5U21hbGxTcXVhcmUnOiAnXFx1MjVGQicsXG4gICAgJ0VtcHR5VmVyeVNtYWxsU3F1YXJlJzogJ1xcdTI1QUInLFxuICAgICdFb2dvbic6ICdcXHUwMTE4JyxcbiAgICAnRW9wZic6ICdcXHVEODM1XFx1REQzQycsXG4gICAgJ0Vwc2lsb24nOiAnXFx1MDM5NScsXG4gICAgJ0VxdWFsJzogJ1xcdTJBNzUnLFxuICAgICdFcXVhbFRpbGRlJzogJ1xcdTIyNDInLFxuICAgICdlcXNpbSc6ICdcXHUyMjQyJyxcbiAgICAnZXNpbSc6ICdcXHUyMjQyJyxcbiAgICAnRXF1aWxpYnJpdW0nOiAnXFx1MjFDQycsXG4gICAgJ3JpZ2h0bGVmdGhhcnBvb25zJzogJ1xcdTIxQ0MnLFxuICAgICdybGhhcic6ICdcXHUyMUNDJyxcbiAgICAnRXNjcic6ICdcXHUyMTMwJyxcbiAgICAnZXhwZWN0YXRpb24nOiAnXFx1MjEzMCcsXG4gICAgJ0VzaW0nOiAnXFx1MkE3MycsXG4gICAgJ0V0YSc6ICdcXHUwMzk3JyxcbiAgICAnRXVtbCc6ICdcXHUwMENCJyxcbiAgICAnRXhpc3RzJzogJ1xcdTIyMDMnLFxuICAgICdleGlzdCc6ICdcXHUyMjAzJyxcbiAgICAnRXhwb25lbnRpYWxFJzogJ1xcdTIxNDcnLFxuICAgICdlZSc6ICdcXHUyMTQ3JyxcbiAgICAnZXhwb25lbnRpYWxlJzogJ1xcdTIxNDcnLFxuICAgICdGY3knOiAnXFx1MDQyNCcsXG4gICAgJ0Zmcic6ICdcXHVEODM1XFx1REQwOScsXG4gICAgJ0ZpbGxlZFNtYWxsU3F1YXJlJzogJ1xcdTI1RkMnLFxuICAgICdGaWxsZWRWZXJ5U21hbGxTcXVhcmUnOiAnXFx1MjVBQScsXG4gICAgJ2JsYWNrc3F1YXJlJzogJ1xcdTI1QUEnLFxuICAgICdzcXVhcmYnOiAnXFx1MjVBQScsXG4gICAgJ3NxdWYnOiAnXFx1MjVBQScsXG4gICAgJ0ZvcGYnOiAnXFx1RDgzNVxcdUREM0QnLFxuICAgICdGb3JBbGwnOiAnXFx1MjIwMCcsXG4gICAgJ2ZvcmFsbCc6ICdcXHUyMjAwJyxcbiAgICAnRm91cmllcnRyZic6ICdcXHUyMTMxJyxcbiAgICAnRnNjcic6ICdcXHUyMTMxJyxcbiAgICAnR0pjeSc6ICdcXHUwNDAzJyxcbiAgICAnR1QnOiAnXFx1MDAzRScsXG4gICAgJ2d0JzogJ1xcdTAwM0UnLFxuICAgICdHYW1tYSc6ICdcXHUwMzkzJyxcbiAgICAnR2FtbWFkJzogJ1xcdTAzREMnLFxuICAgICdHYnJldmUnOiAnXFx1MDExRScsXG4gICAgJ0djZWRpbCc6ICdcXHUwMTIyJyxcbiAgICAnR2NpcmMnOiAnXFx1MDExQycsXG4gICAgJ0djeSc6ICdcXHUwNDEzJyxcbiAgICAnR2RvdCc6ICdcXHUwMTIwJyxcbiAgICAnR2ZyJzogJ1xcdUQ4MzVcXHVERDBBJyxcbiAgICAnR2cnOiAnXFx1MjJEOScsXG4gICAgJ2dnZyc6ICdcXHUyMkQ5JyxcbiAgICAnR29wZic6ICdcXHVEODM1XFx1REQzRScsXG4gICAgJ0dyZWF0ZXJFcXVhbCc6ICdcXHUyMjY1JyxcbiAgICAnZ2UnOiAnXFx1MjI2NScsXG4gICAgJ2dlcSc6ICdcXHUyMjY1JyxcbiAgICAnR3JlYXRlckVxdWFsTGVzcyc6ICdcXHUyMkRCJyxcbiAgICAnZ2VsJzogJ1xcdTIyREInLFxuICAgICdndHJlcWxlc3MnOiAnXFx1MjJEQicsXG4gICAgJ0dyZWF0ZXJGdWxsRXF1YWwnOiAnXFx1MjI2NycsXG4gICAgJ2dFJzogJ1xcdTIyNjcnLFxuICAgICdnZXFxJzogJ1xcdTIyNjcnLFxuICAgICdHcmVhdGVyR3JlYXRlcic6ICdcXHUyQUEyJyxcbiAgICAnR3JlYXRlckxlc3MnOiAnXFx1MjI3NycsXG4gICAgJ2dsJzogJ1xcdTIyNzcnLFxuICAgICdndHJsZXNzJzogJ1xcdTIyNzcnLFxuICAgICdHcmVhdGVyU2xhbnRFcXVhbCc6ICdcXHUyQTdFJyxcbiAgICAnZ2Vxc2xhbnQnOiAnXFx1MkE3RScsXG4gICAgJ2dlcyc6ICdcXHUyQTdFJyxcbiAgICAnR3JlYXRlclRpbGRlJzogJ1xcdTIyNzMnLFxuICAgICdnc2ltJzogJ1xcdTIyNzMnLFxuICAgICdndHJzaW0nOiAnXFx1MjI3MycsXG4gICAgJ0dzY3InOiAnXFx1RDgzNVxcdURDQTInLFxuICAgICdHdCc6ICdcXHUyMjZCJyxcbiAgICAnTmVzdGVkR3JlYXRlckdyZWF0ZXInOiAnXFx1MjI2QicsXG4gICAgJ2dnJzogJ1xcdTIyNkInLFxuICAgICdIQVJEY3knOiAnXFx1MDQyQScsXG4gICAgJ0hhY2VrJzogJ1xcdTAyQzcnLFxuICAgICdjYXJvbic6ICdcXHUwMkM3JyxcbiAgICAnSGF0JzogJ1xcdTAwNUUnLFxuICAgICdIY2lyYyc6ICdcXHUwMTI0JyxcbiAgICAnSGZyJzogJ1xcdTIxMEMnLFxuICAgICdQb2luY2FyZXBsYW5lJzogJ1xcdTIxMEMnLFxuICAgICdIaWxiZXJ0U3BhY2UnOiAnXFx1MjEwQicsXG4gICAgJ0hzY3InOiAnXFx1MjEwQicsXG4gICAgJ2hhbWlsdCc6ICdcXHUyMTBCJyxcbiAgICAnSG9wZic6ICdcXHUyMTBEJyxcbiAgICAncXVhdGVybmlvbnMnOiAnXFx1MjEwRCcsXG4gICAgJ0hvcml6b250YWxMaW5lJzogJ1xcdTI1MDAnLFxuICAgICdib3hoJzogJ1xcdTI1MDAnLFxuICAgICdIc3Ryb2snOiAnXFx1MDEyNicsXG4gICAgJ0h1bXBFcXVhbCc6ICdcXHUyMjRGJyxcbiAgICAnYnVtcGUnOiAnXFx1MjI0RicsXG4gICAgJ2J1bXBlcSc6ICdcXHUyMjRGJyxcbiAgICAnSUVjeSc6ICdcXHUwNDE1JyxcbiAgICAnSUpsaWcnOiAnXFx1MDEzMicsXG4gICAgJ0lPY3knOiAnXFx1MDQwMScsXG4gICAgJ0lhY3V0ZSc6ICdcXHUwMENEJyxcbiAgICAnSWNpcmMnOiAnXFx1MDBDRScsXG4gICAgJ0ljeSc6ICdcXHUwNDE4JyxcbiAgICAnSWRvdCc6ICdcXHUwMTMwJyxcbiAgICAnSWZyJzogJ1xcdTIxMTEnLFxuICAgICdJbSc6ICdcXHUyMTExJyxcbiAgICAnaW1hZ2UnOiAnXFx1MjExMScsXG4gICAgJ2ltYWdwYXJ0JzogJ1xcdTIxMTEnLFxuICAgICdJZ3JhdmUnOiAnXFx1MDBDQycsXG4gICAgJ0ltYWNyJzogJ1xcdTAxMkEnLFxuICAgICdJbWFnaW5hcnlJJzogJ1xcdTIxNDgnLFxuICAgICdpaSc6ICdcXHUyMTQ4JyxcbiAgICAnSW50JzogJ1xcdTIyMkMnLFxuICAgICdJbnRlZ3JhbCc6ICdcXHUyMjJCJyxcbiAgICAnaW50JzogJ1xcdTIyMkInLFxuICAgICdJbnRlcnNlY3Rpb24nOiAnXFx1MjJDMicsXG4gICAgJ2JpZ2NhcCc6ICdcXHUyMkMyJyxcbiAgICAneGNhcCc6ICdcXHUyMkMyJyxcbiAgICAnSW52aXNpYmxlQ29tbWEnOiAnXFx1MjA2MycsXG4gICAgJ2ljJzogJ1xcdTIwNjMnLFxuICAgICdJbnZpc2libGVUaW1lcyc6ICdcXHUyMDYyJyxcbiAgICAnaXQnOiAnXFx1MjA2MicsXG4gICAgJ0lvZ29uJzogJ1xcdTAxMkUnLFxuICAgICdJb3BmJzogJ1xcdUQ4MzVcXHVERDQwJyxcbiAgICAnSW90YSc6ICdcXHUwMzk5JyxcbiAgICAnSXNjcic6ICdcXHUyMTEwJyxcbiAgICAnaW1hZ2xpbmUnOiAnXFx1MjExMCcsXG4gICAgJ0l0aWxkZSc6ICdcXHUwMTI4JyxcbiAgICAnSXVrY3knOiAnXFx1MDQwNicsXG4gICAgJ0l1bWwnOiAnXFx1MDBDRicsXG4gICAgJ0pjaXJjJzogJ1xcdTAxMzQnLFxuICAgICdKY3knOiAnXFx1MDQxOScsXG4gICAgJ0pmcic6ICdcXHVEODM1XFx1REQwRCcsXG4gICAgJ0pvcGYnOiAnXFx1RDgzNVxcdURENDEnLFxuICAgICdKc2NyJzogJ1xcdUQ4MzVcXHVEQ0E1JyxcbiAgICAnSnNlcmN5JzogJ1xcdTA0MDgnLFxuICAgICdKdWtjeSc6ICdcXHUwNDA0JyxcbiAgICAnS0hjeSc6ICdcXHUwNDI1JyxcbiAgICAnS0pjeSc6ICdcXHUwNDBDJyxcbiAgICAnS2FwcGEnOiAnXFx1MDM5QScsXG4gICAgJ0tjZWRpbCc6ICdcXHUwMTM2JyxcbiAgICAnS2N5JzogJ1xcdTA0MUEnLFxuICAgICdLZnInOiAnXFx1RDgzNVxcdUREMEUnLFxuICAgICdLb3BmJzogJ1xcdUQ4MzVcXHVERDQyJyxcbiAgICAnS3Njcic6ICdcXHVEODM1XFx1RENBNicsXG4gICAgJ0xKY3knOiAnXFx1MDQwOScsXG4gICAgJ0xUJzogJ1xcdTAwM0MnLFxuICAgICdsdCc6ICdcXHUwMDNDJyxcbiAgICAnTGFjdXRlJzogJ1xcdTAxMzknLFxuICAgICdMYW1iZGEnOiAnXFx1MDM5QicsXG4gICAgJ0xhbmcnOiAnXFx1MjdFQScsXG4gICAgJ0xhcGxhY2V0cmYnOiAnXFx1MjExMicsXG4gICAgJ0xzY3InOiAnXFx1MjExMicsXG4gICAgJ2xhZ3Jhbic6ICdcXHUyMTEyJyxcbiAgICAnTGFycic6ICdcXHUyMTlFJyxcbiAgICAndHdvaGVhZGxlZnRhcnJvdyc6ICdcXHUyMTlFJyxcbiAgICAnTGNhcm9uJzogJ1xcdTAxM0QnLFxuICAgICdMY2VkaWwnOiAnXFx1MDEzQicsXG4gICAgJ0xjeSc6ICdcXHUwNDFCJyxcbiAgICAnTGVmdEFuZ2xlQnJhY2tldCc6ICdcXHUyN0U4JyxcbiAgICAnbGFuZyc6ICdcXHUyN0U4JyxcbiAgICAnbGFuZ2xlJzogJ1xcdTI3RTgnLFxuICAgICdMZWZ0QXJyb3cnOiAnXFx1MjE5MCcsXG4gICAgJ1Nob3J0TGVmdEFycm93JzogJ1xcdTIxOTAnLFxuICAgICdsYXJyJzogJ1xcdTIxOTAnLFxuICAgICdsZWZ0YXJyb3cnOiAnXFx1MjE5MCcsXG4gICAgJ3NsYXJyJzogJ1xcdTIxOTAnLFxuICAgICdMZWZ0QXJyb3dCYXInOiAnXFx1MjFFNCcsXG4gICAgJ2xhcnJiJzogJ1xcdTIxRTQnLFxuICAgICdMZWZ0QXJyb3dSaWdodEFycm93JzogJ1xcdTIxQzYnLFxuICAgICdsZWZ0cmlnaHRhcnJvd3MnOiAnXFx1MjFDNicsXG4gICAgJ2xyYXJyJzogJ1xcdTIxQzYnLFxuICAgICdMZWZ0Q2VpbGluZyc6ICdcXHUyMzA4JyxcbiAgICAnbGNlaWwnOiAnXFx1MjMwOCcsXG4gICAgJ0xlZnREb3VibGVCcmFja2V0JzogJ1xcdTI3RTYnLFxuICAgICdsb2Jyayc6ICdcXHUyN0U2JyxcbiAgICAnTGVmdERvd25UZWVWZWN0b3InOiAnXFx1Mjk2MScsXG4gICAgJ0xlZnREb3duVmVjdG9yJzogJ1xcdTIxQzMnLFxuICAgICdkaGFybCc6ICdcXHUyMUMzJyxcbiAgICAnZG93bmhhcnBvb25sZWZ0JzogJ1xcdTIxQzMnLFxuICAgICdMZWZ0RG93blZlY3RvckJhcic6ICdcXHUyOTU5JyxcbiAgICAnTGVmdEZsb29yJzogJ1xcdTIzMEEnLFxuICAgICdsZmxvb3InOiAnXFx1MjMwQScsXG4gICAgJ0xlZnRSaWdodEFycm93JzogJ1xcdTIxOTQnLFxuICAgICdoYXJyJzogJ1xcdTIxOTQnLFxuICAgICdsZWZ0cmlnaHRhcnJvdyc6ICdcXHUyMTk0JyxcbiAgICAnTGVmdFJpZ2h0VmVjdG9yJzogJ1xcdTI5NEUnLFxuICAgICdMZWZ0VGVlJzogJ1xcdTIyQTMnLFxuICAgICdkYXNodic6ICdcXHUyMkEzJyxcbiAgICAnTGVmdFRlZUFycm93JzogJ1xcdTIxQTQnLFxuICAgICdtYXBzdG9sZWZ0JzogJ1xcdTIxQTQnLFxuICAgICdMZWZ0VGVlVmVjdG9yJzogJ1xcdTI5NUEnLFxuICAgICdMZWZ0VHJpYW5nbGUnOiAnXFx1MjJCMicsXG4gICAgJ3ZhcnRyaWFuZ2xlbGVmdCc6ICdcXHUyMkIyJyxcbiAgICAndmx0cmknOiAnXFx1MjJCMicsXG4gICAgJ0xlZnRUcmlhbmdsZUJhcic6ICdcXHUyOUNGJyxcbiAgICAnTGVmdFRyaWFuZ2xlRXF1YWwnOiAnXFx1MjJCNCcsXG4gICAgJ2x0cmllJzogJ1xcdTIyQjQnLFxuICAgICd0cmlhbmdsZWxlZnRlcSc6ICdcXHUyMkI0JyxcbiAgICAnTGVmdFVwRG93blZlY3Rvcic6ICdcXHUyOTUxJyxcbiAgICAnTGVmdFVwVGVlVmVjdG9yJzogJ1xcdTI5NjAnLFxuICAgICdMZWZ0VXBWZWN0b3InOiAnXFx1MjFCRicsXG4gICAgJ3VoYXJsJzogJ1xcdTIxQkYnLFxuICAgICd1cGhhcnBvb25sZWZ0JzogJ1xcdTIxQkYnLFxuICAgICdMZWZ0VXBWZWN0b3JCYXInOiAnXFx1Mjk1OCcsXG4gICAgJ0xlZnRWZWN0b3InOiAnXFx1MjFCQycsXG4gICAgJ2xlZnRoYXJwb29udXAnOiAnXFx1MjFCQycsXG4gICAgJ2xoYXJ1JzogJ1xcdTIxQkMnLFxuICAgICdMZWZ0VmVjdG9yQmFyJzogJ1xcdTI5NTInLFxuICAgICdMZXNzRXF1YWxHcmVhdGVyJzogJ1xcdTIyREEnLFxuICAgICdsZWcnOiAnXFx1MjJEQScsXG4gICAgJ2xlc3NlcWd0cic6ICdcXHUyMkRBJyxcbiAgICAnTGVzc0Z1bGxFcXVhbCc6ICdcXHUyMjY2JyxcbiAgICAnbEUnOiAnXFx1MjI2NicsXG4gICAgJ2xlcXEnOiAnXFx1MjI2NicsXG4gICAgJ0xlc3NHcmVhdGVyJzogJ1xcdTIyNzYnLFxuICAgICdsZXNzZ3RyJzogJ1xcdTIyNzYnLFxuICAgICdsZyc6ICdcXHUyMjc2JyxcbiAgICAnTGVzc0xlc3MnOiAnXFx1MkFBMScsXG4gICAgJ0xlc3NTbGFudEVxdWFsJzogJ1xcdTJBN0QnLFxuICAgICdsZXFzbGFudCc6ICdcXHUyQTdEJyxcbiAgICAnbGVzJzogJ1xcdTJBN0QnLFxuICAgICdMZXNzVGlsZGUnOiAnXFx1MjI3MicsXG4gICAgJ2xlc3NzaW0nOiAnXFx1MjI3MicsXG4gICAgJ2xzaW0nOiAnXFx1MjI3MicsXG4gICAgJ0xmcic6ICdcXHVEODM1XFx1REQwRicsXG4gICAgJ0xsJzogJ1xcdTIyRDgnLFxuICAgICdMbGVmdGFycm93JzogJ1xcdTIxREEnLFxuICAgICdsQWFycic6ICdcXHUyMURBJyxcbiAgICAnTG1pZG90JzogJ1xcdTAxM0YnLFxuICAgICdMb25nTGVmdEFycm93JzogJ1xcdTI3RjUnLFxuICAgICdsb25nbGVmdGFycm93JzogJ1xcdTI3RjUnLFxuICAgICd4bGFycic6ICdcXHUyN0Y1JyxcbiAgICAnTG9uZ0xlZnRSaWdodEFycm93JzogJ1xcdTI3RjcnLFxuICAgICdsb25nbGVmdHJpZ2h0YXJyb3cnOiAnXFx1MjdGNycsXG4gICAgJ3hoYXJyJzogJ1xcdTI3RjcnLFxuICAgICdMb25nUmlnaHRBcnJvdyc6ICdcXHUyN0Y2JyxcbiAgICAnbG9uZ3JpZ2h0YXJyb3cnOiAnXFx1MjdGNicsXG4gICAgJ3hyYXJyJzogJ1xcdTI3RjYnLFxuICAgICdMb3BmJzogJ1xcdUQ4MzVcXHVERDQzJyxcbiAgICAnTG93ZXJMZWZ0QXJyb3cnOiAnXFx1MjE5OScsXG4gICAgJ3N3YXJyJzogJ1xcdTIxOTknLFxuICAgICdzd2Fycm93JzogJ1xcdTIxOTknLFxuICAgICdMb3dlclJpZ2h0QXJyb3cnOiAnXFx1MjE5OCcsXG4gICAgJ3NlYXJyJzogJ1xcdTIxOTgnLFxuICAgICdzZWFycm93JzogJ1xcdTIxOTgnLFxuICAgICdMc2gnOiAnXFx1MjFCMCcsXG4gICAgJ2xzaCc6ICdcXHUyMUIwJyxcbiAgICAnTHN0cm9rJzogJ1xcdTAxNDEnLFxuICAgICdMdCc6ICdcXHUyMjZBJyxcbiAgICAnTmVzdGVkTGVzc0xlc3MnOiAnXFx1MjI2QScsXG4gICAgJ2xsJzogJ1xcdTIyNkEnLFxuICAgICdNYXAnOiAnXFx1MjkwNScsXG4gICAgJ01jeSc6ICdcXHUwNDFDJyxcbiAgICAnTWVkaXVtU3BhY2UnOiAnXFx1MjA1RicsXG4gICAgJ01lbGxpbnRyZic6ICdcXHUyMTMzJyxcbiAgICAnTXNjcic6ICdcXHUyMTMzJyxcbiAgICAncGhtbWF0JzogJ1xcdTIxMzMnLFxuICAgICdNZnInOiAnXFx1RDgzNVxcdUREMTAnLFxuICAgICdNaW51c1BsdXMnOiAnXFx1MjIxMycsXG4gICAgJ21ucGx1cyc6ICdcXHUyMjEzJyxcbiAgICAnbXAnOiAnXFx1MjIxMycsXG4gICAgJ01vcGYnOiAnXFx1RDgzNVxcdURENDQnLFxuICAgICdNdSc6ICdcXHUwMzlDJyxcbiAgICAnTkpjeSc6ICdcXHUwNDBBJyxcbiAgICAnTmFjdXRlJzogJ1xcdTAxNDMnLFxuICAgICdOY2Fyb24nOiAnXFx1MDE0NycsXG4gICAgJ05jZWRpbCc6ICdcXHUwMTQ1JyxcbiAgICAnTmN5JzogJ1xcdTA0MUQnLFxuICAgICdOZWdhdGl2ZU1lZGl1bVNwYWNlJzogJ1xcdTIwMEInLFxuICAgICdOZWdhdGl2ZVRoaWNrU3BhY2UnOiAnXFx1MjAwQicsXG4gICAgJ05lZ2F0aXZlVGhpblNwYWNlJzogJ1xcdTIwMEInLFxuICAgICdOZWdhdGl2ZVZlcnlUaGluU3BhY2UnOiAnXFx1MjAwQicsXG4gICAgJ1plcm9XaWR0aFNwYWNlJzogJ1xcdTIwMEInLFxuICAgICdOZXdMaW5lJzogJ1xcdTAwMEEnLFxuICAgICdOZnInOiAnXFx1RDgzNVxcdUREMTEnLFxuICAgICdOb0JyZWFrJzogJ1xcdTIwNjAnLFxuICAgICdOb25CcmVha2luZ1NwYWNlJzogJ1xcdTAwQTAnLFxuICAgICduYnNwJzogJ1xcdTAwQTAnLFxuICAgICdOb3BmJzogJ1xcdTIxMTUnLFxuICAgICduYXR1cmFscyc6ICdcXHUyMTE1JyxcbiAgICAnTm90JzogJ1xcdTJBRUMnLFxuICAgICdOb3RDb25ncnVlbnQnOiAnXFx1MjI2MicsXG4gICAgJ25lcXVpdic6ICdcXHUyMjYyJyxcbiAgICAnTm90Q3VwQ2FwJzogJ1xcdTIyNkQnLFxuICAgICdOb3REb3VibGVWZXJ0aWNhbEJhcic6ICdcXHUyMjI2JyxcbiAgICAnbnBhcic6ICdcXHUyMjI2JyxcbiAgICAnbnBhcmFsbGVsJzogJ1xcdTIyMjYnLFxuICAgICduc2hvcnRwYXJhbGxlbCc6ICdcXHUyMjI2JyxcbiAgICAnbnNwYXInOiAnXFx1MjIyNicsXG4gICAgJ05vdEVsZW1lbnQnOiAnXFx1MjIwOScsXG4gICAgJ25vdGluJzogJ1xcdTIyMDknLFxuICAgICdub3RpbnZhJzogJ1xcdTIyMDknLFxuICAgICdOb3RFcXVhbCc6ICdcXHUyMjYwJyxcbiAgICAnbmUnOiAnXFx1MjI2MCcsXG4gICAgJ05vdEVxdWFsVGlsZGUnOiAnXFx1MjI0MlxcdTAzMzgnLFxuICAgICduZXNpbSc6ICdcXHUyMjQyXFx1MDMzOCcsXG4gICAgJ05vdEV4aXN0cyc6ICdcXHUyMjA0JyxcbiAgICAnbmV4aXN0JzogJ1xcdTIyMDQnLFxuICAgICduZXhpc3RzJzogJ1xcdTIyMDQnLFxuICAgICdOb3RHcmVhdGVyJzogJ1xcdTIyNkYnLFxuICAgICduZ3QnOiAnXFx1MjI2RicsXG4gICAgJ25ndHInOiAnXFx1MjI2RicsXG4gICAgJ05vdEdyZWF0ZXJFcXVhbCc6ICdcXHUyMjcxJyxcbiAgICAnbmdlJzogJ1xcdTIyNzEnLFxuICAgICduZ2VxJzogJ1xcdTIyNzEnLFxuICAgICdOb3RHcmVhdGVyRnVsbEVxdWFsJzogJ1xcdTIyNjdcXHUwMzM4JyxcbiAgICAnbmdFJzogJ1xcdTIyNjdcXHUwMzM4JyxcbiAgICAnbmdlcXEnOiAnXFx1MjI2N1xcdTAzMzgnLFxuICAgICdOb3RHcmVhdGVyR3JlYXRlcic6ICdcXHUyMjZCXFx1MDMzOCcsXG4gICAgJ25HdHYnOiAnXFx1MjI2QlxcdTAzMzgnLFxuICAgICdOb3RHcmVhdGVyTGVzcyc6ICdcXHUyMjc5JyxcbiAgICAnbnRnbCc6ICdcXHUyMjc5JyxcbiAgICAnTm90R3JlYXRlclNsYW50RXF1YWwnOiAnXFx1MkE3RVxcdTAzMzgnLFxuICAgICduZ2Vxc2xhbnQnOiAnXFx1MkE3RVxcdTAzMzgnLFxuICAgICduZ2VzJzogJ1xcdTJBN0VcXHUwMzM4JyxcbiAgICAnTm90R3JlYXRlclRpbGRlJzogJ1xcdTIyNzUnLFxuICAgICduZ3NpbSc6ICdcXHUyMjc1JyxcbiAgICAnTm90SHVtcERvd25IdW1wJzogJ1xcdTIyNEVcXHUwMzM4JyxcbiAgICAnbmJ1bXAnOiAnXFx1MjI0RVxcdTAzMzgnLFxuICAgICdOb3RIdW1wRXF1YWwnOiAnXFx1MjI0RlxcdTAzMzgnLFxuICAgICduYnVtcGUnOiAnXFx1MjI0RlxcdTAzMzgnLFxuICAgICdOb3RMZWZ0VHJpYW5nbGUnOiAnXFx1MjJFQScsXG4gICAgJ25sdHJpJzogJ1xcdTIyRUEnLFxuICAgICdudHJpYW5nbGVsZWZ0JzogJ1xcdTIyRUEnLFxuICAgICdOb3RMZWZ0VHJpYW5nbGVCYXInOiAnXFx1MjlDRlxcdTAzMzgnLFxuICAgICdOb3RMZWZ0VHJpYW5nbGVFcXVhbCc6ICdcXHUyMkVDJyxcbiAgICAnbmx0cmllJzogJ1xcdTIyRUMnLFxuICAgICdudHJpYW5nbGVsZWZ0ZXEnOiAnXFx1MjJFQycsXG4gICAgJ05vdExlc3MnOiAnXFx1MjI2RScsXG4gICAgJ25sZXNzJzogJ1xcdTIyNkUnLFxuICAgICdubHQnOiAnXFx1MjI2RScsXG4gICAgJ05vdExlc3NFcXVhbCc6ICdcXHUyMjcwJyxcbiAgICAnbmxlJzogJ1xcdTIyNzAnLFxuICAgICdubGVxJzogJ1xcdTIyNzAnLFxuICAgICdOb3RMZXNzR3JlYXRlcic6ICdcXHUyMjc4JyxcbiAgICAnbnRsZyc6ICdcXHUyMjc4JyxcbiAgICAnTm90TGVzc0xlc3MnOiAnXFx1MjI2QVxcdTAzMzgnLFxuICAgICduTHR2JzogJ1xcdTIyNkFcXHUwMzM4JyxcbiAgICAnTm90TGVzc1NsYW50RXF1YWwnOiAnXFx1MkE3RFxcdTAzMzgnLFxuICAgICdubGVxc2xhbnQnOiAnXFx1MkE3RFxcdTAzMzgnLFxuICAgICdubGVzJzogJ1xcdTJBN0RcXHUwMzM4JyxcbiAgICAnTm90TGVzc1RpbGRlJzogJ1xcdTIyNzQnLFxuICAgICdubHNpbSc6ICdcXHUyMjc0JyxcbiAgICAnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInOiAnXFx1MkFBMlxcdTAzMzgnLFxuICAgICdOb3ROZXN0ZWRMZXNzTGVzcyc6ICdcXHUyQUExXFx1MDMzOCcsXG4gICAgJ05vdFByZWNlZGVzJzogJ1xcdTIyODAnLFxuICAgICducHInOiAnXFx1MjI4MCcsXG4gICAgJ25wcmVjJzogJ1xcdTIyODAnLFxuICAgICdOb3RQcmVjZWRlc0VxdWFsJzogJ1xcdTJBQUZcXHUwMzM4JyxcbiAgICAnbnByZSc6ICdcXHUyQUFGXFx1MDMzOCcsXG4gICAgJ25wcmVjZXEnOiAnXFx1MkFBRlxcdTAzMzgnLFxuICAgICdOb3RQcmVjZWRlc1NsYW50RXF1YWwnOiAnXFx1MjJFMCcsXG4gICAgJ25wcmN1ZSc6ICdcXHUyMkUwJyxcbiAgICAnTm90UmV2ZXJzZUVsZW1lbnQnOiAnXFx1MjIwQycsXG4gICAgJ25vdG5pJzogJ1xcdTIyMEMnLFxuICAgICdub3RuaXZhJzogJ1xcdTIyMEMnLFxuICAgICdOb3RSaWdodFRyaWFuZ2xlJzogJ1xcdTIyRUInLFxuICAgICducnRyaSc6ICdcXHUyMkVCJyxcbiAgICAnbnRyaWFuZ2xlcmlnaHQnOiAnXFx1MjJFQicsXG4gICAgJ05vdFJpZ2h0VHJpYW5nbGVCYXInOiAnXFx1MjlEMFxcdTAzMzgnLFxuICAgICdOb3RSaWdodFRyaWFuZ2xlRXF1YWwnOiAnXFx1MjJFRCcsXG4gICAgJ25ydHJpZSc6ICdcXHUyMkVEJyxcbiAgICAnbnRyaWFuZ2xlcmlnaHRlcSc6ICdcXHUyMkVEJyxcbiAgICAnTm90U3F1YXJlU3Vic2V0JzogJ1xcdTIyOEZcXHUwMzM4JyxcbiAgICAnTm90U3F1YXJlU3Vic2V0RXF1YWwnOiAnXFx1MjJFMicsXG4gICAgJ25zcXN1YmUnOiAnXFx1MjJFMicsXG4gICAgJ05vdFNxdWFyZVN1cGVyc2V0JzogJ1xcdTIyOTBcXHUwMzM4JyxcbiAgICAnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCc6ICdcXHUyMkUzJyxcbiAgICAnbnNxc3VwZSc6ICdcXHUyMkUzJyxcbiAgICAnTm90U3Vic2V0JzogJ1xcdTIyODJcXHUyMEQyJyxcbiAgICAnbnN1YnNldCc6ICdcXHUyMjgyXFx1MjBEMicsXG4gICAgJ3Zuc3ViJzogJ1xcdTIyODJcXHUyMEQyJyxcbiAgICAnTm90U3Vic2V0RXF1YWwnOiAnXFx1MjI4OCcsXG4gICAgJ25zdWJlJzogJ1xcdTIyODgnLFxuICAgICduc3Vic2V0ZXEnOiAnXFx1MjI4OCcsXG4gICAgJ05vdFN1Y2NlZWRzJzogJ1xcdTIyODEnLFxuICAgICduc2MnOiAnXFx1MjI4MScsXG4gICAgJ25zdWNjJzogJ1xcdTIyODEnLFxuICAgICdOb3RTdWNjZWVkc0VxdWFsJzogJ1xcdTJBQjBcXHUwMzM4JyxcbiAgICAnbnNjZSc6ICdcXHUyQUIwXFx1MDMzOCcsXG4gICAgJ25zdWNjZXEnOiAnXFx1MkFCMFxcdTAzMzgnLFxuICAgICdOb3RTdWNjZWVkc1NsYW50RXF1YWwnOiAnXFx1MjJFMScsXG4gICAgJ25zY2N1ZSc6ICdcXHUyMkUxJyxcbiAgICAnTm90U3VjY2VlZHNUaWxkZSc6ICdcXHUyMjdGXFx1MDMzOCcsXG4gICAgJ05vdFN1cGVyc2V0JzogJ1xcdTIyODNcXHUyMEQyJyxcbiAgICAnbnN1cHNldCc6ICdcXHUyMjgzXFx1MjBEMicsXG4gICAgJ3Zuc3VwJzogJ1xcdTIyODNcXHUyMEQyJyxcbiAgICAnTm90U3VwZXJzZXRFcXVhbCc6ICdcXHUyMjg5JyxcbiAgICAnbnN1cGUnOiAnXFx1MjI4OScsXG4gICAgJ25zdXBzZXRlcSc6ICdcXHUyMjg5JyxcbiAgICAnTm90VGlsZGUnOiAnXFx1MjI0MScsXG4gICAgJ25zaW0nOiAnXFx1MjI0MScsXG4gICAgJ05vdFRpbGRlRXF1YWwnOiAnXFx1MjI0NCcsXG4gICAgJ25zaW1lJzogJ1xcdTIyNDQnLFxuICAgICduc2ltZXEnOiAnXFx1MjI0NCcsXG4gICAgJ05vdFRpbGRlRnVsbEVxdWFsJzogJ1xcdTIyNDcnLFxuICAgICduY29uZyc6ICdcXHUyMjQ3JyxcbiAgICAnTm90VGlsZGVUaWxkZSc6ICdcXHUyMjQ5JyxcbiAgICAnbmFwJzogJ1xcdTIyNDknLFxuICAgICduYXBwcm94JzogJ1xcdTIyNDknLFxuICAgICdOb3RWZXJ0aWNhbEJhcic6ICdcXHUyMjI0JyxcbiAgICAnbm1pZCc6ICdcXHUyMjI0JyxcbiAgICAnbnNob3J0bWlkJzogJ1xcdTIyMjQnLFxuICAgICduc21pZCc6ICdcXHUyMjI0JyxcbiAgICAnTnNjcic6ICdcXHVEODM1XFx1RENBOScsXG4gICAgJ050aWxkZSc6ICdcXHUwMEQxJyxcbiAgICAnTnUnOiAnXFx1MDM5RCcsXG4gICAgJ09FbGlnJzogJ1xcdTAxNTInLFxuICAgICdPYWN1dGUnOiAnXFx1MDBEMycsXG4gICAgJ09jaXJjJzogJ1xcdTAwRDQnLFxuICAgICdPY3knOiAnXFx1MDQxRScsXG4gICAgJ09kYmxhYyc6ICdcXHUwMTUwJyxcbiAgICAnT2ZyJzogJ1xcdUQ4MzVcXHVERDEyJyxcbiAgICAnT2dyYXZlJzogJ1xcdTAwRDInLFxuICAgICdPbWFjcic6ICdcXHUwMTRDJyxcbiAgICAnT21lZ2EnOiAnXFx1MDNBOScsXG4gICAgJ29obSc6ICdcXHUwM0E5JyxcbiAgICAnT21pY3Jvbic6ICdcXHUwMzlGJyxcbiAgICAnT29wZic6ICdcXHVEODM1XFx1REQ0NicsXG4gICAgJ09wZW5DdXJseURvdWJsZVF1b3RlJzogJ1xcdTIwMUMnLFxuICAgICdsZHF1byc6ICdcXHUyMDFDJyxcbiAgICAnT3BlbkN1cmx5UXVvdGUnOiAnXFx1MjAxOCcsXG4gICAgJ2xzcXVvJzogJ1xcdTIwMTgnLFxuICAgICdPcic6ICdcXHUyQTU0JyxcbiAgICAnT3Njcic6ICdcXHVEODM1XFx1RENBQScsXG4gICAgJ09zbGFzaCc6ICdcXHUwMEQ4JyxcbiAgICAnT3RpbGRlJzogJ1xcdTAwRDUnLFxuICAgICdPdGltZXMnOiAnXFx1MkEzNycsXG4gICAgJ091bWwnOiAnXFx1MDBENicsXG4gICAgJ092ZXJCYXInOiAnXFx1MjAzRScsXG4gICAgJ29saW5lJzogJ1xcdTIwM0UnLFxuICAgICdPdmVyQnJhY2UnOiAnXFx1MjNERScsXG4gICAgJ092ZXJCcmFja2V0JzogJ1xcdTIzQjQnLFxuICAgICd0YnJrJzogJ1xcdTIzQjQnLFxuICAgICdPdmVyUGFyZW50aGVzaXMnOiAnXFx1MjNEQycsXG4gICAgJ1BhcnRpYWxEJzogJ1xcdTIyMDInLFxuICAgICdwYXJ0JzogJ1xcdTIyMDInLFxuICAgICdQY3knOiAnXFx1MDQxRicsXG4gICAgJ1Bmcic6ICdcXHVEODM1XFx1REQxMycsXG4gICAgJ1BoaSc6ICdcXHUwM0E2JyxcbiAgICAnUGknOiAnXFx1MDNBMCcsXG4gICAgJ1BsdXNNaW51cyc6ICdcXHUwMEIxJyxcbiAgICAncGx1c21uJzogJ1xcdTAwQjEnLFxuICAgICdwbSc6ICdcXHUwMEIxJyxcbiAgICAnUG9wZic6ICdcXHUyMTE5JyxcbiAgICAncHJpbWVzJzogJ1xcdTIxMTknLFxuICAgICdQcic6ICdcXHUyQUJCJyxcbiAgICAnUHJlY2VkZXMnOiAnXFx1MjI3QScsXG4gICAgJ3ByJzogJ1xcdTIyN0EnLFxuICAgICdwcmVjJzogJ1xcdTIyN0EnLFxuICAgICdQcmVjZWRlc0VxdWFsJzogJ1xcdTJBQUYnLFxuICAgICdwcmUnOiAnXFx1MkFBRicsXG4gICAgJ3ByZWNlcSc6ICdcXHUyQUFGJyxcbiAgICAnUHJlY2VkZXNTbGFudEVxdWFsJzogJ1xcdTIyN0MnLFxuICAgICdwcmN1ZSc6ICdcXHUyMjdDJyxcbiAgICAncHJlY2N1cmx5ZXEnOiAnXFx1MjI3QycsXG4gICAgJ1ByZWNlZGVzVGlsZGUnOiAnXFx1MjI3RScsXG4gICAgJ3ByZWNzaW0nOiAnXFx1MjI3RScsXG4gICAgJ3Byc2ltJzogJ1xcdTIyN0UnLFxuICAgICdQcmltZSc6ICdcXHUyMDMzJyxcbiAgICAnUHJvZHVjdCc6ICdcXHUyMjBGJyxcbiAgICAncHJvZCc6ICdcXHUyMjBGJyxcbiAgICAnUHJvcG9ydGlvbmFsJzogJ1xcdTIyMUQnLFxuICAgICdwcm9wJzogJ1xcdTIyMUQnLFxuICAgICdwcm9wdG8nOiAnXFx1MjIxRCcsXG4gICAgJ3ZhcnByb3B0byc6ICdcXHUyMjFEJyxcbiAgICAndnByb3AnOiAnXFx1MjIxRCcsXG4gICAgJ1BzY3InOiAnXFx1RDgzNVxcdURDQUInLFxuICAgICdQc2knOiAnXFx1MDNBOCcsXG4gICAgJ1FVT1QnOiAnXFx1MDAyMicsXG4gICAgJ3F1b3QnOiAnXFx1MDAyMicsXG4gICAgJ1Fmcic6ICdcXHVEODM1XFx1REQxNCcsXG4gICAgJ1FvcGYnOiAnXFx1MjExQScsXG4gICAgJ3JhdGlvbmFscyc6ICdcXHUyMTFBJyxcbiAgICAnUXNjcic6ICdcXHVEODM1XFx1RENBQycsXG4gICAgJ1JCYXJyJzogJ1xcdTI5MTAnLFxuICAgICdkcmJrYXJvdyc6ICdcXHUyOTEwJyxcbiAgICAnUkVHJzogJ1xcdTAwQUUnLFxuICAgICdjaXJjbGVkUic6ICdcXHUwMEFFJyxcbiAgICAncmVnJzogJ1xcdTAwQUUnLFxuICAgICdSYWN1dGUnOiAnXFx1MDE1NCcsXG4gICAgJ1JhbmcnOiAnXFx1MjdFQicsXG4gICAgJ1JhcnInOiAnXFx1MjFBMCcsXG4gICAgJ3R3b2hlYWRyaWdodGFycm93JzogJ1xcdTIxQTAnLFxuICAgICdSYXJydGwnOiAnXFx1MjkxNicsXG4gICAgJ1JjYXJvbic6ICdcXHUwMTU4JyxcbiAgICAnUmNlZGlsJzogJ1xcdTAxNTYnLFxuICAgICdSY3knOiAnXFx1MDQyMCcsXG4gICAgJ1JlJzogJ1xcdTIxMUMnLFxuICAgICdSZnInOiAnXFx1MjExQycsXG4gICAgJ3JlYWwnOiAnXFx1MjExQycsXG4gICAgJ3JlYWxwYXJ0JzogJ1xcdTIxMUMnLFxuICAgICdSZXZlcnNlRWxlbWVudCc6ICdcXHUyMjBCJyxcbiAgICAnU3VjaFRoYXQnOiAnXFx1MjIwQicsXG4gICAgJ25pJzogJ1xcdTIyMEInLFxuICAgICduaXYnOiAnXFx1MjIwQicsXG4gICAgJ1JldmVyc2VFcXVpbGlicml1bSc6ICdcXHUyMUNCJyxcbiAgICAnbGVmdHJpZ2h0aGFycG9vbnMnOiAnXFx1MjFDQicsXG4gICAgJ2xyaGFyJzogJ1xcdTIxQ0InLFxuICAgICdSZXZlcnNlVXBFcXVpbGlicml1bSc6ICdcXHUyOTZGJyxcbiAgICAnZHVoYXInOiAnXFx1Mjk2RicsXG4gICAgJ1Jobyc6ICdcXHUwM0ExJyxcbiAgICAnUmlnaHRBbmdsZUJyYWNrZXQnOiAnXFx1MjdFOScsXG4gICAgJ3JhbmcnOiAnXFx1MjdFOScsXG4gICAgJ3JhbmdsZSc6ICdcXHUyN0U5JyxcbiAgICAnUmlnaHRBcnJvdyc6ICdcXHUyMTkyJyxcbiAgICAnU2hvcnRSaWdodEFycm93JzogJ1xcdTIxOTInLFxuICAgICdyYXJyJzogJ1xcdTIxOTInLFxuICAgICdyaWdodGFycm93JzogJ1xcdTIxOTInLFxuICAgICdzcmFycic6ICdcXHUyMTkyJyxcbiAgICAnUmlnaHRBcnJvd0Jhcic6ICdcXHUyMUU1JyxcbiAgICAncmFycmInOiAnXFx1MjFFNScsXG4gICAgJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnOiAnXFx1MjFDNCcsXG4gICAgJ3JpZ2h0bGVmdGFycm93cyc6ICdcXHUyMUM0JyxcbiAgICAncmxhcnInOiAnXFx1MjFDNCcsXG4gICAgJ1JpZ2h0Q2VpbGluZyc6ICdcXHUyMzA5JyxcbiAgICAncmNlaWwnOiAnXFx1MjMwOScsXG4gICAgJ1JpZ2h0RG91YmxlQnJhY2tldCc6ICdcXHUyN0U3JyxcbiAgICAncm9icmsnOiAnXFx1MjdFNycsXG4gICAgJ1JpZ2h0RG93blRlZVZlY3Rvcic6ICdcXHUyOTVEJyxcbiAgICAnUmlnaHREb3duVmVjdG9yJzogJ1xcdTIxQzInLFxuICAgICdkaGFycic6ICdcXHUyMUMyJyxcbiAgICAnZG93bmhhcnBvb25yaWdodCc6ICdcXHUyMUMyJyxcbiAgICAnUmlnaHREb3duVmVjdG9yQmFyJzogJ1xcdTI5NTUnLFxuICAgICdSaWdodEZsb29yJzogJ1xcdTIzMEInLFxuICAgICdyZmxvb3InOiAnXFx1MjMwQicsXG4gICAgJ1JpZ2h0VGVlJzogJ1xcdTIyQTInLFxuICAgICd2ZGFzaCc6ICdcXHUyMkEyJyxcbiAgICAnUmlnaHRUZWVBcnJvdyc6ICdcXHUyMUE2JyxcbiAgICAnbWFwJzogJ1xcdTIxQTYnLFxuICAgICdtYXBzdG8nOiAnXFx1MjFBNicsXG4gICAgJ1JpZ2h0VGVlVmVjdG9yJzogJ1xcdTI5NUInLFxuICAgICdSaWdodFRyaWFuZ2xlJzogJ1xcdTIyQjMnLFxuICAgICd2YXJ0cmlhbmdsZXJpZ2h0JzogJ1xcdTIyQjMnLFxuICAgICd2cnRyaSc6ICdcXHUyMkIzJyxcbiAgICAnUmlnaHRUcmlhbmdsZUJhcic6ICdcXHUyOUQwJyxcbiAgICAnUmlnaHRUcmlhbmdsZUVxdWFsJzogJ1xcdTIyQjUnLFxuICAgICdydHJpZSc6ICdcXHUyMkI1JyxcbiAgICAndHJpYW5nbGVyaWdodGVxJzogJ1xcdTIyQjUnLFxuICAgICdSaWdodFVwRG93blZlY3Rvcic6ICdcXHUyOTRGJyxcbiAgICAnUmlnaHRVcFRlZVZlY3Rvcic6ICdcXHUyOTVDJyxcbiAgICAnUmlnaHRVcFZlY3Rvcic6ICdcXHUyMUJFJyxcbiAgICAndWhhcnInOiAnXFx1MjFCRScsXG4gICAgJ3VwaGFycG9vbnJpZ2h0JzogJ1xcdTIxQkUnLFxuICAgICdSaWdodFVwVmVjdG9yQmFyJzogJ1xcdTI5NTQnLFxuICAgICdSaWdodFZlY3Rvcic6ICdcXHUyMUMwJyxcbiAgICAncmhhcnUnOiAnXFx1MjFDMCcsXG4gICAgJ3JpZ2h0aGFycG9vbnVwJzogJ1xcdTIxQzAnLFxuICAgICdSaWdodFZlY3RvckJhcic6ICdcXHUyOTUzJyxcbiAgICAnUm9wZic6ICdcXHUyMTFEJyxcbiAgICAncmVhbHMnOiAnXFx1MjExRCcsXG4gICAgJ1JvdW5kSW1wbGllcyc6ICdcXHUyOTcwJyxcbiAgICAnUnJpZ2h0YXJyb3cnOiAnXFx1MjFEQicsXG4gICAgJ3JBYXJyJzogJ1xcdTIxREInLFxuICAgICdSc2NyJzogJ1xcdTIxMUInLFxuICAgICdyZWFsaW5lJzogJ1xcdTIxMUInLFxuICAgICdSc2gnOiAnXFx1MjFCMScsXG4gICAgJ3JzaCc6ICdcXHUyMUIxJyxcbiAgICAnUnVsZURlbGF5ZWQnOiAnXFx1MjlGNCcsXG4gICAgJ1NIQ0hjeSc6ICdcXHUwNDI5JyxcbiAgICAnU0hjeSc6ICdcXHUwNDI4JyxcbiAgICAnU09GVGN5JzogJ1xcdTA0MkMnLFxuICAgICdTYWN1dGUnOiAnXFx1MDE1QScsXG4gICAgJ1NjJzogJ1xcdTJBQkMnLFxuICAgICdTY2Fyb24nOiAnXFx1MDE2MCcsXG4gICAgJ1NjZWRpbCc6ICdcXHUwMTVFJyxcbiAgICAnU2NpcmMnOiAnXFx1MDE1QycsXG4gICAgJ1NjeSc6ICdcXHUwNDIxJyxcbiAgICAnU2ZyJzogJ1xcdUQ4MzVcXHVERDE2JyxcbiAgICAnU2hvcnRVcEFycm93JzogJ1xcdTIxOTEnLFxuICAgICdVcEFycm93JzogJ1xcdTIxOTEnLFxuICAgICd1YXJyJzogJ1xcdTIxOTEnLFxuICAgICd1cGFycm93JzogJ1xcdTIxOTEnLFxuICAgICdTaWdtYSc6ICdcXHUwM0EzJyxcbiAgICAnU21hbGxDaXJjbGUnOiAnXFx1MjIxOCcsXG4gICAgJ2NvbXBmbic6ICdcXHUyMjE4JyxcbiAgICAnU29wZic6ICdcXHVEODM1XFx1REQ0QScsXG4gICAgJ1NxcnQnOiAnXFx1MjIxQScsXG4gICAgJ3JhZGljJzogJ1xcdTIyMUEnLFxuICAgICdTcXVhcmUnOiAnXFx1MjVBMScsXG4gICAgJ3NxdSc6ICdcXHUyNUExJyxcbiAgICAnc3F1YXJlJzogJ1xcdTI1QTEnLFxuICAgICdTcXVhcmVJbnRlcnNlY3Rpb24nOiAnXFx1MjI5MycsXG4gICAgJ3NxY2FwJzogJ1xcdTIyOTMnLFxuICAgICdTcXVhcmVTdWJzZXQnOiAnXFx1MjI4RicsXG4gICAgJ3Nxc3ViJzogJ1xcdTIyOEYnLFxuICAgICdzcXN1YnNldCc6ICdcXHUyMjhGJyxcbiAgICAnU3F1YXJlU3Vic2V0RXF1YWwnOiAnXFx1MjI5MScsXG4gICAgJ3Nxc3ViZSc6ICdcXHUyMjkxJyxcbiAgICAnc3FzdWJzZXRlcSc6ICdcXHUyMjkxJyxcbiAgICAnU3F1YXJlU3VwZXJzZXQnOiAnXFx1MjI5MCcsXG4gICAgJ3Nxc3VwJzogJ1xcdTIyOTAnLFxuICAgICdzcXN1cHNldCc6ICdcXHUyMjkwJyxcbiAgICAnU3F1YXJlU3VwZXJzZXRFcXVhbCc6ICdcXHUyMjkyJyxcbiAgICAnc3FzdXBlJzogJ1xcdTIyOTInLFxuICAgICdzcXN1cHNldGVxJzogJ1xcdTIyOTInLFxuICAgICdTcXVhcmVVbmlvbic6ICdcXHUyMjk0JyxcbiAgICAnc3FjdXAnOiAnXFx1MjI5NCcsXG4gICAgJ1NzY3InOiAnXFx1RDgzNVxcdURDQUUnLFxuICAgICdTdGFyJzogJ1xcdTIyQzYnLFxuICAgICdzc3RhcmYnOiAnXFx1MjJDNicsXG4gICAgJ1N1Yic6ICdcXHUyMkQwJyxcbiAgICAnU3Vic2V0JzogJ1xcdTIyRDAnLFxuICAgICdTdWJzZXRFcXVhbCc6ICdcXHUyMjg2JyxcbiAgICAnc3ViZSc6ICdcXHUyMjg2JyxcbiAgICAnc3Vic2V0ZXEnOiAnXFx1MjI4NicsXG4gICAgJ1N1Y2NlZWRzJzogJ1xcdTIyN0InLFxuICAgICdzYyc6ICdcXHUyMjdCJyxcbiAgICAnc3VjYyc6ICdcXHUyMjdCJyxcbiAgICAnU3VjY2VlZHNFcXVhbCc6ICdcXHUyQUIwJyxcbiAgICAnc2NlJzogJ1xcdTJBQjAnLFxuICAgICdzdWNjZXEnOiAnXFx1MkFCMCcsXG4gICAgJ1N1Y2NlZWRzU2xhbnRFcXVhbCc6ICdcXHUyMjdEJyxcbiAgICAnc2NjdWUnOiAnXFx1MjI3RCcsXG4gICAgJ3N1Y2NjdXJseWVxJzogJ1xcdTIyN0QnLFxuICAgICdTdWNjZWVkc1RpbGRlJzogJ1xcdTIyN0YnLFxuICAgICdzY3NpbSc6ICdcXHUyMjdGJyxcbiAgICAnc3VjY3NpbSc6ICdcXHUyMjdGJyxcbiAgICAnU3VtJzogJ1xcdTIyMTEnLFxuICAgICdzdW0nOiAnXFx1MjIxMScsXG4gICAgJ1N1cCc6ICdcXHUyMkQxJyxcbiAgICAnU3Vwc2V0JzogJ1xcdTIyRDEnLFxuICAgICdTdXBlcnNldCc6ICdcXHUyMjgzJyxcbiAgICAnc3VwJzogJ1xcdTIyODMnLFxuICAgICdzdXBzZXQnOiAnXFx1MjI4MycsXG4gICAgJ1N1cGVyc2V0RXF1YWwnOiAnXFx1MjI4NycsXG4gICAgJ3N1cGUnOiAnXFx1MjI4NycsXG4gICAgJ3N1cHNldGVxJzogJ1xcdTIyODcnLFxuICAgICdUSE9STic6ICdcXHUwMERFJyxcbiAgICAnVFJBREUnOiAnXFx1MjEyMicsXG4gICAgJ3RyYWRlJzogJ1xcdTIxMjInLFxuICAgICdUU0hjeSc6ICdcXHUwNDBCJyxcbiAgICAnVFNjeSc6ICdcXHUwNDI2JyxcbiAgICAnVGFiJzogJ1xcdTAwMDknLFxuICAgICdUYXUnOiAnXFx1MDNBNCcsXG4gICAgJ1RjYXJvbic6ICdcXHUwMTY0JyxcbiAgICAnVGNlZGlsJzogJ1xcdTAxNjInLFxuICAgICdUY3knOiAnXFx1MDQyMicsXG4gICAgJ1Rmcic6ICdcXHVEODM1XFx1REQxNycsXG4gICAgJ1RoZXJlZm9yZSc6ICdcXHUyMjM0JyxcbiAgICAndGhlcmU0JzogJ1xcdTIyMzQnLFxuICAgICd0aGVyZWZvcmUnOiAnXFx1MjIzNCcsXG4gICAgJ1RoZXRhJzogJ1xcdTAzOTgnLFxuICAgICdUaGlja1NwYWNlJzogJ1xcdTIwNUZcXHUyMDBBJyxcbiAgICAnVGhpblNwYWNlJzogJ1xcdTIwMDknLFxuICAgICd0aGluc3AnOiAnXFx1MjAwOScsXG4gICAgJ1RpbGRlJzogJ1xcdTIyM0MnLFxuICAgICdzaW0nOiAnXFx1MjIzQycsXG4gICAgJ3RoaWNrc2ltJzogJ1xcdTIyM0MnLFxuICAgICd0aGtzaW0nOiAnXFx1MjIzQycsXG4gICAgJ1RpbGRlRXF1YWwnOiAnXFx1MjI0MycsXG4gICAgJ3NpbWUnOiAnXFx1MjI0MycsXG4gICAgJ3NpbWVxJzogJ1xcdTIyNDMnLFxuICAgICdUaWxkZUZ1bGxFcXVhbCc6ICdcXHUyMjQ1JyxcbiAgICAnY29uZyc6ICdcXHUyMjQ1JyxcbiAgICAnVGlsZGVUaWxkZSc6ICdcXHUyMjQ4JyxcbiAgICAnYXAnOiAnXFx1MjI0OCcsXG4gICAgJ2FwcHJveCc6ICdcXHUyMjQ4JyxcbiAgICAnYXN5bXAnOiAnXFx1MjI0OCcsXG4gICAgJ3RoaWNrYXBwcm94JzogJ1xcdTIyNDgnLFxuICAgICd0aGthcCc6ICdcXHUyMjQ4JyxcbiAgICAnVG9wZic6ICdcXHVEODM1XFx1REQ0QicsXG4gICAgJ1RyaXBsZURvdCc6ICdcXHUyMERCJyxcbiAgICAndGRvdCc6ICdcXHUyMERCJyxcbiAgICAnVHNjcic6ICdcXHVEODM1XFx1RENBRicsXG4gICAgJ1RzdHJvayc6ICdcXHUwMTY2JyxcbiAgICAnVWFjdXRlJzogJ1xcdTAwREEnLFxuICAgICdVYXJyJzogJ1xcdTIxOUYnLFxuICAgICdVYXJyb2Npcic6ICdcXHUyOTQ5JyxcbiAgICAnVWJyY3knOiAnXFx1MDQwRScsXG4gICAgJ1VicmV2ZSc6ICdcXHUwMTZDJyxcbiAgICAnVWNpcmMnOiAnXFx1MDBEQicsXG4gICAgJ1VjeSc6ICdcXHUwNDIzJyxcbiAgICAnVWRibGFjJzogJ1xcdTAxNzAnLFxuICAgICdVZnInOiAnXFx1RDgzNVxcdUREMTgnLFxuICAgICdVZ3JhdmUnOiAnXFx1MDBEOScsXG4gICAgJ1VtYWNyJzogJ1xcdTAxNkEnLFxuICAgICdVbmRlckJhcic6ICdcXHUwMDVGJyxcbiAgICAnbG93YmFyJzogJ1xcdTAwNUYnLFxuICAgICdVbmRlckJyYWNlJzogJ1xcdTIzREYnLFxuICAgICdVbmRlckJyYWNrZXQnOiAnXFx1MjNCNScsXG4gICAgJ2JicmsnOiAnXFx1MjNCNScsXG4gICAgJ1VuZGVyUGFyZW50aGVzaXMnOiAnXFx1MjNERCcsXG4gICAgJ1VuaW9uJzogJ1xcdTIyQzMnLFxuICAgICdiaWdjdXAnOiAnXFx1MjJDMycsXG4gICAgJ3hjdXAnOiAnXFx1MjJDMycsXG4gICAgJ1VuaW9uUGx1cyc6ICdcXHUyMjhFJyxcbiAgICAndXBsdXMnOiAnXFx1MjI4RScsXG4gICAgJ1VvZ29uJzogJ1xcdTAxNzInLFxuICAgICdVb3BmJzogJ1xcdUQ4MzVcXHVERDRDJyxcbiAgICAnVXBBcnJvd0Jhcic6ICdcXHUyOTEyJyxcbiAgICAnVXBBcnJvd0Rvd25BcnJvdyc6ICdcXHUyMUM1JyxcbiAgICAndWRhcnInOiAnXFx1MjFDNScsXG4gICAgJ1VwRG93bkFycm93JzogJ1xcdTIxOTUnLFxuICAgICd1cGRvd25hcnJvdyc6ICdcXHUyMTk1JyxcbiAgICAndmFycic6ICdcXHUyMTk1JyxcbiAgICAnVXBFcXVpbGlicml1bSc6ICdcXHUyOTZFJyxcbiAgICAndWRoYXInOiAnXFx1Mjk2RScsXG4gICAgJ1VwVGVlJzogJ1xcdTIyQTUnLFxuICAgICdib3QnOiAnXFx1MjJBNScsXG4gICAgJ2JvdHRvbSc6ICdcXHUyMkE1JyxcbiAgICAncGVycCc6ICdcXHUyMkE1JyxcbiAgICAnVXBUZWVBcnJvdyc6ICdcXHUyMUE1JyxcbiAgICAnbWFwc3RvdXAnOiAnXFx1MjFBNScsXG4gICAgJ1VwcGVyTGVmdEFycm93JzogJ1xcdTIxOTYnLFxuICAgICdud2Fycic6ICdcXHUyMTk2JyxcbiAgICAnbndhcnJvdyc6ICdcXHUyMTk2JyxcbiAgICAnVXBwZXJSaWdodEFycm93JzogJ1xcdTIxOTcnLFxuICAgICduZWFycic6ICdcXHUyMTk3JyxcbiAgICAnbmVhcnJvdyc6ICdcXHUyMTk3JyxcbiAgICAnVXBzaSc6ICdcXHUwM0QyJyxcbiAgICAndXBzaWgnOiAnXFx1MDNEMicsXG4gICAgJ1Vwc2lsb24nOiAnXFx1MDNBNScsXG4gICAgJ1VyaW5nJzogJ1xcdTAxNkUnLFxuICAgICdVc2NyJzogJ1xcdUQ4MzVcXHVEQ0IwJyxcbiAgICAnVXRpbGRlJzogJ1xcdTAxNjgnLFxuICAgICdVdW1sJzogJ1xcdTAwREMnLFxuICAgICdWRGFzaCc6ICdcXHUyMkFCJyxcbiAgICAnVmJhcic6ICdcXHUyQUVCJyxcbiAgICAnVmN5JzogJ1xcdTA0MTInLFxuICAgICdWZGFzaCc6ICdcXHUyMkE5JyxcbiAgICAnVmRhc2hsJzogJ1xcdTJBRTYnLFxuICAgICdWZWUnOiAnXFx1MjJDMScsXG4gICAgJ2JpZ3ZlZSc6ICdcXHUyMkMxJyxcbiAgICAneHZlZSc6ICdcXHUyMkMxJyxcbiAgICAnVmVyYmFyJzogJ1xcdTIwMTYnLFxuICAgICdWZXJ0JzogJ1xcdTIwMTYnLFxuICAgICdWZXJ0aWNhbEJhcic6ICdcXHUyMjIzJyxcbiAgICAnbWlkJzogJ1xcdTIyMjMnLFxuICAgICdzaG9ydG1pZCc6ICdcXHUyMjIzJyxcbiAgICAnc21pZCc6ICdcXHUyMjIzJyxcbiAgICAnVmVydGljYWxMaW5lJzogJ1xcdTAwN0MnLFxuICAgICd2ZXJiYXInOiAnXFx1MDA3QycsXG4gICAgJ3ZlcnQnOiAnXFx1MDA3QycsXG4gICAgJ1ZlcnRpY2FsU2VwYXJhdG9yJzogJ1xcdTI3NTgnLFxuICAgICdWZXJ0aWNhbFRpbGRlJzogJ1xcdTIyNDAnLFxuICAgICd3cic6ICdcXHUyMjQwJyxcbiAgICAnd3JlYXRoJzogJ1xcdTIyNDAnLFxuICAgICdWZXJ5VGhpblNwYWNlJzogJ1xcdTIwMEEnLFxuICAgICdoYWlyc3AnOiAnXFx1MjAwQScsXG4gICAgJ1Zmcic6ICdcXHVEODM1XFx1REQxOScsXG4gICAgJ1ZvcGYnOiAnXFx1RDgzNVxcdURENEQnLFxuICAgICdWc2NyJzogJ1xcdUQ4MzVcXHVEQ0IxJyxcbiAgICAnVnZkYXNoJzogJ1xcdTIyQUEnLFxuICAgICdXY2lyYyc6ICdcXHUwMTc0JyxcbiAgICAnV2VkZ2UnOiAnXFx1MjJDMCcsXG4gICAgJ2JpZ3dlZGdlJzogJ1xcdTIyQzAnLFxuICAgICd4d2VkZ2UnOiAnXFx1MjJDMCcsXG4gICAgJ1dmcic6ICdcXHVEODM1XFx1REQxQScsXG4gICAgJ1dvcGYnOiAnXFx1RDgzNVxcdURENEUnLFxuICAgICdXc2NyJzogJ1xcdUQ4MzVcXHVEQ0IyJyxcbiAgICAnWGZyJzogJ1xcdUQ4MzVcXHVERDFCJyxcbiAgICAnWGknOiAnXFx1MDM5RScsXG4gICAgJ1hvcGYnOiAnXFx1RDgzNVxcdURENEYnLFxuICAgICdYc2NyJzogJ1xcdUQ4MzVcXHVEQ0IzJyxcbiAgICAnWUFjeSc6ICdcXHUwNDJGJyxcbiAgICAnWUljeSc6ICdcXHUwNDA3JyxcbiAgICAnWVVjeSc6ICdcXHUwNDJFJyxcbiAgICAnWWFjdXRlJzogJ1xcdTAwREQnLFxuICAgICdZY2lyYyc6ICdcXHUwMTc2JyxcbiAgICAnWWN5JzogJ1xcdTA0MkInLFxuICAgICdZZnInOiAnXFx1RDgzNVxcdUREMUMnLFxuICAgICdZb3BmJzogJ1xcdUQ4MzVcXHVERDUwJyxcbiAgICAnWXNjcic6ICdcXHVEODM1XFx1RENCNCcsXG4gICAgJ1l1bWwnOiAnXFx1MDE3OCcsXG4gICAgJ1pIY3knOiAnXFx1MDQxNicsXG4gICAgJ1phY3V0ZSc6ICdcXHUwMTc5JyxcbiAgICAnWmNhcm9uJzogJ1xcdTAxN0QnLFxuICAgICdaY3knOiAnXFx1MDQxNycsXG4gICAgJ1pkb3QnOiAnXFx1MDE3QicsXG4gICAgJ1pldGEnOiAnXFx1MDM5NicsXG4gICAgJ1pmcic6ICdcXHUyMTI4JyxcbiAgICAnemVldHJmJzogJ1xcdTIxMjgnLFxuICAgICdab3BmJzogJ1xcdTIxMjQnLFxuICAgICdpbnRlZ2Vycyc6ICdcXHUyMTI0JyxcbiAgICAnWnNjcic6ICdcXHVEODM1XFx1RENCNScsXG4gICAgJ2FhY3V0ZSc6ICdcXHUwMEUxJyxcbiAgICAnYWJyZXZlJzogJ1xcdTAxMDMnLFxuICAgICdhYyc6ICdcXHUyMjNFJyxcbiAgICAnbXN0cG9zJzogJ1xcdTIyM0UnLFxuICAgICdhY0UnOiAnXFx1MjIzRVxcdTAzMzMnLFxuICAgICdhY2QnOiAnXFx1MjIzRicsXG4gICAgJ2FjaXJjJzogJ1xcdTAwRTInLFxuICAgICdhY3knOiAnXFx1MDQzMCcsXG4gICAgJ2FlbGlnJzogJ1xcdTAwRTYnLFxuICAgICdhZnInOiAnXFx1RDgzNVxcdUREMUUnLFxuICAgICdhZ3JhdmUnOiAnXFx1MDBFMCcsXG4gICAgJ2FsZWZzeW0nOiAnXFx1MjEzNScsXG4gICAgJ2FsZXBoJzogJ1xcdTIxMzUnLFxuICAgICdhbHBoYSc6ICdcXHUwM0IxJyxcbiAgICAnYW1hY3InOiAnXFx1MDEwMScsXG4gICAgJ2FtYWxnJzogJ1xcdTJBM0YnLFxuICAgICdhbmQnOiAnXFx1MjIyNycsXG4gICAgJ3dlZGdlJzogJ1xcdTIyMjcnLFxuICAgICdhbmRhbmQnOiAnXFx1MkE1NScsXG4gICAgJ2FuZGQnOiAnXFx1MkE1QycsXG4gICAgJ2FuZHNsb3BlJzogJ1xcdTJBNTgnLFxuICAgICdhbmR2JzogJ1xcdTJBNUEnLFxuICAgICdhbmcnOiAnXFx1MjIyMCcsXG4gICAgJ2FuZ2xlJzogJ1xcdTIyMjAnLFxuICAgICdhbmdlJzogJ1xcdTI5QTQnLFxuICAgICdhbmdtc2QnOiAnXFx1MjIyMScsXG4gICAgJ21lYXN1cmVkYW5nbGUnOiAnXFx1MjIyMScsXG4gICAgJ2FuZ21zZGFhJzogJ1xcdTI5QTgnLFxuICAgICdhbmdtc2RhYic6ICdcXHUyOUE5JyxcbiAgICAnYW5nbXNkYWMnOiAnXFx1MjlBQScsXG4gICAgJ2FuZ21zZGFkJzogJ1xcdTI5QUInLFxuICAgICdhbmdtc2RhZSc6ICdcXHUyOUFDJyxcbiAgICAnYW5nbXNkYWYnOiAnXFx1MjlBRCcsXG4gICAgJ2FuZ21zZGFnJzogJ1xcdTI5QUUnLFxuICAgICdhbmdtc2RhaCc6ICdcXHUyOUFGJyxcbiAgICAnYW5ncnQnOiAnXFx1MjIxRicsXG4gICAgJ2FuZ3J0dmInOiAnXFx1MjJCRScsXG4gICAgJ2FuZ3J0dmJkJzogJ1xcdTI5OUQnLFxuICAgICdhbmdzcGgnOiAnXFx1MjIyMicsXG4gICAgJ2FuZ3phcnInOiAnXFx1MjM3QycsXG4gICAgJ2FvZ29uJzogJ1xcdTAxMDUnLFxuICAgICdhb3BmJzogJ1xcdUQ4MzVcXHVERDUyJyxcbiAgICAnYXBFJzogJ1xcdTJBNzAnLFxuICAgICdhcGFjaXInOiAnXFx1MkE2RicsXG4gICAgJ2FwZSc6ICdcXHUyMjRBJyxcbiAgICAnYXBwcm94ZXEnOiAnXFx1MjI0QScsXG4gICAgJ2FwaWQnOiAnXFx1MjI0QicsXG4gICAgJ2Fwb3MnOiAnXFx1MDAyNycsXG4gICAgJ2FyaW5nJzogJ1xcdTAwRTUnLFxuICAgICdhc2NyJzogJ1xcdUQ4MzVcXHVEQ0I2JyxcbiAgICAnYXN0JzogJ1xcdTAwMkEnLFxuICAgICdtaWRhc3QnOiAnXFx1MDAyQScsXG4gICAgJ2F0aWxkZSc6ICdcXHUwMEUzJyxcbiAgICAnYXVtbCc6ICdcXHUwMEU0JyxcbiAgICAnYXdpbnQnOiAnXFx1MkExMScsXG4gICAgJ2JOb3QnOiAnXFx1MkFFRCcsXG4gICAgJ2JhY2tjb25nJzogJ1xcdTIyNEMnLFxuICAgICdiY29uZyc6ICdcXHUyMjRDJyxcbiAgICAnYmFja2Vwc2lsb24nOiAnXFx1MDNGNicsXG4gICAgJ2JlcHNpJzogJ1xcdTAzRjYnLFxuICAgICdiYWNrcHJpbWUnOiAnXFx1MjAzNScsXG4gICAgJ2JwcmltZSc6ICdcXHUyMDM1JyxcbiAgICAnYmFja3NpbSc6ICdcXHUyMjNEJyxcbiAgICAnYnNpbSc6ICdcXHUyMjNEJyxcbiAgICAnYmFja3NpbWVxJzogJ1xcdTIyQ0QnLFxuICAgICdic2ltZSc6ICdcXHUyMkNEJyxcbiAgICAnYmFydmVlJzogJ1xcdTIyQkQnLFxuICAgICdiYXJ3ZWQnOiAnXFx1MjMwNScsXG4gICAgJ2JhcndlZGdlJzogJ1xcdTIzMDUnLFxuICAgICdiYnJrdGJyayc6ICdcXHUyM0I2JyxcbiAgICAnYmN5JzogJ1xcdTA0MzEnLFxuICAgICdiZHF1byc6ICdcXHUyMDFFJyxcbiAgICAnbGRxdW9yJzogJ1xcdTIwMUUnLFxuICAgICdiZW1wdHl2JzogJ1xcdTI5QjAnLFxuICAgICdiZXRhJzogJ1xcdTAzQjInLFxuICAgICdiZXRoJzogJ1xcdTIxMzYnLFxuICAgICdiZXR3ZWVuJzogJ1xcdTIyNkMnLFxuICAgICd0d2l4dCc6ICdcXHUyMjZDJyxcbiAgICAnYmZyJzogJ1xcdUQ4MzVcXHVERDFGJyxcbiAgICAnYmlnY2lyYyc6ICdcXHUyNUVGJyxcbiAgICAneGNpcmMnOiAnXFx1MjVFRicsXG4gICAgJ2JpZ29kb3QnOiAnXFx1MkEwMCcsXG4gICAgJ3hvZG90JzogJ1xcdTJBMDAnLFxuICAgICdiaWdvcGx1cyc6ICdcXHUyQTAxJyxcbiAgICAneG9wbHVzJzogJ1xcdTJBMDEnLFxuICAgICdiaWdvdGltZXMnOiAnXFx1MkEwMicsXG4gICAgJ3hvdGltZSc6ICdcXHUyQTAyJyxcbiAgICAnYmlnc3FjdXAnOiAnXFx1MkEwNicsXG4gICAgJ3hzcWN1cCc6ICdcXHUyQTA2JyxcbiAgICAnYmlnc3Rhcic6ICdcXHUyNjA1JyxcbiAgICAnc3RhcmYnOiAnXFx1MjYwNScsXG4gICAgJ2JpZ3RyaWFuZ2xlZG93bic6ICdcXHUyNUJEJyxcbiAgICAneGR0cmknOiAnXFx1MjVCRCcsXG4gICAgJ2JpZ3RyaWFuZ2xldXAnOiAnXFx1MjVCMycsXG4gICAgJ3h1dHJpJzogJ1xcdTI1QjMnLFxuICAgICdiaWd1cGx1cyc6ICdcXHUyQTA0JyxcbiAgICAneHVwbHVzJzogJ1xcdTJBMDQnLFxuICAgICdia2Fyb3cnOiAnXFx1MjkwRCcsXG4gICAgJ3JiYXJyJzogJ1xcdTI5MEQnLFxuICAgICdibGFja2xvemVuZ2UnOiAnXFx1MjlFQicsXG4gICAgJ2xvemYnOiAnXFx1MjlFQicsXG4gICAgJ2JsYWNrdHJpYW5nbGUnOiAnXFx1MjVCNCcsXG4gICAgJ3V0cmlmJzogJ1xcdTI1QjQnLFxuICAgICdibGFja3RyaWFuZ2xlZG93bic6ICdcXHUyNUJFJyxcbiAgICAnZHRyaWYnOiAnXFx1MjVCRScsXG4gICAgJ2JsYWNrdHJpYW5nbGVsZWZ0JzogJ1xcdTI1QzInLFxuICAgICdsdHJpZic6ICdcXHUyNUMyJyxcbiAgICAnYmxhY2t0cmlhbmdsZXJpZ2h0JzogJ1xcdTI1QjgnLFxuICAgICdydHJpZic6ICdcXHUyNUI4JyxcbiAgICAnYmxhbmsnOiAnXFx1MjQyMycsXG4gICAgJ2JsazEyJzogJ1xcdTI1OTInLFxuICAgICdibGsxNCc6ICdcXHUyNTkxJyxcbiAgICAnYmxrMzQnOiAnXFx1MjU5MycsXG4gICAgJ2Jsb2NrJzogJ1xcdTI1ODgnLFxuICAgICdibmUnOiAnXFx1MDAzRFxcdTIwRTUnLFxuICAgICdibmVxdWl2JzogJ1xcdTIyNjFcXHUyMEU1JyxcbiAgICAnYm5vdCc6ICdcXHUyMzEwJyxcbiAgICAnYm9wZic6ICdcXHVEODM1XFx1REQ1MycsXG4gICAgJ2Jvd3RpZSc6ICdcXHUyMkM4JyxcbiAgICAnYm94REwnOiAnXFx1MjU1NycsXG4gICAgJ2JveERSJzogJ1xcdTI1NTQnLFxuICAgICdib3hEbCc6ICdcXHUyNTU2JyxcbiAgICAnYm94RHInOiAnXFx1MjU1MycsXG4gICAgJ2JveEgnOiAnXFx1MjU1MCcsXG4gICAgJ2JveEhEJzogJ1xcdTI1NjYnLFxuICAgICdib3hIVSc6ICdcXHUyNTY5JyxcbiAgICAnYm94SGQnOiAnXFx1MjU2NCcsXG4gICAgJ2JveEh1JzogJ1xcdTI1NjcnLFxuICAgICdib3hVTCc6ICdcXHUyNTVEJyxcbiAgICAnYm94VVInOiAnXFx1MjU1QScsXG4gICAgJ2JveFVsJzogJ1xcdTI1NUMnLFxuICAgICdib3hVcic6ICdcXHUyNTU5JyxcbiAgICAnYm94Vic6ICdcXHUyNTUxJyxcbiAgICAnYm94VkgnOiAnXFx1MjU2QycsXG4gICAgJ2JveFZMJzogJ1xcdTI1NjMnLFxuICAgICdib3hWUic6ICdcXHUyNTYwJyxcbiAgICAnYm94VmgnOiAnXFx1MjU2QicsXG4gICAgJ2JveFZsJzogJ1xcdTI1NjInLFxuICAgICdib3hWcic6ICdcXHUyNTVGJyxcbiAgICAnYm94Ym94JzogJ1xcdTI5QzknLFxuICAgICdib3hkTCc6ICdcXHUyNTU1JyxcbiAgICAnYm94ZFInOiAnXFx1MjU1MicsXG4gICAgJ2JveGRsJzogJ1xcdTI1MTAnLFxuICAgICdib3hkcic6ICdcXHUyNTBDJyxcbiAgICAnYm94aEQnOiAnXFx1MjU2NScsXG4gICAgJ2JveGhVJzogJ1xcdTI1NjgnLFxuICAgICdib3hoZCc6ICdcXHUyNTJDJyxcbiAgICAnYm94aHUnOiAnXFx1MjUzNCcsXG4gICAgJ2JveG1pbnVzJzogJ1xcdTIyOUYnLFxuICAgICdtaW51c2InOiAnXFx1MjI5RicsXG4gICAgJ2JveHBsdXMnOiAnXFx1MjI5RScsXG4gICAgJ3BsdXNiJzogJ1xcdTIyOUUnLFxuICAgICdib3h0aW1lcyc6ICdcXHUyMkEwJyxcbiAgICAndGltZXNiJzogJ1xcdTIyQTAnLFxuICAgICdib3h1TCc6ICdcXHUyNTVCJyxcbiAgICAnYm94dVInOiAnXFx1MjU1OCcsXG4gICAgJ2JveHVsJzogJ1xcdTI1MTgnLFxuICAgICdib3h1cic6ICdcXHUyNTE0JyxcbiAgICAnYm94dic6ICdcXHUyNTAyJyxcbiAgICAnYm94dkgnOiAnXFx1MjU2QScsXG4gICAgJ2JveHZMJzogJ1xcdTI1NjEnLFxuICAgICdib3h2Uic6ICdcXHUyNTVFJyxcbiAgICAnYm94dmgnOiAnXFx1MjUzQycsXG4gICAgJ2JveHZsJzogJ1xcdTI1MjQnLFxuICAgICdib3h2cic6ICdcXHUyNTFDJyxcbiAgICAnYnJ2YmFyJzogJ1xcdTAwQTYnLFxuICAgICdic2NyJzogJ1xcdUQ4MzVcXHVEQ0I3JyxcbiAgICAnYnNlbWknOiAnXFx1MjA0RicsXG4gICAgJ2Jzb2wnOiAnXFx1MDA1QycsXG4gICAgJ2Jzb2xiJzogJ1xcdTI5QzUnLFxuICAgICdic29saHN1Yic6ICdcXHUyN0M4JyxcbiAgICAnYnVsbCc6ICdcXHUyMDIyJyxcbiAgICAnYnVsbGV0JzogJ1xcdTIwMjInLFxuICAgICdidW1wRSc6ICdcXHUyQUFFJyxcbiAgICAnY2FjdXRlJzogJ1xcdTAxMDcnLFxuICAgICdjYXAnOiAnXFx1MjIyOScsXG4gICAgJ2NhcGFuZCc6ICdcXHUyQTQ0JyxcbiAgICAnY2FwYnJjdXAnOiAnXFx1MkE0OScsXG4gICAgJ2NhcGNhcCc6ICdcXHUyQTRCJyxcbiAgICAnY2FwY3VwJzogJ1xcdTJBNDcnLFxuICAgICdjYXBkb3QnOiAnXFx1MkE0MCcsXG4gICAgJ2NhcHMnOiAnXFx1MjIyOVxcdUZFMDAnLFxuICAgICdjYXJldCc6ICdcXHUyMDQxJyxcbiAgICAnY2NhcHMnOiAnXFx1MkE0RCcsXG4gICAgJ2NjYXJvbic6ICdcXHUwMTBEJyxcbiAgICAnY2NlZGlsJzogJ1xcdTAwRTcnLFxuICAgICdjY2lyYyc6ICdcXHUwMTA5JyxcbiAgICAnY2N1cHMnOiAnXFx1MkE0QycsXG4gICAgJ2NjdXBzc20nOiAnXFx1MkE1MCcsXG4gICAgJ2Nkb3QnOiAnXFx1MDEwQicsXG4gICAgJ2NlbXB0eXYnOiAnXFx1MjlCMicsXG4gICAgJ2NlbnQnOiAnXFx1MDBBMicsXG4gICAgJ2Nmcic6ICdcXHVEODM1XFx1REQyMCcsXG4gICAgJ2NoY3knOiAnXFx1MDQ0NycsXG4gICAgJ2NoZWNrJzogJ1xcdTI3MTMnLFxuICAgICdjaGVja21hcmsnOiAnXFx1MjcxMycsXG4gICAgJ2NoaSc6ICdcXHUwM0M3JyxcbiAgICAnY2lyJzogJ1xcdTI1Q0InLFxuICAgICdjaXJFJzogJ1xcdTI5QzMnLFxuICAgICdjaXJjJzogJ1xcdTAyQzYnLFxuICAgICdjaXJjZXEnOiAnXFx1MjI1NycsXG4gICAgJ2NpcmUnOiAnXFx1MjI1NycsXG4gICAgJ2NpcmNsZWFycm93bGVmdCc6ICdcXHUyMUJBJyxcbiAgICAnb2xhcnInOiAnXFx1MjFCQScsXG4gICAgJ2NpcmNsZWFycm93cmlnaHQnOiAnXFx1MjFCQicsXG4gICAgJ29yYXJyJzogJ1xcdTIxQkInLFxuICAgICdjaXJjbGVkUyc6ICdcXHUyNEM4JyxcbiAgICAnb1MnOiAnXFx1MjRDOCcsXG4gICAgJ2NpcmNsZWRhc3QnOiAnXFx1MjI5QicsXG4gICAgJ29hc3QnOiAnXFx1MjI5QicsXG4gICAgJ2NpcmNsZWRjaXJjJzogJ1xcdTIyOUEnLFxuICAgICdvY2lyJzogJ1xcdTIyOUEnLFxuICAgICdjaXJjbGVkZGFzaCc6ICdcXHUyMjlEJyxcbiAgICAnb2Rhc2gnOiAnXFx1MjI5RCcsXG4gICAgJ2NpcmZuaW50JzogJ1xcdTJBMTAnLFxuICAgICdjaXJtaWQnOiAnXFx1MkFFRicsXG4gICAgJ2NpcnNjaXInOiAnXFx1MjlDMicsXG4gICAgJ2NsdWJzJzogJ1xcdTI2NjMnLFxuICAgICdjbHVic3VpdCc6ICdcXHUyNjYzJyxcbiAgICAnY29sb24nOiAnXFx1MDAzQScsXG4gICAgJ2NvbW1hJzogJ1xcdTAwMkMnLFxuICAgICdjb21tYXQnOiAnXFx1MDA0MCcsXG4gICAgJ2NvbXAnOiAnXFx1MjIwMScsXG4gICAgJ2NvbXBsZW1lbnQnOiAnXFx1MjIwMScsXG4gICAgJ2Nvbmdkb3QnOiAnXFx1MkE2RCcsXG4gICAgJ2NvcGYnOiAnXFx1RDgzNVxcdURENTQnLFxuICAgICdjb3B5c3InOiAnXFx1MjExNycsXG4gICAgJ2NyYXJyJzogJ1xcdTIxQjUnLFxuICAgICdjcm9zcyc6ICdcXHUyNzE3JyxcbiAgICAnY3Njcic6ICdcXHVEODM1XFx1RENCOCcsXG4gICAgJ2NzdWInOiAnXFx1MkFDRicsXG4gICAgJ2NzdWJlJzogJ1xcdTJBRDEnLFxuICAgICdjc3VwJzogJ1xcdTJBRDAnLFxuICAgICdjc3VwZSc6ICdcXHUyQUQyJyxcbiAgICAnY3Rkb3QnOiAnXFx1MjJFRicsXG4gICAgJ2N1ZGFycmwnOiAnXFx1MjkzOCcsXG4gICAgJ2N1ZGFycnInOiAnXFx1MjkzNScsXG4gICAgJ2N1ZXByJzogJ1xcdTIyREUnLFxuICAgICdjdXJseWVxcHJlYyc6ICdcXHUyMkRFJyxcbiAgICAnY3Vlc2MnOiAnXFx1MjJERicsXG4gICAgJ2N1cmx5ZXFzdWNjJzogJ1xcdTIyREYnLFxuICAgICdjdWxhcnInOiAnXFx1MjFCNicsXG4gICAgJ2N1cnZlYXJyb3dsZWZ0JzogJ1xcdTIxQjYnLFxuICAgICdjdWxhcnJwJzogJ1xcdTI5M0QnLFxuICAgICdjdXAnOiAnXFx1MjIyQScsXG4gICAgJ2N1cGJyY2FwJzogJ1xcdTJBNDgnLFxuICAgICdjdXBjYXAnOiAnXFx1MkE0NicsXG4gICAgJ2N1cGN1cCc6ICdcXHUyQTRBJyxcbiAgICAnY3VwZG90JzogJ1xcdTIyOEQnLFxuICAgICdjdXBvcic6ICdcXHUyQTQ1JyxcbiAgICAnY3Vwcyc6ICdcXHUyMjJBXFx1RkUwMCcsXG4gICAgJ2N1cmFycic6ICdcXHUyMUI3JyxcbiAgICAnY3VydmVhcnJvd3JpZ2h0JzogJ1xcdTIxQjcnLFxuICAgICdjdXJhcnJtJzogJ1xcdTI5M0MnLFxuICAgICdjdXJseXZlZSc6ICdcXHUyMkNFJyxcbiAgICAnY3V2ZWUnOiAnXFx1MjJDRScsXG4gICAgJ2N1cmx5d2VkZ2UnOiAnXFx1MjJDRicsXG4gICAgJ2N1d2VkJzogJ1xcdTIyQ0YnLFxuICAgICdjdXJyZW4nOiAnXFx1MDBBNCcsXG4gICAgJ2N3aW50JzogJ1xcdTIyMzEnLFxuICAgICdjeWxjdHknOiAnXFx1MjMyRCcsXG4gICAgJ2RIYXInOiAnXFx1Mjk2NScsXG4gICAgJ2RhZ2dlcic6ICdcXHUyMDIwJyxcbiAgICAnZGFsZXRoJzogJ1xcdTIxMzgnLFxuICAgICdkYXNoJzogJ1xcdTIwMTAnLFxuICAgICdoeXBoZW4nOiAnXFx1MjAxMCcsXG4gICAgJ2Ria2Fyb3cnOiAnXFx1MjkwRicsXG4gICAgJ3JCYXJyJzogJ1xcdTI5MEYnLFxuICAgICdkY2Fyb24nOiAnXFx1MDEwRicsXG4gICAgJ2RjeSc6ICdcXHUwNDM0JyxcbiAgICAnZGRhcnInOiAnXFx1MjFDQScsXG4gICAgJ2Rvd25kb3duYXJyb3dzJzogJ1xcdTIxQ0EnLFxuICAgICdkZG90c2VxJzogJ1xcdTJBNzcnLFxuICAgICdlRERvdCc6ICdcXHUyQTc3JyxcbiAgICAnZGVnJzogJ1xcdTAwQjAnLFxuICAgICdkZWx0YSc6ICdcXHUwM0I0JyxcbiAgICAnZGVtcHR5dic6ICdcXHUyOUIxJyxcbiAgICAnZGZpc2h0JzogJ1xcdTI5N0YnLFxuICAgICdkZnInOiAnXFx1RDgzNVxcdUREMjEnLFxuICAgICdkaWFtb25kc3VpdCc6ICdcXHUyNjY2JyxcbiAgICAnZGlhbXMnOiAnXFx1MjY2NicsXG4gICAgJ2RpZ2FtbWEnOiAnXFx1MDNERCcsXG4gICAgJ2dhbW1hZCc6ICdcXHUwM0REJyxcbiAgICAnZGlzaW4nOiAnXFx1MjJGMicsXG4gICAgJ2Rpdic6ICdcXHUwMEY3JyxcbiAgICAnZGl2aWRlJzogJ1xcdTAwRjcnLFxuICAgICdkaXZpZGVvbnRpbWVzJzogJ1xcdTIyQzcnLFxuICAgICdkaXZvbngnOiAnXFx1MjJDNycsXG4gICAgJ2RqY3knOiAnXFx1MDQ1MicsXG4gICAgJ2RsY29ybic6ICdcXHUyMzFFJyxcbiAgICAnbGxjb3JuZXInOiAnXFx1MjMxRScsXG4gICAgJ2RsY3JvcCc6ICdcXHUyMzBEJyxcbiAgICAnZG9sbGFyJzogJ1xcdTAwMjQnLFxuICAgICdkb3BmJzogJ1xcdUQ4MzVcXHVERDU1JyxcbiAgICAnZG90ZXFkb3QnOiAnXFx1MjI1MScsXG4gICAgJ2VEb3QnOiAnXFx1MjI1MScsXG4gICAgJ2RvdG1pbnVzJzogJ1xcdTIyMzgnLFxuICAgICdtaW51c2QnOiAnXFx1MjIzOCcsXG4gICAgJ2RvdHBsdXMnOiAnXFx1MjIxNCcsXG4gICAgJ3BsdXNkbyc6ICdcXHUyMjE0JyxcbiAgICAnZG90c3F1YXJlJzogJ1xcdTIyQTEnLFxuICAgICdzZG90Yic6ICdcXHUyMkExJyxcbiAgICAnZHJjb3JuJzogJ1xcdTIzMUYnLFxuICAgICdscmNvcm5lcic6ICdcXHUyMzFGJyxcbiAgICAnZHJjcm9wJzogJ1xcdTIzMEMnLFxuICAgICdkc2NyJzogJ1xcdUQ4MzVcXHVEQ0I5JyxcbiAgICAnZHNjeSc6ICdcXHUwNDU1JyxcbiAgICAnZHNvbCc6ICdcXHUyOUY2JyxcbiAgICAnZHN0cm9rJzogJ1xcdTAxMTEnLFxuICAgICdkdGRvdCc6ICdcXHUyMkYxJyxcbiAgICAnZHRyaSc6ICdcXHUyNUJGJyxcbiAgICAndHJpYW5nbGVkb3duJzogJ1xcdTI1QkYnLFxuICAgICdkd2FuZ2xlJzogJ1xcdTI5QTYnLFxuICAgICdkemN5JzogJ1xcdTA0NUYnLFxuICAgICdkemlncmFycic6ICdcXHUyN0ZGJyxcbiAgICAnZWFjdXRlJzogJ1xcdTAwRTknLFxuICAgICdlYXN0ZXInOiAnXFx1MkE2RScsXG4gICAgJ2VjYXJvbic6ICdcXHUwMTFCJyxcbiAgICAnZWNpcic6ICdcXHUyMjU2JyxcbiAgICAnZXFjaXJjJzogJ1xcdTIyNTYnLFxuICAgICdlY2lyYyc6ICdcXHUwMEVBJyxcbiAgICAnZWNvbG9uJzogJ1xcdTIyNTUnLFxuICAgICdlcWNvbG9uJzogJ1xcdTIyNTUnLFxuICAgICdlY3knOiAnXFx1MDQ0RCcsXG4gICAgJ2Vkb3QnOiAnXFx1MDExNycsXG4gICAgJ2VmRG90JzogJ1xcdTIyNTInLFxuICAgICdmYWxsaW5nZG90c2VxJzogJ1xcdTIyNTInLFxuICAgICdlZnInOiAnXFx1RDgzNVxcdUREMjInLFxuICAgICdlZyc6ICdcXHUyQTlBJyxcbiAgICAnZWdyYXZlJzogJ1xcdTAwRTgnLFxuICAgICdlZ3MnOiAnXFx1MkE5NicsXG4gICAgJ2Vxc2xhbnRndHInOiAnXFx1MkE5NicsXG4gICAgJ2Vnc2RvdCc6ICdcXHUyQTk4JyxcbiAgICAnZWwnOiAnXFx1MkE5OScsXG4gICAgJ2VsaW50ZXJzJzogJ1xcdTIzRTcnLFxuICAgICdlbGwnOiAnXFx1MjExMycsXG4gICAgJ2Vscyc6ICdcXHUyQTk1JyxcbiAgICAnZXFzbGFudGxlc3MnOiAnXFx1MkE5NScsXG4gICAgJ2Vsc2RvdCc6ICdcXHUyQTk3JyxcbiAgICAnZW1hY3InOiAnXFx1MDExMycsXG4gICAgJ2VtcHR5JzogJ1xcdTIyMDUnLFxuICAgICdlbXB0eXNldCc6ICdcXHUyMjA1JyxcbiAgICAnZW1wdHl2JzogJ1xcdTIyMDUnLFxuICAgICd2YXJub3RoaW5nJzogJ1xcdTIyMDUnLFxuICAgICdlbXNwMTMnOiAnXFx1MjAwNCcsXG4gICAgJ2Vtc3AxNCc6ICdcXHUyMDA1JyxcbiAgICAnZW1zcCc6ICdcXHUyMDAzJyxcbiAgICAnZW5nJzogJ1xcdTAxNEInLFxuICAgICdlbnNwJzogJ1xcdTIwMDInLFxuICAgICdlb2dvbic6ICdcXHUwMTE5JyxcbiAgICAnZW9wZic6ICdcXHVEODM1XFx1REQ1NicsXG4gICAgJ2VwYXInOiAnXFx1MjJENScsXG4gICAgJ2VwYXJzbCc6ICdcXHUyOUUzJyxcbiAgICAnZXBsdXMnOiAnXFx1MkE3MScsXG4gICAgJ2Vwc2knOiAnXFx1MDNCNScsXG4gICAgJ2Vwc2lsb24nOiAnXFx1MDNCNScsXG4gICAgJ2Vwc2l2JzogJ1xcdTAzRjUnLFxuICAgICdzdHJhaWdodGVwc2lsb24nOiAnXFx1MDNGNScsXG4gICAgJ3ZhcmVwc2lsb24nOiAnXFx1MDNGNScsXG4gICAgJ2VxdWFscyc6ICdcXHUwMDNEJyxcbiAgICAnZXF1ZXN0JzogJ1xcdTIyNUYnLFxuICAgICdxdWVzdGVxJzogJ1xcdTIyNUYnLFxuICAgICdlcXVpdkREJzogJ1xcdTJBNzgnLFxuICAgICdlcXZwYXJzbCc6ICdcXHUyOUU1JyxcbiAgICAnZXJEb3QnOiAnXFx1MjI1MycsXG4gICAgJ3Jpc2luZ2RvdHNlcSc6ICdcXHUyMjUzJyxcbiAgICAnZXJhcnInOiAnXFx1Mjk3MScsXG4gICAgJ2VzY3InOiAnXFx1MjEyRicsXG4gICAgJ2V0YSc6ICdcXHUwM0I3JyxcbiAgICAnZXRoJzogJ1xcdTAwRjAnLFxuICAgICdldW1sJzogJ1xcdTAwRUInLFxuICAgICdldXJvJzogJ1xcdTIwQUMnLFxuICAgICdleGNsJzogJ1xcdTAwMjEnLFxuICAgICdmY3knOiAnXFx1MDQ0NCcsXG4gICAgJ2ZlbWFsZSc6ICdcXHUyNjQwJyxcbiAgICAnZmZpbGlnJzogJ1xcdUZCMDMnLFxuICAgICdmZmxpZyc6ICdcXHVGQjAwJyxcbiAgICAnZmZsbGlnJzogJ1xcdUZCMDQnLFxuICAgICdmZnInOiAnXFx1RDgzNVxcdUREMjMnLFxuICAgICdmaWxpZyc6ICdcXHVGQjAxJyxcbiAgICAnZmpsaWcnOiAnXFx1MDA2NlxcdTAwNkEnLFxuICAgICdmbGF0JzogJ1xcdTI2NkQnLFxuICAgICdmbGxpZyc6ICdcXHVGQjAyJyxcbiAgICAnZmx0bnMnOiAnXFx1MjVCMScsXG4gICAgJ2Zub2YnOiAnXFx1MDE5MicsXG4gICAgJ2ZvcGYnOiAnXFx1RDgzNVxcdURENTcnLFxuICAgICdmb3JrJzogJ1xcdTIyRDQnLFxuICAgICdwaXRjaGZvcmsnOiAnXFx1MjJENCcsXG4gICAgJ2Zvcmt2JzogJ1xcdTJBRDknLFxuICAgICdmcGFydGludCc6ICdcXHUyQTBEJyxcbiAgICAnZnJhYzEyJzogJ1xcdTAwQkQnLFxuICAgICdoYWxmJzogJ1xcdTAwQkQnLFxuICAgICdmcmFjMTMnOiAnXFx1MjE1MycsXG4gICAgJ2ZyYWMxNCc6ICdcXHUwMEJDJyxcbiAgICAnZnJhYzE1JzogJ1xcdTIxNTUnLFxuICAgICdmcmFjMTYnOiAnXFx1MjE1OScsXG4gICAgJ2ZyYWMxOCc6ICdcXHUyMTVCJyxcbiAgICAnZnJhYzIzJzogJ1xcdTIxNTQnLFxuICAgICdmcmFjMjUnOiAnXFx1MjE1NicsXG4gICAgJ2ZyYWMzNCc6ICdcXHUwMEJFJyxcbiAgICAnZnJhYzM1JzogJ1xcdTIxNTcnLFxuICAgICdmcmFjMzgnOiAnXFx1MjE1QycsXG4gICAgJ2ZyYWM0NSc6ICdcXHUyMTU4JyxcbiAgICAnZnJhYzU2JzogJ1xcdTIxNUEnLFxuICAgICdmcmFjNTgnOiAnXFx1MjE1RCcsXG4gICAgJ2ZyYWM3OCc6ICdcXHUyMTVFJyxcbiAgICAnZnJhc2wnOiAnXFx1MjA0NCcsXG4gICAgJ2Zyb3duJzogJ1xcdTIzMjInLFxuICAgICdzZnJvd24nOiAnXFx1MjMyMicsXG4gICAgJ2ZzY3InOiAnXFx1RDgzNVxcdURDQkInLFxuICAgICdnRWwnOiAnXFx1MkE4QycsXG4gICAgJ2d0cmVxcWxlc3MnOiAnXFx1MkE4QycsXG4gICAgJ2dhY3V0ZSc6ICdcXHUwMUY1JyxcbiAgICAnZ2FtbWEnOiAnXFx1MDNCMycsXG4gICAgJ2dhcCc6ICdcXHUyQTg2JyxcbiAgICAnZ3RyYXBwcm94JzogJ1xcdTJBODYnLFxuICAgICdnYnJldmUnOiAnXFx1MDExRicsXG4gICAgJ2djaXJjJzogJ1xcdTAxMUQnLFxuICAgICdnY3knOiAnXFx1MDQzMycsXG4gICAgJ2dkb3QnOiAnXFx1MDEyMScsXG4gICAgJ2dlc2NjJzogJ1xcdTJBQTknLFxuICAgICdnZXNkb3QnOiAnXFx1MkE4MCcsXG4gICAgJ2dlc2RvdG8nOiAnXFx1MkE4MicsXG4gICAgJ2dlc2RvdG9sJzogJ1xcdTJBODQnLFxuICAgICdnZXNsJzogJ1xcdTIyREJcXHVGRTAwJyxcbiAgICAnZ2VzbGVzJzogJ1xcdTJBOTQnLFxuICAgICdnZnInOiAnXFx1RDgzNVxcdUREMjQnLFxuICAgICdnaW1lbCc6ICdcXHUyMTM3JyxcbiAgICAnZ2pjeSc6ICdcXHUwNDUzJyxcbiAgICAnZ2xFJzogJ1xcdTJBOTInLFxuICAgICdnbGEnOiAnXFx1MkFBNScsXG4gICAgJ2dsaic6ICdcXHUyQUE0JyxcbiAgICAnZ25FJzogJ1xcdTIyNjknLFxuICAgICdnbmVxcSc6ICdcXHUyMjY5JyxcbiAgICAnZ25hcCc6ICdcXHUyQThBJyxcbiAgICAnZ25hcHByb3gnOiAnXFx1MkE4QScsXG4gICAgJ2duZSc6ICdcXHUyQTg4JyxcbiAgICAnZ25lcSc6ICdcXHUyQTg4JyxcbiAgICAnZ25zaW0nOiAnXFx1MjJFNycsXG4gICAgJ2dvcGYnOiAnXFx1RDgzNVxcdURENTgnLFxuICAgICdnc2NyJzogJ1xcdTIxMEEnLFxuICAgICdnc2ltZSc6ICdcXHUyQThFJyxcbiAgICAnZ3NpbWwnOiAnXFx1MkE5MCcsXG4gICAgJ2d0Y2MnOiAnXFx1MkFBNycsXG4gICAgJ2d0Y2lyJzogJ1xcdTJBN0EnLFxuICAgICdndGRvdCc6ICdcXHUyMkQ3JyxcbiAgICAnZ3RyZG90JzogJ1xcdTIyRDcnLFxuICAgICdndGxQYXInOiAnXFx1Mjk5NScsXG4gICAgJ2d0cXVlc3QnOiAnXFx1MkE3QycsXG4gICAgJ2d0cmFycic6ICdcXHUyOTc4JyxcbiAgICAnZ3ZlcnRuZXFxJzogJ1xcdTIyNjlcXHVGRTAwJyxcbiAgICAnZ3ZuRSc6ICdcXHUyMjY5XFx1RkUwMCcsXG4gICAgJ2hhcmRjeSc6ICdcXHUwNDRBJyxcbiAgICAnaGFycmNpcic6ICdcXHUyOTQ4JyxcbiAgICAnaGFycncnOiAnXFx1MjFBRCcsXG4gICAgJ2xlZnRyaWdodHNxdWlnYXJyb3cnOiAnXFx1MjFBRCcsXG4gICAgJ2hiYXInOiAnXFx1MjEwRicsXG4gICAgJ2hzbGFzaCc6ICdcXHUyMTBGJyxcbiAgICAncGxhbmNrJzogJ1xcdTIxMEYnLFxuICAgICdwbGFua3YnOiAnXFx1MjEwRicsXG4gICAgJ2hjaXJjJzogJ1xcdTAxMjUnLFxuICAgICdoZWFydHMnOiAnXFx1MjY2NScsXG4gICAgJ2hlYXJ0c3VpdCc6ICdcXHUyNjY1JyxcbiAgICAnaGVsbGlwJzogJ1xcdTIwMjYnLFxuICAgICdtbGRyJzogJ1xcdTIwMjYnLFxuICAgICdoZXJjb24nOiAnXFx1MjJCOScsXG4gICAgJ2hmcic6ICdcXHVEODM1XFx1REQyNScsXG4gICAgJ2hrc2Vhcm93JzogJ1xcdTI5MjUnLFxuICAgICdzZWFyaGsnOiAnXFx1MjkyNScsXG4gICAgJ2hrc3dhcm93JzogJ1xcdTI5MjYnLFxuICAgICdzd2FyaGsnOiAnXFx1MjkyNicsXG4gICAgJ2hvYXJyJzogJ1xcdTIxRkYnLFxuICAgICdob210aHQnOiAnXFx1MjIzQicsXG4gICAgJ2hvb2tsZWZ0YXJyb3cnOiAnXFx1MjFBOScsXG4gICAgJ2xhcnJoayc6ICdcXHUyMUE5JyxcbiAgICAnaG9va3JpZ2h0YXJyb3cnOiAnXFx1MjFBQScsXG4gICAgJ3JhcnJoayc6ICdcXHUyMUFBJyxcbiAgICAnaG9wZic6ICdcXHVEODM1XFx1REQ1OScsXG4gICAgJ2hvcmJhcic6ICdcXHUyMDE1JyxcbiAgICAnaHNjcic6ICdcXHVEODM1XFx1RENCRCcsXG4gICAgJ2hzdHJvayc6ICdcXHUwMTI3JyxcbiAgICAnaHlidWxsJzogJ1xcdTIwNDMnLFxuICAgICdpYWN1dGUnOiAnXFx1MDBFRCcsXG4gICAgJ2ljaXJjJzogJ1xcdTAwRUUnLFxuICAgICdpY3knOiAnXFx1MDQzOCcsXG4gICAgJ2llY3knOiAnXFx1MDQzNScsXG4gICAgJ2lleGNsJzogJ1xcdTAwQTEnLFxuICAgICdpZnInOiAnXFx1RDgzNVxcdUREMjYnLFxuICAgICdpZ3JhdmUnOiAnXFx1MDBFQycsXG4gICAgJ2lpaWludCc6ICdcXHUyQTBDJyxcbiAgICAncWludCc6ICdcXHUyQTBDJyxcbiAgICAnaWlpbnQnOiAnXFx1MjIyRCcsXG4gICAgJ3RpbnQnOiAnXFx1MjIyRCcsXG4gICAgJ2lpbmZpbic6ICdcXHUyOURDJyxcbiAgICAnaWlvdGEnOiAnXFx1MjEyOScsXG4gICAgJ2lqbGlnJzogJ1xcdTAxMzMnLFxuICAgICdpbWFjcic6ICdcXHUwMTJCJyxcbiAgICAnaW1hdGgnOiAnXFx1MDEzMScsXG4gICAgJ2lub2RvdCc6ICdcXHUwMTMxJyxcbiAgICAnaW1vZic6ICdcXHUyMkI3JyxcbiAgICAnaW1wZWQnOiAnXFx1MDFCNScsXG4gICAgJ2luY2FyZSc6ICdcXHUyMTA1JyxcbiAgICAnaW5maW4nOiAnXFx1MjIxRScsXG4gICAgJ2luZmludGllJzogJ1xcdTI5REQnLFxuICAgICdpbnRjYWwnOiAnXFx1MjJCQScsXG4gICAgJ2ludGVyY2FsJzogJ1xcdTIyQkEnLFxuICAgICdpbnRsYXJoayc6ICdcXHUyQTE3JyxcbiAgICAnaW50cHJvZCc6ICdcXHUyQTNDJyxcbiAgICAnaXByb2QnOiAnXFx1MkEzQycsXG4gICAgJ2lvY3knOiAnXFx1MDQ1MScsXG4gICAgJ2lvZ29uJzogJ1xcdTAxMkYnLFxuICAgICdpb3BmJzogJ1xcdUQ4MzVcXHVERDVBJyxcbiAgICAnaW90YSc6ICdcXHUwM0I5JyxcbiAgICAnaXF1ZXN0JzogJ1xcdTAwQkYnLFxuICAgICdpc2NyJzogJ1xcdUQ4MzVcXHVEQ0JFJyxcbiAgICAnaXNpbkUnOiAnXFx1MjJGOScsXG4gICAgJ2lzaW5kb3QnOiAnXFx1MjJGNScsXG4gICAgJ2lzaW5zJzogJ1xcdTIyRjQnLFxuICAgICdpc2luc3YnOiAnXFx1MjJGMycsXG4gICAgJ2l0aWxkZSc6ICdcXHUwMTI5JyxcbiAgICAnaXVrY3knOiAnXFx1MDQ1NicsXG4gICAgJ2l1bWwnOiAnXFx1MDBFRicsXG4gICAgJ2pjaXJjJzogJ1xcdTAxMzUnLFxuICAgICdqY3knOiAnXFx1MDQzOScsXG4gICAgJ2pmcic6ICdcXHVEODM1XFx1REQyNycsXG4gICAgJ2ptYXRoJzogJ1xcdTAyMzcnLFxuICAgICdqb3BmJzogJ1xcdUQ4MzVcXHVERDVCJyxcbiAgICAnanNjcic6ICdcXHVEODM1XFx1RENCRicsXG4gICAgJ2pzZXJjeSc6ICdcXHUwNDU4JyxcbiAgICAnanVrY3knOiAnXFx1MDQ1NCcsXG4gICAgJ2thcHBhJzogJ1xcdTAzQkEnLFxuICAgICdrYXBwYXYnOiAnXFx1MDNGMCcsXG4gICAgJ3ZhcmthcHBhJzogJ1xcdTAzRjAnLFxuICAgICdrY2VkaWwnOiAnXFx1MDEzNycsXG4gICAgJ2tjeSc6ICdcXHUwNDNBJyxcbiAgICAna2ZyJzogJ1xcdUQ4MzVcXHVERDI4JyxcbiAgICAna2dyZWVuJzogJ1xcdTAxMzgnLFxuICAgICdraGN5JzogJ1xcdTA0NDUnLFxuICAgICdramN5JzogJ1xcdTA0NUMnLFxuICAgICdrb3BmJzogJ1xcdUQ4MzVcXHVERDVDJyxcbiAgICAna3Njcic6ICdcXHVEODM1XFx1RENDMCcsXG4gICAgJ2xBdGFpbCc6ICdcXHUyOTFCJyxcbiAgICAnbEJhcnInOiAnXFx1MjkwRScsXG4gICAgJ2xFZyc6ICdcXHUyQThCJyxcbiAgICAnbGVzc2VxcWd0cic6ICdcXHUyQThCJyxcbiAgICAnbEhhcic6ICdcXHUyOTYyJyxcbiAgICAnbGFjdXRlJzogJ1xcdTAxM0EnLFxuICAgICdsYWVtcHR5dic6ICdcXHUyOUI0JyxcbiAgICAnbGFtYmRhJzogJ1xcdTAzQkInLFxuICAgICdsYW5nZCc6ICdcXHUyOTkxJyxcbiAgICAnbGFwJzogJ1xcdTJBODUnLFxuICAgICdsZXNzYXBwcm94JzogJ1xcdTJBODUnLFxuICAgICdsYXF1byc6ICdcXHUwMEFCJyxcbiAgICAnbGFycmJmcyc6ICdcXHUyOTFGJyxcbiAgICAnbGFycmZzJzogJ1xcdTI5MUQnLFxuICAgICdsYXJybHAnOiAnXFx1MjFBQicsXG4gICAgJ2xvb3BhcnJvd2xlZnQnOiAnXFx1MjFBQicsXG4gICAgJ2xhcnJwbCc6ICdcXHUyOTM5JyxcbiAgICAnbGFycnNpbSc6ICdcXHUyOTczJyxcbiAgICAnbGFycnRsJzogJ1xcdTIxQTInLFxuICAgICdsZWZ0YXJyb3d0YWlsJzogJ1xcdTIxQTInLFxuICAgICdsYXQnOiAnXFx1MkFBQicsXG4gICAgJ2xhdGFpbCc6ICdcXHUyOTE5JyxcbiAgICAnbGF0ZSc6ICdcXHUyQUFEJyxcbiAgICAnbGF0ZXMnOiAnXFx1MkFBRFxcdUZFMDAnLFxuICAgICdsYmFycic6ICdcXHUyOTBDJyxcbiAgICAnbGJicmsnOiAnXFx1Mjc3MicsXG4gICAgJ2xicmFjZSc6ICdcXHUwMDdCJyxcbiAgICAnbGN1Yic6ICdcXHUwMDdCJyxcbiAgICAnbGJyYWNrJzogJ1xcdTAwNUInLFxuICAgICdsc3FiJzogJ1xcdTAwNUInLFxuICAgICdsYnJrZSc6ICdcXHUyOThCJyxcbiAgICAnbGJya3NsZCc6ICdcXHUyOThGJyxcbiAgICAnbGJya3NsdSc6ICdcXHUyOThEJyxcbiAgICAnbGNhcm9uJzogJ1xcdTAxM0UnLFxuICAgICdsY2VkaWwnOiAnXFx1MDEzQycsXG4gICAgJ2xjeSc6ICdcXHUwNDNCJyxcbiAgICAnbGRjYSc6ICdcXHUyOTM2JyxcbiAgICAnbGRyZGhhcic6ICdcXHUyOTY3JyxcbiAgICAnbGRydXNoYXInOiAnXFx1Mjk0QicsXG4gICAgJ2xkc2gnOiAnXFx1MjFCMicsXG4gICAgJ2xlJzogJ1xcdTIyNjQnLFxuICAgICdsZXEnOiAnXFx1MjI2NCcsXG4gICAgJ2xlZnRsZWZ0YXJyb3dzJzogJ1xcdTIxQzcnLFxuICAgICdsbGFycic6ICdcXHUyMUM3JyxcbiAgICAnbGVmdHRocmVldGltZXMnOiAnXFx1MjJDQicsXG4gICAgJ2x0aHJlZSc6ICdcXHUyMkNCJyxcbiAgICAnbGVzY2MnOiAnXFx1MkFBOCcsXG4gICAgJ2xlc2RvdCc6ICdcXHUyQTdGJyxcbiAgICAnbGVzZG90byc6ICdcXHUyQTgxJyxcbiAgICAnbGVzZG90b3InOiAnXFx1MkE4MycsXG4gICAgJ2xlc2cnOiAnXFx1MjJEQVxcdUZFMDAnLFxuICAgICdsZXNnZXMnOiAnXFx1MkE5MycsXG4gICAgJ2xlc3Nkb3QnOiAnXFx1MjJENicsXG4gICAgJ2x0ZG90JzogJ1xcdTIyRDYnLFxuICAgICdsZmlzaHQnOiAnXFx1Mjk3QycsXG4gICAgJ2xmcic6ICdcXHVEODM1XFx1REQyOScsXG4gICAgJ2xnRSc6ICdcXHUyQTkxJyxcbiAgICAnbGhhcnVsJzogJ1xcdTI5NkEnLFxuICAgICdsaGJsayc6ICdcXHUyNTg0JyxcbiAgICAnbGpjeSc6ICdcXHUwNDU5JyxcbiAgICAnbGxoYXJkJzogJ1xcdTI5NkInLFxuICAgICdsbHRyaSc6ICdcXHUyNUZBJyxcbiAgICAnbG1pZG90JzogJ1xcdTAxNDAnLFxuICAgICdsbW91c3QnOiAnXFx1MjNCMCcsXG4gICAgJ2xtb3VzdGFjaGUnOiAnXFx1MjNCMCcsXG4gICAgJ2xuRSc6ICdcXHUyMjY4JyxcbiAgICAnbG5lcXEnOiAnXFx1MjI2OCcsXG4gICAgJ2xuYXAnOiAnXFx1MkE4OScsXG4gICAgJ2xuYXBwcm94JzogJ1xcdTJBODknLFxuICAgICdsbmUnOiAnXFx1MkE4NycsXG4gICAgJ2xuZXEnOiAnXFx1MkE4NycsXG4gICAgJ2xuc2ltJzogJ1xcdTIyRTYnLFxuICAgICdsb2FuZyc6ICdcXHUyN0VDJyxcbiAgICAnbG9hcnInOiAnXFx1MjFGRCcsXG4gICAgJ2xvbmdtYXBzdG8nOiAnXFx1MjdGQycsXG4gICAgJ3htYXAnOiAnXFx1MjdGQycsXG4gICAgJ2xvb3BhcnJvd3JpZ2h0JzogJ1xcdTIxQUMnLFxuICAgICdyYXJybHAnOiAnXFx1MjFBQycsXG4gICAgJ2xvcGFyJzogJ1xcdTI5ODUnLFxuICAgICdsb3BmJzogJ1xcdUQ4MzVcXHVERDVEJyxcbiAgICAnbG9wbHVzJzogJ1xcdTJBMkQnLFxuICAgICdsb3RpbWVzJzogJ1xcdTJBMzQnLFxuICAgICdsb3dhc3QnOiAnXFx1MjIxNycsXG4gICAgJ2xveic6ICdcXHUyNUNBJyxcbiAgICAnbG96ZW5nZSc6ICdcXHUyNUNBJyxcbiAgICAnbHBhcic6ICdcXHUwMDI4JyxcbiAgICAnbHBhcmx0JzogJ1xcdTI5OTMnLFxuICAgICdscmhhcmQnOiAnXFx1Mjk2RCcsXG4gICAgJ2xybSc6ICdcXHUyMDBFJyxcbiAgICAnbHJ0cmknOiAnXFx1MjJCRicsXG4gICAgJ2xzYXF1byc6ICdcXHUyMDM5JyxcbiAgICAnbHNjcic6ICdcXHVEODM1XFx1RENDMScsXG4gICAgJ2xzaW1lJzogJ1xcdTJBOEQnLFxuICAgICdsc2ltZyc6ICdcXHUyQThGJyxcbiAgICAnbHNxdW9yJzogJ1xcdTIwMUEnLFxuICAgICdzYnF1byc6ICdcXHUyMDFBJyxcbiAgICAnbHN0cm9rJzogJ1xcdTAxNDInLFxuICAgICdsdGNjJzogJ1xcdTJBQTYnLFxuICAgICdsdGNpcic6ICdcXHUyQTc5JyxcbiAgICAnbHRpbWVzJzogJ1xcdTIyQzknLFxuICAgICdsdGxhcnInOiAnXFx1Mjk3NicsXG4gICAgJ2x0cXVlc3QnOiAnXFx1MkE3QicsXG4gICAgJ2x0clBhcic6ICdcXHUyOTk2JyxcbiAgICAnbHRyaSc6ICdcXHUyNUMzJyxcbiAgICAndHJpYW5nbGVsZWZ0JzogJ1xcdTI1QzMnLFxuICAgICdsdXJkc2hhcic6ICdcXHUyOTRBJyxcbiAgICAnbHVydWhhcic6ICdcXHUyOTY2JyxcbiAgICAnbHZlcnRuZXFxJzogJ1xcdTIyNjhcXHVGRTAwJyxcbiAgICAnbHZuRSc6ICdcXHUyMjY4XFx1RkUwMCcsXG4gICAgJ21ERG90JzogJ1xcdTIyM0EnLFxuICAgICdtYWNyJzogJ1xcdTAwQUYnLFxuICAgICdzdHJucyc6ICdcXHUwMEFGJyxcbiAgICAnbWFsZSc6ICdcXHUyNjQyJyxcbiAgICAnbWFsdCc6ICdcXHUyNzIwJyxcbiAgICAnbWFsdGVzZSc6ICdcXHUyNzIwJyxcbiAgICAnbWFya2VyJzogJ1xcdTI1QUUnLFxuICAgICdtY29tbWEnOiAnXFx1MkEyOScsXG4gICAgJ21jeSc6ICdcXHUwNDNDJyxcbiAgICAnbWRhc2gnOiAnXFx1MjAxNCcsXG4gICAgJ21mcic6ICdcXHVEODM1XFx1REQyQScsXG4gICAgJ21obyc6ICdcXHUyMTI3JyxcbiAgICAnbWljcm8nOiAnXFx1MDBCNScsXG4gICAgJ21pZGNpcic6ICdcXHUyQUYwJyxcbiAgICAnbWludXMnOiAnXFx1MjIxMicsXG4gICAgJ21pbnVzZHUnOiAnXFx1MkEyQScsXG4gICAgJ21sY3AnOiAnXFx1MkFEQicsXG4gICAgJ21vZGVscyc6ICdcXHUyMkE3JyxcbiAgICAnbW9wZic6ICdcXHVEODM1XFx1REQ1RScsXG4gICAgJ21zY3InOiAnXFx1RDgzNVxcdURDQzInLFxuICAgICdtdSc6ICdcXHUwM0JDJyxcbiAgICAnbXVsdGltYXAnOiAnXFx1MjJCOCcsXG4gICAgJ211bWFwJzogJ1xcdTIyQjgnLFxuICAgICduR2cnOiAnXFx1MjJEOVxcdTAzMzgnLFxuICAgICduR3QnOiAnXFx1MjI2QlxcdTIwRDInLFxuICAgICduTGVmdGFycm93JzogJ1xcdTIxQ0QnLFxuICAgICdubEFycic6ICdcXHUyMUNEJyxcbiAgICAnbkxlZnRyaWdodGFycm93JzogJ1xcdTIxQ0UnLFxuICAgICduaEFycic6ICdcXHUyMUNFJyxcbiAgICAnbkxsJzogJ1xcdTIyRDhcXHUwMzM4JyxcbiAgICAnbkx0JzogJ1xcdTIyNkFcXHUyMEQyJyxcbiAgICAnblJpZ2h0YXJyb3cnOiAnXFx1MjFDRicsXG4gICAgJ25yQXJyJzogJ1xcdTIxQ0YnLFxuICAgICduVkRhc2gnOiAnXFx1MjJBRicsXG4gICAgJ25WZGFzaCc6ICdcXHUyMkFFJyxcbiAgICAnbmFjdXRlJzogJ1xcdTAxNDQnLFxuICAgICduYW5nJzogJ1xcdTIyMjBcXHUyMEQyJyxcbiAgICAnbmFwRSc6ICdcXHUyQTcwXFx1MDMzOCcsXG4gICAgJ25hcGlkJzogJ1xcdTIyNEJcXHUwMzM4JyxcbiAgICAnbmFwb3MnOiAnXFx1MDE0OScsXG4gICAgJ25hdHVyJzogJ1xcdTI2NkUnLFxuICAgICduYXR1cmFsJzogJ1xcdTI2NkUnLFxuICAgICduY2FwJzogJ1xcdTJBNDMnLFxuICAgICduY2Fyb24nOiAnXFx1MDE0OCcsXG4gICAgJ25jZWRpbCc6ICdcXHUwMTQ2JyxcbiAgICAnbmNvbmdkb3QnOiAnXFx1MkE2RFxcdTAzMzgnLFxuICAgICduY3VwJzogJ1xcdTJBNDInLFxuICAgICduY3knOiAnXFx1MDQzRCcsXG4gICAgJ25kYXNoJzogJ1xcdTIwMTMnLFxuICAgICduZUFycic6ICdcXHUyMUQ3JyxcbiAgICAnbmVhcmhrJzogJ1xcdTI5MjQnLFxuICAgICduZWRvdCc6ICdcXHUyMjUwXFx1MDMzOCcsXG4gICAgJ25lc2Vhcic6ICdcXHUyOTI4JyxcbiAgICAndG9lYSc6ICdcXHUyOTI4JyxcbiAgICAnbmZyJzogJ1xcdUQ4MzVcXHVERDJCJyxcbiAgICAnbmhhcnInOiAnXFx1MjFBRScsXG4gICAgJ25sZWZ0cmlnaHRhcnJvdyc6ICdcXHUyMUFFJyxcbiAgICAnbmhwYXInOiAnXFx1MkFGMicsXG4gICAgJ25pcyc6ICdcXHUyMkZDJyxcbiAgICAnbmlzZCc6ICdcXHUyMkZBJyxcbiAgICAnbmpjeSc6ICdcXHUwNDVBJyxcbiAgICAnbmxFJzogJ1xcdTIyNjZcXHUwMzM4JyxcbiAgICAnbmxlcXEnOiAnXFx1MjI2NlxcdTAzMzgnLFxuICAgICdubGFycic6ICdcXHUyMTlBJyxcbiAgICAnbmxlZnRhcnJvdyc6ICdcXHUyMTlBJyxcbiAgICAnbmxkcic6ICdcXHUyMDI1JyxcbiAgICAnbm9wZic6ICdcXHVEODM1XFx1REQ1RicsXG4gICAgJ25vdCc6ICdcXHUwMEFDJyxcbiAgICAnbm90aW5FJzogJ1xcdTIyRjlcXHUwMzM4JyxcbiAgICAnbm90aW5kb3QnOiAnXFx1MjJGNVxcdTAzMzgnLFxuICAgICdub3RpbnZiJzogJ1xcdTIyRjcnLFxuICAgICdub3RpbnZjJzogJ1xcdTIyRjYnLFxuICAgICdub3RuaXZiJzogJ1xcdTIyRkUnLFxuICAgICdub3RuaXZjJzogJ1xcdTIyRkQnLFxuICAgICducGFyc2wnOiAnXFx1MkFGRFxcdTIwRTUnLFxuICAgICducGFydCc6ICdcXHUyMjAyXFx1MDMzOCcsXG4gICAgJ25wb2xpbnQnOiAnXFx1MkExNCcsXG4gICAgJ25yYXJyJzogJ1xcdTIxOUInLFxuICAgICducmlnaHRhcnJvdyc6ICdcXHUyMTlCJyxcbiAgICAnbnJhcnJjJzogJ1xcdTI5MzNcXHUwMzM4JyxcbiAgICAnbnJhcnJ3JzogJ1xcdTIxOURcXHUwMzM4JyxcbiAgICAnbnNjcic6ICdcXHVEODM1XFx1RENDMycsXG4gICAgJ25zdWInOiAnXFx1MjI4NCcsXG4gICAgJ25zdWJFJzogJ1xcdTJBQzVcXHUwMzM4JyxcbiAgICAnbnN1YnNldGVxcSc6ICdcXHUyQUM1XFx1MDMzOCcsXG4gICAgJ25zdXAnOiAnXFx1MjI4NScsXG4gICAgJ25zdXBFJzogJ1xcdTJBQzZcXHUwMzM4JyxcbiAgICAnbnN1cHNldGVxcSc6ICdcXHUyQUM2XFx1MDMzOCcsXG4gICAgJ250aWxkZSc6ICdcXHUwMEYxJyxcbiAgICAnbnUnOiAnXFx1MDNCRCcsXG4gICAgJ251bSc6ICdcXHUwMDIzJyxcbiAgICAnbnVtZXJvJzogJ1xcdTIxMTYnLFxuICAgICdudW1zcCc6ICdcXHUyMDA3JyxcbiAgICAnbnZEYXNoJzogJ1xcdTIyQUQnLFxuICAgICdudkhhcnInOiAnXFx1MjkwNCcsXG4gICAgJ252YXAnOiAnXFx1MjI0RFxcdTIwRDInLFxuICAgICdudmRhc2gnOiAnXFx1MjJBQycsXG4gICAgJ252Z2UnOiAnXFx1MjI2NVxcdTIwRDInLFxuICAgICdudmd0JzogJ1xcdTAwM0VcXHUyMEQyJyxcbiAgICAnbnZpbmZpbic6ICdcXHUyOURFJyxcbiAgICAnbnZsQXJyJzogJ1xcdTI5MDInLFxuICAgICdudmxlJzogJ1xcdTIyNjRcXHUyMEQyJyxcbiAgICAnbnZsdCc6ICdcXHUwMDNDXFx1MjBEMicsXG4gICAgJ252bHRyaWUnOiAnXFx1MjJCNFxcdTIwRDInLFxuICAgICdudnJBcnInOiAnXFx1MjkwMycsXG4gICAgJ252cnRyaWUnOiAnXFx1MjJCNVxcdTIwRDInLFxuICAgICdudnNpbSc6ICdcXHUyMjNDXFx1MjBEMicsXG4gICAgJ253QXJyJzogJ1xcdTIxRDYnLFxuICAgICdud2FyaGsnOiAnXFx1MjkyMycsXG4gICAgJ253bmVhcic6ICdcXHUyOTI3JyxcbiAgICAnb2FjdXRlJzogJ1xcdTAwRjMnLFxuICAgICdvY2lyYyc6ICdcXHUwMEY0JyxcbiAgICAnb2N5JzogJ1xcdTA0M0UnLFxuICAgICdvZGJsYWMnOiAnXFx1MDE1MScsXG4gICAgJ29kaXYnOiAnXFx1MkEzOCcsXG4gICAgJ29kc29sZCc6ICdcXHUyOUJDJyxcbiAgICAnb2VsaWcnOiAnXFx1MDE1MycsXG4gICAgJ29mY2lyJzogJ1xcdTI5QkYnLFxuICAgICdvZnInOiAnXFx1RDgzNVxcdUREMkMnLFxuICAgICdvZ29uJzogJ1xcdTAyREInLFxuICAgICdvZ3JhdmUnOiAnXFx1MDBGMicsXG4gICAgJ29ndCc6ICdcXHUyOUMxJyxcbiAgICAnb2hiYXInOiAnXFx1MjlCNScsXG4gICAgJ29sY2lyJzogJ1xcdTI5QkUnLFxuICAgICdvbGNyb3NzJzogJ1xcdTI5QkInLFxuICAgICdvbHQnOiAnXFx1MjlDMCcsXG4gICAgJ29tYWNyJzogJ1xcdTAxNEQnLFxuICAgICdvbWVnYSc6ICdcXHUwM0M5JyxcbiAgICAnb21pY3Jvbic6ICdcXHUwM0JGJyxcbiAgICAnb21pZCc6ICdcXHUyOUI2JyxcbiAgICAnb29wZic6ICdcXHVEODM1XFx1REQ2MCcsXG4gICAgJ29wYXInOiAnXFx1MjlCNycsXG4gICAgJ29wZXJwJzogJ1xcdTI5QjknLFxuICAgICdvcic6ICdcXHUyMjI4JyxcbiAgICAndmVlJzogJ1xcdTIyMjgnLFxuICAgICdvcmQnOiAnXFx1MkE1RCcsXG4gICAgJ29yZGVyJzogJ1xcdTIxMzQnLFxuICAgICdvcmRlcm9mJzogJ1xcdTIxMzQnLFxuICAgICdvc2NyJzogJ1xcdTIxMzQnLFxuICAgICdvcmRmJzogJ1xcdTAwQUEnLFxuICAgICdvcmRtJzogJ1xcdTAwQkEnLFxuICAgICdvcmlnb2YnOiAnXFx1MjJCNicsXG4gICAgJ29yb3InOiAnXFx1MkE1NicsXG4gICAgJ29yc2xvcGUnOiAnXFx1MkE1NycsXG4gICAgJ29ydic6ICdcXHUyQTVCJyxcbiAgICAnb3NsYXNoJzogJ1xcdTAwRjgnLFxuICAgICdvc29sJzogJ1xcdTIyOTgnLFxuICAgICdvdGlsZGUnOiAnXFx1MDBGNScsXG4gICAgJ290aW1lc2FzJzogJ1xcdTJBMzYnLFxuICAgICdvdW1sJzogJ1xcdTAwRjYnLFxuICAgICdvdmJhcic6ICdcXHUyMzNEJyxcbiAgICAncGFyYSc6ICdcXHUwMEI2JyxcbiAgICAncGFyc2ltJzogJ1xcdTJBRjMnLFxuICAgICdwYXJzbCc6ICdcXHUyQUZEJyxcbiAgICAncGN5JzogJ1xcdTA0M0YnLFxuICAgICdwZXJjbnQnOiAnXFx1MDAyNScsXG4gICAgJ3BlcmlvZCc6ICdcXHUwMDJFJyxcbiAgICAncGVybWlsJzogJ1xcdTIwMzAnLFxuICAgICdwZXJ0ZW5rJzogJ1xcdTIwMzEnLFxuICAgICdwZnInOiAnXFx1RDgzNVxcdUREMkQnLFxuICAgICdwaGknOiAnXFx1MDNDNicsXG4gICAgJ3BoaXYnOiAnXFx1MDNENScsXG4gICAgJ3N0cmFpZ2h0cGhpJzogJ1xcdTAzRDUnLFxuICAgICd2YXJwaGknOiAnXFx1MDNENScsXG4gICAgJ3Bob25lJzogJ1xcdTI2MEUnLFxuICAgICdwaSc6ICdcXHUwM0MwJyxcbiAgICAncGl2JzogJ1xcdTAzRDYnLFxuICAgICd2YXJwaSc6ICdcXHUwM0Q2JyxcbiAgICAncGxhbmNraCc6ICdcXHUyMTBFJyxcbiAgICAncGx1cyc6ICdcXHUwMDJCJyxcbiAgICAncGx1c2FjaXInOiAnXFx1MkEyMycsXG4gICAgJ3BsdXNjaXInOiAnXFx1MkEyMicsXG4gICAgJ3BsdXNkdSc6ICdcXHUyQTI1JyxcbiAgICAncGx1c2UnOiAnXFx1MkE3MicsXG4gICAgJ3BsdXNzaW0nOiAnXFx1MkEyNicsXG4gICAgJ3BsdXN0d28nOiAnXFx1MkEyNycsXG4gICAgJ3BvaW50aW50JzogJ1xcdTJBMTUnLFxuICAgICdwb3BmJzogJ1xcdUQ4MzVcXHVERDYxJyxcbiAgICAncG91bmQnOiAnXFx1MDBBMycsXG4gICAgJ3ByRSc6ICdcXHUyQUIzJyxcbiAgICAncHJhcCc6ICdcXHUyQUI3JyxcbiAgICAncHJlY2FwcHJveCc6ICdcXHUyQUI3JyxcbiAgICAncHJlY25hcHByb3gnOiAnXFx1MkFCOScsXG4gICAgJ3BybmFwJzogJ1xcdTJBQjknLFxuICAgICdwcmVjbmVxcSc6ICdcXHUyQUI1JyxcbiAgICAncHJuRSc6ICdcXHUyQUI1JyxcbiAgICAncHJlY25zaW0nOiAnXFx1MjJFOCcsXG4gICAgJ3BybnNpbSc6ICdcXHUyMkU4JyxcbiAgICAncHJpbWUnOiAnXFx1MjAzMicsXG4gICAgJ3Byb2ZhbGFyJzogJ1xcdTIzMkUnLFxuICAgICdwcm9mbGluZSc6ICdcXHUyMzEyJyxcbiAgICAncHJvZnN1cmYnOiAnXFx1MjMxMycsXG4gICAgJ3BydXJlbCc6ICdcXHUyMkIwJyxcbiAgICAncHNjcic6ICdcXHVEODM1XFx1RENDNScsXG4gICAgJ3BzaSc6ICdcXHUwM0M4JyxcbiAgICAncHVuY3NwJzogJ1xcdTIwMDgnLFxuICAgICdxZnInOiAnXFx1RDgzNVxcdUREMkUnLFxuICAgICdxb3BmJzogJ1xcdUQ4MzVcXHVERDYyJyxcbiAgICAncXByaW1lJzogJ1xcdTIwNTcnLFxuICAgICdxc2NyJzogJ1xcdUQ4MzVcXHVEQ0M2JyxcbiAgICAncXVhdGludCc6ICdcXHUyQTE2JyxcbiAgICAncXVlc3QnOiAnXFx1MDAzRicsXG4gICAgJ3JBdGFpbCc6ICdcXHUyOTFDJyxcbiAgICAnckhhcic6ICdcXHUyOTY0JyxcbiAgICAncmFjZSc6ICdcXHUyMjNEXFx1MDMzMScsXG4gICAgJ3JhY3V0ZSc6ICdcXHUwMTU1JyxcbiAgICAncmFlbXB0eXYnOiAnXFx1MjlCMycsXG4gICAgJ3JhbmdkJzogJ1xcdTI5OTInLFxuICAgICdyYW5nZSc6ICdcXHUyOUE1JyxcbiAgICAncmFxdW8nOiAnXFx1MDBCQicsXG4gICAgJ3JhcnJhcCc6ICdcXHUyOTc1JyxcbiAgICAncmFycmJmcyc6ICdcXHUyOTIwJyxcbiAgICAncmFycmMnOiAnXFx1MjkzMycsXG4gICAgJ3JhcnJmcyc6ICdcXHUyOTFFJyxcbiAgICAncmFycnBsJzogJ1xcdTI5NDUnLFxuICAgICdyYXJyc2ltJzogJ1xcdTI5NzQnLFxuICAgICdyYXJydGwnOiAnXFx1MjFBMycsXG4gICAgJ3JpZ2h0YXJyb3d0YWlsJzogJ1xcdTIxQTMnLFxuICAgICdyYXJydyc6ICdcXHUyMTlEJyxcbiAgICAncmlnaHRzcXVpZ2Fycm93JzogJ1xcdTIxOUQnLFxuICAgICdyYXRhaWwnOiAnXFx1MjkxQScsXG4gICAgJ3JhdGlvJzogJ1xcdTIyMzYnLFxuICAgICdyYmJyayc6ICdcXHUyNzczJyxcbiAgICAncmJyYWNlJzogJ1xcdTAwN0QnLFxuICAgICdyY3ViJzogJ1xcdTAwN0QnLFxuICAgICdyYnJhY2snOiAnXFx1MDA1RCcsXG4gICAgJ3JzcWInOiAnXFx1MDA1RCcsXG4gICAgJ3JicmtlJzogJ1xcdTI5OEMnLFxuICAgICdyYnJrc2xkJzogJ1xcdTI5OEUnLFxuICAgICdyYnJrc2x1JzogJ1xcdTI5OTAnLFxuICAgICdyY2Fyb24nOiAnXFx1MDE1OScsXG4gICAgJ3JjZWRpbCc6ICdcXHUwMTU3JyxcbiAgICAncmN5JzogJ1xcdTA0NDAnLFxuICAgICdyZGNhJzogJ1xcdTI5MzcnLFxuICAgICdyZGxkaGFyJzogJ1xcdTI5NjknLFxuICAgICdyZHNoJzogJ1xcdTIxQjMnLFxuICAgICdyZWN0JzogJ1xcdTI1QUQnLFxuICAgICdyZmlzaHQnOiAnXFx1Mjk3RCcsXG4gICAgJ3Jmcic6ICdcXHVEODM1XFx1REQyRicsXG4gICAgJ3JoYXJ1bCc6ICdcXHUyOTZDJyxcbiAgICAncmhvJzogJ1xcdTAzQzEnLFxuICAgICdyaG92JzogJ1xcdTAzRjEnLFxuICAgICd2YXJyaG8nOiAnXFx1MDNGMScsXG4gICAgJ3JpZ2h0cmlnaHRhcnJvd3MnOiAnXFx1MjFDOScsXG4gICAgJ3JyYXJyJzogJ1xcdTIxQzknLFxuICAgICdyaWdodHRocmVldGltZXMnOiAnXFx1MjJDQycsXG4gICAgJ3J0aHJlZSc6ICdcXHUyMkNDJyxcbiAgICAncmluZyc6ICdcXHUwMkRBJyxcbiAgICAncmxtJzogJ1xcdTIwMEYnLFxuICAgICdybW91c3QnOiAnXFx1MjNCMScsXG4gICAgJ3Jtb3VzdGFjaGUnOiAnXFx1MjNCMScsXG4gICAgJ3JubWlkJzogJ1xcdTJBRUUnLFxuICAgICdyb2FuZyc6ICdcXHUyN0VEJyxcbiAgICAncm9hcnInOiAnXFx1MjFGRScsXG4gICAgJ3JvcGFyJzogJ1xcdTI5ODYnLFxuICAgICdyb3BmJzogJ1xcdUQ4MzVcXHVERDYzJyxcbiAgICAncm9wbHVzJzogJ1xcdTJBMkUnLFxuICAgICdyb3RpbWVzJzogJ1xcdTJBMzUnLFxuICAgICdycGFyJzogJ1xcdTAwMjknLFxuICAgICdycGFyZ3QnOiAnXFx1Mjk5NCcsXG4gICAgJ3JwcG9saW50JzogJ1xcdTJBMTInLFxuICAgICdyc2FxdW8nOiAnXFx1MjAzQScsXG4gICAgJ3JzY3InOiAnXFx1RDgzNVxcdURDQzcnLFxuICAgICdydGltZXMnOiAnXFx1MjJDQScsXG4gICAgJ3J0cmknOiAnXFx1MjVCOScsXG4gICAgJ3RyaWFuZ2xlcmlnaHQnOiAnXFx1MjVCOScsXG4gICAgJ3J0cmlsdHJpJzogJ1xcdTI5Q0UnLFxuICAgICdydWx1aGFyJzogJ1xcdTI5NjgnLFxuICAgICdyeCc6ICdcXHUyMTFFJyxcbiAgICAnc2FjdXRlJzogJ1xcdTAxNUInLFxuICAgICdzY0UnOiAnXFx1MkFCNCcsXG4gICAgJ3NjYXAnOiAnXFx1MkFCOCcsXG4gICAgJ3N1Y2NhcHByb3gnOiAnXFx1MkFCOCcsXG4gICAgJ3NjYXJvbic6ICdcXHUwMTYxJyxcbiAgICAnc2NlZGlsJzogJ1xcdTAxNUYnLFxuICAgICdzY2lyYyc6ICdcXHUwMTVEJyxcbiAgICAnc2NuRSc6ICdcXHUyQUI2JyxcbiAgICAnc3VjY25lcXEnOiAnXFx1MkFCNicsXG4gICAgJ3NjbmFwJzogJ1xcdTJBQkEnLFxuICAgICdzdWNjbmFwcHJveCc6ICdcXHUyQUJBJyxcbiAgICAnc2Nuc2ltJzogJ1xcdTIyRTknLFxuICAgICdzdWNjbnNpbSc6ICdcXHUyMkU5JyxcbiAgICAnc2Nwb2xpbnQnOiAnXFx1MkExMycsXG4gICAgJ3NjeSc6ICdcXHUwNDQxJyxcbiAgICAnc2RvdCc6ICdcXHUyMkM1JyxcbiAgICAnc2RvdGUnOiAnXFx1MkE2NicsXG4gICAgJ3NlQXJyJzogJ1xcdTIxRDgnLFxuICAgICdzZWN0JzogJ1xcdTAwQTcnLFxuICAgICdzZW1pJzogJ1xcdTAwM0InLFxuICAgICdzZXN3YXInOiAnXFx1MjkyOScsXG4gICAgJ3Rvc2EnOiAnXFx1MjkyOScsXG4gICAgJ3NleHQnOiAnXFx1MjczNicsXG4gICAgJ3Nmcic6ICdcXHVEODM1XFx1REQzMCcsXG4gICAgJ3NoYXJwJzogJ1xcdTI2NkYnLFxuICAgICdzaGNoY3knOiAnXFx1MDQ0OScsXG4gICAgJ3NoY3knOiAnXFx1MDQ0OCcsXG4gICAgJ3NoeSc6ICdcXHUwMEFEJyxcbiAgICAnc2lnbWEnOiAnXFx1MDNDMycsXG4gICAgJ3NpZ21hZic6ICdcXHUwM0MyJyxcbiAgICAnc2lnbWF2JzogJ1xcdTAzQzInLFxuICAgICd2YXJzaWdtYSc6ICdcXHUwM0MyJyxcbiAgICAnc2ltZG90JzogJ1xcdTJBNkEnLFxuICAgICdzaW1nJzogJ1xcdTJBOUUnLFxuICAgICdzaW1nRSc6ICdcXHUyQUEwJyxcbiAgICAnc2ltbCc6ICdcXHUyQTlEJyxcbiAgICAnc2ltbEUnOiAnXFx1MkE5RicsXG4gICAgJ3NpbW5lJzogJ1xcdTIyNDYnLFxuICAgICdzaW1wbHVzJzogJ1xcdTJBMjQnLFxuICAgICdzaW1yYXJyJzogJ1xcdTI5NzInLFxuICAgICdzbWFzaHAnOiAnXFx1MkEzMycsXG4gICAgJ3NtZXBhcnNsJzogJ1xcdTI5RTQnLFxuICAgICdzbWlsZSc6ICdcXHUyMzIzJyxcbiAgICAnc3NtaWxlJzogJ1xcdTIzMjMnLFxuICAgICdzbXQnOiAnXFx1MkFBQScsXG4gICAgJ3NtdGUnOiAnXFx1MkFBQycsXG4gICAgJ3NtdGVzJzogJ1xcdTJBQUNcXHVGRTAwJyxcbiAgICAnc29mdGN5JzogJ1xcdTA0NEMnLFxuICAgICdzb2wnOiAnXFx1MDAyRicsXG4gICAgJ3NvbGInOiAnXFx1MjlDNCcsXG4gICAgJ3NvbGJhcic6ICdcXHUyMzNGJyxcbiAgICAnc29wZic6ICdcXHVEODM1XFx1REQ2NCcsXG4gICAgJ3NwYWRlcyc6ICdcXHUyNjYwJyxcbiAgICAnc3BhZGVzdWl0JzogJ1xcdTI2NjAnLFxuICAgICdzcWNhcHMnOiAnXFx1MjI5M1xcdUZFMDAnLFxuICAgICdzcWN1cHMnOiAnXFx1MjI5NFxcdUZFMDAnLFxuICAgICdzc2NyJzogJ1xcdUQ4MzVcXHVEQ0M4JyxcbiAgICAnc3Rhcic6ICdcXHUyNjA2JyxcbiAgICAnc3ViJzogJ1xcdTIyODInLFxuICAgICdzdWJzZXQnOiAnXFx1MjI4MicsXG4gICAgJ3N1YkUnOiAnXFx1MkFDNScsXG4gICAgJ3N1YnNldGVxcSc6ICdcXHUyQUM1JyxcbiAgICAnc3ViZG90JzogJ1xcdTJBQkQnLFxuICAgICdzdWJlZG90JzogJ1xcdTJBQzMnLFxuICAgICdzdWJtdWx0JzogJ1xcdTJBQzEnLFxuICAgICdzdWJuRSc6ICdcXHUyQUNCJyxcbiAgICAnc3Vic2V0bmVxcSc6ICdcXHUyQUNCJyxcbiAgICAnc3VibmUnOiAnXFx1MjI4QScsXG4gICAgJ3N1YnNldG5lcSc6ICdcXHUyMjhBJyxcbiAgICAnc3VicGx1cyc6ICdcXHUyQUJGJyxcbiAgICAnc3VicmFycic6ICdcXHUyOTc5JyxcbiAgICAnc3Vic2ltJzogJ1xcdTJBQzcnLFxuICAgICdzdWJzdWInOiAnXFx1MkFENScsXG4gICAgJ3N1YnN1cCc6ICdcXHUyQUQzJyxcbiAgICAnc3VuZyc6ICdcXHUyNjZBJyxcbiAgICAnc3VwMSc6ICdcXHUwMEI5JyxcbiAgICAnc3VwMic6ICdcXHUwMEIyJyxcbiAgICAnc3VwMyc6ICdcXHUwMEIzJyxcbiAgICAnc3VwRSc6ICdcXHUyQUM2JyxcbiAgICAnc3Vwc2V0ZXFxJzogJ1xcdTJBQzYnLFxuICAgICdzdXBkb3QnOiAnXFx1MkFCRScsXG4gICAgJ3N1cGRzdWInOiAnXFx1MkFEOCcsXG4gICAgJ3N1cGVkb3QnOiAnXFx1MkFDNCcsXG4gICAgJ3N1cGhzb2wnOiAnXFx1MjdDOScsXG4gICAgJ3N1cGhzdWInOiAnXFx1MkFENycsXG4gICAgJ3N1cGxhcnInOiAnXFx1Mjk3QicsXG4gICAgJ3N1cG11bHQnOiAnXFx1MkFDMicsXG4gICAgJ3N1cG5FJzogJ1xcdTJBQ0MnLFxuICAgICdzdXBzZXRuZXFxJzogJ1xcdTJBQ0MnLFxuICAgICdzdXBuZSc6ICdcXHUyMjhCJyxcbiAgICAnc3Vwc2V0bmVxJzogJ1xcdTIyOEInLFxuICAgICdzdXBwbHVzJzogJ1xcdTJBQzAnLFxuICAgICdzdXBzaW0nOiAnXFx1MkFDOCcsXG4gICAgJ3N1cHN1Yic6ICdcXHUyQUQ0JyxcbiAgICAnc3Vwc3VwJzogJ1xcdTJBRDYnLFxuICAgICdzd0Fycic6ICdcXHUyMUQ5JyxcbiAgICAnc3dud2FyJzogJ1xcdTI5MkEnLFxuICAgICdzemxpZyc6ICdcXHUwMERGJyxcbiAgICAndGFyZ2V0JzogJ1xcdTIzMTYnLFxuICAgICd0YXUnOiAnXFx1MDNDNCcsXG4gICAgJ3RjYXJvbic6ICdcXHUwMTY1JyxcbiAgICAndGNlZGlsJzogJ1xcdTAxNjMnLFxuICAgICd0Y3knOiAnXFx1MDQ0MicsXG4gICAgJ3RlbHJlYyc6ICdcXHUyMzE1JyxcbiAgICAndGZyJzogJ1xcdUQ4MzVcXHVERDMxJyxcbiAgICAndGhldGEnOiAnXFx1MDNCOCcsXG4gICAgJ3RoZXRhc3ltJzogJ1xcdTAzRDEnLFxuICAgICd0aGV0YXYnOiAnXFx1MDNEMScsXG4gICAgJ3ZhcnRoZXRhJzogJ1xcdTAzRDEnLFxuICAgICd0aG9ybic6ICdcXHUwMEZFJyxcbiAgICAndGltZXMnOiAnXFx1MDBENycsXG4gICAgJ3RpbWVzYmFyJzogJ1xcdTJBMzEnLFxuICAgICd0aW1lc2QnOiAnXFx1MkEzMCcsXG4gICAgJ3RvcGJvdCc6ICdcXHUyMzM2JyxcbiAgICAndG9wY2lyJzogJ1xcdTJBRjEnLFxuICAgICd0b3BmJzogJ1xcdUQ4MzVcXHVERDY1JyxcbiAgICAndG9wZm9yayc6ICdcXHUyQURBJyxcbiAgICAndHByaW1lJzogJ1xcdTIwMzQnLFxuICAgICd0cmlhbmdsZSc6ICdcXHUyNUI1JyxcbiAgICAndXRyaSc6ICdcXHUyNUI1JyxcbiAgICAndHJpYW5nbGVxJzogJ1xcdTIyNUMnLFxuICAgICd0cmllJzogJ1xcdTIyNUMnLFxuICAgICd0cmlkb3QnOiAnXFx1MjVFQycsXG4gICAgJ3RyaW1pbnVzJzogJ1xcdTJBM0EnLFxuICAgICd0cmlwbHVzJzogJ1xcdTJBMzknLFxuICAgICd0cmlzYic6ICdcXHUyOUNEJyxcbiAgICAndHJpdGltZSc6ICdcXHUyQTNCJyxcbiAgICAndHJwZXppdW0nOiAnXFx1MjNFMicsXG4gICAgJ3RzY3InOiAnXFx1RDgzNVxcdURDQzknLFxuICAgICd0c2N5JzogJ1xcdTA0NDYnLFxuICAgICd0c2hjeSc6ICdcXHUwNDVCJyxcbiAgICAndHN0cm9rJzogJ1xcdTAxNjcnLFxuICAgICd1SGFyJzogJ1xcdTI5NjMnLFxuICAgICd1YWN1dGUnOiAnXFx1MDBGQScsXG4gICAgJ3VicmN5JzogJ1xcdTA0NUUnLFxuICAgICd1YnJldmUnOiAnXFx1MDE2RCcsXG4gICAgJ3VjaXJjJzogJ1xcdTAwRkInLFxuICAgICd1Y3knOiAnXFx1MDQ0MycsXG4gICAgJ3VkYmxhYyc6ICdcXHUwMTcxJyxcbiAgICAndWZpc2h0JzogJ1xcdTI5N0UnLFxuICAgICd1ZnInOiAnXFx1RDgzNVxcdUREMzInLFxuICAgICd1Z3JhdmUnOiAnXFx1MDBGOScsXG4gICAgJ3VoYmxrJzogJ1xcdTI1ODAnLFxuICAgICd1bGNvcm4nOiAnXFx1MjMxQycsXG4gICAgJ3VsY29ybmVyJzogJ1xcdTIzMUMnLFxuICAgICd1bGNyb3AnOiAnXFx1MjMwRicsXG4gICAgJ3VsdHJpJzogJ1xcdTI1RjgnLFxuICAgICd1bWFjcic6ICdcXHUwMTZCJyxcbiAgICAndW9nb24nOiAnXFx1MDE3MycsXG4gICAgJ3VvcGYnOiAnXFx1RDgzNVxcdURENjYnLFxuICAgICd1cHNpJzogJ1xcdTAzQzUnLFxuICAgICd1cHNpbG9uJzogJ1xcdTAzQzUnLFxuICAgICd1cHVwYXJyb3dzJzogJ1xcdTIxQzgnLFxuICAgICd1dWFycic6ICdcXHUyMUM4JyxcbiAgICAndXJjb3JuJzogJ1xcdTIzMUQnLFxuICAgICd1cmNvcm5lcic6ICdcXHUyMzFEJyxcbiAgICAndXJjcm9wJzogJ1xcdTIzMEUnLFxuICAgICd1cmluZyc6ICdcXHUwMTZGJyxcbiAgICAndXJ0cmknOiAnXFx1MjVGOScsXG4gICAgJ3VzY3InOiAnXFx1RDgzNVxcdURDQ0EnLFxuICAgICd1dGRvdCc6ICdcXHUyMkYwJyxcbiAgICAndXRpbGRlJzogJ1xcdTAxNjknLFxuICAgICd1dW1sJzogJ1xcdTAwRkMnLFxuICAgICd1d2FuZ2xlJzogJ1xcdTI5QTcnLFxuICAgICd2QmFyJzogJ1xcdTJBRTgnLFxuICAgICd2QmFydic6ICdcXHUyQUU5JyxcbiAgICAndmFuZ3J0JzogJ1xcdTI5OUMnLFxuICAgICd2YXJzdWJzZXRuZXEnOiAnXFx1MjI4QVxcdUZFMDAnLFxuICAgICd2c3VibmUnOiAnXFx1MjI4QVxcdUZFMDAnLFxuICAgICd2YXJzdWJzZXRuZXFxJzogJ1xcdTJBQ0JcXHVGRTAwJyxcbiAgICAndnN1Ym5FJzogJ1xcdTJBQ0JcXHVGRTAwJyxcbiAgICAndmFyc3Vwc2V0bmVxJzogJ1xcdTIyOEJcXHVGRTAwJyxcbiAgICAndnN1cG5lJzogJ1xcdTIyOEJcXHVGRTAwJyxcbiAgICAndmFyc3Vwc2V0bmVxcSc6ICdcXHUyQUNDXFx1RkUwMCcsXG4gICAgJ3ZzdXBuRSc6ICdcXHUyQUNDXFx1RkUwMCcsXG4gICAgJ3ZjeSc6ICdcXHUwNDMyJyxcbiAgICAndmVlYmFyJzogJ1xcdTIyQkInLFxuICAgICd2ZWVlcSc6ICdcXHUyMjVBJyxcbiAgICAndmVsbGlwJzogJ1xcdTIyRUUnLFxuICAgICd2ZnInOiAnXFx1RDgzNVxcdUREMzMnLFxuICAgICd2b3BmJzogJ1xcdUQ4MzVcXHVERDY3JyxcbiAgICAndnNjcic6ICdcXHVEODM1XFx1RENDQicsXG4gICAgJ3Z6aWd6YWcnOiAnXFx1Mjk5QScsXG4gICAgJ3djaXJjJzogJ1xcdTAxNzUnLFxuICAgICd3ZWRiYXInOiAnXFx1MkE1RicsXG4gICAgJ3dlZGdlcSc6ICdcXHUyMjU5JyxcbiAgICAnd2VpZXJwJzogJ1xcdTIxMTgnLFxuICAgICd3cCc6ICdcXHUyMTE4JyxcbiAgICAnd2ZyJzogJ1xcdUQ4MzVcXHVERDM0JyxcbiAgICAnd29wZic6ICdcXHVEODM1XFx1REQ2OCcsXG4gICAgJ3dzY3InOiAnXFx1RDgzNVxcdURDQ0MnLFxuICAgICd4ZnInOiAnXFx1RDgzNVxcdUREMzUnLFxuICAgICd4aSc6ICdcXHUwM0JFJyxcbiAgICAneG5pcyc6ICdcXHUyMkZCJyxcbiAgICAneG9wZic6ICdcXHVEODM1XFx1REQ2OScsXG4gICAgJ3hzY3InOiAnXFx1RDgzNVxcdURDQ0QnLFxuICAgICd5YWN1dGUnOiAnXFx1MDBGRCcsXG4gICAgJ3lhY3knOiAnXFx1MDQ0RicsXG4gICAgJ3ljaXJjJzogJ1xcdTAxNzcnLFxuICAgICd5Y3knOiAnXFx1MDQ0QicsXG4gICAgJ3llbic6ICdcXHUwMEE1JyxcbiAgICAneWZyJzogJ1xcdUQ4MzVcXHVERDM2JyxcbiAgICAneWljeSc6ICdcXHUwNDU3JyxcbiAgICAneW9wZic6ICdcXHVEODM1XFx1REQ2QScsXG4gICAgJ3lzY3InOiAnXFx1RDgzNVxcdURDQ0UnLFxuICAgICd5dWN5JzogJ1xcdTA0NEUnLFxuICAgICd5dW1sJzogJ1xcdTAwRkYnLFxuICAgICd6YWN1dGUnOiAnXFx1MDE3QScsXG4gICAgJ3pjYXJvbic6ICdcXHUwMTdFJyxcbiAgICAnemN5JzogJ1xcdTA0MzcnLFxuICAgICd6ZG90JzogJ1xcdTAxN0MnLFxuICAgICd6ZXRhJzogJ1xcdTAzQjYnLFxuICAgICd6ZnInOiAnXFx1RDgzNVxcdUREMzcnLFxuICAgICd6aGN5JzogJ1xcdTA0MzYnLFxuICAgICd6aWdyYXJyJzogJ1xcdTIxREQnLFxuICAgICd6b3BmJzogJ1xcdUQ4MzVcXHVERDZCJyxcbiAgICAnenNjcic6ICdcXHVEODM1XFx1RENDRicsXG4gICAgJ3p3aic6ICdcXHUyMDBEJyxcbiAgICAnenduaic6ICdcXHUyMDBDJ1xufTtcbi8vIFRoZSAmbmdzcDsgcHNldWRvLWVudGl0eSBpcyBkZW5vdGluZyBhIHNwYWNlLiBzZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFydC1sYW5nL2FuZ3VsYXIvYmxvYi8wYmI2MTEzODdkMjlkNjViNWFmN2Y5ZDI1MTVhYjU3MWZkM2ZiZWU0L190ZXN0cy90ZXN0L2NvbXBpbGVyL3ByZXNlcnZlX3doaXRlc3BhY2VfdGVzdC5kYXJ0XG5jb25zdCBOR1NQX1VOSUNPREUgPSAnXFx1RTUwMCc7XG5OQU1FRF9FTlRJVElFU1snbmdzcCddID0gTkdTUF9VTklDT0RFO1xuXG5jbGFzcyBUb2tlbkVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JNc2csIHRva2VuVHlwZSwgc3Bhbikge1xuICAgICAgICBzdXBlcihzcGFuLCBlcnJvck1zZyk7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgIH1cbn1cbmNsYXNzIFRva2VuaXplUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlbnMsIGVycm9ycywgbm9uTm9ybWFsaXplZEljdUV4cHJlc3Npb25zKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5ub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnMgPSBub25Ob3JtYWxpemVkSWN1RXhwcmVzc2lvbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gdG9rZW5pemUoc291cmNlLCB1cmwsIGdldFRhZ0RlZmluaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRva2VuaXplciA9IG5ldyBfVG9rZW5pemVyKG5ldyBQYXJzZVNvdXJjZUZpbGUoc291cmNlLCB1cmwpLCBnZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB0b2tlbml6ZXIudG9rZW5pemUoKTtcbiAgICByZXR1cm4gbmV3IFRva2VuaXplUmVzdWx0KG1lcmdlVGV4dFRva2Vucyh0b2tlbml6ZXIudG9rZW5zKSwgdG9rZW5pemVyLmVycm9ycywgdG9rZW5pemVyLm5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucyk7XG59XG5jb25zdCBfQ1JfT1JfQ1JMRl9SRUdFWFAgPSAvXFxyXFxuPy9nO1xuZnVuY3Rpb24gX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhjaGFyQ29kZSkge1xuICAgIGNvbnN0IGNoYXIgPSBjaGFyQ29kZSA9PT0gJEVPRiA/ICdFT0YnIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAgcmV0dXJuIGBVbmV4cGVjdGVkIGNoYXJhY3RlciBcIiR7Y2hhcn1cImA7XG59XG5mdW5jdGlvbiBfdW5rbm93bkVudGl0eUVycm9yTXNnKGVudGl0eVNyYykge1xuICAgIHJldHVybiBgVW5rbm93biBlbnRpdHkgXCIke2VudGl0eVNyY31cIiAtIHVzZSB0aGUgXCImIzxkZWNpbWFsPjtcIiBvciAgXCImI3g8aGV4PjtcIiBzeW50YXhgO1xufVxuZnVuY3Rpb24gX3VucGFyc2FibGVFbnRpdHlFcnJvck1zZyh0eXBlLCBlbnRpdHlTdHIpIHtcbiAgICByZXR1cm4gYFVuYWJsZSB0byBwYXJzZSBlbnRpdHkgXCIke2VudGl0eVN0cn1cIiAtICR7dHlwZX0gY2hhcmFjdGVyIHJlZmVyZW5jZSBlbnRpdGllcyBtdXN0IGVuZCB3aXRoIFwiO1wiYDtcbn1cbnZhciBDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlO1xuKGZ1bmN0aW9uIChDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZVtcIkhFWFwiXSA9IFwiaGV4YWRlY2ltYWxcIjtcbiAgICBDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlW1wiREVDXCJdID0gXCJkZWNpbWFsXCI7XG59KShDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlIHx8IChDaGFyYWN0ZXJSZWZlcmVuY2VUeXBlID0ge30pKTtcbmNsYXNzIF9Db250cm9sRmxvd0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgfVxufVxuLy8gU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTEvc3ludGF4Lmh0bWwjd3JpdGluZy1odG1sLWRvY3VtZW50c1xuY2xhc3MgX1Rva2VuaXplciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIF9maWxlIFRoZSBodG1sIHNvdXJjZSBmaWxlIGJlaW5nIHRva2VuaXplZC5cbiAgICAgKiBAcGFyYW0gX2dldFRhZ0RlZmluaXRpb24gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0cmlldmUgYSB0YWcgZGVmaW5pdGlvbiBmb3IgYSBnaXZlbiB0YWcgbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9mIHRoZSB0b2tlbml6YXRpb24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoX2ZpbGUsIF9nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2dldFRhZ0RlZmluaXRpb24gPSBfZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5UeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2luSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLm5vbk5vcm1hbGl6ZWRJY3VFeHByZXNzaW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl90b2tlbml6ZUljdSA9IG9wdGlvbnMudG9rZW5pemVFeHBhbnNpb25Gb3JtcyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IG9wdGlvbnMuaW50ZXJwb2xhdGlvbkNvbmZpZyB8fCBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgICAgICB0aGlzLl9sZWFkaW5nVHJpdmlhQ29kZVBvaW50cyA9XG4gICAgICAgICAgICBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycyAmJiBvcHRpb25zLmxlYWRpbmdUcml2aWFDaGFycy5tYXAoYyA9PiBjLmNvZGVQb2ludEF0KDApIHx8IDApO1xuICAgICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMucmFuZ2UgfHwgeyBlbmRQb3M6IF9maWxlLmNvbnRlbnQubGVuZ3RoLCBzdGFydFBvczogMCwgc3RhcnRMaW5lOiAwLCBzdGFydENvbDogMCB9O1xuICAgICAgICB0aGlzLl9jdXJzb3IgPSBvcHRpb25zLmVzY2FwZWRTdHJpbmcgPyBuZXcgRXNjYXBlZENoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpIDpcbiAgICAgICAgICAgIG5ldyBQbGFpbkNoYXJhY3RlckN1cnNvcihfZmlsZSwgcmFuZ2UpO1xuICAgICAgICB0aGlzLl9wcmVzZXJ2ZUxpbmVFbmRpbmdzID0gb3B0aW9ucy5wcmVzZXJ2ZUxpbmVFbmRpbmdzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9lc2NhcGVkU3RyaW5nID0gb3B0aW9ucy5lc2NhcGVkU3RyaW5nIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLl9pMThuTm9ybWFsaXplTGluZUVuZGluZ3NJbklDVXMgPSBvcHRpb25zLmkxOG5Ob3JtYWxpemVMaW5lRW5kaW5nc0luSUNVcyB8fCBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMoY29udGVudCkge1xuICAgICAgICBpZiAodGhpcy5fcHJlc2VydmVMaW5lRW5kaW5ncykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1MS9zeW50YXguaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgICAgICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgb3JpZ2luYWwgcG9zaXRpb24gaW4gdGhlIHNvdXJjZSwgd2UgY2FuIG5vdFxuICAgICAgICAvLyBwcmUtcHJvY2VzcyBpdC5cbiAgICAgICAgLy8gSW5zdGVhZCBDUnMgYXJlIHByb2Nlc3NlZCByaWdodCBiZWZvcmUgaW5zdGFudGlhdGluZyB0aGUgdG9rZW5zLlxuICAgICAgICByZXR1cm4gY29udGVudC5yZXBsYWNlKF9DUl9PUl9DUkxGX1JFR0VYUCwgJ1xcbicpO1xuICAgIH1cbiAgICB0b2tlbml6ZSgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRFT0YpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJExUKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRCQU5HKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTEJSQUNLRVQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNkYXRhKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTUlOVVMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUNvbW1lbnQoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZURvY1R5cGUoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGFnQ2xvc2Uoc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVRhZ09wZW4oc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fdG9rZW5pemVJY3UgJiYgdGhpcy5fdG9rZW5pemVFeHBhbnNpb25Gb3JtKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIChwb3NzaWJseSBpbnRlcnBvbGF0ZWQpIHRleHQgdGhlIGVuZCBvZiB0aGUgdGV4dCBpcyBnaXZlbiBieSBgaXNUZXh0RW5kKClgLCB3aGlsZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcHJlbWF0dXJlIGVuZCBvZiBhbiBpbnRlcnBvbGF0aW9uIGlzIGdpdmVuIGJ5IHRoZSBzdGFydCBvZiBhIG5ldyBIVE1MIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVXaXRoSW50ZXJwb2xhdGlvbig1IC8qIFRva2VuVHlwZS5URVhUICovLCA4IC8qIFRva2VuVHlwZS5JTlRFUlBPTEFUSU9OICovLCAoKSA9PiB0aGlzLl9pc1RleHRFbmQoKSwgKCkgPT4gdGhpcy5faXNUYWdTdGFydCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyNCAvKiBUb2tlblR5cGUuRU9GICovKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB3aGV0aGVyIGFuIElDVSB0b2tlbiBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3Rva2VuaXplRXhwYW5zaW9uRm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFeHBhbnNpb25Gb3JtU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZUV4cGFuc2lvbkZvcm1TdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRXhwYW5zaW9uQ2FzZVN0YXJ0KHRoaXMuX2N1cnNvci5wZWVrKCkpICYmIHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlU3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkUkJSQUNFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25DYXNlRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbkV4cGFuc2lvbkZvcm0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYmVnaW5Ub2tlbih0eXBlLCBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBfZW5kVG9rZW4ocGFydHMsIGVuZCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRva2VuU3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUb2tlbkVycm9yKCdQcm9ncmFtbWluZyBlcnJvciAtIGF0dGVtcHRlZCB0byBlbmQgYSB0b2tlbiB3aGVuIHRoZXJlIHdhcyBubyBzdGFydCB0byB0aGUgdG9rZW4nLCB0aGlzLl9jdXJyZW50VG9rZW5UeXBlLCB0aGlzLl9jdXJzb3IuZ2V0U3BhbihlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRva2VuVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRva2VuRXJyb3IoJ1Byb2dyYW1taW5nIGVycm9yIC0gYXR0ZW1wdGVkIHRvIGVuZCBhIHRva2VuIHdoaWNoIGhhcyBubyB0b2tlbiB0eXBlJywgbnVsbCwgdGhpcy5fY3Vyc29yLmdldFNwYW4odGhpcy5fY3VycmVudFRva2VuU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX2N1cnJlbnRUb2tlblR5cGUsXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIHNvdXJjZVNwYW46IChlbmQgPz8gdGhpcy5fY3Vyc29yKS5nZXRTcGFuKHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0LCB0aGlzLl9sZWFkaW5nVHJpdmlhQ29kZVBvaW50cyksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB0aGlzLl9jdXJyZW50VG9rZW5TdGFydCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblR5cGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIF9jcmVhdGVFcnJvcihtc2csIHNwYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzSW5FeHBhbnNpb25Gb3JtKCkpIHtcbiAgICAgICAgICAgIG1zZyArPSBgIChEbyB5b3UgaGF2ZSBhbiB1bmVzY2FwZWQgXCJ7XCIgaW4geW91ciB0ZW1wbGF0ZT8gVXNlIFwie3sgJ3snIH19XCIpIHRvIGVzY2FwZSBpdC4pYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUb2tlbkVycm9yKG1zZywgdGhpcy5fY3VycmVudFRva2VuVHlwZSwgc3Bhbik7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUb2tlblN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRva2VuVHlwZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbnRyb2xGbG93RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ3Vyc29yRXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSB0aGlzLl9jcmVhdGVFcnJvcihlLm1zZywgdGhpcy5fY3Vyc29yLmdldFNwYW4oZS5jdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIF9Db250cm9sRmxvd0Vycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdENoYXJDb2RlKGNoYXJDb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSBjaGFyQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2F0dGVtcHRDaGFyQ29kZUNhc2VJbnNlbnNpdGl2ZShjaGFyQ29kZSkge1xuICAgICAgICBpZiAoY29tcGFyZUNoYXJDb2RlQ2FzZUluc2Vuc2l0aXZlKHRoaXMuX2N1cnNvci5wZWVrKCksIGNoYXJDb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX3JlcXVpcmVDaGFyQ29kZShjaGFyQ29kZSkge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGVtcHRTdHIoY2hhcnMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fY3Vyc29yLmNoYXJzTGVmdCgpIDwgbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKGNoYXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYXR0ZW1wdGluZyB0byBwYXJzZSB0aGUgc3RyaW5nIGZhaWxzLCB3ZSB3YW50IHRvIHJlc2V0IHRoZSBwYXJzZXJcbiAgICAgICAgICAgICAgICAvLyB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSBhdHRlbXB0XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gaW5pdGlhbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2F0dGVtcHRTdHJDYXNlSW5zZW5zaXRpdmUoY2hhcnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0Q2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY2hhcnMuY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9yZXF1aXJlU3RyKGNoYXJzKSB7XG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdFN0cihjaGFycykpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKGxvY2F0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKSB7XG4gICAgICAgIHdoaWxlICghcHJlZGljYXRlKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKHByZWRpY2F0ZSwgbGVuKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4ocHJlZGljYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5kaWZmKHN0YXJ0KSA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyh0aGlzLl9jdXJzb3IucGVlaygpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oc3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXR0ZW1wdFVudGlsQ2hhcihjaGFyKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZWFkQ2hhcigpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVseSB1cG9uIHJlYWRpbmcgZGlyZWN0bHkgZnJvbSBgX2lucHV0YCBhcyB0aGUgYWN0dWFsIGNoYXIgdmFsdWVcbiAgICAgICAgLy8gbWF5IGhhdmUgYmVlbiBnZW5lcmF0ZWQgZnJvbSBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLl9jdXJzb3IucGVlaygpKTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxuICAgIF9jb25zdW1lRW50aXR5KHRleHRUb2tlblR5cGUpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbig5IC8qIFRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgIGlmICh0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEhBU0gpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0hleCA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkeCkgfHwgdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRYKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc0RpZ2l0RW50aXR5RW5kKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpICE9ICRTRU1JQ09MT04pIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIGN1cnNvciB0byBpbmNsdWRlIHRoZSBwZWVrZWQgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgcHJvdmlkZWQgdG8gdGhlIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gbWVzc2FnZS5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudGl0eVR5cGUgPSBpc0hleCA/IENoYXJhY3RlclJlZmVyZW5jZVR5cGUuSEVYIDogQ2hhcmFjdGVyUmVmZXJlbmNlVHlwZS5ERUM7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VucGFyc2FibGVFbnRpdHlFcnJvck1zZyhlbnRpdHlUeXBlLCB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoc3RhcnQpKSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJOdW0gPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29kZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyTnVtLCBpc0hleCA/IDE2IDogMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKSwgdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2codGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmFtZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTmFtZWRFbnRpdHlFbmQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT0gJFNFTUlDT0xPTikge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNlbWljb2xvbiB3YXMgZm91bmQgc28gYWJvcnQgdGhlIGVuY29kZWQgZW50aXR5IHRva2VuIHRoYXQgd2FzIGluIHByb2dyZXNzLCBhbmQgdHJlYXRcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGFzIGEgdGV4dCB0b2tlblxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odGV4dFRva2VuVHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG5hbWVTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbJyYnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5fY3Vyc29yLmdldENoYXJzKG5hbWVTdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFyID0gTkFNRURfRU5USVRJRVNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmtub3duRW50aXR5RXJyb3JNc2cobmFtZSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtjaGFyLCBgJiR7bmFtZX07YF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lUmF3VGV4dChjb25zdW1lRW50aXRpZXMsIGVuZE1hcmtlclByZWRpY2F0ZSkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKGNvbnN1bWVFbnRpdGllcyA/IDYgLyogVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCAqLyA6IDcgLyogVG9rZW5UeXBlLlJBV19URVhUICovKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0Nsb3NlU3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kRW5kTWFya2VyID0gZW5kTWFya2VyUHJlZGljYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB0YWdDbG9zZVN0YXJ0O1xuICAgICAgICAgICAgaWYgKGZvdW5kRW5kTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc3VtZUVudGl0aWVzICYmIHRoaXMuX2N1cnNvci5wZWVrKCkgPT09ICRBTVBFUlNBTkQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldKTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbnRpdHkoNiAvKiBUb2tlblR5cGUuRVNDQVBBQkxFX1JBV19URVhUICovKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpblRva2VuKDYgLyogVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0aGlzLl9wcm9jZXNzQ2FycmlhZ2VSZXR1cm5zKHBhcnRzLmpvaW4oJycpKV0pO1xuICAgIH1cbiAgICBfY29uc3VtZUNvbW1lbnQoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxMCAvKiBUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCAqLywgc3RhcnQpO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJE1JTlVTKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9jb25zdW1lUmF3VGV4dChmYWxzZSwgKCkgPT4gdGhpcy5fYXR0ZW1wdFN0cignLS0+JykpO1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDExIC8qIFRva2VuVHlwZS5DT01NRU5UX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVTdHIoJy0tPicpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgfVxuICAgIF9jb25zdW1lQ2RhdGEoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxMiAvKiBUb2tlblR5cGUuQ0RBVEFfU1RBUlQgKi8sIHN0YXJ0KTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignQ0RBVEFbJyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHQoZmFsc2UsICgpID0+IHRoaXMuX2F0dGVtcHRTdHIoJ11dPicpKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxMyAvKiBUb2tlblR5cGUuQ0RBVEFfRU5EICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZVN0cignXV0+Jyk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVEb2NUeXBlKHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMTggLyogVG9rZW5UeXBlLkRPQ19UWVBFICovLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKCRHVCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jdXJzb3IuZ2V0Q2hhcnMoY29udGVudFN0YXJ0KTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW2NvbnRlbnRdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVQcmVmaXhBbmROYW1lKCkge1xuICAgICAgICBjb25zdCBuYW1lT3JQcmVmaXhTdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICBsZXQgcHJlZml4ID0gJyc7XG4gICAgICAgIHdoaWxlICh0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkQ09MT04gJiYgIWlzUHJlZml4RW5kKHRoaXMuX2N1cnNvci5wZWVrKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYW1lU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkQ09MT04pIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lT3JQcmVmaXhTdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgbmFtZVN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuYW1lU3RhcnQgPSBuYW1lT3JQcmVmaXhTdGFydDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGVVbnRpbEZuKGlzTmFtZUVuZCwgcHJlZml4ID09PSAnJyA/IDAgOiAxKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2N1cnNvci5nZXRDaGFycyhuYW1lU3RhcnQpO1xuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlbihzdGFydCkge1xuICAgICAgICBsZXQgdGFnTmFtZTtcbiAgICAgICAgbGV0IHByZWZpeDtcbiAgICAgICAgbGV0IG9wZW5UYWdUb2tlbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghaXNBc2NpaUxldHRlcih0aGlzLl9jdXJzb3IucGVlaygpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX2NyZWF0ZUVycm9yKF91bmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3JNc2codGhpcy5fY3Vyc29yLnBlZWsoKSksIHRoaXMuX2N1cnNvci5nZXRTcGFuKHN0YXJ0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuVGFnVG9rZW4gPSB0aGlzLl9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KTtcbiAgICAgICAgICAgIHByZWZpeCA9IG9wZW5UYWdUb2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIHRhZ05hbWUgPSBvcGVuVGFnVG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJFNMQVNIICYmIHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRHVCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMVCAmJiB0aGlzLl9jdXJzb3IucGVlaygpICE9PSAkRU9GKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkRVEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVUYWdPcGVuRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgX0NvbnRyb2xGbG93RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlblRhZ1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGVycm9yZWQgYmVmb3JlIHdlIGNvdWxkIGNsb3NlIHRoZSBvcGVuaW5nIHRhZywgc28gaXQgaXMgaW5jb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAgICAgb3BlblRhZ1Rva2VuLnR5cGUgPSA0IC8qIFRva2VuVHlwZS5JTkNPTVBMRVRFX1RBR19PUEVOICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgc3RhcnQgdGFnIGlzIGludmFsaWQsIGFzc3VtZSB3ZSB3YW50IGEgXCI8XCIgYXMgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFjayB0byBiYWNrIHRleHQgdG9rZW5zIGFyZSBtZXJnZWQgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbig1IC8qIFRva2VuVHlwZS5URVhUICovLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFsnPCddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50VG9rZW5UeXBlID0gdGhpcy5fZ2V0VGFnRGVmaW5pdGlvbih0YWdOYW1lKS5nZXRDb250ZW50VHlwZShwcmVmaXgpO1xuICAgICAgICBpZiAoY29udGVudFRva2VuVHlwZSA9PT0gVGFnQ29udGVudFR5cGUuUkFXX1RFWFQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVSYXdUZXh0V2l0aFRhZ0Nsb3NlKHByZWZpeCwgdGFnTmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRUb2tlblR5cGUgPT09IFRhZ0NvbnRlbnRUeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCkge1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29uc3VtZVJhd1RleHRXaXRoVGFnQ2xvc2UocHJlZml4LCB0YWdOYW1lLCBjb25zdW1lRW50aXRpZXMpIHtcbiAgICAgICAgdGhpcy5fY29uc3VtZVJhd1RleHQoY29uc3VtZUVudGl0aWVzLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkTFQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXR0ZW1wdENoYXJDb2RlKCRTTEFTSCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fYXR0ZW1wdENoYXJDb2RlVW50aWxGbihpc05vdFdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdHRlbXB0U3RyQ2FzZUluc2Vuc2l0aXZlKHRhZ05hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRlbXB0Q2hhckNvZGUoJEdUKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMyAvKiBUb2tlblR5cGUuVEFHX0NMT1NFICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlVW50aWxGbihjb2RlID0+IGNvZGUgPT09ICRHVCwgMyk7XG4gICAgICAgIHRoaXMuX2N1cnNvci5hZHZhbmNlKCk7IC8vIENvbnN1bWUgdGhlIGA+YFxuICAgICAgICB0aGlzLl9lbmRUb2tlbihbcHJlZml4LCB0YWdOYW1lXSk7XG4gICAgfVxuICAgIF9jb25zdW1lVGFnT3BlblN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMCAvKiBUb2tlblR5cGUuVEFHX09QRU5fU1RBUlQgKi8sIHN0YXJ0KTtcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lU3RhcnQgPSB0aGlzLl9jdXJzb3IucGVlaygpO1xuICAgICAgICBpZiAoYXR0ck5hbWVTdGFydCA9PT0gJFNRIHx8IGF0dHJOYW1lU3RhcnQgPT09ICREUSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoX3VuZXhwZWN0ZWRDaGFyYWN0ZXJFcnJvck1zZyhhdHRyTmFtZVN0YXJ0KSwgdGhpcy5fY3Vyc29yLmdldFNwYW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxNCAvKiBUb2tlblR5cGUuQVRUUl9OQU1FICovKTtcbiAgICAgICAgY29uc3QgcHJlZml4QW5kTmFtZSA9IHRoaXMuX2NvbnN1bWVQcmVmaXhBbmROYW1lKCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKHByZWZpeEFuZE5hbWUpO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHJpYnV0ZVZhbHVlKCkge1xuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkU1EgfHwgdGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJERRKSB7XG4gICAgICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSB0aGlzLl9jdXJzb3IucGVlaygpO1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZVF1b3RlKHF1b3RlQ2hhcik7XG4gICAgICAgICAgICAvLyBJbiBhbiBhdHRyaWJ1dGUgdGhlbiBlbmQgb2YgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBhbmQgdGhlIHByZW1hdHVyZSBlbmQgdG8gYW4gaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgLy8gYXJlIGJvdGggdHJpZ2dlcmVkIGJ5IHRoZSBgcXVvdGVDaGFyYC5cbiAgICAgICAgICAgIGNvbnN0IGVuZFByZWRpY2F0ZSA9ICgpID0+IHRoaXMuX2N1cnNvci5wZWVrKCkgPT09IHF1b3RlQ2hhcjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVXaXRoSW50ZXJwb2xhdGlvbigxNiAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9URVhUICovLCAxNyAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovLCBlbmRQcmVkaWNhdGUsIGVuZFByZWRpY2F0ZSk7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lUXVvdGUocXVvdGVDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZFByZWRpY2F0ZSA9ICgpID0+IGlzTmFtZUVuZCh0aGlzLl9jdXJzb3IucGVlaygpKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVXaXRoSW50ZXJwb2xhdGlvbigxNiAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9URVhUICovLCAxNyAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovLCBlbmRQcmVkaWNhdGUsIGVuZFByZWRpY2F0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NvbnN1bWVRdW90ZShxdW90ZUNoYXIpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigxNSAvKiBUb2tlblR5cGUuQVRUUl9RVU9URSAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZShxdW90ZUNoYXIpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbU3RyaW5nLmZyb21Db2RlUG9pbnQocXVvdGVDaGFyKV0pO1xuICAgIH1cbiAgICBfY29uc3VtZVRhZ09wZW5FbmQoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuX2F0dGVtcHRDaGFyQ29kZSgkU0xBU0gpID8gMiAvKiBUb2tlblR5cGUuVEFHX09QRU5fRU5EX1ZPSUQgKi8gOiAxIC8qIFRva2VuVHlwZS5UQUdfT1BFTl9FTkQgKi87XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odG9rZW5UeXBlKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRHVCk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICB9XG4gICAgX2NvbnN1bWVUYWdDbG9zZShzdGFydCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDMgLyogVG9rZW5UeXBlLlRBR19DTE9TRSAqLywgc3RhcnQpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIGNvbnN0IHByZWZpeEFuZE5hbWUgPSB0aGlzLl9jb25zdW1lUHJlZml4QW5kTmFtZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkR1QpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihwcmVmaXhBbmROYW1lKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFeHBhbnNpb25Gb3JtU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oMTkgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRMQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wdXNoKDE5IC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9TVEFSVCAqLyk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8pO1xuICAgICAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLl9yZWFkVW50aWwoJENPTU1BKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZENvbmRpdGlvbiA9IHRoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMoY29uZGl0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuX2kxOG5Ob3JtYWxpemVMaW5lRW5kaW5nc0luSUNVcykge1xuICAgICAgICAgICAgLy8gV2UgZXhwbGljaXRseSB3YW50IHRvIG5vcm1hbGl6ZSBsaW5lIGVuZGluZ3MgZm9yIHRoaXMgdGV4dC5cbiAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKFtub3JtYWxpemVkQ29uZGl0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbm90IG5vcm1hbGl6aW5nIGxpbmUgZW5kaW5ncy5cbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvblRva2VuID0gdGhpcy5fZW5kVG9rZW4oW2NvbmRpdGlvbl0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRDb25kaXRpb24gIT09IGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMubm9uTm9ybWFsaXplZEljdUV4cHJlc3Npb25zLnB1c2goY29uZGl0aW9uVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4oNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8pO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5fcmVhZFVudGlsKCRDT01NQSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFt0eXBlXSk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkQ09NTUEpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uQ2FzZVN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDIwIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9WQUxVRSAqLyk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fcmVhZFVudGlsKCRMQlJBQ0UpLnRyaW0oKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3ZhbHVlXSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUICovKTtcbiAgICAgICAgdGhpcy5fcmVxdWlyZUNoYXJDb2RlKCRMQlJBQ0UpO1xuICAgICAgICB0aGlzLl9lbmRUb2tlbihbXSk7XG4gICAgICAgIHRoaXMuX2F0dGVtcHRDaGFyQ29kZVVudGlsRm4oaXNOb3RXaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnB1c2goMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqLyk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uQ2FzZUVuZCgpIHtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbigyMiAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX0VORCAqLyk7XG4gICAgICAgIHRoaXMuX3JlcXVpcmVDaGFyQ29kZSgkUkJSQUNFKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW10pO1xuICAgICAgICB0aGlzLl9hdHRlbXB0Q2hhckNvZGVVbnRpbEZuKGlzTm90V2hpdGVzcGFjZSk7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFeHBhbnNpb25Gb3JtRW5kKCkge1xuICAgICAgICB0aGlzLl9iZWdpblRva2VuKDIzIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9FTkQgKi8pO1xuICAgICAgICB0aGlzLl9yZXF1aXJlQ2hhckNvZGUoJFJCUkFDRSk7XG4gICAgICAgIHRoaXMuX2VuZFRva2VuKFtdKTtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lIGEgc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucy5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCB0b2tlbiBjb25zdW1lZCB3aWxsIGJlIG9mIGB0b2tlblR5cGVgIGFuZCB0aGVuIHRoZXJlIHdpbGwgYmUgYWx0ZXJuYXRpbmdcbiAgICAgKiBgaW50ZXJwb2xhdGlvblRva2VuVHlwZWAgYW5kIGB0b2tlblR5cGVgIHRva2VucyB1bnRpbCB0aGUgYGVuZFByZWRpY2F0ZSgpYCByZXR1cm5zIHRydWUuXG4gICAgICpcbiAgICAgKiBJZiBhbiBpbnRlcnBvbGF0aW9uIHRva2VuIGVuZHMgcHJlbWF0dXJlbHkgaXQgd2lsbCBoYXZlIG5vIGVuZCBtYXJrZXIgaW4gaXRzIGBwYXJ0c2AgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFRva2VuVHlwZSB0aGUga2luZCBvZiB0b2tlbnMgdG8gaW50ZXJsZWF2ZSBhcm91bmQgaW50ZXJwb2xhdGlvbiB0b2tlbnMuXG4gICAgICogQHBhcmFtIGludGVycG9sYXRpb25Ub2tlblR5cGUgdGhlIGtpbmQgb2YgdG9rZW5zIHRoYXQgY29udGFpbiBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEBwYXJhbSBlbmRQcmVkaWNhdGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIHdlIHNob3VsZCBzdG9wIGNvbnN1bWluZy5cbiAgICAgKiBAcGFyYW0gZW5kSW50ZXJwb2xhdGlvbiBhIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgcHJlbWF0dXJlIGVuZCB0byBhblxuICAgICAqICAgICBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24gLSBpLmUuIGJlZm9yZSB3ZSBnZXQgdG8gdGhlIG5vcm1hbCBpbnRlcnBvbGF0aW9uIGNsb3NpbmcgbWFya2VyLlxuICAgICAqL1xuICAgIF9jb25zdW1lV2l0aEludGVycG9sYXRpb24odGV4dFRva2VuVHlwZSwgaW50ZXJwb2xhdGlvblRva2VuVHlwZSwgZW5kUHJlZGljYXRlLCBlbmRJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odGV4dFRva2VuVHlwZSk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIHdoaWxlICghZW5kUHJlZGljYXRlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnICYmIHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUb2tlbihbdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhwYXJ0cy5qb2luKCcnKSldLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBwYXJ0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb25Ub2tlblR5cGUsIGN1cnJlbnQsIGVuZEludGVycG9sYXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odGV4dFRva2VuVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkQU1QRVJTQU5EKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgICAgICAgICAgICAgcGFydHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRW50aXR5KHRleHRUb2tlblR5cGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luVG9rZW4odGV4dFRva2VuVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX3JlYWRDaGFyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYW4gaW50ZXJwb2xhdGlvbiB3YXMgc3RhcnRlZCBidXQgbm90IGVuZGVkIGluc2lkZSB0aGlzIHRleHQgdG9rZW4uXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgbGV4ZXIgY29ycmVjdGx5LlxuICAgICAgICB0aGlzLl9pbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4oW3RoaXMuX3Byb2Nlc3NDYXJyaWFnZVJldHVybnMocGFydHMuam9pbignJykpXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN1bWUgYSBibG9jayBvZiB0ZXh0IHRoYXQgaGFzIGJlZW4gaW50ZXJwcmV0ZWQgYXMgYW4gQW5ndWxhciBpbnRlcnBvbGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVycG9sYXRpb25Ub2tlblR5cGUgdGhlIHR5cGUgb2YgdGhlIGludGVycG9sYXRpb24gdG9rZW4gdG8gZ2VuZXJhdGUuXG4gICAgICogQHBhcmFtIGludGVycG9sYXRpb25TdGFydCBhIGN1cnNvciB0aGF0IHBvaW50cyB0byB0aGUgc3RhcnQgb2YgdGhpcyBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEBwYXJhbSBwcmVtYXR1cmVFbmRQcmVkaWNhdGUgYSBmdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCBjaGFyYWN0ZXJzIGluZGljYXRlXG4gICAgICogICAgIGFuIGVuZCB0byB0aGUgaW50ZXJwb2xhdGlvbiBiZWZvcmUgaXRzIG5vcm1hbCBjbG9zaW5nIG1hcmtlci5cbiAgICAgKi9cbiAgICBfY29uc3VtZUludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvblRva2VuVHlwZSwgaW50ZXJwb2xhdGlvblN0YXJ0LCBwcmVtYXR1cmVFbmRQcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYmVnaW5Ub2tlbihpbnRlcnBvbGF0aW9uVG9rZW5UeXBlLCBpbnRlcnBvbGF0aW9uU3RhcnQpO1xuICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuc3RhcnQpO1xuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIGludGVycG9sYXRpb24sIGlnbm9yaW5nIGNvbnRlbnQgaW5zaWRlIHF1b3Rlcy5cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvblN0YXJ0ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgIGxldCBpblF1b3RlID0gbnVsbDtcbiAgICAgICAgbGV0IGluQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAodGhpcy5fY3Vyc29yLnBlZWsoKSAhPT0gJEVPRiAmJlxuICAgICAgICAgICAgKHByZW1hdHVyZUVuZFByZWRpY2F0ZSA9PT0gbnVsbCB8fCAhcHJlbWF0dXJlRW5kUHJlZGljYXRlKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNUYWdTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN0YXJ0aW5nIHdoYXQgbG9va3MgbGlrZSBhbiBIVE1MIGVsZW1lbnQgaW4gdGhlIG1pZGRsZSBvZiB0aGlzIGludGVycG9sYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGN1cnNvciB0byBiZWZvcmUgdGhlIGA8YCBjaGFyYWN0ZXIgYW5kIGVuZCB0aGUgaW50ZXJwb2xhdGlvbiB0b2tlbi5cbiAgICAgICAgICAgICAgICAvLyAoVGhpcyBpcyBhY3R1YWxseSB3cm9uZyBidXQgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSkuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHRoaXMuX2dldFByb2Nlc3NlZENoYXJzKGV4cHJlc3Npb25TdGFydCwgY3VycmVudCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHBhcnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5RdW90ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hdHRlbXB0U3RyKHRoaXMuX2ludGVycG9sYXRpb25Db25maWcuZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmUgbm90IGluIGEgc3RyaW5nLCBhbmQgd2UgaGl0IHRoZSBlbmQgaW50ZXJwb2xhdGlvbiBtYXJrZXJcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9nZXRQcm9jZXNzZWRDaGFycyhleHByZXNzaW9uU3RhcnQsIGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRva2VuKHBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdHRlbXB0U3RyKCcvLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9uY2Ugd2UgYXJlIGluIGEgY29tbWVudCB3ZSBpZ25vcmUgYW55IHF1b3Rlc1xuICAgICAgICAgICAgICAgICAgICBpbkNvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLl9jdXJzb3IucGVlaygpO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAkQkFDS1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgbmV4dCBjaGFyYWN0ZXIgYmVjYXVzZSBpdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3IuYWR2YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gaW5RdW90ZSkge1xuICAgICAgICAgICAgICAgIC8vIEV4aXRpbmcgdGhlIGN1cnJlbnQgcXVvdGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIGluUXVvdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWluQ29tbWVudCAmJiBpblF1b3RlID09PSBudWxsICYmIGlzUXVvdGUoY2hhcikpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnRlcmluZyBhIG5ldyBxdW90ZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgaW5RdW90ZSA9IGNoYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGl0IEVPRiB3aXRob3V0IGZpbmRpbmcgYSBjbG9zaW5nIGludGVycG9sYXRpb24gbWFya2VyXG4gICAgICAgIHBhcnRzLnB1c2godGhpcy5fZ2V0UHJvY2Vzc2VkQ2hhcnMoZXhwcmVzc2lvblN0YXJ0LCB0aGlzLl9jdXJzb3IpKTtcbiAgICAgICAgdGhpcy5fZW5kVG9rZW4ocGFydHMpO1xuICAgIH1cbiAgICBfZ2V0UHJvY2Vzc2VkQ2hhcnMoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc0NhcnJpYWdlUmV0dXJucyhlbmQuZ2V0Q2hhcnMoc3RhcnQpKTtcbiAgICB9XG4gICAgX2lzVGV4dEVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVGFnU3RhcnQoKSB8fCB0aGlzLl9jdXJzb3IucGVlaygpID09PSAkRU9GKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdG9rZW5pemVJY3UgJiYgIXRoaXMuX2luSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBhbnNpb25Gb3JtU3RhcnQoKSkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9mIGFuIGV4cGFuc2lvbiBmb3JtXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29yLnBlZWsoKSA9PT0gJFJCUkFDRSAmJiB0aGlzLl9pc0luRXhwYW5zaW9uQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIGFuZCBleHBhbnNpb24gY2FzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IGN1cnNvciBpcyBwb2ludGluZyB0byB0aGUgc3RhcnQgb2YgYSB0YWdcbiAgICAgKiAob3BlbmluZy9jbG9zaW5nL2NvbW1lbnRzL2NkYXRhL2V0YykuXG4gICAgICovXG4gICAgX2lzVGFnU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3IucGVlaygpID09PSAkTFQpIHtcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGA8YCBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlIGlzIG5vdCB0aGUgc3RhcnQgb2YgYW4gSFRNTCBlbGVtZW50LlxuICAgICAgICAgICAgY29uc3QgdG1wID0gdGhpcy5fY3Vyc29yLmNsb25lKCk7XG4gICAgICAgICAgICB0bXAuYWR2YW5jZSgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFscGhhYmV0aWMsICEgbm9yIC8gdGhlbiBpdCBpcyBhIHRhZyBzdGFydFxuICAgICAgICAgICAgY29uc3QgY29kZSA9IHRtcC5wZWVrKCk7XG4gICAgICAgICAgICBpZiAoKCRhIDw9IGNvZGUgJiYgY29kZSA8PSAkeikgfHwgKCRBIDw9IGNvZGUgJiYgY29kZSA8PSAkWikgfHxcbiAgICAgICAgICAgICAgICBjb2RlID09PSAkU0xBU0ggfHwgY29kZSA9PT0gJEJBTkcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9yZWFkVW50aWwoY2hhcikge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2N1cnNvci5jbG9uZSgpO1xuICAgICAgICB0aGlzLl9hdHRlbXB0VW50aWxDaGFyKGNoYXIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3Vyc29yLmdldENoYXJzKHN0YXJ0KTtcbiAgICB9XG4gICAgX2lzSW5FeHBhbnNpb25DYXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFja1t0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqLztcbiAgICB9XG4gICAgX2lzSW5FeHBhbnNpb25Gb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uQ2FzZVN0YWNrLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvbkNhc2VTdGFja1t0aGlzLl9leHBhbnNpb25DYXNlU3RhY2subGVuZ3RoIC0gMV0gPT09XG4gICAgICAgICAgICAgICAgMTkgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUICovO1xuICAgIH1cbiAgICBpc0V4cGFuc2lvbkZvcm1TdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnNvci5wZWVrKCkgIT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9jdXJzb3IuY2xvbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJwb2xhdGlvbiA9IHRoaXMuX2F0dGVtcHRTdHIodGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZy5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiAhaXNJbnRlcnBvbGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTm90V2hpdGVzcGFjZShjb2RlKSB7XG4gICAgcmV0dXJuICFpc1doaXRlc3BhY2UoY29kZSkgfHwgY29kZSA9PT0gJEVPRjtcbn1cbmZ1bmN0aW9uIGlzTmFtZUVuZChjb2RlKSB7XG4gICAgcmV0dXJuIGlzV2hpdGVzcGFjZShjb2RlKSB8fCBjb2RlID09PSAkR1QgfHwgY29kZSA9PT0gJExUIHx8XG4gICAgICAgIGNvZGUgPT09ICRTTEFTSCB8fCBjb2RlID09PSAkU1EgfHwgY29kZSA9PT0gJERRIHx8IGNvZGUgPT09ICRFUSB8fFxuICAgICAgICBjb2RlID09PSAkRU9GO1xufVxuZnVuY3Rpb24gaXNQcmVmaXhFbmQoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA8ICRhIHx8ICR6IDwgY29kZSkgJiYgKGNvZGUgPCAkQSB8fCAkWiA8IGNvZGUpICYmXG4gICAgICAgIChjb2RlIDwgJDAgfHwgY29kZSA+ICQ5KTtcbn1cbmZ1bmN0aW9uIGlzRGlnaXRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT09ICRFT0YgfHwgIWlzQXNjaWlIZXhEaWdpdChjb2RlKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZWRFbnRpdHlFbmQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAkU0VNSUNPTE9OIHx8IGNvZGUgPT09ICRFT0YgfHwgIWlzQXNjaWlMZXR0ZXIoY29kZSk7XG59XG5mdW5jdGlvbiBpc0V4cGFuc2lvbkNhc2VTdGFydChwZWVrKSB7XG4gICAgcmV0dXJuIHBlZWsgIT09ICRSQlJBQ0U7XG59XG5mdW5jdGlvbiBjb21wYXJlQ2hhckNvZGVDYXNlSW5zZW5zaXRpdmUoY29kZTEsIGNvZGUyKSB7XG4gICAgcmV0dXJuIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZTEpID09PSB0b1VwcGVyQ2FzZUNoYXJDb2RlKGNvZGUyKTtcbn1cbmZ1bmN0aW9uIHRvVXBwZXJDYXNlQ2hhckNvZGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49ICRhICYmIGNvZGUgPD0gJHogPyBjb2RlIC0gJGEgKyAkQSA6IGNvZGU7XG59XG5mdW5jdGlvbiBtZXJnZVRleHRUb2tlbnMoc3JjVG9rZW5zKSB7XG4gICAgY29uc3QgZHN0VG9rZW5zID0gW107XG4gICAgbGV0IGxhc3REc3RUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyY1Rva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHNyY1Rva2Vuc1tpXTtcbiAgICAgICAgaWYgKChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT09IDUgLyogVG9rZW5UeXBlLlRFWFQgKi8gJiYgdG9rZW4udHlwZSA9PT0gNSAvKiBUb2tlblR5cGUuVEVYVCAqLykgfHxcbiAgICAgICAgICAgIChsYXN0RHN0VG9rZW4gJiYgbGFzdERzdFRva2VuLnR5cGUgPT09IDE2IC8qIFRva2VuVHlwZS5BVFRSX1ZBTFVFX1RFWFQgKi8gJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlID09PSAxNiAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9URVhUICovKSkge1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnBhcnRzWzBdICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgbGFzdERzdFRva2VuLnNvdXJjZVNwYW4uZW5kID0gdG9rZW4uc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsYXN0RHN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGRzdFRva2Vucy5wdXNoKGxhc3REc3RUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdFRva2Vucztcbn1cbmNsYXNzIFBsYWluQ2hhcmFjdGVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlT3JDdXJzb3IsIHJhbmdlKSB7XG4gICAgICAgIGlmIChmaWxlT3JDdXJzb3IgaW5zdGFuY2VvZiBQbGFpbkNoYXJhY3RlckN1cnNvcikge1xuICAgICAgICAgICAgdGhpcy5maWxlID0gZmlsZU9yQ3Vyc29yLmZpbGU7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gZmlsZU9yQ3Vyc29yLmlucHV0O1xuICAgICAgICAgICAgdGhpcy5lbmQgPSBmaWxlT3JDdXJzb3IuZW5kO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBmaWxlT3JDdXJzb3Iuc3RhdGU7XG4gICAgICAgICAgICAvLyBOb3RlOiBhdm9pZCB1c2luZyBgey4uLmZpbGVPckN1cnNvci5zdGF0ZX1gIGhlcmUgYXMgdGhhdCBoYXMgYSBzZXZlcmUgcGVyZm9ybWFuY2UgcGVuYWx0eS5cbiAgICAgICAgICAgIC8vIEluIEVTNSBidW5kbGVzIHRoZSBvYmplY3Qgc3ByZWFkIG9wZXJhdG9yIGlzIHRyYW5zbGF0ZWQgaW50byB0aGUgYF9fYXNzaWduYCBoZWxwZXIsIHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBub3Qgb3B0aW1pemVkIGJ5IFZNcyBhcyBlZmZpY2llbnRseSBhcyBhIHJhdyBvYmplY3QgbGl0ZXJhbC4gU2luY2UgdGhpcyBjb25zdHJ1Y3RvciBpc1xuICAgICAgICAgICAgLy8gY2FsbGVkIGluIHRpZ2h0IGxvb3BzLCB0aGlzIGRpZmZlcmVuY2UgbWF0dGVycy5cbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcGVlazogc3RhdGUucGVlayxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0YXRlLm9mZnNldCxcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGF0ZS5saW5lLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhdGUuY29sdW1uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2dyYW1taW5nIGVycm9yOiB0aGUgcmFuZ2UgYXJndW1lbnQgbXVzdCBiZSBwcm92aWRlZCB3aXRoIGEgZmlsZSBhcmd1bWVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGVPckN1cnNvcjtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBmaWxlT3JDdXJzb3IuY29udGVudDtcbiAgICAgICAgICAgIHRoaXMuZW5kID0gcmFuZ2UuZW5kUG9zO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICBwZWVrOiAtMSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHJhbmdlLnN0YXJ0UG9zLFxuICAgICAgICAgICAgICAgIGxpbmU6IHJhbmdlLnN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHJhbmdlLnN0YXJ0Q29sLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFpbkNoYXJhY3RlckN1cnNvcih0aGlzKTtcbiAgICB9XG4gICAgcGVlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGVlaztcbiAgICB9XG4gICAgY2hhcnNMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQgLSB0aGlzLnN0YXRlLm9mZnNldDtcbiAgICB9XG4gICAgZGlmZihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5vZmZzZXQgLSBvdGhlci5zdGF0ZS5vZmZzZXQ7XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBlZWsodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGdldFNwYW4oc3RhcnQsIGxlYWRpbmdUcml2aWFDb2RlUG9pbnRzKSB7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgfHwgdGhpcztcbiAgICAgICAgbGV0IGZ1bGxTdGFydCA9IHN0YXJ0O1xuICAgICAgICBpZiAobGVhZGluZ1RyaXZpYUNvZGVQb2ludHMpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmRpZmYoc3RhcnQpID4gMCAmJiBsZWFkaW5nVHJpdmlhQ29kZVBvaW50cy5pbmRleE9mKHN0YXJ0LnBlZWsoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTdGFydCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFydC5hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRMb2NhdGlvbiA9IHRoaXMubG9jYXRpb25Gcm9tQ3Vyc29yKHN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kTG9jYXRpb24gPSB0aGlzLmxvY2F0aW9uRnJvbUN1cnNvcih0aGlzKTtcbiAgICAgICAgY29uc3QgZnVsbFN0YXJ0TG9jYXRpb24gPSBmdWxsU3RhcnQgIT09IHN0YXJ0ID8gdGhpcy5sb2NhdGlvbkZyb21DdXJzb3IoZnVsbFN0YXJ0KSA6IHN0YXJ0TG9jYXRpb247XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0TG9jYXRpb24sIGVuZExvY2F0aW9uLCBmdWxsU3RhcnRMb2NhdGlvbik7XG4gICAgfVxuICAgIGdldENoYXJzKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnN1YnN0cmluZyhzdGFydC5zdGF0ZS5vZmZzZXQsIHRoaXMuc3RhdGUub2Zmc2V0KTtcbiAgICB9XG4gICAgY2hhckF0KHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgfVxuICAgIGFkdmFuY2VTdGF0ZShzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID49IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3Vyc29yRXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiRU9GXCInLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50Q2hhciA9IHRoaXMuY2hhckF0KHN0YXRlLm9mZnNldCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gJExGKSB7XG4gICAgICAgICAgICBzdGF0ZS5saW5lKys7XG4gICAgICAgICAgICBzdGF0ZS5jb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc05ld0xpbmUoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQrKztcbiAgICAgICAgdGhpcy51cGRhdGVQZWVrKHN0YXRlKTtcbiAgICB9XG4gICAgdXBkYXRlUGVlayhzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5wZWVrID0gc3RhdGUub2Zmc2V0ID49IHRoaXMuZW5kID8gJEVPRiA6IHRoaXMuY2hhckF0KHN0YXRlLm9mZnNldCk7XG4gICAgfVxuICAgIGxvY2F0aW9uRnJvbUN1cnNvcihjdXJzb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUxvY2F0aW9uKGN1cnNvci5maWxlLCBjdXJzb3Iuc3RhdGUub2Zmc2V0LCBjdXJzb3Iuc3RhdGUubGluZSwgY3Vyc29yLnN0YXRlLmNvbHVtbik7XG4gICAgfVxufVxuY2xhc3MgRXNjYXBlZENoYXJhY3RlckN1cnNvciBleHRlbmRzIFBsYWluQ2hhcmFjdGVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihmaWxlT3JDdXJzb3IsIHJhbmdlKSB7XG4gICAgICAgIGlmIChmaWxlT3JDdXJzb3IgaW5zdGFuY2VvZiBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yKSB7XG4gICAgICAgICAgICBzdXBlcihmaWxlT3JDdXJzb3IpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0geyAuLi5maWxlT3JDdXJzb3IuaW50ZXJuYWxTdGF0ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoZmlsZU9yQ3Vyc29yLCByYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmludGVybmFsU3RhdGU7XG4gICAgICAgIHN1cGVyLmFkdmFuY2UoKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzRXNjYXBlU2VxdWVuY2UoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgc3VwZXIuaW5pdCgpO1xuICAgICAgICB0aGlzLnByb2Nlc3NFc2NhcGVTZXF1ZW5jZSgpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFc2NhcGVkQ2hhcmFjdGVyQ3Vyc29yKHRoaXMpO1xuICAgIH1cbiAgICBnZXRDaGFycyhzdGFydCkge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgICBsZXQgY2hhcnMgPSAnJztcbiAgICAgICAgd2hpbGUgKGN1cnNvci5pbnRlcm5hbFN0YXRlLm9mZnNldCA8IHRoaXMuaW50ZXJuYWxTdGF0ZS5vZmZzZXQpIHtcbiAgICAgICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGN1cnNvci5wZWVrKCkpO1xuICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGVzY2FwZSBzZXF1ZW5jZSB0aGF0IHN0YXJ0cyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgdGV4dC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byBlbnN1cmUgdGhhdCBgcGVla2AgaGFzIHRoZSB1bmVzY2FwZWQgdmFsdWUgb2YgZXNjYXBlIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBwcm9jZXNzRXNjYXBlU2VxdWVuY2UoKSB7XG4gICAgICAgIGNvbnN0IHBlZWsgPSAoKSA9PiB0aGlzLmludGVybmFsU3RhdGUucGVlaztcbiAgICAgICAgaWYgKHBlZWsoKSA9PT0gJEJBQ0tTTEFTSCkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBoaXQgYW4gZXNjYXBlIHNlcXVlbmNlIHNvIHdlIG5lZWQgdGhlIGludGVybmFsIHN0YXRlIHRvIGJlY29tZSBpbmRlcGVuZGVudFxuICAgICAgICAgICAgLy8gb2YgdGhlIGV4dGVybmFsIHN0YXRlLlxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0geyAuLi50aGlzLnN0YXRlIH07XG4gICAgICAgICAgICAvLyBNb3ZlIHBhc3QgdGhlIGJhY2tzbGFzaFxuICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBzdGFuZGFyZCBjb250cm9sIGNoYXIgc2VxdWVuY2VzXG4gICAgICAgICAgICBpZiAocGVlaygpID09PSAkbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRMRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkQ1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJFZUQUI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wZWVrID0gJFRBQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJGIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSAkQlNQQUNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGVlaygpID09PSAkZikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9ICRGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBjb25zaWRlciBtb3JlIGNvbXBsZXggc2VxdWVuY2VzXG4gICAgICAgICAgICBlbHNlIGlmIChwZWVrKCkgPT09ICR1KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5pY29kZSBjb2RlLXBvaW50IHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RhdGUodGhpcy5pbnRlcm5hbFN0YXRlKTsgLy8gYWR2YW5jZSBwYXN0IHRoZSBgdWAgY2hhclxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09ICRMQlJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFyaWFibGUgbGVuZ3RoIFVuaWNvZGUsIGUuZy4gYFxceHsxMjN9YFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGB7YCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgdmFyaWFibGUgbnVtYmVyIG9mIGhleCBkaWdpdHMgdW50aWwgd2UgaGl0IGEgYH1gIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXRTdGFydCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwZWVrKCkgIT09ICRSQlJBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSB0aGlzLmRlY29kZUhleERpZ2l0cyhkaWdpdFN0YXJ0LCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4ZWQgbGVuZ3RoIFVuaWNvZGUsIGUuZy4gYFxcdTEyMzRgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2l0U3RhcnQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBlZWsoKSA9PT0gJHgpIHtcbiAgICAgICAgICAgICAgICAvLyBIZXggY2hhciBjb2RlLCBlLmcuIGBcXHgyRmBcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIHBhc3QgdGhlIGB4YCBjaGFyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlnaXRTdGFydCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuZGVjb2RlSGV4RGlnaXRzKGRpZ2l0U3RhcnQsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPY3RhbERpZ2l0KHBlZWsoKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPY3RhbCBjaGFyIGNvZGUsIGUuZy4gYFxcMDEyYCxcbiAgICAgICAgICAgICAgICBsZXQgb2N0YWwgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgcHJldmlvdXMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlzT2N0YWxEaWdpdChwZWVrKCkpICYmIGxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIG9jdGFsICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHBlZWsoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZVN0YXRlKHRoaXMuaW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnBlZWsgPSBwYXJzZUludChvY3RhbCwgOCk7XG4gICAgICAgICAgICAgICAgLy8gQmFja3VwIG9uZSBjaGFyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gcHJldmlvdXMuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmV3TGluZSh0aGlzLmludGVybmFsU3RhdGUucGVlaykpIHtcbiAgICAgICAgICAgICAgICAvLyBMaW5lIGNvbnRpbnVhdGlvbiBgXFxgIGZvbGxvd2VkIGJ5IGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdGF0ZSh0aGlzLmludGVybmFsU3RhdGUpOyAvLyBhZHZhbmNlIG92ZXIgdGhlIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5pbnRlcm5hbFN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm9uZSBvZiB0aGUgYGlmYCBibG9ja3Mgd2VyZSBleGVjdXRlZCB0aGVuIHdlIGp1c3QgaGF2ZSBhbiBlc2NhcGVkIG5vcm1hbCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGp1c3QsIGVmZmVjdGl2ZWx5LCBza2lwIHRoZSBiYWNrc2xhc2ggZnJvbSB0aGUgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucGVlayA9IHRoaXMuaW50ZXJuYWxTdGF0ZS5wZWVrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29kZUhleERpZ2l0cyhzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGhleCA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQuaW50ZXJuYWxTdGF0ZS5vZmZzZXQsIHN0YXJ0LmludGVybmFsU3RhdGUub2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBwYXJzZUludChoZXgsIDE2KTtcbiAgICAgICAgaWYgKCFpc05hTihjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnN0YXRlID0gc3RhcnQuaW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAgIHRocm93IG5ldyBDdXJzb3JFcnJvcignSW52YWxpZCBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2UnLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDdXJzb3JFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnLCBjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gY3Vyc29yO1xuICAgIH1cbn1cblxuY2xhc3MgVHJlZUVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgc3RhdGljIGNyZWF0ZShlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZUVycm9yKGVsZW1lbnROYW1lLCBzcGFuLCBtc2cpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50TmFtZSwgc3BhbiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIG1zZyk7XG4gICAgICAgIHRoaXMuZWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZVRyZWVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHJvb3ROb2RlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gcm9vdE5vZGVzO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG59XG5jbGFzcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGdldFRhZ0RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgcGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdG9rZW5pemVSZXN1bHQgPSB0b2tlbml6ZShzb3VyY2UsIHVybCwgdGhpcy5nZXRUYWdEZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9UcmVlQnVpbGRlcih0b2tlbml6ZVJlc3VsdC50b2tlbnMsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbik7XG4gICAgICAgIHBhcnNlci5idWlsZCgpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZXIucm9vdE5vZGVzLCB0b2tlbml6ZVJlc3VsdC5lcnJvcnMuY29uY2F0KHBhcnNlci5lcnJvcnMpKTtcbiAgICB9XG59XG5jbGFzcyBfVHJlZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgZ2V0VGFnRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5nZXRUYWdEZWZpbml0aW9uID0gZ2V0VGFnRGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX2FkdmFuY2UoKTtcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgIT09IDI0IC8qIFRva2VuVHlwZS5FT0YgKi8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDAgLyogVG9rZW5UeXBlLlRBR19PUEVOX1NUQVJUICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSA0IC8qIFRva2VuVHlwZS5JTkNPTVBMRVRFX1RBR19PUEVOICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc3VtZVN0YXJ0VGFnKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDMgLyogVG9rZW5UeXBlLlRBR19DTE9TRSAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVFbmRUYWcodGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMTIgLyogVG9rZW5UeXBlLkNEQVRBX1NUQVJUICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2VWb2lkRWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnN1bWVDZGF0YSh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxMCAvKiBUb2tlblR5cGUuQ09NTUVOVF9TVEFSVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lQ29tbWVudCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSA1IC8qIFRva2VuVHlwZS5URVhUICovIHx8IHRoaXMuX3BlZWsudHlwZSA9PT0gNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IDYgLyogVG9rZW5UeXBlLkVTQ0FQQUJMRV9SQVdfVEVYVCAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVm9pZEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lVGV4dCh0aGlzLl9hZHZhbmNlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25zdW1lRXhwYW5zaW9uKHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBvdGhlciB0b2tlbnMuLi5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkdmFuY2UoKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9wZWVrO1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPCB0aGlzLnRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVyZSBpcyBhbHdheXMgYW4gRU9GIHRva2VuIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMuX2luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVlayA9IHRoaXMudG9rZW5zW3RoaXMuX2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuICAgIF9hZHZhbmNlSWYodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfY29uc3VtZUNkYXRhKF9zdGFydFRva2VuKSB7XG4gICAgICAgIHRoaXMuX2NvbnN1bWVUZXh0KHRoaXMuX2FkdmFuY2UoKSk7XG4gICAgICAgIHRoaXMuX2FkdmFuY2VJZigxMyAvKiBUb2tlblR5cGUuQ0RBVEFfRU5EICovKTtcbiAgICB9XG4gICAgX2NvbnN1bWVDb21tZW50KHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0aGlzLl9hZHZhbmNlSWYoNyAvKiBUb2tlblR5cGUuUkFXX1RFWFQgKi8pO1xuICAgICAgICB0aGlzLl9hZHZhbmNlSWYoMTEgLyogVG9rZW5UeXBlLkNPTU1FTlRfRU5EICovKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0ICE9IG51bGwgPyB0ZXh0LnBhcnRzWzBdLnRyaW0oKSA6IG51bGw7XG4gICAgICAgIHRoaXMuX2FkZFRvUGFyZW50KG5ldyBDb21tZW50KHZhbHVlLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgfVxuICAgIF9jb25zdW1lRXhwYW5zaW9uKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN3aXRjaFZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICBjb25zdCBjYXNlcyA9IFtdO1xuICAgICAgICAvLyByZWFkID1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjAgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX1ZBTFVFICovKSB7XG4gICAgICAgICAgICBjb25zdCBleHBDYXNlID0gdGhpcy5fcGFyc2VFeHBhbnNpb25DYXNlKCk7XG4gICAgICAgICAgICBpZiAoIWV4cENhc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBlcnJvclxuICAgICAgICAgICAgY2FzZXMucHVzaChleHBDYXNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkIHRoZSBmaW5hbCB9XG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgIT09IDIzIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fRk9STV9FTkQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCB0aGlzLl9wZWVrLnNvdXJjZVNwYW4sIGBJbnZhbGlkIElDVSBtZXNzYWdlLiBNaXNzaW5nICd9Jy5gKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlU3BhbiA9IG5ldyBQYXJzZVNvdXJjZVNwYW4odG9rZW4uc291cmNlU3Bhbi5zdGFydCwgdGhpcy5fcGVlay5zb3VyY2VTcGFuLmVuZCwgdG9rZW4uc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgRXhwYW5zaW9uKHN3aXRjaFZhbHVlLnBhcnRzWzBdLCB0eXBlLnBhcnRzWzBdLCBjYXNlcywgc291cmNlU3Bhbiwgc3dpdGNoVmFsdWUuc291cmNlU3BhbikpO1xuICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgfVxuICAgIF9wYXJzZUV4cGFuc2lvbkNhc2UoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAvLyByZWFkIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSAhPT0gMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqLykge1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKG51bGwsIHRoaXMuX3BlZWsuc291cmNlU3BhbiwgYEludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ3snLmApKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWQgdW50aWwgfVxuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgY29uc3QgZXhwID0gdGhpcy5fY29sbGVjdEV4cGFuc2lvbkV4cFRva2VucyhzdGFydCk7XG4gICAgICAgIGlmICghZXhwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgZXhwLnB1c2goeyB0eXBlOiAyNCAvKiBUb2tlblR5cGUuRU9GICovLCBwYXJ0czogW10sIHNvdXJjZVNwYW46IGVuZC5zb3VyY2VTcGFuIH0pO1xuICAgICAgICAvLyBwYXJzZSBldmVyeXRoaW5nIGluIGJldHdlZW4geyBhbmQgfVxuICAgICAgICBjb25zdCBleHBhbnNpb25DYXNlUGFyc2VyID0gbmV3IF9UcmVlQnVpbGRlcihleHAsIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbik7XG4gICAgICAgIGV4cGFuc2lvbkNhc2VQYXJzZXIuYnVpbGQoKTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbkNhc2VQYXJzZXIuZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5lcnJvcnMuY29uY2F0KGV4cGFuc2lvbkNhc2VQYXJzZXIuZXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlLnNvdXJjZVNwYW4uc3RhcnQsIGVuZC5zb3VyY2VTcGFuLmVuZCwgdmFsdWUuc291cmNlU3Bhbi5mdWxsU3RhcnQpO1xuICAgICAgICBjb25zdCBleHBTb3VyY2VTcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydC5zb3VyY2VTcGFuLnN0YXJ0LCBlbmQuc291cmNlU3Bhbi5lbmQsIHN0YXJ0LnNvdXJjZVNwYW4uZnVsbFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKHZhbHVlLnBhcnRzWzBdLCBleHBhbnNpb25DYXNlUGFyc2VyLnJvb3ROb2Rlcywgc291cmNlU3BhbiwgdmFsdWUuc291cmNlU3BhbiwgZXhwU291cmNlU3Bhbik7XG4gICAgfVxuICAgIF9jb2xsZWN0RXhwYW5zaW9uRXhwVG9rZW5zKHN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGV4cCA9IFtdO1xuICAgICAgICBjb25zdCBleHBhbnNpb25Gb3JtU3RhY2sgPSBbMjEgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9TVEFSVCAqL107XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxOSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fU1RBUlQgKi8gfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9wZWVrLnR5cGUgPT09IDIxIC8qIFRva2VuVHlwZS5FWFBBTlNJT05fQ0FTRV9FWFBfU1RBUlQgKi8pIHtcbiAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucHVzaCh0aGlzLl9wZWVrLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjIgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9DQVNFX0VYUF9FTkQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdE9uU3RhY2soZXhwYW5zaW9uRm9ybVN0YWNrLCAyMSAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0NBU0VfRVhQX1NUQVJUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25Gb3JtU3RhY2subGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBgSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuYCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAyMyAvKiBUb2tlblR5cGUuRVhQQU5TSU9OX0ZPUk1fRU5EICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RPblN0YWNrKGV4cGFuc2lvbkZvcm1TdGFjaywgMTkgLyogVG9rZW5UeXBlLkVYUEFOU0lPTl9GT1JNX1NUQVJUICovKSkge1xuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25Gb3JtU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUobnVsbCwgc3RhcnQuc291cmNlU3BhbiwgYEludmFsaWQgSUNVIG1lc3NhZ2UuIE1pc3NpbmcgJ30nLmApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZWsudHlwZSA9PT0gMjQgLyogVG9rZW5UeXBlLkVPRiAqLykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShudWxsLCBzdGFydC5zb3VyY2VTcGFuLCBgSW52YWxpZCBJQ1UgbWVzc2FnZS4gTWlzc2luZyAnfScuYCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwLnB1c2godGhpcy5fYWR2YW5jZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29uc3VtZVRleHQodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gW3Rva2VuXTtcbiAgICAgICAgY29uc3Qgc3RhcnRTcGFuID0gdG9rZW4uc291cmNlU3BhbjtcbiAgICAgICAgbGV0IHRleHQgPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCAmJiB0ZXh0WzBdID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50Lm5hbWUpLmlnbm9yZUZpcnN0TGYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgdG9rZW5zWzBdID0geyB0eXBlOiB0b2tlbi50eXBlLCBzb3VyY2VTcGFuOiB0b2tlbi5zb3VyY2VTcGFuLCBwYXJ0czogW3RleHRdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuX3BlZWsudHlwZSA9PT0gOCAvKiBUb2tlblR5cGUuSU5URVJQT0xBVElPTiAqLyB8fCB0aGlzLl9wZWVrLnR5cGUgPT09IDUgLyogVG9rZW5UeXBlLlRFWFQgKi8gfHxcbiAgICAgICAgICAgIHRoaXMuX3BlZWsudHlwZSA9PT0gOSAvKiBUb2tlblR5cGUuRU5DT0RFRF9FTlRJVFkgKi8pIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09IDggLyogVG9rZW5UeXBlLklOVEVSUE9MQVRJT04gKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3ZSBkZWNvZGUgSFRNTCBlbnRpdGllcyB0aGF0IGFwcGVhciBpbiBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMuIFRoaXMgaXMgYXJndWFibHkgYSBidWcsIGJ1dCBpdCBjb3VsZCBiZSBhIGNvbnNpZGVyYWJsZSBicmVha2luZyBjaGFuZ2UgdG9cbiAgICAgICAgICAgICAgICAvLyBmaXggaXQuIEl0IHNob3VsZCBiZSBhZGRyZXNzZWQgaW4gYSBsYXJnZXIgcHJvamVjdCB0byByZWZhY3RvciB0aGUgZW50aXJlIHBhcnNlci9sZXhlclxuICAgICAgICAgICAgICAgIC8vIGNoYWluIGFmdGVyIFZpZXcgRW5naW5lIGhhcyBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgdGV4dCArPSB0b2tlbi5wYXJ0cy5qb2luKCcnKS5yZXBsYWNlKC8mKFteO10rKTsvZywgZGVjb2RlRW50aXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09IDkgLyogVG9rZW5UeXBlLkVOQ09ERURfRU5USVRZICovKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSB0b2tlbi5wYXJ0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdG9rZW4ucGFydHMuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5kU3BhbiA9IHRva2VuLnNvdXJjZVNwYW47XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChuZXcgVGV4dCh0ZXh0LCBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0U3Bhbi5zdGFydCwgZW5kU3Bhbi5lbmQsIHN0YXJ0U3Bhbi5mdWxsU3RhcnQsIHN0YXJ0U3Bhbi5kZXRhaWxzKSwgdG9rZW5zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb3NlVm9pZEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwgJiYgdGhpcy5nZXRUYWdEZWZpbml0aW9uKGVsLm5hbWUpLmlzVm9pZCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25zdW1lU3RhcnRUYWcoc3RhcnRUYWdUb2tlbikge1xuICAgICAgICBjb25zdCBbcHJlZml4LCBuYW1lXSA9IHN0YXJ0VGFnVG9rZW4ucGFydHM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9wZWVrLnR5cGUgPT09IDE0IC8qIFRva2VuVHlwZS5BVFRSX05BTUUgKi8pIHtcbiAgICAgICAgICAgIGF0dHJzLnB1c2godGhpcy5fY29uc3VtZUF0dHIodGhpcy5fYWR2YW5jZSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUocHJlZml4LCBuYW1lLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICBsZXQgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gTm90ZTogVGhlcmUgY291bGQgaGF2ZSBiZWVuIGEgdG9rZW5pemVyIGVycm9yXG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IGEgdG9rZW4gZm9yIHRoZSBlbmQgdGFnLi4uXG4gICAgICAgIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDIgLyogVG9rZW5UeXBlLlRBR19PUEVOX0VORF9WT0lEICovKSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICBzZWxmQ2xvc2luZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0YWdEZWYgPSB0aGlzLmdldFRhZ0RlZmluaXRpb24oZnVsbE5hbWUpO1xuICAgICAgICAgICAgaWYgKCEodGFnRGVmLmNhblNlbGZDbG9zZSB8fCBnZXROc1ByZWZpeChmdWxsTmFtZSkgIT09IG51bGwgfHwgdGFnRGVmLmlzVm9pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHN0YXJ0VGFnVG9rZW4uc291cmNlU3BhbiwgYE9ubHkgdm9pZCwgY3VzdG9tIGFuZCBmb3JlaWduIGVsZW1lbnRzIGNhbiBiZSBzZWxmIGNsb3NlZCBcIiR7c3RhcnRUYWdUb2tlbi5wYXJ0c1sxXX1cImApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9wZWVrLnR5cGUgPT09IDEgLyogVG9rZW5UeXBlLlRBR19PUEVOX0VORCAqLykge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICAgICAgc2VsZkNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW4uZnVsbFN0YXJ0O1xuICAgICAgICBjb25zdCBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uc3RhcnQsIGVuZCwgc3RhcnRUYWdUb2tlbi5zb3VyY2VTcGFuLmZ1bGxTdGFydCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIGBzdGFydFNwYW5gIGJlY2F1c2UgYHNwYW5gIHdpbGwgYmUgbW9kaWZpZWQgd2hlbiB0aGVyZSBpcyBhbiBgZW5kYCBzcGFuLlxuICAgICAgICBjb25zdCBzdGFydFNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHN0YXJ0VGFnVG9rZW4uc291cmNlU3Bhbi5zdGFydCwgZW5kLCBzdGFydFRhZ1Rva2VuLnNvdXJjZVNwYW4uZnVsbFN0YXJ0KTtcbiAgICAgICAgY29uc3QgZWwgPSBuZXcgRWxlbWVudChmdWxsTmFtZSwgYXR0cnMsIFtdLCBzcGFuLCBzdGFydFNwYW4sIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX3B1c2hFbGVtZW50KGVsKTtcbiAgICAgICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50cyB0aGF0IGFyZSBzZWxmLWNsb3NlZCBoYXZlIHRoZWlyIGBlbmRTb3VyY2VTcGFuYCBzZXQgdG8gdGhlIGZ1bGwgc3BhbiwgYXMgdGhlXG4gICAgICAgICAgICAvLyBlbGVtZW50IHN0YXJ0IHRhZyBhbHNvIHJlcHJlc2VudHMgdGhlIGVuZCB0YWcuXG4gICAgICAgICAgICB0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lLCBzcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydFRhZ1Rva2VuLnR5cGUgPT09IDQgLyogVG9rZW5UeXBlLklOQ09NUExFVEVfVEFHX09QRU4gKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGFscmVhZHkga25vdyB0aGUgb3BlbmluZyB0YWcgaXMgbm90IGNvbXBsZXRlLCBzbyBpdCBpcyB1bmxpa2VseSBpdCBoYXMgYSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAvLyBjbG9zZSB0YWcuIExldCdzIG9wdGltaXN0aWNhbGx5IHBhcnNlIGl0IGFzIGEgZnVsbCBlbGVtZW50IGFuZCBlbWl0IGFuIGVycm9yLlxuICAgICAgICAgICAgdGhpcy5fcG9wRWxlbWVudChmdWxsTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKFRyZWVFcnJvci5jcmVhdGUoZnVsbE5hbWUsIHNwYW4sIGBPcGVuaW5nIHRhZyBcIiR7ZnVsbE5hbWV9XCIgbm90IHRlcm1pbmF0ZWQuYCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9wdXNoRWxlbWVudChlbCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbCA9IHRoaXMuX2dldFBhcmVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudEVsICYmIHRoaXMuZ2V0VGFnRGVmaW5pdGlvbihwYXJlbnRFbC5uYW1lKS5pc0Nsb3NlZEJ5Q2hpbGQoZWwubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGRUb1BhcmVudChlbCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5wdXNoKGVsKTtcbiAgICB9XG4gICAgX2NvbnN1bWVFbmRUYWcoZW5kVGFnVG9rZW4pIHtcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSB0aGlzLl9nZXRFbGVtZW50RnVsbE5hbWUoZW5kVGFnVG9rZW4ucGFydHNbMF0sIGVuZFRhZ1Rva2VuLnBhcnRzWzFdLCB0aGlzLl9nZXRQYXJlbnRFbGVtZW50KCkpO1xuICAgICAgICBpZiAodGhpcy5nZXRUYWdEZWZpbml0aW9uKGZ1bGxOYW1lKS5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2goVHJlZUVycm9yLmNyZWF0ZShmdWxsTmFtZSwgZW5kVGFnVG9rZW4uc291cmNlU3BhbiwgYFZvaWQgZWxlbWVudHMgZG8gbm90IGhhdmUgZW5kIHRhZ3MgXCIke2VuZFRhZ1Rva2VuLnBhcnRzWzFdfVwiYCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9wb3BFbGVtZW50KGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYFVuZXhwZWN0ZWQgY2xvc2luZyB0YWcgXCIke2Z1bGxOYW1lfVwiLiBJdCBtYXkgaGFwcGVuIHdoZW4gdGhlIHRhZyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBieSBhbm90aGVyIHRhZy4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2Nsb3NpbmctZWxlbWVudHMtdGhhdC1oYXZlLWltcGxpZWQtZW5kLXRhZ3NgO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChUcmVlRXJyb3IuY3JlYXRlKGZ1bGxOYW1lLCBlbmRUYWdUb2tlbi5zb3VyY2VTcGFuLCBlcnJNc2cpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIG5lYXJlc3QgZWxlbWVudCB3aXRoIHRoZSB0YWcgbmFtZSBgZnVsbE5hbWVgIGluIHRoZSBwYXJzZSB0cmVlLlxuICAgICAqIGBlbmRTb3VyY2VTcGFuYCBpcyB0aGUgc3BhbiBvZiB0aGUgY2xvc2luZyB0YWcsIG9yIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc1xuICAgICAqIG5vdCBoYXZlIGEgY2xvc2luZyB0YWcgKGZvciBleGFtcGxlLCB0aGlzIGhhcHBlbnMgd2hlbiBhbiBpbmNvbXBsZXRlXG4gICAgICogb3BlbmluZyB0YWcgaXMgcmVjb3ZlcmVkKS5cbiAgICAgKi9cbiAgICBfcG9wRWxlbWVudChmdWxsTmFtZSwgZW5kU291cmNlU3Bhbikge1xuICAgICAgICBsZXQgdW5leHBlY3RlZENsb3NlVGFnRGV0ZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgc3RhY2tJbmRleCA9IHRoaXMuX2VsZW1lbnRTdGFjay5sZW5ndGggLSAxOyBzdGFja0luZGV4ID49IDA7IHN0YWNrSW5kZXgtLSkge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLl9lbGVtZW50U3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgICAgICBpZiAoZWwubmFtZSA9PT0gZnVsbE5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIHBhcnNlIHNwYW4gd2l0aCB0aGUgZWxlbWVudCB0aGF0IGlzIGJlaW5nIGNsb3NlZC4gQW55IGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IHN0YWNrIGF0IHRoaXMgcG9pbnQgYXJlIGNsb3NlZCBpbXBsaWNpdGx5LCBzbyB0aGV5IHdvbid0IGdldFxuICAgICAgICAgICAgICAgIC8vIGFuIGVuZCBzb3VyY2Ugc3BhbiAoYXMgdGhlcmUgaXMgbm8gZXhwbGljaXQgY2xvc2luZyBlbGVtZW50KS5cbiAgICAgICAgICAgICAgICBlbC5lbmRTb3VyY2VTcGFuID0gZW5kU291cmNlU3BhbjtcbiAgICAgICAgICAgICAgICBlbC5zb3VyY2VTcGFuLmVuZCA9IGVuZFNvdXJjZVNwYW4gIT09IG51bGwgPyBlbmRTb3VyY2VTcGFuLmVuZCA6IGVsLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRTdGFjay5zcGxpY2Uoc3RhY2tJbmRleCwgdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIHN0YWNrSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhdW5leHBlY3RlZENsb3NlVGFnRGV0ZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0VGFnRGVmaW5pdGlvbihlbC5uYW1lKS5jbG9zZWRCeVBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGNsb3NlIHRhZyBidXQgY29udGludWUgcHJvY2Vzc2luZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIHN0YWNrIHNvIHdlIGNhbiBhc3NpZ24gYW4gYGVuZFNvdXJjZVNwYW5gIGlmIHRoZXJlIGlzIGEgY29ycmVzcG9uZGluZyBzdGFydCB0YWcgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBlbmQgdGFnIGluIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkQ2xvc2VUYWdEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfY29uc3VtZUF0dHIoYXR0ck5hbWUpIHtcbiAgICAgICAgY29uc3QgZnVsbE5hbWUgPSBtZXJnZU5zQW5kTmFtZShhdHRyTmFtZS5wYXJ0c1swXSwgYXR0ck5hbWUucGFydHNbMV0pO1xuICAgICAgICBsZXQgYXR0ckVuZCA9IGF0dHJOYW1lLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICAvLyBDb25zdW1lIGFueSBxdW90ZVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxNSAvKiBUb2tlblR5cGUuQVRUUl9RVU9URSAqLykge1xuICAgICAgICAgICAgdGhpcy5fYWR2YW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN1bWUgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgY29uc3QgdmFsdWVUb2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IHZhbHVlU3RhcnRTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgdmFsdWVFbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIE5PVEU6IFdlIG5lZWQgdG8gdXNlIGEgbmV3IHZhcmlhYmxlIGBuZXh0VG9rZW5UeXBlYCBoZXJlIHRvIGhpZGUgdGhlIGFjdHVhbCB0eXBlIG9mXG4gICAgICAgIC8vIGBfcGVlay50eXBlYCBmcm9tIFRTLiBPdGhlcndpc2UgVFMgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2YgYF9wZWVrLnR5cGVgIHByZXZlbnRpbmcgaXQgZnJvbVxuICAgICAgICAvLyBiZWluZyBhYmxlIHRvIGNvbnNpZGVyIGBBVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT05gIGFzIGFuIG9wdGlvbi4gVGhpcyBpcyBiZWNhdXNlIFRTIGlzIG5vdFxuICAgICAgICAvLyBhYmxlIHRvIHNlZSB0aGF0IGBfYWR2YW5jZSgpYCB3aWxsIGFjdHVhbGx5IG11dGF0ZSBgX3BlZWtgLlxuICAgICAgICBjb25zdCBuZXh0VG9rZW5UeXBlID0gdGhpcy5fcGVlay50eXBlO1xuICAgICAgICBpZiAobmV4dFRva2VuVHlwZSA9PT0gMTYgLyogVG9rZW5UeXBlLkFUVFJfVkFMVUVfVEVYVCAqLykge1xuICAgICAgICAgICAgdmFsdWVTdGFydFNwYW4gPSB0aGlzLl9wZWVrLnNvdXJjZVNwYW47XG4gICAgICAgICAgICB2YWx1ZUVuZCA9IHRoaXMuX3BlZWsuc291cmNlU3Bhbi5lbmQ7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcGVlay50eXBlID09PSAxNiAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9URVhUICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSAxNyAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlay50eXBlID09PSA5IC8qIFRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9rZW4gPSB0aGlzLl9hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVUb2tlbnMucHVzaCh2YWx1ZVRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVUb2tlbi50eXBlID09PSAxNyAvKiBUb2tlblR5cGUuQVRUUl9WQUxVRV9JTlRFUlBPTEFUSU9OICovKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdlIGRlY29kZSBIVE1MIGVudGl0aWVzIHRoYXQgYXBwZWFyIGluIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbnMuIFRoaXMgaXMgYXJndWFibHkgYSBidWcsIGJ1dCBpdCBjb3VsZCBiZSBhIGNvbnNpZGVyYWJsZSBicmVha2luZyBjaGFuZ2UgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gZml4IGl0LiBJdCBzaG91bGQgYmUgYWRkcmVzc2VkIGluIGEgbGFyZ2VyIHByb2plY3QgdG8gcmVmYWN0b3IgdGhlIGVudGlyZSBwYXJzZXIvbGV4ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhaW4gYWZ0ZXIgVmlldyBFbmdpbmUgaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdmFsdWVUb2tlbi5wYXJ0cy5qb2luKCcnKS5yZXBsYWNlKC8mKFteO10rKTsvZywgZGVjb2RlRW50aXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVUb2tlbi50eXBlID09PSA5IC8qIFRva2VuVHlwZS5FTkNPREVEX0VOVElUWSAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSB2YWx1ZVRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdmFsdWVUb2tlbi5wYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVFbmQgPSBhdHRyRW5kID0gdmFsdWVUb2tlbi5zb3VyY2VTcGFuLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdW1lIGFueSBxdW90ZVxuICAgICAgICBpZiAodGhpcy5fcGVlay50eXBlID09PSAxNSAvKiBUb2tlblR5cGUuQVRUUl9RVU9URSAqLykge1xuICAgICAgICAgICAgY29uc3QgcXVvdGVUb2tlbiA9IHRoaXMuX2FkdmFuY2UoKTtcbiAgICAgICAgICAgIGF0dHJFbmQgPSBxdW90ZVRva2VuLnNvdXJjZVNwYW4uZW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlU3BhbiA9IHZhbHVlU3RhcnRTcGFuICYmIHZhbHVlRW5kICYmXG4gICAgICAgICAgICBuZXcgUGFyc2VTb3VyY2VTcGFuKHZhbHVlU3RhcnRTcGFuLnN0YXJ0LCB2YWx1ZUVuZCwgdmFsdWVTdGFydFNwYW4uZnVsbFN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGUoZnVsbE5hbWUsIHZhbHVlLCBuZXcgUGFyc2VTb3VyY2VTcGFuKGF0dHJOYW1lLnNvdXJjZVNwYW4uc3RhcnQsIGF0dHJFbmQsIGF0dHJOYW1lLnNvdXJjZVNwYW4uZnVsbFN0YXJ0KSwgYXR0ck5hbWUuc291cmNlU3BhbiwgdmFsdWVTcGFuLCB2YWx1ZVRva2Vucy5sZW5ndGggPiAwID8gdmFsdWVUb2tlbnMgOiB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIF9nZXRQYXJlbnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCA+IDAgPyB0aGlzLl9lbGVtZW50U3RhY2tbdGhpcy5fZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdIDogbnVsbDtcbiAgICB9XG4gICAgX2FkZFRvUGFyZW50KG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RWxlbWVudCgpO1xuICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RWxlbWVudEZ1bGxOYW1lKHByZWZpeCwgbG9jYWxOYW1lLCBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIGlmIChwcmVmaXggPT09ICcnKSB7XG4gICAgICAgICAgICBwcmVmaXggPSB0aGlzLmdldFRhZ0RlZmluaXRpb24obG9jYWxOYW1lKS5pbXBsaWNpdE5hbWVzcGFjZVByZWZpeCB8fCAnJztcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09ICcnICYmIHBhcmVudEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBzcGxpdE5zTmFtZShwYXJlbnRFbGVtZW50Lm5hbWUpWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFRhZ0RlZmluaXRpb24gPSB0aGlzLmdldFRhZ0RlZmluaXRpb24ocGFyZW50VGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUYWdEZWZpbml0aW9uLnByZXZlbnROYW1lc3BhY2VJbmhlcml0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBnZXROc1ByZWZpeChwYXJlbnRFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VOc0FuZE5hbWUocHJlZml4LCBsb2NhbE5hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxhc3RPblN0YWNrKHN0YWNrLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA+IDAgJiYgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IGVsZW1lbnQ7XG59XG4vKipcbiAqIERlY29kZSB0aGUgYGVudGl0eWAgc3RyaW5nLCB3aGljaCB3ZSBiZWxpZXZlIGlzIHRoZSBjb250ZW50cyBvZiBhbiBIVE1MIGVudGl0eS5cbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIG5vdCBhY3R1YWxseSBhIHZhbGlkL2tub3duIGVudGl0eSB0aGVuIGp1c3QgcmV0dXJuIHRoZSBvcmlnaW5hbCBgbWF0Y2hgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlRW50aXR5KG1hdGNoLCBlbnRpdHkpIHtcbiAgICBpZiAoTkFNRURfRU5USVRJRVNbZW50aXR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBOQU1FRF9FTlRJVElFU1tlbnRpdHldIHx8IG1hdGNoO1xuICAgIH1cbiAgICBpZiAoL14jeFthLWYwLTldKyQvaS50ZXN0KGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGVudGl0eS5zbGljZSgyKSwgMTYpKTtcbiAgICB9XG4gICAgaWYgKC9eI1xcZCskLy50ZXN0KGVudGl0eSkpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGVudGl0eS5zbGljZSgxKSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufVxuXG5jbGFzcyBIdG1sUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZ2V0SHRtbFRhZ0RlZmluaXRpb24pO1xuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY29uc3QgUFJFU0VSVkVfV1NfQVRUUl9OQU1FID0gJ25nUHJlc2VydmVXaGl0ZXNwYWNlcyc7XG5jb25zdCBTS0lQX1dTX1RSSU1fVEFHUyA9IG5ldyBTZXQoWydwcmUnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAnc2NyaXB0JywgJ3N0eWxlJ10pO1xuLy8gRXF1aXZhbGVudCB0byBcXHMgd2l0aCBcXHUwMGEwIChub24tYnJlYWtpbmcgc3BhY2UpIGV4Y2x1ZGVkLlxuLy8gQmFzZWQgb24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwXG5jb25zdCBXU19DSEFSUyA9ICcgXFxmXFxuXFxyXFx0XFx2XFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmYnO1xuY29uc3QgTk9fV1NfUkVHRVhQID0gbmV3IFJlZ0V4cChgW14ke1dTX0NIQVJTfV1gKTtcbmNvbnN0IFdTX1JFUExBQ0VfUkVHRVhQID0gbmV3IFJlZ0V4cChgWyR7V1NfQ0hBUlN9XXsyLH1gLCAnZycpO1xuZnVuY3Rpb24gaGFzUHJlc2VydmVXaGl0ZXNwYWNlc0F0dHIoYXR0cnMpIHtcbiAgICByZXR1cm4gYXR0cnMuc29tZSgoYXR0cikgPT4gYXR0ci5uYW1lID09PSBQUkVTRVJWRV9XU19BVFRSX05BTUUpO1xufVxuLyoqXG4gKiBBbmd1bGFyIERhcnQgaW50cm9kdWNlZCAmbmdzcDsgYXMgYSBwbGFjZWhvbGRlciBmb3Igbm9uLXJlbW92YWJsZSBzcGFjZSwgc2VlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2RhcnQtbGFuZy9hbmd1bGFyL2Jsb2IvMGJiNjExMzg3ZDI5ZDY1YjVhZjdmOWQyNTE1YWI1NzFmZDNmYmVlNC9fdGVzdHMvdGVzdC9jb21waWxlci9wcmVzZXJ2ZV93aGl0ZXNwYWNlX3Rlc3QuZGFydCNMMjUtTDMyXG4gKiBJbiBBbmd1bGFyIERhcnQgJm5nc3A7IGlzIGNvbnZlcnRlZCB0byB0aGUgMHhFNTAwIFBVQSAoUHJpdmF0ZSBVc2UgQXJlYXMpIHVuaWNvZGUgY2hhcmFjdGVyXG4gKiBhbmQgbGF0ZXIgb24gcmVwbGFjZWQgYnkgYSBzcGFjZS4gV2UgYXJlIHJlLWltcGxlbWVudGluZyB0aGUgc2FtZSBpZGVhIGhlcmUuXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2VOZ3NwKHZhbHVlKSB7XG4gICAgLy8gbGV4ZXIgaXMgcmVwbGFjaW5nIHRoZSAmbmdzcDsgcHNldWRvLWVudGl0eSB3aXRoIE5HU1BfVU5JQ09ERVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoTkdTUF9VTklDT0RFLCAnZycpLCAnICcpO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3IgY2FuIHdhbGsgSFRNTCBwYXJzZSB0cmVlIGFuZCByZW1vdmUgLyB0cmltIHRleHQgbm9kZXMgdXNpbmcgdGhlIGZvbGxvd2luZyBydWxlczpcbiAqIC0gY29uc2lkZXIgc3BhY2VzLCB0YWJzIGFuZCBuZXcgbGluZXMgYXMgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzO1xuICogLSBkcm9wIHRleHQgbm9kZXMgY29uc2lzdGluZyBvZiB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgb25seTtcbiAqIC0gZm9yIGFsbCBvdGhlciB0ZXh0IG5vZGVzIHJlcGxhY2UgY29uc2VjdXRpdmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHdpdGggb25lIHNwYWNlO1xuICogLSBjb252ZXJ0ICZuZ3NwOyBwc2V1ZG8tZW50aXR5IHRvIGEgc2luZ2xlIHNwYWNlO1xuICpcbiAqIFJlbW92YWwgYW5kIHRyaW1taW5nIG9mIHdoaXRlc3BhY2VzIGhhdmUgcG9zaXRpdmUgcGVyZm9ybWFuY2UgaW1wYWN0IChsZXNzIGNvZGUgdG8gZ2VuZXJhdGVcbiAqIHdoaWxlIGNvbXBpbGluZyB0ZW1wbGF0ZXMsIGZhc3RlciB2aWV3IGNyZWF0aW9uKS4gQXQgdGhlIHNhbWUgdGltZSBpdCBjYW4gYmUgXCJkZXN0cnVjdGl2ZVwiXG4gKiBpbiBzb21lIGNhc2VzICh3aGl0ZXNwYWNlcyBjYW4gaW5mbHVlbmNlIGxheW91dCkuIEJlY2F1c2Ugb2YgdGhlIHBvdGVudGlhbCBvZiBicmVha2luZyBsYXlvdXRcbiAqIHRoaXMgdmlzaXRvciBpcyBub3QgYWN0aXZhdGVkIGJ5IGRlZmF1bHQgaW4gQW5ndWxhciA1IGFuZCBwZW9wbGUgbmVlZCB0byBleHBsaWNpdGx5IG9wdC1pbiBmb3JcbiAqIHdoaXRlc3BhY2UgcmVtb3ZhbC4gVGhlIGRlZmF1bHQgb3B0aW9uIGZvciB3aGl0ZXNwYWNlIHJlbW92YWwgd2lsbCBiZSByZXZpc2l0ZWQgaW4gQW5ndWxhciA2XG4gKiBhbmQgbWlnaHQgYmUgY2hhbmdlZCB0byBcIm9uXCIgYnkgZGVmYXVsdC5cbiAqL1xuY2xhc3MgV2hpdGVzcGFjZVZpc2l0b3Ige1xuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChTS0lQX1dTX1RSSU1fVEFHUy5oYXMoZWxlbWVudC5uYW1lKSB8fCBoYXNQcmVzZXJ2ZVdoaXRlc3BhY2VzQXR0cihlbGVtZW50LmF0dHJzKSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZGVzY2VudCBpbnRvIGVsZW1lbnRzIHdoZXJlIHdlIG5lZWQgdG8gcHJlc2VydmUgd2hpdGVzcGFjZXNcbiAgICAgICAgICAgIC8vIGJ1dCBzdGlsbCB2aXNpdCBhbGwgYXR0cmlidXRlcyB0byBlbGltaW5hdGUgb25lIHVzZWQgYXMgYSBtYXJrZXQgdG8gcHJlc2VydmUgV1NcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudChlbGVtZW50Lm5hbWUsIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuYXR0cnMpLCBlbGVtZW50LmNoaWxkcmVuLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQubmFtZSwgZWxlbWVudC5hdHRycywgdmlzaXRBbGxXaXRoU2libGluZ3ModGhpcywgZWxlbWVudC5jaGlsZHJlbiksIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGUubmFtZSAhPT0gUFJFU0VSVkVfV1NfQVRUUl9OQU1FID8gYXR0cmlidXRlIDogbnVsbDtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaXNOb3RCbGFuayA9IHRleHQudmFsdWUubWF0Y2goTk9fV1NfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgaGFzRXhwYW5zaW9uU2libGluZyA9IGNvbnRleHQgJiZcbiAgICAgICAgICAgIChjb250ZXh0LnByZXYgaW5zdGFuY2VvZiBFeHBhbnNpb24gfHwgY29udGV4dC5uZXh0IGluc3RhbmNlb2YgRXhwYW5zaW9uKTtcbiAgICAgICAgaWYgKGlzTm90QmxhbmsgfHwgaGFzRXhwYW5zaW9uU2libGluZykge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgd2hpdGVzcGFjZSBpbiB0aGUgdG9rZW5zIG9mIHRoaXMgVGV4dCBub2RlXG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0ZXh0LnRva2Vucy5tYXAodG9rZW4gPT4gdG9rZW4udHlwZSA9PT0gNSAvKiBUb2tlblR5cGUuVEVYVCAqLyA/IGNyZWF0ZVdoaXRlc3BhY2VQcm9jZXNzZWRUZXh0VG9rZW4odG9rZW4pIDogdG9rZW4pO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgd2hpdGVzcGFjZSBvZiB0aGUgdmFsdWUgb2YgdGhpcyBUZXh0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzc1doaXRlc3BhY2UodGV4dC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHQodmFsdWUsIHRleHQuc291cmNlU3BhbiwgdG9rZW5zLCB0ZXh0LmkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb247XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBleHBhbnNpb25DYXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVdoaXRlc3BhY2VQcm9jZXNzZWRUZXh0VG9rZW4oeyB0eXBlLCBwYXJ0cywgc291cmNlU3BhbiB9KSB7XG4gICAgcmV0dXJuIHsgdHlwZSwgcGFydHM6IFtwcm9jZXNzV2hpdGVzcGFjZShwYXJ0c1swXSldLCBzb3VyY2VTcGFuIH07XG59XG5mdW5jdGlvbiBwcm9jZXNzV2hpdGVzcGFjZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOZ3NwKHRleHQpLnJlcGxhY2UoV1NfUkVQTEFDRV9SRUdFWFAsICcgJyk7XG59XG5mdW5jdGlvbiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sQXN0V2l0aEVycm9ycykge1xuICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHZpc2l0QWxsKG5ldyBXaGl0ZXNwYWNlVmlzaXRvcigpLCBodG1sQXN0V2l0aEVycm9ycy5yb290Tm9kZXMpLCBodG1sQXN0V2l0aEVycm9ycy5lcnJvcnMpO1xufVxuZnVuY3Rpb24gdmlzaXRBbGxXaXRoU2libGluZ3ModmlzaXRvciwgbm9kZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKChhc3QsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHsgcHJldjogbm9kZXNbaSAtIDFdLCBuZXh0OiBub2Rlc1tpICsgMV0gfTtcbiAgICAgICAgY29uc3QgYXN0UmVzdWx0ID0gYXN0LnZpc2l0KHZpc2l0b3IsIGNvbnRleHQpO1xuICAgICAgICBpZiAoYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhc3RSZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWFwRW50cnkoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB7IGtleSwgdmFsdWUsIHF1b3RlZDogZmFsc2UgfTtcbn1cbmZ1bmN0aW9uIG1hcExpdGVyYWwob2JqLCBxdW90ZWQgPSBmYWxzZSkge1xuICAgIHJldHVybiBsaXRlcmFsTWFwKE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiAoe1xuICAgICAgICBrZXksXG4gICAgICAgIHF1b3RlZCxcbiAgICAgICAgdmFsdWU6IG9ialtrZXldLFxuICAgIH0pKSk7XG59XG5cbi8qKlxuICogU2V0IG9mIHRhZ05hbWV8cHJvcGVydHlOYW1lIGNvcnJlc3BvbmRpbmcgdG8gVHJ1c3RlZCBUeXBlcyBzaW5rcy4gUHJvcGVydGllcyBhcHBseWluZyB0byBhbGxcbiAqIHRhZ3MgdXNlICcqJy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSwgYW5kIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aFxuICogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy10cnVzdGVkLXR5cGVzL2Rpc3Qvc3BlYy8jaW50ZWdyYXRpb25zXG4gKi9cbmNvbnN0IFRSVVNURURfVFlQRVNfU0lOS1MgPSBuZXcgU2V0KFtcbiAgICAvLyBOT1RFOiBBbGwgc3RyaW5ncyBpbiB0aGlzIHNldCAqbXVzdCogYmUgbG93ZXJjYXNlIVxuICAgIC8vIFRydXN0ZWRIVE1MXG4gICAgJ2lmcmFtZXxzcmNkb2MnLFxuICAgICcqfGlubmVyaHRtbCcsXG4gICAgJyp8b3V0ZXJodG1sJyxcbiAgICAvLyBOQjogbm8gVHJ1c3RlZFNjcmlwdCBoZXJlLCBhcyB0aGUgY29ycmVzcG9uZGluZyB0YWdzIGFyZSBzdHJpcHBlZCBieSB0aGUgY29tcGlsZXIuXG4gICAgLy8gVHJ1c3RlZFNjcmlwdFVSTFxuICAgICdlbWJlZHxzcmMnLFxuICAgICdvYmplY3R8Y29kZWJhc2UnLFxuICAgICdvYmplY3R8ZGF0YScsXG5dKTtcbi8qKlxuICogaXNUcnVzdGVkVHlwZXNTaW5rIHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgb24gdGhlIGdpdmVuIERPTSB0YWcgaXMgYSBUcnVzdGVkIFR5cGVzXG4gKiBzaW5rLiBJbiB0aGF0IGNhc2UsIHVzZSBgRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dGAgdG8gZGV0ZXJtaW5lIHdoaWNoIHBhcnRpY3VsYXJcbiAqIFRydXN0ZWQgVHlwZSBpcyByZXF1aXJlZCBmb3IgdmFsdWVzIHBhc3NlZCB0byB0aGUgc2luazpcbiAqIC0gU2VjdXJpdHlDb250ZXh0LkhUTUwgY29ycmVzcG9uZHMgdG8gVHJ1c3RlZEhUTUxcbiAqIC0gU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCBjb3JyZXNwb25kcyB0byBUcnVzdGVkU2NyaXB0VVJMXG4gKi9cbmZ1bmN0aW9uIGlzVHJ1c3RlZFR5cGVzU2luayh0YWdOYW1lLCBwcm9wTmFtZSkge1xuICAgIC8vIE1ha2Ugc3VyZSBjb21wYXJpc29ucyBhcmUgY2FzZSBpbnNlbnNpdGl2ZSwgc28gdGhhdCBjYXNlIGRpZmZlcmVuY2VzIGJldHdlZW4gYXR0cmlidXRlIGFuZFxuICAgIC8vIHByb3BlcnR5IG5hbWVzIGRvIG5vdCBoYXZlIGEgc2VjdXJpdHkgaW1wYWN0LlxuICAgIHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcHJvcE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBUUlVTVEVEX1RZUEVTX1NJTktTLmhhcyh0YWdOYW1lICsgJ3wnICsgcHJvcE5hbWUpIHx8XG4gICAgICAgIFRSVVNURURfVFlQRVNfU0lOS1MuaGFzKCcqfCcgKyBwcm9wTmFtZSk7XG59XG5cbmNvbnN0IFBST1BFUlRZX1BBUlRTX1NFUEFSQVRPUiA9ICcuJztcbmNvbnN0IEFUVFJJQlVURV9QUkVGSVggPSAnYXR0cic7XG5jb25zdCBDTEFTU19QUkVGSVggPSAnY2xhc3MnO1xuY29uc3QgU1RZTEVfUFJFRklYID0gJ3N0eWxlJztcbmNvbnN0IFRFTVBMQVRFX0FUVFJfUFJFRklYJDEgPSAnKic7XG5jb25zdCBBTklNQVRFX1BST1BfUFJFRklYID0gJ2FuaW1hdGUtJztcbi8qKlxuICogUGFyc2VzIGJpbmRpbmdzIGluIHRlbXBsYXRlcyBhbmQgaW4gdGhlIGRpcmVjdGl2ZSBob3N0IGFyZWEuXG4gKi9cbmNsYXNzIEJpbmRpbmdQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKF9leHByUGFyc2VyLCBfaW50ZXJwb2xhdGlvbkNvbmZpZywgX3NjaGVtYVJlZ2lzdHJ5LCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5fZXhwclBhcnNlciA9IF9leHByUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnID0gX2ludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHRoaXMuX3NjaGVtYVJlZ2lzdHJ5ID0gX3NjaGVtYVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB9XG4gICAgZ2V0IGludGVycG9sYXRpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICBjcmVhdGVCb3VuZEhvc3RQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgY29uc3QgYm91bmRQcm9wcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5QmluZGluZyhwcm9wTmFtZSwgZXhwcmVzc2lvbiwgdHJ1ZSwgc291cmNlU3Bhbiwgc291cmNlU3Bhbi5zdGFydC5vZmZzZXQsIHVuZGVmaW5lZCwgW10sIFxuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYHNvdXJjZVNwYW5gIGZvciAgYGtleVNwYW5gLiBUaGlzIGlzbid0IHJlYWxseSBhY2N1cmF0ZSwgYnV0IG5laXRoZXIgaXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gc291cmNlU3BhbiwgYXMgaXQgcmVwcmVzZW50cyB0aGUgc291cmNlU3BhbiBvZiB0aGUgaG9zdCBpdHNlbGYgcmF0aGVyIHRoYW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gc291cmNlIG9mIHRoZSBob3N0IGJpbmRpbmcgKHdoaWNoIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRlbXBsYXRlKS4gUmVnYXJkbGVzcyxcbiAgICAgICAgICAgICAgICAvLyBuZWl0aGVyIG9mIHRoZXNlIHZhbHVlcyBhcmUgdXNlZCBpbiBJdnkgYnV0IGFyZSBvbmx5IGhlcmUgdG8gc2F0aXNmeSB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmUuIFRoaXMgc2hvdWxkIGxpa2VseSBiZSByZWZhY3RvcmVkIGluIHRoZSBmdXR1cmUgc28gdGhhdCBgc291cmNlU3BhbmBcbiAgICAgICAgICAgICAgICAvLyBpc24ndCBiZWluZyB1c2VkIGluYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICBib3VuZFByb3BzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBWYWx1ZSBvZiB0aGUgaG9zdCBwcm9wZXJ0eSBiaW5kaW5nIFwiJHtwcm9wTmFtZX1cIiBuZWVkcyB0byBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gZXhwcmVzc2lvbiBidXQgZ290IFwiJHtleHByZXNzaW9ufVwiICgke3R5cGVvZiBleHByZXNzaW9ufSlgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRQcm9wcztcbiAgICB9XG4gICAgY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhob3N0TGlzdGVuZXJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldEV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIE9iamVjdC5rZXlzKGhvc3RMaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gaG9zdExpc3RlbmVyc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBgc291cmNlU3BhbmAgZm9yICBga2V5U3BhbmAgYW5kIGBoYW5kbGVyU3BhbmAuIFRoaXMgaXNuJ3QgcmVhbGx5IGFjY3VyYXRlLCBidXRcbiAgICAgICAgICAgICAgICAvLyBuZWl0aGVyIGlzIHRoZSBgc291cmNlU3BhbmAsIGFzIGl0IHJlcHJlc2VudHMgdGhlIGBzb3VyY2VTcGFuYCBvZiB0aGUgaG9zdCBpdHNlbGZcbiAgICAgICAgICAgICAgICAvLyByYXRoZXIgdGhhbiB0aGUgc291cmNlIG9mIHRoZSBob3N0IGJpbmRpbmcgKHdoaWNoIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHRlbXBsYXRlKS5cbiAgICAgICAgICAgICAgICAvLyBSZWdhcmRsZXNzLCBuZWl0aGVyIG9mIHRoZXNlIHZhbHVlcyBhcmUgdXNlZCBpbiBJdnkgYnV0IGFyZSBvbmx5IGhlcmUgdG8gc2F0aXNmeSB0aGVcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBzaWduYXR1cmUuIFRoaXMgc2hvdWxkIGxpa2VseSBiZSByZWZhY3RvcmVkIGluIHRoZSBmdXR1cmUgc28gdGhhdCBgc291cmNlU3BhbmBcbiAgICAgICAgICAgICAgICAvLyBpc24ndCBiZWluZyB1c2VkIGluYWNjdXJhdGVseS5cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlRXZlbnQocHJvcE5hbWUsIGV4cHJlc3Npb24sIC8qIGlzQXNzaWdubWVudEV2ZW50ICovIGZhbHNlLCBzb3VyY2VTcGFuLCBzb3VyY2VTcGFuLCBbXSwgdGFyZ2V0RXZlbnRzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBWYWx1ZSBvZiB0aGUgaG9zdCBsaXN0ZW5lciBcIiR7cHJvcE5hbWV9XCIgbmVlZHMgdG8gYmUgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGV4cHJlc3Npb24gYnV0IGdvdCBcIiR7ZXhwcmVzc2lvbn1cIiAoJHt0eXBlb2YgZXhwcmVzc2lvbn0pYCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldEV2ZW50cztcbiAgICB9XG4gICAgcGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMpIHtcbiAgICAgICAgY29uc3Qgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVPZmZzZXQgPSBzb3VyY2VTcGFuLmZ1bGxTdGFydC5vZmZzZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbih2YWx1ZSwgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQsIGludGVycG9sYXRlZFRva2VucywgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gYHBhcnNlSW50ZXJwb2xhdGlvbmAsIGJ1dCB0cmVhdHMgdGhlIHByb3ZpZGVkIHN0cmluZyBhcyBhIHNpbmdsZSBleHByZXNzaW9uXG4gICAgICogZWxlbWVudCB0aGF0IHdvdWxkIG5vcm1hbGx5IGFwcGVhciB3aXRoaW4gdGhlIGludGVycG9sYXRpb24gcHJlZml4IGFuZCBzdWZmaXggKGB7e2AgYW5kIGB9fWApLlxuICAgICAqIFRoaXMgaXMgdXNlZCBmb3IgcGFyc2luZyB0aGUgc3dpdGNoIGV4cHJlc3Npb24gaW4gSUNVcy5cbiAgICAgKi9cbiAgICBwYXJzZUludGVycG9sYXRpb25FeHByZXNzaW9uKGV4cHJlc3Npb24sIHNvdXJjZVNwYW4pIHtcbiAgICAgICAgY29uc3Qgc291cmNlSW5mbyA9IHNvdXJjZVNwYW4uc3RhcnQudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVPZmZzZXQgPSBzb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX2V4cHJQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgICAgICBpZiAoYXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEV4cHJlc3Npb25QYXJzZXJFcnJvcnMoYXN0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgYmluZGluZ3MgaW4gYSBtaWNyb3N5bnRheCBleHByZXNzaW9uLCBhbmQgY29udmVydHMgdGhlbSB0b1xuICAgICAqIGBQYXJzZWRQcm9wZXJ0eWAgb3IgYFBhcnNlZFZhcmlhYmxlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cGxLZXkgdGVtcGxhdGUgYmluZGluZyBuYW1lXG4gICAgICogQHBhcmFtIHRwbFZhbHVlIHRlbXBsYXRlIGJpbmRpbmcgdmFsdWVcbiAgICAgKiBAcGFyYW0gc291cmNlU3BhbiBzcGFuIG9mIHRlbXBsYXRlIGJpbmRpbmcgcmVsYXRpdmUgdG8gZW50aXJlIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZVZhbHVlT2Zmc2V0IHN0YXJ0IG9mIHRoZSB0cGxWYWx1ZSByZWxhdGl2ZSB0byB0aGUgZW50aXJlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHRhcmdldE1hdGNoYWJsZUF0dHJzIHBvdGVudGlhbCBhdHRyaWJ1dGVzIHRvIG1hdGNoIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB0YXJnZXRQcm9wcyB0YXJnZXQgcHJvcGVydHkgYmluZGluZ3MgaW4gdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHRhcmdldFZhcnMgdGFyZ2V0IHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGVcbiAgICAgKi9cbiAgICBwYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZVZhbHVlT2Zmc2V0LCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIHRhcmdldFZhcnMsIGlzSXZ5QXN0KSB7XG4gICAgICAgIGNvbnN0IGFic29sdXRlS2V5T2Zmc2V0ID0gc291cmNlU3Bhbi5zdGFydC5vZmZzZXQgKyBURU1QTEFURV9BVFRSX1BSRUZJWCQxLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQmluZGluZ3ModHBsS2V5LCB0cGxWYWx1ZSwgc291cmNlU3BhbiwgYWJzb2x1dGVLZXlPZmZzZXQsIGFic29sdXRlVmFsdWVPZmZzZXQpO1xuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIC8vIHNvdXJjZVNwYW4gaXMgZm9yIHRoZSBlbnRpcmUgSFRNTCBhdHRyaWJ1dGUuIGJpbmRpbmdTcGFuIGlzIGZvciBhIHBhcnRpY3VsYXJcbiAgICAgICAgICAgIC8vIGJpbmRpbmcgd2l0aGluIHRoZSBtaWNyb3N5bnRheCBleHByZXNzaW9uIHNvIGl0J3MgbW9yZSBuYXJyb3cgdGhhbiBzb3VyY2VTcGFuLlxuICAgICAgICAgICAgY29uc3QgYmluZGluZ1NwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGJpbmRpbmcuc291cmNlU3Bhbik7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBiaW5kaW5nLmtleS5zb3VyY2U7XG4gICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLCBiaW5kaW5nLmtleS5zcGFuKTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nIGluc3RhbmNlb2YgVmFyaWFibGVCaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nLnZhbHVlID8gYmluZGluZy52YWx1ZS5zb3VyY2UgOiAnJGltcGxpY2l0JztcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNwYW4gPSBiaW5kaW5nLnZhbHVlID8gbW92ZVBhcnNlU291cmNlU3Bhbihzb3VyY2VTcGFuLCBiaW5kaW5nLnZhbHVlLnNwYW4pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRhcmdldFZhcnMucHVzaChuZXcgUGFyc2VkVmFyaWFibGUoa2V5LCB2YWx1ZSwgYmluZGluZ1NwYW4sIGtleVNwYW4sIHZhbHVlU3BhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZGluZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY1NwYW4gPSBpc0l2eUFzdCA/IGJpbmRpbmdTcGFuIDogc291cmNlU3BhbjtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNwYW4gPSBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGJpbmRpbmcudmFsdWUuYXN0LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlUHJvcGVydHlBc3Qoa2V5LCBiaW5kaW5nLnZhbHVlLCBzcmNTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtrZXksICcnIC8qIHZhbHVlICovXSk7XG4gICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGxpdGVyYWwgYXR0cmlidXRlIHdpdGggbm8gUkhTLCBzb3VyY2Ugc3BhbiBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRoZSBrZXkgc3Bhbi5cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTGl0ZXJhbEF0dHIoa2V5LCBudWxsIC8qIHZhbHVlICovLCBrZXlTcGFuLCBhYnNvbHV0ZVZhbHVlT2Zmc2V0LCB1bmRlZmluZWQgLyogdmFsdWVTcGFuICovLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgYmluZGluZ3MgaW4gYSBtaWNyb3N5bnRheCBleHByZXNzaW9uLCBlLmcuXG4gICAgICogYGBgXG4gICAgICogICAgPHRhZyAqdHBsS2V5PVwibGV0IHZhbHVlMSA9IHByb3A7IGxldCB2YWx1ZTIgPSBsb2NhbFZhclwiPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRwbEtleSB0ZW1wbGF0ZSBiaW5kaW5nIG5hbWVcbiAgICAgKiBAcGFyYW0gdHBsVmFsdWUgdGVtcGxhdGUgYmluZGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIHNwYW4gb2YgdGVtcGxhdGUgYmluZGluZyByZWxhdGl2ZSB0byBlbnRpcmUgdGhlIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIGFic29sdXRlS2V5T2Zmc2V0IHN0YXJ0IG9mIHRoZSBgdHBsS2V5YFxuICAgICAqIEBwYXJhbSBhYnNvbHV0ZVZhbHVlT2Zmc2V0IHN0YXJ0IG9mIHRoZSBgdHBsVmFsdWVgXG4gICAgICovXG4gICAgX3BhcnNlVGVtcGxhdGVCaW5kaW5ncyh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVWYWx1ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBzb3VyY2VJbmZvID0gc291cmNlU3Bhbi5zdGFydC50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmluZGluZ3NSZXN1bHQgPSB0aGlzLl9leHByUGFyc2VyLnBhcnNlVGVtcGxhdGVCaW5kaW5ncyh0cGxLZXksIHRwbFZhbHVlLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZUtleU9mZnNldCwgYWJzb2x1dGVWYWx1ZU9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGJpbmRpbmdzUmVzdWx0LmVycm9ycywgc291cmNlU3Bhbik7XG4gICAgICAgICAgICBiaW5kaW5nc1Jlc3VsdC53YXJuaW5ncy5mb3JFYWNoKCh3YXJuaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iod2FybmluZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLldBUk5JTkcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmluZGluZ3NSZXN1bHQudGVtcGxhdGVCaW5kaW5ncztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYCR7ZX1gLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIGtleVNwYW4pIHtcbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGlmIChrZXlTcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3BhbihrZXlTcGFuLCBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleVNwYW4uc3RhcnQub2Zmc2V0ICsgMSwga2V5U3Bhbi5lbmQub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgQXNzaWduaW5nIGFuaW1hdGlvbiB0cmlnZ2VycyB2aWEgQHByb3A9XCJleHBcIiBhdHRyaWJ1dGVzIHdpdGggYW4gZXhwcmVzc2lvbiBpcyBpbnZhbGlkLmAgK1xuICAgICAgICAgICAgICAgICAgICBgIFVzZSBwcm9wZXJ0eSBiaW5kaW5ncyAoZS5nLiBbQHByb3BdPVwiZXhwXCIpIG9yIHVzZSBhbiBhdHRyaWJ1dGUgd2l0aG91dCBhIHZhbHVlIChlLmcuIEBwcm9wKSBpbnN0ZWFkLmAsIHNvdXJjZVNwYW4sIFBhcnNlRXJyb3JMZXZlbC5FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbihuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IFBhcnNlZFByb3BlcnR5KG5hbWUsIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUodmFsdWUsICcnLCBhYnNvbHV0ZU9mZnNldCksIFBhcnNlZFByb3BlcnR5VHlwZS5MSVRFUkFMX0FUVFIsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlUHJvcGVydHlCaW5kaW5nKG5hbWUsIGV4cHJlc3Npb24sIGlzSG9zdCwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQsIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzLCBrZXlTcGFuKSB7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYFByb3BlcnR5IG5hbWUgaXMgbWlzc2luZyBpbiBiaW5kaW5nYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzQW5pbWF0aW9uUHJvcCA9IGZhbHNlO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEFOSU1BVEVfUFJPUF9QUkVGSVgpKSB7XG4gICAgICAgICAgICBpc0FuaW1hdGlvblByb3AgPSB0cnVlO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKEFOSU1BVEVfUFJPUF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChrZXlTcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3BhbihrZXlTcGFuLCBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleVNwYW4uc3RhcnQub2Zmc2V0ICsgQU5JTUFURV9QUk9QX1BSRUZJWC5sZW5ndGgsIGtleVNwYW4uZW5kLm9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQW5pbWF0aW9uTGFiZWwobmFtZSkpIHtcbiAgICAgICAgICAgIGlzQW5pbWF0aW9uUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAoa2V5U3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAga2V5U3BhbiA9IG1vdmVQYXJzZVNvdXJjZVNwYW4oa2V5U3BhbiwgbmV3IEFic29sdXRlU291cmNlU3BhbihrZXlTcGFuLnN0YXJ0Lm9mZnNldCArIDEsIGtleVNwYW4uZW5kLm9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvblByb3ApIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIHRoaXMuX3BhcnNlQmluZGluZyhleHByZXNzaW9uLCBpc0hvc3QsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuLCBhYnNvbHV0ZU9mZnNldCksIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldFByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc291cmNlU3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMsIGtleVNwYW4sIGludGVycG9sYXRlZFRva2Vucykge1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUludGVycG9sYXRpb24odmFsdWUsIHZhbHVlU3BhbiB8fCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMpO1xuICAgICAgICBpZiAoZXhwcikge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VQcm9wZXJ0eUFzdChuYW1lLCBleHByLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9wYXJzZVByb3BlcnR5QXN0KG5hbWUsIGFzdCwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0UHJvcHMpIHtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRQcm9wcy5wdXNoKG5ldyBQYXJzZWRQcm9wZXJ0eShuYW1lLCBhc3QsIFBhcnNlZFByb3BlcnR5VHlwZS5ERUZBVUxULCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9XG4gICAgX3BhcnNlQW5pbWF0aW9uKG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0LCBrZXlTcGFuLCB2YWx1ZVNwYW4sIHRhcmdldE1hdGNoYWJsZUF0dHJzLCB0YXJnZXRQcm9wcykge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKCdBbmltYXRpb24gdHJpZ2dlciBpcyBtaXNzaW5nJywgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIG9jY3VyIHdoZW4gYSBAdHJpZ2dlciBpcyBub3QgcGFpcmVkIHdpdGggYW4gZXhwcmVzc2lvbi5cbiAgICAgICAgLy8gRm9yIGFuaW1hdGlvbnMgaXQgaXMgdmFsaWQgdG8gbm90IGhhdmUgYW4gZXhwcmVzc2lvbiBzaW5jZSAqL3ZvaWRcbiAgICAgICAgLy8gc3RhdGVzIHdpbGwgYmUgYXBwbGllZCBieSBhbmd1bGFyIHdoZW4gdGhlIGVsZW1lbnQgaXMgYXR0YWNoZWQvZGV0YWNoZWRcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VCaW5kaW5nKGV4cHJlc3Npb24gfHwgJ3VuZGVmaW5lZCcsIGZhbHNlLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB0YXJnZXRNYXRjaGFibGVBdHRycy5wdXNoKFtuYW1lLCBhc3Quc291cmNlXSk7XG4gICAgICAgIHRhcmdldFByb3BzLnB1c2gobmV3IFBhcnNlZFByb3BlcnR5KG5hbWUsIGFzdCwgUGFyc2VkUHJvcGVydHlUeXBlLkFOSU1BVElPTiwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfVxuICAgIF9wYXJzZUJpbmRpbmcodmFsdWUsIGlzSG9zdEJpbmRpbmcsIHNvdXJjZVNwYW4sIGFic29sdXRlT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUluZm8gPSAoc291cmNlU3BhbiAmJiBzb3VyY2VTcGFuLnN0YXJ0IHx8ICcodW5rbm93biknKS50b1N0cmluZygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gaXNIb3N0QmluZGluZyA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZVNpbXBsZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwclBhcnNlci5wYXJzZUJpbmRpbmcodmFsdWUsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXhwcmVzc2lvblBhcnNlckVycm9ycyhhc3QuZXJyb3JzLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIHJldHVybiBhc3Q7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGAke2V9YCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQm91bmRFbGVtZW50UHJvcGVydHkoZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3AsIHNraXBWYWxpZGF0aW9uID0gZmFsc2UsIG1hcFByb3BlcnR5TmFtZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKGJvdW5kUHJvcC5pc0FuaW1hdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3VuZEVsZW1lbnRQcm9wZXJ0eShib3VuZFByb3AubmFtZSwgNCAvKiBCaW5kaW5nVHlwZS5BbmltYXRpb24gKi8sIFNlY3VyaXR5Q29udGV4dC5OT05FLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgbnVsbCwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGJvdW5kUHJvcC5rZXlTcGFuLCBib3VuZFByb3AudmFsdWVTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5pdCA9IG51bGw7XG4gICAgICAgIGxldCBiaW5kaW5nVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGJvdW5kUHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFydHMgPSBib3VuZFByb3AubmFtZS5zcGxpdChQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xuICAgICAgICBsZXQgc2VjdXJpdHlDb250ZXh0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNwZWNpYWwgY2FzZXMgKHByZWZpeCBzdHlsZSwgYXR0ciwgY2xhc3MpXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAocGFydHNbMF0gPT0gQVRUUklCVVRFX1BSRUZJWCkge1xuICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gcGFydHMuc2xpY2UoMSkuam9pbihQUk9QRVJUWV9QQVJUU19TRVBBUkFUT1IpO1xuICAgICAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShib3VuZFByb3BlcnR5TmFtZSwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyh0aGlzLl9zY2hlbWFSZWdpc3RyeSwgZWxlbWVudFNlbGVjdG9yLCBib3VuZFByb3BlcnR5TmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbnNTZXBhcmF0b3JJZHggPSBib3VuZFByb3BlcnR5TmFtZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5zU2VwYXJhdG9ySWR4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnMgPSBib3VuZFByb3BlcnR5TmFtZS5zdWJzdHJpbmcoMCwgbnNTZXBhcmF0b3JJZHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gYm91bmRQcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKG5zU2VwYXJhdG9ySWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kUHJvcGVydHlOYW1lID0gbWVyZ2VOc0FuZE5hbWUobnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IDEgLyogQmluZGluZ1R5cGUuQXR0cmlidXRlICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFydHNbMF0gPT0gQ0xBU1NfUFJFRklYKSB7XG4gICAgICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICBiaW5kaW5nVHlwZSA9IDIgLyogQmluZGluZ1R5cGUuQ2xhc3MgKi87XG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IFtTZWN1cml0eUNvbnRleHQuTk9ORV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJ0c1swXSA9PSBTVFlMRV9QUkVGSVgpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gcGFydHMubGVuZ3RoID4gMiA/IHBhcnRzWzJdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBib3VuZFByb3BlcnR5TmFtZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMyAvKiBCaW5kaW5nVHlwZS5TdHlsZSAqLztcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzID0gW1NlY3VyaXR5Q29udGV4dC5TVFlMRV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90IGEgc3BlY2lhbCBjYXNlLCB1c2UgdGhlIGZ1bGwgcHJvcGVydHkgbmFtZVxuICAgICAgICBpZiAoYm91bmRQcm9wZXJ0eU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFByb3BOYW1lID0gdGhpcy5fc2NoZW1hUmVnaXN0cnkuZ2V0TWFwcGVkUHJvcE5hbWUoYm91bmRQcm9wLm5hbWUpO1xuICAgICAgICAgICAgYm91bmRQcm9wZXJ0eU5hbWUgPSBtYXBQcm9wZXJ0eU5hbWUgPyBtYXBwZWRQcm9wTmFtZSA6IGJvdW5kUHJvcC5uYW1lO1xuICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cyA9IGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHModGhpcy5fc2NoZW1hUmVnaXN0cnksIGVsZW1lbnRTZWxlY3RvciwgbWFwcGVkUHJvcE5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgIGJpbmRpbmdUeXBlID0gMCAvKiBCaW5kaW5nVHlwZS5Qcm9wZXJ0eSAqLztcbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVByb3BlcnR5T3JBdHRyaWJ1dGVOYW1lKG1hcHBlZFByb3BOYW1lLCBib3VuZFByb3Auc291cmNlU3BhbiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQm91bmRFbGVtZW50UHJvcGVydHkoYm91bmRQcm9wZXJ0eU5hbWUsIGJpbmRpbmdUeXBlLCBzZWN1cml0eUNvbnRleHRzWzBdLCBib3VuZFByb3AuZXhwcmVzc2lvbiwgdW5pdCwgYm91bmRQcm9wLnNvdXJjZVNwYW4sIGJvdW5kUHJvcC5rZXlTcGFuLCBib3VuZFByb3AudmFsdWVTcGFuKTtcbiAgICB9XG4gICAgLy8gVE9ETzoga2V5U3BhbiBzaG91bGQgYmUgcmVxdWlyZWQgYnV0IHdhcyBtYWRlIG9wdGlvbmFsIHRvIGF2b2lkIGNoYW5naW5nIFZFIHBhcnNlci5cbiAgICBwYXJzZUV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIGlzQXNzaWdubWVudEV2ZW50LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cywga2V5U3Bhbikge1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBFdmVudCBuYW1lIGlzIG1pc3NpbmcgaW4gYmluZGluZ2AsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkxhYmVsKG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmIChrZXlTcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrZXlTcGFuID0gbW92ZVBhcnNlU291cmNlU3BhbihrZXlTcGFuLCBuZXcgQWJzb2x1dGVTb3VyY2VTcGFuKGtleVNwYW4uc3RhcnQub2Zmc2V0ICsgMSwga2V5U3Bhbi5lbmQub2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUFuaW1hdGlvbkV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIGlzQXNzaWdubWVudEV2ZW50LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlUmVndWxhckV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIGlzQXNzaWdubWVudEV2ZW50LCBzb3VyY2VTcGFuLCBoYW5kbGVyU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIHRhcmdldEV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY1Bvc3NpYmxlU2VjdXJpdHlDb250ZXh0cyhzZWxlY3RvciwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSB0aGlzLl9zY2hlbWFSZWdpc3RyeS5nZXRNYXBwZWRQcm9wTmFtZShwcm9wTmFtZSk7XG4gICAgICAgIHJldHVybiBjYWxjUG9zc2libGVTZWN1cml0eUNvbnRleHRzKHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LCBzZWxlY3RvciwgcHJvcCwgaXNBdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBfcGFyc2VBbmltYXRpb25FdmVudChuYW1lLCBleHByZXNzaW9uLCBpc0Fzc2lnbm1lbnRFdmVudCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIHRhcmdldEV2ZW50cywga2V5U3Bhbikge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc3BsaXRBdFBlcmlvZChuYW1lLCBbbmFtZSwgJyddKTtcbiAgICAgICAgY29uc3QgZXZlbnROYW1lID0gbWF0Y2hlc1swXTtcbiAgICAgICAgY29uc3QgcGhhc2UgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGFzdCA9IHRoaXMuX3BhcnNlQWN0aW9uKGV4cHJlc3Npb24sIGlzQXNzaWdubWVudEV2ZW50LCBoYW5kbGVyU3Bhbik7XG4gICAgICAgIHRhcmdldEV2ZW50cy5wdXNoKG5ldyBQYXJzZWRFdmVudChldmVudE5hbWUsIHBoYXNlLCAxIC8qIFBhcnNlZEV2ZW50VHlwZS5BbmltYXRpb24gKi8sIGFzdCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIGtleVNwYW4pKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBBbmltYXRpb24gZXZlbnQgbmFtZSBpcyBtaXNzaW5nIGluIGJpbmRpbmdgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhhc2UpIHtcbiAgICAgICAgICAgIGlmIChwaGFzZSAhPT0gJ3N0YXJ0JyAmJiBwaGFzZSAhPT0gJ2RvbmUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoYFRoZSBwcm92aWRlZCBhbmltYXRpb24gb3V0cHV0IHBoYXNlIHZhbHVlIFwiJHtwaGFzZX1cIiBmb3IgXCJAJHtldmVudE5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZCAodXNlIHN0YXJ0IG9yIGRvbmUpYCwgc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgVGhlIGFuaW1hdGlvbiB0cmlnZ2VyIG91dHB1dCBldmVudCAoQCR7ZXZlbnROYW1lfSkgaXMgbWlzc2luZyBpdHMgcGhhc2UgdmFsdWUgbmFtZSAoc3RhcnQgb3IgZG9uZSBhcmUgY3VycmVudGx5IHN1cHBvcnRlZClgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcGFyc2VSZWd1bGFyRXZlbnQobmFtZSwgZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIHNvdXJjZVNwYW4sIGhhbmRsZXJTcGFuLCB0YXJnZXRNYXRjaGFibGVBdHRycywgdGFyZ2V0RXZlbnRzLCBrZXlTcGFuKSB7XG4gICAgICAgIC8vIGxvbmcgZm9ybWF0OiAndGFyZ2V0OiBldmVudE5hbWUnXG4gICAgICAgIGNvbnN0IFt0YXJnZXQsIGV2ZW50TmFtZV0gPSBzcGxpdEF0Q29sb24obmFtZSwgW251bGwsIG5hbWVdKTtcbiAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fcGFyc2VBY3Rpb24oZXhwcmVzc2lvbiwgaXNBc3NpZ25tZW50RXZlbnQsIGhhbmRsZXJTcGFuKTtcbiAgICAgICAgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMucHVzaChbbmFtZSwgYXN0LnNvdXJjZV0pO1xuICAgICAgICB0YXJnZXRFdmVudHMucHVzaChuZXcgUGFyc2VkRXZlbnQoZXZlbnROYW1lLCB0YXJnZXQsIDAgLyogUGFyc2VkRXZlbnRUeXBlLlJlZ3VsYXIgKi8sIGFzdCwgc291cmNlU3BhbiwgaGFuZGxlclNwYW4sIGtleVNwYW4pKTtcbiAgICAgICAgLy8gRG9uJ3QgZGV0ZWN0IGRpcmVjdGl2ZXMgZm9yIGV2ZW50IG5hbWVzIGZvciBub3csXG4gICAgICAgIC8vIHNvIGRvbid0IGFkZCB0aGUgZXZlbnQgbmFtZSB0byB0aGUgbWF0Y2hhYmxlQXR0cnNcbiAgICB9XG4gICAgX3BhcnNlQWN0aW9uKHZhbHVlLCBpc0Fzc2lnbm1lbnRFdmVudCwgc291cmNlU3Bhbikge1xuICAgICAgICBjb25zdCBzb3VyY2VJbmZvID0gKHNvdXJjZVNwYW4gJiYgc291cmNlU3Bhbi5zdGFydCB8fCAnKHVua25vd24nKS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZU9mZnNldCA9IChzb3VyY2VTcGFuICYmIHNvdXJjZVNwYW4uc3RhcnQpID8gc291cmNlU3Bhbi5zdGFydC5vZmZzZXQgOiAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5fZXhwclBhcnNlci5wYXJzZUFjdGlvbih2YWx1ZSwgaXNBc3NpZ25tZW50RXZlbnQsIHNvdXJjZUluZm8sIGFic29sdXRlT2Zmc2V0LCB0aGlzLl9pbnRlcnBvbGF0aW9uQ29uZmlnKTtcbiAgICAgICAgICAgIGlmIChhc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGFzdC5lcnJvcnMsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhc3QgfHwgYXN0LmFzdCBpbnN0YW5jZW9mIEVtcHR5RXhwcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGBFbXB0eSBleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWRgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwclBhcnNlci53cmFwTGl0ZXJhbFByaW1pdGl2ZSgnRVJST1InLCBzb3VyY2VJbmZvLCBhYnNvbHV0ZU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihgJHtlfWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4cHJQYXJzZXIud3JhcExpdGVyYWxQcmltaXRpdmUoJ0VSUk9SJywgc291cmNlSW5mbywgYWJzb2x1dGVPZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZXBvcnRFcnJvcihtZXNzYWdlLCBzb3VyY2VTcGFuLCBsZXZlbCA9IFBhcnNlRXJyb3JMZXZlbC5FUlJPUikge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzZUVycm9yKHNvdXJjZVNwYW4sIG1lc3NhZ2UsIGxldmVsKSk7XG4gICAgfVxuICAgIF9yZXBvcnRFeHByZXNzaW9uUGFyc2VyRXJyb3JzKGVycm9ycywgc291cmNlU3Bhbikge1xuICAgICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoZXJyb3IubWVzc2FnZSwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHByb3BOYW1lIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSAvIGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuXG4gICAgICogQHBhcmFtIGlzQXR0ciB0cnVlIHdoZW4gYmluZGluZyB0byBhbiBhdHRyaWJ1dGVcbiAgICAgKi9cbiAgICBfdmFsaWRhdGVQcm9wZXJ0eU9yQXR0cmlidXRlTmFtZShwcm9wTmFtZSwgc291cmNlU3BhbiwgaXNBdHRyKSB7XG4gICAgICAgIGNvbnN0IHJlcG9ydCA9IGlzQXR0ciA/IHRoaXMuX3NjaGVtYVJlZ2lzdHJ5LnZhbGlkYXRlQXR0cmlidXRlKHByb3BOYW1lKSA6XG4gICAgICAgICAgICB0aGlzLl9zY2hlbWFSZWdpc3RyeS52YWxpZGF0ZVByb3BlcnR5KHByb3BOYW1lKTtcbiAgICAgICAgaWYgKHJlcG9ydC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IocmVwb3J0Lm1zZywgc291cmNlU3BhbiwgUGFyc2VFcnJvckxldmVsLkVSUk9SKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFBpcGVDb2xsZWN0b3IgZXh0ZW5kcyBSZWN1cnNpdmVBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5waXBlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnBpcGVzLnNldChhc3QubmFtZSwgYXN0KTtcbiAgICAgICAgYXN0LmV4cC52aXNpdCh0aGlzKTtcbiAgICAgICAgdGhpcy52aXNpdEFsbChhc3QuYXJncywgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQW5pbWF0aW9uTGFiZWwobmFtZSkge1xuICAgIHJldHVybiBuYW1lWzBdID09ICdAJztcbn1cbmZ1bmN0aW9uIGNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMocmVnaXN0cnksIHNlbGVjdG9yLCBwcm9wTmFtZSwgaXNBdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBjdHhzID0gW107XG4gICAgQ3NzU2VsZWN0b3IucGFyc2Uoc2VsZWN0b3IpLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnROYW1lcyA9IHNlbGVjdG9yLmVsZW1lbnQgPyBbc2VsZWN0b3IuZWxlbWVudF0gOiByZWdpc3RyeS5hbGxLbm93bkVsZW1lbnROYW1lcygpO1xuICAgICAgICBjb25zdCBub3RFbGVtZW50TmFtZXMgPSBuZXcgU2V0KHNlbGVjdG9yLm5vdFNlbGVjdG9ycy5maWx0ZXIoc2VsZWN0b3IgPT4gc2VsZWN0b3IuaXNFbGVtZW50U2VsZWN0b3IoKSlcbiAgICAgICAgICAgIC5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5lbGVtZW50KSk7XG4gICAgICAgIGNvbnN0IHBvc3NpYmxlRWxlbWVudE5hbWVzID0gZWxlbWVudE5hbWVzLmZpbHRlcihlbGVtZW50TmFtZSA9PiAhbm90RWxlbWVudE5hbWVzLmhhcyhlbGVtZW50TmFtZSkpO1xuICAgICAgICBjdHhzLnB1c2goLi4ucG9zc2libGVFbGVtZW50TmFtZXMubWFwKGVsZW1lbnROYW1lID0+IHJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dChlbGVtZW50TmFtZSwgcHJvcE5hbWUsIGlzQXR0cmlidXRlKSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBjdHhzLmxlbmd0aCA9PT0gMCA/IFtTZWN1cml0eUNvbnRleHQuTk9ORV0gOiBBcnJheS5mcm9tKG5ldyBTZXQoY3R4cykpLnNvcnQoKTtcbn1cbi8qKlxuICogQ29tcHV0ZSBhIG5ldyBQYXJzZVNvdXJjZVNwYW4gYmFzZWQgb2ZmIGFuIG9yaWdpbmFsIGBzb3VyY2VTcGFuYCBieSB1c2luZ1xuICogYWJzb2x1dGUgb2Zmc2V0cyBmcm9tIHRoZSBzcGVjaWZpZWQgYGFic29sdXRlU3BhbmAuXG4gKlxuICogQHBhcmFtIHNvdXJjZVNwYW4gb3JpZ2luYWwgc291cmNlIHNwYW5cbiAqIEBwYXJhbSBhYnNvbHV0ZVNwYW4gYWJzb2x1dGUgc291cmNlIHNwYW4gdG8gbW92ZSB0b1xuICovXG5mdW5jdGlvbiBtb3ZlUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4sIGFic29sdXRlU3Bhbikge1xuICAgIC8vIFRoZSBkaWZmZXJlbmNlIG9mIHR3byBhYnNvbHV0ZSBvZmZzZXRzIHByb3ZpZGUgdGhlIHJlbGF0aXZlIG9mZnNldFxuICAgIGNvbnN0IHN0YXJ0RGlmZiA9IGFic29sdXRlU3Bhbi5zdGFydCAtIHNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgIGNvbnN0IGVuZERpZmYgPSBhYnNvbHV0ZVNwYW4uZW5kIC0gc291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgIHJldHVybiBuZXcgUGFyc2VTb3VyY2VTcGFuKHNvdXJjZVNwYW4uc3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZW5kLm1vdmVCeShlbmREaWZmKSwgc291cmNlU3Bhbi5mdWxsU3RhcnQubW92ZUJ5KHN0YXJ0RGlmZiksIHNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG5cbi8vIFNvbWUgb2YgdGhlIGNvZGUgY29tZXMgZnJvbSBXZWJDb21wb25lbnRzLkpTXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvYmxvYi9tYXN0ZXIvc3JjL0hUTUxJbXBvcnRzL3BhdGguanNcbmZ1bmN0aW9uIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHVybCkge1xuICAgIGlmICh1cmwgPT0gbnVsbCB8fCB1cmwubGVuZ3RoID09PSAwIHx8IHVybFswXSA9PSAnLycpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzY2hlbWVNYXRjaCA9IHVybC5tYXRjaChVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQKTtcbiAgICByZXR1cm4gc2NoZW1lTWF0Y2ggPT09IG51bGwgfHwgc2NoZW1lTWF0Y2hbMV0gPT0gJ3BhY2thZ2UnIHx8IHNjaGVtZU1hdGNoWzFdID09ICdhc3NldCc7XG59XG5jb25zdCBVUkxfV0lUSF9TQ0hFTUFfUkVHRVhQID0gL14oW146Lz8jXSspOi87XG5cbmNvbnN0IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIkMSA9ICdzZWxlY3QnO1xuY29uc3QgTElOS19FTEVNRU5UID0gJ2xpbmsnO1xuY29uc3QgTElOS19TVFlMRV9SRUxfQVRUUiA9ICdyZWwnO1xuY29uc3QgTElOS19TVFlMRV9IUkVGX0FUVFIgPSAnaHJlZic7XG5jb25zdCBMSU5LX1NUWUxFX1JFTF9WQUxVRSA9ICdzdHlsZXNoZWV0JztcbmNvbnN0IFNUWUxFX0VMRU1FTlQgPSAnc3R5bGUnO1xuY29uc3QgU0NSSVBUX0VMRU1FTlQgPSAnc2NyaXB0JztcbmNvbnN0IE5HX05PTl9CSU5EQUJMRV9BVFRSID0gJ25nTm9uQmluZGFibGUnO1xuY29uc3QgTkdfUFJPSkVDVF9BUyA9ICduZ1Byb2plY3RBcyc7XG5mdW5jdGlvbiBwcmVwYXJzZUVsZW1lbnQoYXN0KSB7XG4gICAgbGV0IHNlbGVjdEF0dHIgPSBudWxsO1xuICAgIGxldCBocmVmQXR0ciA9IG51bGw7XG4gICAgbGV0IHJlbEF0dHIgPSBudWxsO1xuICAgIGxldCBub25CaW5kYWJsZSA9IGZhbHNlO1xuICAgIGxldCBwcm9qZWN0QXMgPSAnJztcbiAgICBhc3QuYXR0cnMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgY29uc3QgbGNBdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobGNBdHRyTmFtZSA9PSBOR19DT05URU5UX1NFTEVDVF9BVFRSJDEpIHtcbiAgICAgICAgICAgIHNlbGVjdEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxjQXR0ck5hbWUgPT0gTElOS19TVFlMRV9IUkVGX0FUVFIpIHtcbiAgICAgICAgICAgIGhyZWZBdHRyID0gYXR0ci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsY0F0dHJOYW1lID09IExJTktfU1RZTEVfUkVMX0FUVFIpIHtcbiAgICAgICAgICAgIHJlbEF0dHIgPSBhdHRyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19OT05fQklOREFCTEVfQVRUUikge1xuICAgICAgICAgICAgbm9uQmluZGFibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHIubmFtZSA9PSBOR19QUk9KRUNUX0FTKSB7XG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdEFzID0gYXR0ci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGVjdEF0dHIgPSBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cik7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBhc3QubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuT1RIRVI7XG4gICAgaWYgKGlzTmdDb250ZW50KG5vZGVOYW1lKSkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuTkdfQ09OVEVOVDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZU5hbWUgPT0gU1RZTEVfRUxFTUVOVCkge1xuICAgICAgICB0eXBlID0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IFNDUklQVF9FTEVNRU5UKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGVOYW1lID09IExJTktfRUxFTUVOVCAmJiByZWxBdHRyID09IExJTktfU1RZTEVfUkVMX1ZBTFVFKSB7XG4gICAgICAgIHR5cGUgPSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByZXBhcnNlZEVsZW1lbnQodHlwZSwgc2VsZWN0QXR0ciwgaHJlZkF0dHIsIG5vbkJpbmRhYmxlLCBwcm9qZWN0QXMpO1xufVxudmFyIFByZXBhcnNlZEVsZW1lbnRUeXBlO1xuKGZ1bmN0aW9uIChQcmVwYXJzZWRFbGVtZW50VHlwZSkge1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiTkdfQ09OVEVOVFwiXSA9IDBdID0gXCJOR19DT05URU5UXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTVFlMRVwiXSA9IDFdID0gXCJTVFlMRVwiO1xuICAgIFByZXBhcnNlZEVsZW1lbnRUeXBlW1ByZXBhcnNlZEVsZW1lbnRUeXBlW1wiU1RZTEVTSEVFVFwiXSA9IDJdID0gXCJTVFlMRVNIRUVUXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJTQ1JJUFRcIl0gPSAzXSA9IFwiU0NSSVBUXCI7XG4gICAgUHJlcGFyc2VkRWxlbWVudFR5cGVbUHJlcGFyc2VkRWxlbWVudFR5cGVbXCJPVEhFUlwiXSA9IDRdID0gXCJPVEhFUlwiO1xufSkoUHJlcGFyc2VkRWxlbWVudFR5cGUgfHwgKFByZXBhcnNlZEVsZW1lbnRUeXBlID0ge30pKTtcbmNsYXNzIFByZXBhcnNlZEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNlbGVjdEF0dHIsIGhyZWZBdHRyLCBub25CaW5kYWJsZSwgcHJvamVjdEFzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2VsZWN0QXR0ciA9IHNlbGVjdEF0dHI7XG4gICAgICAgIHRoaXMuaHJlZkF0dHIgPSBocmVmQXR0cjtcbiAgICAgICAgdGhpcy5ub25CaW5kYWJsZSA9IG5vbkJpbmRhYmxlO1xuICAgICAgICB0aGlzLnByb2plY3RBcyA9IHByb2plY3RBcztcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVOZ0NvbnRlbnRTZWxlY3Qoc2VsZWN0QXR0cikge1xuICAgIGlmIChzZWxlY3RBdHRyID09PSBudWxsIHx8IHNlbGVjdEF0dHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnKic7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RBdHRyO1xufVxuXG5jb25zdCBCSU5EX05BTUVfUkVHRVhQID0gL14oPzooYmluZC0pfChsZXQtKXwocmVmLXwjKXwob24tKXwoYmluZG9uLSl8KEApKSguKikkLztcbi8vIEdyb3VwIDEgPSBcImJpbmQtXCJcbmNvbnN0IEtXX0JJTkRfSURYID0gMTtcbi8vIEdyb3VwIDIgPSBcImxldC1cIlxuY29uc3QgS1dfTEVUX0lEWCA9IDI7XG4vLyBHcm91cCAzID0gXCJyZWYtLyNcIlxuY29uc3QgS1dfUkVGX0lEWCA9IDM7XG4vLyBHcm91cCA0ID0gXCJvbi1cIlxuY29uc3QgS1dfT05fSURYID0gNDtcbi8vIEdyb3VwIDUgPSBcImJpbmRvbi1cIlxuY29uc3QgS1dfQklORE9OX0lEWCA9IDU7XG4vLyBHcm91cCA2ID0gXCJAXCJcbmNvbnN0IEtXX0FUX0lEWCA9IDY7XG4vLyBHcm91cCA3ID0gdGhlIGlkZW50aWZpZXIgYWZ0ZXIgXCJiaW5kLVwiLCBcImxldC1cIiwgXCJyZWYtLyNcIiwgXCJvbi1cIiwgXCJiaW5kb24tXCIgb3IgXCJAXCJcbmNvbnN0IElERU5UX0tXX0lEWCA9IDc7XG5jb25zdCBCSU5ESU5HX0RFTElNUyA9IHtcbiAgICBCQU5BTkFfQk9YOiB7IHN0YXJ0OiAnWygnLCBlbmQ6ICcpXScgfSxcbiAgICBQUk9QRVJUWTogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgIEVWRU5UOiB7IHN0YXJ0OiAnKCcsIGVuZDogJyknIH0sXG59O1xuY29uc3QgVEVNUExBVEVfQVRUUl9QUkVGSVggPSAnKic7XG5mdW5jdGlvbiBodG1sQXN0VG9SZW5kZXIzQXN0KGh0bWxOb2RlcywgYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gbmV3IEh0bWxBc3RUb0l2eUFzdChiaW5kaW5nUGFyc2VyLCBvcHRpb25zKTtcbiAgICBjb25zdCBpdnlOb2RlcyA9IHZpc2l0QWxsKHRyYW5zZm9ybWVyLCBodG1sTm9kZXMpO1xuICAgIC8vIEVycm9ycyBtaWdodCBvcmlnaW5hdGUgaW4gZWl0aGVyIHRoZSBiaW5kaW5nIHBhcnNlciBvciB0aGUgaHRtbCB0byBpdnkgdHJhbnNmb3JtZXJcbiAgICBjb25zdCBhbGxFcnJvcnMgPSBiaW5kaW5nUGFyc2VyLmVycm9ycy5jb25jYXQodHJhbnNmb3JtZXIuZXJyb3JzKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5vZGVzOiBpdnlOb2RlcyxcbiAgICAgICAgZXJyb3JzOiBhbGxFcnJvcnMsXG4gICAgICAgIHN0eWxlVXJsczogdHJhbnNmb3JtZXIuc3R5bGVVcmxzLFxuICAgICAgICBzdHlsZXM6IHRyYW5zZm9ybWVyLnN0eWxlcyxcbiAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiB0cmFuc2Zvcm1lci5uZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgcmVzdWx0LmNvbW1lbnROb2RlcyA9IHRyYW5zZm9ybWVyLmNvbW1lbnROb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxBc3RUb0l2eUFzdCB7XG4gICAgY29uc3RydWN0b3IoYmluZGluZ1BhcnNlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIgPSBiaW5kaW5nUGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICB0aGlzLnN0eWxlVXJscyA9IFtdO1xuICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycyA9IFtdO1xuICAgICAgICAvLyBUaGlzIGFycmF5IHdpbGwgYmUgcG9wdWxhdGVkIGlmIGBSZW5kZXIzUGFyc2VPcHRpb25zWydjb2xsZWN0Q29tbWVudE5vZGVzJ11gIGlzIHRydWVcbiAgICAgICAgdGhpcy5jb21tZW50Tm9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBIVE1MIHZpc2l0b3JcbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBpc0kxOG5Sb290RWxlbWVudCA9IGlzSTE4blJvb3ROb2RlKGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5JMThuQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdDYW5ub3QgbWFyayBhbiBlbGVtZW50IGFzIHRyYW5zbGF0YWJsZSBpbnNpZGUgb2YgYSB0cmFuc2xhdGFibGUgc2VjdGlvbi4gUGxlYXNlIHJlbW92ZSB0aGUgbmVzdGVkIGkxOG4gbWFya2VyLicsIGVsZW1lbnQuc291cmNlU3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TQ1JJUFQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXBhcnNlZEVsZW1lbnQudHlwZSA9PT0gUHJlcGFyc2VkRWxlbWVudFR5cGUuU1RZTEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGV4dENvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChjb250ZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNUWUxFU0hFRVQgJiZcbiAgICAgICAgICAgIGlzU3R5bGVVcmxSZXNvbHZhYmxlKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlVXJscy5wdXNoKHByZXBhcnNlZEVsZW1lbnQuaHJlZkF0dHIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBpcyBhIGA8bmctdGVtcGxhdGU+YFxuICAgICAgICBjb25zdCBpc1RlbXBsYXRlRWxlbWVudCA9IGlzTmdUZW1wbGF0ZShlbGVtZW50Lm5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRQcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGNvbnN0IGJvdW5kRXZlbnRzID0gW107XG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgaTE4bkF0dHJzTWV0YSA9IHt9O1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgZWxlbWVudCBoYXMgYW55ICotYXR0cmlidXRlXG4gICAgICAgIGxldCBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgZWxlbWVudC5hdHRycykge1xuICAgICAgICAgICAgbGV0IGhhc0JpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAvLyBgKmF0dHJgIGRlZmluZXMgdGVtcGxhdGUgYmluZGluZ3NcbiAgICAgICAgICAgIGxldCBpc1RlbXBsYXRlQmluZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pMThuKSB7XG4gICAgICAgICAgICAgICAgaTE4bkF0dHJzTWV0YVthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUuaTE4bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3JtYWxpemVkTmFtZS5zdGFydHNXaXRoKFRFTVBMQVRFX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vICotYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgQ2FuJ3QgaGF2ZSBtdWx0aXBsZSB0ZW1wbGF0ZSBiaW5kaW5ncyBvbiBvbmUgZWxlbWVudC4gVXNlIG9ubHkgb25lIGF0dHJpYnV0ZSBwcmVmaXhlZCB3aXRoICpgLCBhdHRyaWJ1dGUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzVGVtcGxhdGVCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbGVtZW50SGFzSW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBsYXRlVmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVLZXkgPSBub3JtYWxpemVkTmFtZS5zdWJzdHJpbmcoVEVNUExBVEVfQVRUUl9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRWYXJpYWJsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhYnNvbHV0ZVZhbHVlT2Zmc2V0ID0gYXR0cmlidXRlLnZhbHVlU3BhbiA/XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsdWUgc3BhbiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGhhdmUgYSB2YWx1ZSwgbGlrZSBgYXR0cmAgaW5cbiAgICAgICAgICAgICAgICAgICAgLy9gPGRpdiBhdHRyPjwvZGl2PmAuIEluIHRoaXMgY2FzZSwgcG9pbnQgdG8gb25lIGNoYXJhY3RlciBiZXlvbmQgdGhlIGxhc3QgY2hhcmFjdGVyIG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0ICsgYXR0cmlidXRlLm5hbWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUlubGluZVRlbXBsYXRlQmluZGluZyh0ZW1wbGF0ZUtleSwgdGVtcGxhdGVWYWx1ZSwgYXR0cmlidXRlLnNvdXJjZVNwYW4sIGFic29sdXRlVmFsdWVPZmZzZXQsIFtdLCB0ZW1wbGF0ZVBhcnNlZFByb3BlcnRpZXMsIHBhcnNlZFZhcmlhYmxlcywgdHJ1ZSAvKiBpc0l2eUFzdCAqLyk7XG4gICAgICAgICAgICAgICAgdGVtcGxhdGVWYXJpYWJsZXMucHVzaCguLi5wYXJzZWRWYXJpYWJsZXMubWFwKHYgPT4gbmV3IFZhcmlhYmxlKHYubmFtZSwgdi52YWx1ZSwgdi5zb3VyY2VTcGFuLCB2LmtleVNwYW4sIHYudmFsdWVTcGFuKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHZhcmlhYmxlcywgZXZlbnRzLCBwcm9wZXJ0eSBiaW5kaW5ncywgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgIGhhc0JpbmRpbmcgPSB0aGlzLnBhcnNlQXR0cmlidXRlKGlzVGVtcGxhdGVFbGVtZW50LCBhdHRyaWJ1dGUsIFtdLCBwYXJzZWRQcm9wZXJ0aWVzLCBib3VuZEV2ZW50cywgdmFyaWFibGVzLCByZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQmluZGluZyAmJiAhaXNUZW1wbGF0ZUJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIHRoZSBiaW5kaW5ncyBhcyBhdHRyaWJ1dGVzIGFzIHdlbGwgaW4gdGhlIEFTVFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaCh0aGlzLnZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwocHJlcGFyc2VkRWxlbWVudC5ub25CaW5kYWJsZSA/IE5PTl9CSU5EQUJMRV9WSVNJVE9SIDogdGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGxldCBwYXJzZWRFbGVtZW50O1xuICAgICAgICBpZiAocHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5OR19DT05URU5UKSB7XG4gICAgICAgICAgICAvLyBgPG5nLWNvbnRlbnQ+YFxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudC5jaGlsZHJlbi5ldmVyeSgobm9kZSkgPT4gaXNFbXB0eVRleHROb2RlKG5vZGUpIHx8IGlzQ29tbWVudE5vZGUobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgPG5nLWNvbnRlbnQ+IGVsZW1lbnQgY2Fubm90IGhhdmUgY29udGVudC5gLCBlbGVtZW50LnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBwcmVwYXJzZWRFbGVtZW50LnNlbGVjdEF0dHI7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGVsZW1lbnQuYXR0cnMubWFwKGF0dHIgPT4gdGhpcy52aXNpdEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgICAgICBwYXJzZWRFbGVtZW50ID0gbmV3IENvbnRlbnQoc2VsZWN0b3IsIGF0dHJzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgICAgICB0aGlzLm5nQ29udGVudFNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gYDxuZy10ZW1wbGF0ZT5gXG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHRoaXMuZXh0cmFjdEF0dHJpYnV0ZXMoZWxlbWVudC5uYW1lLCBwYXJzZWRQcm9wZXJ0aWVzLCBpMThuQXR0cnNNZXRhKTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIFsgLyogbm8gdGVtcGxhdGUgYXR0cmlidXRlcyAqL10sIGNoaWxkcmVuLCByZWZlcmVuY2VzLCB2YXJpYWJsZXMsIGVsZW1lbnQuc291cmNlU3BhbiwgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuZW5kU291cmNlU3BhbiwgZWxlbWVudC5pMThuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gdGhpcy5leHRyYWN0QXR0cmlidXRlcyhlbGVtZW50Lm5hbWUsIHBhcnNlZFByb3BlcnRpZXMsIGkxOG5BdHRyc01ldGEpO1xuICAgICAgICAgICAgcGFyc2VkRWxlbWVudCA9IG5ldyBFbGVtZW50JDEoZWxlbWVudC5uYW1lLCBhdHRyaWJ1dGVzLCBhdHRycy5ib3VuZCwgYm91bmRFdmVudHMsIGNoaWxkcmVuLCByZWZlcmVuY2VzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRIYXNJbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIGFuIGlubGluZS10ZW1wbGF0ZSAoZS5nLiBoYXMgKm5nRm9yKSB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIG5vZGUgdGhhdCBjb250YWlucyB0aGlzIG5vZGUuXG4gICAgICAgICAgICAvLyBNb3Jlb3ZlciwgaWYgdGhlIG5vZGUgaXMgYW4gZWxlbWVudCwgdGhlbiB3ZSBuZWVkIHRvIGhvaXN0IGl0cyBhdHRyaWJ1dGVzIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgLy8gbm9kZSBmb3IgbWF0Y2hpbmcgYWdhaW5zdCBjb250ZW50IHByb2plY3Rpb24gc2VsZWN0b3JzLlxuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB0aGlzLmV4dHJhY3RBdHRyaWJ1dGVzKCduZy10ZW1wbGF0ZScsIHRlbXBsYXRlUGFyc2VkUHJvcGVydGllcywgaTE4bkF0dHJzTWV0YSk7XG4gICAgICAgICAgICBjb25zdCB0ZW1wbGF0ZUF0dHJzID0gW107XG4gICAgICAgICAgICBhdHRycy5saXRlcmFsLmZvckVhY2goYXR0ciA9PiB0ZW1wbGF0ZUF0dHJzLnB1c2goYXR0cikpO1xuICAgICAgICAgICAgYXR0cnMuYm91bmQuZm9yRWFjaChhdHRyID0+IHRlbXBsYXRlQXR0cnMucHVzaChhdHRyKSk7XG4gICAgICAgICAgICBjb25zdCBob2lzdGVkQXR0cnMgPSBwYXJzZWRFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCQxID9cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHBhcnNlZEVsZW1lbnQuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBwYXJzZWRFbGVtZW50LmlucHV0cyxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogcGFyc2VkRWxlbWVudC5vdXRwdXRzLFxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHsgYXR0cmlidXRlczogW10sIGlucHV0czogW10sIG91dHB1dHM6IFtdIH07XG4gICAgICAgICAgICAvLyBGb3IgPG5nLXRlbXBsYXRlPnMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgb24gdGhlbSwgYXZvaWQgcGFzc2luZyBpMThuIGluZm9ybWF0aW9uIHRvXG4gICAgICAgICAgICAvLyB0aGUgd3JhcHBpbmcgdGVtcGxhdGUgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBpMThuIGluc3RydWN0aW9ucyBmcm9tIGJlaW5nIGdlbmVyYXRlZC4gVGhlXG4gICAgICAgICAgICAvLyBuZWNlc3NhcnkgaTE4biBtZXRhIGluZm9ybWF0aW9uIHdpbGwgYmUgZXh0cmFjdGVkIGZyb20gY2hpbGQgZWxlbWVudHMuXG4gICAgICAgICAgICBjb25zdCBpMThuID0gaXNUZW1wbGF0ZUVsZW1lbnQgJiYgaXNJMThuUm9vdEVsZW1lbnQgPyB1bmRlZmluZWQgOiBlbGVtZW50LmkxOG47XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGFyc2VkRWxlbWVudCBpbnN0YW5jZW9mIFRlbXBsYXRlID8gbnVsbCA6IHBhcnNlZEVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIHBhcnNlZEVsZW1lbnQgPSBuZXcgVGVtcGxhdGUobmFtZSwgaG9pc3RlZEF0dHJzLmF0dHJpYnV0ZXMsIGhvaXN0ZWRBdHRycy5pbnB1dHMsIGhvaXN0ZWRBdHRycy5vdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzLCBbcGFyc2VkRWxlbWVudF0sIFsgLyogbm8gcmVmZXJlbmNlcyAqL10sIHRlbXBsYXRlVmFyaWFibGVzLCBlbGVtZW50LnNvdXJjZVNwYW4sIGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBlbGVtZW50LmVuZFNvdXJjZVNwYW4sIGkxOG4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0kxOG5Sb290RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRFbGVtZW50O1xuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUsIGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBhdHRyaWJ1dGUua2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgYXR0cmlidXRlLmkxOG4pO1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuLCB0ZXh0LnRva2VucywgdGV4dC5pMThuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uKSB7XG4gICAgICAgIGlmICghZXhwYW5zaW9uLmkxOG4pIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBnZW5lcmF0ZSBJY3UgaW4gY2FzZSBpdCB3YXMgY3JlYXRlZFxuICAgICAgICAgICAgLy8gb3V0c2lkZSBvZiBpMThuIGJsb2NrIGluIGEgdGVtcGxhdGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNJMThuUm9vdE5vZGUoZXhwYW5zaW9uLmkxOG4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZSBcIiR7ZXhwYW5zaW9uLmkxOG4uY29uc3RydWN0b3J9XCIgZm9yIFwiaTE4blwiIHByb3BlcnR5IG9mICR7ZXhwYW5zaW9uLnNvdXJjZVNwYW4udG9TdHJpbmcoKX0uIEV4cGVjdGVkIGEgXCJNZXNzYWdlXCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXhwYW5zaW9uLmkxOG47XG4gICAgICAgIGNvbnN0IHZhcnMgPSB7fTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0ge307XG4gICAgICAgIC8vIGV4dHJhY3QgVkFScyBmcm9tIElDVXMgLSB3ZSBwcm9jZXNzIHRoZW0gc2VwYXJhdGVseSB3aGlsZVxuICAgICAgICAvLyBhc3NlbWJsaW5nIHJlc3VsdGluZyBtZXNzYWdlIHZpYSBnb29nLmdldE1zZyBmdW5jdGlvbiwgc2luY2VcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwYXNzIHRoZW0gdG8gdG9wLWxldmVsIGdvb2cuZ2V0TXNnIGNhbGxcbiAgICAgICAgT2JqZWN0LmtleXMobWVzc2FnZS5wbGFjZWhvbGRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZS5wbGFjZWhvbGRlcnNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChJMThOX0lDVV9WQVJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnRseSB3aGVuIHRoZSBgcGx1cmFsYCBvciBgc2VsZWN0YCBrZXl3b3JkcyBpbiBhbiBJQ1UgY29udGFpbiB0cmFpbGluZyBzcGFjZXMgKGUuZy5cbiAgICAgICAgICAgICAgICAvLyBge2NvdW50LCBzZWxlY3QgLCAuLi59YCksIHRoZXNlIHNwYWNlcyBhcmUgYWxzbyBpbmNsdWRlZCBpbnRvIHRoZSBrZXkgbmFtZXMgaW4gSUNVIHZhcnNcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBcIlZBUl9TRUxFQ1QgXCIpLiBUaGVzZSB0cmFpbGluZyBzcGFjZXMgYXJlIG5vdCBkZXNpcmFibGUsIHNpbmNlIHRoZXkgd2lsbCBsYXRlciBiZVxuICAgICAgICAgICAgICAgIC8vIGNvbnZlcnRlZCBpbnRvIGBfYCBzeW1ib2xzIHdoaWxlIG5vcm1hbGl6aW5nIHBsYWNlaG9sZGVyIG5hbWVzLCB3aGljaCBtaWdodCBsZWFkIHRvXG4gICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2hlcyBhdCBydW50aW1lIChpLmUuIHBsYWNlaG9sZGVyIHdpbGwgbm90IGJlIHJlcGxhY2VkIHdpdGggdGhlIGNvcnJlY3QgdmFsdWUpLlxuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZEtleSA9IGtleS50cmltKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXN0ID0gdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24odmFsdWUudGV4dCwgdmFsdWUuc291cmNlU3Bhbik7XG4gICAgICAgICAgICAgICAgdmFyc1tmb3JtYXR0ZWRLZXldID0gbmV3IEJvdW5kVGV4dChhc3QsIHZhbHVlLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJzW2tleV0gPSB0aGlzLl92aXNpdFRleHRXaXRoSW50ZXJwb2xhdGlvbih2YWx1ZS50ZXh0LCB2YWx1ZS5zb3VyY2VTcGFuLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1JDEodmFycywgcGxhY2Vob2xkZXJzLCBleHBhbnNpb24uc291cmNlU3BhbiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWVudE5vZGVzLnB1c2gobmV3IENvbW1lbnQkMShjb21tZW50LnZhbHVlIHx8ICcnLCBjb21tZW50LnNvdXJjZVNwYW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gY29udmVydCB2aWV3IGVuZ2luZSBgUGFyc2VkUHJvcGVydHlgIHRvIGEgZm9ybWF0IHN1aXRhYmxlIGZvciBJVllcbiAgICBleHRyYWN0QXR0cmlidXRlcyhlbGVtZW50TmFtZSwgcHJvcGVydGllcywgaTE4blByb3BzTWV0YSkge1xuICAgICAgICBjb25zdCBib3VuZCA9IFtdO1xuICAgICAgICBjb25zdCBsaXRlcmFsID0gW107XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGkxOG4gPSBpMThuUHJvcHNNZXRhW3Byb3AubmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcC5pc0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsLnB1c2gobmV3IFRleHRBdHRyaWJ1dGUocHJvcC5uYW1lLCBwcm9wLmV4cHJlc3Npb24uc291cmNlIHx8ICcnLCBwcm9wLnNvdXJjZVNwYW4sIHByb3Aua2V5U3BhbiwgcHJvcC52YWx1ZVNwYW4sIGkxOG4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB2YWxpZGF0aW9uIGlzIHNraXBwZWQgYW5kIHByb3BlcnR5IG1hcHBpbmcgaXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAvLyBkdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBhIGdpdmVuIHByb3AgaXMgbm90IGFuXG4gICAgICAgICAgICAgICAgLy8gaW5wdXQgb2YgYSBkaXJlY3RpdmUgYW5kIGRpcmVjdGl2ZSBtYXRjaGluZyBoYXBwZW5zIGF0IHJ1bnRpbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgYmVwID0gdGhpcy5iaW5kaW5nUGFyc2VyLmNyZWF0ZUJvdW5kRWxlbWVudFByb3BlcnR5KGVsZW1lbnROYW1lLCBwcm9wLCAvKiBza2lwVmFsaWRhdGlvbiAqLyB0cnVlLCAvKiBtYXBQcm9wZXJ0eU5hbWUgKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJvdW5kLnB1c2goQm91bmRBdHRyaWJ1dGUuZnJvbUJvdW5kRWxlbWVudFByb3BlcnR5KGJlcCwgaTE4bikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgYm91bmQsIGxpdGVyYWwgfTtcbiAgICB9XG4gICAgcGFyc2VBdHRyaWJ1dGUoaXNUZW1wbGF0ZUVsZW1lbnQsIGF0dHJpYnV0ZSwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywgYm91bmRFdmVudHMsIHZhcmlhYmxlcywgcmVmZXJlbmNlcykge1xuICAgICAgICBjb25zdCBuYW1lID0gbm9ybWFsaXplQXR0cmlidXRlTmFtZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuICAgICAgICBjb25zdCBzcmNTcGFuID0gYXR0cmlidXRlLnNvdXJjZVNwYW47XG4gICAgICAgIGNvbnN0IGFic29sdXRlT2Zmc2V0ID0gYXR0cmlidXRlLnZhbHVlU3BhbiA/IGF0dHJpYnV0ZS52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0IDogc3JjU3Bhbi5zdGFydC5vZmZzZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgcHJlZml4LCBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGFkanVzdCB0aGUgc3RhcnQgbG9jYXRpb24gZm9yIHRoZSBrZXlTcGFuIHRvIGFjY291bnQgZm9yIHRoZSByZW1vdmVkICdkYXRhLSdcbiAgICAgICAgICAgIC8vIHByZWZpeCBmcm9tIGBub3JtYWxpemVBdHRyaWJ1dGVOYW1lYC5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25BZGp1c3RtZW50ID0gYXR0cmlidXRlLm5hbWUubGVuZ3RoIC0gbmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBrZXlTcGFuU3RhcnQgPSBzcmNTcGFuLnN0YXJ0Lm1vdmVCeShwcmVmaXgubGVuZ3RoICsgbm9ybWFsaXphdGlvbkFkanVzdG1lbnQpO1xuICAgICAgICAgICAgY29uc3Qga2V5U3BhbkVuZCA9IGtleVNwYW5TdGFydC5tb3ZlQnkoaWRlbnRpZmllci5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVNvdXJjZVNwYW4oa2V5U3BhblN0YXJ0LCBrZXlTcGFuRW5kLCBrZXlTcGFuU3RhcnQsIGlkZW50aWZpZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpbmRQYXJ0cyA9IG5hbWUubWF0Y2goQklORF9OQU1FX1JFR0VYUCk7XG4gICAgICAgIGlmIChiaW5kUGFydHMpIHtcbiAgICAgICAgICAgIGlmIChiaW5kUGFydHNbS1dfQklORF9JRFhdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gYmluZFBhcnRzW0lERU5UX0tXX0lEWF07XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgYmluZFBhcnRzW0tXX0JJTkRfSURYXSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGlkZW50aWZpZXIsIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0xFVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgYmluZFBhcnRzW0tXX0xFVF9JRFhdLCBpZGVudGlmaWVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBrZXlTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgXCJsZXQtXCIgaXMgb25seSBzdXBwb3J0ZWQgb24gbmctdGVtcGxhdGUgZWxlbWVudHMuYCwgc3JjU3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX1JFRl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sIGJpbmRQYXJ0c1tLV19SRUZfSURYXSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZVJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc3JjU3Bhbiwga2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgcmVmZXJlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kUGFydHNbS1dfT05fSURYXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBiaW5kUGFydHNbSURFTlRfS1dfSURYXTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBiaW5kUGFydHNbS1dfT05fSURYXSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoaWRlbnRpZmllciwgdmFsdWUsIC8qIGlzQXNzaWdubWVudEV2ZW50ICovIGZhbHNlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IHNyY1NwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKGV2ZW50cywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZFBhcnRzW0tXX0JJTkRPTl9JRFhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGJpbmRQYXJ0c1tJREVOVF9LV19JRFhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNwYW4gPSBjcmVhdGVLZXlTcGFuKHNyY1NwYW4sIGJpbmRQYXJ0c1tLV19CSU5ET05fSURYXSwgaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGlkZW50aWZpZXIsIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMsIGtleVNwYW4pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBc3NpZ25tZW50RXZlbnQoaWRlbnRpZmllciwgdmFsdWUsIHNyY1NwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGJvdW5kRXZlbnRzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpbmRQYXJ0c1tLV19BVF9JRFhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgJycsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZUxpdGVyYWxBdHRyKG5hbWUsIHZhbHVlLCBzcmNTcGFuLCBhYnNvbHV0ZU9mZnNldCwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkaWRuJ3Qgc2VlIGEga3ctcHJlZml4ZWQgcHJvcGVydHkgYmluZGluZywgYnV0IHdlIGhhdmUgbm90IHlldCBjaGVja2VkXG4gICAgICAgIC8vIGZvciB0aGUgW10vKCkvWygpXSBzeW50YXguXG4gICAgICAgIGxldCBkZWxpbXMgPSBudWxsO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKEJJTkRJTkdfREVMSU1TLkJBTkFOQV9CT1guc3RhcnQpKSB7XG4gICAgICAgICAgICBkZWxpbXMgPSBCSU5ESU5HX0RFTElNUy5CQU5BTkFfQk9YO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChCSU5ESU5HX0RFTElNUy5QUk9QRVJUWS5zdGFydCkpIHtcbiAgICAgICAgICAgIGRlbGltcyA9IEJJTkRJTkdfREVMSU1TLlBST1BFUlRZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChCSU5ESU5HX0RFTElNUy5FVkVOVC5zdGFydCkpIHtcbiAgICAgICAgICAgIGRlbGltcyA9IEJJTkRJTkdfREVMSU1TLkVWRU5UO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxpbXMgIT09IG51bGwgJiZcbiAgICAgICAgICAgIC8vIE5PVEU6IG9sZGVyIHZlcnNpb25zIG9mIHRoZSBwYXJzZXIgd291bGQgbWF0Y2ggYSBzdGFydC9lbmQgZGVsaW1pdGVkXG4gICAgICAgICAgICAvLyBiaW5kaW5nIGlmZiB0aGUgcHJvcGVydHkgbmFtZSB3YXMgdGVybWluYXRlZCBieSB0aGUgZW5kaW5nIGRlbGltaXRlclxuICAgICAgICAgICAgLy8gYW5kIHRoZSBpZGVudGlmaWVyIGluIHRoZSBiaW5kaW5nIHdhcyBub24tZW1wdHkuXG4gICAgICAgICAgICAvLyBUT0RPKGF5YXpoYWZpeik6IHVwZGF0ZSB0aGlzIHRvIGhhbmRsZSBtYWxmb3JtZWQgYmluZGluZ3MuXG4gICAgICAgICAgICBuYW1lLmVuZHNXaXRoKGRlbGltcy5lbmQpICYmIG5hbWUubGVuZ3RoID4gZGVsaW1zLnN0YXJ0Lmxlbmd0aCArIGRlbGltcy5lbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbmFtZS5zdWJzdHJpbmcoZGVsaW1zLnN0YXJ0Lmxlbmd0aCwgbmFtZS5sZW5ndGggLSBkZWxpbXMuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBrZXlTcGFuID0gY3JlYXRlS2V5U3BhbihzcmNTcGFuLCBkZWxpbXMuc3RhcnQsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKGRlbGltcy5zdGFydCA9PT0gQklORElOR19ERUxJTVMuQkFOQU5BX0JPWC5zdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5QmluZGluZyhpZGVudGlmaWVyLCB2YWx1ZSwgZmFsc2UsIHNyY1NwYW4sIGFic29sdXRlT2Zmc2V0LCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBwYXJzZWRQcm9wZXJ0aWVzLCBrZXlTcGFuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQXNzaWdubWVudEV2ZW50KGlkZW50aWZpZXIsIHZhbHVlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuLCBtYXRjaGFibGVBdHRyaWJ1dGVzLCBib3VuZEV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkZWxpbXMuc3RhcnQgPT09IEJJTkRJTkdfREVMSU1TLlBST1BFUlRZLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlUHJvcGVydHlCaW5kaW5nKGlkZW50aWZpZXIsIHZhbHVlLCBmYWxzZSwgc3JjU3BhbiwgYWJzb2x1dGVPZmZzZXQsIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIHBhcnNlZFByb3BlcnRpZXMsIGtleVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5nUGFyc2VyLnBhcnNlRXZlbnQoaWRlbnRpZmllciwgdmFsdWUsIC8qIGlzQXNzaWdubWVudEV2ZW50ICovIGZhbHNlLCBzcmNTcGFuLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IHNyY1NwYW4sIG1hdGNoYWJsZUF0dHJpYnV0ZXMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgICAgICAgICAgYWRkRXZlbnRzKGV2ZW50cywgYm91bmRFdmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gZXhwbGljaXQgYmluZGluZyBmb3VuZC5cbiAgICAgICAgY29uc3Qga2V5U3BhbiA9IGNyZWF0ZUtleVNwYW4oc3JjU3BhbiwgJycgLyogcHJlZml4ICovLCBuYW1lKTtcbiAgICAgICAgY29uc3QgaGFzQmluZGluZyA9IHRoaXMuYmluZGluZ1BhcnNlci5wYXJzZVByb3BlcnR5SW50ZXJwb2xhdGlvbihuYW1lLCB2YWx1ZSwgc3JjU3BhbiwgYXR0cmlidXRlLnZhbHVlU3BhbiwgbWF0Y2hhYmxlQXR0cmlidXRlcywgcGFyc2VkUHJvcGVydGllcywga2V5U3BhbiwgYXR0cmlidXRlLnZhbHVlVG9rZW5zID8/IG51bGwpO1xuICAgICAgICByZXR1cm4gaGFzQmluZGluZztcbiAgICB9XG4gICAgX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHZhbHVlLCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMsIGkxOG4pIHtcbiAgICAgICAgY29uc3QgdmFsdWVOb05nc3AgPSByZXBsYWNlTmdzcCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VJbnRlcnBvbGF0aW9uKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuLCBpbnRlcnBvbGF0ZWRUb2tlbnMpO1xuICAgICAgICByZXR1cm4gZXhwciA/IG5ldyBCb3VuZFRleHQoZXhwciwgc291cmNlU3BhbiwgaTE4bikgOiBuZXcgVGV4dCQzKHZhbHVlTm9OZ3NwLCBzb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgcGFyc2VWYXJpYWJsZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuLCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGlkZW50aWZpZXIuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFwiLVwiIGlzIG5vdCBhbGxvd2VkIGluIHZhcmlhYmxlIG5hbWVzYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFZhcmlhYmxlIGRvZXMgbm90IGhhdmUgYSBuYW1lYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyaWFibGVzLnB1c2gobmV3IFZhcmlhYmxlKGlkZW50aWZpZXIsIHZhbHVlLCBzb3VyY2VTcGFuLCBrZXlTcGFuLCB2YWx1ZVNwYW4pKTtcbiAgICB9XG4gICAgcGFyc2VSZWZlcmVuY2UoaWRlbnRpZmllciwgdmFsdWUsIHNvdXJjZVNwYW4sIGtleVNwYW4sIHZhbHVlU3BhbiwgcmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcihgXCItXCIgaXMgbm90IGFsbG93ZWQgaW4gcmVmZXJlbmNlIG5hbWVzYCwgc291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpZmllci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoYFJlZmVyZW5jZSBkb2VzIG5vdCBoYXZlIGEgbmFtZWAsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZmVyZW5jZXMuc29tZShyZWZlcmVuY2UgPT4gcmVmZXJlbmNlLm5hbWUgPT09IGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKGBSZWZlcmVuY2UgXCIjJHtpZGVudGlmaWVyfVwiIGlzIGRlZmluZWQgbW9yZSB0aGFuIG9uY2VgLCBzb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZWZlcmVuY2VzLnB1c2gobmV3IFJlZmVyZW5jZShpZGVudGlmaWVyLCB2YWx1ZSwgc291cmNlU3Bhbiwga2V5U3BhbiwgdmFsdWVTcGFuKSk7XG4gICAgfVxuICAgIHBhcnNlQXNzaWdubWVudEV2ZW50KG5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZVNwYW4sIHZhbHVlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGJvdW5kRXZlbnRzLCBrZXlTcGFuKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmJpbmRpbmdQYXJzZXIucGFyc2VFdmVudChgJHtuYW1lfUNoYW5nZWAsIGAke2V4cHJlc3Npb259ID0kZXZlbnRgLCAvKiBpc0Fzc2lnbm1lbnRFdmVudCAqLyB0cnVlLCBzb3VyY2VTcGFuLCB2YWx1ZVNwYW4gfHwgc291cmNlU3BhbiwgdGFyZ2V0TWF0Y2hhYmxlQXR0cnMsIGV2ZW50cywga2V5U3Bhbik7XG4gICAgICAgIGFkZEV2ZW50cyhldmVudHMsIGJvdW5kRXZlbnRzKTtcbiAgICB9XG4gICAgcmVwb3J0RXJyb3IobWVzc2FnZSwgc291cmNlU3BhbiwgbGV2ZWwgPSBQYXJzZUVycm9yTGV2ZWwuRVJST1IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2VFcnJvcihzb3VyY2VTcGFuLCBtZXNzYWdlLCBsZXZlbCkpO1xuICAgIH1cbn1cbmNsYXNzIE5vbkJpbmRhYmxlVmlzaXRvciB7XG4gICAgdmlzaXRFbGVtZW50KGFzdCkge1xuICAgICAgICBjb25zdCBwcmVwYXJzZWRFbGVtZW50ID0gcHJlcGFyc2VFbGVtZW50KGFzdCk7XG4gICAgICAgIGlmIChwcmVwYXJzZWRFbGVtZW50LnR5cGUgPT09IFByZXBhcnNlZEVsZW1lbnRUeXBlLlNDUklQVCB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRSB8fFxuICAgICAgICAgICAgcHJlcGFyc2VkRWxlbWVudC50eXBlID09PSBQcmVwYXJzZWRFbGVtZW50VHlwZS5TVFlMRVNIRUVUKSB7XG4gICAgICAgICAgICAvLyBTa2lwcGluZyA8c2NyaXB0PiBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICAgICAgLy8gU2tpcHBpbmcgPHN0eWxlPiBhbmQgc3R5bGVzaGVldHMgYXMgd2UgYWxyZWFkeSBwcm9jZXNzZWQgdGhlbVxuICAgICAgICAgICAgLy8gaW4gdGhlIFN0eWxlQ29tcGlsZXJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlzaXRBbGwodGhpcywgYXN0LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50JDEoYXN0Lm5hbWUsIHZpc2l0QWxsKHRoaXMsIGFzdC5hdHRycyksIFxuICAgICAgICAvKiBpbnB1dHMgKi8gW10sIC8qIG91dHB1dHMgKi8gW10sIGNoaWxkcmVuLCAvKiByZWZlcmVuY2VzICovIFtdLCBhc3Quc291cmNlU3BhbiwgYXN0LnN0YXJ0U291cmNlU3BhbiwgYXN0LmVuZFNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSwgYXR0cmlidXRlLnZhbHVlLCBhdHRyaWJ1dGUuc291cmNlU3BhbiwgYXR0cmlidXRlLmtleVNwYW4sIGF0dHJpYnV0ZS52YWx1ZVNwYW4sIGF0dHJpYnV0ZS5pMThuKTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDModGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jb25zdCBOT05fQklOREFCTEVfVklTSVRPUiA9IG5ldyBOb25CaW5kYWJsZVZpc2l0b3IoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0ck5hbWUpIHtcbiAgICByZXR1cm4gL15kYXRhLS9pLnRlc3QoYXR0ck5hbWUpID8gYXR0ck5hbWUuc3Vic3RyaW5nKDUpIDogYXR0ck5hbWU7XG59XG5mdW5jdGlvbiBhZGRFdmVudHMoZXZlbnRzLCBib3VuZEV2ZW50cykge1xuICAgIGJvdW5kRXZlbnRzLnB1c2goLi4uZXZlbnRzLm1hcChlID0+IEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50KGUpKSk7XG59XG5mdW5jdGlvbiBpc0VtcHR5VGV4dE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dCAmJiBub2RlLnZhbHVlLnRyaW0oKS5sZW5ndGggPT0gMDtcbn1cbmZ1bmN0aW9uIGlzQ29tbWVudE5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQ29tbWVudDtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50cyhub2RlKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICEobm9kZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIFRleHQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW5bMF0udmFsdWU7XG4gICAgfVxufVxuXG52YXIgVGFnVHlwZTtcbihmdW5jdGlvbiAoVGFnVHlwZSkge1xuICAgIFRhZ1R5cGVbVGFnVHlwZVtcIkVMRU1FTlRcIl0gPSAwXSA9IFwiRUxFTUVOVFwiO1xuICAgIFRhZ1R5cGVbVGFnVHlwZVtcIlRFTVBMQVRFXCJdID0gMV0gPSBcIlRFTVBMQVRFXCI7XG59KShUYWdUeXBlIHx8IChUYWdUeXBlID0ge30pKTtcbi8qKlxuICogR2VuZXJhdGVzIGFuIG9iamVjdCB0aGF0IGlzIHVzZWQgYXMgYSBzaGFyZWQgc3RhdGUgYmV0d2VlbiBwYXJlbnQgYW5kIGFsbCBjaGlsZCBjb250ZXh0cy5cbiAqL1xuZnVuY3Rpb24gc2V0dXBSZWdpc3RyeSgpIHtcbiAgICByZXR1cm4geyBnZXRVbmlxdWVJZDogZ2V0U2VxTnVtYmVyR2VuZXJhdG9yKCksIGljdXM6IG5ldyBNYXAoKSB9O1xufVxuLyoqXG4gKiBJMThuQ29udGV4dCBpcyBhIGhlbHBlciBjbGFzcyB3aGljaCBrZWVwcyB0cmFjayBvZiBhbGwgaTE4bi1yZWxhdGVkIGFzcGVjdHNcbiAqIChhY2N1bXVsYXRlcyBwbGFjZWhvbGRlcnMsIGJpbmRpbmdzLCBldGMpIGJldHdlZW4gaTE4blN0YXJ0IGFuZCBpMThuRW5kIGluc3RydWN0aW9ucy5cbiAqXG4gKiBXaGVuIHdlIGVudGVyIGEgbmVzdGVkIHRlbXBsYXRlLCB0aGUgdG9wLWxldmVsIGNvbnRleHQgaXMgYmVpbmcgcGFzc2VkIGRvd25cbiAqIHRvIHRoZSBuZXN0ZWQgY29tcG9uZW50LCB3aGljaCB1c2VzIHRoaXMgY29udGV4dCB0byBnZW5lcmF0ZSBhIGNoaWxkIGluc3RhbmNlXG4gKiBvZiBJMThuQ29udGV4dCBjbGFzcyAodG8gaGFuZGxlIG5lc3RlZCB0ZW1wbGF0ZSkgYW5kIGF0IHRoZSBlbmQsIHJlY29uY2lsZXMgaXQgYmFja1xuICogd2l0aCB0aGUgcGFyZW50IGNvbnRleHQuXG4gKlxuICogQHBhcmFtIGluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGkxOG5TdGFydCwgd2hpY2ggaW5pdGlhdGVzIHRoaXMgY29udGV4dFxuICogQHBhcmFtIHJlZiBSZWZlcmVuY2UgdG8gYSB0cmFuc2xhdGlvbiBjb25zdCB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgaWYgdGh1cyBjb250ZXh0XG4gKiBAcGFyYW0gbGV2ZWwgTmVzdGluZyBsZXZlbCBkZWZpbmVkIGZvciBjaGlsZCBjb250ZXh0c1xuICogQHBhcmFtIHRlbXBsYXRlSW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgYSB0ZW1wbGF0ZSB3aGljaCB0aGlzIGNvbnRleHQgYmVsb25ncyB0b1xuICogQHBhcmFtIG1ldGEgTWV0YSBpbmZvcm1hdGlvbiAoaWQsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBldGMpIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRleHRcbiAqL1xuY2xhc3MgSTE4bkNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCByZWYsIGxldmVsID0gMCwgdGVtcGxhdGVJbmRleCA9IG51bGwsIG1ldGEsIHJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUluZGV4ID0gdGVtcGxhdGVJbmRleDtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pc0VtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSByZWdpc3RyeSB8fCBzZXR1cFJlZ2lzdHJ5KCk7XG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLl9yZWdpc3RyeS5nZXRVbmlxdWVJZCgpO1xuICAgIH1cbiAgICBhcHBlbmRUYWcodHlwZSwgbm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICBpZiAobm9kZS5pc1ZvaWQgJiYgY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGlnbm9yZSBcImNsb3NlXCIgZm9yIHZvaWQgdGFnc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBoID0gbm9kZS5pc1ZvaWQgfHwgIWNsb3NlZCA/IG5vZGUuc3RhcnROYW1lIDogbm9kZS5jbG9zZU5hbWU7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB7IHR5cGUsIGluZGV4LCBjdHg6IHRoaXMuaWQsIGlzVm9pZDogbm9kZS5pc1ZvaWQsIGNsb3NlZCB9O1xuICAgICAgICB1cGRhdGVQbGFjZWhvbGRlck1hcCh0aGlzLnBsYWNlaG9sZGVycywgcGgsIGNvbnRlbnQpO1xuICAgIH1cbiAgICBnZXQgaWN1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdHJ5LmljdXM7XG4gICAgfVxuICAgIGdldCBpc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxldmVsID09PSAwO1xuICAgIH1cbiAgICBnZXQgaXNSZXNvbHZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VucmVzb2x2ZWRDdHhDb3VudCA9PT0gMDtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVycy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4gcmVzdWx0LnNldChrZXksIHZhbHVlcy5tYXAoc2VyaWFsaXplUGxhY2Vob2xkZXJWYWx1ZSkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gcHVibGljIEFQSSB0byBhY2N1bXVsYXRlIGkxOG4tcmVsYXRlZCBjb250ZW50XG4gICAgYXBwZW5kQmluZGluZyhiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuYWRkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBhcHBlbmRJY3UobmFtZSwgcmVmKSB7XG4gICAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyTWFwKHRoaXMuX3JlZ2lzdHJ5LmljdXMsIG5hbWUsIHJlZik7XG4gICAgfVxuICAgIGFwcGVuZEJvdW5kVGV4dChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBocyA9IGFzc2VtYmxlQm91bmRUZXh0UGxhY2Vob2xkZXJzKG5vZGUsIHRoaXMuYmluZGluZ3Muc2l6ZSwgdGhpcy5pZCk7XG4gICAgICAgIHBocy5mb3JFYWNoKCh2YWx1ZXMsIGtleSkgPT4gdXBkYXRlUGxhY2Vob2xkZXJNYXAodGhpcy5wbGFjZWhvbGRlcnMsIGtleSwgLi4udmFsdWVzKSk7XG4gICAgfVxuICAgIGFwcGVuZFRlbXBsYXRlKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIGFkZCBvcGVuIGFuZCBjbG9zZSB0YWdzIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgICAgIC8vIHNpbmNlIHdlIHByb2Nlc3MgbmVzdGVkIHRlbXBsYXRlcyBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuYXBwZW5kVGFnKFRhZ1R5cGUuVEVNUExBVEUsIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50Kys7XG4gICAgfVxuICAgIGFwcGVuZEVsZW1lbnQobm9kZSwgaW5kZXgsIGNsb3NlZCkge1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLkVMRU1FTlQsIG5vZGUsIGluZGV4LCBjbG9zZWQpO1xuICAgIH1cbiAgICBhcHBlbmRQcm9qZWN0aW9uKG5vZGUsIGluZGV4KSB7XG4gICAgICAgIC8vIEFkZCBvcGVuIGFuZCBjbG9zZSB0YWdzIGF0IHRoZSBzYW1lIHRpbWUsIHNpbmNlIGA8bmctY29udGVudD5gIGhhcyBubyBjb250ZW50LFxuICAgICAgICAvLyBzbyB3aGVuIHdlIGNvbWUgYWNyb3NzIGA8bmctY29udGVudD5gIHdlIGNhbiByZWdpc3RlciBib3RoIG9wZW4gYW5kIGNsb3NlIHRhZ3MuXG4gICAgICAgIC8vIE5vdGU6IHJ1bnRpbWUgaTE4biBsb2dpYyBkb2Vzbid0IGRpc3Rpbmd1aXNoIGA8bmctY29udGVudD5gIHRhZyBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICAgIC8vIHJlZ3VsYXIgZWxlbWVudCB0YWcgcGxhY2Vob2xkZXJzLCBzbyB3ZSBnZW5lcmF0ZSBlbGVtZW50IHBsYWNlaG9sZGVycyBmb3IgYm90aCB0eXBlcy5cbiAgICAgICAgdGhpcy5hcHBlbmRUYWcoVGFnVHlwZS5FTEVNRU5ULCBub2RlLCBpbmRleCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZFRhZyhUYWdUeXBlLkVMRU1FTlQsIG5vZGUsIGluZGV4LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGFuIGluc3RhbmNlIG9mIGEgY2hpbGQgY29udGV4dCBiYXNlZCBvbiB0aGUgcm9vdCBvbmUsXG4gICAgICogd2hlbiB3ZSBlbnRlciBhIG5lc3RlZCB0ZW1wbGF0ZSB3aXRoaW4gSTE4biBzZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluc3RydWN0aW9uIGluZGV4IG9mIGNvcnJlc3BvbmRpbmcgaTE4blN0YXJ0LCB3aGljaCBpbml0aWF0ZXMgdGhpcyBjb250ZXh0XG4gICAgICogQHBhcmFtIHRlbXBsYXRlSW5kZXggSW5zdHJ1Y3Rpb24gaW5kZXggb2YgYSB0ZW1wbGF0ZSB3aGljaCB0aGlzIGNvbnRleHQgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSBtZXRhIE1ldGEgaW5mb3JtYXRpb24gKGlkLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgZXRjKSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJMThuQ29udGV4dCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGZvcmtDaGlsZENvbnRleHQoaW5kZXgsIHRlbXBsYXRlSW5kZXgsIG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJMThuQ29udGV4dChpbmRleCwgdGhpcy5yZWYsIHRoaXMubGV2ZWwgKyAxLCB0ZW1wbGF0ZUluZGV4LCBtZXRhLCB0aGlzLl9yZWdpc3RyeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uY2lsZXMgY2hpbGQgY29udGV4dCBpbnRvIHBhcmVudCBvbmUgb25jZSB0aGUgZW5kIG9mIHRoZSBpMThuIGJsb2NrIGlzIHJlYWNoZWQgKGkxOG5FbmQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRleHQgQ2hpbGQgSTE4bkNvbnRleHQgaW5zdGFuY2UgdG8gYmUgcmVjb25jaWxlZCB3aXRoIHBhcmVudCBjb250ZXh0LlxuICAgICAqL1xuICAgIHJlY29uY2lsZUNoaWxkQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIC8vIHNldCB0aGUgcmlnaHQgY29udGV4dCBpZCBmb3Igb3BlbiBhbmQgY2xvc2VcbiAgICAgICAgLy8gdGVtcGxhdGUgdGFncywgc28gd2UgY2FuIHVzZSBpdCBhcyBzdWItYmxvY2sgaWRzXG4gICAgICAgIFsnc3RhcnQnLCAnY2xvc2UnXS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gY29udGV4dC5tZXRhW2Ake29wfU5hbWVgXTtcbiAgICAgICAgICAgIGNvbnN0IHBocyA9IHRoaXMucGxhY2Vob2xkZXJzLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcGhzLmZpbmQoZmluZFRlbXBsYXRlRm4odGhpcy5pZCwgY29udGV4dC50ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgdGFnLmN0eCA9IGNvbnRleHQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWNvbmNpbGUgcGxhY2Vob2xkZXJzXG4gICAgICAgIGNvbnN0IGNoaWxkUGhzID0gY29udGV4dC5wbGFjZWhvbGRlcnM7XG4gICAgICAgIGNoaWxkUGhzLmZvckVhY2goKHZhbHVlcywga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwaHMgPSB0aGlzLnBsYWNlaG9sZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghcGhzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlcnMuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cnkgdG8gZmluZCBtYXRjaGluZyB0ZW1wbGF0ZS4uLlxuICAgICAgICAgICAgY29uc3QgdG1wbElkeCA9IHBocy5maW5kSW5kZXgoZmluZFRlbXBsYXRlRm4oY29udGV4dC5pZCwgY29udGV4dC50ZW1wbGF0ZUluZGV4KSk7XG4gICAgICAgICAgICBpZiAodG1wbElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gLi4uIGlmIGZvdW5kIC0gcmVwbGFjZSBpdCB3aXRoIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDbG9zZVRhZyA9IGtleS5zdGFydHNXaXRoKCdDTE9TRScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVGVtcGxhdGVUYWcgPSBrZXkuZW5kc1dpdGgoJ05HLVRFTVBMQVRFJyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzVGVtcGxhdGVUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VycmVudCB0ZW1wbGF0ZSdzIGNvbnRlbnQgaXMgcGxhY2VkIGJlZm9yZSBvciBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgdGVtcGxhdGUgdGFnLCBkZXBlbmRpbmcgb24gdGhlIG9wZW4vY2xvc2UgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgIHBocy5zcGxpY2UodG1wbElkeCArIChpc0Nsb3NlVGFnID8gMCA6IDEpLCAwLCAuLi52YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaXNDbG9zZVRhZyA/IHZhbHVlcy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2lkeF0udG1wbCA9IHBoc1t0bXBsSWR4XTtcbiAgICAgICAgICAgICAgICAgICAgcGhzLnNwbGljZSh0bXBsSWR4LCAxLCAuLi52YWx1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2UganVzdCBhcHBlbmQgY29udGVudCB0byBwbGFjZWhvbGRlciB2YWx1ZVxuICAgICAgICAgICAgICAgIHBocy5wdXNoKC4uLnZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVycy5zZXQoa2V5LCBwaHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdW5yZXNvbHZlZEN0eENvdW50LS07XG4gICAgfVxufVxuLy9cbi8vIEhlbHBlciBtZXRob2RzXG4vL1xuZnVuY3Rpb24gd3JhcChzeW1ib2wsIGluZGV4LCBjb250ZXh0SWQsIGNsb3NlZCkge1xuICAgIGNvbnN0IHN0YXRlID0gY2xvc2VkID8gJy8nIDogJyc7XG4gICAgcmV0dXJuIHdyYXBJMThuUGxhY2Vob2xkZXIoYCR7c3RhdGV9JHtzeW1ib2x9JHtpbmRleH1gLCBjb250ZXh0SWQpO1xufVxuZnVuY3Rpb24gd3JhcFRhZyhzeW1ib2wsIHsgaW5kZXgsIGN0eCwgaXNWb2lkIH0sIGNsb3NlZCkge1xuICAgIHJldHVybiBpc1ZvaWQgPyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCkgKyB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgdHJ1ZSkgOlxuICAgICAgICB3cmFwKHN5bWJvbCwgaW5kZXgsIGN0eCwgY2xvc2VkKTtcbn1cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZUZuKGN0eCwgdGVtcGxhdGVJbmRleCkge1xuICAgIHJldHVybiAodG9rZW4pID0+IHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4udHlwZSA9PT0gVGFnVHlwZS5URU1QTEFURSAmJlxuICAgICAgICB0b2tlbi5pbmRleCA9PT0gdGVtcGxhdGVJbmRleCAmJiB0b2tlbi5jdHggPT09IGN0eDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVBsYWNlaG9sZGVyVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gKGRhdGEsIGNsb3NlZCkgPT4gd3JhcFRhZygnIycsIGRhdGEsIGNsb3NlZCk7XG4gICAgY29uc3QgdGVtcGxhdGUgPSAoZGF0YSwgY2xvc2VkKSA9PiB3cmFwVGFnKCcqJywgZGF0YSwgY2xvc2VkKTtcbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBUYWdUeXBlLkVMRU1FTlQ6XG4gICAgICAgICAgICAvLyBjbG9zZSBlbGVtZW50IHRhZ1xuICAgICAgICAgICAgaWYgKHZhbHVlLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50KHZhbHVlLCB0cnVlKSArICh2YWx1ZS50bXBsID8gdGVtcGxhdGUodmFsdWUudG1wbCwgdHJ1ZSkgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvcGVuIGVsZW1lbnQgdGFnIHRoYXQgYWxzbyBpbml0aWF0ZXMgYSB0ZW1wbGF0ZVxuICAgICAgICAgICAgaWYgKHZhbHVlLnRtcGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGUodmFsdWUudG1wbCkgKyBlbGVtZW50KHZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pc1ZvaWQgPyB0ZW1wbGF0ZSh2YWx1ZS50bXBsLCB0cnVlKSA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50KHZhbHVlKTtcbiAgICAgICAgY2FzZSBUYWdUeXBlLlRFTVBMQVRFOlxuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHZhbHVlLCB2YWx1ZS5jbG9zZWQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cblxuY2xhc3MgSWN1U2VyaWFsaXplclZpc2l0b3Ige1xuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnZhbHVlO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgY29uc3Qgc3RyQ2FzZXMgPSBPYmplY3Qua2V5cyhpY3UuY2FzZXMpLm1hcCgoaykgPT4gYCR7a30geyR7aWN1LmNhc2VzW2tdLnZpc2l0KHRoaXMpfX1gKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYHske2ljdS5leHByZXNzaW9uUGxhY2Vob2xkZXJ9LCAke2ljdS50eXBlfSwgJHtzdHJDYXNlcy5qb2luKCcgJyl9fWA7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIHBoLmlzVm9pZCA/XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSkgOlxuICAgICAgICAgICAgYCR7dGhpcy5mb3JtYXRQaChwaC5zdGFydE5hbWUpfSR7cGguY2hpbGRyZW4ubWFwKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKS5qb2luKCcnKX0ke3RoaXMuZm9ybWF0UGgocGguY2xvc2VOYW1lKX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdFBoKHBoLm5hbWUpO1xuICAgIH1cbiAgICBmb3JtYXRQaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYHske2Zvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWUodmFsdWUsIC8qIHVzZUNhbWVsQ2FzZSAqLyBmYWxzZSl9fWA7XG4gICAgfVxufVxuY29uc3Qgc2VyaWFsaXplciA9IG5ldyBJY3VTZXJpYWxpemVyVmlzaXRvcigpO1xuZnVuY3Rpb24gc2VyaWFsaXplSWN1Tm9kZShpY3UpIHtcbiAgICByZXR1cm4gaWN1LnZpc2l0KHNlcmlhbGl6ZXIpO1xufVxuXG5jb25zdCBUQUdfVE9fUExBQ0VIT0xERVJfTkFNRVMgPSB7XG4gICAgJ0EnOiAnTElOSycsXG4gICAgJ0InOiAnQk9MRF9URVhUJyxcbiAgICAnQlInOiAnTElORV9CUkVBSycsXG4gICAgJ0VNJzogJ0VNUEhBU0lTRURfVEVYVCcsXG4gICAgJ0gxJzogJ0hFQURJTkdfTEVWRUwxJyxcbiAgICAnSDInOiAnSEVBRElOR19MRVZFTDInLFxuICAgICdIMyc6ICdIRUFESU5HX0xFVkVMMycsXG4gICAgJ0g0JzogJ0hFQURJTkdfTEVWRUw0JyxcbiAgICAnSDUnOiAnSEVBRElOR19MRVZFTDUnLFxuICAgICdINic6ICdIRUFESU5HX0xFVkVMNicsXG4gICAgJ0hSJzogJ0hPUklaT05UQUxfUlVMRScsXG4gICAgJ0knOiAnSVRBTElDX1RFWFQnLFxuICAgICdMSSc6ICdMSVNUX0lURU0nLFxuICAgICdMSU5LJzogJ01FRElBX0xJTksnLFxuICAgICdPTCc6ICdPUkRFUkVEX0xJU1QnLFxuICAgICdQJzogJ1BBUkFHUkFQSCcsXG4gICAgJ1EnOiAnUVVPVEFUSU9OJyxcbiAgICAnUyc6ICdTVFJJS0VUSFJPVUdIX1RFWFQnLFxuICAgICdTTUFMTCc6ICdTTUFMTF9URVhUJyxcbiAgICAnU1VCJzogJ1NVQlNUUklQVCcsXG4gICAgJ1NVUCc6ICdTVVBFUlNDUklQVCcsXG4gICAgJ1RCT0RZJzogJ1RBQkxFX0JPRFknLFxuICAgICdURCc6ICdUQUJMRV9DRUxMJyxcbiAgICAnVEZPT1QnOiAnVEFCTEVfRk9PVEVSJyxcbiAgICAnVEgnOiAnVEFCTEVfSEVBREVSX0NFTEwnLFxuICAgICdUSEVBRCc6ICdUQUJMRV9IRUFERVInLFxuICAgICdUUic6ICdUQUJMRV9ST1cnLFxuICAgICdUVCc6ICdNT05PU1BBQ0VEX1RFWFQnLFxuICAgICdVJzogJ1VOREVSTElORURfVEVYVCcsXG4gICAgJ1VMJzogJ1VOT1JERVJFRF9MSVNUJyxcbn07XG4vKipcbiAqIENyZWF0ZXMgdW5pcXVlIG5hbWVzIGZvciBwbGFjZWhvbGRlciB3aXRoIGRpZmZlcmVudCBjb250ZW50LlxuICpcbiAqIFJldHVybnMgdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZSB3aGVuIHRoZSBjb250ZW50IGlzIGlkZW50aWNhbC5cbiAqL1xuY2xhc3MgUGxhY2Vob2xkZXJSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSBvY2N1cnJlbmNlIG9mIHRoZSBiYXNlIG5hbWUgdG9wIGdlbmVyYXRlIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzID0ge307XG4gICAgICAgIC8vIE1hcHMgc2lnbmF0dXJlIHRvIHBsYWNlaG9sZGVyIG5hbWVzXG4gICAgICAgIHRoaXMuX3NpZ25hdHVyZVRvTmFtZSA9IHt9O1xuICAgIH1cbiAgICBnZXRTdGFydFRhZ1BsYWNlaG9sZGVyTmFtZSh0YWcsIGF0dHJzLCBpc1ZvaWQpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5faGFzaFRhZyh0YWcsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBpZiAodGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cHBlclRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBiYXNlTmFtZSA9IFRBR19UT19QTEFDRUhPTERFUl9OQU1FU1t1cHBlclRhZ10gfHwgYFRBR18ke3VwcGVyVGFnfWA7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUoaXNWb2lkID8gYmFzZU5hbWUgOiBgU1RBUlRfJHtiYXNlTmFtZX1gKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0Q2xvc2VUYWdQbGFjZWhvbGRlck5hbWUodGFnKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuX2hhc2hDbG9zaW5nVGFnKHRhZyk7XG4gICAgICAgIGlmICh0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGJhc2VOYW1lID0gVEFHX1RPX1BMQUNFSE9MREVSX05BTUVTW3VwcGVyVGFnXSB8fCBgVEFHXyR7dXBwZXJUYWd9YDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZShgQ0xPU0VfJHtiYXNlTmFtZX1gKTtcbiAgICAgICAgdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV0gPSBuYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZ2V0UGxhY2Vob2xkZXJOYW1lKG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgdXBwZXJOYW1lID0gbmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBgUEg6ICR7dXBwZXJOYW1lfT0ke2NvbnRlbnR9YDtcbiAgICAgICAgaWYgKHRoaXMuX3NpZ25hdHVyZVRvTmFtZVtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlVG9OYW1lW3NpZ25hdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5pcXVlTmFtZSA9IHRoaXMuX2dlbmVyYXRlVW5pcXVlTmFtZSh1cHBlck5hbWUpO1xuICAgICAgICB0aGlzLl9zaWduYXR1cmVUb05hbWVbc2lnbmF0dXJlXSA9IHVuaXF1ZU5hbWU7XG4gICAgICAgIHJldHVybiB1bmlxdWVOYW1lO1xuICAgIH1cbiAgICBnZXRVbmlxdWVQbGFjZWhvbGRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZW5lcmF0ZVVuaXF1ZU5hbWUobmFtZS50b1VwcGVyQ2FzZSgpKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgYSBoYXNoIGZvciBhIHRhZyAtIGRvZXMgbm90IHRha2UgYXR0cmlidXRlIG9yZGVyIGludG8gYWNjb3VudFxuICAgIF9oYXNoVGFnKHRhZywgYXR0cnMsIGlzVm9pZCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IGA8JHt0YWd9YDtcbiAgICAgICAgY29uc3Qgc3RyQXR0cnMgPSBPYmplY3Qua2V5cyhhdHRycykuc29ydCgpLm1hcCgobmFtZSkgPT4gYCAke25hbWV9PSR7YXR0cnNbbmFtZV19YCkuam9pbignJyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGlzVm9pZCA/ICcvPicgOiBgPjwvJHt0YWd9PmA7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ckF0dHJzICsgZW5kO1xuICAgIH1cbiAgICBfaGFzaENsb3NpbmdUYWcodGFnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoVGFnKGAvJHt0YWd9YCwge30sIGZhbHNlKTtcbiAgICB9XG4gICAgX2dlbmVyYXRlVW5pcXVlTmFtZShiYXNlKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHMuaGFzT3duUHJvcGVydHkoYmFzZSk7XG4gICAgICAgIGlmICghc2Vlbikge1xuICAgICAgICAgICAgdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fcGxhY2VIb2xkZXJOYW1lQ291bnRzW2Jhc2VdO1xuICAgICAgICB0aGlzLl9wbGFjZUhvbGRlck5hbWVDb3VudHNbYmFzZV0gPSBpZCArIDE7XG4gICAgICAgIHJldHVybiBgJHtiYXNlfV8ke2lkfWA7XG4gICAgfVxufVxuXG5jb25zdCBfZXhwUGFyc2VyID0gbmV3IFBhcnNlciQxKG5ldyBMZXhlcigpKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGNvbnZlcnRpbmcgaHRtbCBub2RlcyB0byBhbiBpMThuIE1lc3NhZ2UgZ2l2ZW4gYW4gaW50ZXJwb2xhdGlvbkNvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVJMThuTWVzc2FnZUZhY3RvcnkoaW50ZXJwb2xhdGlvbkNvbmZpZykge1xuICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX0kxOG5WaXNpdG9yKF9leHBQYXJzZXIsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgIHJldHVybiAobm9kZXMsIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCwgdmlzaXROb2RlRm4pID0+IHZpc2l0b3IudG9JMThuTWVzc2FnZShub2RlcywgbWVhbmluZywgZGVzY3JpcHRpb24sIGN1c3RvbUlkLCB2aXNpdE5vZGVGbik7XG59XG5mdW5jdGlvbiBub29wVmlzaXROb2RlRm4oX2h0bWwsIGkxOG4pIHtcbiAgICByZXR1cm4gaTE4bjtcbn1cbmNsYXNzIF9JMThuVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoX2V4cHJlc3Npb25QYXJzZXIsIF9pbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2V4cHJlc3Npb25QYXJzZXIgPSBfZXhwcmVzc2lvblBhcnNlcjtcbiAgICAgICAgdGhpcy5faW50ZXJwb2xhdGlvbkNvbmZpZyA9IF9pbnRlcnBvbGF0aW9uQ29uZmlnO1xuICAgIH1cbiAgICB0b0kxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nID0gJycsIGRlc2NyaXB0aW9uID0gJycsIGN1c3RvbUlkID0gJycsIHZpc2l0Tm9kZUZuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBpc0ljdTogbm9kZXMubGVuZ3RoID09IDEgJiYgbm9kZXNbMF0gaW5zdGFuY2VvZiBFeHBhbnNpb24sXG4gICAgICAgICAgICBpY3VEZXB0aDogMCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyUmVnaXN0cnk6IG5ldyBQbGFjZWhvbGRlclJlZ2lzdHJ5KCksXG4gICAgICAgICAgICBwbGFjZWhvbGRlclRvQ29udGVudDoge30sXG4gICAgICAgICAgICBwbGFjZWhvbGRlclRvTWVzc2FnZToge30sXG4gICAgICAgICAgICB2aXNpdE5vZGVGbjogdmlzaXROb2RlRm4gfHwgbm9vcFZpc2l0Tm9kZUZuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpMThub2RlcyA9IHZpc2l0QWxsKHRoaXMsIG5vZGVzLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKGkxOG5vZGVzLCBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50LCBjb250ZXh0LnBsYWNlaG9sZGVyVG9NZXNzYWdlLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQpO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbiwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGF0dHJzID0ge307XG4gICAgICAgIGVsLmF0dHJzLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgICAgICAvLyBEbyBub3QgdmlzaXQgdGhlIGF0dHJpYnV0ZXMsIHRyYW5zbGF0YWJsZSBvbmVzIGFyZSB0b3AtbGV2ZWwgQVNUc1xuICAgICAgICAgICAgYXR0cnNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpc1ZvaWQgPSBnZXRIdG1sVGFnRGVmaW5pdGlvbihlbC5uYW1lKS5pc1ZvaWQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0UGhOYW1lID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldFN0YXJ0VGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUsIGF0dHJzLCBpc1ZvaWQpO1xuICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W3N0YXJ0UGhOYW1lXSA9IHtcbiAgICAgICAgICAgIHRleHQ6IGVsLnN0YXJ0U291cmNlU3Bhbi50b1N0cmluZygpLFxuICAgICAgICAgICAgc291cmNlU3BhbjogZWwuc3RhcnRTb3VyY2VTcGFuLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2xvc2VQaE5hbWUgPSAnJztcbiAgICAgICAgaWYgKCFpc1ZvaWQpIHtcbiAgICAgICAgICAgIGNsb3NlUGhOYW1lID0gY29udGV4dC5wbGFjZWhvbGRlclJlZ2lzdHJ5LmdldENsb3NlVGFnUGxhY2Vob2xkZXJOYW1lKGVsLm5hbWUpO1xuICAgICAgICAgICAgY29udGV4dC5wbGFjZWhvbGRlclRvQ29udGVudFtjbG9zZVBoTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogYDwvJHtlbC5uYW1lfT5gLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGVsLmVuZFNvdXJjZVNwYW4gPz8gZWwuc291cmNlU3BhbixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBUYWdQbGFjZWhvbGRlcihlbC5uYW1lLCBhdHRycywgc3RhcnRQaE5hbWUsIGNsb3NlUGhOYW1lLCBjaGlsZHJlbiwgaXNWb2lkLCBlbC5zb3VyY2VTcGFuLCBlbC5zdGFydFNvdXJjZVNwYW4sIGVsLmVuZFNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gY29udGV4dC52aXNpdE5vZGVGbihlbCwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlID0gYXR0cmlidXRlLnZhbHVlVG9rZW5zID09PSB1bmRlZmluZWQgfHwgYXR0cmlidXRlLnZhbHVlVG9rZW5zLmxlbmd0aCA9PT0gMSA/XG4gICAgICAgICAgICBuZXcgVGV4dCQyKGF0dHJpYnV0ZS52YWx1ZSwgYXR0cmlidXRlLnZhbHVlU3BhbiB8fCBhdHRyaWJ1dGUuc291cmNlU3BhbikgOlxuICAgICAgICAgICAgdGhpcy5fdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24oYXR0cmlidXRlLnZhbHVlVG9rZW5zLCBhdHRyaWJ1dGUudmFsdWVTcGFuIHx8IGF0dHJpYnV0ZS5zb3VyY2VTcGFuLCBjb250ZXh0LCBhdHRyaWJ1dGUuaTE4bik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGF0dHJpYnV0ZSwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0ZXh0LnRva2Vucy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pIDpcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0VGV4dFdpdGhJbnRlcnBvbGF0aW9uKHRleHQudG9rZW5zLCB0ZXh0LnNvdXJjZVNwYW4sIGNvbnRleHQsIHRleHQuaTE4bik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKHRleHQsIG5vZGUpO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuaWN1RGVwdGgrKztcbiAgICAgICAgY29uc3QgaTE4bkljdUNhc2VzID0ge307XG4gICAgICAgIGNvbnN0IGkxOG5JY3UgPSBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGkxOG5JY3VDYXNlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICBpY3UuY2FzZXMuZm9yRWFjaCgoY2F6ZSkgPT4ge1xuICAgICAgICAgICAgaTE4bkljdUNhc2VzW2NhemUudmFsdWVdID0gbmV3IENvbnRhaW5lcihjYXplLmV4cHJlc3Npb24ubWFwKChub2RlKSA9PiBub2RlLnZpc2l0KHRoaXMsIGNvbnRleHQpKSwgY2F6ZS5leHBTb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRleHQuaWN1RGVwdGgtLTtcbiAgICAgICAgaWYgKGNvbnRleHQuaXNJY3UgfHwgY29udGV4dC5pY3VEZXB0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgYW4gSUNVIG5vZGUgd2hlbjpcbiAgICAgICAgICAgIC8vIC0gdGhlIG1lc3NhZ2UgKHZzIGEgcGFydCBvZiB0aGUgbWVzc2FnZSkgaXMgYW4gSUNVIG1lc3NhZ2UsIG9yXG4gICAgICAgICAgICAvLyAtIHRoZSBJQ1UgbWVzc2FnZSBpcyBuZXN0ZWQuXG4gICAgICAgICAgICBjb25zdCBleHBQaCA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRVbmlxdWVQbGFjZWhvbGRlcihgVkFSXyR7aWN1LnR5cGV9YCk7XG4gICAgICAgICAgICBpMThuSWN1LmV4cHJlc3Npb25QbGFjZWhvbGRlciA9IGV4cFBoO1xuICAgICAgICAgICAgY29udGV4dC5wbGFjZWhvbGRlclRvQ29udGVudFtleHBQaF0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogaWN1LnN3aXRjaFZhbHVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IGljdS5zd2l0Y2hWYWx1ZVNvdXJjZVNwYW4sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudmlzaXROb2RlRm4oaWN1LCBpMThuSWN1KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHJldHVybnMgYSBwbGFjZWhvbGRlclxuICAgICAgICAvLyBJQ1UgcGxhY2Vob2xkZXJzIHNob3VsZCBub3QgYmUgcmVwbGFjZWQgd2l0aCB0aGVpciBvcmlnaW5hbCBjb250ZW50IGJ1dCB3aXRoIHRoZSB0aGVpclxuICAgICAgICAvLyB0cmFuc2xhdGlvbnMuXG4gICAgICAgIC8vIFRPRE8odmljYik6IGFkZCBhIGh0bWwuTm9kZSAtPiBpMThuLk1lc3NhZ2UgY2FjaGUgdG8gYXZvaWQgaGF2aW5nIHRvIHJlLWNyZWF0ZSB0aGUgbXNnXG4gICAgICAgIGNvbnN0IHBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoJ0lDVScsIGljdS5zb3VyY2VTcGFuLnRvU3RyaW5nKCkpO1xuICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0gPSB0aGlzLnRvSTE4bk1lc3NhZ2UoW2ljdV0sICcnLCAnJywgJycsIHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgSWN1UGxhY2Vob2xkZXIoaTE4bkljdSwgcGhOYW1lLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZpc2l0Tm9kZUZuKGljdSwgbm9kZSk7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShfaWN1Q2FzZSwgX2NvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlYWNoYWJsZSBjb2RlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQsIHRleHQgYW5kIGludGVycG9sYXRlZCB0b2tlbnMgdXAgaW50byB0ZXh0IGFuZCBwbGFjZWhvbGRlciBwaWVjZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5zIFRoZSB0ZXh0IGFuZCBpbnRlcnBvbGF0ZWQgdG9rZW5zLlxuICAgICAqIEBwYXJhbSBzb3VyY2VTcGFuIFRoZSBzcGFuIG9mIHRoZSB3aG9sZSBvZiB0aGUgYHRleHRgIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSB2aXNpdG9yLCB1c2VkIHRvIGNvbXB1dGUgYW5kIHN0b3JlIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcGFyYW0gcHJldmlvdXNJMThuIEFueSBpMThuIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGB0ZXh0YCBmcm9tIGEgcHJldmlvdXMgcGFzcy5cbiAgICAgKi9cbiAgICBfdmlzaXRUZXh0V2l0aEludGVycG9sYXRpb24odG9rZW5zLCBzb3VyY2VTcGFuLCBjb250ZXh0LCBwcmV2aW91c0kxOG4pIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgc2VxdWVuY2Ugb2YgYFRleHRgIGFuZCBgUGxhY2Vob2xkZXJgIG5vZGVzIGdyb3VwZWQgaW4gYSBgQ29udGFpbmVyYC5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgLy8gV2Ugd2lsbCBvbmx5IGNyZWF0ZSBhIGNvbnRhaW5lciBpZiB0aGVyZSBhcmUgYWN0dWFsbHkgaW50ZXJwb2xhdGlvbnMsXG4gICAgICAgIC8vIHNvIHRoaXMgZmxhZyB0cmFja3MgdGhhdC5cbiAgICAgICAgbGV0IGhhc0ludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgOCAvKiBUb2tlblR5cGUuSU5URVJQT0xBVElPTiAqLzpcbiAgICAgICAgICAgICAgICBjYXNlIDE3IC8qIFRva2VuVHlwZS5BVFRSX1ZBTFVFX0lOVEVSUE9MQVRJT04gKi86XG4gICAgICAgICAgICAgICAgICAgIGhhc0ludGVycG9sYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdG9rZW4ucGFydHNbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VOYW1lID0gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShleHByZXNzaW9uKSB8fCAnSU5URVJQT0xBVElPTic7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBoTmFtZSA9IGNvbnRleHQucGxhY2Vob2xkZXJSZWdpc3RyeS5nZXRQbGFjZWhvbGRlck5hbWUoYmFzZU5hbWUsIGV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnBsYWNlaG9sZGVyVG9Db250ZW50W3BoTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0b2tlbi5wYXJ0cy5qb2luKCcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVNwYW46IHRva2VuLnNvdXJjZVNwYW5cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChuZXcgUGxhY2Vob2xkZXIoZXhwcmVzc2lvbiwgcGhOYW1lLCB0b2tlbi5zb3VyY2VTcGFuKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi5wYXJ0c1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHRva2VuIGlzIHRleHQgb3IgYW4gZW5jb2RlZCBlbnRpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBpcyBmb2xsb3dpbmcgb24gZnJvbSBhIHByZXZpb3VzIHRleHQgbm9kZSB0aGVuIG1lcmdlIGl0IGludG8gdGhhdCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGlmIGl0IGlzIGZvbGxvd2luZyBhbiBpbnRlcnBvbGF0aW9uLCB0aGVuIGFkZCBhIG5ldyBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIFRleHQkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnZhbHVlICs9IHRva2VuLnBhcnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLnNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHByZXZpb3VzLnNvdXJjZVNwYW4uc3RhcnQsIHRva2VuLnNvdXJjZVNwYW4uZW5kLCBwcmV2aW91cy5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgcHJldmlvdXMuc291cmNlU3Bhbi5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV3IFRleHQkMih0b2tlbi5wYXJ0c1swXSwgdG9rZW4uc291cmNlU3BhbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAvLyBXaGl0ZXNwYWNlIHJlbW92YWwgbWF5IGhhdmUgaW52YWxpZGF0ZWQgdGhlIGludGVycG9sYXRpb24gc291cmNlLXNwYW5zLlxuICAgICAgICAgICAgcmV1c2VQcmV2aW91c1NvdXJjZVNwYW5zKG5vZGVzLCBwcmV2aW91c0kxOG4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250YWluZXIobm9kZXMsIHNvdXJjZVNwYW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZS11c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIGBwcmV2aW91c0kxOG5gIG1ldGFkYXRhIGZvciB0aGUgYG5vZGVzYC5cbiAqXG4gKiBXaGl0ZXNwYWNlIHJlbW92YWwgY2FuIGludmFsaWRhdGUgdGhlIHNvdXJjZS1zcGFucyBvZiBpbnRlcnBvbGF0aW9uIG5vZGVzLCBzbyB3ZVxuICogcmV1c2UgdGhlIHNvdXJjZS1zcGFuIHN0b3JlZCBmcm9tIGEgcHJldmlvdXMgcGFzcyBiZWZvcmUgdGhlIHdoaXRlc3BhY2Ugd2FzIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIG5vZGVzIFRoZSBgVGV4dGAgYW5kIGBQbGFjZWhvbGRlcmAgbm9kZXMgdG8gYmUgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHByZXZpb3VzSTE4biBBbnkgaTE4biBtZXRhZGF0YSBmb3IgdGhlc2UgYG5vZGVzYCBzdG9yZWQgZnJvbSBhIHByZXZpb3VzIHBhc3MuXG4gKi9cbmZ1bmN0aW9uIHJldXNlUHJldmlvdXNTb3VyY2VTcGFucyhub2RlcywgcHJldmlvdXNJMThuKSB7XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhlIGBwcmV2aW91c0kxOG5gIGlzIGFuIGkxOG4gYE1lc3NhZ2VgLCBzbyB3ZSBhcmUgcHJvY2Vzc2luZyBhbiBgQXR0cmlidXRlYCB3aXRoIGkxOG5cbiAgICAgICAgLy8gbWV0YWRhdGEuIFRoZSBgTWVzc2FnZWAgc2hvdWxkIGNvbnNpc3Qgb25seSBvZiBhIHNpbmdsZSBgQ29udGFpbmVyYCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAvLyBwYXJ0cyAoYFRleHRgIGFuZCBgUGxhY2Vob2xkZXJgKSB0byBwcm9jZXNzLlxuICAgICAgICBhc3NlcnRTaW5nbGVDb250YWluZXJNZXNzYWdlKHByZXZpb3VzSTE4bik7XG4gICAgICAgIHByZXZpb3VzSTE4biA9IHByZXZpb3VzSTE4bi5ub2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzSTE4biBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAvLyBUaGUgYHByZXZpb3VzSTE4bmAgaXMgYSBgQ29udGFpbmVyYCwgd2hpY2ggbWVhbnMgdGhhdCB0aGlzIGlzIGEgc2Vjb25kIGkxOG4gZXh0cmFjdGlvbiBwYXNzXG4gICAgICAgIC8vIGFmdGVyIHdoaXRlc3BhY2UgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBU1Qgbm9kZXMuXG4gICAgICAgIGFzc2VydEVxdWl2YWxlbnROb2RlcyhwcmV2aW91c0kxOG4uY2hpbGRyZW4sIG5vZGVzKTtcbiAgICAgICAgLy8gUmV1c2UgdGhlIHNvdXJjZS1zcGFucyBmcm9tIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2Rlc1tpXS5zb3VyY2VTcGFuID0gcHJldmlvdXNJMThuLmNoaWxkcmVuW2ldLnNvdXJjZVNwYW47XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYG1lc3NhZ2VgIGNvbnRhaW5zIGV4YWN0bHkgb25lIGBDb250YWluZXJgIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFNpbmdsZUNvbnRhaW5lck1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IG5vZGVzID0gbWVzc2FnZS5ub2RlcztcbiAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAxIHx8ICEobm9kZXNbMF0gaW5zdGFuY2VvZiBDb250YWluZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwcmV2aW91cyBpMThuIG1lc3NhZ2UgLSBleHBlY3RlZCBpdCB0byBjb25zaXN0IG9mIG9ubHkgYSBzaW5nbGUgYENvbnRhaW5lcmAgbm9kZS4nKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYHByZXZpb3VzTm9kZXNgIGFuZCBgbm9kZWAgY29sbGVjdGlvbnMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYW5kXG4gKiBjb3JyZXNwb25kaW5nIGVsZW1lbnRzIGhhdmUgdGhlIHNhbWUgbm9kZSB0eXBlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFcXVpdmFsZW50Tm9kZXMocHJldmlvdXNOb2Rlcywgbm9kZXMpIHtcbiAgICBpZiAocHJldmlvdXNOb2Rlcy5sZW5ndGggIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxuICAgIGlmIChwcmV2aW91c05vZGVzLnNvbWUoKG5vZGUsIGkpID0+IG5vZGVzW2ldLmNvbnN0cnVjdG9yICE9PSBub2RlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0eXBlcyBvZiB0aGUgaTE4biBtZXNzYWdlIGNoaWxkcmVuIGNoYW5nZWQgYmV0d2VlbiBmaXJzdCBhbmQgc2Vjb25kIHBhc3MuJyk7XG4gICAgfVxufVxuY29uc3QgX0NVU1RPTV9QSF9FWFAgPSAvXFwvXFwvW1xcc1xcU10qaTE4bltcXHNcXFNdKlxcKFtcXHNcXFNdKnBoW1xcc1xcU10qPVtcXHNcXFNdKihcInwnKShbXFxzXFxTXSo/KVxcMVtcXHNcXFNdKlxcKS9nO1xuZnVuY3Rpb24gZXh0cmFjdFBsYWNlaG9sZGVyTmFtZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zcGxpdChfQ1VTVE9NX1BIX0VYUClbMl07XG59XG5cbi8qKlxuICogQW4gaTE4biBlcnJvci5cbiAqL1xuY2xhc3MgSTE4bkVycm9yIGV4dGVuZHMgUGFyc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgbXNnKSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIG1zZyk7XG4gICAgfVxufVxuXG5jb25zdCBzZXRJMThuUmVmcyA9IChodG1sTm9kZSwgaTE4bk5vZGUpID0+IHtcbiAgICBpZiAoaHRtbE5vZGUgaW5zdGFuY2VvZiBOb2RlV2l0aEkxOG4pIHtcbiAgICAgICAgaWYgKGkxOG5Ob2RlIGluc3RhbmNlb2YgSWN1UGxhY2Vob2xkZXIgJiYgaHRtbE5vZGUuaTE4biBpbnN0YW5jZW9mIE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaHRtbCBub2RlIHJlcHJlc2VudHMgYW4gSUNVIGJ1dCB0aGlzIGlzIGEgc2Vjb25kIHByb2Nlc3NpbmcgcGFzcywgYW5kIHRoZSBsZWdhY3kgaWRcbiAgICAgICAgICAgIC8vIHdhcyBjb21wdXRlZCBpbiB0aGUgcHJldmlvdXMgcGFzcyBhbmQgc3RvcmVkIGluIHRoZSBgaTE4bmAgcHJvcGVydHkgYXMgYSBtZXNzYWdlLlxuICAgICAgICAgICAgLy8gV2UgYXJlIGFib3V0IHRvIHdpcGUgb3V0IHRoYXQgcHJvcGVydHkgc28gY2FwdHVyZSB0aGUgcHJldmlvdXMgbWVzc2FnZSB0byBiZSByZXVzZWQgd2hlblxuICAgICAgICAgICAgLy8gZ2VuZXJhdGluZyB0aGUgbWVzc2FnZSBmb3IgdGhpcyBJQ1UgbGF0ZXIuIFNlZSBgX2dlbmVyYXRlSTE4bk1lc3NhZ2UoKWAuXG4gICAgICAgICAgICBpMThuTm9kZS5wcmV2aW91c01lc3NhZ2UgPSBodG1sTm9kZS5pMThuO1xuICAgICAgICB9XG4gICAgICAgIGh0bWxOb2RlLmkxOG4gPSBpMThuTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGkxOG5Ob2RlO1xufTtcbi8qKlxuICogVGhpcyB2aXNpdG9yIHdhbGtzIG92ZXIgSFRNTCBwYXJzZSB0cmVlIGFuZCBjb252ZXJ0cyBpbmZvcm1hdGlvbiBzdG9yZWQgaW5cbiAqIGkxOG4tcmVsYXRlZCBhdHRyaWJ1dGVzIChcImkxOG5cIiBhbmQgXCJpMThuLSpcIikgaW50byBpMThuIG1ldGEgb2JqZWN0IHRoYXQgaXNcbiAqIHN0b3JlZCB3aXRoIG90aGVyIGVsZW1lbnQncyBhbmQgYXR0cmlidXRlJ3MgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIEkxOG5NZXRhVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZyA9IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcsIGtlZXBJMThuQXR0cnMgPSBmYWxzZSwgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbkNvbmZpZyA9IGludGVycG9sYXRpb25Db25maWc7XG4gICAgICAgIHRoaXMua2VlcEkxOG5BdHRycyA9IGtlZXBJMThuQXR0cnM7XG4gICAgICAgIHRoaXMuZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCA9IGVuYWJsZUkxOG5MZWdhY3lNZXNzYWdlSWRGb3JtYXQ7XG4gICAgICAgIC8vIHdoZXRoZXIgdmlzaXRlZCBub2RlcyBjb250YWluIGkxOG4gaW5mb3JtYXRpb25cbiAgICAgICAgdGhpcy5oYXNJMThuTWV0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgICAgICAgLy8gaTE4biBtZXNzYWdlIGdlbmVyYXRpb24gZmFjdG9yeVxuICAgICAgICB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZSA9IGNyZWF0ZUkxOG5NZXNzYWdlRmFjdG9yeSh0aGlzLmludGVycG9sYXRpb25Db25maWcpO1xuICAgIH1cbiAgICBfZ2VuZXJhdGVJMThuTWVzc2FnZShub2RlcywgbWV0YSA9ICcnLCB2aXNpdE5vZGVGbikge1xuICAgICAgICBjb25zdCB7IG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBjdXN0b21JZCB9ID0gdGhpcy5fcGFyc2VNZXRhZGF0YShtZXRhKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlKG5vZGVzLCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgY3VzdG9tSWQsIHZpc2l0Tm9kZUZuKTtcbiAgICAgICAgdGhpcy5fc2V0TWVzc2FnZUlkKG1lc3NhZ2UsIG1ldGEpO1xuICAgICAgICB0aGlzLl9zZXRMZWdhY3lJZHMobWVzc2FnZSwgbWV0YSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICB2aXNpdEFsbFdpdGhFcnJvcnMobm9kZXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzLCBudWxsKSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHJlc3VsdCwgdGhpcy5fZXJyb3JzKTtcbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChoYXNJMThuQXR0cnMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzSTE4bk1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzTWV0YSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGVsZW1lbnQuYXR0cnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBJMThOX0FUVFIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcm9vdCAnaTE4bicgbm9kZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaTE4biA9IGVsZW1lbnQuaTE4biB8fCBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5fZ2VuZXJhdGVJMThuTWVzc2FnZShlbGVtZW50LmNoaWxkcmVuLCBpMThuLCBzZXRJMThuUmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoZSBtZXNzYWdlIGlmIGl0IGlzIGVtcHR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgbWVzc2FnZSBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmkxOG4gPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyLm5hbWUuc3RhcnRzV2l0aChJMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyAnaTE4bi0qJyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBhdHRyLm5hbWUuc2xpY2UoSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcnVzdGVkVHlwZXNTaW5rKGVsZW1lbnQubmFtZSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGF0dHIsIGBUcmFuc2xhdGluZyBhdHRyaWJ1dGUgJyR7bmFtZX0nIGlzIGRpc2FsbG93ZWQgZm9yIHNlY3VyaXR5IHJlYXNvbnMuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyc01ldGFbbmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBub24taTE4biBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGkxOG4gbWV0YSBmb3IgYXR0cmlidXRlc1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzTWV0YSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBhdHRyc01ldGFbYXR0ci5uYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGNyZWF0ZSB0cmFuc2xhdGlvbiBmb3IgZW1wdHkgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YSAhPT0gdW5kZWZpbmVkICYmIGF0dHIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuaTE4biA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2F0dHJdLCBhdHRyLmkxOG4gfHwgbWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcEkxOG5BdHRycykge1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBlbGVtZW50J3MgYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBrZWVwaW5nIG9ubHkgbm9uLWkxOG4gcmVsYXRlZCBvbmVzXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hdHRycyA9IGF0dHJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjdXJyZW50TWVzc2FnZSkge1xuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGV4cGFuc2lvbi5pMThuO1xuICAgICAgICB0aGlzLmhhc0kxOG5NZXRhID0gdHJ1ZTtcbiAgICAgICAgaWYgKG1ldGEgaW5zdGFuY2VvZiBJY3VQbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgLy8gc2V0IElDVSBwbGFjZWhvbGRlciBuYW1lIChlLmcuIFwiSUNVXzFcIiksXG4gICAgICAgICAgICAvLyBnZW5lcmF0ZWQgd2hpbGUgcHJvY2Vzc2luZyByb290IGVsZW1lbnQgY29udGVudHMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gcmVmZXJlbmNlIGl0IHdoZW4gd2Ugb3V0cHV0IHRyYW5zbGF0aW9uXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbWV0YS5uYW1lO1xuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2V4cGFuc2lvbl0sIG1ldGEpO1xuICAgICAgICAgICAgY29uc3QgaWN1ID0gaWN1RnJvbUkxOG5NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgaWN1Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRNZXNzYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxzbyB1cGRhdGUgdGhlIHBsYWNlaG9sZGVyVG9NZXNzYWdlIG1hcCB3aXRoIHRoaXMgbmV3IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBjdXJyZW50TWVzc2FnZS5wbGFjZWhvbGRlclRvTWVzc2FnZVtuYW1lXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJQ1UgaXMgYSB0b3AgbGV2ZWwgbWVzc2FnZSwgdHJ5IHRvIHVzZSBtZXRhZGF0YSBmcm9tIGNvbnRhaW5lciBlbGVtZW50IGlmIHByb3ZpZGVkIHZpYVxuICAgICAgICAgICAgLy8gYGNvbnRleHRgIGFyZ3VtZW50LiBOb3RlOiBjb250ZXh0IG1heSBub3QgYmUgYXZhaWxhYmxlIGZvciBzdGFuZGFsb25lIElDVXMgKHdpdGhvdXRcbiAgICAgICAgICAgIC8vIHdyYXBwaW5nIGVsZW1lbnQpLCBzbyBmYWxsYmFjayB0byBJQ1UgbWV0YWRhdGEgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgbWVzc2FnZSA9IHRoaXMuX2dlbmVyYXRlSTE4bk1lc3NhZ2UoW2V4cGFuc2lvbl0sIGN1cnJlbnRNZXNzYWdlIHx8IG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGFuc2lvbi5pMThuID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvbjtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCkge1xuICAgICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGV4cGFuc2lvbkNhc2UpIHtcbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvbkNhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBnZW5lcmFsIGZvcm0gYG1ldGFgIHBhc3NlZCBpbnRvIGV4dHJhY3QgdGhlIGV4cGxpY2l0IG1ldGFkYXRhIG5lZWRlZCB0byBjcmVhdGUgYVxuICAgICAqIGBNZXNzYWdlYC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0aHJlZSBwb3NzaWJpbGl0aWVzIGZvciB0aGUgYG1ldGFgIHZhcmlhYmxlXG4gICAgICogMSkgYSBzdHJpbmcgZnJvbSBhbiBgaTE4bmAgdGVtcGxhdGUgYXR0cmlidXRlOiBwYXJzZSBpdCB0byBleHRyYWN0IHRoZSBtZXRhZGF0YSB2YWx1ZXMuXG4gICAgICogMikgYSBgTWVzc2FnZWAgZnJvbSBhIHByZXZpb3VzIHByb2Nlc3NpbmcgcGFzczogcmV1c2UgdGhlIG1ldGFkYXRhIHZhbHVlcyBpbiB0aGUgbWVzc2FnZS5cbiAgICAgKiA0KSBvdGhlcjogaWdub3JlIHRoaXMgYW5kIGp1c3QgcHJvY2VzcyB0aGUgbWVzc2FnZSBtZXRhZGF0YSBhcyBub3JtYWxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhIHRoZSBidWNrZXQgdGhhdCBob2xkcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHRoZSBwYXJzZWQgbWV0YWRhdGEuXG4gICAgICovXG4gICAgX3BhcnNlTWV0YWRhdGEobWV0YSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnID8gcGFyc2VJMThuTWV0YShtZXRhKSA6XG4gICAgICAgICAgICBtZXRhIGluc3RhbmNlb2YgTWVzc2FnZSA/IG1ldGEgOlxuICAgICAgICAgICAgICAgIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSAob3IgcmVzdG9yZSkgbWVzc2FnZSBpZCBpZiBub3Qgc3BlY2lmaWVkIGFscmVhZHkuXG4gICAgICovXG4gICAgX3NldE1lc3NhZ2VJZChtZXNzYWdlLCBtZXRhKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICAgICAgbWVzc2FnZS5pZCA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlICYmIG1ldGEuaWQgfHwgZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGBtZXNzYWdlYCB3aXRoIGEgYGxlZ2FjeUlkYCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSB3aG9zZSBsZWdhY3kgaWQgc2hvdWxkIGJlIHNldFxuICAgICAqIEBwYXJhbSBtZXRhIGluZm9ybWF0aW9uIGFib3V0IHRoZSBtZXNzYWdlIGJlaW5nIHByb2Nlc3NlZFxuICAgICAqL1xuICAgIF9zZXRMZWdhY3lJZHMobWVzc2FnZSwgbWV0YSkge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVJMThuTGVnYWN5TWVzc2FnZUlkRm9ybWF0KSB7XG4gICAgICAgICAgICBtZXNzYWdlLmxlZ2FjeUlkcyA9IFtjb21wdXRlRGlnZXN0KG1lc3NhZ2UpLCBjb21wdXRlRGVjaW1hbERpZ2VzdChtZXNzYWdlKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1ldGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9jY3VycyBpZiB3ZSBhcmUgZG9pbmcgdGhlIDJuZCBwYXNzIGFmdGVyIHdoaXRlc3BhY2UgcmVtb3ZhbCAoc2VlIGBwYXJzZVRlbXBsYXRlKClgIGluXG4gICAgICAgICAgICAvLyBgcGFja2FnZXMvY29tcGlsZXIvc3JjL3JlbmRlcjMvdmlldy90ZW1wbGF0ZS50c2ApLlxuICAgICAgICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIHdhbnQgdG8gcmV1c2UgdGhlIGxlZ2FjeSBtZXNzYWdlIGdlbmVyYXRlZCBpbiB0aGUgMXN0IHBhc3MgKHNlZVxuICAgICAgICAgICAgLy8gYHNldEkxOG5SZWZzKClgKS5cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzTWVzc2FnZSA9IG1ldGEgaW5zdGFuY2VvZiBNZXNzYWdlID8gbWV0YSA6XG4gICAgICAgICAgICAgICAgbWV0YSBpbnN0YW5jZW9mIEljdVBsYWNlaG9sZGVyID8gbWV0YS5wcmV2aW91c01lc3NhZ2UgOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtZXNzYWdlLmxlZ2FjeUlkcyA9IHByZXZpb3VzTWVzc2FnZSA/IHByZXZpb3VzTWVzc2FnZS5sZWdhY3lJZHMgOiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVwb3J0RXJyb3Iobm9kZSwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9XG59XG4vKiogSTE4biBzZXBhcmF0b3JzIGZvciBtZXRhZGF0YSAqKi9cbmNvbnN0IEkxOE5fTUVBTklOR19TRVBBUkFUT1IgPSAnfCc7XG5jb25zdCBJMThOX0lEX1NFUEFSQVRPUiA9ICdAQCc7XG4vKipcbiAqIFBhcnNlcyBpMThuIG1ldGFzIGxpa2U6XG4gKiAgLSBcIkBAaWRcIixcbiAqICAtIFwiZGVzY3JpcHRpb25bQEBpZF1cIixcbiAqICAtIFwibWVhbmluZ3xkZXNjcmlwdGlvbltAQGlkXVwiXG4gKiBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBwYXJzZWQgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSBtZXRhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaTE4biBtZXRhXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBpZCwgbWVhbmluZyBhbmQgZGVzY3JpcHRpb24gZmllbGRzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSTE4bk1ldGEobWV0YSA9ICcnKSB7XG4gICAgbGV0IGN1c3RvbUlkO1xuICAgIGxldCBtZWFuaW5nO1xuICAgIGxldCBkZXNjcmlwdGlvbjtcbiAgICBtZXRhID0gbWV0YS50cmltKCk7XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgY29uc3QgaWRJbmRleCA9IG1ldGEuaW5kZXhPZihJMThOX0lEX1NFUEFSQVRPUik7XG4gICAgICAgIGNvbnN0IGRlc2NJbmRleCA9IG1ldGEuaW5kZXhPZihJMThOX01FQU5JTkdfU0VQQVJBVE9SKTtcbiAgICAgICAgbGV0IG1lYW5pbmdBbmREZXNjO1xuICAgICAgICBbbWVhbmluZ0FuZERlc2MsIGN1c3RvbUlkXSA9XG4gICAgICAgICAgICAoaWRJbmRleCA+IC0xKSA/IFttZXRhLnNsaWNlKDAsIGlkSW5kZXgpLCBtZXRhLnNsaWNlKGlkSW5kZXggKyAyKV0gOiBbbWV0YSwgJyddO1xuICAgICAgICBbbWVhbmluZywgZGVzY3JpcHRpb25dID0gKGRlc2NJbmRleCA+IC0xKSA/XG4gICAgICAgICAgICBbbWVhbmluZ0FuZERlc2Muc2xpY2UoMCwgZGVzY0luZGV4KSwgbWVhbmluZ0FuZERlc2Muc2xpY2UoZGVzY0luZGV4ICsgMSldIDpcbiAgICAgICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdO1xuICAgIH1cbiAgICByZXR1cm4geyBjdXN0b21JZCwgbWVhbmluZywgZGVzY3JpcHRpb24gfTtcbn1cbi8vIENvbnZlcnRzIGkxOG4gbWV0YSBpbmZvcm1hdGlvbiBmb3IgYSBtZXNzYWdlIChpZCwgZGVzY3JpcHRpb24sIG1lYW5pbmcpXG4vLyB0byBhIEpzRG9jIHN0YXRlbWVudCBmb3JtYXR0ZWQgYXMgZXhwZWN0ZWQgYnkgdGhlIENsb3N1cmUgY29tcGlsZXIuXG5mdW5jdGlvbiBpMThuTWV0YVRvSlNEb2MobWV0YSkge1xuICAgIGNvbnN0IHRhZ3MgPSBbXTtcbiAgICBpZiAobWV0YS5kZXNjcmlwdGlvbikge1xuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcImRlc2NcIiAvKiBvLkpTRG9jVGFnTmFtZS5EZXNjICovLCB0ZXh0OiBtZXRhLmRlc2NyaXB0aW9uIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VwcHJlc3MgdGhlIEpTQ29tcGlsZXIgd2FybmluZyB0aGF0IGEgYEBkZXNjYCB3YXMgbm90IGdpdmVuIGZvciB0aGlzIG1lc3NhZ2UuXG4gICAgICAgIHRhZ3MucHVzaCh7IHRhZ05hbWU6IFwic3VwcHJlc3NcIiAvKiBvLkpTRG9jVGFnTmFtZS5TdXBwcmVzcyAqLywgdGV4dDogJ3ttc2dEZXNjcmlwdGlvbnN9JyB9KTtcbiAgICB9XG4gICAgaWYgKG1ldGEubWVhbmluZykge1xuICAgICAgICB0YWdzLnB1c2goeyB0YWdOYW1lOiBcIm1lYW5pbmdcIiAvKiBvLkpTRG9jVGFnTmFtZS5NZWFuaW5nICovLCB0ZXh0OiBtZXRhLm1lYW5pbmcgfSk7XG4gICAgfVxuICAgIHJldHVybiBqc0RvY0NvbW1lbnQodGFncyk7XG59XG5cbi8qKiBDbG9zdXJlIHVzZXMgYGdvb2cuZ2V0TXNnKG1lc3NhZ2UpYCB0byBsb29rdXAgdHJhbnNsYXRpb25zICovXG5jb25zdCBHT09HX0dFVF9NU0cgPSAnZ29vZy5nZXRNc2cnO1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBgZ29vZy5nZXRNc2coKWAgc3RhdGVtZW50IGFuZCByZWFzc2lnbm1lbnQuIFRoZSB0ZW1wbGF0ZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IGkxOG4+U2VudCBmcm9tIHt7IHNlbmRlciB9fSB0byA8c3BhbiBjbGFzcz1cInJlY2VpdmVyXCI+e3sgcmVjZWl2ZXIgfX08L3NwYW4+PC9kaXY+XG4gKiBgYGBcbiAqXG4gKiBHZW5lcmF0ZXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgTVNHX0ZPTyA9IGdvb2cuZ2V0TXNnKFxuICogICAvLyBNZXNzYWdlIHRlbXBsYXRlLlxuICogICAnU2VudCBmcm9tIHskaW50ZXJwb2xhdGlvbn0gdG8geyRzdGFydFRhZ1NwYW59eyRpbnRlcnBvbGF0aW9uXzF9eyRjbG9zZVRhZ1NwYW59LicsXG4gKiAgIC8vIFBsYWNlaG9sZGVyIHZhbHVlcywgc2V0IHRvIG1hZ2ljIHN0cmluZ3Mgd2hpY2ggZ2V0IHJlcGxhY2VkIGJ5IHRoZSBBbmd1bGFyIHJ1bnRpbWUuXG4gKiAgIHtcbiAqICAgICAnaW50ZXJwb2xhdGlvbic6ICdcXHVGRkZEMFxcdUZGRkQnLFxuICogICAgICdzdGFydFRhZ1NwYW4nOiAnXFx1RkZGRDFcXHVGRkZEJyxcbiAqICAgICAnaW50ZXJwb2xhdGlvbl8xJzogJ1xcdUZGRkQyXFx1RkZGRCcsXG4gKiAgICAgJ2Nsb3NlVGFnU3Bhbic6ICdcXHVGRkZEM1xcdUZGRkQnLFxuICogICB9LFxuICogICAvLyBPcHRpb25zIGJhZy5cbiAqICAge1xuICogICAgIC8vIE1hcHMgZWFjaCBwbGFjZWhvbGRlciB0byB0aGUgb3JpZ2luYWwgQW5ndWxhciBzb3VyY2UgY29kZSB3aGljaCBnZW5lcmF0ZXMgaXQncyB2YWx1ZS5cbiAqICAgICBvcmlnaW5hbF9jb2RlOiB7XG4gKiAgICAgICAnaW50ZXJwb2xhdGlvbic6ICd7eyBzZW5kZXIgfX0nLFxuICogICAgICAgJ3N0YXJ0VGFnU3Bhbic6ICc8c3BhbiBjbGFzcz1cInJlY2VpdmVyXCI+JyxcbiAqICAgICAgICdpbnRlcnBvbGF0aW9uXzEnOiAne3sgcmVjZWl2ZXIgfX0nLFxuICogICAgICAgJ2Nsb3NlVGFnU3Bhbic6ICc8L3NwYW4+JyxcbiAqICAgICB9LFxuICogICB9LFxuICogKTtcbiAqIGNvbnN0IEkxOE5fMCA9IE1TR19GT087XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlR29vZ2xlR2V0TXNnU3RhdGVtZW50cyh2YXJpYWJsZSQxLCBtZXNzYWdlLCBjbG9zdXJlVmFyLCBwbGFjZWhvbGRlclZhbHVlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VTdHJpbmcgPSBzZXJpYWxpemVJMThuTWVzc2FnZUZvckdldE1zZyhtZXNzYWdlKTtcbiAgICBjb25zdCBhcmdzID0gW2xpdGVyYWwobWVzc2FnZVN0cmluZyldO1xuICAgIGlmIChPYmplY3Qua2V5cyhwbGFjZWhvbGRlclZhbHVlcykubGVuZ3RoKSB7XG4gICAgICAgIC8vIE1lc3NhZ2UgdGVtcGxhdGUgcGFyYW1ldGVycyBjb250YWluaW5nIHRoZSBtYWdpYyBzdHJpbmdzIHJlcGxhY2VkIGJ5IHRoZSBBbmd1bGFyIHJ1bnRpbWUgd2l0aFxuICAgICAgICAvLyByZWFsIGRhdGEsIGUuZy4gYHsnaW50ZXJwb2xhdGlvbic6ICdcXHVGRkZEMFxcdUZGRkQnfWAuXG4gICAgICAgIGFyZ3MucHVzaChtYXBMaXRlcmFsKGZvcm1hdEkxOG5QbGFjZWhvbGRlck5hbWVzSW5NYXAocGxhY2Vob2xkZXJWYWx1ZXMsIHRydWUgLyogdXNlQ2FtZWxDYXNlICovKSwgdHJ1ZSAvKiBxdW90ZWQgKi8pKTtcbiAgICAgICAgLy8gTWVzc2FnZSBvcHRpb25zIG9iamVjdCwgd2hpY2ggY29udGFpbnMgb3JpZ2luYWwgc291cmNlIGNvZGUgZm9yIHBsYWNlaG9sZGVycyAoYXMgdGhleSBhcmVcbiAgICAgICAgLy8gcHJlc2VudCBpbiBhIHRlbXBsYXRlLCBlLmcuXG4gICAgICAgIC8vIGB7b3JpZ2luYWxfY29kZTogeydpbnRlcnBvbGF0aW9uJzogJ3t7IG5hbWUgfX0nLCAnc3RhcnRUYWdTcGFuJzogJzxzcGFuPid9fWAuXG4gICAgICAgIGFyZ3MucHVzaChtYXBMaXRlcmFsKHtcbiAgICAgICAgICAgIG9yaWdpbmFsX2NvZGU6IGxpdGVyYWxNYXAoT2JqZWN0LmtleXMocGxhY2Vob2xkZXJWYWx1ZXMpXG4gICAgICAgICAgICAgICAgLm1hcCgocGFyYW0pID0+ICh7XG4gICAgICAgICAgICAgICAga2V5OiBmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lKHBhcmFtKSxcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1lc3NhZ2UucGxhY2Vob2xkZXJzW3BhcmFtXSA/XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBzb3VyY2Ugc3BhbiBmb3IgdHlwaWNhbCBwbGFjZWhvbGRlciBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwobWVzc2FnZS5wbGFjZWhvbGRlcnNbcGFyYW1dLnNvdXJjZVNwYW4udG9TdHJpbmcoKSkgOlxuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgbXVzdCBiZSBhbiBJQ1UgZXhwcmVzc2lvbiwgZ2V0IGl0J3Mgc291cmNlIHNwYW4uXG4gICAgICAgICAgICAgICAgICAgIGxpdGVyYWwobWVzc2FnZS5wbGFjZWhvbGRlclRvTWVzc2FnZVtwYXJhbV1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5ub2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuc291cmNlU3Bhbi50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpKSxcbiAgICAgICAgICAgIH0pKSksXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gLyoqXG4gICAgLy8gICogQGRlc2MgZGVzY3JpcHRpb24gb2YgbWVzc2FnZVxuICAgIC8vICAqIEBtZWFuaW5nIG1lYW5pbmcgb2YgbWVzc2FnZVxuICAgIC8vICAqL1xuICAgIC8vIGNvbnN0IE1TR18uLi4gPSBnb29nLmdldE1zZyguLik7XG4gICAgLy8gSTE4Tl9YID0gTVNHXy4uLjtcbiAgICBjb25zdCBnb29nR2V0TXNnU3RtdCA9IGNsb3N1cmVWYXIuc2V0KHZhcmlhYmxlKEdPT0dfR0VUX01TRykuY2FsbEZuKGFyZ3MpKS50b0NvbnN0RGVjbCgpO1xuICAgIGdvb2dHZXRNc2dTdG10LmFkZExlYWRpbmdDb21tZW50KGkxOG5NZXRhVG9KU0RvYyhtZXNzYWdlKSk7XG4gICAgY29uc3QgaTE4bkFzc2lnbm1lbnRTdG10ID0gbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGUkMS5zZXQoY2xvc3VyZVZhcikpO1xuICAgIHJldHVybiBbZ29vZ0dldE1zZ1N0bXQsIGkxOG5Bc3NpZ25tZW50U3RtdF07XG59XG4vKipcbiAqIFRoaXMgdmlzaXRvciB3YWxrcyBvdmVyIGkxOG4gdHJlZSBhbmQgZ2VuZXJhdGVzIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24sIGluY2x1ZGluZyBJQ1VzIGFuZFxuICogcGxhY2Vob2xkZXJzIGluIGB7JHBsYWNlaG9sZGVyfWAgKGZvciBwbGFpbiBtZXNzYWdlcykgb3IgYHtQTEFDRUhPTERFUn1gIChpbnNpZGUgSUNVcykgZm9ybWF0LlxuICovXG5jbGFzcyBHZXRNc2dTZXJpYWxpemVyVmlzaXRvciB7XG4gICAgZm9ybWF0UGgodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGB7JCR7Zm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZSh2YWx1ZSl9fWA7XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnZhbHVlO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJycpO1xuICAgIH1cbiAgICB2aXNpdEljdShpY3UpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUljdU5vZGUoaWN1KTtcbiAgICB9XG4gICAgdmlzaXRUYWdQbGFjZWhvbGRlcihwaCkge1xuICAgICAgICByZXR1cm4gcGguaXNWb2lkID9cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGgocGguc3RhcnROYW1lKSA6XG4gICAgICAgICAgICBgJHt0aGlzLmZvcm1hdFBoKHBoLnN0YXJ0TmFtZSl9JHtwaC5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpLmpvaW4oJycpfSR7dGhpcy5mb3JtYXRQaChwaC5jbG9zZU5hbWUpfWA7XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UGgocGgubmFtZSk7XG4gICAgfVxufVxuY29uc3Qgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgR2V0TXNnU2VyaWFsaXplclZpc2l0b3IoKTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUkxOG5NZXNzYWdlRm9yR2V0TXNnKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5ub2Rlcy5tYXAobm9kZSA9PiBub2RlLnZpc2l0KHNlcmlhbGl6ZXJWaXNpdG9yLCBudWxsKSkuam9pbignJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsaXplU3RhdGVtZW50cyh2YXJpYWJsZSwgbWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBtZXNzYWdlUGFydHMsIHBsYWNlSG9sZGVycyB9ID0gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JMb2NhbGl6ZShtZXNzYWdlKTtcbiAgICBjb25zdCBzb3VyY2VTcGFuID0gZ2V0U291cmNlU3BhbihtZXNzYWdlKTtcbiAgICBjb25zdCBleHByZXNzaW9ucyA9IHBsYWNlSG9sZGVycy5tYXAocGggPT4gcGFyYW1zW3BoLnRleHRdKTtcbiAgICBjb25zdCBsb2NhbGl6ZWRTdHJpbmckMSA9IGxvY2FsaXplZFN0cmluZyhtZXNzYWdlLCBtZXNzYWdlUGFydHMsIHBsYWNlSG9sZGVycywgZXhwcmVzc2lvbnMsIHNvdXJjZVNwYW4pO1xuICAgIGNvbnN0IHZhcmlhYmxlSW5pdGlhbGl6YXRpb24gPSB2YXJpYWJsZS5zZXQobG9jYWxpemVkU3RyaW5nJDEpO1xuICAgIHJldHVybiBbbmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGVJbml0aWFsaXphdGlvbildO1xufVxuLyoqXG4gKiBUaGlzIHZpc2l0b3Igd2Fsa3Mgb3ZlciBhbiBpMThuIHRyZWUsIGNhcHR1cmluZyBsaXRlcmFsIHN0cmluZ3MgYW5kIHBsYWNlaG9sZGVycy5cbiAqXG4gKiBUaGUgcmVzdWx0IGNhbiBiZSB1c2VkIGZvciBnZW5lcmF0aW5nIHRoZSBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKi9cbmNsYXNzIExvY2FsaXplU2VyaWFsaXplclZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHBsYWNlaG9sZGVyVG9NZXNzYWdlLCBwaWVjZXMpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclRvTWVzc2FnZSA9IHBsYWNlaG9sZGVyVG9NZXNzYWdlO1xuICAgICAgICB0aGlzLnBpZWNlcyA9IHBpZWNlcztcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMucGllY2VzW3RoaXMucGllY2VzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgTGl0ZXJhbFBpZWNlKSB7XG4gICAgICAgICAgICAvLyBUd28gbGl0ZXJhbCBwaWVjZXMgaW4gYSByb3cgbWVhbnMgdGhhdCB0aGVyZSB3YXMgc29tZSBjb21tZW50IG5vZGUgaW4tYmV0d2Vlbi5cbiAgICAgICAgICAgIHRoaXMucGllY2VzW3RoaXMucGllY2VzLmxlbmd0aCAtIDFdLnRleHQgKz0gdGV4dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVNwYW4gPSBuZXcgUGFyc2VTb3VyY2VTcGFuKHRleHQuc291cmNlU3Bhbi5mdWxsU3RhcnQsIHRleHQuc291cmNlU3Bhbi5lbmQsIHRleHQuc291cmNlU3Bhbi5mdWxsU3RhcnQsIHRleHQuc291cmNlU3Bhbi5kZXRhaWxzKTtcbiAgICAgICAgICAgIHRoaXMucGllY2VzLnB1c2gobmV3IExpdGVyYWxQaWVjZSh0ZXh0LnZhbHVlLCBzb3VyY2VTcGFuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lci5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnZpc2l0KHRoaXMpKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1KSB7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2gobmV3IExpdGVyYWxQaWVjZShzZXJpYWxpemVJY3VOb2RlKGljdSksIGljdS5zb3VyY2VTcGFuKSk7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgdGhpcy5waWVjZXMucHVzaCh0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyUGllY2UocGguc3RhcnROYW1lLCBwaC5zdGFydFNvdXJjZVNwYW4gPz8gcGguc291cmNlU3BhbikpO1xuICAgICAgICBpZiAoIXBoLmlzVm9pZCkge1xuICAgICAgICAgICAgcGguY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC52aXNpdCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnBpZWNlcy5wdXNoKHRoaXMuY3JlYXRlUGxhY2Vob2xkZXJQaWVjZShwaC5jbG9zZU5hbWUsIHBoLmVuZFNvdXJjZVNwYW4gPz8gcGguc291cmNlU3BhbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgpIHtcbiAgICAgICAgdGhpcy5waWVjZXMucHVzaCh0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyUGllY2UocGgubmFtZSwgcGguc291cmNlU3BhbikpO1xuICAgIH1cbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoKSB7XG4gICAgICAgIHRoaXMucGllY2VzLnB1c2godGhpcy5jcmVhdGVQbGFjZWhvbGRlclBpZWNlKHBoLm5hbWUsIHBoLnNvdXJjZVNwYW4sIHRoaXMucGxhY2Vob2xkZXJUb01lc3NhZ2VbcGgubmFtZV0pKTtcbiAgICB9XG4gICAgY3JlYXRlUGxhY2Vob2xkZXJQaWVjZShuYW1lLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBsYWNlaG9sZGVyUGllY2UoZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZShuYW1lLCAvKiB1c2VDYW1lbENhc2UgKi8gZmFsc2UpLCBzb3VyY2VTcGFuLCBhc3NvY2lhdGVkTWVzc2FnZSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXJpYWxpemUgYW4gaTE4biBtZXNzYWdlIGludG8gdHdvIGFycmF5czogbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKlxuICogVGhlc2UgYXJyYXlzIHdpbGwgYmUgdXNlZCB0byBnZW5lcmF0ZSBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gYmUgc2VyaWFsaXplZC5cbiAqIEByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtZXNzYWdlUGFydHMgYW5kIHBsYWNlaG9sZGVycy5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplSTE4bk1lc3NhZ2VGb3JMb2NhbGl6ZShtZXNzYWdlKSB7XG4gICAgY29uc3QgcGllY2VzID0gW107XG4gICAgY29uc3Qgc2VyaWFsaXplclZpc2l0b3IgPSBuZXcgTG9jYWxpemVTZXJpYWxpemVyVmlzaXRvcihtZXNzYWdlLnBsYWNlaG9sZGVyVG9NZXNzYWdlLCBwaWVjZXMpO1xuICAgIG1lc3NhZ2Uubm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQoc2VyaWFsaXplclZpc2l0b3IpKTtcbiAgICByZXR1cm4gcHJvY2Vzc01lc3NhZ2VQaWVjZXMocGllY2VzKTtcbn1cbmZ1bmN0aW9uIGdldFNvdXJjZVNwYW4obWVzc2FnZSkge1xuICAgIGNvbnN0IHN0YXJ0Tm9kZSA9IG1lc3NhZ2Uubm9kZXNbMF07XG4gICAgY29uc3QgZW5kTm9kZSA9IG1lc3NhZ2Uubm9kZXNbbWVzc2FnZS5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydE5vZGUuc291cmNlU3Bhbi5mdWxsU3RhcnQsIGVuZE5vZGUuc291cmNlU3Bhbi5lbmQsIHN0YXJ0Tm9kZS5zb3VyY2VTcGFuLmZ1bGxTdGFydCwgc3RhcnROb2RlLnNvdXJjZVNwYW4uZGV0YWlscyk7XG59XG4vKipcbiAqIENvbnZlcnQgdGhlIGxpc3Qgb2Ygc2VyaWFsaXplZCBNZXNzYWdlUGllY2VzIGludG8gdHdvIGFycmF5cy5cbiAqXG4gKiBPbmUgY29udGFpbnMgdGhlIGxpdGVyYWwgc3RyaW5nIHBpZWNlcyBhbmQgdGhlIG90aGVyIHRoZSBwbGFjZWhvbGRlcnMgdGhhdCB3aWxsIGJlIHJlcGxhY2VkIGJ5XG4gKiBleHByZXNzaW9ucyB3aGVuIHJlbmRlcmluZyBgJGxvY2FsaXplYCB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbHMuXG4gKlxuICogQHBhcmFtIHBpZWNlcyBUaGUgcGllY2VzIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWVzc2FnZVBhcnRzIGFuZCBwbGFjZWhvbGRlcnMuXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlUGllY2VzKHBpZWNlcykge1xuICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xuICAgIGNvbnN0IHBsYWNlSG9sZGVycyA9IFtdO1xuICAgIGlmIChwaWVjZXNbMF0gaW5zdGFuY2VvZiBQbGFjZWhvbGRlclBpZWNlKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhbiBpbml0aWFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbMF0uc291cmNlU3Bhbi5zdGFydCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGllY2VzW2ldO1xuICAgICAgICBpZiAocGFydCBpbnN0YW5jZW9mIExpdGVyYWxQaWVjZSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbGFjZUhvbGRlcnMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIGlmIChwaWVjZXNbaSAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgdHdvIHBsYWNlaG9sZGVycyBpbiBhIHJvdywgc28gd2UgbmVlZCB0byBhZGQgYW4gZW1wdHkgbWVzc2FnZSBwYXJ0LlxuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNyZWF0ZUVtcHR5TWVzc2FnZVBhcnQocGllY2VzW2kgLSAxXS5zb3VyY2VTcGFuLmVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgUGxhY2Vob2xkZXJQaWVjZSkge1xuICAgICAgICAvLyBUaGUgbGFzdCBwaWVjZSB3YXMgYSBwbGFjZWhvbGRlciBzbyB3ZSBuZWVkIHRvIGFkZCBhIGZpbmFsIGVtcHR5IG1lc3NhZ2UgcGFydC5cbiAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY3JlYXRlRW1wdHlNZXNzYWdlUGFydChwaWVjZXNbcGllY2VzLmxlbmd0aCAtIDFdLnNvdXJjZVNwYW4uZW5kKSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2VQYXJ0cywgcGxhY2VIb2xkZXJzIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eU1lc3NhZ2VQYXJ0KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBMaXRlcmFsUGllY2UoJycsIG5ldyBQYXJzZVNvdXJjZVNwYW4obG9jYXRpb24sIGxvY2F0aW9uKSk7XG59XG5cbi8vIFNlbGVjdG9yIGF0dHJpYnV0ZSBuYW1lIG9mIGA8bmctY29udGVudD5gXG5jb25zdCBOR19DT05URU5UX1NFTEVDVF9BVFRSID0gJ3NlbGVjdCc7XG4vLyBBdHRyaWJ1dGUgbmFtZSBvZiBgbmdQcm9qZWN0QXNgLlxuY29uc3QgTkdfUFJPSkVDVF9BU19BVFRSX05BTUUgPSAnbmdQcm9qZWN0QXMnO1xuLy8gR2xvYmFsIHN5bWJvbHMgYXZhaWxhYmxlIG9ubHkgaW5zaWRlIGV2ZW50IGJpbmRpbmdzLlxuY29uc3QgRVZFTlRfQklORElOR19TQ09QRV9HTE9CQUxTID0gbmV3IFNldChbJyRldmVudCddKTtcbi8vIExpc3Qgb2Ygc3VwcG9ydGVkIGdsb2JhbCB0YXJnZXRzIGZvciBldmVudCBsaXN0ZW5lcnNcbmNvbnN0IEdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTID0gbmV3IE1hcChbWyd3aW5kb3cnLCBJZGVudGlmaWVycy5yZXNvbHZlV2luZG93XSwgWydkb2N1bWVudCcsIElkZW50aWZpZXJzLnJlc29sdmVEb2N1bWVudF0sIFsnYm9keScsIElkZW50aWZpZXJzLnJlc29sdmVCb2R5XV0pO1xuY29uc3QgTEVBRElOR19UUklWSUFfQ0hBUlMgPSBbJyAnLCAnXFxuJywgJ1xccicsICdcXHQnXTtcbi8vICBpZiAocmYgJiBmbGFncykgeyAuLiB9XG5mdW5jdGlvbiByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoZmxhZ3MsIHN0YXRlbWVudHMpIHtcbiAgICByZXR1cm4gaWZTdG10KHZhcmlhYmxlKFJFTkRFUl9GTEFHUykuYml0d2lzZUFuZChsaXRlcmFsKGZsYWdzKSwgbnVsbCwgZmFsc2UpLCBzdGF0ZW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVFdmVudExpc3RlbmVyUGFyYW1ldGVycyhldmVudEFzdCwgaGFuZGxlck5hbWUgPSBudWxsLCBzY29wZSA9IG51bGwpIHtcbiAgICBjb25zdCB7IHR5cGUsIG5hbWUsIHRhcmdldCwgcGhhc2UsIGhhbmRsZXIgfSA9IGV2ZW50QXN0O1xuICAgIGlmICh0YXJnZXQgJiYgIUdMT0JBTF9UQVJHRVRfUkVTT0xWRVJTLmhhcyh0YXJnZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBnbG9iYWwgdGFyZ2V0ICcke3RhcmdldH0nIGRlZmluZWQgZm9yICcke25hbWV9JyBldmVudC5cbiAgICAgICAgU3VwcG9ydGVkIGxpc3Qgb2YgZ2xvYmFsIHRhcmdldHM6ICR7QXJyYXkuZnJvbShHTE9CQUxfVEFSR0VUX1JFU09MVkVSUy5rZXlzKCkpfS5gKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnRBcmd1bWVudE5hbWUgPSAnJGV2ZW50JztcbiAgICBjb25zdCBpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgaW1wbGljaXRSZWNlaXZlckV4cHIgPSAoc2NvcGUgPT09IG51bGwgfHwgc2NvcGUuYmluZGluZ0xldmVsID09PSAwKSA/XG4gICAgICAgIHZhcmlhYmxlKENPTlRFWFRfTkFNRSkgOlxuICAgICAgICBzY29wZS5nZXRPckNyZWF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgY29uc3QgYmluZGluZ1N0YXRlbWVudHMgPSBjb252ZXJ0QWN0aW9uQmluZGluZyhzY29wZSwgaW1wbGljaXRSZWNlaXZlckV4cHIsIGhhbmRsZXIsICdiJywgZXZlbnRBc3QuaGFuZGxlclNwYW4sIGltcGxpY2l0UmVjZWl2ZXJBY2Nlc3NlcywgRVZFTlRfQklORElOR19TQ09QRV9HTE9CQUxTKTtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdmFyaWFibGVEZWNsYXJhdGlvbnMgPSBzY29wZT8udmFyaWFibGVEZWNsYXJhdGlvbnMoKTtcbiAgICBjb25zdCByZXN0b3JlVmlld1N0YXRlbWVudCA9IHNjb3BlPy5yZXN0b3JlVmlld1N0YXRlbWVudCgpO1xuICAgIGlmICh2YXJpYWJsZURlY2xhcmF0aW9ucykge1xuICAgICAgICAvLyBgdmFyaWFibGVEZWNsYXJhdGlvbnNgIG5lZWRzIHRvIHJ1biBmaXJzdCwgYmVjYXVzZVxuICAgICAgICAvLyBgcmVzdG9yZVZpZXdTdGF0ZW1lbnRgIGRlcGVuZHMgb24gdGhlIHJlc3VsdC5cbiAgICAgICAgc3RhdGVtZW50cy5wdXNoKC4uLnZhcmlhYmxlRGVjbGFyYXRpb25zKTtcbiAgICB9XG4gICAgc3RhdGVtZW50cy5wdXNoKC4uLmJpbmRpbmdTdGF0ZW1lbnRzKTtcbiAgICBpZiAocmVzdG9yZVZpZXdTdGF0ZW1lbnQpIHtcbiAgICAgICAgc3RhdGVtZW50cy51bnNoaWZ0KHJlc3RvcmVWaWV3U3RhdGVtZW50KTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIGByZXN0b3JlVmlld2AgY2FsbCwgd2UgbmVlZCB0byByZXNldCB0aGUgdmlldyBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lclxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCBhIGxlYWsuIElmIHRoZXJlJ3MgYSBgcmV0dXJuYCBzdGF0ZW1lbnQgYWxyZWFkeSwgd2Ugd3JhcCBpdCBpbiB0aGVcbiAgICAgICAgLy8gY2FsbCwgZS5nLiBgcmV0dXJuIHJlc2V0VmlldyhjdHguZm9vKCkpYC4gT3RoZXJ3aXNlIHdlIGFkZCB0aGUgY2FsbCBhcyB0aGUgbGFzdCBzdGF0ZW1lbnQuXG4gICAgICAgIGNvbnN0IGxhc3RTdGF0ZW1lbnQgPSBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0U3RhdGVtZW50IGluc3RhbmNlb2YgUmV0dXJuU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzW3N0YXRlbWVudHMubGVuZ3RoIC0gMV0gPSBuZXcgUmV0dXJuU3RhdGVtZW50KGludm9rZUluc3RydWN0aW9uKGxhc3RTdGF0ZW1lbnQudmFsdWUuc291cmNlU3BhbiwgSWRlbnRpZmllcnMucmVzZXRWaWV3LCBbbGFzdFN0YXRlbWVudC52YWx1ZV0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuZXcgRXhwcmVzc2lvblN0YXRlbWVudChpbnZva2VJbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycy5yZXNldFZpZXcsIFtdKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHR5cGUgPT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLyA/IHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lck5hbWUobmFtZSwgcGhhc2UpIDogbmFtZTtcbiAgICBjb25zdCBmbk5hbWUgPSBoYW5kbGVyTmFtZSAmJiBzYW5pdGl6ZUlkZW50aWZpZXIoaGFuZGxlck5hbWUpO1xuICAgIGNvbnN0IGZuQXJncyA9IFtdO1xuICAgIGlmIChpbXBsaWNpdFJlY2VpdmVyQWNjZXNzZXMuaGFzKGV2ZW50QXJndW1lbnROYW1lKSkge1xuICAgICAgICBmbkFyZ3MucHVzaChuZXcgRm5QYXJhbShldmVudEFyZ3VtZW50TmFtZSwgRFlOQU1JQ19UWVBFKSk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJGbiA9IGZuKGZuQXJncywgc3RhdGVtZW50cywgSU5GRVJSRURfVFlQRSwgbnVsbCwgZm5OYW1lKTtcbiAgICBjb25zdCBwYXJhbXMgPSBbbGl0ZXJhbChldmVudE5hbWUpLCBoYW5kbGVyRm5dO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChmYWxzZSksIC8vIGB1c2VDYXB0dXJlYCBmbGFnLCBkZWZhdWx0cyB0byBgZmFsc2VgXG4gICAgICAgIGltcG9ydEV4cHIoR0xPQkFMX1RBUkdFVF9SRVNPTFZFUlMuZ2V0KHRhcmdldCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudERlZkNvbnN0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVwYXJlU3RhdGVtZW50czogW10sXG4gICAgICAgIGNvbnN0RXhwcmVzc2lvbnM6IFtdLFxuICAgICAgICBpMThuVmFyUmVmc0NhY2hlOiBuZXcgTWFwKCksXG4gICAgfTtcbn1cbmNsYXNzIFRlbXBsYXRlRGVmaW5pdGlvbkJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0YW50UG9vbCwgcGFyZW50QmluZGluZ1Njb3BlLCBsZXZlbCA9IDAsIGNvbnRleHROYW1lLCBpMThuQ29udGV4dCwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCBfbmFtZXNwYWNlLCByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aCwgaTE4blVzZUV4dGVybmFsSWRzLCBfY29uc3RhbnRzID0gY3JlYXRlQ29tcG9uZW50RGVmQ29uc3RzKCkpIHtcbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5jb250ZXh0TmFtZSA9IGNvbnRleHROYW1lO1xuICAgICAgICB0aGlzLmkxOG5Db250ZXh0ID0gaTE4bkNvbnRleHQ7XG4gICAgICAgIHRoaXMudGVtcGxhdGVJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG4gICAgICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgICAgICB0aGlzLl9uYW1lc3BhY2UgPSBfbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLmkxOG5Vc2VFeHRlcm5hbElkcyA9IGkxOG5Vc2VFeHRlcm5hbElkcztcbiAgICAgICAgdGhpcy5fY29uc3RhbnRzID0gX2NvbnN0YW50cztcbiAgICAgICAgdGhpcy5fZGF0YUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fYmluZGluZ0NvbnRleHQgPSAwO1xuICAgICAgICB0aGlzLl9wcmVmaXhDb2RlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBnZW5lcmF0ZSBjcmVhdGlvbiBtb2RlIGluc3RydWN0aW9ucy4gV2Ugc3RvcmUgdGhlbSBoZXJlIGFzIHdlIHByb2Nlc3NcbiAgICAgICAgICogdGhlIHRlbXBsYXRlIHNvIGJpbmRpbmdzIGluIGxpc3RlbmVycyBhcmUgcmVzb2x2ZWQgb25seSBvbmNlIGFsbCBub2RlcyBoYXZlIGJlZW4gdmlzaXRlZC5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIGFsbCBsb2NhbCByZWZzIGFuZCBjb250ZXh0IHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlIGZvciBtYXRjaGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NyZWF0aW9uQ29kZUZucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gZ2VuZXJhdGUgdXBkYXRlIG1vZGUgaW5zdHJ1Y3Rpb25zLiBXZSBzdG9yZSB0aGVtIGhlcmUgYXMgd2UgcHJvY2Vzc1xuICAgICAgICAgKiB0aGUgdGVtcGxhdGUgc28gYmluZGluZ3MgYXJlIHJlc29sdmVkIG9ubHkgb25jZSBhbGwgbm9kZXMgaGF2ZSBiZWVuIHZpc2l0ZWQuIFRoaXMgZW5zdXJlc1xuICAgICAgICAgKiBhbGwgbG9jYWwgcmVmcyBhbmQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGF2YWlsYWJsZSBmb3IgbWF0Y2hpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGRhdGVDb2RlRm5zID0gW107XG4gICAgICAgIC8qKiBJbmRleCBvZiB0aGUgY3VycmVudGx5LXNlbGVjdGVkIG5vZGUuICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgIC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgZGVjbGFyYXRpb25zIGdlbmVyYXRlZCBmcm9tIHZpc2l0aW5nIHBpcGVzLCBsaXRlcmFscywgZXRjLiAqL1xuICAgICAgICB0aGlzLl90ZW1wVmFyaWFibGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBidWlsZCBuZXN0ZWQgdGVtcGxhdGVzLiBOZXN0ZWQgdGVtcGxhdGVzIG11c3Qgbm90IGJlIHZpc2l0ZWQgdW50aWxcbiAgICAgICAgICogYWZ0ZXIgdGhlIHBhcmVudCB0ZW1wbGF0ZSBoYXMgZmluaXNoZWQgdmlzaXRpbmcgYWxsIG9mIGl0cyBub2Rlcy4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gICAgICAgICAqIGxvY2FsIHJlZiBiaW5kaW5ncyBpbiBuZXN0ZWQgdGVtcGxhdGVzIGFyZSBhYmxlIHRvIGZpbmQgbG9jYWwgcmVmIHZhbHVlcyBpZiB0aGUgcmVmc1xuICAgICAgICAgKiBhcmUgZGVmaW5lZCBhZnRlciB0aGUgdGVtcGxhdGUgZGVjbGFyYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZXN0ZWRUZW1wbGF0ZUZucyA9IFtdO1xuICAgICAgICAvLyBpMThuIGNvbnRleHQgbG9jYWwgdG8gdGhpcyB0ZW1wbGF0ZVxuICAgICAgICB0aGlzLmkxOG4gPSBudWxsO1xuICAgICAgICAvLyBOdW1iZXIgb2Ygc2xvdHMgdG8gcmVzZXJ2ZSBmb3IgcHVyZUZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cyA9IDA7XG4gICAgICAgIC8vIE51bWJlciBvZiBiaW5kaW5nIHNsb3RzXG4gICAgICAgIHRoaXMuX2JpbmRpbmdTbG90cyA9IDA7XG4gICAgICAgIC8vIFByb2plY3Rpb24gc2xvdHMgZm91bmQgaW4gdGhlIHRlbXBsYXRlLiBQcm9qZWN0aW9uIHNsb3RzIGNhbiBkaXN0cmlidXRlIHByb2plY3RlZFxuICAgICAgICAvLyBub2RlcyBiYXNlZCBvbiBhIHNlbGVjdG9yLCBvciBjYW4ganVzdCB1c2UgdGhlIHdpbGRjYXJkIHNlbGVjdG9yIHRvIG1hdGNoXG4gICAgICAgIC8vIGFsbCBub2RlcyB3aGljaCBhcmVuJ3QgbWF0Y2hpbmcgYW55IHNlbGVjdG9yLlxuICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzID0gW107XG4gICAgICAgIC8vIE51bWJlciBvZiBub24tZGVmYXVsdCBzZWxlY3RvcnMgZm91bmQgaW4gYWxsIHBhcmVudCB0ZW1wbGF0ZXMgb2YgdGhpcyB0ZW1wbGF0ZS4gV2UgbmVlZCB0b1xuICAgICAgICAvLyB0cmFjayBpdCB0byBwcm9wZXJseSBhZGp1c3QgcHJvamVjdGlvbiBzbG90IGluZGV4IGluIHRoZSBgcHJvamVjdGlvbmAgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIHRoaXMuX25nQ29udGVudFNlbGVjdG9yc09mZnNldCA9IDA7XG4gICAgICAgIC8vIEV4cHJlc3Npb24gdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBpbXBsaWNpdCByZWNlaXZlciB3aGVuIGNvbnZlcnRpbmcgdGVtcGxhdGVcbiAgICAgICAgLy8gZXhwcmVzc2lvbnMgdG8gb3V0cHV0IEFTVC5cbiAgICAgICAgdGhpcy5faW1wbGljaXRSZWNlaXZlckV4cHIgPSBudWxsO1xuICAgICAgICAvLyBUaGVzZSBzaG91bGQgYmUgaGFuZGxlZCBpbiB0aGUgdGVtcGxhdGUgb3IgZWxlbWVudCBkaXJlY3RseS5cbiAgICAgICAgdGhpcy52aXNpdFJlZmVyZW5jZSA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRWYXJpYWJsZSA9IGludmFsaWQ7XG4gICAgICAgIHRoaXMudmlzaXRUZXh0QXR0cmlidXRlID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEJvdW5kQXR0cmlidXRlID0gaW52YWxpZDtcbiAgICAgICAgdGhpcy52aXNpdEJvdW5kRXZlbnQgPSBpbnZhbGlkO1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUgPSBwYXJlbnRCaW5kaW5nU2NvcGUubmVzdGVkU2NvcGUobGV2ZWwpO1xuICAgICAgICAvLyBUdXJuIHRoZSByZWxhdGl2ZSBjb250ZXh0IGZpbGUgcGF0aCBpbnRvIGFuIGlkZW50aWZpZXIgYnkgcmVwbGFjaW5nIG5vbi1hbHBoYW51bWVyaWNcbiAgICAgICAgLy8gY2hhcmFjdGVycyB3aXRoIHVuZGVyc2NvcmVzLlxuICAgICAgICB0aGlzLmZpbGVCYXNlZEkxOG5TdWZmaXggPSByZWxhdGl2ZUNvbnRleHRGaWxlUGF0aC5yZXBsYWNlKC9bXkEtWmEtejAtOV0vZywgJ18nKSArICdfJztcbiAgICAgICAgdGhpcy5fdmFsdWVDb252ZXJ0ZXIgPSBuZXcgVmFsdWVDb252ZXJ0ZXIoY29uc3RhbnRQb29sLCAoKSA9PiB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKSwgKG51bVNsb3RzKSA9PiB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMobnVtU2xvdHMpLCAobmFtZSwgbG9jYWxOYW1lLCBzbG90LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLnNldCh0aGlzLmxldmVsLCBsb2NhbE5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycy5waXBlLCBbbGl0ZXJhbChzbG90KSwgbGl0ZXJhbChuYW1lKV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKG5vZGVzLCB2YXJpYWJsZXMsIG5nQ29udGVudFNlbGVjdG9yc09mZnNldCA9IDAsIGkxOG4pIHtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0ID0gbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0O1xuICAgICAgICBpZiAodGhpcy5fbmFtZXNwYWNlICE9PSBJZGVudGlmaWVycy5uYW1lc3BhY2VIVE1MKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24obnVsbCwgdGhpcy5fbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgdmFyaWFibGUgYmluZGluZ3NcbiAgICAgICAgdmFyaWFibGVzLmZvckVhY2godiA9PiB0aGlzLnJlZ2lzdGVyQ29udGV4dFZhcmlhYmxlcyh2KSk7XG4gICAgICAgIC8vIEluaXRpYXRlIGkxOG4gY29udGV4dCBpbiBjYXNlOlxuICAgICAgICAvLyAtIHRoaXMgdGVtcGxhdGUgaGFzIHBhcmVudCBpMThuIGNvbnRleHRcbiAgICAgICAgLy8gLSBvciB0aGUgdGVtcGxhdGUgaGFzIGkxOG4gbWV0YSBhc3NvY2lhdGVkIHdpdGggaXQsXG4gICAgICAgIC8vICAgYnV0IGl0J3Mgbm90IGluaXRpYXRlZCBieSB0aGUgRWxlbWVudCAoZS5nLiA8bmctdGVtcGxhdGUgaTE4bj4pXG4gICAgICAgIGNvbnN0IGluaXRJMThuQ29udGV4dCA9IHRoaXMuaTE4bkNvbnRleHQgfHxcbiAgICAgICAgICAgIChpc0kxOG5Sb290Tm9kZShpMThuKSAmJiAhaXNTaW5nbGVJMThuSWN1KGkxOG4pICYmXG4gICAgICAgICAgICAgICAgIShpc1NpbmdsZUVsZW1lbnRUZW1wbGF0ZShub2RlcykgJiYgbm9kZXNbMF0uaTE4biA9PT0gaTE4bikpO1xuICAgICAgICBjb25zdCBzZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbiA9IGhhc1RleHRDaGlsZHJlbk9ubHkobm9kZXMpO1xuICAgICAgICBpZiAoaW5pdEkxOG5Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5TdGFydChudWxsLCBpMThuLCBzZWxmQ2xvc2luZ0kxOG5JbnN0cnVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCBwYXNzIHRocm91Z2ggdGhlIG5vZGVzIG9mIHRoaXMgdGVtcGxhdGUuIEluIHRoaXMgcGFzcywgd2VcbiAgICAgICAgLy8gcXVldWUgYWxsIGNyZWF0aW9uIG1vZGUgYW5kIHVwZGF0ZSBtb2RlIGluc3RydWN0aW9ucyBmb3IgZ2VuZXJhdGlvbiBpbiB0aGUgc2Vjb25kXG4gICAgICAgIC8vIHBhc3MuIEl0J3MgbmVjZXNzYXJ5IHRvIHNlcGFyYXRlIHRoZSBwYXNzZXMgdG8gZW5zdXJlIGxvY2FsIHJlZnMgYXJlIGRlZmluZWQgYmVmb3JlXG4gICAgICAgIC8vIHJlc29sdmluZyBiaW5kaW5ncy4gV2UgYWxzbyBjb3VudCBiaW5kaW5ncyBpbiB0aGlzIHBhc3MgYXMgd2Ugd2FsayBib3VuZCBleHByZXNzaW9ucy5cbiAgICAgICAgdmlzaXRBbGwkMSh0aGlzLCBub2Rlcyk7XG4gICAgICAgIC8vIEFkZCB0b3RhbCBiaW5kaW5nIGNvdW50IHRvIHB1cmUgZnVuY3Rpb24gY291bnQgc28gcHVyZSBmdW5jdGlvbiBpbnN0cnVjdGlvbnMgYXJlXG4gICAgICAgIC8vIGdlbmVyYXRlZCB3aXRoIHRoZSBjb3JyZWN0IHNsb3Qgb2Zmc2V0IHdoZW4gdXBkYXRlIGluc3RydWN0aW9ucyBhcmUgcHJvY2Vzc2VkLlxuICAgICAgICB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cyArPSB0aGlzLl9iaW5kaW5nU2xvdHM7XG4gICAgICAgIC8vIFBpcGVzIGFyZSB3YWxrZWQgaW4gdGhlIGZpcnN0IHBhc3MgKHRvIGVucXVldWUgYHBpcGUoKWAgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIGFuZFxuICAgICAgICAvLyBgcGlwZUJpbmRgIHVwZGF0ZSBpbnN0cnVjdGlvbnMpLCBzbyB3ZSBoYXZlIHRvIHVwZGF0ZSB0aGUgc2xvdCBvZmZzZXRzIG1hbnVhbGx5XG4gICAgICAgIC8vIHRvIGFjY291bnQgZm9yIGJpbmRpbmdzLlxuICAgICAgICB0aGlzLl92YWx1ZUNvbnZlcnRlci51cGRhdGVQaXBlU2xvdE9mZnNldHModGhpcy5fYmluZGluZ1Nsb3RzKTtcbiAgICAgICAgLy8gTmVzdGVkIHRlbXBsYXRlcyBtdXN0IGJlIHByb2Nlc3NlZCBiZWZvcmUgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIHNvIHRlbXBsYXRlKClcbiAgICAgICAgLy8gaW5zdHJ1Y3Rpb25zIGNhbiBiZSBnZW5lcmF0ZWQgd2l0aCB0aGUgY29ycmVjdCBpbnRlcm5hbCBjb25zdCBjb3VudC5cbiAgICAgICAgdGhpcy5fbmVzdGVkVGVtcGxhdGVGbnMuZm9yRWFjaChidWlsZFRlbXBsYXRlRm4gPT4gYnVpbGRUZW1wbGF0ZUZuKCkpO1xuICAgICAgICAvLyBPdXRwdXQgdGhlIGBwcm9qZWN0aW9uRGVmYCBpbnN0cnVjdGlvbiB3aGVuIHNvbWUgYDxuZy1jb250ZW50PmAgdGFncyBhcmUgcHJlc2VudC5cbiAgICAgICAgLy8gVGhlIGBwcm9qZWN0aW9uRGVmYCBpbnN0cnVjdGlvbiBpcyBvbmx5IGVtaXR0ZWQgZm9yIHRoZSBjb21wb25lbnQgdGVtcGxhdGUgYW5kXG4gICAgICAgIC8vIGlzIHNraXBwZWQgZm9yIG5lc3RlZCB0ZW1wbGF0ZXMgKDxuZy10ZW1wbGF0ZT4gdGFncykuXG4gICAgICAgIGlmICh0aGlzLmxldmVsID09PSAwICYmIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0IHRoZSBgcHJvamVjdGlvbkRlZmAgaW5zdHJ1Y3Rpb25zIGNyZWF0ZXMgb25lIHNsb3QgZm9yIHRoZSB3aWxkY2FyZFxuICAgICAgICAgICAgLy8gc2VsZWN0b3IgaWYgbm8gcGFyYW1ldGVycyBhcmUgcGFzc2VkLiBUaGVyZWZvcmUgd2Ugb25seSB3YW50IHRvIGFsbG9jYXRlIGEgbmV3XG4gICAgICAgICAgICAvLyBhcnJheSBmb3IgdGhlIHByb2plY3Rpb24gc2xvdHMgaWYgdGhlIGRlZmF1bHQgcHJvamVjdGlvbiBzbG90IGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoID4gMSB8fCB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzWzBdICE9PSAnKicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByM1Jlc2VydmVkU2xvdHMgPSB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLm1hcChzID0+IHMgIT09ICcqJyA/IHBhcnNlU2VsZWN0b3JUb1IzU2VsZWN0b3IocykgOiBzKTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5jb25zdGFudFBvb2wuZ2V0Q29uc3RMaXRlcmFsKGFzTGl0ZXJhbChyM1Jlc2VydmVkU2xvdHMpLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBhY2N1bXVsYXRlIG5nQ29udGVudCBzZWxlY3RvcnMgd2hpbGUgcHJvY2Vzc2luZyB0ZW1wbGF0ZSBlbGVtZW50cyxcbiAgICAgICAgICAgIC8vIHdlICpwcmVwZW5kKiBgcHJvamVjdGlvbkRlZmAgdG8gY3JlYXRpb24gaW5zdHJ1Y3Rpb25zIGJsb2NrLCB0byBwdXQgaXQgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgYHByb2plY3Rpb25gIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzLnByb2plY3Rpb25EZWYsIHBhcmFtZXRlcnMsIC8qIHByZXBlbmQgKi8gdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRJMThuQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5pMThuRW5kKG51bGwsIHNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZW5lcmF0ZSBhbGwgdGhlIGNyZWF0aW9uIG1vZGUgaW5zdHJ1Y3Rpb25zIChlLmcuIHJlc29sdmUgYmluZGluZ3MgaW4gbGlzdGVuZXJzKVxuICAgICAgICBjb25zdCBjcmVhdGlvblN0YXRlbWVudHMgPSBnZXRJbnN0cnVjdGlvblN0YXRlbWVudHModGhpcy5fY3JlYXRpb25Db2RlRm5zKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYWxsIHRoZSB1cGRhdGUgbW9kZSBpbnN0cnVjdGlvbnMgKGUuZy4gcmVzb2x2ZSBwcm9wZXJ0eSBvciB0ZXh0IGJpbmRpbmdzKVxuICAgICAgICBjb25zdCB1cGRhdGVTdGF0ZW1lbnRzID0gZ2V0SW5zdHJ1Y3Rpb25TdGF0ZW1lbnRzKHRoaXMuX3VwZGF0ZUNvZGVGbnMpO1xuICAgICAgICAvLyAgVmFyaWFibGUgZGVjbGFyYXRpb24gbXVzdCBvY2N1ciBhZnRlciBiaW5kaW5nIHJlc29sdXRpb24gc28gd2UgY2FuIGdlbmVyYXRlIGNvbnRleHRcbiAgICAgICAgLy8gIGluc3RydWN0aW9ucyB0aGF0IGJ1aWxkIG9uIGVhY2ggb3RoZXIuXG4gICAgICAgIC8vIGUuZy4gY29uc3QgYiA9IG5leHRDb250ZXh0KCkuJGltcGxpY2l0KCk7IGNvbnN0IGIgPSBuZXh0Q29udGV4dCgpO1xuICAgICAgICBjb25zdCBjcmVhdGlvblZhcmlhYmxlcyA9IHRoaXMuX2JpbmRpbmdTY29wZS52aWV3U25hcHNob3RTdGF0ZW1lbnRzKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhcmlhYmxlcyA9IHRoaXMuX2JpbmRpbmdTY29wZS52YXJpYWJsZURlY2xhcmF0aW9ucygpLmNvbmNhdCh0aGlzLl90ZW1wVmFyaWFibGVzKTtcbiAgICAgICAgY29uc3QgY3JlYXRpb25CbG9jayA9IGNyZWF0aW9uU3RhdGVtZW50cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIFtyZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBjb3JlLlJlbmRlckZsYWdzLkNyZWF0ZSAqLywgY3JlYXRpb25WYXJpYWJsZXMuY29uY2F0KGNyZWF0aW9uU3RhdGVtZW50cykpXSA6XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgY29uc3QgdXBkYXRlQmxvY2sgPSB1cGRhdGVTdGF0ZW1lbnRzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgW3JlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIGNvcmUuUmVuZGVyRmxhZ3MuVXBkYXRlICovLCB1cGRhdGVWYXJpYWJsZXMuY29uY2F0KHVwZGF0ZVN0YXRlbWVudHMpKV0gOlxuICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgLy8gaS5lLiAocmY6IFJlbmRlckZsYWdzLCBjdHg6IGFueSlcbiAgICAgICAgW25ldyBGblBhcmFtKFJFTkRFUl9GTEFHUywgTlVNQkVSX1RZUEUpLCBuZXcgRm5QYXJhbShDT05URVhUX05BTUUsIG51bGwpXSwgW1xuICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHZhcmlhYmxlIGRlY2xhcmF0aW9ucyBmb3IgcXVlcnkgcmVmcmVzaCAoaS5lLiBsZXQgX3Q6IGFueTspXG4gICAgICAgICAgICAuLi50aGlzLl9wcmVmaXhDb2RlLFxuICAgICAgICAgICAgLy8gQ3JlYXRpbmcgbW9kZSAoaS5lLiBpZiAocmYgJiBSZW5kZXJGbGFncy5DcmVhdGUpIHsgLi4uIH0pXG4gICAgICAgICAgICAuLi5jcmVhdGlvbkJsb2NrLFxuICAgICAgICAgICAgLy8gQmluZGluZyBhbmQgcmVmcmVzaCBtb2RlIChpLmUuIGlmIChyZiAmIFJlbmRlckZsYWdzLlVwZGF0ZSkgey4uLn0pXG4gICAgICAgICAgICAuLi51cGRhdGVCbG9jayxcbiAgICAgICAgXSwgSU5GRVJSRURfVFlQRSwgbnVsbCwgdGhpcy50ZW1wbGF0ZU5hbWUpO1xuICAgIH1cbiAgICAvLyBMb2NhbFJlc29sdmVyXG4gICAgZ2V0TG9jYWwobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ1Njb3BlLmdldChuYW1lKTtcbiAgICB9XG4gICAgLy8gTG9jYWxSZXNvbHZlclxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5ub3RpZnlJbXBsaWNpdFJlY2VpdmVyVXNlKCk7XG4gICAgfVxuICAgIC8vIExvY2FsUmVzb2x2ZXJcbiAgICBtYXliZVJlc3RvcmVWaWV3KCkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUubWF5YmVSZXN0b3JlVmlldygpO1xuICAgIH1cbiAgICBpMThuVHJhbnNsYXRlKG1lc3NhZ2UsIHBhcmFtcyA9IHt9LCByZWYsIHRyYW5zZm9ybUZuKSB7XG4gICAgICAgIGNvbnN0IF9yZWYgPSByZWYgfHwgdGhpcy5pMThuR2VuZXJhdGVNYWluQmxvY2tWYXIoKTtcbiAgICAgICAgLy8gQ2xvc3VyZSBDb21waWxlciByZXF1aXJlcyBjb25zdCBuYW1lcyB0byBzdGFydCB3aXRoIGBNU0dfYCBidXQgZGlzYWxsb3dzIGFueSBvdGhlciBjb25zdCB0b1xuICAgICAgICAvLyBzdGFydCB3aXRoIGBNU0dfYC4gV2UgZGVmaW5lIGEgdmFyaWFibGUgc3RhcnRpbmcgd2l0aCBgTVNHX2AganVzdCBmb3IgdGhlIGBnb29nLmdldE1zZ2AgY2FsbFxuICAgICAgICBjb25zdCBjbG9zdXJlVmFyID0gdGhpcy5pMThuR2VuZXJhdGVDbG9zdXJlVmFyKG1lc3NhZ2UuaWQpO1xuICAgICAgICBjb25zdCBzdGF0ZW1lbnRzID0gZ2V0VHJhbnNsYXRpb25EZWNsU3RtdHMobWVzc2FnZSwgX3JlZiwgY2xvc3VyZVZhciwgcGFyYW1zLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgIHRoaXMuX2NvbnN0YW50cy5wcmVwYXJlU3RhdGVtZW50cy5wdXNoKC4uLnN0YXRlbWVudHMpO1xuICAgICAgICByZXR1cm4gX3JlZjtcbiAgICB9XG4gICAgcmVnaXN0ZXJDb250ZXh0VmFyaWFibGVzKHZhcmlhYmxlJDEpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVkTmFtZSA9IHRoaXMuX2JpbmRpbmdTY29wZS5mcmVzaFJlZmVyZW5jZU5hbWUoKTtcbiAgICAgICAgY29uc3QgcmV0cmlldmFsTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICBjb25zdCBsaHMgPSB2YXJpYWJsZSh2YXJpYWJsZSQxLm5hbWUgKyBzY29wZWROYW1lKTtcbiAgICAgICAgdGhpcy5fYmluZGluZ1Njb3BlLnNldChyZXRyaWV2YWxMZXZlbCwgdmFyaWFibGUkMS5uYW1lLCBsaHMsIDEgLyogRGVjbGFyYXRpb25Qcmlvcml0eS5DT05URVhUICovLCAoc2NvcGUsIHJlbGF0aXZlTGV2ZWwpID0+IHtcbiAgICAgICAgICAgIGxldCByaHM7XG4gICAgICAgICAgICBpZiAoc2NvcGUuYmluZGluZ0xldmVsID09PSByZXRyaWV2YWxMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChzY29wZS5pc0xpc3RlbmVyU2NvcGUoKSAmJiBzY29wZS5oYXNSZXN0b3JlVmlld1ZhcmlhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiByZXN0b3JlZEN0eC5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBnZXQgdGhlIGNvbnRleHQgZnJvbSBhIHZpZXcgcmVmZXJlbmNlLCBpZiBvbmUgaXMgYXZhaWxhYmxlLCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb250ZXh0IHRoYXQgd2FzIHBhc3NlZCBpbiBkdXJpbmcgY3JlYXRpb24gbWF5IG5vdCBiZSBjb3JyZWN0IGFueW1vcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9wdWxsLzQwMzYwLlxuICAgICAgICAgICAgICAgICAgICByaHMgPSB2YXJpYWJsZShSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5vdGlmeVJlc3RvcmVkVmlld0NvbnRleHRVc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gY3R4XG4gICAgICAgICAgICAgICAgICAgIHJocyA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkQ3R4VmFyID0gc2NvcGUuZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gY3R4X3IwICAgT1IgIHgoMik7XG4gICAgICAgICAgICAgICAgcmhzID0gc2hhcmVkQ3R4VmFyID8gc2hhcmVkQ3R4VmFyIDogZ2VuZXJhdGVOZXh0Q29udGV4dEV4cHIocmVsYXRpdmVMZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlLmcuIGNvbnN0ICRpdGVtJCA9IHgoMikuJGltcGxpY2l0O1xuICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KHJocy5wcm9wKHZhcmlhYmxlJDEudmFsdWUgfHwgSU1QTElDSVRfUkVGRVJFTkNFKSkudG9Db25zdERlY2woKV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpMThuQXBwZW5kQmluZGluZ3MoZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKGV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zLmZvckVhY2goZXhwcmVzc2lvbiA9PiB0aGlzLmkxOG4uYXBwZW5kQmluZGluZyhleHByZXNzaW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaTE4bkJpbmRQcm9wcyhwcm9wcykge1xuICAgICAgICBjb25zdCBib3VuZCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2tleV07XG4gICAgICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFRleHQkMykge1xuICAgICAgICAgICAgICAgIGJvdW5kW2tleV0gPSBsaXRlcmFsKHByb3AudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wLnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RyaW5ncywgZXhwcmVzc2lvbnMgfSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBiaW5kaW5ncyB9ID0gdGhpcy5pMThuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGFzc2VtYmxlSTE4bkJvdW5kU3RyaW5nKHN0cmluZ3MsIGJpbmRpbmdzLnNpemUsIGlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pMThuQXBwZW5kQmluZGluZ3MoZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgICAgICAgICBib3VuZFtrZXldID0gbGl0ZXJhbChsYWJlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZXMgdG9wIGxldmVsIHZhcnMgZm9yIGkxOG4gYmxvY2tzIChpLmUuIGBpMThuX05gKS5cbiAgICBpMThuR2VuZXJhdGVNYWluQmxvY2tWYXIoKSB7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZSh0aGlzLmNvbnN0YW50UG9vbC51bmlxdWVOYW1lKFRSQU5TTEFUSU9OX1ZBUl9QUkVGSVgpKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGVzIHZhcnMgd2l0aCBDbG9zdXJlLXNwZWNpZmljIG5hbWVzIGZvciBpMThuIGJsb2NrcyAoaS5lLiBgTVNHX1hYWGApLlxuICAgIGkxOG5HZW5lcmF0ZUNsb3N1cmVWYXIobWVzc2FnZUlkKSB7XG4gICAgICAgIGxldCBuYW1lO1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0aGlzLmZpbGVCYXNlZEkxOG5TdWZmaXgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaTE4blVzZUV4dGVybmFsSWRzKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KGBFWFRFUk5BTF9gKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVN1ZmZpeCA9IHRoaXMuY29uc3RhbnRQb29sLnVuaXF1ZU5hbWUoc3VmZml4KTtcbiAgICAgICAgICAgIG5hbWUgPSBgJHtwcmVmaXh9JHtzYW5pdGl6ZUlkZW50aWZpZXIobWVzc2FnZUlkKX0kJCR7dW5pcXVlU3VmZml4fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBnZXRUcmFuc2xhdGlvbkNvbnN0UHJlZml4KHN1ZmZpeCk7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5jb25zdGFudFBvb2wudW5pcXVlTmFtZShwcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYWJsZShuYW1lKTtcbiAgICB9XG4gICAgaTE4blVwZGF0ZVJlZihjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgaWN1cywgbWV0YSwgaXNSb290LCBpc1Jlc29sdmVkLCBpc0VtaXR0ZWQgfSA9IGNvbnRleHQ7XG4gICAgICAgIGlmIChpc1Jvb3QgJiYgaXNSZXNvbHZlZCAmJiAhaXNFbWl0dGVkICYmICFpc1NpbmdsZUkxOG5JY3UobWV0YSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaXNFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVycyA9IGNvbnRleHQuZ2V0U2VyaWFsaXplZFBsYWNlaG9sZGVycygpO1xuICAgICAgICAgICAgbGV0IGljdU1hcHBpbmcgPSB7fTtcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBwbGFjZWhvbGRlcnMuc2l6ZSA/IHBsYWNlaG9sZGVyc1RvUGFyYW1zKHBsYWNlaG9sZGVycykgOiB7fTtcbiAgICAgICAgICAgIGlmIChpY3VzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBpY3VzLmZvckVhY2goKHJlZnMsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgb25lIElDVSBkZWZpbmVkIGZvciBhIGdpdmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZWhvbGRlciAtIGp1c3Qgb3V0cHV0IGl0cyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gcmVmc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UgbmVlZCB0byBhY3RpdmF0ZSBwb3N0LXByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHJlcGxhY2UgSUNVIHBsYWNlaG9sZGVycyB3aXRoIHByb3BlciB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gd3JhcEkxOG5QbGFjZWhvbGRlcihgJHtJMThOX0lDVV9NQVBQSU5HX1BSRUZJWH0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1trZXldID0gbGl0ZXJhbChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpY3VNYXBwaW5nW2tleV0gPSBsaXRlcmFsQXJyKHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0cmFuc2xhdGlvbiByZXF1aXJlcyBwb3N0IHByb2Nlc3NpbmcgaW4gMiBjYXNlczpcbiAgICAgICAgICAgIC8vIC0gaWYgd2UgaGF2ZSBwbGFjZWhvbGRlcnMgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgKGV4LiBgU1RBUlRfRElWYDogW++/vSMx77+9LCDvv70jMu+/vSwgLi4uXSlcbiAgICAgICAgICAgIC8vIC0gaWYgd2UgaGF2ZSBtdWx0aXBsZSBJQ1VzIHRoYXQgcmVmZXIgdG8gdGhlIHNhbWUgcGxhY2Vob2xkZXIgbmFtZVxuICAgICAgICAgICAgY29uc3QgbmVlZHNQb3N0cHJvY2Vzc2luZyA9IEFycmF5LmZyb20ocGxhY2Vob2xkZXJzLnZhbHVlcygpKS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUubGVuZ3RoID4gMSkgfHxcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhpY3VNYXBwaW5nKS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgdHJhbnNmb3JtRm47XG4gICAgICAgICAgICBpZiAobmVlZHNQb3N0cHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUZuID0gKHJhdykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0gW3Jhd107XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhpY3VNYXBwaW5nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChtYXBMaXRlcmFsKGljdU1hcHBpbmcsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52b2tlSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMuaTE4blBvc3Rwcm9jZXNzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pMThuVHJhbnNsYXRlKG1ldGEsIHBhcmFtcywgY29udGV4dC5yZWYsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpMThuU3RhcnQoc3BhbiA9IG51bGwsIG1ldGEsIHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIHRoaXMuaTE4biA9IHRoaXMuaTE4bkNvbnRleHQgP1xuICAgICAgICAgICAgdGhpcy5pMThuQ29udGV4dC5mb3JrQ2hpbGRDb250ZXh0KGluZGV4LCB0aGlzLnRlbXBsYXRlSW5kZXgsIG1ldGEpIDpcbiAgICAgICAgICAgIG5ldyBJMThuQ29udGV4dChpbmRleCwgdGhpcy5pMThuR2VuZXJhdGVNYWluQmxvY2tWYXIoKSwgMCwgdGhpcy50ZW1wbGF0ZUluZGV4LCBtZXRhKTtcbiAgICAgICAgLy8gZ2VuZXJhdGUgaTE4blN0YXJ0IGluc3RydWN0aW9uXG4gICAgICAgIGNvbnN0IHsgaWQsIHJlZiB9ID0gdGhpcy5pMThuO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbbGl0ZXJhbChpbmRleCksIHRoaXMuYWRkVG9Db25zdHMocmVmKV07XG4gICAgICAgIGlmIChpZCA+IDApIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdCBwdXNoIDNyZCBhcmd1bWVudCAoc3ViLWJsb2NrIGlkKVxuICAgICAgICAgICAgLy8gaW50byBpMThuU3RhcnQgY2FsbCBmb3IgdG9wIGxldmVsIGkxOG4gY29udGV4dFxuICAgICAgICAgICAgcGFyYW1zLnB1c2gobGl0ZXJhbChpZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzcGFuLCBzZWxmQ2xvc2luZyA/IElkZW50aWZpZXJzLmkxOG4gOiBJZGVudGlmaWVycy5pMThuU3RhcnQsIHBhcmFtcyk7XG4gICAgfVxuICAgIGkxOG5FbmQoc3BhbiA9IG51bGwsIHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2kxOG5FbmQgaXMgZXhlY3V0ZWQgd2l0aCBubyBpMThuIGNvbnRleHQgcHJlc2VudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmkxOG5Db250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmkxOG5Db250ZXh0LnJlY29uY2lsZUNoaWxkQ29udGV4dCh0aGlzLmkxOG4pO1xuICAgICAgICAgICAgdGhpcy5pMThuVXBkYXRlUmVmKHRoaXMuaTE4bkNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pMThuVXBkYXRlUmVmKHRoaXMuaTE4bik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgYWNjdW11bGF0ZWQgYmluZGluZ3NcbiAgICAgICAgY29uc3QgeyBpbmRleCwgYmluZGluZ3MgfSA9IHRoaXMuaTE4bjtcbiAgICAgICAgaWYgKGJpbmRpbmdzLnNpemUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgICAgICAgICAgIC8vIGZvciBpMThuIGJsb2NrLCBhZHZhbmNlIHRvIHRoZSBtb3N0IHJlY2VudCBlbGVtZW50IGluZGV4IChieSB0YWtpbmcgdGhlIGN1cnJlbnQgbnVtYmVyIG9mXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgYW5kIHN1YnRyYWN0aW5nIG9uZSkgYmVmb3JlIGludm9raW5nIGBpMThuRXhwYCBpbnN0cnVjdGlvbnMsIHRvIG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZWNlc3NhcnkgbGlmZWN5Y2xlIGhvb2tzIG9mIGNvbXBvbmVudHMvZGlyZWN0aXZlcyBhcmUgcHJvcGVybHkgZmx1c2hlZC5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UodGhpcy5nZXRDb25zdENvdW50KCkgLSAxLCBzcGFuLCBJZGVudGlmaWVycy5pMThuRXhwLCAoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoYmluZGluZykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbihzcGFuLCBJZGVudGlmaWVycy5pMThuQXBwbHksIFtsaXRlcmFsKGluZGV4KV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZkNsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzcGFuLCBJZGVudGlmaWVycy5pMThuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmkxOG4gPSBudWxsOyAvLyByZXNldCBsb2NhbCBpMThuIGNvbnRleHRcbiAgICB9XG4gICAgaTE4bkF0dHJpYnV0ZXNJbnN0cnVjdGlvbihub2RlSW5kZXgsIGF0dHJzLCBzb3VyY2VTcGFuKSB7XG4gICAgICAgIGxldCBoYXNCaW5kaW5ncyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpMThuQXR0ckFyZ3MgPSBbXTtcbiAgICAgICAgYXR0cnMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhdHRyLmkxOG47XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWQgPSBhdHRyLnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHMoY29udmVydGVkKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0ZWQgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gYXNzZW1ibGVCb3VuZFRleHRQbGFjZWhvbGRlcnMobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGxhY2Vob2xkZXJzVG9QYXJhbXMocGxhY2Vob2xkZXJzKTtcbiAgICAgICAgICAgICAgICBpMThuQXR0ckFyZ3MucHVzaChsaXRlcmFsKGF0dHIubmFtZSksIHRoaXMuaTE4blRyYW5zbGF0ZShtZXNzYWdlLCBwYXJhbXMpKTtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWQuZXhwcmVzc2lvbnMuZm9yRWFjaChleHByZXNzaW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2Uobm9kZUluZGV4LCBzb3VyY2VTcGFuLCBJZGVudGlmaWVycy5pMThuRXhwLCAoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcoZXhwcmVzc2lvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGkxOG5BdHRyQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGxpdGVyYWwodGhpcy5hbGxvY2F0ZURhdGFTbG90KCkpO1xuICAgICAgICAgICAgY29uc3QgY29uc3RJbmRleCA9IHRoaXMuYWRkVG9Db25zdHMobGl0ZXJhbEFycihpMThuQXR0ckFyZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzb3VyY2VTcGFuLCBJZGVudGlmaWVycy5pMThuQXR0cmlidXRlcywgW2luZGV4LCBjb25zdEluZGV4XSk7XG4gICAgICAgICAgICBpZiAoaGFzQmluZGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uKHNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmkxOG5BcHBseSwgW2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TmFtZXNwYWNlSW5zdHJ1Y3Rpb24obmFtZXNwYWNlS2V5KSB7XG4gICAgICAgIHN3aXRjaCAobmFtZXNwYWNlS2V5KSB7XG4gICAgICAgICAgICBjYXNlICdtYXRoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMubmFtZXNwYWNlTWF0aE1MO1xuICAgICAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMubmFtZXNwYWNlU1ZHO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMubmFtZXNwYWNlSFRNTDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGROYW1lc3BhY2VJbnN0cnVjdGlvbihuc0luc3RydWN0aW9uLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX25hbWVzcGFjZSA9IG5zSW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnN0YXJ0U291cmNlU3BhbiwgbnNJbnN0cnVjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gdXBkYXRlIGluc3RydWN0aW9uIGZvciBhbiBpbnRlcnBvbGF0ZWQgcHJvcGVydHkgb3IgYXR0cmlidXRlLCBzdWNoIGFzXG4gICAgICogYHByb3A9XCJ7e3ZhbHVlfX1cImAgb3IgYGF0dHIudGl0bGU9XCJ7e3ZhbHVlfX1cImBcbiAgICAgKi9cbiAgICBpbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihpbnN0cnVjdGlvbiwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgaW5zdHJ1Y3Rpb24sICgpID0+IFtsaXRlcmFsKGF0dHJOYW1lKSwgLi4udGhpcy5nZXRVcGRhdGVJbnN0cnVjdGlvbkFyZ3VtZW50cyh2YWx1ZSksIC4uLnBhcmFtc10pO1xuICAgIH1cbiAgICB2aXNpdENvbnRlbnQobmdDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgY29uc3QgcHJvamVjdGlvblNsb3RJZHggPSB0aGlzLl9uZ0NvbnRlbnRTZWxlY3RvcnNPZmZzZXQgKyB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IFtsaXRlcmFsKHNsb3QpXTtcbiAgICAgICAgdGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5wdXNoKG5nQ29udGVudC5zZWxlY3Rvcik7XG4gICAgICAgIGNvbnN0IG5vbkNvbnRlbnRTZWxlY3RBdHRyaWJ1dGVzID0gbmdDb250ZW50LmF0dHJpYnV0ZXMuZmlsdGVyKGF0dHIgPT4gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkgIT09IE5HX0NPTlRFTlRfU0VMRUNUX0FUVFIpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhuZ0NvbnRlbnQubmFtZSwgbm9uQ29udGVudFNlbGVjdEF0dHJpYnV0ZXMsIFtdLCBbXSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChsaXRlcmFsKHByb2plY3Rpb25TbG90SWR4KSwgbGl0ZXJhbEFycihhdHRyaWJ1dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdGlvblNsb3RJZHggIT09IDApIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChsaXRlcmFsKHByb2plY3Rpb25TbG90SWR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKG5nQ29udGVudC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy5wcm9qZWN0aW9uLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuaTE4bikge1xuICAgICAgICAgICAgdGhpcy5pMThuLmFwcGVuZFByb2plY3Rpb24obmdDb250ZW50LmkxOG4sIHNsb3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRJbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICBjb25zdCBzdHlsaW5nQnVpbGRlciA9IG5ldyBTdHlsaW5nQnVpbGRlcihudWxsKTtcbiAgICAgICAgbGV0IGlzTm9uQmluZGFibGVNb2RlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlzSTE4blJvb3RFbGVtZW50ID0gaXNJMThuUm9vdE5vZGUoZWxlbWVudC5pMThuKSAmJiAhaXNTaW5nbGVJMThuSWN1KGVsZW1lbnQuaTE4bik7XG4gICAgICAgIGNvbnN0IG91dHB1dEF0dHJzID0gW107XG4gICAgICAgIGNvbnN0IFtuYW1lc3BhY2VLZXksIGVsZW1lbnROYW1lXSA9IHNwbGl0TnNOYW1lKGVsZW1lbnQubmFtZSk7XG4gICAgICAgIGNvbnN0IGlzTmdDb250YWluZXIkMSA9IGlzTmdDb250YWluZXIoZWxlbWVudC5uYW1lKTtcbiAgICAgICAgLy8gSGFuZGxlIHN0eWxpbmcsIGkxOG4sIG5nTm9uQmluZGFibGUgYXR0cmlidXRlc1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIHZhbHVlIH0gPSBhdHRyO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IE5PTl9CSU5EQUJMRV9BVFRSKSB7XG4gICAgICAgICAgICAgICAgaXNOb25CaW5kYWJsZU1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIHN0eWxpbmdCdWlsZGVyLnJlZ2lzdGVyU3R5bGVBdHRyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBzdHlsaW5nQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRBdHRycy5wdXNoKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlZ3VsYXIgZWxlbWVudCBvciBuZy1jb250YWluZXIgY3JlYXRpb24gbW9kZVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gW2xpdGVyYWwoZWxlbWVudEluZGV4KV07XG4gICAgICAgIGlmICghaXNOZ0NvbnRhaW5lciQxKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLnB1c2gobGl0ZXJhbChlbGVtZW50TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgICAgICBjb25zdCBhbGxPdGhlcklucHV0cyA9IFtdO1xuICAgICAgICBjb25zdCBib3VuZEkxOG5BdHRycyA9IFtdO1xuICAgICAgICBlbGVtZW50LmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxpbmdJbnB1dFdhc1NldCA9IHN0eWxpbmdCdWlsZGVyLnJlZ2lzdGVyQm91bmRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICBpZiAoIXN0eWxpbmdJbnB1dFdhc1NldCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAwIC8qIEJpbmRpbmdUeXBlLlByb3BlcnR5ICovICYmIGlucHV0LmkxOG4pIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRJMThuQXR0cnMucHVzaChpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGxPdGhlcklucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgYXR0cmlidXRlcyBmb3IgZGlyZWN0aXZlIGFuZCBwcm9qZWN0aW9uIG1hdGNoaW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnQubmFtZSwgb3V0cHV0QXR0cnMsIGFsbE90aGVySW5wdXRzLCBlbGVtZW50Lm91dHB1dHMsIHN0eWxpbmdCdWlsZGVyLCBbXSwgYm91bmRJMThuQXR0cnMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRBdHRyc1RvQ29uc3RzKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgLy8gbG9jYWwgcmVmcyAoZXguOiA8ZGl2ICNmb28gI2Jhcj1cImJhelwiPilcbiAgICAgICAgY29uc3QgcmVmcyA9IHRoaXMucHJlcGFyZVJlZnNBcnJheShlbGVtZW50LnJlZmVyZW5jZXMpO1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2godGhpcy5hZGRUb0NvbnN0cyhyZWZzKSk7XG4gICAgICAgIGNvbnN0IHdhc0luTmFtZXNwYWNlID0gdGhpcy5fbmFtZXNwYWNlO1xuICAgICAgICBjb25zdCBjdXJyZW50TmFtZXNwYWNlID0gdGhpcy5nZXROYW1lc3BhY2VJbnN0cnVjdGlvbihuYW1lc3BhY2VLZXkpO1xuICAgICAgICAvLyBJZiB0aGUgbmFtZXNwYWNlIGlzIGNoYW5naW5nIG5vdywgaW5jbHVkZSBhbiBpbnN0cnVjdGlvbiB0byBjaGFuZ2UgaXRcbiAgICAgICAgLy8gZHVyaW5nIGVsZW1lbnQgY3JlYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50TmFtZXNwYWNlICE9PSB3YXNJbk5hbWVzcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5hZGROYW1lc3BhY2VJbnN0cnVjdGlvbihjdXJyZW50TmFtZXNwYWNlLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIG5vdCBhcHBlbmQgdGV4dCBub2RlIGluc3RydWN0aW9ucyBhbmQgSUNVcyBpbnNpZGUgaTE4biBzZWN0aW9uLFxuICAgICAgICAvLyBzbyB3ZSBleGNsdWRlIHRoZW0gd2hpbGUgY2FsY3VsYXRpbmcgd2hldGhlciBjdXJyZW50IGVsZW1lbnQgaGFzIGNoaWxkcmVuXG4gICAgICAgIGNvbnN0IGhhc0NoaWxkcmVuID0gKCFpc0kxOG5Sb290RWxlbWVudCAmJiB0aGlzLmkxOG4pID8gIWhhc1RleHRDaGlsZHJlbk9ubHkoZWxlbWVudC5jaGlsZHJlbikgOlxuICAgICAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPiAwO1xuICAgICAgICBjb25zdCBjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uID0gIXN0eWxpbmdCdWlsZGVyLmhhc0JpbmRpbmdzV2l0aFBpcGVzICYmXG4gICAgICAgICAgICBlbGVtZW50Lm91dHB1dHMubGVuZ3RoID09PSAwICYmIGJvdW5kSTE4bkF0dHJzLmxlbmd0aCA9PT0gMCAmJiAhaGFzQ2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGNyZWF0ZVNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uID0gIWNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24gJiYgaGFzVGV4dENoaWxkcmVuT25seShlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgICAgaWYgKGNyZWF0ZVNlbGZDbG9zaW5nSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihlbGVtZW50LnNvdXJjZVNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXIgOiBJZGVudGlmaWVycy5lbGVtZW50LCB0cmltVHJhaWxpbmdOdWxscyhwYXJhbWV0ZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGlzTmdDb250YWluZXIkMSA/IElkZW50aWZpZXJzLmVsZW1lbnRDb250YWluZXJTdGFydCA6IElkZW50aWZpZXJzLmVsZW1lbnRTdGFydCwgdHJpbVRyYWlsaW5nTnVsbHMocGFyYW1ldGVycykpO1xuICAgICAgICAgICAgaWYgKGlzTm9uQmluZGFibGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGlvbkluc3RydWN0aW9uKGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLCBJZGVudGlmaWVycy5kaXNhYmxlQmluZGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJvdW5kSTE4bkF0dHJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG5BdHRyaWJ1dGVzSW5zdHJ1Y3Rpb24oZWxlbWVudEluZGV4LCBib3VuZEkxOG5BdHRycywgZWxlbWVudC5zdGFydFNvdXJjZVNwYW4gPz8gZWxlbWVudC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIExpc3RlbmVycyAob3V0cHV0cylcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0QXN0IG9mIGVsZW1lbnQub3V0cHV0cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24ob3V0cHV0QXN0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmxpc3RlbmVyLCB0aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcihlbGVtZW50Lm5hbWUsIG91dHB1dEFzdCwgZWxlbWVudEluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZTogaXQncyBpbXBvcnRhbnQgdG8ga2VlcCBpMThuL2kxOG5TdGFydCBpbnN0cnVjdGlvbnMgYWZ0ZXIgaTE4bkF0dHJpYnV0ZXMgYW5kXG4gICAgICAgICAgICAvLyBsaXN0ZW5lcnMsIHRvIG1ha2Ugc3VyZSBpMThuQXR0cmlidXRlcyBpbnN0cnVjdGlvbiB0YXJnZXRzIGN1cnJlbnQgZWxlbWVudCBhdCBydW50aW1lLlxuICAgICAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuU3RhcnQoZWxlbWVudC5zdGFydFNvdXJjZVNwYW4sIGVsZW1lbnQuaTE4biwgY3JlYXRlU2VsZkNsb3NpbmdJMThuSW5zdHJ1Y3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBjb2RlIGhlcmUgd2lsbCBjb2xsZWN0IGFsbCB1cGRhdGUtbGV2ZWwgc3R5bGluZyBpbnN0cnVjdGlvbnMgYW5kIGFkZCB0aGVtIHRvIHRoZVxuICAgICAgICAvLyB1cGRhdGUgYmxvY2sgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIEFPVCBjb2RlLiBJbnN0cnVjdGlvbnMgbGlrZSBgc3R5bGVQcm9wYCxcbiAgICAgICAgLy8gYHN0eWxlTWFwYCwgYGNsYXNzTWFwYCwgYGNsYXNzUHJvcGBcbiAgICAgICAgLy8gYXJlIGFsbCBnZW5lcmF0ZWQgYW5kIGFzc2lnbmVkIGluIHRoZSBjb2RlIGJlbG93LlxuICAgICAgICBjb25zdCBzdHlsaW5nSW5zdHJ1Y3Rpb25zID0gc3R5bGluZ0J1aWxkZXIuYnVpbGRVcGRhdGVMZXZlbEluc3RydWN0aW9ucyh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gc3R5bGluZ0luc3RydWN0aW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0cnVjdGlvbiA9IHN0eWxpbmdJbnN0cnVjdGlvbnNbaV07XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdGhpcy5wcm9jZXNzU3R5bGluZ1VwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5zdHJ1Y3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSByZWFzb24gd2h5IGB1bmRlZmluZWRgIGlzIHVzZWQgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgdW5kZXJzdGFuZHMgdGhpcyBhcyBhXG4gICAgICAgIC8vIHNwZWNpYWwgdmFsdWUgdG8gc3ltYm9saXplIHRoYXQgdGhlcmUgaXMgbm8gUkhTIHRvIHRoaXMgYmluZGluZ1xuICAgICAgICAvLyBUT0RPIChtYXRza28pOiByZXZpc2l0IHRoaXMgb25jZSBGVy05NTkgaXMgYXBwcm9hY2hlZFxuICAgICAgICBjb25zdCBlbXB0eVZhbHVlQmluZEluc3RydWN0aW9uID0gbGl0ZXJhbCh1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCBwcm9wZXJ0eUJpbmRpbmdzID0gW107XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZUJpbmRpbmdzID0gW107XG4gICAgICAgIC8vIEdlbmVyYXRlIGVsZW1lbnQgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgYWxsT3RoZXJJbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gNCAvKiBCaW5kaW5nVHlwZS5BbmltYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGlucHV0LnZhbHVlLnZpc2l0KHRoaXMuX3ZhbHVlQ29udmVydGVyKTtcbiAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gYmluZGluZ3MgY2FuIGJlIHByZXNlbnRlZCBpbiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG4gICAgICAgICAgICAgICAgLy8gMS4gW0BiaW5kaW5nXT1cImZvb0V4cFwiXG4gICAgICAgICAgICAgICAgLy8gMi4gW0BiaW5kaW5nXT1cInt2YWx1ZTpmb29FeHAsIHBhcmFtczp7Li4ufX1cIlxuICAgICAgICAgICAgICAgIC8vIDMuIFtAYmluZGluZ11cbiAgICAgICAgICAgICAgICAvLyA0LiBAYmluZGluZ1xuICAgICAgICAgICAgICAgIC8vIEFsbCBmb3JtYXRzIHdpbGwgYmUgdmFsaWQgZm9yIHdoZW4gYSBzeW50aGV0aWMgYmluZGluZyBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb25pbmcgZm9yIHRoaXMgaXMgYmVjYXVzZSB0aGUgcmVuZGVyZXIgc2hvdWxkIGdldCBlYWNoXG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIGJpbmRpbmcgdmFsdWUgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSB0aGF0IHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lZCBpbi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1ZhbHVlID0gdmFsdWUgaW5zdGFuY2VvZiBMaXRlcmFsUHJpbWl0aXZlID8gISF2YWx1ZS52YWx1ZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlCaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3BhbjogaW5wdXQuc291cmNlU3BhbixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zT3JGbjogZ2V0QmluZGluZ0Z1bmN0aW9uUGFyYW1zKCgpID0+IGhhc1ZhbHVlID8gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSA6IGVtcHR5VmFsdWVCaW5kSW5zdHJ1Y3Rpb24sIHByZXBhcmVTeW50aGV0aWNQcm9wZXJ0eU5hbWUoaW5wdXQubmFtZSkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBtdXN0IHNraXAgYXR0cmlidXRlcyB3aXRoIGFzc29jaWF0ZWQgaTE4biBjb250ZXh0LCBzaW5jZSB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBoYW5kbGVkXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdGVseSBhbmQgY29ycmVzcG9uZGluZyBgaTE4bkV4cGAgYW5kIGBpMThuQXBwbHlgIGluc3RydWN0aW9ucyB3aWxsIGJlIGdlbmVyYXRlZFxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5pMThuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFthdHRyTmFtZXNwYWNlLCBhdHRyTmFtZV0gPSBzcGxpdE5zTmFtZShpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNBdHRyaWJ1dGVCaW5kaW5nID0gaW5wdXRUeXBlID09PSAxIC8qIEJpbmRpbmdUeXBlLkF0dHJpYnV0ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNhbml0aXphdGlvblJlZiA9IHJlc29sdmVTYW5pdGl6YXRpb25GbihpbnB1dC5zZWN1cml0eUNvbnRleHQsIGlzQXR0cmlidXRlQmluZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2FuaXRpemF0aW9uUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gc2FuaXRpemF0aW9uIGZ1bmN0aW9uIGZvdW5kIGJhc2VkIG9uIHRoZSBzZWN1cml0eSBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBhbiBhdHRyaWJ1dGUvcHJvcGVydHkgLSBjaGVjayB3aGV0aGVyIHRoaXMgYXR0cmlidXRlL3Byb3BlcnR5IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmUgb2YgdGhlIHNlY3VyaXR5LXNlbnNpdGl2ZSA8aWZyYW1lPiBhdHRyaWJ1dGVzIChhbmQgdGhhdCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhY3R1YWxseSBhbiA8aWZyYW1lPikuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJZnJhbWVFbGVtZW50KGVsZW1lbnQubmFtZSkgJiYgaXNJZnJhbWVTZWN1cml0eVNlbnNpdGl2ZUF0dHIoaW5wdXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW5pdGl6YXRpb25SZWYgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnZhbGlkYXRlSWZyYW1lQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FuaXRpemF0aW9uUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChzYW5pdGl6YXRpb25SZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2VMaXRlcmFsID0gbGl0ZXJhbChhdHRyTmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW5pdGl6YXRpb25SZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChuYW1lc3BhY2VMaXRlcmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIHNhbml0aXphdGlvbiByZWYsIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgcGFyYW0gc28gdGhhdCB3ZSBjYW4gcGFzcyBpbiB0aGUgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGxpdGVyYWwobnVsbCksIG5hbWVzcGFjZUxpdGVyYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRUeXBlID09PSAwIC8qIEJpbmRpbmdUeXBlLlByb3BlcnR5ICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcD1cInt7dmFsdWV9fVwiIGFuZCBmcmllbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZWRVcGRhdGVJbnN0cnVjdGlvbihnZXRQcm9wZXJ0eUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW3Byb3BdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSBwcm9wZXJ0aWVzIHNvIHRoYXQgd2UgY2FuIGNoYWluIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBnZXRCaW5kaW5nRnVuY3Rpb25QYXJhbXMoKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSwgYXR0ck5hbWUsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnB1dFR5cGUgPT09IDEgLyogQmluZGluZ1R5cGUuQXR0cmlidXRlICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uICYmIGdldEludGVycG9sYXRpb25BcmdzTGVuZ3RoKHZhbHVlKSA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRyLm5hbWU9XCJ0ZXh0e3t2YWx1ZX19XCIgYW5kIGZyaWVuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFVwZGF0ZUluc3RydWN0aW9uKGdldEF0dHJpYnV0ZUludGVycG9sYXRpb25FeHByZXNzaW9uKHZhbHVlKSwgZWxlbWVudEluZGV4LCBhdHRyTmFtZSwgaW5wdXQsIHZhbHVlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRWYWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGlvbiA/IHZhbHVlLmV4cHJlc3Npb25zWzBdIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gW2F0dHIubmFtZV09XCJ2YWx1ZVwiIG9yIGF0dHIubmFtZT1cInt7dmFsdWV9fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGVjdCB0aGUgYXR0cmlidXRlIGJpbmRpbmdzIHNvIHRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZCBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUJpbmRpbmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuOiBpbnB1dC5zb3VyY2VTcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNPckZuOiBnZXRCaW5kaW5nRnVuY3Rpb25QYXJhbXMoKCkgPT4gdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKGJvdW5kVmFsdWUpLCBhdHRyTmFtZSwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xhc3MgcHJvcFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgaW5wdXQuc291cmNlU3BhbiwgSWRlbnRpZmllcnMuY2xhc3NQcm9wLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbChlbGVtZW50SW5kZXgpLCBsaXRlcmFsKGF0dHJOYW1lKSwgdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eUJpbmRpbmcgb2YgcHJvcGVydHlCaW5kaW5ncykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0cnVjdGlvbldpdGhBZHZhbmNlKGVsZW1lbnRJbmRleCwgcHJvcGVydHlCaW5kaW5nLnNwYW4sIElkZW50aWZpZXJzLnByb3BlcnR5LCBwcm9wZXJ0eUJpbmRpbmcucGFyYW1zT3JGbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVCaW5kaW5nIG9mIGF0dHJpYnV0ZUJpbmRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2UoZWxlbWVudEluZGV4LCBhdHRyaWJ1dGVCaW5kaW5nLnNwYW4sIElkZW50aWZpZXJzLmF0dHJpYnV0ZSwgYXR0cmlidXRlQmluZGluZy5wYXJhbXNPckZuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmF2ZXJzZSBlbGVtZW50IGNoaWxkIG5vZGVzXG4gICAgICAgIHZpc2l0QWxsJDEodGhpcywgZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICAgIGlmICghaXNJMThuUm9vdEVsZW1lbnQgJiYgdGhpcy5pMThuKSB7XG4gICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kRWxlbWVudChlbGVtZW50LmkxOG4sIGVsZW1lbnRJbmRleCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjcmVhdGVTZWxmQ2xvc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggZWxlbWVudCBjb25zdHJ1Y3Rpb24gbW9kZS5cbiAgICAgICAgICAgIGNvbnN0IHNwYW4gPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4gPz8gZWxlbWVudC5zb3VyY2VTcGFuO1xuICAgICAgICAgICAgaWYgKGlzSTE4blJvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuRW5kKHNwYW4sIGNyZWF0ZVNlbGZDbG9zaW5nSTE4bkluc3RydWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05vbkJpbmRhYmxlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbihzcGFuLCBJZGVudGlmaWVycy5lbmFibGVCaW5kaW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24oc3BhbiwgaXNOZ0NvbnRhaW5lciQxID8gSWRlbnRpZmllcnMuZWxlbWVudENvbnRhaW5lckVuZCA6IElkZW50aWZpZXJzLmVsZW1lbnRFbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgTkdfVEVNUExBVEVfVEFHX05BTUUgPSAnbmctdGVtcGxhdGUnO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZUluZGV4ID0gdGhpcy5hbGxvY2F0ZURhdGFTbG90KCk7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bi5hcHBlbmRUZW1wbGF0ZSh0ZW1wbGF0ZS5pMThuLCB0ZW1wbGF0ZUluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdOYW1lV2l0aG91dE5hbWVzcGFjZSA9IHRlbXBsYXRlLnRhZ05hbWUgPyBzcGxpdE5zTmFtZSh0ZW1wbGF0ZS50YWdOYW1lKVsxXSA6IHRlbXBsYXRlLnRhZ05hbWU7XG4gICAgICAgIGNvbnN0IGNvbnRleHROYW1lID0gYCR7dGhpcy5jb250ZXh0TmFtZX0ke3RlbXBsYXRlLnRhZ05hbWUgPyAnXycgKyBzYW5pdGl6ZUlkZW50aWZpZXIodGVtcGxhdGUudGFnTmFtZSkgOiAnJ31fJHt0ZW1wbGF0ZUluZGV4fWA7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlTmFtZSA9IGAke2NvbnRleHROYW1lfV9UZW1wbGF0ZWA7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICBsaXRlcmFsKHRlbXBsYXRlSW5kZXgpLFxuICAgICAgICAgICAgdmFyaWFibGUodGVtcGxhdGVOYW1lKSxcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIHRhZydzIG5hbWVzcGFjZSBoZXJlLCBiZWNhdXNlIHdlIGluZmVyXG4gICAgICAgICAgICAvLyBpdCBiYXNlZCBvbiB0aGUgcGFyZW50IG5vZGVzIGluc2lkZSB0aGUgdGVtcGxhdGUgaW5zdHJ1Y3Rpb24uXG4gICAgICAgICAgICBsaXRlcmFsKHRhZ05hbWVXaXRob3V0TmFtZXNwYWNlKSxcbiAgICAgICAgXTtcbiAgICAgICAgLy8gcHJlcGFyZSBhdHRyaWJ1dGVzIHBhcmFtZXRlciAoaW5jbHVkaW5nIGF0dHJpYnV0ZXMgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nKVxuICAgICAgICBjb25zdCBhdHRyc0V4cHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVFeHByZXNzaW9ucyhOR19URU1QTEFURV9UQUdfTkFNRSwgdGVtcGxhdGUuYXR0cmlidXRlcywgdGVtcGxhdGUuaW5wdXRzLCB0ZW1wbGF0ZS5vdXRwdXRzLCB1bmRlZmluZWQgLyogc3R5bGVzICovLCB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzKTtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHRoaXMuYWRkQXR0cnNUb0NvbnN0cyhhdHRyc0V4cHJzKSk7XG4gICAgICAgIC8vIGxvY2FsIHJlZnMgKGV4LjogPG5nLXRlbXBsYXRlICNmb28+KVxuICAgICAgICBpZiAodGVtcGxhdGUucmVmZXJlbmNlcyAmJiB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVmcyA9IHRoaXMucHJlcGFyZVJlZnNBcnJheSh0ZW1wbGF0ZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaCh0aGlzLmFkZFRvQ29uc3RzKHJlZnMpKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLnRlbXBsYXRlUmVmRXh0cmFjdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAgICBjb25zdCB0ZW1wbGF0ZVZpc2l0b3IgPSBuZXcgVGVtcGxhdGVEZWZpbml0aW9uQnVpbGRlcih0aGlzLmNvbnN0YW50UG9vbCwgdGhpcy5fYmluZGluZ1Njb3BlLCB0aGlzLmxldmVsICsgMSwgY29udGV4dE5hbWUsIHRoaXMuaTE4biwgdGVtcGxhdGVJbmRleCwgdGVtcGxhdGVOYW1lLCB0aGlzLl9uYW1lc3BhY2UsIHRoaXMuZmlsZUJhc2VkSTE4blN1ZmZpeCwgdGhpcy5pMThuVXNlRXh0ZXJuYWxJZHMsIHRoaXMuX2NvbnN0YW50cyk7XG4gICAgICAgIC8vIE5lc3RlZCB0ZW1wbGF0ZXMgbXVzdCBub3QgYmUgdmlzaXRlZCB1bnRpbCBhZnRlciB0aGVpciBwYXJlbnQgdGVtcGxhdGVzIGhhdmUgY29tcGxldGVkXG4gICAgICAgIC8vIHByb2Nlc3NpbmcsIHNvIHRoZXkgYXJlIHF1ZXVlZCBoZXJlIHVudGlsIGFmdGVyIHRoZSBpbml0aWFsIHBhc3MuIE90aGVyd2lzZSwgd2Ugd291bGRuJ3RcbiAgICAgICAgLy8gYmUgYWJsZSB0byBzdXBwb3J0IGJpbmRpbmdzIGluIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gbG9jYWwgcmVmcyB0aGF0IG9jY3VyIGFmdGVyIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBkZWZpbml0aW9uLiBlLmcuIDxkaXYgKm5nSWY9XCJzaG93aW5nXCI+e3sgZm9vIH19PC9kaXY+ICA8ZGl2ICNmb28+PC9kaXY+XG4gICAgICAgIHRoaXMuX25lc3RlZFRlbXBsYXRlRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGVGdW5jdGlvbkV4cHIgPSB0ZW1wbGF0ZVZpc2l0b3IuYnVpbGRUZW1wbGF0ZUZ1bmN0aW9uKHRlbXBsYXRlLmNoaWxkcmVuLCB0ZW1wbGF0ZS52YXJpYWJsZXMsIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoICsgdGhpcy5fbmdDb250ZW50U2VsZWN0b3JzT2Zmc2V0LCB0ZW1wbGF0ZS5pMThuKTtcbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRQb29sLnN0YXRlbWVudHMucHVzaCh0ZW1wbGF0ZUZ1bmN0aW9uRXhwci50b0RlY2xTdG10KHRlbXBsYXRlTmFtZSkpO1xuICAgICAgICAgICAgaWYgKHRlbXBsYXRlVmlzaXRvci5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzLnB1c2goLi4udGVtcGxhdGVWaXNpdG9yLl9uZ0NvbnRlbnRSZXNlcnZlZFNsb3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGUuZy4gdGVtcGxhdGUoMSwgTXlDb21wX1RlbXBsYXRlXzEpXG4gICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZW1wbGF0ZS5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy50ZW1wbGF0ZUNyZWF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5zcGxpY2UoMiwgMCwgbGl0ZXJhbCh0ZW1wbGF0ZVZpc2l0b3IuZ2V0Q29uc3RDb3VudCgpKSwgbGl0ZXJhbCh0ZW1wbGF0ZVZpc2l0b3IuZ2V0VmFyQ291bnQoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRyaW1UcmFpbGluZ051bGxzKHBhcmFtZXRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaGFuZGxlIHByb3BlcnR5IGJpbmRpbmdzIGUuZy4gybXJtXByb3BlcnR5KCduZ0Zvck9mJywgY3R4Lml0ZW1zKSwgZXQgYWw7XG4gICAgICAgIHRoaXMudGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIHRlbXBsYXRlLnRlbXBsYXRlQXR0cnMpO1xuICAgICAgICAvLyBPbmx5IGFkZCBub3JtYWwgaW5wdXQvb3V0cHV0IGJpbmRpbmcgaW5zdHJ1Y3Rpb25zIG9uIGV4cGxpY2l0IDxuZy10ZW1wbGF0ZT4gZWxlbWVudHMuXG4gICAgICAgIGlmICh0YWdOYW1lV2l0aG91dE5hbWVzcGFjZSA9PT0gTkdfVEVNUExBVEVfVEFHX05BTUUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpMThuSW5wdXRzLCBpbnB1dHNdID0gcGFydGl0aW9uQXJyYXkodGVtcGxhdGUuaW5wdXRzLCBoYXNJMThuTWV0YSk7XG4gICAgICAgICAgICAvLyBBZGQgaTE4biBhdHRyaWJ1dGVzIHRoYXQgbWF5IGFjdCBhcyBpbnB1dHMgdG8gZGlyZWN0aXZlcy4gSWYgc3VjaCBhdHRyaWJ1dGVzIGFyZSBwcmVzZW50LFxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgYGkxOG5BdHRyaWJ1dGVzYCBpbnN0cnVjdGlvbi4gTm90ZTogd2UgZ2VuZXJhdGUgaXQgb25seSBmb3IgZXhwbGljaXQgPG5nLXRlbXBsYXRlPlxuICAgICAgICAgICAgLy8gZWxlbWVudHMsIGluIGNhc2Ugb2YgaW5saW5lIHRlbXBsYXRlcywgY29ycmVzcG9uZGluZyBpbnN0cnVjdGlvbnMgd2lsbCBiZSBnZW5lcmF0ZWQgaW4gdGhlXG4gICAgICAgICAgICAvLyBuZXN0ZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICAgICAgICBpZiAoaTE4bklucHV0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuQXR0cmlidXRlc0luc3RydWN0aW9uKHRlbXBsYXRlSW5kZXgsIGkxOG5JbnB1dHMsIHRlbXBsYXRlLnN0YXJ0U291cmNlU3BhbiA/PyB0ZW1wbGF0ZS5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgaW5wdXQgYmluZGluZ3NcbiAgICAgICAgICAgIGlmIChpbnB1dHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVQcm9wZXJ0eUJpbmRpbmdzKHRlbXBsYXRlSW5kZXgsIGlucHV0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBsaXN0ZW5lcnMgZm9yIGRpcmVjdGl2ZSBvdXRwdXRcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0cHV0QXN0IG9mIHRlbXBsYXRlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24ob3V0cHV0QXN0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzLmxpc3RlbmVyLCB0aGlzLnByZXBhcmVMaXN0ZW5lclBhcmFtZXRlcignbmdfdGVtcGxhdGUnLCBvdXRwdXRBc3QsIHRlbXBsYXRlSW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICB0aGlzLmFsbG9jYXRlQmluZGluZ1Nsb3RzKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkxOG4uYXBwZW5kQm91bmRUZXh0KHRleHQuaTE4bik7XG4gICAgICAgICAgICAgICAgdGhpcy5pMThuQXBwZW5kQmluZGluZ3ModmFsdWUuZXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpO1xuICAgICAgICB0aGlzLmNyZWF0aW9uSW5zdHJ1Y3Rpb24odGV4dC5zb3VyY2VTcGFuLCBJZGVudGlmaWVycy50ZXh0LCBbbGl0ZXJhbChub2RlSW5kZXgpXSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVCaW5kaW5nU2xvdHModmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluc3RydWN0aW9uV2l0aEFkdmFuY2Uobm9kZUluZGV4LCB0ZXh0LnNvdXJjZVNwYW4sIGdldFRleHRJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZSksICgpID0+IHRoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdUZXh0IG5vZGVzIHNob3VsZCBiZSBpbnRlcnBvbGF0ZWQgYW5kIG5ldmVyIGJvdW5kIGRpcmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7XG4gICAgICAgIC8vIHdoZW4gYSB0ZXh0IGVsZW1lbnQgaXMgbG9jYXRlZCB3aXRoaW4gYSB0cmFuc2xhdGFibGVcbiAgICAgICAgLy8gYmxvY2ssIHdlIGV4Y2x1ZGUgdGhpcyB0ZXh0IGVsZW1lbnQgZnJvbSBpbnN0cnVjdGlvbnMgc2V0LFxuICAgICAgICAvLyBzaW5jZSBpdCB3aWxsIGJlIGNhcHR1cmVkIGluIGkxOG4gY29udGVudCBhbmQgcHJvY2Vzc2VkIGF0IHJ1bnRpbWVcbiAgICAgICAgaWYgKCF0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRpb25JbnN0cnVjdGlvbih0ZXh0LnNvdXJjZVNwYW4sIElkZW50aWZpZXJzLnRleHQsIFtsaXRlcmFsKHRoaXMuYWxsb2NhdGVEYXRhU2xvdCgpKSwgbGl0ZXJhbCh0ZXh0LnZhbHVlKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICBsZXQgaW5pdFdhc0ludm9rZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gaWYgYW4gSUNVIHdhcyBjcmVhdGVkIG91dHNpZGUgb2YgaTE4biBibG9jaywgd2Ugc3RpbGwgdHJlYXRcbiAgICAgICAgLy8gaXQgYXMgYSB0cmFuc2xhdGFibGUgZW50aXR5IGFuZCBpbnZva2UgaTE4blN0YXJ0IGFuZCBpMThuRW5kXG4gICAgICAgIC8vIHRvIGdlbmVyYXRlIGkxOG4gY29udGV4dCBhbmQgdGhlIG5lY2Vzc2FyeSBpbnN0cnVjdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLmkxOG4pIHtcbiAgICAgICAgICAgIGluaXRXYXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaTE4blN0YXJ0KG51bGwsIGljdS5pMThuLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpMThuID0gdGhpcy5pMThuO1xuICAgICAgICBjb25zdCB2YXJzID0gdGhpcy5pMThuQmluZFByb3BzKGljdS52YXJzKTtcbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJzID0gdGhpcy5pMThuQmluZFByb3BzKGljdS5wbGFjZWhvbGRlcnMpO1xuICAgICAgICAvLyBvdXRwdXQgSUNVIGRpcmVjdGx5IGFuZCBrZWVwIElDVSByZWZlcmVuY2UgaW4gY29udGV4dFxuICAgICAgICBjb25zdCBtZXNzYWdlID0gaWN1LmkxOG47XG4gICAgICAgIC8vIHdlIGFsd2F5cyBuZWVkIHBvc3QtcHJvY2Vzc2luZyBmdW5jdGlvbiBmb3IgSUNVcywgdG8gbWFrZSBzdXJlIHRoYXQ6XG4gICAgICAgIC8vIC0gYWxsIHBsYWNlaG9sZGVycyBpbiBhIGZvcm0gb2Yge1BMQUNFSE9MREVSfSBhcmUgcmVwbGFjZWQgd2l0aCBhY3R1YWwgdmFsdWVzIChub3RlOlxuICAgICAgICAvLyBgZ29vZy5nZXRNc2dgIGRvZXMgbm90IHByb2Nlc3MgSUNVcyBhbmQgdXNlcyB0aGUgYHtQTEFDRUhPTERFUn1gIGZvcm1hdCBmb3IgcGxhY2Vob2xkZXJzXG4gICAgICAgIC8vIGluc2lkZSBJQ1VzKVxuICAgICAgICAvLyAtIGFsbCBJQ1UgdmFycyAoc3VjaCBhcyBgVkFSX1NFTEVDVGAgb3IgYFZBUl9QTFVSQUxgKSBhcmUgcmVwbGFjZWQgd2l0aCBjb3JyZWN0IHZhbHVlc1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IChyYXcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgLi4udmFycywgLi4ucGxhY2Vob2xkZXJzIH07XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWQgPSBmb3JtYXRJMThuUGxhY2Vob2xkZXJOYW1lc0luTWFwKHBhcmFtcywgLyogdXNlQ2FtZWxDYXNlICovIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VJbnN0cnVjdGlvbihudWxsLCBJZGVudGlmaWVycy5pMThuUG9zdHByb2Nlc3MsIFtyYXcsIG1hcExpdGVyYWwoZm9ybWF0dGVkLCB0cnVlKV0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSB3aG9sZSBpMThuIG1lc3NhZ2UgaXMgYSBzaW5nbGUgSUNVIC0gd2UgZG8gbm90IG5lZWQgdG9cbiAgICAgICAgLy8gY3JlYXRlIGEgc2VwYXJhdGUgdG9wLWxldmVsIHRyYW5zbGF0aW9uLCB3ZSBjYW4gdXNlIHRoZSByb290IHJlZiBpbnN0ZWFkXG4gICAgICAgIC8vIGFuZCBtYWtlIHRoaXMgSUNVIGEgdG9wLWxldmVsIHRyYW5zbGF0aW9uXG4gICAgICAgIC8vIG5vdGU6IElDVSBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIHdpdGggYWN0dWFsIHZhbHVlcyBpbiBgaTE4blBvc3Rwcm9jZXNzYCBmdW5jdGlvblxuICAgICAgICAvLyBzZXBhcmF0ZWx5LCBzbyB3ZSBkbyBub3QgcGFzcyBwbGFjZWhvbGRlcnMgaW50byBgaTE4blRyYW5zbGF0ZWAgZnVuY3Rpb24uXG4gICAgICAgIGlmIChpc1NpbmdsZUkxOG5JY3UoaTE4bi5tZXRhKSkge1xuICAgICAgICAgICAgdGhpcy5pMThuVHJhbnNsYXRlKG1lc3NhZ2UsIC8qIHBsYWNlaG9sZGVycyAqLyB7fSwgaTE4bi5yZWYsIHRyYW5zZm9ybUZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG91dHB1dCBJQ1UgZGlyZWN0bHkgYW5kIGtlZXAgSUNVIHJlZmVyZW5jZSBpbiBjb250ZXh0XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmkxOG5UcmFuc2xhdGUobWVzc2FnZSwgLyogcGxhY2Vob2xkZXJzICovIHt9LCAvKiByZWYgKi8gdW5kZWZpbmVkLCB0cmFuc2Zvcm1Gbik7XG4gICAgICAgICAgICBpMThuLmFwcGVuZEljdShpY3VGcm9tSTE4bk1lc3NhZ2UobWVzc2FnZSkubmFtZSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdFdhc0ludm9rZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaTE4bkVuZChudWxsLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWxsb2NhdGVEYXRhU2xvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFJbmRleCsrO1xuICAgIH1cbiAgICBnZXRDb25zdENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUluZGV4O1xuICAgIH1cbiAgICBnZXRWYXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1cmVGdW5jdGlvblNsb3RzO1xuICAgIH1cbiAgICBnZXRDb25zdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25zdGFudHM7XG4gICAgfVxuICAgIGdldE5nQ29udGVudFNlbGVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25nQ29udGVudFJlc2VydmVkU2xvdHMubGVuZ3RoID9cbiAgICAgICAgICAgIHRoaXMuY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChhc0xpdGVyYWwodGhpcy5fbmdDb250ZW50UmVzZXJ2ZWRTbG90cyksIHRydWUpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGJpbmRpbmdDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5fYmluZGluZ0NvbnRleHQrK31gO1xuICAgIH1cbiAgICB0ZW1wbGF0ZVByb3BlcnR5QmluZGluZ3ModGVtcGxhdGVJbmRleCwgYXR0cnMpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGF0dHJzKSB7XG4gICAgICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIEJvdW5kQXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC52YWx1ZS52aXNpdCh0aGlzLl92YWx1ZUNvbnZlcnRlcik7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyYW1zIHR5cGljYWxseSBjb250YWluIGF0dHJpYnV0ZSBuYW1lc3BhY2UgYW5kIHZhbHVlIHNhbml0aXplciwgd2hpY2ggaXMgYXBwbGljYWJsZVxuICAgICAgICAgICAgICAgIC8vIGZvciByZWd1bGFyIEhUTUwgZWxlbWVudHMsIGJ1dCBub3QgYXBwbGljYWJsZSBmb3IgPG5nLXRlbXBsYXRlPiAoc2luY2UgcHJvcHMgYWN0IGFzXG4gICAgICAgICAgICAgICAgLy8gaW5wdXRzIHRvIGRpcmVjdGl2ZXMpLCBzbyBrZWVwIHBhcmFtcyBhcnJheSBlbXB0eS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBwcm9wPVwie3t2YWx1ZX19XCIgY2FzZVxuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJwb2xhdGVkVXBkYXRlSW5zdHJ1Y3Rpb24oZ2V0UHJvcGVydHlJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbih2YWx1ZSksIHRlbXBsYXRlSW5kZXgsIGlucHV0Lm5hbWUsIGlucHV0LCB2YWx1ZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFtwcm9wXT1cInZhbHVlXCIgY2FzZVxuICAgICAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGlucHV0LnNvdXJjZVNwYW4sXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc09yRm46IGdldEJpbmRpbmdGdW5jdGlvblBhcmFtcygoKSA9PiB0aGlzLmNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodmFsdWUpLCBpbnB1dC5uYW1lKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlCaW5kaW5nIG9mIHByb3BlcnR5QmluZGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZSh0ZW1wbGF0ZUluZGV4LCBwcm9wZXJ0eUJpbmRpbmcuc3BhbiwgSWRlbnRpZmllcnMucHJvcGVydHksIHByb3BlcnR5QmluZGluZy5wYXJhbXNPckZuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCaW5kaW5ncyBtdXN0IG9ubHkgYmUgcmVzb2x2ZWQgYWZ0ZXIgYWxsIGxvY2FsIHJlZnMgaGF2ZSBiZWVuIHZpc2l0ZWQsIHNvIGFsbFxuICAgIC8vIGluc3RydWN0aW9ucyBhcmUgcXVldWVkIGluIGNhbGxiYWNrcyB0aGF0IGV4ZWN1dGUgb25jZSB0aGUgaW5pdGlhbCBwYXNzIGhhcyBjb21wbGV0ZWQuXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIHN1cHBvcnQgbG9jYWwgcmVmcyB0aGF0IGFyZSBkZWZpbmVkIGFmdGVyIHRoZWlyXG4gICAgLy8gYmluZGluZ3MuIGUuZy4ge3sgZm9vIH19IDxkaXYgI2Zvbz48L2Rpdj5cbiAgICBpbnN0cnVjdGlvbkZuKGZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuLCBwcmVwZW5kID0gZmFsc2UpIHtcbiAgICAgICAgZm5zW3ByZXBlbmQgPyAndW5zaGlmdCcgOiAncHVzaCddKHsgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3R5bGluZ1VwZGF0ZUluc3RydWN0aW9uKGVsZW1lbnRJbmRleCwgaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgbGV0IGFsbG9jYXRlQmluZGluZ1Nsb3RzID0gMDtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgaW5zdHJ1Y3Rpb24uY2FsbHMpIHtcbiAgICAgICAgICAgICAgICBhbGxvY2F0ZUJpbmRpbmdTbG90cyArPSBjYWxsLmFsbG9jYXRlQmluZGluZ1Nsb3RzO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZShlbGVtZW50SW5kZXgsIGNhbGwuc291cmNlU3BhbiwgaW5zdHJ1Y3Rpb24ucmVmZXJlbmNlLCAoKSA9PiBjYWxsLnBhcmFtcyh2YWx1ZSA9PiAoY2FsbC5zdXBwb3J0c0ludGVycG9sYXRpb24gJiYgdmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VXBkYXRlSW5zdHJ1Y3Rpb25Bcmd1bWVudHModmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxvY2F0ZUJpbmRpbmdTbG90cztcbiAgICB9XG4gICAgY3JlYXRpb25JbnN0cnVjdGlvbihzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4sIHByZXBlbmQpIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbkZuKHRoaXMuX2NyZWF0aW9uQ29kZUZucywgc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuIHx8IFtdLCBwcmVwZW5kKTtcbiAgICB9XG4gICAgdXBkYXRlSW5zdHJ1Y3Rpb25XaXRoQWR2YW5jZShub2RlSW5kZXgsIHNwYW4sIHJlZmVyZW5jZSwgcGFyYW1zT3JGbikge1xuICAgICAgICB0aGlzLmFkZEFkdmFuY2VJbnN0cnVjdGlvbklmTmVjZXNzYXJ5KG5vZGVJbmRleCwgc3Bhbik7XG4gICAgICAgIHRoaXMudXBkYXRlSW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuKTtcbiAgICB9XG4gICAgdXBkYXRlSW5zdHJ1Y3Rpb24oc3BhbiwgcmVmZXJlbmNlLCBwYXJhbXNPckZuKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Gbih0aGlzLl91cGRhdGVDb2RlRm5zLCBzcGFuLCByZWZlcmVuY2UsIHBhcmFtc09yRm4gfHwgW10pO1xuICAgIH1cbiAgICBhZGRBZHZhbmNlSW5zdHJ1Y3Rpb25JZk5lY2Vzc2FyeShub2RlSW5kZXgsIHNwYW4pIHtcbiAgICAgICAgaWYgKG5vZGVJbmRleCAhPT0gdGhpcy5fY3VycmVudEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IG5vZGVJbmRleCAtIHRoaXMuX2N1cnJlbnRJbmRleDtcbiAgICAgICAgICAgIGlmIChkZWx0YSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkdmFuY2UgaW5zdHJ1Y3Rpb24gY2FuIG9ubHkgZ28gZm9yd2FyZHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25Gbih0aGlzLl91cGRhdGVDb2RlRm5zLCBzcGFuLCBJZGVudGlmaWVycy5hZHZhbmNlLCBbbGl0ZXJhbChkZWx0YSldKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IG5vZGVJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKG51bVNsb3RzKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsU2xvdHMgPSB0aGlzLl9wdXJlRnVuY3Rpb25TbG90cztcbiAgICAgICAgdGhpcy5fcHVyZUZ1bmN0aW9uU2xvdHMgKz0gbnVtU2xvdHM7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFNsb3RzO1xuICAgIH1cbiAgICBhbGxvY2F0ZUJpbmRpbmdTbG90cyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iaW5kaW5nU2xvdHMgKz0gdmFsdWUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0aW9uID8gdmFsdWUuZXhwcmVzc2lvbnMubGVuZ3RoIDogMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBleHByZXNzaW9uIHRoYXQgcmVmZXJzIHRvIHRoZSBpbXBsaWNpdCByZWNlaXZlci4gVGhlIGltcGxpY2l0XG4gICAgICogcmVjZWl2ZXIgaXMgYWx3YXlzIHRoZSByb290IGxldmVsIGNvbnRleHQuXG4gICAgICovXG4gICAgZ2V0SW1wbGljaXRSZWNlaXZlckV4cHIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ltcGxpY2l0UmVjZWl2ZXJFeHByO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbXBsaWNpdFJlY2VpdmVyRXhwciA9IHRoaXMubGV2ZWwgPT09IDAgP1xuICAgICAgICAgICAgdmFyaWFibGUoQ09OVEVYVF9OQU1FKSA6XG4gICAgICAgICAgICB0aGlzLl9iaW5kaW5nU2NvcGUuZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyKDApO1xuICAgIH1cbiAgICBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlZFByb3BlcnR5QmluZGluZyA9IGNvbnZlcnRQcm9wZXJ0eUJpbmRpbmcodGhpcywgdGhpcy5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwcigpLCB2YWx1ZSwgdGhpcy5iaW5kaW5nQ29udGV4dCgpKTtcbiAgICAgICAgY29uc3QgdmFsRXhwciA9IGNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5jdXJyVmFsRXhwcjtcbiAgICAgICAgdGhpcy5fdGVtcFZhcmlhYmxlcy5wdXNoKC4uLmNvbnZlcnRlZFByb3BlcnR5QmluZGluZy5zdG10cyk7XG4gICAgICAgIHJldHVybiB2YWxFeHByO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhcmd1bWVudCBleHByZXNzaW9ucyB0byBwYXNzIHRvIGFuIHVwZGF0ZSBpbnN0cnVjdGlvbiBleHByZXNzaW9uLiBBbHNvIHVwZGF0ZXNcbiAgICAgKiB0aGUgdGVtcCB2YXJpYWJsZXMgc3RhdGUgd2l0aCB0ZW1wIHZhcmlhYmxlcyB0aGF0IHdlcmUgaWRlbnRpZmllZCBhcyBuZWVkaW5nIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiB3aGlsZSB2aXNpdGluZyB0aGUgYXJndW1lbnRzLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgb3JpZ2luYWwgZXhwcmVzc2lvbiB3ZSB3aWxsIGJlIHJlc29sdmluZyBhbiBhcmd1bWVudHMgbGlzdCBmcm9tLlxuICAgICAqL1xuICAgIGdldFVwZGF0ZUluc3RydWN0aW9uQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHsgYXJncywgc3RtdHMgfSA9IGNvbnZlcnRVcGRhdGVBcmd1bWVudHModGhpcywgdGhpcy5nZXRJbXBsaWNpdFJlY2VpdmVyRXhwcigpLCB2YWx1ZSwgdGhpcy5iaW5kaW5nQ29udGV4dCgpKTtcbiAgICAgICAgdGhpcy5fdGVtcFZhcmlhYmxlcy5wdXNoKC4uLnN0bXRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGFsbCBhdHRyaWJ1dGUgZXhwcmVzc2lvbiB2YWx1ZXMgZm9yIHRoZSBgVEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBwcm9wZXJseSBjb25zdHJ1Y3QgYW4gYXR0cmlidXRlcyBhcnJheSB0aGF0XG4gICAgICogaXMgcGFzc2VkIGludG8gdGhlIGBlbGVtZW50U3RhcnRgIChvciBqdXN0IGBlbGVtZW50YCkgZnVuY3Rpb25zLiBCZWNhdXNlIHRoZXJlXG4gICAgICogYXJlIG1hbnkgZGlmZmVyZW50IHR5cGVzIG9mIGF0dHJpYnV0ZXMsIHRoZSBhcnJheSBuZWVkcyB0byBiZSBjb25zdHJ1Y3RlZCBpbiBhXG4gICAgICogc3BlY2lhbCB3YXkgc28gdGhhdCBgZWxlbWVudFN0YXJ0YCBjYW4gcHJvcGVybHkgZXZhbHVhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqIFRoZSBmb3JtYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogYXR0cnMgPSBbcHJvcCwgdmFsdWUsIHByb3AyLCB2YWx1ZTIsXG4gICAgICogICBQUk9KRUNUX0FTLCBzZWxlY3RvcixcbiAgICAgKiAgIENMQVNTRVMsIGNsYXNzMSwgY2xhc3MyLFxuICAgICAqICAgU1RZTEVTLCBzdHlsZTEsIHZhbHVlMSwgc3R5bGUyLCB2YWx1ZTIsXG4gICAgICogICBCSU5ESU5HUywgbmFtZTEsIG5hbWUyLCBuYW1lMyxcbiAgICAgKiAgIFRFTVBMQVRFLCBuYW1lNCwgbmFtZTUsIG5hbWU2LFxuICAgICAqICAgSTE4TiwgbmFtZTcsIG5hbWU4LCAuLi5dXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiB3aWxsIGZ1bGx5IGlnbm9yZSBhbGwgc3ludGhldGljIChAZm9vKSBhdHRyaWJ1dGUgdmFsdWVzXG4gICAgICogYmVjYXVzZSB0aG9zZSB2YWx1ZXMgYXJlIGludGVuZGVkIHRvIGFsd2F5cyBiZSBnZW5lcmF0ZWQgYXMgcHJvcGVydHkgaW5zdHJ1Y3Rpb25zLlxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnROYW1lLCByZW5kZXJBdHRyaWJ1dGVzLCBpbnB1dHMsIG91dHB1dHMsIHN0eWxlcywgdGVtcGxhdGVBdHRycyA9IFtdLCBib3VuZEkxOG5BdHRycyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IGFscmVhZHlTZWVuID0gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBhdHRyRXhwcnMgPSBbXTtcbiAgICAgICAgbGV0IG5nUHJvamVjdEFzQXR0cjtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHJlbmRlckF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IE5HX1BST0pFQ1RfQVNfQVRUUl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgbmdQcm9qZWN0QXNBdHRyID0gYXR0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBzdGF0aWMgaTE4biBhdHRyaWJ1dGVzIGFyZW4ndCBpbiB0aGUgaTE4biBhcnJheSxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSB0cmVhdGVkIGluIHRoZSBzYW1lIHdheSBhcyByZWd1bGFyIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICBpZiAoYXR0ci5pMThuKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBpMThuIGF0dHJpYnV0ZXMgYXJlIHByZXNlbnQgb24gZWxlbWVudHMgd2l0aCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICAgICAgICAvLyAoZS5nLiBgPGRpdiAqbmdJZiB0aXRsZT1cIkhlbGxvXCIgaTE4bi10aXRsZT5gKSwgd2Ugd2FudCB0byBhdm9pZCBnZW5lcmF0aW5nXG4gICAgICAgICAgICAgICAgLy8gZHVwbGljYXRlIGkxOG4gdHJhbnNsYXRpb24gYmxvY2tzIGZvciBgybXJtXRlbXBsYXRlYCBhbmQgYMm1ybVlbGVtZW50YCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuIFNvIHdlIGRvIGEgY2FjaGUgbG9va3VwIHRvIHNlZSBpZiBzdWl0YWJsZSBpMThuIHRyYW5zbGF0aW9uIGJsb2NrXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBleGlzdHMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpMThuVmFyUmVmc0NhY2hlIH0gPSB0aGlzLl9jb25zdGFudHM7XG4gICAgICAgICAgICAgICAgbGV0IGkxOG5WYXJSZWY7XG4gICAgICAgICAgICAgICAgaWYgKGkxOG5WYXJSZWZzQ2FjaGUuaGFzKGF0dHIuaTE4bikpIHtcbiAgICAgICAgICAgICAgICAgICAgaTE4blZhclJlZiA9IGkxOG5WYXJSZWZzQ2FjaGUuZ2V0KGF0dHIuaTE4bik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpMThuVmFyUmVmID0gdGhpcy5pMThuVHJhbnNsYXRlKGF0dHIuaTE4bik7XG4gICAgICAgICAgICAgICAgICAgIGkxOG5WYXJSZWZzQ2FjaGUuc2V0KGF0dHIuaTE4biwgaTE4blZhclJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoYXR0ci5uYW1lKSwgaTE4blZhclJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMoYXR0ci5uYW1lKSwgdHJ1c3RlZENvbnN0QXR0cmlidXRlKGVsZW1lbnROYW1lLCBhdHRyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBuZ1Byb2plY3RBcyBuZXh0IHRvIHRoZSBvdGhlciBuYW1lLCB2YWx1ZSBwYWlycyBzbyB3ZSBjYW4gdmVyaWZ5IHRoYXQgd2UgbWF0Y2hcbiAgICAgICAgLy8gbmdQcm9qZWN0QXMgbWFya2VyIGluIHRoZSBhdHRyaWJ1dGUgbmFtZSBzbG90LlxuICAgICAgICBpZiAobmdQcm9qZWN0QXNBdHRyKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXROZ1Byb2plY3RBc0xpdGVyYWwobmdQcm9qZWN0QXNBdHRyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQXR0ckV4cHIoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbHJlYWR5U2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaCguLi5nZXRBdHRyaWJ1dGVOYW1lTGl0ZXJhbHMoa2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgYXR0ckV4cHJzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5U2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBvY2N1cnMgYmVmb3JlIEJJTkRJTkdTIGFuZCBURU1QTEFURSBiZWNhdXNlIG9uY2UgYGVsZW1lbnRTdGFydGBcbiAgICAgICAgLy8gY29tZXMgYWNyb3NzIHRoZSBCSU5ESU5HUyBvciBURU1QTEFURSBtYXJrZXJzIHRoZW4gaXQgd2lsbCBjb250aW51ZSByZWFkaW5nIGVhY2ggdmFsdWUgYXNcbiAgICAgICAgLy8gYXMgc2luZ2xlIHByb3BlcnR5IHZhbHVlIGNlbGwgYnkgY2VsbC5cbiAgICAgICAgaWYgKHN0eWxlcykge1xuICAgICAgICAgICAgc3R5bGVzLnBvcHVsYXRlSW5pdGlhbFN0eWxpbmdBdHRycyhhdHRyRXhwcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHMubGVuZ3RoIHx8IG91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyc0xlbmd0aEJlZm9yZUlucHV0cyA9IGF0dHJFeHBycy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdGhlIGFuaW1hdGlvbiBhbmQgYXR0cmlidXRlIGJpbmRpbmdzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXJyYXkgc2luY2UgdGhleSBhcmVuJ3QgdXNlZCBmb3IgZGlyZWN0aXZlIG1hdGNoaW5nLlxuICAgICAgICAgICAgICAgIGlmIChpbnB1dC50eXBlICE9PSA0IC8qIEJpbmRpbmdUeXBlLkFuaW1hdGlvbiAqLyAmJiBpbnB1dC50eXBlICE9PSAxIC8qIEJpbmRpbmdUeXBlLkF0dHJpYnV0ZSAqLykge1xuICAgICAgICAgICAgICAgICAgICBhZGRBdHRyRXhwcihpbnB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvdXRwdXQudHlwZSAhPT0gMSAvKiBQYXJzZWRFdmVudFR5cGUuQW5pbWF0aW9uICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEF0dHJFeHByKG91dHB1dC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgY2hlYXAgd2F5IG9mIGFkZGluZyB0aGUgbWFya2VyIG9ubHkgYWZ0ZXIgYWxsIHRoZSBpbnB1dC9vdXRwdXRcbiAgICAgICAgICAgIC8vIHZhbHVlcyBoYXZlIGJlZW4gZmlsdGVyZWQgKGJ5IG5vdCBpbmNsdWRpbmcgdGhlIGFuaW1hdGlvbiBvbmVzKSBhbmQgYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBleHByZXNzaW9ucy4gVGhlIG1hcmtlciBpcyBpbXBvcnRhbnQgYmVjYXVzZSBpdCB0ZWxscyB0aGUgcnVudGltZVxuICAgICAgICAgICAgLy8gY29kZSB0aGF0IHRoaXMgaXMgd2hlcmUgYXR0cmlidXRlcyB3aXRob3V0IHZhbHVlcyBzdGFydC4uLlxuICAgICAgICAgICAgaWYgKGF0dHJFeHBycy5sZW5ndGggIT09IGF0dHJzTGVuZ3RoQmVmb3JlSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgYXR0ckV4cHJzLnNwbGljZShhdHRyc0xlbmd0aEJlZm9yZUlucHV0cywgMCwgbGl0ZXJhbCgzIC8qIGNvcmUuQXR0cmlidXRlTWFya2VyLkJpbmRpbmdzICovKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBsYXRlQXR0cnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhdHRyRXhwcnMucHVzaChsaXRlcmFsKDQgLyogY29yZS5BdHRyaWJ1dGVNYXJrZXIuVGVtcGxhdGUgKi8pKTtcbiAgICAgICAgICAgIHRlbXBsYXRlQXR0cnMuZm9yRWFjaChhdHRyID0+IGFkZEF0dHJFeHByKGF0dHIubmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZEkxOG5BdHRycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF0dHJFeHBycy5wdXNoKGxpdGVyYWwoNiAvKiBjb3JlLkF0dHJpYnV0ZU1hcmtlci5JMThuICovKSk7XG4gICAgICAgICAgICBib3VuZEkxOG5BdHRycy5mb3JFYWNoKGF0dHIgPT4gYWRkQXR0ckV4cHIoYXR0ci5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJFeHBycztcbiAgICB9XG4gICAgYWRkVG9Db25zdHMoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAoaXNOdWxsKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gVFlQRURfTlVMTF9FWFBSO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnN0cyA9IHRoaXMuX2NvbnN0YW50cy5jb25zdEV4cHJlc3Npb25zO1xuICAgICAgICAvLyBUcnkgdG8gcmV1c2UgYSBsaXRlcmFsIHRoYXQncyBhbHJlYWR5IGluIHRoZSBhcnJheSwgaWYgcG9zc2libGUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29uc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RzW2ldLmlzRXF1aXZhbGVudChleHByZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXRlcmFsKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXRlcmFsKGNvbnN0cy5wdXNoKGV4cHJlc3Npb24pIC0gMSk7XG4gICAgfVxuICAgIGFkZEF0dHJzVG9Db25zdHMoYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZFRvQ29uc3RzKGxpdGVyYWxBcnIoYXR0cnMpKSA6IFRZUEVEX05VTExfRVhQUjtcbiAgICB9XG4gICAgcHJlcGFyZVJlZnNBcnJheShyZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmICghcmVmZXJlbmNlcyB8fCByZWZlcmVuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRZUEVEX05VTExfRVhQUjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZzUGFyYW0gPSByZWZlcmVuY2VzLmZsYXRNYXAocmVmZXJlbmNlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3QgPSB0aGlzLmFsbG9jYXRlRGF0YVNsb3QoKTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB1cGRhdGUgdGVtcG9yYXJ5LlxuICAgICAgICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gdGhpcy5fYmluZGluZ1Njb3BlLmZyZXNoUmVmZXJlbmNlTmFtZSgpO1xuICAgICAgICAgICAgY29uc3QgcmV0cmlldmFsTGV2ZWwgPSB0aGlzLmxldmVsO1xuICAgICAgICAgICAgY29uc3QgbGhzID0gdmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRpbmdTY29wZS5zZXQocmV0cmlldmFsTGV2ZWwsIHJlZmVyZW5jZS5uYW1lLCBsaHMsIDAgLyogRGVjbGFyYXRpb25Qcmlvcml0eS5ERUZBVUxUICovLCAoc2NvcGUsIHJlbGF0aXZlTGV2ZWwpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBlLmcuIG5leHRDb250ZXh0KDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDb250ZXh0U3RtdCA9IHJlbGF0aXZlTGV2ZWwgPiAwID8gW2dlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWwpLnRvU3RtdCgpXSA6IFtdO1xuICAgICAgICAgICAgICAgIC8vIGUuZy4gY29uc3QgJGZvbyQgPSByZWZlcmVuY2UoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmRXhwciA9IGxocy5zZXQoaW1wb3J0RXhwcihJZGVudGlmaWVycy5yZWZlcmVuY2UpLmNhbGxGbihbbGl0ZXJhbChzbG90KV0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENvbnRleHRTdG10LmNvbmNhdChyZWZFeHByLnRvQ29uc3REZWNsKCkpO1xuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gW3JlZmVyZW5jZS5uYW1lLCByZWZlcmVuY2UudmFsdWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFzTGl0ZXJhbChyZWZzUGFyYW0pO1xuICAgIH1cbiAgICBwcmVwYXJlTGlzdGVuZXJQYXJhbWV0ZXIodGFnTmFtZSwgb3V0cHV0QXN0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gb3V0cHV0QXN0Lm5hbWU7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nRm5OYW1lID0gb3V0cHV0QXN0LnR5cGUgPT09IDEgLyogUGFyc2VkRXZlbnRUeXBlLkFuaW1hdGlvbiAqLyA/XG4gICAgICAgICAgICAgICAgLy8gc3ludGhldGljIEBsaXN0ZW5lci5mb28gdmFsdWVzIGFyZSB0cmVhdGVkIHRoZSBleGFjdCBzYW1lIGFzIGFyZSBzdGFuZGFyZCBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICBwcmVwYXJlU3ludGhldGljTGlzdGVuZXJGdW5jdGlvbk5hbWUoZXZlbnROYW1lLCBvdXRwdXRBc3QucGhhc2UpIDpcbiAgICAgICAgICAgICAgICBzYW5pdGl6ZUlkZW50aWZpZXIoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJOYW1lID0gYCR7dGhpcy50ZW1wbGF0ZU5hbWV9XyR7dGFnTmFtZX1fJHtiaW5kaW5nRm5OYW1lfV8ke2luZGV4fV9saXN0ZW5lcmA7XG4gICAgICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuX2JpbmRpbmdTY29wZS5uZXN0ZWRTY29wZSh0aGlzLl9iaW5kaW5nU2NvcGUuYmluZGluZ0xldmVsLCBFVkVOVF9CSU5ESU5HX1NDT1BFX0dMT0JBTFMpO1xuICAgICAgICAgICAgcmV0dXJuIHByZXBhcmVFdmVudExpc3RlbmVyUGFyYW1ldGVycyhvdXRwdXRBc3QsIGhhbmRsZXJOYW1lLCBzY29wZSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgVmFsdWVDb252ZXJ0ZXIgZXh0ZW5kcyBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RhbnRQb29sLCBhbGxvY2F0ZVNsb3QsIGFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMsIGRlZmluZVBpcGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb25zdGFudFBvb2wgPSBjb25zdGFudFBvb2w7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVTbG90ID0gYWxsb2NhdGVTbG90O1xuICAgICAgICB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMgPSBhbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUgPSBkZWZpbmVQaXBlO1xuICAgICAgICB0aGlzLl9waXBlQmluZEV4cHJzID0gW107XG4gICAgfVxuICAgIC8vIEFzdE1lbW9yeUVmZmljaWVudFRyYW5zZm9ybWVyXG4gICAgdmlzaXRQaXBlKHBpcGUsIGNvbnRleHQpIHtcbiAgICAgICAgLy8gQWxsb2NhdGUgYSBzbG90IHRvIGNyZWF0ZSB0aGUgcGlwZVxuICAgICAgICBjb25zdCBzbG90ID0gdGhpcy5hbGxvY2F0ZVNsb3QoKTtcbiAgICAgICAgY29uc3Qgc2xvdFBzZXVkb0xvY2FsID0gYFBJUEU6JHtzbG90fWA7XG4gICAgICAgIC8vIEFsbG9jYXRlIG9uZSBzbG90IGZvciB0aGUgcmVzdWx0IHBsdXMgb25lIHNsb3QgcGVyIHBpcGUgYXJndW1lbnRcbiAgICAgICAgY29uc3QgcHVyZUZ1bmN0aW9uU2xvdCA9IHRoaXMuYWxsb2NhdGVQdXJlRnVuY3Rpb25TbG90cygyICsgcGlwZS5hcmdzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG5ldyBQcm9wZXJ0eVJlYWQocGlwZS5zcGFuLCBwaXBlLnNvdXJjZVNwYW4sIHBpcGUubmFtZVNwYW4sIG5ldyBJbXBsaWNpdFJlY2VpdmVyKHBpcGUuc3BhbiwgcGlwZS5zb3VyY2VTcGFuKSwgc2xvdFBzZXVkb0xvY2FsKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBpc1Zhckxlbmd0aCB9ID0gcGlwZUJpbmRpbmdDYWxsSW5mbyhwaXBlLmFyZ3MpO1xuICAgICAgICB0aGlzLmRlZmluZVBpcGUocGlwZS5uYW1lLCBzbG90UHNldWRvTG9jYWwsIHNsb3QsIGltcG9ydEV4cHIoaWRlbnRpZmllcikpO1xuICAgICAgICBjb25zdCBhcmdzID0gW3BpcGUuZXhwLCAuLi5waXBlLmFyZ3NdO1xuICAgICAgICBjb25zdCBjb252ZXJ0ZWRBcmdzID0gaXNWYXJMZW5ndGggP1xuICAgICAgICAgICAgdGhpcy52aXNpdEFsbChbbmV3IExpdGVyYWxBcnJheShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgYXJncyldKSA6XG4gICAgICAgICAgICB0aGlzLnZpc2l0QWxsKGFyZ3MpO1xuICAgICAgICBjb25zdCBwaXBlQmluZEV4cHIgPSBuZXcgQ2FsbChwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgdGFyZ2V0LCBbXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3Bhbiwgc2xvdCksXG4gICAgICAgICAgICBuZXcgTGl0ZXJhbFByaW1pdGl2ZShwaXBlLnNwYW4sIHBpcGUuc291cmNlU3BhbiwgcHVyZUZ1bmN0aW9uU2xvdCksXG4gICAgICAgICAgICAuLi5jb252ZXJ0ZWRBcmdzLFxuICAgICAgICBdLCBudWxsKTtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5wdXNoKHBpcGVCaW5kRXhwcik7XG4gICAgICAgIHJldHVybiBwaXBlQmluZEV4cHI7XG4gICAgfVxuICAgIHVwZGF0ZVBpcGVTbG90T2Zmc2V0cyhiaW5kaW5nU2xvdHMpIHtcbiAgICAgICAgdGhpcy5fcGlwZUJpbmRFeHBycy5mb3JFYWNoKChwaXBlKSA9PiB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNsb3Qgb2Zmc2V0IGFyZyAoaW5kZXggMSkgdG8gYWNjb3VudCBmb3IgYmluZGluZyBzbG90c1xuICAgICAgICAgICAgY29uc3Qgc2xvdE9mZnNldCA9IHBpcGUuYXJnc1sxXTtcbiAgICAgICAgICAgIHNsb3RPZmZzZXQudmFsdWUgKz0gYmluZGluZ1Nsb3RzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmlzaXRMaXRlcmFsQXJyYXkoYXJyYXksIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKGFycmF5LnNwYW4sIGFycmF5LnNvdXJjZVNwYW4sIHRoaXMudmlzaXRBbGwoYXJyYXkuZXhwcmVzc2lvbnMpLCB2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGxpdGVyYWwgaGFzIGNhbGN1bGF0ZWQgKG5vbi1saXRlcmFsKSBlbGVtZW50cyB0cmFuc2Zvcm0gaXQgaW50b1xuICAgICAgICAgICAgLy8gY2FsbHMgdG8gbGl0ZXJhbCBmYWN0b3JpZXMgdGhhdCBjb21wb3NlIHRoZSBsaXRlcmFsIGFuZCB3aWxsIGNhY2hlIGludGVybWVkaWF0ZVxuICAgICAgICAgICAgLy8gdmFsdWVzLlxuICAgICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IGxpdGVyYWxBcnIodmFsdWVzKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRMaXRlcmFsRmFjdG9yeSh0aGlzLmNvbnN0YW50UG9vbCwgbGl0ZXJhbCwgdGhpcy5hbGxvY2F0ZVB1cmVGdW5jdGlvblNsb3RzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0TGl0ZXJhbE1hcChtYXAsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWlsdGluRnVuY3Rpb25DYWxsKG1hcC5zcGFuLCBtYXAuc291cmNlU3BhbiwgdGhpcy52aXNpdEFsbChtYXAudmFsdWVzKSwgdmFsdWVzID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBsaXRlcmFsIGhhcyBjYWxjdWxhdGVkIChub24tbGl0ZXJhbCkgZWxlbWVudHMgIHRyYW5zZm9ybSBpdCBpbnRvXG4gICAgICAgICAgICAvLyBjYWxscyB0byBsaXRlcmFsIGZhY3RvcmllcyB0aGF0IGNvbXBvc2UgdGhlIGxpdGVyYWwgYW5kIHdpbGwgY2FjaGUgaW50ZXJtZWRpYXRlXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXG4gICAgICAgICAgICBjb25zdCBsaXRlcmFsID0gbGl0ZXJhbE1hcCh2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+ICh7IGtleTogbWFwLmtleXNbaW5kZXhdLmtleSwgdmFsdWUsIHF1b3RlZDogbWFwLmtleXNbaW5kZXhdLnF1b3RlZCB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuIGdldExpdGVyYWxGYWN0b3J5KHRoaXMuY29uc3RhbnRQb29sLCBsaXRlcmFsLCB0aGlzLmFsbG9jYXRlUHVyZUZ1bmN0aW9uU2xvdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyBQaXBlcyBhbHdheXMgaGF2ZSBhdCBsZWFzdCBvbmUgcGFyYW1ldGVyLCB0aGUgdmFsdWUgdGhleSBvcGVyYXRlIG9uXG5jb25zdCBwaXBlQmluZGluZ0lkZW50aWZpZXJzID0gW0lkZW50aWZpZXJzLnBpcGVCaW5kMSwgSWRlbnRpZmllcnMucGlwZUJpbmQyLCBJZGVudGlmaWVycy5waXBlQmluZDMsIElkZW50aWZpZXJzLnBpcGVCaW5kNF07XG5mdW5jdGlvbiBwaXBlQmluZGluZ0NhbGxJbmZvKGFyZ3MpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gcGlwZUJpbmRpbmdJZGVudGlmaWVyc1thcmdzLmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllciB8fCBJZGVudGlmaWVycy5waXBlQmluZFYsXG4gICAgICAgIGlzVmFyTGVuZ3RoOiAhaWRlbnRpZmllcixcbiAgICB9O1xufVxuY29uc3QgcHVyZUZ1bmN0aW9uSWRlbnRpZmllcnMgPSBbXG4gICAgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMCwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMSwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMiwgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uMywgSWRlbnRpZmllcnMucHVyZUZ1bmN0aW9uNCxcbiAgICBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb241LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb242LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb243LCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb244XG5dO1xuZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2FsbEluZm8oYXJncykge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBwdXJlRnVuY3Rpb25JZGVudGlmaWVyc1thcmdzLmxlbmd0aF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllciB8fCBJZGVudGlmaWVycy5wdXJlRnVuY3Rpb25WLFxuICAgICAgICBpc1Zhckxlbmd0aDogIWlkZW50aWZpZXIsXG4gICAgfTtcbn1cbi8vIGUuZy4geCgyKTtcbmZ1bmN0aW9uIGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWxEaWZmKSB7XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMubmV4dENvbnRleHQpXG4gICAgICAgIC5jYWxsRm4ocmVsYXRpdmVMZXZlbERpZmYgPiAxID8gW2xpdGVyYWwocmVsYXRpdmVMZXZlbERpZmYpXSA6IFtdKTtcbn1cbmZ1bmN0aW9uIGdldExpdGVyYWxGYWN0b3J5KGNvbnN0YW50UG9vbCwgbGl0ZXJhbCQxLCBhbGxvY2F0ZVNsb3RzKSB7XG4gICAgY29uc3QgeyBsaXRlcmFsRmFjdG9yeSwgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMgfSA9IGNvbnN0YW50UG9vbC5nZXRMaXRlcmFsRmFjdG9yeShsaXRlcmFsJDEpO1xuICAgIC8vIEFsbG9jYXRlIDEgc2xvdCBmb3IgdGhlIHJlc3VsdCBwbHVzIDEgcGVyIGFyZ3VtZW50XG4gICAgY29uc3Qgc3RhcnRTbG90ID0gYWxsb2NhdGVTbG90cygxICsgbGl0ZXJhbEZhY3RvcnlBcmd1bWVudHMubGVuZ3RoKTtcbiAgICBjb25zdCB7IGlkZW50aWZpZXIsIGlzVmFyTGVuZ3RoIH0gPSBwdXJlRnVuY3Rpb25DYWxsSW5mbyhsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cyk7XG4gICAgLy8gTGl0ZXJhbCBmYWN0b3JpZXMgYXJlIHB1cmUgZnVuY3Rpb25zIHRoYXQgb25seSBuZWVkIHRvIGJlIHJlLWludm9rZWQgd2hlbiB0aGUgcGFyYW1ldGVyc1xuICAgIC8vIGNoYW5nZS5cbiAgICBjb25zdCBhcmdzID0gW2xpdGVyYWwoc3RhcnRTbG90KSwgbGl0ZXJhbEZhY3RvcnldO1xuICAgIGlmIChpc1Zhckxlbmd0aCkge1xuICAgICAgICBhcmdzLnB1c2gobGl0ZXJhbEFycihsaXRlcmFsRmFjdG9yeUFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKC4uLmxpdGVyYWxGYWN0b3J5QXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydEV4cHIoaWRlbnRpZmllcikuY2FsbEZuKGFyZ3MpO1xufVxuLyoqXG4gKiBHZXRzIGFuIGFycmF5IG9mIGxpdGVyYWxzIHRoYXQgY2FuIGJlIGFkZGVkIHRvIGFuIGV4cHJlc3Npb25cbiAqIHRvIHJlcHJlc2VudCB0aGUgbmFtZSBhbmQgbmFtZXNwYWNlIG9mIGFuIGF0dHJpYnV0ZS4gRS5nLlxuICogYDp4bGluazpocmVmYCB0dXJucyBpbnRvIGBbQXR0cmlidXRlTWFya2VyLk5hbWVzcGFjZVVSSSwgJ3hsaW5rJywgJ2hyZWYnXWAuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlLCBpbmNsdWRpbmcgdGhlIG5hbWVzcGFjZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTmFtZUxpdGVyYWxzKG5hbWUpIHtcbiAgICBjb25zdCBbYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lXSA9IHNwbGl0TnNOYW1lKG5hbWUpO1xuICAgIGNvbnN0IG5hbWVMaXRlcmFsID0gbGl0ZXJhbChhdHRyaWJ1dGVOYW1lKTtcbiAgICBpZiAoYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsaXRlcmFsKDAgLyogY29yZS5BdHRyaWJ1dGVNYXJrZXIuTmFtZXNwYWNlVVJJICovKSwgbGl0ZXJhbChhdHRyaWJ1dGVOYW1lc3BhY2UpLCBuYW1lTGl0ZXJhbFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW25hbWVMaXRlcmFsXTtcbn1cbi8qKiBUaGUgcHJlZml4IHVzZWQgdG8gZ2V0IGEgc2hhcmVkIGNvbnRleHQgaW4gQmluZGluZ1Njb3BlJ3MgbWFwLiAqL1xuY29uc3QgU0hBUkVEX0NPTlRFWFRfS0VZID0gJyQkc2hhcmVkX2N0eCQkJztcbmNsYXNzIEJpbmRpbmdTY29wZSB7XG4gICAgc3RhdGljIGNyZWF0ZVJvb3RTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5kaW5nU2NvcGUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYmluZGluZ0xldmVsID0gMCwgcGFyZW50ID0gbnVsbCwgZ2xvYmFscykge1xuICAgICAgICB0aGlzLmJpbmRpbmdMZXZlbCA9IGJpbmRpbmdMZXZlbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICAgIC8qKiBLZWVwcyBhIG1hcCBmcm9tIGxvY2FsIHZhcmlhYmxlcyB0byB0aGVpciBCaW5kaW5nRGF0YS4gKi9cbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlTmFtZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlID0gbnVsbDtcbiAgICAgICAgdGhpcy51c2VzUmVzdG9yZWRWaWV3Q29udGV4dCA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2xvYmFscyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZ2xvYmFscykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KDAsIG5hbWUsIHZhcmlhYmxlKG5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBjdXJyZW50Lm1hcC5nZXQobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBsb2NhbCBjb3B5IGFuZCByZXNldCB0aGUgYGRlY2xhcmVgIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHZhbHVlLnJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGhzOiB2YWx1ZS5saHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogdmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB2YWx1ZS5wcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgdmFsdWUgbG9jYWxseS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libHkgZ2VuZXJhdGUgYSBzaGFyZWQgY29udGV4dCB2YXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXN0b3JlVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuZGVjbGFyZUxvY2FsQ2FsbGJhY2sgJiYgIXZhbHVlLmRlY2xhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5saHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IHRvIHRoaXMgcG9pbnQsIHdlIGFyZSBsb29raW5nIGZvciBhIHByb3BlcnR5IG9uIHRoZSB0b3AgbGV2ZWwgY29tcG9uZW50XG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBvbiB0aGUgdG9wIGFuZCBkb24ndCBuZWVkIHRvIHJlLWRlY2xhcmUgYGN0eGAuXG4gICAgICAgIC8vIC0gSWYgbGV2ZWwgPiAwLCB3ZSBhcmUgaW4gYW4gZW1iZWRkZWQgdmlldy4gV2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgbmFtZSBvZiB0aGVcbiAgICAgICAgLy8gbG9jYWwgdmFyIHdlIHVzZWQgdG8gc3RvcmUgdGhlIGNvbXBvbmVudCBjb250ZXh0LCBlLmcuIGNvbnN0ICRjb21wJCA9IHgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ0xldmVsID09PSAwID8gbnVsbCA6IHRoaXMuZ2V0Q29tcG9uZW50UHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxvY2FsIHZhcmlhYmxlIGZvciBsYXRlciByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmV0cmlldmFsTGV2ZWwgVGhlIGxldmVsIGZyb20gd2hpY2ggdGhpcyB2YWx1ZSBjYW4gYmUgcmV0cmlldmVkXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAgICogQHBhcmFtIGxocyBBU1QgcmVwcmVzZW50aW5nIHRoZSBsZWZ0IGhhbmQgc2lkZSBvZiB0aGUgYGxldCBsaHMgPSByaHM7YC5cbiAgICAgKiBAcGFyYW0gcHJpb3JpdHkgVGhlIHNvcnRpbmcgcHJpb3JpdHkgb2YgdGhpcyB2YXJcbiAgICAgKiBAcGFyYW0gZGVjbGFyZUxvY2FsQ2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZSB3aGVuIGRlY2xhcmluZyB0aGlzIGxvY2FsIHZhclxuICAgICAqIEBwYXJhbSBsb2NhbFJlZiBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGEgbG9jYWwgcmVmXG4gICAgICovXG4gICAgc2V0KHJldHJpZXZhbExldmVsLCBuYW1lLCBsaHMsIHByaW9yaXR5ID0gMCAvKiBEZWNsYXJhdGlvblByaW9yaXR5LkRFRkFVTFQgKi8sIGRlY2xhcmVMb2NhbENhbGxiYWNrLCBsb2NhbFJlZikge1xuICAgICAgICBpZiAodGhpcy5tYXAuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBhIGxvY2FsIHJlZiBhbmQgZG8gbm90IHVwZGF0ZSBleGlzdGluZyB2YWx1ZSxcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGUgZmlyc3QgZGVmaW5lZCByZWYgaXMgYWx3YXlzIHJldHVybmVkLlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoYFRoZSBuYW1lICR7bmFtZX0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHNjb3BlIHRvIGJlICR7dGhpcy5tYXAuZ2V0KG5hbWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFwLnNldChuYW1lLCB7XG4gICAgICAgICAgICByZXRyaWV2YWxMZXZlbDogcmV0cmlldmFsTGV2ZWwsXG4gICAgICAgICAgICBsaHM6IGxocyxcbiAgICAgICAgICAgIGRlY2xhcmU6IGZhbHNlLFxuICAgICAgICAgICAgZGVjbGFyZUxvY2FsQ2FsbGJhY2s6IGRlY2xhcmVMb2NhbENhbGxiYWNrLFxuICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgTG9jYWxSZXNvbHZlci5cbiAgICBnZXRMb2NhbChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChuYW1lKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBMb2NhbFJlc29sdmVyLlxuICAgIG5vdGlmeUltcGxpY2l0UmVjZWl2ZXJVc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdMZXZlbCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGltcGxpY2l0IHJlY2VpdmVyIGlzIGFjY2Vzc2VkIGluIGFuIGVtYmVkZGVkIHZpZXcsIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRlY2xhcmUgYSBzaGFyZWQgY29udGV4dCB2YXJpYWJsZSBmb3IgdGhlIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgICAgICAgIC8vIGluIHRoZSB1cGRhdGUgdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5lc3RlZFNjb3BlKGxldmVsLCBnbG9iYWxzKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gbmV3IEJpbmRpbmdTY29wZShsZXZlbCwgdGhpcywgZ2xvYmFscyk7XG4gICAgICAgIGlmIChsZXZlbCA+IDApXG4gICAgICAgICAgICBuZXdTY29wZS5nZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIoMCk7XG4gICAgICAgIHJldHVybiBuZXdTY29wZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBvciBjcmVhdGVzIGEgc2hhcmVkIGNvbnRleHQgdmFyaWFibGUgYW5kIHJldHVybnMgaXRzIGV4cHJlc3Npb24uIE5vdGUgdGhhdFxuICAgICAqIHRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IHRoZSBzaGFyZWQgdmFyaWFibGUgd2lsbCBiZSBkZWNsYXJlZC4gVmFyaWFibGVzIGluIHRoZVxuICAgICAqIGJpbmRpbmcgc2NvcGUgd2lsbCBiZSBvbmx5IGRlY2xhcmVkIGlmIHRoZXkgYXJlIHVzZWQuXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdLZXkgPSBTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbDtcbiAgICAgICAgaWYgKCF0aGlzLm1hcC5oYXMoYmluZGluZ0tleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFyZWQgY29udGV4dCB2YXJpYWJsZXMgYXJlIGFsd2F5cyBnZW5lcmF0ZWQgYXMgXCJSZWFkVmFyRXhwclwiLlxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGJpbmRpbmdLZXkpLmxocztcbiAgICB9XG4gICAgZ2V0U2hhcmVkQ29udGV4dE5hbWUocmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgY29uc3Qgc2hhcmVkQ3R4T2JqID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIHJldHJpZXZhbExldmVsKTtcbiAgICAgICAgLy8gU2hhcmVkIGNvbnRleHQgdmFyaWFibGVzIGFyZSBhbHdheXMgZ2VuZXJhdGVkIGFzIFwiUmVhZFZhckV4cHJcIi5cbiAgICAgICAgcmV0dXJuIHNoYXJlZEN0eE9iaiAmJiBzaGFyZWRDdHhPYmouZGVjbGFyZSA/IHNoYXJlZEN0eE9iai5saHMgOiBudWxsO1xuICAgIH1cbiAgICBtYXliZUdlbmVyYXRlU2hhcmVkQ29udGV4dFZhcih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUucHJpb3JpdHkgPT09IDEgLyogRGVjbGFyYXRpb25Qcmlvcml0eS5DT05URVhUICovICYmXG4gICAgICAgICAgICB2YWx1ZS5yZXRyaWV2YWxMZXZlbCA8IHRoaXMuYmluZGluZ0xldmVsKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRDdHhPYmogPSB0aGlzLm1hcC5nZXQoU0hBUkVEX0NPTlRFWFRfS0VZICsgdmFsdWUucmV0cmlldmFsTGV2ZWwpO1xuICAgICAgICAgICAgaWYgKHNoYXJlZEN0eE9iaikge1xuICAgICAgICAgICAgICAgIHNoYXJlZEN0eE9iai5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTaGFyZWRDb250ZXh0VmFyKHZhbHVlLnJldHJpZXZhbExldmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZVNoYXJlZENvbnRleHRWYXIocmV0cmlldmFsTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGhzID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FICsgdGhpcy5mcmVzaFJlZmVyZW5jZU5hbWUoKSk7XG4gICAgICAgIHRoaXMubWFwLnNldChTSEFSRURfQ09OVEVYVF9LRVkgKyByZXRyaWV2YWxMZXZlbCwge1xuICAgICAgICAgICAgcmV0cmlldmFsTGV2ZWw6IHJldHJpZXZhbExldmVsLFxuICAgICAgICAgICAgbGhzOiBsaHMsXG4gICAgICAgICAgICBkZWNsYXJlTG9jYWxDYWxsYmFjazogKHNjb3BlLCByZWxhdGl2ZUxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgY3R4X3IwID0gbmV4dENvbnRleHQoMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsaHMuc2V0KGdlbmVyYXRlTmV4dENvbnRleHRFeHByKHJlbGF0aXZlTGV2ZWwpKS50b0NvbnN0RGVjbCgpXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNsYXJlOiBmYWxzZSxcbiAgICAgICAgICAgIHByaW9yaXR5OiAyIC8qIERlY2xhcmF0aW9uUHJpb3JpdHkuU0hBUkVEX0NPTlRFWFQgKi8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnRQcm9wZXJ0eShuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFZhbHVlID0gdGhpcy5tYXAuZ2V0KFNIQVJFRF9DT05URVhUX0tFWSArIDApO1xuICAgICAgICBjb21wb25lbnRWYWx1ZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZVJlc3RvcmVWaWV3KCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRWYWx1ZS5saHMucHJvcChuYW1lKTtcbiAgICB9XG4gICAgbWF5YmVSZXN0b3JlVmlldygpIHtcbiAgICAgICAgLy8gVmlldyByZXN0b3JhdGlvbiBpcyByZXF1aXJlZCBmb3IgbGlzdGVuZXIgaW5zdHJ1Y3Rpb25zIGluc2lkZSBlbWJlZGRlZCB2aWV3cywgYmVjYXVzZVxuICAgICAgICAvLyB0aGV5IG9ubHkgcnVuIGluIGNyZWF0aW9uIG1vZGUgYW5kIHRoZXkgY2FuIGhhdmUgcmVmZXJlbmNlcyB0byB0aGUgY29udGV4dCBvYmplY3QuXG4gICAgICAgIC8vIElmIHRoZSBjb250ZXh0IG9iamVjdCBjaGFuZ2VzIGluIHVwZGF0ZSBtb2RlLCB0aGUgcmVmZXJlbmNlIHdpbGwgYmUgaW5jb3JyZWN0LCBiZWNhdXNlXG4gICAgICAgIC8vIGl0IHdhcyBlc3RhYmxpc2hlZCBkdXJpbmcgY3JlYXRpb24uXG4gICAgICAgIGlmICh0aGlzLmlzTGlzdGVuZXJTY29wZSgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJlbnQgc2F2ZXMgdmFyaWFibGUgdG8gZ2VuZXJhdGUgYSBzaGFyZWQgYGNvbnN0ICRzJCA9IGdldEN1cnJlbnRWaWV3KCk7YCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlc3RvcmVWaWV3VmFyaWFibGUgPSB2YXJpYWJsZSh0aGlzLnBhcmVudC5mcmVzaFJlZmVyZW5jZU5hbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgPSB0aGlzLnBhcmVudC5yZXN0b3JlVmlld1ZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3RvcmVWaWV3U3RhdGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCByZXN0b3JlQ2FsbCA9IGludm9rZUluc3RydWN0aW9uKG51bGwsIElkZW50aWZpZXJzLnJlc3RvcmVWaWV3LCBbdGhpcy5yZXN0b3JlVmlld1ZhcmlhYmxlXSk7XG4gICAgICAgICAgICAvLyBFaXRoZXIgYGNvbnN0IHJlc3RvcmVkQ3R4ID0gcmVzdG9yZVZpZXcoJHN0YXRlJCk7YCBvciBgcmVzdG9yZVZpZXcoJHN0YXRlJCk7YFxuICAgICAgICAgICAgLy8gZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYmVpbmcgdXNlZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXNSZXN0b3JlZFZpZXdDb250ZXh0ID9cbiAgICAgICAgICAgICAgICB2YXJpYWJsZShSRVNUT1JFRF9WSUVXX0NPTlRFWFRfTkFNRSkuc2V0KHJlc3RvcmVDYWxsKS50b0NvbnN0RGVjbCgpIDpcbiAgICAgICAgICAgICAgICByZXN0b3JlQ2FsbC50b1N0bXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlld1NuYXBzaG90U3RhdGVtZW50cygpIHtcbiAgICAgICAgLy8gY29uc3QgJHN0YXRlJCA9IGdldEN1cnJlbnRWaWV3KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGUgP1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVZpZXdWYXJpYWJsZS5zZXQoaW52b2tlSW5zdHJ1Y3Rpb24obnVsbCwgSWRlbnRpZmllcnMuZ2V0Q3VycmVudFZpZXcsIFtdKSkudG9Db25zdERlY2woKVxuICAgICAgICAgICAgXSA6XG4gICAgICAgICAgICBbXTtcbiAgICB9XG4gICAgaXNMaXN0ZW5lclNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuYmluZGluZ0xldmVsID09PSB0aGlzLmJpbmRpbmdMZXZlbDtcbiAgICB9XG4gICAgdmFyaWFibGVEZWNsYXJhdGlvbnMoKSB7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGV4dExldmVsID0gMDtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tYXAudmFsdWVzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKHZhbHVlID0+IHZhbHVlLmRlY2xhcmUpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5yZXRyaWV2YWxMZXZlbCAtIGEucmV0cmlldmFsTGV2ZWwgfHwgYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpXG4gICAgICAgICAgICAucmVkdWNlKChzdG10cywgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxldmVsRGlmZiA9IHRoaXMuYmluZGluZ0xldmVsIC0gdmFsdWUucmV0cmlldmFsTGV2ZWw7XG4gICAgICAgICAgICBjb25zdCBjdXJyU3RtdHMgPSB2YWx1ZS5kZWNsYXJlTG9jYWxDYWxsYmFjayh0aGlzLCBsZXZlbERpZmYgLSBjdXJyZW50Q29udGV4dExldmVsKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0TGV2ZWwgPSBsZXZlbERpZmY7XG4gICAgICAgICAgICByZXR1cm4gc3RtdHMuY29uY2F0KGN1cnJTdG10cyk7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgZnJlc2hSZWZlcmVuY2VOYW1lKCkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIC8vIEZpbmQgdGhlIHRvcCBzY29wZSBhcyBpdCBtYWludGFpbnMgdGhlIGdsb2JhbCByZWZlcmVuY2UgY291bnRcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQucGFyZW50KVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgICAgICBjb25zdCByZWYgPSBgJHtSRUZFUkVOQ0VfUFJFRklYfSR7Y3VycmVudC5yZWZlcmVuY2VOYW1lSW5kZXgrK31gO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBoYXNSZXN0b3JlVmlld1ZhcmlhYmxlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlc3RvcmVWaWV3VmFyaWFibGU7XG4gICAgfVxuICAgIG5vdGlmeVJlc3RvcmVkVmlld0NvbnRleHRVc2UoKSB7XG4gICAgICAgIHRoaXMudXNlc1Jlc3RvcmVkVmlld0NvbnRleHQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDc3NTZWxlY3RvcmAgZ2l2ZW4gYSB0YWcgbmFtZSBhbmQgYSBtYXAgb2YgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDc3NTZWxlY3RvcihlbGVtZW50TmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGNzc1NlbGVjdG9yID0gbmV3IENzc1NlbGVjdG9yKCk7XG4gICAgY29uc3QgZWxlbWVudE5hbWVOb05zID0gc3BsaXROc05hbWUoZWxlbWVudE5hbWUpWzFdO1xuICAgIGNzc1NlbGVjdG9yLnNldEVsZW1lbnQoZWxlbWVudE5hbWVOb05zKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWVOb05zID0gc3BsaXROc05hbWUobmFtZSlbMV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgY3NzU2VsZWN0b3IuYWRkQXR0cmlidXRlKG5hbWVOb05zLCB2YWx1ZSk7XG4gICAgICAgIGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSB2YWx1ZS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICAgIGNsYXNzZXMuZm9yRWFjaChjbGFzc05hbWUgPT4gY3NzU2VsZWN0b3IuYWRkQ2xhc3NOYW1lKGNsYXNzTmFtZSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNzc1NlbGVjdG9yO1xufVxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGV4cHJlc3Npb25zIG91dCBvZiBhbiBgbmdQcm9qZWN0QXNgIGF0dHJpYnV0ZXNcbiAqIHdoaWNoIGNhbiBiZSBhZGRlZCB0byB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZ2V0TmdQcm9qZWN0QXNMaXRlcmFsKGF0dHJpYnV0ZSkge1xuICAgIC8vIFBhcnNlIHRoZSBhdHRyaWJ1dGUgdmFsdWUgaW50byBhIENzc1NlbGVjdG9yTGlzdC4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGVcbiAgICAvLyBmaXJzdCBzZWxlY3RvciwgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IG11bHRpcGxlIHNlbGVjdG9ycyBpbiBuZ1Byb2plY3RBcy5cbiAgICBjb25zdCBwYXJzZWRSM1NlbGVjdG9yID0gcGFyc2VTZWxlY3RvclRvUjNTZWxlY3RvcihhdHRyaWJ1dGUudmFsdWUpWzBdO1xuICAgIHJldHVybiBbbGl0ZXJhbCg1IC8qIGNvcmUuQXR0cmlidXRlTWFya2VyLlByb2plY3RBcyAqLyksIGFzTGl0ZXJhbChwYXJzZWRSM1NlbGVjdG9yKV07XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgcHJvcGVydHlcbiAqIEBwYXJhbSBpbnRlcnBvbGF0aW9uIEFuIEludGVycG9sYXRpb24gQVNUXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGU7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlMTtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnByb3BlcnR5SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMucHJvcGVydHlJbnRlcnBvbGF0ZTM7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNDtcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNjtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlNztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5wcm9wZXJ0eUludGVycG9sYXRlVjtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGluc3RydWN0aW9uIHRvIGdlbmVyYXRlIGZvciBhbiBpbnRlcnBvbGF0ZWQgYXR0cmlidXRlXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihpbnRlcnBvbGF0aW9uKSB7XG4gICAgc3dpdGNoIChnZXRJbnRlcnBvbGF0aW9uQXJnc0xlbmd0aChpbnRlcnBvbGF0aW9uKSkge1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUxO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGUzO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU0O1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZTY7XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMuYXR0cmlidXRlSW50ZXJwb2xhdGU3O1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLmF0dHJpYnV0ZUludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy5hdHRyaWJ1dGVJbnRlcnBvbGF0ZVY7XG4gICAgfVxufVxuLyoqXG4gKiBHZXRzIHRoZSBpbnN0cnVjdGlvbiB0byBnZW5lcmF0ZSBmb3IgaW50ZXJwb2xhdGVkIHRleHQuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBBbiBJbnRlcnBvbGF0aW9uIEFTVFxuICovXG5mdW5jdGlvbiBnZXRUZXh0SW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oaW50ZXJwb2xhdGlvbikge1xuICAgIHN3aXRjaCAoZ2V0SW50ZXJwb2xhdGlvbkFyZ3NMZW5ndGgoaW50ZXJwb2xhdGlvbikpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTE7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGUyO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlMztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTQ7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlNTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGU2O1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgcmV0dXJuIElkZW50aWZpZXJzLnRleHRJbnRlcnBvbGF0ZTc7XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICByZXR1cm4gSWRlbnRpZmllcnMudGV4dEludGVycG9sYXRlODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBJZGVudGlmaWVycy50ZXh0SW50ZXJwb2xhdGVWO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgYSB0ZW1wbGF0ZSBpbnRvIHJlbmRlcjMgYE5vZGVgcyBhbmQgYWRkaXRpb25hbCBtZXRhZGF0YSwgd2l0aCBubyBvdGhlciBkZXBlbmRlbmNpZXMuXG4gKlxuICogQHBhcmFtIHRlbXBsYXRlIHRleHQgb2YgdGhlIHRlbXBsYXRlIHRvIHBhcnNlXG4gKiBAcGFyYW0gdGVtcGxhdGVVcmwgVVJMIHRvIHVzZSBmb3Igc291cmNlIG1hcHBpbmcgb2YgdGhlIHBhcnNlZCB0ZW1wbGF0ZVxuICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyB0byBtb2RpZnkgaG93IHRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGVtcGxhdGVVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgaW50ZXJwb2xhdGlvbkNvbmZpZywgcHJlc2VydmVXaGl0ZXNwYWNlcywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiaW5kaW5nUGFyc2VyID0gbWFrZUJpbmRpbmdQYXJzZXIoaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG4gICAgY29uc3QgaHRtbFBhcnNlciA9IG5ldyBIdG1sUGFyc2VyKCk7XG4gICAgY29uc3QgcGFyc2VSZXN1bHQgPSBodG1sUGFyc2VyLnBhcnNlKHRlbXBsYXRlLCB0ZW1wbGF0ZVVybCwgeyBsZWFkaW5nVHJpdmlhQ2hhcnM6IExFQURJTkdfVFJJVklBX0NIQVJTLCAuLi5vcHRpb25zLCB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgIGlmICghb3B0aW9ucy5hbHdheXNBdHRlbXB0SHRtbFRvUjNBc3RDb252ZXJzaW9uICYmIHBhcnNlUmVzdWx0LmVycm9ycyAmJlxuICAgICAgICBwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUZW1wbGF0ZSA9IHtcbiAgICAgICAgICAgIGludGVycG9sYXRpb25Db25maWcsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzLFxuICAgICAgICAgICAgZXJyb3JzOiBwYXJzZVJlc3VsdC5lcnJvcnMsXG4gICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICBzdHlsZVVybHM6IFtdLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIG5nQ29udGVudFNlbGVjdG9yczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sbGVjdENvbW1lbnROb2Rlcykge1xuICAgICAgICAgICAgcGFyc2VkVGVtcGxhdGUuY29tbWVudE5vZGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZFRlbXBsYXRlO1xuICAgIH1cbiAgICBsZXQgcm9vdE5vZGVzID0gcGFyc2VSZXN1bHQucm9vdE5vZGVzO1xuICAgIC8vIHByb2Nlc3MgaTE4biBtZXRhIGluZm9ybWF0aW9uIChzY2FuIGF0dHJpYnV0ZXMsIGdlbmVyYXRlIGlkcylcbiAgICAvLyBiZWZvcmUgd2UgcnVuIHdoaXRlc3BhY2UgcmVtb3ZhbCBwcm9jZXNzLCBiZWNhdXNlIGV4aXN0aW5nIGkxOG5cbiAgICAvLyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIGV4dHJhY3QtaTE4bikgcmVsaWVzIG9uIGEgcmF3IGNvbnRlbnQgdG8gZ2VuZXJhdGVcbiAgICAvLyBtZXNzYWdlIGlkc1xuICAgIGNvbnN0IGkxOG5NZXRhVmlzaXRvciA9IG5ldyBJMThuTWV0YVZpc2l0b3IoaW50ZXJwb2xhdGlvbkNvbmZpZywgLyoga2VlcEkxOG5BdHRycyAqLyAhcHJlc2VydmVXaGl0ZXNwYWNlcywgZW5hYmxlSTE4bkxlZ2FjeU1lc3NhZ2VJZEZvcm1hdCk7XG4gICAgY29uc3QgaTE4bk1ldGFSZXN1bHQgPSBpMThuTWV0YVZpc2l0b3IudmlzaXRBbGxXaXRoRXJyb3JzKHJvb3ROb2Rlcyk7XG4gICAgaWYgKCFvcHRpb25zLmFsd2F5c0F0dGVtcHRIdG1sVG9SM0FzdENvbnZlcnNpb24gJiYgaTE4bk1ldGFSZXN1bHQuZXJyb3JzICYmXG4gICAgICAgIGkxOG5NZXRhUmVzdWx0LmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFRlbXBsYXRlID0ge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZXMsXG4gICAgICAgICAgICBlcnJvcnM6IGkxOG5NZXRhUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlVXJsczogW10sXG4gICAgICAgICAgICBzdHlsZXM6IFtdLFxuICAgICAgICAgICAgbmdDb250ZW50U2VsZWN0b3JzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5jb2xsZWN0Q29tbWVudE5vZGVzKSB7XG4gICAgICAgICAgICBwYXJzZWRUZW1wbGF0ZS5jb21tZW50Tm9kZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkVGVtcGxhdGU7XG4gICAgfVxuICAgIHJvb3ROb2RlcyA9IGkxOG5NZXRhUmVzdWx0LnJvb3ROb2RlcztcbiAgICBpZiAoIXByZXNlcnZlV2hpdGVzcGFjZXMpIHtcbiAgICAgICAgcm9vdE5vZGVzID0gdmlzaXRBbGwobmV3IFdoaXRlc3BhY2VWaXNpdG9yKCksIHJvb3ROb2Rlcyk7XG4gICAgICAgIC8vIHJ1biBpMThuIG1ldGEgdmlzaXRvciBhZ2FpbiBpbiBjYXNlIHdoaXRlc3BhY2VzIGFyZSByZW1vdmVkIChiZWNhdXNlIHRoYXQgbWlnaHQgYWZmZWN0XG4gICAgICAgIC8vIGdlbmVyYXRlZCBpMThuIG1lc3NhZ2UgY29udGVudCkgYW5kIGZpcnN0IHBhc3MgaW5kaWNhdGVkIHRoYXQgaTE4biBjb250ZW50IGlzIHByZXNlbnQgaW4gYVxuICAgICAgICAvLyB0ZW1wbGF0ZS4gRHVyaW5nIHRoaXMgcGFzcyBpMThuIElEcyBnZW5lcmF0ZWQgYXQgdGhlIGZpcnN0IHBhc3Mgd2lsbCBiZSBwcmVzZXJ2ZWQsIHNvIHdlIGNhblxuICAgICAgICAvLyBtaW1pYyBleGlzdGluZyBleHRyYWN0aW9uIHByb2Nlc3MgKG5nIGV4dHJhY3QtaTE4bilcbiAgICAgICAgaWYgKGkxOG5NZXRhVmlzaXRvci5oYXNJMThuTWV0YSkge1xuICAgICAgICAgICAgcm9vdE5vZGVzID0gdmlzaXRBbGwobmV3IEkxOG5NZXRhVmlzaXRvcihpbnRlcnBvbGF0aW9uQ29uZmlnLCAvKiBrZWVwSTE4bkF0dHJzICovIGZhbHNlKSwgcm9vdE5vZGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IG5vZGVzLCBlcnJvcnMsIHN0eWxlVXJscywgc3R5bGVzLCBuZ0NvbnRlbnRTZWxlY3RvcnMsIGNvbW1lbnROb2RlcyB9ID0gaHRtbEFzdFRvUmVuZGVyM0FzdChyb290Tm9kZXMsIGJpbmRpbmdQYXJzZXIsIHsgY29sbGVjdENvbW1lbnROb2RlczogISFvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMgfSk7XG4gICAgZXJyb3JzLnB1c2goLi4ucGFyc2VSZXN1bHQuZXJyb3JzLCAuLi5pMThuTWV0YVJlc3VsdC5lcnJvcnMpO1xuICAgIGNvbnN0IHBhcnNlZFRlbXBsYXRlID0ge1xuICAgICAgICBpbnRlcnBvbGF0aW9uQ29uZmlnLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzLFxuICAgICAgICBlcnJvcnM6IGVycm9ycy5sZW5ndGggPiAwID8gZXJyb3JzIDogbnVsbCxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIHN0eWxlVXJscyxcbiAgICAgICAgc3R5bGVzLFxuICAgICAgICBuZ0NvbnRlbnRTZWxlY3RvcnNcbiAgICB9O1xuICAgIGlmIChvcHRpb25zLmNvbGxlY3RDb21tZW50Tm9kZXMpIHtcbiAgICAgICAgcGFyc2VkVGVtcGxhdGUuY29tbWVudE5vZGVzID0gY29tbWVudE5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkVGVtcGxhdGU7XG59XG5jb25zdCBlbGVtZW50UmVnaXN0cnkgPSBuZXcgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5KCk7XG4vKipcbiAqIENvbnN0cnVjdCBhIGBCaW5kaW5nUGFyc2VyYCB3aXRoIGEgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBtYWtlQmluZGluZ1BhcnNlcihpbnRlcnBvbGF0aW9uQ29uZmlnID0gREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRykge1xuICAgIHJldHVybiBuZXcgQmluZGluZ1BhcnNlcihuZXcgUGFyc2VyJDEobmV3IExleGVyKCkpLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBlbGVtZW50UmVnaXN0cnksIFtdKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTYW5pdGl6YXRpb25Gbihjb250ZXh0LCBpc0F0dHJpYnV0ZSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2FuaXRpemVIdG1sKTtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuU0NSSVBUOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2FuaXRpemVTY3JpcHQpO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5TVFlMRTpcbiAgICAgICAgICAgIC8vIHRoZSBjb21waWxlciBkb2VzIG5vdCBmaWxsIGluIGFuIGluc3RydWN0aW9uIGZvciBbc3R5bGUucHJvcD9dIGJpbmRpbmdcbiAgICAgICAgICAgIC8vIHZhbHVlcyBiZWNhdXNlIHRoZSBzdHlsZSBhbGdvcml0aG0ga25vd3MgaW50ZXJuYWxseSB3aGF0IHByb3BzIGFyZSBzdWJqZWN0XG4gICAgICAgICAgICAvLyB0byBzYW5pdGl6YXRpb24gKG9ubHkgW2F0dHIuc3R5bGVdIHZhbHVlcyBhcmUgZXhwbGljaXRseSBzYW5pdGl6ZWQpXG4gICAgICAgICAgICByZXR1cm4gaXNBdHRyaWJ1dGUgPyBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNhbml0aXplU3R5bGUpIDogbnVsbDtcbiAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuVVJMOlxuICAgICAgICAgICAgcmV0dXJuIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2FuaXRpemVVcmwpO1xuICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkw6XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0RXhwcihJZGVudGlmaWVycy5zYW5pdGl6ZVJlc291cmNlVXJsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRydXN0ZWRDb25zdEF0dHJpYnV0ZSh0YWdOYW1lLCBhdHRyKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhc0xpdGVyYWwoYXR0ci52YWx1ZSk7XG4gICAgaWYgKGlzVHJ1c3RlZFR5cGVzU2luayh0YWdOYW1lLCBhdHRyLm5hbWUpKSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudFJlZ2lzdHJ5LnNlY3VyaXR5Q29udGV4dCh0YWdOYW1lLCBhdHRyLm5hbWUsIC8qIGlzQXR0cmlidXRlICovIHRydWUpKSB7XG4gICAgICAgICAgICBjYXNlIFNlY3VyaXR5Q29udGV4dC5IVE1MOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YWdnZWRUZW1wbGF0ZShpbXBvcnRFeHByKElkZW50aWZpZXJzLnRydXN0Q29uc3RhbnRIdG1sKSwgbmV3IFRlbXBsYXRlTGl0ZXJhbChbbmV3IFRlbXBsYXRlTGl0ZXJhbEVsZW1lbnQoYXR0ci52YWx1ZSldLCBbXSksIHVuZGVmaW5lZCwgYXR0ci52YWx1ZVNwYW4pO1xuICAgICAgICAgICAgLy8gTkI6IG5vIFNlY3VyaXR5Q29udGV4dC5TQ1JJUFQgaGVyZSwgYXMgdGhlIGNvcnJlc3BvbmRpbmcgdGFncyBhcmUgc3RyaXBwZWQgYnkgdGhlIGNvbXBpbGVyLlxuICAgICAgICAgICAgY2FzZSBTZWN1cml0eUNvbnRleHQuUkVTT1VSQ0VfVVJMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0YWdnZWRUZW1wbGF0ZShpbXBvcnRFeHByKElkZW50aWZpZXJzLnRydXN0Q29uc3RhbnRSZXNvdXJjZVVybCksIG5ldyBUZW1wbGF0ZUxpdGVyYWwoW25ldyBUZW1wbGF0ZUxpdGVyYWxFbGVtZW50KGF0dHIudmFsdWUpXSwgW10pLCB1bmRlZmluZWQsIGF0dHIudmFsdWVTcGFuKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTaW5nbGVFbGVtZW50VGVtcGxhdGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkcmVuWzBdIGluc3RhbmNlb2YgRWxlbWVudCQxO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUZXh0JDMgfHwgbm9kZSBpbnN0YW5jZW9mIEJvdW5kVGV4dCB8fCBub2RlIGluc3RhbmNlb2YgSWN1JDE7XG59XG5mdW5jdGlvbiBpc0lmcmFtZUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiB0YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpZnJhbWUnO1xufVxuZnVuY3Rpb24gaGFzVGV4dENoaWxkcmVuT25seShjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5ldmVyeShpc1RleHROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdGdW5jdGlvblBhcmFtcyhkZWZlcnJlZFBhcmFtcywgbmFtZSwgZWFnZXJQYXJhbXMpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlZmVycmVkUGFyYW1zKCk7XG4gICAgICAgIGNvbnN0IGZuUGFyYW1zID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgIGlmIChlYWdlclBhcmFtcykge1xuICAgICAgICAgICAgZm5QYXJhbXMucHVzaCguLi5lYWdlclBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdGhlIHByb3BlcnR5IG5hbWUgdG8gYWx3YXlzIGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXG4gICAgICAgICAgICBmblBhcmFtcy51bnNoaWZ0KGxpdGVyYWwobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmblBhcmFtcztcbiAgICB9O1xufVxuLyoqIE5hbWUgb2YgdGhlIGdsb2JhbCB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIHVzZSBDbG9zdXJlIHRyYW5zbGF0aW9ucyBvciBub3QgKi9cbmNvbnN0IE5HX0kxOE5fQ0xPU1VSRV9NT0RFID0gJ25nSTE4bkNsb3N1cmVNb2RlJztcbi8qKlxuICogR2VuZXJhdGUgc3RhdGVtZW50cyB0aGF0IGRlZmluZSBhIGdpdmVuIHRyYW5zbGF0aW9uIG1lc3NhZ2UuXG4gKlxuICogYGBgXG4gKiB2YXIgSTE4Tl8xO1xuICogaWYgKHR5cGVvZiBuZ0kxOG5DbG9zdXJlTW9kZSAhPT0gdW5kZWZpbmVkICYmIG5nSTE4bkNsb3N1cmVNb2RlKSB7XG4gKiAgICAgdmFyIE1TR19FWFRFUk5BTF9YWFggPSBnb29nLmdldE1zZyhcbiAqICAgICAgICAgIFwiU29tZSBtZXNzYWdlIHdpdGggeyRpbnRlcnBvbGF0aW9ufSFcIixcbiAqICAgICAgICAgIHsgXCJpbnRlcnBvbGF0aW9uXCI6IFwiXFx1RkZGRDBcXHVGRkZEXCIgfVxuICogICAgICk7XG4gKiAgICAgSTE4Tl8xID0gTVNHX0VYVEVSTkFMX1hYWDtcbiAqIH1cbiAqIGVsc2Uge1xuICogICAgIEkxOE5fMSA9ICRsb2NhbGl6ZWBTb21lIG1lc3NhZ2Ugd2l0aCAkeydcXHVGRkZEMFxcdUZGRkQnfSFgO1xuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgVGhlIG9yaWdpbmFsIGkxOG4gQVNUIG1lc3NhZ2Ugbm9kZVxuICogQHBhcmFtIHZhcmlhYmxlIFRoZSB2YXJpYWJsZSB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdGhlIHRyYW5zbGF0aW9uLCBlLmcuIGBJMThOXzFgLlxuICogQHBhcmFtIGNsb3N1cmVWYXIgVGhlIHZhcmlhYmxlIGZvciBDbG9zdXJlIGBnb29nLmdldE1zZ2AgY2FsbHMsIGUuZy4gYE1TR19FWFRFUk5BTF9YWFhgLlxuICogQHBhcmFtIHBhcmFtcyBPYmplY3QgbWFwcGluZyBwbGFjZWhvbGRlciBuYW1lcyB0byB0aGVpciB2YWx1ZXMgKGUuZy5cbiAqIGB7IFwiaW50ZXJwb2xhdGlvblwiOiBcIlxcdUZGRkQwXFx1RkZGRFwiIH1gKS5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1GbiBPcHRpb25hbCB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgdHJhbnNsYXRpb24gKGUuZy5cbiAqIHBvc3QtcHJvY2Vzc2luZykuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzdGF0ZW1lbnRzIHRoYXQgZGVmaW5lZCBhIGdpdmVuIHRyYW5zbGF0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbkRlY2xTdG10cyhtZXNzYWdlLCB2YXJpYWJsZSwgY2xvc3VyZVZhciwgcGFyYW1zID0ge30sIHRyYW5zZm9ybUZuKSB7XG4gICAgY29uc3Qgc3RhdGVtZW50cyA9IFtcbiAgICAgICAgZGVjbGFyZUkxOG5WYXJpYWJsZSh2YXJpYWJsZSksXG4gICAgICAgIGlmU3RtdChjcmVhdGVDbG9zdXJlTW9kZUd1YXJkKCksIGNyZWF0ZUdvb2dsZUdldE1zZ1N0YXRlbWVudHModmFyaWFibGUsIG1lc3NhZ2UsIGNsb3N1cmVWYXIsIHBhcmFtcyksIGNyZWF0ZUxvY2FsaXplU3RhdGVtZW50cyh2YXJpYWJsZSwgbWVzc2FnZSwgZm9ybWF0STE4blBsYWNlaG9sZGVyTmFtZXNJbk1hcChwYXJhbXMsIC8qIHVzZUNhbWVsQ2FzZSAqLyBmYWxzZSkpKSxcbiAgICBdO1xuICAgIGlmICh0cmFuc2Zvcm1Gbikge1xuICAgICAgICBzdGF0ZW1lbnRzLnB1c2gobmV3IEV4cHJlc3Npb25TdGF0ZW1lbnQodmFyaWFibGUuc2V0KHRyYW5zZm9ybUZuKHZhcmlhYmxlKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgZXhwcmVzc2lvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBndWFyZCB0aGUgY2xvc3VyZSBtb2RlIGJsb2NrXG4gKiBJdCBpcyBlcXVpdmFsZW50IHRvOlxuICpcbiAqIGBgYFxuICogdHlwZW9mIG5nSTE4bkNsb3N1cmVNb2RlICE9PSB1bmRlZmluZWQgJiYgbmdJMThuQ2xvc3VyZU1vZGVcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjcmVhdGVDbG9zdXJlTW9kZUd1YXJkKCkge1xuICAgIHJldHVybiB0eXBlb2ZFeHByKHZhcmlhYmxlKE5HX0kxOE5fQ0xPU1VSRV9NT0RFKSlcbiAgICAgICAgLm5vdElkZW50aWNhbChsaXRlcmFsKCd1bmRlZmluZWQnLCBTVFJJTkdfVFlQRSkpXG4gICAgICAgIC5hbmQodmFyaWFibGUoTkdfSTE4Tl9DTE9TVVJFX01PREUpKTtcbn1cblxuLy8gVGhpcyByZWdleCBtYXRjaGVzIGFueSBiaW5kaW5nIG5hbWVzIHRoYXQgY29udGFpbiB0aGUgXCJhdHRyLlwiIHByZWZpeCwgZS5nLiBcImF0dHIucmVxdWlyZWRcIlxuLy8gSWYgdGhlcmUgaXMgYSBtYXRjaCwgdGhlIGZpcnN0IG1hdGNoaW5nIGdyb3VwIHdpbGwgY29udGFpbiB0aGUgYXR0cmlidXRlIG5hbWUgdG8gYmluZC5cbmNvbnN0IEFUVFJfUkVHRVggPSAvYXR0clxcLihbXlxcXV0rKS87XG5jb25zdCBDT01QT05FTlRfVkFSSUFCTEUgPSAnJUNPTVAlJztcbmNvbnN0IEhPU1RfQVRUUiA9IGBfbmdob3N0LSR7Q09NUE9ORU5UX1ZBUklBQkxFfWA7XG5jb25zdCBDT05URU5UX0FUVFIgPSBgX25nY29udGVudC0ke0NPTVBPTkVOVF9WQVJJQUJMRX1gO1xuZnVuY3Rpb24gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBjb25zdCBzZWxlY3RvcnMgPSBwYXJzZVNlbGVjdG9yVG9SM1NlbGVjdG9yKG1ldGEuc2VsZWN0b3IpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15RGlyZWN0aXZlYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIC8vIGUuZy4gYHNlbGVjdG9yczogW1snJywgJ3NvbWVEaXInLCAnJ11dYFxuICAgIGlmIChzZWxlY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2VsZWN0b3JzJywgYXNMaXRlcmFsKHNlbGVjdG9ycykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gZS5nLiBgY29udGVudFF1ZXJpZXM6IChyZiwgY3R4LCBkaXJJbmRleCkgPT4geyAuLi4gfVxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY29udGVudFF1ZXJpZXMnLCBjcmVhdGVDb250ZW50UXVlcmllc0Z1bmN0aW9uKG1ldGEucXVlcmllcywgY29uc3RhbnRQb29sLCBtZXRhLm5hbWUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEudmlld1F1ZXJpZXMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcnknLCBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKG1ldGEudmlld1F1ZXJpZXMsIGNvbnN0YW50UG9vbCwgbWV0YS5uYW1lKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGhvc3RCaW5kaW5nczogKHJmLCBjdHgpID0+IHsgLi4uIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdEJpbmRpbmdzJywgY3JlYXRlSG9zdEJpbmRpbmdzRnVuY3Rpb24obWV0YS5ob3N0LCBtZXRhLnR5cGVTb3VyY2VTcGFuLCBiaW5kaW5nUGFyc2VyLCBjb25zdGFudFBvb2wsIG1ldGEuc2VsZWN0b3IgfHwgJycsIG1ldGEubmFtZSwgZGVmaW5pdGlvbk1hcCkpO1xuICAgIC8vIGUuZyAnaW5wdXRzOiB7YTogJ2EnfWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaW5wdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5pbnB1dHMsIHRydWUpKTtcbiAgICAvLyBlLmcgJ291dHB1dHM6IHthOiAnYSd9YFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCdvdXRwdXRzJywgY29uZGl0aW9uYWxseUNyZWF0ZU1hcE9iamVjdExpdGVyYWwobWV0YS5vdXRwdXRzKSk7XG4gICAgaWYgKG1ldGEuZXhwb3J0QXMgIT09IG51bGwpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydEFzJywgbGl0ZXJhbEFycihtZXRhLmV4cG9ydEFzLm1hcChlID0+IGxpdGVyYWwoZSkpKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc3RhbmRhbG9uZScsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbk1hcDtcbn1cbi8qKlxuICogQWRkIGZlYXR1cmVzIHRvIHRoZSBkZWZpbml0aW9uIG1hcC5cbiAqL1xuZnVuY3Rpb24gYWRkRmVhdHVyZXMoZGVmaW5pdGlvbk1hcCwgbWV0YSkge1xuICAgIC8vIGUuZy4gYGZlYXR1cmVzOiBbTmdPbkNoYW5nZXNGZWF0dXJlXWBcbiAgICBjb25zdCBmZWF0dXJlcyA9IFtdO1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IG1ldGEucHJvdmlkZXJzO1xuICAgIGNvbnN0IHZpZXdQcm92aWRlcnMgPSBtZXRhLnZpZXdQcm92aWRlcnM7XG4gICAgaWYgKHByb3ZpZGVycyB8fCB2aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbcHJvdmlkZXJzIHx8IG5ldyBMaXRlcmFsQXJyYXlFeHByKFtdKV07XG4gICAgICAgIGlmICh2aWV3UHJvdmlkZXJzKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2godmlld1Byb3ZpZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZmVhdHVyZXMucHVzaChpbXBvcnRFeHByKElkZW50aWZpZXJzLlByb3ZpZGVyc0ZlYXR1cmUpLmNhbGxGbihhcmdzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZXNJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSW5oZXJpdERlZmluaXRpb25GZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmZ1bGxJbmhlcml0YW5jZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuQ29weURlZmluaXRpb25GZWF0dXJlKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmxpZmVjeWNsZS51c2VzT25DaGFuZ2VzKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5OZ09uQ2hhbmdlc0ZlYXR1cmUpKTtcbiAgICB9XG4gICAgLy8gVE9ETzogYmV0dGVyIHdheSBvZiBkaWZmZXJlbnRpYXRpbmcgY29tcG9uZW50IHZzIGRpcmVjdGl2ZSBtZXRhZGF0YS5cbiAgICBpZiAobWV0YS5oYXNPd25Qcm9wZXJ0eSgndGVtcGxhdGUnKSAmJiBtZXRhLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuU3RhbmRhbG9uZUZlYXR1cmUpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuaG9zdERpcmVjdGl2ZXM/Lmxlbmd0aCkge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKGltcG9ydEV4cHIoSWRlbnRpZmllcnMuSG9zdERpcmVjdGl2ZXNGZWF0dXJlKS5jYWxsRm4oW2NyZWF0ZUhvc3REaXJlY3RpdmVzRmVhdHVyZUFyZyhtZXRhLmhvc3REaXJlY3RpdmVzKV0pKTtcbiAgICB9XG4gICAgaWYgKGZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZmVhdHVyZXMnLCBsaXRlcmFsQXJyKGZlYXR1cmVzKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21waWxlIGEgZGlyZWN0aXZlIGZvciB0aGUgcmVuZGVyMyBydW50aW1lIGFzIGRlZmluZWQgYnkgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURpcmVjdGl2ZUZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlZmluZURpcmVjdGl2ZSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlRGlyZWN0aXZlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBDb21waWxlIGEgY29tcG9uZW50IGZvciB0aGUgcmVuZGVyMyBydW50aW1lIGFzIGRlZmluZWQgYnkgdGhlIGBSM0NvbXBvbmVudE1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUNvbXBvbmVudEZyb21NZXRhZGF0YShtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gYmFzZURpcmVjdGl2ZUZpZWxkcyhtZXRhLCBjb25zdGFudFBvb2wsIGJpbmRpbmdQYXJzZXIpO1xuICAgIGFkZEZlYXR1cmVzKGRlZmluaXRpb25NYXAsIG1ldGEpO1xuICAgIGNvbnN0IHNlbGVjdG9yID0gbWV0YS5zZWxlY3RvciAmJiBDc3NTZWxlY3Rvci5wYXJzZShtZXRhLnNlbGVjdG9yKTtcbiAgICBjb25zdCBmaXJzdFNlbGVjdG9yID0gc2VsZWN0b3IgJiYgc2VsZWN0b3JbMF07XG4gICAgLy8gZS5nLiBgYXR0cjogW1wiY2xhc3NcIiwgXCIubXkuYXBwXCJdYFxuICAgIC8vIFRoaXMgaXMgb3B0aW9uYWwgYW4gb25seSBpbmNsdWRlZCBpZiB0aGUgZmlyc3Qgc2VsZWN0b3Igb2YgYSBjb21wb25lbnQgc3BlY2lmaWVzIGF0dHJpYnV0ZXMuXG4gICAgaWYgKGZpcnN0U2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JBdHRyaWJ1dGVzID0gZmlyc3RTZWxlY3Rvci5nZXRBdHRycygpO1xuICAgICAgICBpZiAoc2VsZWN0b3JBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2F0dHJzJywgY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsQXJyKHNlbGVjdG9yQXR0cmlidXRlcy5tYXAodmFsdWUgPT4gdmFsdWUgIT0gbnVsbCA/IGxpdGVyYWwodmFsdWUpIDogbGl0ZXJhbCh1bmRlZmluZWQpKSksIFxuICAgICAgICAgICAgLyogZm9yY2VTaGFyZWQgKi8gdHJ1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGUuZy4gYHRlbXBsYXRlOiBmdW5jdGlvbiBNeUNvbXBvbmVudF9UZW1wbGF0ZShfY3R4LCBfY20pIHsuLi59YFxuICAgIGNvbnN0IHRlbXBsYXRlVHlwZU5hbWUgPSBtZXRhLm5hbWU7XG4gICAgY29uc3QgdGVtcGxhdGVOYW1lID0gdGVtcGxhdGVUeXBlTmFtZSA/IGAke3RlbXBsYXRlVHlwZU5hbWV9X1RlbXBsYXRlYCA6IG51bGw7XG4gICAgY29uc3QgY2hhbmdlRGV0ZWN0aW9uID0gbWV0YS5jaGFuZ2VEZXRlY3Rpb247XG4gICAgY29uc3QgdGVtcGxhdGUgPSBtZXRhLnRlbXBsYXRlO1xuICAgIGNvbnN0IHRlbXBsYXRlQnVpbGRlciA9IG5ldyBUZW1wbGF0ZURlZmluaXRpb25CdWlsZGVyKGNvbnN0YW50UG9vbCwgQmluZGluZ1Njb3BlLmNyZWF0ZVJvb3RTY29wZSgpLCAwLCB0ZW1wbGF0ZVR5cGVOYW1lLCBudWxsLCBudWxsLCB0ZW1wbGF0ZU5hbWUsIElkZW50aWZpZXJzLm5hbWVzcGFjZUhUTUwsIG1ldGEucmVsYXRpdmVDb250ZXh0RmlsZVBhdGgsIG1ldGEuaTE4blVzZUV4dGVybmFsSWRzKTtcbiAgICBjb25zdCB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbiA9IHRlbXBsYXRlQnVpbGRlci5idWlsZFRlbXBsYXRlRnVuY3Rpb24odGVtcGxhdGUubm9kZXMsIFtdKTtcbiAgICAvLyBXZSBuZWVkIHRvIHByb3ZpZGUgdGhpcyBzbyB0aGF0IGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBjb21wb25lbnRzIGtub3cgd2hhdFxuICAgIC8vIHByb2plY3RlZCBjb250ZW50IGJsb2NrcyB0byBwYXNzIHRocm91Z2ggdG8gdGhlIGNvbXBvbmVudCB3aGVuIGl0IGlzIGluc3RhbnRpYXRlZC5cbiAgICBjb25zdCBuZ0NvbnRlbnRTZWxlY3RvcnMgPSB0ZW1wbGF0ZUJ1aWxkZXIuZ2V0TmdDb250ZW50U2VsZWN0b3JzKCk7XG4gICAgaWYgKG5nQ29udGVudFNlbGVjdG9ycykge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdDb250ZW50U2VsZWN0b3JzJywgbmdDb250ZW50U2VsZWN0b3JzKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgZGVjbHM6IDJgXG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY2xzJywgbGl0ZXJhbCh0ZW1wbGF0ZUJ1aWxkZXIuZ2V0Q29uc3RDb3VudCgpKSk7XG4gICAgLy8gZS5nLiBgdmFyczogMmBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmFycycsIGxpdGVyYWwodGVtcGxhdGVCdWlsZGVyLmdldFZhckNvdW50KCkpKTtcbiAgICAvLyBHZW5lcmF0ZSBgY29uc3RzYCBzZWN0aW9uIG9mIENvbXBvbmVudERlZjpcbiAgICAvLyAtIGVpdGhlciBhcyBhbiBhcnJheTpcbiAgICAvLyAgIGBjb25zdHM6IFtbJ29uZScsICd0d28nXSwgWyd0aHJlZScsICdmb3VyJ11dYFxuICAgIC8vIC0gb3IgYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGluIGNhc2UgYWRkaXRpb25hbCBzdGF0ZW1lbnRzIGFyZSBwcmVzZW50ICh0byBzdXBwb3J0IGkxOG4pOlxuICAgIC8vICAgYGNvbnN0czogZnVuY3Rpb24oKSB7IHZhciBpMThuXzA7IGlmIChuZ0kxOG5DbG9zdXJlTW9kZSkgey4uLn0gZWxzZSB7Li4ufSByZXR1cm4gW2kxOG5fMF07IH1gXG4gICAgY29uc3QgeyBjb25zdEV4cHJlc3Npb25zLCBwcmVwYXJlU3RhdGVtZW50cyB9ID0gdGVtcGxhdGVCdWlsZGVyLmdldENvbnN0cygpO1xuICAgIGlmIChjb25zdEV4cHJlc3Npb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGNvbnN0c0V4cHIgPSBsaXRlcmFsQXJyKGNvbnN0RXhwcmVzc2lvbnMpO1xuICAgICAgICAvLyBQcmVwYXJlIHN0YXRlbWVudHMgYXJlIHByZXNlbnQgLSB0dXJuIGBjb25zdHNgIGludG8gYSBmdW5jdGlvbi5cbiAgICAgICAgaWYgKHByZXBhcmVTdGF0ZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0c0V4cHIgPSBmbihbXSwgWy4uLnByZXBhcmVTdGF0ZW1lbnRzLCBuZXcgUmV0dXJuU3RhdGVtZW50KGNvbnN0c0V4cHIpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2NvbnN0cycsIGNvbnN0c0V4cHIpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgndGVtcGxhdGUnLCB0ZW1wbGF0ZUZ1bmN0aW9uRXhwcmVzc2lvbik7XG4gICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcGVuZGVuY2llcycsIGNvbXBpbGVEZWNsYXJhdGlvbkxpc3QobGl0ZXJhbEFycihtZXRhLmRlY2xhcmF0aW9ucy5tYXAoZGVjbCA9PiBkZWNsLnR5cGUpKSwgbWV0YS5kZWNsYXJhdGlvbkxpc3RFbWl0TW9kZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBudWxsKSB7XG4gICAgICAgIG1ldGEuZW5jYXBzdWxhdGlvbiA9IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkO1xuICAgIH1cbiAgICAvLyBlLmcuIGBzdHlsZXM6IFtzdHIxLCBzdHIyXWBcbiAgICBpZiAobWV0YS5zdHlsZXMgJiYgbWV0YS5zdHlsZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVmFsdWVzID0gbWV0YS5lbmNhcHN1bGF0aW9uID09IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkID9cbiAgICAgICAgICAgIGNvbXBpbGVTdHlsZXMobWV0YS5zdHlsZXMsIENPTlRFTlRfQVRUUiwgSE9TVF9BVFRSKSA6XG4gICAgICAgICAgICBtZXRhLnN0eWxlcztcbiAgICAgICAgY29uc3Qgc3R5bGVOb2RlcyA9IHN0eWxlVmFsdWVzLnJlZHVjZSgocmVzdWx0LCBzdHlsZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0eWxlLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY29uc3RhbnRQb29sLmdldENvbnN0TGl0ZXJhbChsaXRlcmFsKHN0eWxlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBpZiAoc3R5bGVOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc3R5bGVzJywgbGl0ZXJhbEFycihzdHlsZU5vZGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWV0YS5lbmNhcHN1bGF0aW9uID09PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBzdHlsZSwgZG9uJ3QgZ2VuZXJhdGUgY3NzIHNlbGVjdG9ycyBvbiBlbGVtZW50c1xuICAgICAgICBtZXRhLmVuY2Fwc3VsYXRpb24gPSBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB2aWV3IGVuY2Fwc3VsYXRpb24gaWYgaXQncyBub3QgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICBpZiAobWV0YS5lbmNhcHN1bGF0aW9uICE9PSBWaWV3RW5jYXBzdWxhdGlvbi5FbXVsYXRlZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZW5jYXBzdWxhdGlvbicsIGxpdGVyYWwobWV0YS5lbmNhcHN1bGF0aW9uKSk7XG4gICAgfVxuICAgIC8vIGUuZy4gYGFuaW1hdGlvbjogW3RyaWdnZXIoJzEyMycsIFtdKV1gXG4gICAgaWYgKG1ldGEuYW5pbWF0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZGF0YScsIGxpdGVyYWxNYXAoW3sga2V5OiAnYW5pbWF0aW9uJywgdmFsdWU6IG1ldGEuYW5pbWF0aW9ucywgcXVvdGVkOiBmYWxzZSB9XSkpO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB0aGUgY2hhbmdlIGRldGVjdGlvbiBmbGFnIGlmIGl0J3MgZGVmaW5lZCBhbmQgaXQncyBub3QgdGhlIGRlZmF1bHQuXG4gICAgaWYgKGNoYW5nZURldGVjdGlvbiAhPSBudWxsICYmIGNoYW5nZURldGVjdGlvbiAhPT0gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnY2hhbmdlRGV0ZWN0aW9uJywgbGl0ZXJhbChjaGFuZ2VEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVmaW5lQ29tcG9uZW50KS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldLCB1bmRlZmluZWQsIHRydWUpO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVDb21wb25lbnRUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIHR5cGUgc3BlY2lmaWNhdGlvbiBmcm9tIHRoZSBjb21wb25lbnQgbWV0YS4gVGhpcyB0eXBlIGlzIGluc2VydGVkIGludG8gLmQudHMgZmlsZXNcbiAqIHRvIGJlIGNvbnN1bWVkIGJ5IHVwc3RyZWFtIGNvbXBpbGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50VHlwZShtZXRhKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtcyA9IGNyZWF0ZUJhc2VEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpO1xuICAgIHR5cGVQYXJhbXMucHVzaChzdHJpbmdBcnJheUFzVHlwZShtZXRhLnRlbXBsYXRlLm5nQ29udGVudFNlbGVjdG9ycykpO1xuICAgIHR5cGVQYXJhbXMucHVzaChleHByZXNzaW9uVHlwZShsaXRlcmFsKG1ldGEuaXNTdGFuZGFsb25lKSkpO1xuICAgIHR5cGVQYXJhbXMucHVzaChjcmVhdGVIb3N0RGlyZWN0aXZlc1R5cGUobWV0YSkpO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLkNvbXBvbmVudERlY2xhcmF0aW9uLCB0eXBlUGFyYW1zKSk7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBhcnJheSBsaXRlcmFsIG9mIGRlY2xhcmF0aW9ucyBpbnRvIGFuIGV4cHJlc3Npb24gYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBlbWl0XG4gKiBtb2RlLlxuICovXG5mdW5jdGlvbiBjb21waWxlRGVjbGFyYXRpb25MaXN0KGxpc3QsIG1vZGUpIHtcbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIERlY2xhcmF0aW9uTGlzdEVtaXRNb2RlLkRpcmVjdCAqLzpcbiAgICAgICAgICAgIC8vIGRpcmVjdGl2ZXM6IFtNeURpcl0sXG4gICAgICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgICAgY2FzZSAxIC8qIERlY2xhcmF0aW9uTGlzdEVtaXRNb2RlLkNsb3N1cmUgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdOyB9XG4gICAgICAgICAgICByZXR1cm4gZm4oW10sIFtuZXcgUmV0dXJuU3RhdGVtZW50KGxpc3QpXSk7XG4gICAgICAgIGNhc2UgMiAvKiBEZWNsYXJhdGlvbkxpc3RFbWl0TW9kZS5DbG9zdXJlUmVzb2x2ZWQgKi86XG4gICAgICAgICAgICAvLyBkaXJlY3RpdmVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbTXlEaXJdLm1hcChuZy5yZXNvbHZlRm9yd2FyZFJlZik7IH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkTGlzdCA9IGxpc3QucHJvcCgnbWFwJykuY2FsbEZuKFtpbXBvcnRFeHByKElkZW50aWZpZXJzLnJlc29sdmVGb3J3YXJkUmVmKV0pO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFtdLCBbbmV3IFJldHVyblN0YXRlbWVudChyZXNvbHZlZExpc3QpXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gW2dldFF1ZXJ5UHJlZGljYXRlKHF1ZXJ5LCBjb25zdGFudFBvb2wpLCBsaXRlcmFsKHRvUXVlcnlGbGFncyhxdWVyeSkpXTtcbiAgICBpZiAocXVlcnkucmVhZCkge1xuICAgICAgICBwYXJhbWV0ZXJzLnB1c2gocXVlcnkucmVhZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuLyoqXG4gKiBUcmFuc2xhdGVzIHF1ZXJ5IGZsYWdzIGludG8gYFRRdWVyeUZsYWdzYCB0eXBlIGluIHBhY2thZ2VzL2NvcmUvc3JjL3JlbmRlcjMvaW50ZXJmYWNlcy9xdWVyeS50c1xuICogQHBhcmFtIHF1ZXJ5XG4gKi9cbmZ1bmN0aW9uIHRvUXVlcnlGbGFncyhxdWVyeSkge1xuICAgIHJldHVybiAocXVlcnkuZGVzY2VuZGFudHMgPyAxIC8qIFF1ZXJ5RmxhZ3MuZGVzY2VuZGFudHMgKi8gOiAwIC8qIFF1ZXJ5RmxhZ3Mubm9uZSAqLykgfFxuICAgICAgICAocXVlcnkuc3RhdGljID8gMiAvKiBRdWVyeUZsYWdzLmlzU3RhdGljICovIDogMCAvKiBRdWVyeUZsYWdzLm5vbmUgKi8pIHxcbiAgICAgICAgKHF1ZXJ5LmVtaXREaXN0aW5jdENoYW5nZXNPbmx5ID8gNCAvKiBRdWVyeUZsYWdzLmVtaXREaXN0aW5jdENoYW5nZXNPbmx5ICovIDogMCAvKiBRdWVyeUZsYWdzLm5vbmUgKi8pO1xufVxuZnVuY3Rpb24gY29udmVydEF0dHJpYnV0ZXNUb0V4cHJlc3Npb25zKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXR0cmlidXRlcykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIHZhbHVlcy5wdXNoKGxpdGVyYWwoa2V5KSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLy8gRGVmaW5lIGFuZCB1cGRhdGUgYW55IGNvbnRlbnQgcXVlcmllc1xuZnVuY3Rpb24gY3JlYXRlQ29udGVudFF1ZXJpZXNGdW5jdGlvbihxdWVyaWVzLCBjb25zdGFudFBvb2wsIG5hbWUpIHtcbiAgICBjb25zdCBjcmVhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdXBkYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IHRlbXBBbGxvY2F0b3IgPSB0ZW1wb3JhcnlBbGxvY2F0b3IodXBkYXRlU3RhdGVtZW50cywgVEVNUE9SQVJZX05BTUUpO1xuICAgIGZvciAoY29uc3QgcXVlcnkgb2YgcXVlcmllcykge1xuICAgICAgICAvLyBjcmVhdGlvbiwgZS5nLiByMy5jb250ZW50UXVlcnkoZGlySW5kZXgsIHNvbWVQcmVkaWNhdGUsIHRydWUsIG51bGwpO1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb250ZW50UXVlcnkpXG4gICAgICAgICAgICAuY2FsbEZuKFt2YXJpYWJsZSgnZGlySW5kZXgnKSwgLi4ucHJlcGFyZVF1ZXJ5UGFyYW1zKHF1ZXJ5LCBjb25zdGFudFBvb2wpXSlcbiAgICAgICAgICAgIC50b1N0bXQoKSk7XG4gICAgICAgIC8vIHVwZGF0ZSwgZS5nLiAocjMucXVlcnlSZWZyZXNoKHRtcCA9IHIzLmxvYWRRdWVyeSgpKSAmJiAoY3R4LnNvbWVEaXIgPSB0bXApKTtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5ID0gdGVtcEFsbG9jYXRvcigpO1xuICAgICAgICBjb25zdCBnZXRRdWVyeUxpc3QgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmxvYWRRdWVyeSkuY2FsbEZuKFtdKTtcbiAgICAgICAgY29uc3QgcmVmcmVzaCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMucXVlcnlSZWZyZXNoKS5jYWxsRm4oW3RlbXBvcmFyeS5zZXQoZ2V0UXVlcnlMaXN0KV0pO1xuICAgICAgICBjb25zdCB1cGRhdGVEaXJlY3RpdmUgPSB2YXJpYWJsZShDT05URVhUX05BTUUpXG4gICAgICAgICAgICAucHJvcChxdWVyeS5wcm9wZXJ0eU5hbWUpXG4gICAgICAgICAgICAuc2V0KHF1ZXJ5LmZpcnN0ID8gdGVtcG9yYXJ5LnByb3AoJ2ZpcnN0JykgOiB0ZW1wb3JhcnkpO1xuICAgICAgICB1cGRhdGVTdGF0ZW1lbnRzLnB1c2gocmVmcmVzaC5hbmQodXBkYXRlRGlyZWN0aXZlKS50b1N0bXQoKSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRRdWVyaWVzRm5OYW1lID0gbmFtZSA/IGAke25hbWV9X0NvbnRlbnRRdWVyaWVzYCA6IG51bGw7XG4gICAgcmV0dXJuIGZuKFtcbiAgICAgICAgbmV3IEZuUGFyYW0oUkVOREVSX0ZMQUdTLCBOVU1CRVJfVFlQRSksIG5ldyBGblBhcmFtKENPTlRFWFRfTkFNRSwgbnVsbCksXG4gICAgICAgIG5ldyBGblBhcmFtKCdkaXJJbmRleCcsIG51bGwpXG4gICAgXSwgW1xuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBjb3JlLlJlbmRlckZsYWdzLkNyZWF0ZSAqLywgY3JlYXRlU3RhdGVtZW50cyksXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIGNvcmUuUmVuZGVyRmxhZ3MuVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKVxuICAgIF0sIElORkVSUkVEX1RZUEUsIG51bGwsIGNvbnRlbnRRdWVyaWVzRm5OYW1lKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0FzVHlwZShzdHIpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbChzdHIpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ01hcEFzTGl0ZXJhbEV4cHJlc3Npb24obWFwKSB7XG4gICAgY29uc3QgbWFwVmFsdWVzID0gT2JqZWN0LmtleXMobWFwKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBBcnJheS5pc0FycmF5KG1hcFtrZXldKSA/IG1hcFtrZXldWzBdIDogbWFwW2tleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbCh2YWx1ZSksXG4gICAgICAgICAgICBxdW90ZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpdGVyYWxNYXAobWFwVmFsdWVzKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0FycmF5QXNUeXBlKGFycikge1xuICAgIHJldHVybiBhcnIubGVuZ3RoID4gMCA/IGV4cHJlc3Npb25UeXBlKGxpdGVyYWxBcnIoYXJyLm1hcCh2YWx1ZSA9PiBsaXRlcmFsKHZhbHVlKSkpKSA6XG4gICAgICAgIE5PTkVfVFlQRTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEaXJlY3RpdmVUeXBlUGFyYW1zKG1ldGEpIHtcbiAgICAvLyBPbiB0aGUgdHlwZSBzaWRlLCByZW1vdmUgbmV3bGluZXMgZnJvbSB0aGUgc2VsZWN0b3IgYXMgaXQgd2lsbCBuZWVkIHRvIGZpdCBpbnRvIGEgVHlwZVNjcmlwdFxuICAgIC8vIHN0cmluZyBsaXRlcmFsLCB3aGljaCBtdXN0IGJlIG9uIG9uZSBsaW5lLlxuICAgIGNvbnN0IHNlbGVjdG9yRm9yVHlwZSA9IG1ldGEuc2VsZWN0b3IgIT09IG51bGwgPyBtZXRhLnNlbGVjdG9yLnJlcGxhY2UoL1xcbi9nLCAnJykgOiBudWxsO1xuICAgIHJldHVybiBbXG4gICAgICAgIHR5cGVXaXRoUGFyYW1ldGVycyhtZXRhLnR5cGUudHlwZSwgbWV0YS50eXBlQXJndW1lbnRDb3VudCksXG4gICAgICAgIHNlbGVjdG9yRm9yVHlwZSAhPT0gbnVsbCA/IHN0cmluZ0FzVHlwZShzZWxlY3RvckZvclR5cGUpIDogTk9ORV9UWVBFLFxuICAgICAgICBtZXRhLmV4cG9ydEFzICE9PSBudWxsID8gc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5leHBvcnRBcykgOiBOT05FX1RZUEUsXG4gICAgICAgIGV4cHJlc3Npb25UeXBlKHN0cmluZ01hcEFzTGl0ZXJhbEV4cHJlc3Npb24obWV0YS5pbnB1dHMpKSxcbiAgICAgICAgZXhwcmVzc2lvblR5cGUoc3RyaW5nTWFwQXNMaXRlcmFsRXhwcmVzc2lvbihtZXRhLm91dHB1dHMpKSxcbiAgICAgICAgc3RyaW5nQXJyYXlBc1R5cGUobWV0YS5xdWVyaWVzLm1hcChxID0+IHEucHJvcGVydHlOYW1lKSksXG4gICAgXTtcbn1cbi8qKlxuICogQ3JlYXRlcyB0aGUgdHlwZSBzcGVjaWZpY2F0aW9uIGZyb20gdGhlIGRpcmVjdGl2ZSBtZXRhLiBUaGlzIHR5cGUgaXMgaW5zZXJ0ZWQgaW50byAuZC50cyBmaWxlc1xuICogdG8gYmUgY29uc3VtZWQgYnkgdXBzdHJlYW0gY29tcGlsYXRpb25zLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVUeXBlKG1ldGEpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1zID0gY3JlYXRlQmFzZURpcmVjdGl2ZVR5cGVQYXJhbXMobWV0YSk7XG4gICAgLy8gRGlyZWN0aXZlcyBoYXZlIG5vIE5nQ29udGVudFNlbGVjdG9ycyBzbG90LCBidXQgaW5zdGVhZCBleHByZXNzIGEgYG5ldmVyYCB0eXBlXG4gICAgLy8gc28gdGhhdCBmdXR1cmUgZmllbGRzIGFsaWduLlxuICAgIHR5cGVQYXJhbXMucHVzaChOT05FX1RZUEUpO1xuICAgIHR5cGVQYXJhbXMucHVzaChleHByZXNzaW9uVHlwZShsaXRlcmFsKG1ldGEuaXNTdGFuZGFsb25lKSkpO1xuICAgIHR5cGVQYXJhbXMucHVzaChjcmVhdGVIb3N0RGlyZWN0aXZlc1R5cGUobWV0YSkpO1xuICAgIHJldHVybiBleHByZXNzaW9uVHlwZShpbXBvcnRFeHByKElkZW50aWZpZXJzLkRpcmVjdGl2ZURlY2xhcmF0aW9uLCB0eXBlUGFyYW1zKSk7XG59XG4vLyBEZWZpbmUgYW5kIHVwZGF0ZSBhbnkgdmlldyBxdWVyaWVzXG5mdW5jdGlvbiBjcmVhdGVWaWV3UXVlcmllc0Z1bmN0aW9uKHZpZXdRdWVyaWVzLCBjb25zdGFudFBvb2wsIG5hbWUpIHtcbiAgICBjb25zdCBjcmVhdGVTdGF0ZW1lbnRzID0gW107XG4gICAgY29uc3QgdXBkYXRlU3RhdGVtZW50cyA9IFtdO1xuICAgIGNvbnN0IHRlbXBBbGxvY2F0b3IgPSB0ZW1wb3JhcnlBbGxvY2F0b3IodXBkYXRlU3RhdGVtZW50cywgVEVNUE9SQVJZX05BTUUpO1xuICAgIHZpZXdRdWVyaWVzLmZvckVhY2goKHF1ZXJ5KSA9PiB7XG4gICAgICAgIC8vIGNyZWF0aW9uLCBlLmcuIHIzLnZpZXdRdWVyeShzb21lUHJlZGljYXRlLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcXVlcnlEZWZpbml0aW9uID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy52aWV3UXVlcnkpLmNhbGxGbihwcmVwYXJlUXVlcnlQYXJhbXMocXVlcnksIGNvbnN0YW50UG9vbCkpO1xuICAgICAgICBjcmVhdGVTdGF0ZW1lbnRzLnB1c2gocXVlcnlEZWZpbml0aW9uLnRvU3RtdCgpKTtcbiAgICAgICAgLy8gdXBkYXRlLCBlLmcuIChyMy5xdWVyeVJlZnJlc2godG1wID0gcjMubG9hZFF1ZXJ5KCkpICYmIChjdHguc29tZURpciA9IHRtcCkpO1xuICAgICAgICBjb25zdCB0ZW1wb3JhcnkgPSB0ZW1wQWxsb2NhdG9yKCk7XG4gICAgICAgIGNvbnN0IGdldFF1ZXJ5TGlzdCA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMubG9hZFF1ZXJ5KS5jYWxsRm4oW10pO1xuICAgICAgICBjb25zdCByZWZyZXNoID0gaW1wb3J0RXhwcihJZGVudGlmaWVycy5xdWVyeVJlZnJlc2gpLmNhbGxGbihbdGVtcG9yYXJ5LnNldChnZXRRdWVyeUxpc3QpXSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURpcmVjdGl2ZSA9IHZhcmlhYmxlKENPTlRFWFRfTkFNRSlcbiAgICAgICAgICAgIC5wcm9wKHF1ZXJ5LnByb3BlcnR5TmFtZSlcbiAgICAgICAgICAgIC5zZXQocXVlcnkuZmlyc3QgPyB0ZW1wb3JhcnkucHJvcCgnZmlyc3QnKSA6IHRlbXBvcmFyeSk7XG4gICAgICAgIHVwZGF0ZVN0YXRlbWVudHMucHVzaChyZWZyZXNoLmFuZCh1cGRhdGVEaXJlY3RpdmUpLnRvU3RtdCgpKTtcbiAgICB9KTtcbiAgICBjb25zdCB2aWV3UXVlcnlGbk5hbWUgPSBuYW1lID8gYCR7bmFtZX1fUXVlcnlgIDogbnVsbDtcbiAgICByZXR1cm4gZm4oW25ldyBGblBhcmFtKFJFTkRFUl9GTEFHUywgTlVNQkVSX1RZUEUpLCBuZXcgRm5QYXJhbShDT05URVhUX05BTUUsIG51bGwpXSwgW1xuICAgICAgICByZW5kZXJGbGFnQ2hlY2tJZlN0bXQoMSAvKiBjb3JlLlJlbmRlckZsYWdzLkNyZWF0ZSAqLywgY3JlYXRlU3RhdGVtZW50cyksXG4gICAgICAgIHJlbmRlckZsYWdDaGVja0lmU3RtdCgyIC8qIGNvcmUuUmVuZGVyRmxhZ3MuVXBkYXRlICovLCB1cGRhdGVTdGF0ZW1lbnRzKVxuICAgIF0sIElORkVSUkVEX1RZUEUsIG51bGwsIHZpZXdRdWVyeUZuTmFtZSk7XG59XG4vLyBSZXR1cm4gYSBob3N0IGJpbmRpbmcgZnVuY3Rpb24gb3IgbnVsbCBpZiBvbmUgaXMgbm90IG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RCaW5kaW5nc0Z1bmN0aW9uKGhvc3RCaW5kaW5nc01ldGFkYXRhLCB0eXBlU291cmNlU3BhbiwgYmluZGluZ1BhcnNlciwgY29uc3RhbnRQb29sLCBzZWxlY3RvciwgbmFtZSwgZGVmaW5pdGlvbk1hcCkge1xuICAgIGNvbnN0IGJpbmRpbmdDb250ZXh0ID0gdmFyaWFibGUoQ09OVEVYVF9OQU1FKTtcbiAgICBjb25zdCBzdHlsZUJ1aWxkZXIgPSBuZXcgU3R5bGluZ0J1aWxkZXIoYmluZGluZ0NvbnRleHQpO1xuICAgIGNvbnN0IHsgc3R5bGVBdHRyLCBjbGFzc0F0dHIgfSA9IGhvc3RCaW5kaW5nc01ldGFkYXRhLnNwZWNpYWxBdHRyaWJ1dGVzO1xuICAgIGlmIChzdHlsZUF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJTdHlsZUF0dHIoc3R5bGVBdHRyKTtcbiAgICB9XG4gICAgaWYgKGNsYXNzQXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0eWxlQnVpbGRlci5yZWdpc3RlckNsYXNzQXR0cihjbGFzc0F0dHIpO1xuICAgIH1cbiAgICBjb25zdCBjcmVhdGVJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVJbnN0cnVjdGlvbnMgPSBbXTtcbiAgICBjb25zdCB1cGRhdGVWYXJpYWJsZXMgPSBbXTtcbiAgICBjb25zdCBob3N0QmluZGluZ1NvdXJjZVNwYW4gPSB0eXBlU291cmNlU3BhbjtcbiAgICAvLyBDYWxjdWxhdGUgaG9zdCBldmVudCBiaW5kaW5nc1xuICAgIGNvbnN0IGV2ZW50QmluZGluZ3MgPSBiaW5kaW5nUGFyc2VyLmNyZWF0ZURpcmVjdGl2ZUhvc3RFdmVudEFzdHMoaG9zdEJpbmRpbmdzTWV0YWRhdGEubGlzdGVuZXJzLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgIGlmIChldmVudEJpbmRpbmdzICYmIGV2ZW50QmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNyZWF0ZUluc3RydWN0aW9ucy5wdXNoKC4uLmNyZWF0ZUhvc3RMaXN0ZW5lcnMoZXZlbnRCaW5kaW5ncywgbmFtZSkpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvc3QgcHJvcGVydHkgYmluZGluZ3NcbiAgICBjb25zdCBiaW5kaW5ncyA9IGJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhob3N0QmluZGluZ3NNZXRhZGF0YS5wcm9wZXJ0aWVzLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgIGNvbnN0IGFsbE90aGVyQmluZGluZ3MgPSBbXTtcbiAgICAvLyBXZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgYW1vdW50IG9mIGJpbmRpbmcgc2xvdHMgcmVxdWlyZWQgYnlcbiAgICAvLyBhbGwgdGhlIGluc3RydWN0aW9ucyB0b2dldGhlciBiZWZvcmUgYW55IHZhbHVlIGNvbnZlcnNpb25zIGhhcHBlbi5cbiAgICAvLyBWYWx1ZSBjb252ZXJzaW9ucyBtYXkgcmVxdWlyZSBhZGRpdGlvbmFsIHNsb3RzIGZvciBpbnRlcnBvbGF0aW9uIGFuZFxuICAgIC8vIGJpbmRpbmdzIHdpdGggcGlwZXMuIFRoZXNlIGNhbGN1bGF0ZXMgaGFwcGVuIGFmdGVyIHRoaXMgYmxvY2suXG4gICAgbGV0IHRvdGFsSG9zdFZhcnNDb3VudCA9IDA7XG4gICAgYmluZGluZ3MgJiYgYmluZGluZ3MuZm9yRWFjaCgoYmluZGluZykgPT4ge1xuICAgICAgICBjb25zdCBzdHlsaW5nSW5wdXRXYXNTZXQgPSBzdHlsZUJ1aWxkZXIucmVnaXN0ZXJJbnB1dEJhc2VkT25OYW1lKGJpbmRpbmcubmFtZSwgYmluZGluZy5leHByZXNzaW9uLCBob3N0QmluZGluZ1NvdXJjZVNwYW4pO1xuICAgICAgICBpZiAoc3R5bGluZ0lucHV0V2FzU2V0KSB7XG4gICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFsbE90aGVyQmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZhbHVlQ29udmVydGVyO1xuICAgIGNvbnN0IGdldFZhbHVlQ29udmVydGVyID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlQ29udmVydGVyKSB7XG4gICAgICAgICAgICBjb25zdCBob3N0VmFyc0NvdW50Rm4gPSAobnVtU2xvdHMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFZhcnNDb3VudCA9IHRvdGFsSG9zdFZhcnNDb3VudDtcbiAgICAgICAgICAgICAgICB0b3RhbEhvc3RWYXJzQ291bnQgKz0gbnVtU2xvdHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsVmFyc0NvdW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhbHVlQ29udmVydGVyID0gbmV3IFZhbHVlQ29udmVydGVyKGNvbnN0YW50UG9vbCwgKCkgPT4gZXJyb3IoJ1VuZXhwZWN0ZWQgbm9kZScpLCAvLyBuZXcgbm9kZXMgYXJlIGlsbGVnYWwgaGVyZVxuICAgICAgICAgICAgaG9zdFZhcnNDb3VudEZuLCAoKSA9PiBlcnJvcignVW5leHBlY3RlZCBwaXBlJykpOyAvLyBwaXBlcyBhcmUgaWxsZWdhbCBoZXJlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlQ29udmVydGVyO1xuICAgIH07XG4gICAgY29uc3QgcHJvcGVydHlCaW5kaW5ncyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZUJpbmRpbmdzID0gW107XG4gICAgY29uc3Qgc3ludGhldGljSG9zdEJpbmRpbmdzID0gW107XG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGFsbE90aGVyQmluZGluZ3MpIHtcbiAgICAgICAgLy8gcmVzb2x2ZSBsaXRlcmFsIGFycmF5cyBhbmQgbGl0ZXJhbCBvYmplY3RzXG4gICAgICAgIGNvbnN0IHZhbHVlID0gYmluZGluZy5leHByZXNzaW9uLnZpc2l0KGdldFZhbHVlQ29udmVydGVyKCkpO1xuICAgICAgICBjb25zdCBiaW5kaW5nRXhwciA9IGJpbmRpbmdGbihiaW5kaW5nQ29udGV4dCwgdmFsdWUpO1xuICAgICAgICBjb25zdCB7IGJpbmRpbmdOYW1lLCBpbnN0cnVjdGlvbiwgaXNBdHRyaWJ1dGUgfSA9IGdldEJpbmRpbmdOYW1lQW5kSW5zdHJ1Y3Rpb24oYmluZGluZyk7XG4gICAgICAgIGNvbnN0IHNlY3VyaXR5Q29udGV4dHMgPSBiaW5kaW5nUGFyc2VyLmNhbGNQb3NzaWJsZVNlY3VyaXR5Q29udGV4dHMoc2VsZWN0b3IsIGJpbmRpbmdOYW1lLCBpc0F0dHJpYnV0ZSlcbiAgICAgICAgICAgIC5maWx0ZXIoY29udGV4dCA9PiBjb250ZXh0ICE9PSBTZWN1cml0eUNvbnRleHQuTk9ORSk7XG4gICAgICAgIGxldCBzYW5pdGl6ZXJGbiA9IG51bGw7XG4gICAgICAgIGlmIChzZWN1cml0eUNvbnRleHRzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHNlY3VyaXR5Q29udGV4dHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb250ZXh0cy5pbmRleE9mKFNlY3VyaXR5Q29udGV4dC5VUkwpID4gLTEgJiZcbiAgICAgICAgICAgICAgICBzZWN1cml0eUNvbnRleHRzLmluZGV4T2YoU2VjdXJpdHlDb250ZXh0LlJFU09VUkNFX1VSTCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc29tZSBVUkwgYXR0cmlidXRlcyAoc3VjaCBhcyBcInNyY1wiIGFuZCBcImhyZWZcIikgdGhhdCBtYXkgYmUgYSBwYXJ0XG4gICAgICAgICAgICAgICAgLy8gb2YgZGlmZmVyZW50IHNlY3VyaXR5IGNvbnRleHRzLiBJbiB0aGlzIGNhc2Ugd2UgdXNlIHNwZWNpYWwgc2FuaXRpemF0aW9uIGZ1bmN0aW9uIGFuZFxuICAgICAgICAgICAgICAgIC8vIHNlbGVjdCB0aGUgYWN0dWFsIHNhbml0aXplciBhdCBydW50aW1lIGJhc2VkIG9uIGEgdGFnIG5hbWUgdGhhdCBpcyBwcm92aWRlZCB3aGlsZVxuICAgICAgICAgICAgICAgIC8vIGludm9raW5nIHNhbml0aXphdGlvbiBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBzYW5pdGl6ZXJGbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuc2FuaXRpemVVcmxPclJlc291cmNlVXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNhbml0aXplckZuID0gcmVzb2x2ZVNhbml0aXphdGlvbkZuKHNlY3VyaXR5Q29udGV4dHNbMF0sIGlzQXR0cmlidXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0cnVjdGlvblBhcmFtcyA9IFtsaXRlcmFsKGJpbmRpbmdOYW1lKSwgYmluZGluZ0V4cHIuY3VyclZhbEV4cHJdO1xuICAgICAgICBpZiAoc2FuaXRpemVyRm4pIHtcbiAgICAgICAgICAgIGluc3RydWN0aW9uUGFyYW1zLnB1c2goc2FuaXRpemVyRm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIHNhbml0aXphdGlvbiBmdW5jdGlvbiBmb3VuZCBiYXNlZCBvbiB0aGUgc2VjdXJpdHkgY29udGV4dFxuICAgICAgICAgICAgLy8gb2YgYW4gYXR0cmlidXRlL3Byb3BlcnR5IGJpbmRpbmcgLSBjaGVjayB3aGV0aGVyIHRoaXMgYXR0cmlidXRlL3Byb3BlcnR5IGlzXG4gICAgICAgICAgICAvLyBvbmUgb2YgdGhlIHNlY3VyaXR5LXNlbnNpdGl2ZSA8aWZyYW1lPiBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgLy8gTm90ZTogZm9yIGhvc3QgYmluZGluZ3MgZGVmaW5lZCBvbiBhIGRpcmVjdGl2ZSwgd2UgZG8gbm90IHRyeSB0byBmaW5kIGFsbFxuICAgICAgICAgICAgLy8gcG9zc2libGUgcGxhY2VzIHdoZXJlIGl0IGNhbiBiZSBtYXRjaGVkLCBzbyB3ZSBjYW4gbm90IGRldGVybWluZSB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGUgaG9zdCBlbGVtZW50IGlzIGFuIDxpZnJhbWU+LiBJbiB0aGlzIGNhc2UsIGlmIGFuIGF0dHJpYnV0ZS9iaW5kaW5nXG4gICAgICAgICAgICAvLyBuYW1lIGlzIGluIHRoZSBgSUZSQU1FX1NFQ1VSSVRZX1NFTlNJVElWRV9BVFRSU2Agc2V0IC0gYXBwZW5kIGEgdmFsaWRhdGlvblxuICAgICAgICAgICAgLy8gZnVuY3Rpb24sIHdoaWNoIHdvdWxkIGJlIGludm9rZWQgYXQgcnVudGltZSBhbmQgd291bGQgaGF2ZSBhY2Nlc3MgdG8gdGhlXG4gICAgICAgICAgICAvLyB1bmRlcmx5aW5nIERPTSBlbGVtZW50LCBjaGVjayBpZiBpdCdzIGFuIDxpZnJhbWU+IGFuZCBpZiBzbyAtIHJ1bnMgZXh0cmEgY2hlY2tzLlxuICAgICAgICAgICAgaWYgKGlzSWZyYW1lU2VjdXJpdHlTZW5zaXRpdmVBdHRyKGJpbmRpbmdOYW1lKSkge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uUGFyYW1zLnB1c2goaW1wb3J0RXhwcihJZGVudGlmaWVycy52YWxpZGF0ZUlmcmFtZUF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVZhcmlhYmxlcy5wdXNoKC4uLmJpbmRpbmdFeHByLnN0bXRzKTtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uID09PSBJZGVudGlmaWVycy5ob3N0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5QmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gPT09IElkZW50aWZpZXJzLmF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlQmluZGluZ3MucHVzaChpbnN0cnVjdGlvblBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5zdHJ1Y3Rpb24gPT09IElkZW50aWZpZXJzLnN5bnRoZXRpY0hvc3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgc3ludGhldGljSG9zdEJpbmRpbmdzLnB1c2goaW5zdHJ1Y3Rpb25QYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlSW5zdHJ1Y3Rpb25zLnB1c2goeyByZWZlcmVuY2U6IGluc3RydWN0aW9uLCBwYXJhbXNPckZuOiBpbnN0cnVjdGlvblBhcmFtcywgc3BhbjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGJpbmRpbmdQYXJhbXMgb2YgcHJvcGVydHlCaW5kaW5ncykge1xuICAgICAgICB1cGRhdGVJbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogSWRlbnRpZmllcnMuaG9zdFByb3BlcnR5LCBwYXJhbXNPckZuOiBiaW5kaW5nUGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGJpbmRpbmdQYXJhbXMgb2YgYXR0cmlidXRlQmluZGluZ3MpIHtcbiAgICAgICAgdXBkYXRlSW5zdHJ1Y3Rpb25zLnB1c2goeyByZWZlcmVuY2U6IElkZW50aWZpZXJzLmF0dHJpYnV0ZSwgcGFyYW1zT3JGbjogYmluZGluZ1BhcmFtcywgc3BhbjogbnVsbCB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBiaW5kaW5nUGFyYW1zIG9mIHN5bnRoZXRpY0hvc3RCaW5kaW5ncykge1xuICAgICAgICB1cGRhdGVJbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogSWRlbnRpZmllcnMuc3ludGhldGljSG9zdFByb3BlcnR5LCBwYXJhbXNPckZuOiBiaW5kaW5nUGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgIH1cbiAgICAvLyBzaW5jZSB3ZSdyZSBkZWFsaW5nIHdpdGggZGlyZWN0aXZlcy9jb21wb25lbnRzIGFuZCBib3RoIGhhdmUgaG9zdEJpbmRpbmdcbiAgICAvLyBmdW5jdGlvbnMsIHdlIG5lZWQgdG8gZ2VuZXJhdGUgYSBzcGVjaWFsIGhvc3RBdHRycyBpbnN0cnVjdGlvbiB0aGF0IGRlYWxzXG4gICAgLy8gd2l0aCBib3RoIHRoZSBhc3NpZ25tZW50IG9mIHN0eWxpbmcgYXMgd2VsbCBhcyBzdGF0aWMgYXR0cmlidXRlcyB0byB0aGUgaG9zdFxuICAgIC8vIGVsZW1lbnQuIFRoZSBpbnN0cnVjdGlvbiBiZWxvdyB3aWxsIGluc3RydWN0IGFsbCBpbml0aWFsIHN0eWxpbmcgKHN0eWxpbmdcbiAgICAvLyB0aGF0IGlzIGluc2lkZSBvZiBhIGhvc3QgYmluZGluZyB3aXRoaW4gYSBkaXJlY3RpdmUvY29tcG9uZW50KSB0byBiZSBhdHRhY2hlZFxuICAgIC8vIHRvIHRoZSBob3N0IGVsZW1lbnQgYWxvbmdzaWRlIGFueSBvZiB0aGUgcHJvdmlkZWQgaG9zdCBhdHRyaWJ1dGVzIHRoYXQgd2VyZVxuICAgIC8vIGNvbGxlY3RlZCBlYXJsaWVyLlxuICAgIGNvbnN0IGhvc3RBdHRycyA9IGNvbnZlcnRBdHRyaWJ1dGVzVG9FeHByZXNzaW9ucyhob3N0QmluZGluZ3NNZXRhZGF0YS5hdHRyaWJ1dGVzKTtcbiAgICBzdHlsZUJ1aWxkZXIuYXNzaWduSG9zdEF0dHJzKGhvc3RBdHRycywgZGVmaW5pdGlvbk1hcCk7XG4gICAgaWYgKHN0eWxlQnVpbGRlci5oYXNCaW5kaW5ncykge1xuICAgICAgICAvLyBmaW5hbGx5IGVhY2ggYmluZGluZyB0aGF0IHdhcyByZWdpc3RlcmVkIGluIHRoZSBzdGF0ZW1lbnQgYWJvdmUgd2lsbCBuZWVkIHRvIGJlIGFkZGVkIHRvXG4gICAgICAgIC8vIHRoZSB1cGRhdGUgYmxvY2sgb2YgYSBjb21wb25lbnQvZGlyZWN0aXZlIHRlbXBsYXRlRm4vaG9zdEJpbmRpbmdzRm4gc28gdGhhdCB0aGUgYmluZGluZ3NcbiAgICAgICAgLy8gYXJlIGV2YWx1YXRlZCBhbmQgdXBkYXRlZCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICAgIHN0eWxlQnVpbGRlci5idWlsZFVwZGF0ZUxldmVsSW5zdHJ1Y3Rpb25zKGdldFZhbHVlQ29udmVydGVyKCkpLmZvckVhY2goaW5zdHJ1Y3Rpb24gPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGluc3RydWN0aW9uLmNhbGxzKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc3VidHJhY3QgYSB2YWx1ZSBvZiBgMWAgaGVyZSBiZWNhdXNlIHRoZSBiaW5kaW5nIHNsb3Qgd2FzIGFscmVhZHkgYWxsb2NhdGVkXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIHRvcCBvZiB0aGlzIG1ldGhvZCB3aGVuIGFsbCB0aGUgaW5wdXQgYmluZGluZ3Mgd2VyZSBjb3VudGVkLlxuICAgICAgICAgICAgICAgIHRvdGFsSG9zdFZhcnNDb3VudCArPVxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChjYWxsLmFsbG9jYXRlQmluZGluZ1Nsb3RzIC0gTUlOX1NUWUxJTkdfQklORElOR19TTE9UU19SRVFVSVJFRCwgMCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlSW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2U6IGluc3RydWN0aW9uLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zT3JGbjogY29udmVydFN0eWxpbmdDYWxsKGNhbGwsIGJpbmRpbmdDb250ZXh0LCBiaW5kaW5nRm4pLFxuICAgICAgICAgICAgICAgICAgICBzcGFuOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodG90YWxIb3N0VmFyc0NvdW50KSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdob3N0VmFycycsIGxpdGVyYWwodG90YWxIb3N0VmFyc0NvdW50KSk7XG4gICAgfVxuICAgIGlmIChjcmVhdGVJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCB8fCB1cGRhdGVJbnN0cnVjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBob3N0QmluZGluZ3NGbk5hbWUgPSBuYW1lID8gYCR7bmFtZX1fSG9zdEJpbmRpbmdzYCA6IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudHMgPSBbXTtcbiAgICAgICAgaWYgKGNyZWF0ZUluc3RydWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyRmxhZ0NoZWNrSWZTdG10KDEgLyogY29yZS5SZW5kZXJGbGFncy5DcmVhdGUgKi8sIGdldEluc3RydWN0aW9uU3RhdGVtZW50cyhjcmVhdGVJbnN0cnVjdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZUluc3RydWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2gocmVuZGVyRmxhZ0NoZWNrSWZTdG10KDIgLyogY29yZS5SZW5kZXJGbGFncy5VcGRhdGUgKi8sIHVwZGF0ZVZhcmlhYmxlcy5jb25jYXQoZ2V0SW5zdHJ1Y3Rpb25TdGF0ZW1lbnRzKHVwZGF0ZUluc3RydWN0aW9ucykpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuKFtuZXcgRm5QYXJhbShSRU5ERVJfRkxBR1MsIE5VTUJFUl9UWVBFKSwgbmV3IEZuUGFyYW0oQ09OVEVYVF9OQU1FLCBudWxsKV0sIHN0YXRlbWVudHMsIElORkVSUkVEX1RZUEUsIG51bGwsIGhvc3RCaW5kaW5nc0ZuTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYmluZGluZ0ZuKGltcGxpY2l0LCB2YWx1ZSkge1xuICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlCaW5kaW5nKG51bGwsIGltcGxpY2l0LCB2YWx1ZSwgJ2InKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTdHlsaW5nQ2FsbChjYWxsLCBiaW5kaW5nQ29udGV4dCwgYmluZGluZ0ZuKSB7XG4gICAgcmV0dXJuIGNhbGwucGFyYW1zKHZhbHVlID0+IGJpbmRpbmdGbihiaW5kaW5nQ29udGV4dCwgdmFsdWUpLmN1cnJWYWxFeHByKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdOYW1lQW5kSW5zdHJ1Y3Rpb24oYmluZGluZykge1xuICAgIGxldCBiaW5kaW5nTmFtZSA9IGJpbmRpbmcubmFtZTtcbiAgICBsZXQgaW5zdHJ1Y3Rpb247XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYW4gYXR0ciBiaW5kaW5nIG9yIGEgcHJvcGVydHkgYmluZGluZ1xuICAgIGNvbnN0IGF0dHJNYXRjaGVzID0gYmluZGluZ05hbWUubWF0Y2goQVRUUl9SRUdFWCk7XG4gICAgaWYgKGF0dHJNYXRjaGVzKSB7XG4gICAgICAgIGJpbmRpbmdOYW1lID0gYXR0ck1hdGNoZXNbMV07XG4gICAgICAgIGluc3RydWN0aW9uID0gSWRlbnRpZmllcnMuYXR0cmlidXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpbmRpbmcuaXNBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGJpbmRpbmdOYW1lID0gcHJlcGFyZVN5bnRoZXRpY1Byb3BlcnR5TmFtZShiaW5kaW5nTmFtZSk7XG4gICAgICAgICAgICAvLyBob3N0IGJpbmRpbmdzIHRoYXQgaGF2ZSBhIHN5bnRoZXRpYyBwcm9wZXJ0eSAoZS5nLiBAZm9vKSBzaG91bGQgYWx3YXlzIGJlIHJlbmRlcmVkXG4gICAgICAgICAgICAvLyBpbiB0aGUgY29udGV4dCBvZiB0aGUgY29tcG9uZW50IGFuZCBub3QgdGhlIHBhcmVudC4gVGhlcmVmb3JlIHRoZXJlIGlzIGEgc3BlY2lhbFxuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBpbnN0cnVjdGlvbiBhdmFpbGFibGUgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgICAgIGluc3RydWN0aW9uID0gSWRlbnRpZmllcnMuc3ludGhldGljSG9zdFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb24gPSBJZGVudGlmaWVycy5ob3N0UHJvcGVydHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmluZGluZ05hbWUsIGluc3RydWN0aW9uLCBpc0F0dHJpYnV0ZTogISFhdHRyTWF0Y2hlcyB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdExpc3RlbmVycyhldmVudEJpbmRpbmdzLCBuYW1lKSB7XG4gICAgY29uc3QgbGlzdGVuZXJQYXJhbXMgPSBbXTtcbiAgICBjb25zdCBzeW50aGV0aWNMaXN0ZW5lclBhcmFtcyA9IFtdO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBldmVudEJpbmRpbmdzKSB7XG4gICAgICAgIGxldCBiaW5kaW5nTmFtZSA9IGJpbmRpbmcubmFtZSAmJiBzYW5pdGl6ZUlkZW50aWZpZXIoYmluZGluZy5uYW1lKTtcbiAgICAgICAgY29uc3QgYmluZGluZ0ZuTmFtZSA9IGJpbmRpbmcudHlwZSA9PT0gMSAvKiBQYXJzZWRFdmVudFR5cGUuQW5pbWF0aW9uICovID9cbiAgICAgICAgICAgIHByZXBhcmVTeW50aGV0aWNMaXN0ZW5lckZ1bmN0aW9uTmFtZShiaW5kaW5nTmFtZSwgYmluZGluZy50YXJnZXRPclBoYXNlKSA6XG4gICAgICAgICAgICBiaW5kaW5nTmFtZTtcbiAgICAgICAgY29uc3QgaGFuZGxlck5hbWUgPSBuYW1lICYmIGJpbmRpbmdOYW1lID8gYCR7bmFtZX1fJHtiaW5kaW5nRm5OYW1lfV9Ib3N0QmluZGluZ0hhbmRsZXJgIDogbnVsbDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gcHJlcGFyZUV2ZW50TGlzdGVuZXJQYXJhbWV0ZXJzKEJvdW5kRXZlbnQuZnJvbVBhcnNlZEV2ZW50KGJpbmRpbmcpLCBoYW5kbGVyTmFtZSk7XG4gICAgICAgIGlmIChiaW5kaW5nLnR5cGUgPT0gMSAvKiBQYXJzZWRFdmVudFR5cGUuQW5pbWF0aW9uICovKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNMaXN0ZW5lclBhcmFtcy5wdXNoKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lclBhcmFtcy5wdXNoKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJhbXMgb2Ygc3ludGhldGljTGlzdGVuZXJQYXJhbXMpIHtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goeyByZWZlcmVuY2U6IElkZW50aWZpZXJzLnN5bnRoZXRpY0hvc3RMaXN0ZW5lciwgcGFyYW1zT3JGbjogcGFyYW1zLCBzcGFuOiBudWxsIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcmFtcyBvZiBsaXN0ZW5lclBhcmFtcykge1xuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh7IHJlZmVyZW5jZTogSWRlbnRpZmllcnMubGlzdGVuZXIsIHBhcmFtc09yRm46IHBhcmFtcywgc3BhbjogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbn1cbmNvbnN0IEhPU1RfUkVHX0VYUCA9IC9eKD86XFxbKFteXFxdXSspXFxdKXwoPzpcXCgoW15cXCldKylcXCkpJC87XG5mdW5jdGlvbiBwYXJzZUhvc3RCaW5kaW5ncyhob3N0KSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHt9O1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCBzcGVjaWFsQXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhvc3QpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaG9zdFtrZXldO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0ga2V5Lm1hdGNoKEhPU1RfUkVHX0VYUCk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhc3MgYmluZGluZyBtdXN0IGJlIHN0cmluZ2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxBdHRyaWJ1dGVzLmNsYXNzQXR0ciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0eWxlIGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQXR0cmlidXRlcy5zdHlsZUF0dHIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGxpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzEgLyogSG9zdEJpbmRpbmdHcm91cC5CaW5kaW5nICovXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8oYWx4aHViKTogbWFrZSB0aGlzIGEgZGlhZ25vc3RpYy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3BlcnR5IGJpbmRpbmcgbXVzdCBiZSBzdHJpbmdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN5bnRoZXRpYyBwcm9wZXJ0aWVzICh0aGUgb25lcyB0aGF0IGhhdmUgYSBgQGAgYXMgYSBwcmVmaXgpXG4gICAgICAgICAgICAvLyBhcmUgc3RpbGwgdHJlYXRlZCB0aGUgc2FtZSBhcyByZWd1bGFyIHByb3BlcnRpZXMuIFRoZXJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gcG9pbnQgaW4gc3RvcmluZyB0aGVtIGluIGEgc2VwYXJhdGUgbWFwLlxuICAgICAgICAgICAgcHJvcGVydGllc1ttYXRjaGVzWzEgLyogSG9zdEJpbmRpbmdHcm91cC5CaW5kaW5nICovXV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXRjaGVzWzIgLyogSG9zdEJpbmRpbmdHcm91cC5FdmVudCAqL10gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IG1ha2UgdGhpcyBhIGRpYWdub3N0aWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFdmVudCBiaW5kaW5nIG11c3QgYmUgc3RyaW5nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcnNbbWF0Y2hlc1syIC8qIEhvc3RCaW5kaW5nR3JvdXAuRXZlbnQgKi9dXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGF0dHJpYnV0ZXMsIGxpc3RlbmVycywgcHJvcGVydGllcywgc3BlY2lhbEF0dHJpYnV0ZXMgfTtcbn1cbi8qKlxuICogVmVyaWZpZXMgaG9zdCBiaW5kaW5ncyBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBlcnJvcnMgKGlmIGFueSkuIEVtcHR5IGFycmF5IGluZGljYXRlcyB0aGF0IGFcbiAqIGdpdmVuIHNldCBvZiBob3N0IGJpbmRpbmdzIGhhcyBubyBlcnJvcnMuXG4gKlxuICogQHBhcmFtIGJpbmRpbmdzIHNldCBvZiBob3N0IGJpbmRpbmdzIHRvIHZlcmlmeS5cbiAqIEBwYXJhbSBzb3VyY2VTcGFuIHNvdXJjZSBzcGFuIHdoZXJlIGhvc3QgYmluZGluZ3Mgd2VyZSBkZWZpbmVkLlxuICogQHJldHVybnMgYXJyYXkgb2YgZXJyb3JzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHNldCBvZiBob3N0IGJpbmRpbmdzLlxuICovXG5mdW5jdGlvbiB2ZXJpZnlIb3N0QmluZGluZ3MoYmluZGluZ3MsIHNvdXJjZVNwYW4pIHtcbiAgICAvLyBUT0RPOiBhYnN0cmFjdCBvdXQgaG9zdCBiaW5kaW5ncyB2ZXJpZmljYXRpb24gbG9naWMgYW5kIHVzZSBpdCBpbnN0ZWFkIG9mXG4gICAgLy8gY3JlYXRpbmcgZXZlbnRzIGFuZCBwcm9wZXJ0aWVzIEFTVHMgdG8gZGV0ZWN0IGVycm9ycyAoRlctOTk2KVxuICAgIGNvbnN0IGJpbmRpbmdQYXJzZXIgPSBtYWtlQmluZGluZ1BhcnNlcigpO1xuICAgIGJpbmRpbmdQYXJzZXIuY3JlYXRlRGlyZWN0aXZlSG9zdEV2ZW50QXN0cyhiaW5kaW5ncy5saXN0ZW5lcnMsIHNvdXJjZVNwYW4pO1xuICAgIGJpbmRpbmdQYXJzZXIuY3JlYXRlQm91bmRIb3N0UHJvcGVydGllcyhiaW5kaW5ncy5wcm9wZXJ0aWVzLCBzb3VyY2VTcGFuKTtcbiAgICByZXR1cm4gYmluZGluZ1BhcnNlci5lcnJvcnM7XG59XG5mdW5jdGlvbiBjb21waWxlU3R5bGVzKHN0eWxlcywgc2VsZWN0b3IsIGhvc3RTZWxlY3Rvcikge1xuICAgIGNvbnN0IHNoYWRvd0NzcyA9IG5ldyBTaGFkb3dDc3MoKTtcbiAgICByZXR1cm4gc3R5bGVzLm1hcChzdHlsZSA9PiB7XG4gICAgICAgIHJldHVybiBzaGFkb3dDc3Muc2hpbUNzc1RleHQoc3R5bGUsIHNlbGVjdG9yLCBob3N0U2VsZWN0b3IpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdERpcmVjdGl2ZXNUeXBlKG1ldGEpIHtcbiAgICBpZiAoIW1ldGEuaG9zdERpcmVjdGl2ZXM/Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gTk9ORV9UWVBFO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvblR5cGUobGl0ZXJhbEFycihtZXRhLmhvc3REaXJlY3RpdmVzLm1hcChob3N0TWV0YSA9PiBsaXRlcmFsTWFwKFtcbiAgICAgICAgeyBrZXk6ICdkaXJlY3RpdmUnLCB2YWx1ZTogdHlwZW9mRXhwcihob3N0TWV0YS5kaXJlY3RpdmUudHlwZSksIHF1b3RlZDogZmFsc2UgfSxcbiAgICAgICAgeyBrZXk6ICdpbnB1dHMnLCB2YWx1ZTogc3RyaW5nTWFwQXNMaXRlcmFsRXhwcmVzc2lvbihob3N0TWV0YS5pbnB1dHMgfHwge30pLCBxdW90ZWQ6IGZhbHNlIH0sXG4gICAgICAgIHsga2V5OiAnb3V0cHV0cycsIHZhbHVlOiBzdHJpbmdNYXBBc0xpdGVyYWxFeHByZXNzaW9uKGhvc3RNZXRhLm91dHB1dHMgfHwge30pLCBxdW90ZWQ6IGZhbHNlIH0sXG4gICAgXSkpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0RGlyZWN0aXZlc0ZlYXR1cmVBcmcoaG9zdERpcmVjdGl2ZXMpIHtcbiAgICBjb25zdCBleHByZXNzaW9ucyA9IFtdO1xuICAgIGxldCBoYXNGb3J3YXJkUmVmID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjdXJyZW50IG9mIGhvc3REaXJlY3RpdmVzKSB7XG4gICAgICAgIC8vIFVzZSBhIHNob3J0aGFuZCBpZiB0aGVyZSBhcmUgbm8gaW5wdXRzIG9yIG91dHB1dHMuXG4gICAgICAgIGlmICghY3VycmVudC5pbnB1dHMgJiYgIWN1cnJlbnQub3V0cHV0cykge1xuICAgICAgICAgICAgZXhwcmVzc2lvbnMucHVzaChjdXJyZW50LmRpcmVjdGl2ZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbeyBrZXk6ICdkaXJlY3RpdmUnLCB2YWx1ZTogY3VycmVudC5kaXJlY3RpdmUudHlwZSwgcXVvdGVkOiBmYWxzZSB9XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50LmlucHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0c0xpdGVyYWwgPSBjcmVhdGVIb3N0RGlyZWN0aXZlc01hcHBpbmdBcnJheShjdXJyZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0c0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHsga2V5OiAnaW5wdXRzJywgdmFsdWU6IGlucHV0c0xpdGVyYWwsIHF1b3RlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQub3V0cHV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHNMaXRlcmFsID0gY3JlYXRlSG9zdERpcmVjdGl2ZXNNYXBwaW5nQXJyYXkoY3VycmVudC5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0c0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHsga2V5OiAnb3V0cHV0cycsIHZhbHVlOiBvdXRwdXRzTGl0ZXJhbCwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGxpdGVyYWxNYXAoa2V5cykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50LmlzRm9yd2FyZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgaGFzRm9yd2FyZFJlZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyBhIGZvcndhcmQgcmVmZXJlbmNlLCB3ZSBnZW5lcmF0ZSBhIGBmdW5jdGlvbigpIHsgcmV0dXJuIFtIb3N0RGlyXSB9YCxcbiAgICAvLyBvdGhlcndpc2Ugd2UgY2FuIHNhdmUgc29tZSBieXRlcyBieSB1c2luZyBhIHBsYWluIGFycmF5LCBlLmcuIGBbSG9zdERpcl1gLlxuICAgIHJldHVybiBoYXNGb3J3YXJkUmVmID9cbiAgICAgICAgbmV3IEZ1bmN0aW9uRXhwcihbXSwgW25ldyBSZXR1cm5TdGF0ZW1lbnQobGl0ZXJhbEFycihleHByZXNzaW9ucykpXSkgOlxuICAgICAgICBsaXRlcmFsQXJyKGV4cHJlc3Npb25zKTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gaW5wdXQvb3V0cHV0IG1hcHBpbmcgb2JqZWN0IGxpdGVyYWwgaW50byBhbiBhcnJheSB3aGVyZSB0aGUgZXZlbiBrZXlzIGFyZSB0aGVcbiAqIHB1YmxpYyBuYW1lIG9mIHRoZSBiaW5kaW5nIGFuZCB0aGUgb2RkIG9uZXMgYXJlIHRoZSBuYW1lIGl0IHdhcyBhbGlhc2VkIHRvLiBFLmcuXG4gKiBge2lucHV0T25lOiAnYWxpYXNPbmUnLCBpbnB1dFR3bzogJ2FsaWFzVHdvJ31gIHdpbGwgYmVjb21lXG4gKiBgWydpbnB1dE9uZScsICdhbGlhc09uZScsICdpbnB1dFR3bycsICdhbGlhc1R3byddYC5cbiAqXG4gKiBUaGlzIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LCBiZWNhdXNlIGhvc3RzIGJpbmQgdG8gdGhlIHB1YmxpYyBuYW1lIG9mIHRoZSBob3N0IGRpcmVjdGl2ZSBhbmRcbiAqIGtlZXBpbmcgdGhlIG1hcHBpbmcgaW4gYW4gb2JqZWN0IGxpdGVyYWwgd2lsbCBicmVhayBmb3IgYXBwcyB1c2luZyBwcm9wZXJ0eSByZW5hbWluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG9zdERpcmVjdGl2ZXNNYXBwaW5nQXJyYXkobWFwcGluZykge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgZm9yIChjb25zdCBwdWJsaWNOYW1lIGluIG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuaGFzT3duUHJvcGVydHkocHVibGljTmFtZSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobGl0ZXJhbChwdWJsaWNOYW1lKSwgbGl0ZXJhbChtYXBwaW5nW3B1YmxpY05hbWVdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aCA+IDAgPyBsaXRlcmFsQXJyKGVsZW1lbnRzKSA6IG51bGw7XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIGZvciByZXRyaWV2aW5nIGRvY3VtZW50cyBieSBVUkwgdGhhdCB0aGUgY29tcGlsZXIgdXNlcyB0b1xuICogbG9hZCB0ZW1wbGF0ZXMuXG4gKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBjbGFzcywgcmF0aGVyIHRoYW4gYW4gaW50ZXJmYWNlLCBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkXG4gKiBhcyBpbmplY3Rpb24gdG9rZW4uXG4gKi9cbmNsYXNzIFJlc291cmNlTG9hZGVyIHtcbn1cblxuY2xhc3MgQ29tcGlsZXJGYWNhZGVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihqaXRFdmFsdWF0b3IgPSBuZXcgSml0RXZhbHVhdG9yKCkpIHtcbiAgICAgICAgdGhpcy5qaXRFdmFsdWF0b3IgPSBqaXRFdmFsdWF0b3I7XG4gICAgICAgIHRoaXMuRmFjdG9yeVRhcmdldCA9IEZhY3RvcnlUYXJnZXQkMTtcbiAgICAgICAgdGhpcy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xuICAgICAgICB0aGlzLmVsZW1lbnRTY2hlbWFSZWdpc3RyeSA9IG5ldyBEb21FbGVtZW50U2NoZW1hUmVnaXN0cnkoKTtcbiAgICB9XG4gICAgY29tcGlsZVBpcGUoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgbmFtZTogZmFjYWRlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgICAgIGRlcHM6IG51bGwsXG4gICAgICAgICAgICBwaXBlTmFtZTogZmFjYWRlLnBpcGVOYW1lLFxuICAgICAgICAgICAgcHVyZTogZmFjYWRlLnB1cmUsXG4gICAgICAgICAgICBpc1N0YW5kYWxvbmU6IGZhY2FkZS5pc1N0YW5kYWxvbmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVQaXBlRnJvbU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgW10pO1xuICAgIH1cbiAgICBjb21waWxlUGlwZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb252ZXJ0RGVjbGFyZVBpcGVGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdGFibGUoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZmFjYWRlKSB7XG4gICAgICAgIGNvbnN0IHsgZXhwcmVzc2lvbiwgc3RhdGVtZW50cyB9ID0gY29tcGlsZUluamVjdGFibGUoe1xuICAgICAgICAgICAgbmFtZTogZmFjYWRlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogZmFjYWRlLnR5cGVBcmd1bWVudENvdW50LFxuICAgICAgICAgICAgcHJvdmlkZWRJbjogY29tcHV0ZVByb3ZpZGVkSW4oZmFjYWRlLnByb3ZpZGVkSW4pLFxuICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VDbGFzcycpLFxuICAgICAgICAgICAgdXNlRmFjdG9yeTogd3JhcEV4cHJlc3Npb24oZmFjYWRlLCAndXNlRmFjdG9yeScpLFxuICAgICAgICAgICAgdXNlVmFsdWU6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VWYWx1ZScpLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihmYWNhZGUsICd1c2VFeGlzdGluZycpLFxuICAgICAgICAgICAgZGVwczogZmFjYWRlLmRlcHM/Lm1hcChjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGEpLFxuICAgICAgICB9LCBcbiAgICAgICAgLyogcmVzb2x2ZUZvcndhcmRSZWZzICovIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIHN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlSW5qZWN0YWJsZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb24sIHN0YXRlbWVudHMgfSA9IGNvbXBpbGVJbmplY3RhYmxlKHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS50eXBlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgICAgIHByb3ZpZGVkSW46IGNvbXB1dGVQcm92aWRlZEluKGZhY2FkZS5wcm92aWRlZEluKSxcbiAgICAgICAgICAgIHVzZUNsYXNzOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlQ2xhc3MnKSxcbiAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHdyYXBFeHByZXNzaW9uKGZhY2FkZSwgJ3VzZUZhY3RvcnknKSxcbiAgICAgICAgICAgIHVzZVZhbHVlOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlVmFsdWUnKSxcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBjb252ZXJ0VG9Qcm92aWRlckV4cHJlc3Npb24oZmFjYWRlLCAndXNlRXhpc3RpbmcnKSxcbiAgICAgICAgICAgIGRlcHM6IGZhY2FkZS5kZXBzPy5tYXAoY29udmVydFIzRGVjbGFyZURlcGVuZGVuY3lNZXRhZGF0YSksXG4gICAgICAgIH0sIFxuICAgICAgICAvKiByZXNvbHZlRm9yd2FyZFJlZnMgKi8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgc3RhdGVtZW50cyk7XG4gICAgfVxuICAgIGNvbXBpbGVJbmplY3Rvcihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGZhY2FkZS5uYW1lLFxuICAgICAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBmYWNhZGUucHJvdmlkZXJzICYmIGZhY2FkZS5wcm92aWRlcnMubGVuZ3RoID4gMCA/XG4gICAgICAgICAgICAgICAgbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGltcG9ydHM6IGZhY2FkZS5pbXBvcnRzLm1hcChpID0+IG5ldyBXcmFwcGVkTm9kZUV4cHIoaSkpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSBjb21waWxlSW5qZWN0b3IobWV0YSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24ocmVzLmV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZUluamVjdG9yRGVjbGFyYXRpb24oYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgZGVjbGFyYXRpb24pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlSW5qZWN0b3JGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZUluamVjdG9yKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVOZ01vZHVsZShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZmFjYWRlLnR5cGUpLFxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgICAgIGFkamFjZW50VHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudHlwZSksXG4gICAgICAgICAgICBib290c3RyYXA6IGZhY2FkZS5ib290c3RyYXAubWFwKHdyYXBSZWZlcmVuY2UpLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBmYWNhZGUuZGVjbGFyYXRpb25zLm1hcCh3cmFwUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIHB1YmxpY0RlY2xhcmF0aW9uVHlwZXM6IG51bGwsXG4gICAgICAgICAgICBpbXBvcnRzOiBmYWNhZGUuaW1wb3J0cy5tYXAod3JhcFJlZmVyZW5jZSksXG4gICAgICAgICAgICBpbmNsdWRlSW1wb3J0VHlwZXM6IHRydWUsXG4gICAgICAgICAgICBleHBvcnRzOiBmYWNhZGUuZXhwb3J0cy5tYXAod3JhcFJlZmVyZW5jZSksXG4gICAgICAgICAgICBzZWxlY3RvclNjb3BlTW9kZTogUjNTZWxlY3RvclNjb3BlTW9kZS5JbmxpbmUsXG4gICAgICAgICAgICBjb250YWluc0ZvcndhcmREZWNsczogZmFsc2UsXG4gICAgICAgICAgICBzY2hlbWFzOiBmYWNhZGUuc2NoZW1hcyA/IGZhY2FkZS5zY2hlbWFzLm1hcCh3cmFwUmVmZXJlbmNlKSA6IG51bGwsXG4gICAgICAgICAgICBpZDogZmFjYWRlLmlkID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUuaWQpIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gY29tcGlsZU5nTW9kdWxlKG1ldGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKHJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBbXSk7XG4gICAgfVxuICAgIGNvbXBpbGVOZ01vZHVsZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBjb21waWxlTmdNb2R1bGVEZWNsYXJhdGlvbkV4cHJlc3Npb24oZGVjbGFyYXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5qaXRFeHByZXNzaW9uKGV4cHJlc3Npb24sIGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIFtdKTtcbiAgICB9XG4gICAgY29tcGlsZURpcmVjdGl2ZShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWNhZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREaXJlY3RpdmVGYWNhZGVUb01ldGFkYXRhKGZhY2FkZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKTtcbiAgICB9XG4gICAgY29tcGlsZURpcmVjdGl2ZURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGRlY2xhcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IHR5cGVTb3VyY2VTcGFuID0gdGhpcy5jcmVhdGVQYXJzZVNvdXJjZVNwYW4oJ0RpcmVjdGl2ZScsIGRlY2xhcmF0aW9uLnR5cGUubmFtZSwgc291cmNlTWFwVXJsKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IGNvbnZlcnREZWNsYXJlRGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbiwgdHlwZVNvdXJjZVNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlRGlyZWN0aXZlRnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSk7XG4gICAgfVxuICAgIGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgY29uc3QgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKCk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgY29uc3RhbnRQb29sLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlQ29tcG9uZW50KGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIGZhY2FkZSkge1xuICAgICAgICAvLyBQYXJzZSB0aGUgdGVtcGxhdGUgYW5kIGNoZWNrIGZvciBlcnJvcnMuXG4gICAgICAgIGNvbnN0IHsgdGVtcGxhdGUsIGludGVycG9sYXRpb24gfSA9IHBhcnNlSml0VGVtcGxhdGUoZmFjYWRlLnRlbXBsYXRlLCBmYWNhZGUubmFtZSwgc291cmNlTWFwVXJsLCBmYWNhZGUucHJlc2VydmVXaGl0ZXNwYWNlcywgZmFjYWRlLmludGVycG9sYXRpb24pO1xuICAgICAgICAvLyBDb21waWxlIHRoZSBjb21wb25lbnQgbWV0YWRhdGEsIGluY2x1ZGluZyB0ZW1wbGF0ZSwgaW50byBhbiBleHByZXNzaW9uLlxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgLi4uZmFjYWRlLFxuICAgICAgICAgICAgLi4uY29udmVydERpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZmFjYWRlKSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBmYWNhZGUuc2VsZWN0b3IgfHwgdGhpcy5lbGVtZW50U2NoZW1hUmVnaXN0cnkuZ2V0RGVmYXVsdENvbXBvbmVudEVsZW1lbnROYW1lKCksXG4gICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogZmFjYWRlLmRlY2xhcmF0aW9ucy5tYXAoY29udmVydERlY2xhcmF0aW9uRmFjYWRlVG9NZXRhZGF0YSksXG4gICAgICAgICAgICBkZWNsYXJhdGlvbkxpc3RFbWl0TW9kZTogMCAvKiBEZWNsYXJhdGlvbkxpc3RFbWl0TW9kZS5EaXJlY3QgKi8sXG4gICAgICAgICAgICBzdHlsZXM6IFsuLi5mYWNhZGUuc3R5bGVzLCAuLi50ZW1wbGF0ZS5zdHlsZXNdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogZmFjYWRlLmVuY2Fwc3VsYXRpb24sXG4gICAgICAgICAgICBpbnRlcnBvbGF0aW9uLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBmYWNhZGUuY2hhbmdlRGV0ZWN0aW9uLFxuICAgICAgICAgICAgYW5pbWF0aW9uczogZmFjYWRlLmFuaW1hdGlvbnMgIT0gbnVsbCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZmFjYWRlLmFuaW1hdGlvbnMpIDogbnVsbCxcbiAgICAgICAgICAgIHZpZXdQcm92aWRlcnM6IGZhY2FkZS52aWV3UHJvdmlkZXJzICE9IG51bGwgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS52aWV3UHJvdmlkZXJzKSA6XG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoOiAnJyxcbiAgICAgICAgICAgIGkxOG5Vc2VFeHRlcm5hbElkczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgaml0RXhwcmVzc2lvblNvdXJjZU1hcCA9IGBuZzovLy8ke2ZhY2FkZS5uYW1lfS5qc2A7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVDb21wb25lbnRGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgaml0RXhwcmVzc2lvblNvdXJjZU1hcCwgbWV0YSk7XG4gICAgfVxuICAgIGNvbXBpbGVDb21wb25lbnREZWNsYXJhdGlvbihhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBkZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCB0eXBlU291cmNlU3BhbiA9IHRoaXMuY3JlYXRlUGFyc2VTb3VyY2VTcGFuKCdDb21wb25lbnQnLCBkZWNsYXJhdGlvbi50eXBlLm5hbWUsIHNvdXJjZU1hcFVybCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBjb252ZXJ0RGVjbGFyZUNvbXBvbmVudEZhY2FkZVRvTWV0YWRhdGEoZGVjbGFyYXRpb24sIHR5cGVTb3VyY2VTcGFuLCBzb3VyY2VNYXBVcmwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQ29tcG9uZW50RnJvbU1ldGEoYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgbWV0YSk7XG4gICAgfVxuICAgIGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0YW50UG9vbCA9IG5ldyBDb25zdGFudFBvb2woKTtcbiAgICAgICAgY29uc3QgYmluZGluZ1BhcnNlciA9IG1ha2VCaW5kaW5nUGFyc2VyKG1ldGEuaW50ZXJwb2xhdGlvbik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YWRhdGEobWV0YSwgY29uc3RhbnRQb29sLCBiaW5kaW5nUGFyc2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaml0RXhwcmVzc2lvbihyZXMuZXhwcmVzc2lvbiwgYW5ndWxhckNvcmVFbnYsIHNvdXJjZU1hcFVybCwgY29uc3RhbnRQb29sLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlRmFjdG9yeShhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnlSZXMgPSBjb21waWxlRmFjdG9yeUZ1bmN0aW9uKHtcbiAgICAgICAgICAgIG5hbWU6IG1ldGEubmFtZSxcbiAgICAgICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UobWV0YS50eXBlKSxcbiAgICAgICAgICAgIGludGVybmFsVHlwZTogbmV3IFdyYXBwZWROb2RlRXhwcihtZXRhLnR5cGUpLFxuICAgICAgICAgICAgdHlwZUFyZ3VtZW50Q291bnQ6IG1ldGEudHlwZUFyZ3VtZW50Q291bnQsXG4gICAgICAgICAgICBkZXBzOiBjb252ZXJ0UjNEZXBlbmRlbmN5TWV0YWRhdGFBcnJheShtZXRhLmRlcHMpLFxuICAgICAgICAgICAgdGFyZ2V0OiBtZXRhLnRhcmdldCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24oZmFjdG9yeVJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWN0b3J5UmVzLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjb21waWxlRmFjdG9yeURlY2xhcmF0aW9uKGFuZ3VsYXJDb3JlRW52LCBzb3VyY2VNYXBVcmwsIG1ldGEpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeVJlcyA9IGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24oe1xuICAgICAgICAgICAgbmFtZTogbWV0YS50eXBlLm5hbWUsXG4gICAgICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKG1ldGEudHlwZSksXG4gICAgICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIobWV0YS50eXBlKSxcbiAgICAgICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICAgICAgZGVwczogQXJyYXkuaXNBcnJheShtZXRhLmRlcHMpID8gbWV0YS5kZXBzLm1hcChjb252ZXJ0UjNEZWNsYXJlRGVwZW5kZW5jeU1ldGFkYXRhKSA6XG4gICAgICAgICAgICAgICAgbWV0YS5kZXBzLFxuICAgICAgICAgICAgdGFyZ2V0OiBtZXRhLnRhcmdldCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmppdEV4cHJlc3Npb24oZmFjdG9yeVJlcy5leHByZXNzaW9uLCBhbmd1bGFyQ29yZUVudiwgc291cmNlTWFwVXJsLCBmYWN0b3J5UmVzLnN0YXRlbWVudHMpO1xuICAgIH1cbiAgICBjcmVhdGVQYXJzZVNvdXJjZVNwYW4oa2luZCwgdHlwZU5hbWUsIHNvdXJjZVVybCkge1xuICAgICAgICByZXR1cm4gcjNKaXRUeXBlU291cmNlU3BhbihraW5kLCB0eXBlTmFtZSwgc291cmNlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSklUIGNvbXBpbGVzIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgdGhhdCBleHByZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlZiB0aGUgZGVmaW5pdGlvbiB3aGljaCB3aWxsIGJlIGNvbXBpbGVkIGFuZCBleGVjdXRlZCB0byBnZXQgdGhlIHZhbHVlIHRvIHBhdGNoXG4gICAgICogQHBhcmFtIGNvbnRleHQgYW4gb2JqZWN0IG1hcCBvZiBAYW5ndWxhci9jb3JlIHN5bWJvbCBuYW1lcyB0byBzeW1ib2xzIHdoaWNoIHdpbGwgYmUgYXZhaWxhYmxlXG4gICAgICogaW4gdGhlIGNvbnRleHQgb2YgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gc291cmNlVXJsIGEgVVJMIHRvIHVzZSBmb3IgdGhlIHNvdXJjZSBtYXAgb2YgdGhlIGNvbXBpbGVkIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0gcHJlU3RhdGVtZW50cyBhIGNvbGxlY3Rpb24gb2Ygc3RhdGVtZW50cyB0aGF0IHNob3VsZCBiZSBldmFsdWF0ZWQgYmVmb3JlIHRoZSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGppdEV4cHJlc3Npb24oZGVmLCBjb250ZXh0LCBzb3VyY2VVcmwsIHByZVN0YXRlbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIENvbnN0YW50UG9vbCBtYXkgY29udGFpbiBTdGF0ZW1lbnRzIHdoaWNoIGRlY2xhcmUgdmFyaWFibGVzIHVzZWQgaW4gdGhlIGZpbmFsIGV4cHJlc3Npb24uXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgaXRzIHN0YXRlbWVudHMgbmVlZCB0byBwcmVjZWRlIHRoZSBhY3R1YWwgSklUIG9wZXJhdGlvbi4gVGhlIGZpbmFsIHN0YXRlbWVudCBpcyBhXG4gICAgICAgIC8vIGRlY2xhcmF0aW9uIG9mICRkZWYgd2hpY2ggaXMgc2V0IHRvIHRoZSBleHByZXNzaW9uIGJlaW5nIGNvbXBpbGVkLlxuICAgICAgICBjb25zdCBzdGF0ZW1lbnRzID0gW1xuICAgICAgICAgICAgLi4ucHJlU3RhdGVtZW50cyxcbiAgICAgICAgICAgIG5ldyBEZWNsYXJlVmFyU3RtdCgnJGRlZicsIGRlZiwgdW5kZWZpbmVkLCBTdG10TW9kaWZpZXIuRXhwb3J0ZWQpLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmppdEV2YWx1YXRvci5ldmFsdWF0ZVN0YXRlbWVudHMoc291cmNlVXJsLCBzdGF0ZW1lbnRzLCBuZXcgUjNKaXRSZWZsZWN0b3IoY29udGV4dCksIC8qIGVuYWJsZVNvdXJjZU1hcHMgKi8gdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZXNbJyRkZWYnXTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9SM1F1ZXJ5TWV0YWRhdGEoZmFjYWRlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZmFjYWRlLFxuICAgICAgICBwcmVkaWNhdGU6IGNvbnZlcnRRdWVyeVByZWRpY2F0ZShmYWNhZGUucHJlZGljYXRlKSxcbiAgICAgICAgcmVhZDogZmFjYWRlLnJlYWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5yZWFkKSA6IG51bGwsXG4gICAgICAgIHN0YXRpYzogZmFjYWRlLnN0YXRpYyxcbiAgICAgICAgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHk6IGZhY2FkZS5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFF1ZXJ5RGVjbGFyYXRpb25Ub01ldGFkYXRhKGRlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydHlOYW1lOiBkZWNsYXJhdGlvbi5wcm9wZXJ0eU5hbWUsXG4gICAgICAgIGZpcnN0OiBkZWNsYXJhdGlvbi5maXJzdCA/PyBmYWxzZSxcbiAgICAgICAgcHJlZGljYXRlOiBjb252ZXJ0UXVlcnlQcmVkaWNhdGUoZGVjbGFyYXRpb24ucHJlZGljYXRlKSxcbiAgICAgICAgZGVzY2VuZGFudHM6IGRlY2xhcmF0aW9uLmRlc2NlbmRhbnRzID8/IGZhbHNlLFxuICAgICAgICByZWFkOiBkZWNsYXJhdGlvbi5yZWFkID8gbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi5yZWFkKSA6IG51bGwsXG4gICAgICAgIHN0YXRpYzogZGVjbGFyYXRpb24uc3RhdGljID8/IGZhbHNlLFxuICAgICAgICBlbWl0RGlzdGluY3RDaGFuZ2VzT25seTogZGVjbGFyYXRpb24uZW1pdERpc3RpbmN0Q2hhbmdlc09ubHkgPz8gdHJ1ZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydFF1ZXJ5UHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByZWRpY2F0ZSkgP1xuICAgICAgICAvLyBUaGUgcHJlZGljYXRlIGlzIGFuIGFycmF5IG9mIHN0cmluZ3Mgc28gcGFzcyBpdCB0aHJvdWdoLlxuICAgICAgICBwcmVkaWNhdGUgOlxuICAgICAgICAvLyBUaGUgcHJlZGljYXRlIGlzIGEgdHlwZSAtIGFzc3VtZSB0aGF0IHdlIHdpbGwgbmVlZCB0byB1bndyYXAgYW55IGBmb3J3YXJkUmVmKClgIGNhbGxzLlxuICAgICAgICBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKG5ldyBXcmFwcGVkTm9kZUV4cHIocHJlZGljYXRlKSwgMSAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuV3JhcHBlZCAqLyk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShmYWNhZGUpIHtcbiAgICBjb25zdCBpbnB1dHNGcm9tTWV0YWRhdGEgPSBwYXJzZUlucHV0T3V0cHV0cyhmYWNhZGUuaW5wdXRzIHx8IFtdKTtcbiAgICBjb25zdCBvdXRwdXRzRnJvbU1ldGFkYXRhID0gcGFyc2VJbnB1dE91dHB1dHMoZmFjYWRlLm91dHB1dHMgfHwgW10pO1xuICAgIGNvbnN0IHByb3BNZXRhZGF0YSA9IGZhY2FkZS5wcm9wTWV0YWRhdGE7XG4gICAgY29uc3QgaW5wdXRzRnJvbVR5cGUgPSB7fTtcbiAgICBjb25zdCBvdXRwdXRzRnJvbVR5cGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIHByb3BNZXRhZGF0YSkge1xuICAgICAgICBpZiAocHJvcE1ldGFkYXRhLmhhc093blByb3BlcnR5KGZpZWxkKSkge1xuICAgICAgICAgICAgcHJvcE1ldGFkYXRhW2ZpZWxkXS5mb3JFYWNoKGFubiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5wdXQoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dHNGcm9tVHlwZVtmaWVsZF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgYW5uLmJpbmRpbmdQcm9wZXJ0eU5hbWUgPyBbYW5uLmJpbmRpbmdQcm9wZXJ0eU5hbWUsIGZpZWxkXSA6IGZpZWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc091dHB1dChhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHNGcm9tVHlwZVtmaWVsZF0gPSBhbm4uYmluZGluZ1Byb3BlcnR5TmFtZSB8fCBmaWVsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5mYWNhZGUsXG4gICAgICAgIHR5cGVBcmd1bWVudENvdW50OiAwLFxuICAgICAgICB0eXBlU291cmNlU3BhbjogZmFjYWRlLnR5cGVTb3VyY2VTcGFuLFxuICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGZhY2FkZS50eXBlKSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50eXBlKSxcbiAgICAgICAgZGVwczogbnVsbCxcbiAgICAgICAgaG9zdDogZXh0cmFjdEhvc3RCaW5kaW5ncyhmYWNhZGUucHJvcE1ldGFkYXRhLCBmYWNhZGUudHlwZVNvdXJjZVNwYW4sIGZhY2FkZS5ob3N0KSxcbiAgICAgICAgaW5wdXRzOiB7IC4uLmlucHV0c0Zyb21NZXRhZGF0YSwgLi4uaW5wdXRzRnJvbVR5cGUgfSxcbiAgICAgICAgb3V0cHV0czogeyAuLi5vdXRwdXRzRnJvbU1ldGFkYXRhLCAuLi5vdXRwdXRzRnJvbVR5cGUgfSxcbiAgICAgICAgcXVlcmllczogZmFjYWRlLnF1ZXJpZXMubWFwKGNvbnZlcnRUb1IzUXVlcnlNZXRhZGF0YSksXG4gICAgICAgIHByb3ZpZGVyczogZmFjYWRlLnByb3ZpZGVycyAhPSBudWxsID8gbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUucHJvdmlkZXJzKSA6IG51bGwsXG4gICAgICAgIHZpZXdRdWVyaWVzOiBmYWNhZGUudmlld1F1ZXJpZXMubWFwKGNvbnZlcnRUb1IzUXVlcnlNZXRhZGF0YSksXG4gICAgICAgIGZ1bGxJbmhlcml0YW5jZTogZmFsc2UsXG4gICAgICAgIGhvc3REaXJlY3RpdmVzOiBjb252ZXJ0SG9zdERpcmVjdGl2ZXNUb01ldGFkYXRhKGZhY2FkZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJlRGlyZWN0aXZlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbiwgdHlwZVNvdXJjZVNwYW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBkZWNsYXJhdGlvbi50eXBlLm5hbWUsXG4gICAgICAgIHR5cGU6IHdyYXBSZWZlcmVuY2UoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIHR5cGVTb3VyY2VTcGFuLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIHNlbGVjdG9yOiBkZWNsYXJhdGlvbi5zZWxlY3RvciA/PyBudWxsLFxuICAgICAgICBpbnB1dHM6IGRlY2xhcmF0aW9uLmlucHV0cyA/PyB7fSxcbiAgICAgICAgb3V0cHV0czogZGVjbGFyYXRpb24ub3V0cHV0cyA/PyB7fSxcbiAgICAgICAgaG9zdDogY29udmVydEhvc3REZWNsYXJhdGlvblRvTWV0YWRhdGEoZGVjbGFyYXRpb24uaG9zdCksXG4gICAgICAgIHF1ZXJpZXM6IChkZWNsYXJhdGlvbi5xdWVyaWVzID8/IFtdKS5tYXAoY29udmVydFF1ZXJ5RGVjbGFyYXRpb25Ub01ldGFkYXRhKSxcbiAgICAgICAgdmlld1F1ZXJpZXM6IChkZWNsYXJhdGlvbi52aWV3UXVlcmllcyA/PyBbXSkubWFwKGNvbnZlcnRRdWVyeURlY2xhcmF0aW9uVG9NZXRhZGF0YSksXG4gICAgICAgIHByb3ZpZGVyczogZGVjbGFyYXRpb24ucHJvdmlkZXJzICE9PSB1bmRlZmluZWQgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnByb3ZpZGVycykgOlxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgZXhwb3J0QXM6IGRlY2xhcmF0aW9uLmV4cG9ydEFzID8/IG51bGwsXG4gICAgICAgIHVzZXNJbmhlcml0YW5jZTogZGVjbGFyYXRpb24udXNlc0luaGVyaXRhbmNlID8/IGZhbHNlLFxuICAgICAgICBsaWZlY3ljbGU6IHsgdXNlc09uQ2hhbmdlczogZGVjbGFyYXRpb24udXNlc09uQ2hhbmdlcyA/PyBmYWxzZSB9LFxuICAgICAgICBkZXBzOiBudWxsLFxuICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgZnVsbEluaGVyaXRhbmNlOiBmYWxzZSxcbiAgICAgICAgaXNTdGFuZGFsb25lOiBkZWNsYXJhdGlvbi5pc1N0YW5kYWxvbmUgPz8gZmFsc2UsXG4gICAgICAgIGhvc3REaXJlY3RpdmVzOiBjb252ZXJ0SG9zdERpcmVjdGl2ZXNUb01ldGFkYXRhKGRlY2xhcmF0aW9uKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydEhvc3REZWNsYXJhdGlvblRvTWV0YWRhdGEoaG9zdCA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXR0cmlidXRlczogY29udmVydE9wYXF1ZVZhbHVlc1RvRXhwcmVzc2lvbnMoaG9zdC5hdHRyaWJ1dGVzID8/IHt9KSxcbiAgICAgICAgbGlzdGVuZXJzOiBob3N0Lmxpc3RlbmVycyA/PyB7fSxcbiAgICAgICAgcHJvcGVydGllczogaG9zdC5wcm9wZXJ0aWVzID8/IHt9LFxuICAgICAgICBzcGVjaWFsQXR0cmlidXRlczoge1xuICAgICAgICAgICAgY2xhc3NBdHRyOiBob3N0LmNsYXNzQXR0cmlidXRlLFxuICAgICAgICAgICAgc3R5bGVBdHRyOiBob3N0LnN0eWxlQXR0cmlidXRlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0SG9zdERpcmVjdGl2ZXNUb01ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgaWYgKG1ldGFkYXRhLmhvc3REaXJlY3RpdmVzPy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmhvc3REaXJlY3RpdmVzLm1hcChob3N0RGlyZWN0aXZlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaG9zdERpcmVjdGl2ZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmU6IHdyYXBSZWZlcmVuY2UoaG9zdERpcmVjdGl2ZSksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0czogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0czogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkUmVmZXJlbmNlOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlOiB3cmFwUmVmZXJlbmNlKGhvc3REaXJlY3RpdmUuZGlyZWN0aXZlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNGb3J3YXJkUmVmZXJlbmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiBob3N0RGlyZWN0aXZlLmlucHV0cyA/IHBhcnNlSW5wdXRPdXRwdXRzKGhvc3REaXJlY3RpdmUuaW5wdXRzKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IGhvc3REaXJlY3RpdmUub3V0cHV0cyA/IHBhcnNlSW5wdXRPdXRwdXRzKGhvc3REaXJlY3RpdmUub3V0cHV0cykgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPcGFxdWVWYWx1ZXNUb0V4cHJlc3Npb25zKG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBuZXcgV3JhcHBlZE5vZGVFeHByKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJlQ29tcG9uZW50RmFjYWRlVG9NZXRhZGF0YShkZWNsLCB0eXBlU291cmNlU3Bhbiwgc291cmNlTWFwVXJsKSB7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgaW50ZXJwb2xhdGlvbiB9ID0gcGFyc2VKaXRUZW1wbGF0ZShkZWNsLnRlbXBsYXRlLCBkZWNsLnR5cGUubmFtZSwgc291cmNlTWFwVXJsLCBkZWNsLnByZXNlcnZlV2hpdGVzcGFjZXMgPz8gZmFsc2UsIGRlY2wuaW50ZXJwb2xhdGlvbik7XG4gICAgY29uc3QgZGVjbGFyYXRpb25zID0gW107XG4gICAgaWYgKGRlY2wuZGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5uZXJEZXAgb2YgZGVjbC5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5uZXJEZXAua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcG9uZW50JzpcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goY29udmVydERpcmVjdGl2ZURlY2xhcmF0aW9uVG9NZXRhZGF0YShpbm5lckRlcCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwaXBlJzpcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zLnB1c2goY29udmVydFBpcGVEZWNsYXJhdGlvblRvTWV0YWRhdGEoaW5uZXJEZXApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZGVjbC5jb21wb25lbnRzIHx8IGRlY2wuZGlyZWN0aXZlcyB8fCBkZWNsLnBpcGVzKSB7XG4gICAgICAgIC8vIEV4aXN0aW5nIGRlY2xhcmF0aW9ucyBvbiBOUE0gbWF5IG5vdCBiZSB1c2luZyB0aGUgbmV3IGBkZXBlbmRlbmNpZXNgIG1lcmdlZCBmaWVsZCwgYW5kIG1heVxuICAgICAgICAvLyBoYXZlIHNlcGFyYXRlIGZpZWxkcyBmb3IgZGVwZW5kZW5jaWVzIGluc3RlYWQuIFVuaWZ5IHRoZW0gZm9yIEpJVCBjb21waWxhdGlvbi5cbiAgICAgICAgZGVjbC5jb21wb25lbnRzICYmXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCguLi5kZWNsLmNvbXBvbmVudHMubWFwKGRpciA9PiBjb252ZXJ0RGlyZWN0aXZlRGVjbGFyYXRpb25Ub01ldGFkYXRhKGRpciwgLyogaXNDb21wb25lbnQgKi8gdHJ1ZSkpKTtcbiAgICAgICAgZGVjbC5kaXJlY3RpdmVzICYmXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMucHVzaCguLi5kZWNsLmRpcmVjdGl2ZXMubWFwKGRpciA9PiBjb252ZXJ0RGlyZWN0aXZlRGVjbGFyYXRpb25Ub01ldGFkYXRhKGRpcikpKTtcbiAgICAgICAgZGVjbC5waXBlcyAmJiBkZWNsYXJhdGlvbnMucHVzaCguLi5jb252ZXJ0UGlwZU1hcFRvTWV0YWRhdGEoZGVjbC5waXBlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5jb252ZXJ0RGVjbGFyZURpcmVjdGl2ZUZhY2FkZVRvTWV0YWRhdGEoZGVjbCwgdHlwZVNvdXJjZVNwYW4pLFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgc3R5bGVzOiBkZWNsLnN0eWxlcyA/PyBbXSxcbiAgICAgICAgZGVjbGFyYXRpb25zLFxuICAgICAgICB2aWV3UHJvdmlkZXJzOiBkZWNsLnZpZXdQcm92aWRlcnMgIT09IHVuZGVmaW5lZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbC52aWV3UHJvdmlkZXJzKSA6XG4gICAgICAgICAgICBudWxsLFxuICAgICAgICBhbmltYXRpb25zOiBkZWNsLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCA/IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbC5hbmltYXRpb25zKSA6IG51bGwsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogZGVjbC5jaGFuZ2VEZXRlY3Rpb24gPz8gQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuRGVmYXVsdCxcbiAgICAgICAgZW5jYXBzdWxhdGlvbjogZGVjbC5lbmNhcHN1bGF0aW9uID8/IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkLFxuICAgICAgICBpbnRlcnBvbGF0aW9uLFxuICAgICAgICBkZWNsYXJhdGlvbkxpc3RFbWl0TW9kZTogMiAvKiBEZWNsYXJhdGlvbkxpc3RFbWl0TW9kZS5DbG9zdXJlUmVzb2x2ZWQgKi8sXG4gICAgICAgIHJlbGF0aXZlQ29udGV4dEZpbGVQYXRoOiAnJyxcbiAgICAgICAgaTE4blVzZUV4dGVybmFsSWRzOiB0cnVlLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RGVjbGFyYXRpb25GYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVjbGFyYXRpb24sXG4gICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREaXJlY3RpdmVEZWNsYXJhdGlvblRvTWV0YWRhdGEoZGVjbGFyYXRpb24sIGlzQ29tcG9uZW50ID0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5EaXJlY3RpdmUsXG4gICAgICAgIGlzQ29tcG9uZW50OiBpc0NvbXBvbmVudCB8fCBkZWNsYXJhdGlvbi5raW5kID09PSAnY29tcG9uZW50JyxcbiAgICAgICAgc2VsZWN0b3I6IGRlY2xhcmF0aW9uLnNlbGVjdG9yLFxuICAgICAgICB0eXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBpbnB1dHM6IGRlY2xhcmF0aW9uLmlucHV0cyA/PyBbXSxcbiAgICAgICAgb3V0cHV0czogZGVjbGFyYXRpb24ub3V0cHV0cyA/PyBbXSxcbiAgICAgICAgZXhwb3J0QXM6IGRlY2xhcmF0aW9uLmV4cG9ydEFzID8/IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRQaXBlTWFwVG9NZXRhZGF0YShwaXBlcykge1xuICAgIGlmICghcGlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGlwZXMpLm1hcChuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtpbmQ6IFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5QaXBlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIocGlwZXNbbmFtZV0pLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29udmVydFBpcGVEZWNsYXJhdGlvblRvTWV0YWRhdGEocGlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5QaXBlLFxuICAgICAgICBuYW1lOiBwaXBlLm5hbWUsXG4gICAgICAgIHR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIocGlwZS50eXBlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VKaXRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHlwZU5hbWUsIHNvdXJjZU1hcFVybCwgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbikge1xuICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBpbnRlcnBvbGF0aW9uID8gSW50ZXJwb2xhdGlvbkNvbmZpZy5mcm9tQXJyYXkoaW50ZXJwb2xhdGlvbikgOiBERUZBVUxUX0lOVEVSUE9MQVRJT05fQ09ORklHO1xuICAgIC8vIFBhcnNlIHRoZSB0ZW1wbGF0ZSBhbmQgY2hlY2sgZm9yIGVycm9ycy5cbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCBzb3VyY2VNYXBVcmwsIHsgcHJlc2VydmVXaGl0ZXNwYWNlcywgaW50ZXJwb2xhdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAocGFyc2VkLmVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBwYXJzZWQuZXJyb3JzLm1hcChlcnIgPT4gZXJyLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3JzIGR1cmluZyBKSVQgY29tcGlsYXRpb24gb2YgdGVtcGxhdGUgZm9yICR7dHlwZU5hbWV9OiAke2Vycm9yc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGVtcGxhdGU6IHBhcnNlZCwgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvbkNvbmZpZyB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IHRoZSBleHByZXNzaW9uLCBpZiBwcmVzZW50IHRvIGFuIGBSM1Byb3ZpZGVyRXhwcmVzc2lvbmAuXG4gKlxuICogSW4gSklUIG1vZGUgd2UgZG8gbm90IHdhbnQgdGhlIGNvbXBpbGVyIHRvIHdyYXAgdGhlIGV4cHJlc3Npb24gaW4gYSBgZm9yd2FyZFJlZigpYCBjYWxsIGJlY2F1c2UsXG4gKiBpZiBpdCBpcyByZWZlcmVuY2luZyBhIHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGRlZmluZWQsIGl0IHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gd3JhcHBlZCBpblxuICogYSBgZm9yd2FyZFJlZigpYCAtIGVpdGhlciBieSB0aGUgYXBwbGljYXRpb24gZGV2ZWxvcGVyIG9yIGR1cmluZyBwYXJ0aWFsLWNvbXBpbGF0aW9uLiBUaHVzIHdlIGNhblxuICogdXNlIGBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbihvYmosIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1heUJlRm9yd2FyZFJlZkV4cHJlc3Npb24obmV3IFdyYXBwZWROb2RlRXhwcihvYmpbcHJvcGVydHldKSwgMCAvKiBGb3J3YXJkUmVmSGFuZGxpbmcuTm9uZSAqLyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBFeHByZXNzaW9uKG9iaiwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZWROb2RlRXhwcihvYmpbcHJvcGVydHldKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZVByb3ZpZGVkSW4ocHJvdmlkZWRJbikge1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0eXBlb2YgcHJvdmlkZWRJbiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBXcmFwcGVkTm9kZUV4cHIocHJvdmlkZWRJbikgOlxuICAgICAgICBuZXcgTGl0ZXJhbEV4cHIocHJvdmlkZWRJbiA/PyBudWxsKTtcbiAgICAvLyBTZWUgYGNvbnZlcnRUb1Byb3ZpZGVyRXhwcmVzc2lvbigpYCBmb3Igd2h5IHRoaXMgdXNlcyBgRm9yd2FyZFJlZkhhbmRsaW5nLk5vbmVgLlxuICAgIHJldHVybiBjcmVhdGVNYXlCZUZvcndhcmRSZWZFeHByZXNzaW9uKGV4cHJlc3Npb24sIDAgLyogRm9yd2FyZFJlZkhhbmRsaW5nLk5vbmUgKi8pO1xufVxuZnVuY3Rpb24gY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhQXJyYXkoZmFjYWRlcykge1xuICAgIHJldHVybiBmYWNhZGVzID09IG51bGwgPyBudWxsIDogZmFjYWRlcy5tYXAoY29udmVydFIzRGVwZW5kZW5jeU1ldGFkYXRhKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSM0RlcGVuZGVuY3lNZXRhZGF0YShmYWNhZGUpIHtcbiAgICBjb25zdCBpc0F0dHJpYnV0ZURlcCA9IGZhY2FkZS5hdHRyaWJ1dGUgIT0gbnVsbDsgLy8gYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgY29uc3QgcmF3VG9rZW4gPSBmYWNhZGUudG9rZW4gPT09IG51bGwgPyBudWxsIDogbmV3IFdyYXBwZWROb2RlRXhwcihmYWNhZGUudG9rZW4pO1xuICAgIC8vIEluIEpJVCBtb2RlLCBpZiB0aGUgZGVwIGlzIGFuIGBAQXR0cmlidXRlKClgIHRoZW4gd2UgdXNlIHRoZSBhdHRyaWJ1dGUgbmFtZSBnaXZlbiBpblxuICAgIC8vIGBhdHRyaWJ1dGVgIHJhdGhlciB0aGFuIHRoZSBgdG9rZW5gLlxuICAgIGNvbnN0IHRva2VuID0gaXNBdHRyaWJ1dGVEZXAgPyBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS5hdHRyaWJ1dGUpIDogcmF3VG9rZW47XG4gICAgcmV0dXJuIGNyZWF0ZVIzRGVwZW5kZW5jeU1ldGFkYXRhKHRva2VuLCBpc0F0dHJpYnV0ZURlcCwgZmFjYWRlLmhvc3QsIGZhY2FkZS5vcHRpb25hbCwgZmFjYWRlLnNlbGYsIGZhY2FkZS5za2lwU2VsZik7XG59XG5mdW5jdGlvbiBjb252ZXJ0UjNEZWNsYXJlRGVwZW5kZW5jeU1ldGFkYXRhKGZhY2FkZSkge1xuICAgIGNvbnN0IGlzQXR0cmlidXRlRGVwID0gZmFjYWRlLmF0dHJpYnV0ZSA/PyBmYWxzZTtcbiAgICBjb25zdCB0b2tlbiA9IGZhY2FkZS50b2tlbiA9PT0gbnVsbCA/IG51bGwgOiBuZXcgV3JhcHBlZE5vZGVFeHByKGZhY2FkZS50b2tlbik7XG4gICAgcmV0dXJuIGNyZWF0ZVIzRGVwZW5kZW5jeU1ldGFkYXRhKHRva2VuLCBpc0F0dHJpYnV0ZURlcCwgZmFjYWRlLmhvc3QgPz8gZmFsc2UsIGZhY2FkZS5vcHRpb25hbCA/PyBmYWxzZSwgZmFjYWRlLnNlbGYgPz8gZmFsc2UsIGZhY2FkZS5za2lwU2VsZiA/PyBmYWxzZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSM0RlcGVuZGVuY3lNZXRhZGF0YSh0b2tlbiwgaXNBdHRyaWJ1dGVEZXAsIGhvc3QsIG9wdGlvbmFsLCBzZWxmLCBza2lwU2VsZikge1xuICAgIC8vIElmIHRoZSBkZXAgaXMgYW4gYEBBdHRyaWJ1dGUoKWAgdGhlIGBhdHRyaWJ1dGVOYW1lVHlwZWAgb3VnaHQgdG8gYmUgdGhlIGB1bmtub3duYCB0eXBlLlxuICAgIC8vIEJ1dCB0eXBlcyBhcmUgbm90IGF2YWlsYWJsZSBhdCBydW50aW1lIHNvIHdlIGp1c3QgdXNlIGEgbGl0ZXJhbCBgXCI8dW5rbm93bj5cImAgc3RyaW5nIGFzIGEgZHVtbXlcbiAgICAvLyBtYXJrZXIuXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZVR5cGUgPSBpc0F0dHJpYnV0ZURlcCA/IGxpdGVyYWwoJ3Vua25vd24nKSA6IG51bGw7XG4gICAgcmV0dXJuIHsgdG9rZW4sIGF0dHJpYnV0ZU5hbWVUeXBlLCBob3N0LCBvcHRpb25hbCwgc2VsZiwgc2tpcFNlbGYgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RIb3N0QmluZGluZ3MocHJvcE1ldGFkYXRhLCBzb3VyY2VTcGFuLCBob3N0KSB7XG4gICAgLy8gRmlyc3QgcGFyc2UgdGhlIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBtZXRhZGF0YS5cbiAgICBjb25zdCBiaW5kaW5ncyA9IHBhcnNlSG9zdEJpbmRpbmdzKGhvc3QgfHwge30pO1xuICAgIC8vIEFmdGVyIHRoYXQgY2hlY2sgaG9zdCBiaW5kaW5ncyBmb3IgZXJyb3JzXG4gICAgY29uc3QgZXJyb3JzID0gdmVyaWZ5SG9zdEJpbmRpbmdzKGJpbmRpbmdzLCBzb3VyY2VTcGFuKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLm1hcCgoZXJyb3IpID0+IGVycm9yLm1zZykuam9pbignXFxuJykpO1xuICAgIH1cbiAgICAvLyBOZXh0LCBsb29wIG92ZXIgdGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCwgbG9va2luZyBmb3IgQEhvc3RCaW5kaW5nIGFuZCBASG9zdExpc3RlbmVyLlxuICAgIGZvciAoY29uc3QgZmllbGQgaW4gcHJvcE1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChwcm9wTWV0YWRhdGEuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICBwcm9wTWV0YWRhdGFbZmllbGRdLmZvckVhY2goYW5uID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIb3N0QmluZGluZyhhbm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBkZWNvcmF0b3IsIHdlIGtub3cgdGhhdCB0aGUgdmFsdWUgaXMgYSBjbGFzcyBtZW1iZXIuIEFsd2F5cyBhY2Nlc3MgaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3VnaCBgdGhpc2Agc28gdGhhdCBmdXJ0aGVyIGRvd24gdGhlIGxpbmUgaXQgY2FuJ3QgYmUgY29uZnVzZWQgZm9yIGEgbGl0ZXJhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyAoZS5nLiBpZiB0aGVyZSdzIGEgcHJvcGVydHkgY2FsbGVkIGB0cnVlYCkuXG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnByb3BlcnRpZXNbYW5uLmhvc3RQcm9wZXJ0eU5hbWUgfHwgZmllbGRdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNhZmVQcm9wZXJ0eUFjY2Vzc1N0cmluZygndGhpcycsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNIb3N0TGlzdGVuZXIoYW5uKSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncy5saXN0ZW5lcnNbYW5uLmV2ZW50TmFtZSB8fCBmaWVsZF0gPSBgJHtmaWVsZH0oJHsoYW5uLmFyZ3MgfHwgW10pLmpvaW4oJywnKX0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmluZGluZ3M7XG59XG5mdW5jdGlvbiBpc0hvc3RCaW5kaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnSG9zdEJpbmRpbmcnO1xufVxuZnVuY3Rpb24gaXNIb3N0TGlzdGVuZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubmdNZXRhZGF0YU5hbWUgPT09ICdIb3N0TGlzdGVuZXInO1xufVxuZnVuY3Rpb24gaXNJbnB1dCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5uZ01ldGFkYXRhTmFtZSA9PT0gJ0lucHV0Jztcbn1cbmZ1bmN0aW9uIGlzT3V0cHV0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLm5nTWV0YWRhdGFOYW1lID09PSAnT3V0cHV0Jztcbn1cbmZ1bmN0aW9uIHBhcnNlSW5wdXRPdXRwdXRzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChyZXN1bHRzLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBbZmllbGQsIHByb3BlcnR5XSA9IHZhbHVlLnNwbGl0KCc6JywgMikubWFwKHN0ciA9PiBzdHIudHJpbSgpKTtcbiAgICAgICAgcmVzdWx0c1tmaWVsZF0gPSBwcm9wZXJ0eSB8fCBmaWVsZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gY29udmVydERlY2xhcmVQaXBlRmFjYWRlVG9NZXRhZGF0YShkZWNsYXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlY2xhcmF0aW9uLnR5cGUubmFtZSxcbiAgICAgICAgdHlwZTogd3JhcFJlZmVyZW5jZShkZWNsYXJhdGlvbi50eXBlKSxcbiAgICAgICAgaW50ZXJuYWxUeXBlOiBuZXcgV3JhcHBlZE5vZGVFeHByKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICB0eXBlQXJndW1lbnRDb3VudDogMCxcbiAgICAgICAgcGlwZU5hbWU6IGRlY2xhcmF0aW9uLm5hbWUsXG4gICAgICAgIGRlcHM6IG51bGwsXG4gICAgICAgIHB1cmU6IGRlY2xhcmF0aW9uLnB1cmUgPz8gdHJ1ZSxcbiAgICAgICAgaXNTdGFuZGFsb25lOiBkZWNsYXJhdGlvbi5pc1N0YW5kYWxvbmUgPz8gZmFsc2UsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREZWNsYXJlSW5qZWN0b3JGYWNhZGVUb01ldGFkYXRhKGRlY2xhcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogZGVjbGFyYXRpb24udHlwZS5uYW1lLFxuICAgICAgICB0eXBlOiB3cmFwUmVmZXJlbmNlKGRlY2xhcmF0aW9uLnR5cGUpLFxuICAgICAgICBpbnRlcm5hbFR5cGU6IG5ldyBXcmFwcGVkTm9kZUV4cHIoZGVjbGFyYXRpb24udHlwZSksXG4gICAgICAgIHByb3ZpZGVyczogZGVjbGFyYXRpb24ucHJvdmlkZXJzICE9PSB1bmRlZmluZWQgJiYgZGVjbGFyYXRpb24ucHJvdmlkZXJzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgbmV3IFdyYXBwZWROb2RlRXhwcihkZWNsYXJhdGlvbi5wcm92aWRlcnMpIDpcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgIGltcG9ydHM6IGRlY2xhcmF0aW9uLmltcG9ydHMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5pbXBvcnRzLm1hcChpID0+IG5ldyBXcmFwcGVkTm9kZUV4cHIoaSkpIDpcbiAgICAgICAgICAgIFtdLFxuICAgIH07XG59XG5mdW5jdGlvbiBwdWJsaXNoRmFjYWRlKGdsb2JhbCkge1xuICAgIGNvbnN0IG5nID0gZ2xvYmFsLm5nIHx8IChnbG9iYWwubmcgPSB7fSk7XG4gICAgbmcuybVjb21waWxlckZhY2FkZSA9IG5ldyBDb21waWxlckZhY2FkZUltcGwoKTtcbn1cblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGNvbXBpbGVyIHBhY2thZ2UuXG4gKi9cbmNvbnN0IFZFUlNJT04gPSBuZXcgVmVyc2lvbignMTUuMi43Jyk7XG5cbmNsYXNzIENvbXBpbGVyQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRlZmF1bHRFbmNhcHN1bGF0aW9uID0gVmlld0VuY2Fwc3VsYXRpb24uRW11bGF0ZWQsIHVzZUppdCA9IHRydWUsIG1pc3NpbmdUcmFuc2xhdGlvbiA9IG51bGwsIHByZXNlcnZlV2hpdGVzcGFjZXMsIHN0cmljdEluamVjdGlvblBhcmFtZXRlcnMgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVuY2Fwc3VsYXRpb24gPSBkZWZhdWx0RW5jYXBzdWxhdGlvbjtcbiAgICAgICAgdGhpcy51c2VKaXQgPSAhIXVzZUppdDtcbiAgICAgICAgdGhpcy5taXNzaW5nVHJhbnNsYXRpb24gPSBtaXNzaW5nVHJhbnNsYXRpb247XG4gICAgICAgIHRoaXMucHJlc2VydmVXaGl0ZXNwYWNlcyA9IHByZXNlcnZlV2hpdGVzcGFjZXNEZWZhdWx0KG5vVW5kZWZpbmVkKHByZXNlcnZlV2hpdGVzcGFjZXMpKTtcbiAgICAgICAgdGhpcy5zdHJpY3RJbmplY3Rpb25QYXJhbWV0ZXJzID0gc3RyaWN0SW5qZWN0aW9uUGFyYW1ldGVycyA9PT0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwcmVzZXJ2ZVdoaXRlc3BhY2VzRGVmYXVsdChwcmVzZXJ2ZVdoaXRlc3BhY2VzT3B0aW9uLCBkZWZhdWx0U2V0dGluZyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb24gPT09IG51bGwgPyBkZWZhdWx0U2V0dGluZyA6IHByZXNlcnZlV2hpdGVzcGFjZXNPcHRpb247XG59XG5cbmNvbnN0IF9JMThOX0FUVFIgPSAnaTE4bic7XG5jb25zdCBfSTE4Tl9BVFRSX1BSRUZJWCA9ICdpMThuLSc7XG5jb25zdCBfSTE4Tl9DT01NRU5UX1BSRUZJWF9SRUdFWFAgPSAvXmkxOG46Py87XG5jb25zdCBNRUFOSU5HX1NFUEFSQVRPUiA9ICd8JztcbmNvbnN0IElEX1NFUEFSQVRPUiA9ICdAQCc7XG5sZXQgaTE4bkNvbW1lbnRzV2FybmVkID0gZmFsc2U7XG4vKipcbiAqIEV4dHJhY3QgdHJhbnNsYXRhYmxlIG1lc3NhZ2VzIGZyb20gYW4gaHRtbCBBU1RcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1lc3NhZ2VzKG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgcmV0dXJuIHZpc2l0b3IuZXh0cmFjdChub2RlcywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG59XG5mdW5jdGlvbiBtZXJnZVRyYW5zbGF0aW9ucyhub2RlcywgdHJhbnNsYXRpb25zLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCBpbXBsaWNpdFRhZ3MsIGltcGxpY2l0QXR0cnMpIHtcbiAgICBjb25zdCB2aXNpdG9yID0gbmV3IF9WaXNpdG9yKGltcGxpY2l0VGFncywgaW1wbGljaXRBdHRycyk7XG4gICAgcmV0dXJuIHZpc2l0b3IubWVyZ2Uobm9kZXMsIHRyYW5zbGF0aW9ucywgaW50ZXJwb2xhdGlvbkNvbmZpZyk7XG59XG5jbGFzcyBFeHRyYWN0aW9uUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlcywgZXJyb3JzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgfVxufVxudmFyIF9WaXNpdG9yTW9kZTtcbihmdW5jdGlvbiAoX1Zpc2l0b3JNb2RlKSB7XG4gICAgX1Zpc2l0b3JNb2RlW19WaXNpdG9yTW9kZVtcIkV4dHJhY3RcIl0gPSAwXSA9IFwiRXh0cmFjdFwiO1xuICAgIF9WaXNpdG9yTW9kZVtfVmlzaXRvck1vZGVbXCJNZXJnZVwiXSA9IDFdID0gXCJNZXJnZVwiO1xufSkoX1Zpc2l0b3JNb2RlIHx8IChfVmlzaXRvck1vZGUgPSB7fSkpO1xuLyoqXG4gKiBUaGlzIFZpc2l0b3IgaXMgdXNlZDpcbiAqIDEuIHRvIGV4dHJhY3QgYWxsIHRoZSB0cmFuc2xhdGFibGUgc3RyaW5ncyBmcm9tIGFuIGh0bWwgQVNUIChzZWUgYGV4dHJhY3QoKWApLFxuICogMi4gdG8gcmVwbGFjZSB0aGUgdHJhbnNsYXRhYmxlIHN0cmluZ3Mgd2l0aCB0aGUgYWN0dWFsIHRyYW5zbGF0aW9ucyAoc2VlIGBtZXJnZSgpYClcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgX1Zpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKF9pbXBsaWNpdFRhZ3MsIF9pbXBsaWNpdEF0dHJzKSB7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0VGFncyA9IF9pbXBsaWNpdFRhZ3M7XG4gICAgICAgIHRoaXMuX2ltcGxpY2l0QXR0cnMgPSBfaW1wbGljaXRBdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIG1lc3NhZ2VzIGZyb20gdGhlIHRyZWVcbiAgICAgKi9cbiAgICBleHRyYWN0KG5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2luaXQoX1Zpc2l0b3JNb2RlLkV4dHJhY3QsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzLCBudWxsKSk7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXh0cmFjdGlvblJlc3VsdCh0aGlzLl9tZXNzYWdlcywgdGhpcy5fZXJyb3JzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRyZWUgd2hlcmUgYWxsIHRyYW5zbGF0YWJsZSBub2RlcyBhcmUgdHJhbnNsYXRlZFxuICAgICAqL1xuICAgIG1lcmdlKG5vZGVzLCB0cmFuc2xhdGlvbnMsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgdGhpcy5faW5pdChfVmlzaXRvck1vZGUuTWVyZ2UsIGludGVycG9sYXRpb25Db25maWcpO1xuICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSB0cmFuc2xhdGlvbnM7XG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHNpbmdsZSBmYWtlIHJvb3QgZWxlbWVudFxuICAgICAgICBjb25zdCB3cmFwcGVyID0gbmV3IEVsZW1lbnQoJ3dyYXBwZXInLCBbXSwgbm9kZXMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGVkTm9kZSA9IHdyYXBwZXIudmlzaXQodGhpcywgbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3Iobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0sICdVbmNsb3NlZCBibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VUcmVlUmVzdWx0KHRyYW5zbGF0ZWROb2RlLmNoaWxkcmVuLCB0aGlzLl9lcnJvcnMpO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICAvLyBQYXJzZSBjYXNlcyBmb3IgdHJhbnNsYXRhYmxlIGh0bWwgYXR0cmlidXRlc1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IF9WaXNpdG9yTW9kZS5NZXJnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFeHBhbnNpb25DYXNlKGljdUNhc2UudmFsdWUsIGV4cHJlc3Npb24sIGljdUNhc2Uuc291cmNlU3BhbiwgaWN1Q2FzZS52YWx1ZVNvdXJjZVNwYW4sIGljdUNhc2UuZXhwU291cmNlU3Bhbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb24oaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihpY3UpO1xuICAgICAgICBjb25zdCB3YXNJbkljdSA9IHRoaXMuX2luSWN1O1xuICAgICAgICBpZiAoIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICAvLyBuZXN0ZWQgSUNVIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgZXh0cmFjdGVkIGJ1dCB0b3AtbGV2ZWwgdHJhbnNsYXRlZCBhcyBhIHdob2xlXG4gICAgICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFtpY3VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2luSWN1ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXNlcyA9IHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcywgY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGljdSA9IG5ldyBFeHBhbnNpb24oaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZXMsIGljdS5zb3VyY2VTcGFuLCBpY3Uuc3dpdGNoVmFsdWVTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbkljdSA9IHdhc0luSWN1O1xuICAgICAgICByZXR1cm4gaWN1O1xuICAgIH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBpc09wZW5pbmcgPSBfaXNPcGVuaW5nQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgaWYgKGlzT3BlbmluZyAmJiB0aGlzLl9pc0luVHJhbnNsYXRhYmxlU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVwb3J0RXJyb3IoY29tbWVudCwgJ0NvdWxkIG5vdCBzdGFydCBhIGJsb2NrIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNDbG9zaW5nID0gX2lzQ2xvc2luZ0NvbW1lbnQoY29tbWVudCk7XG4gICAgICAgIGlmIChpc0Nsb3NpbmcgJiYgIXRoaXMuX2luSTE4bkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnVHJ5aW5nIHRvIGNsb3NlIGFuIHVub3BlbmVkIGJsb2NrJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5Ob2RlICYmICF0aGlzLl9pbkljdSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbkkxOG5CbG9jaykge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCBmcm9tIHY1IHlvdSBzaG91bGQgdXNlIDxuZy1jb250YWluZXIgaTE4bj4gaW5zdGVhZCBvZiBpMThuIGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghaTE4bkNvbW1lbnRzV2FybmVkICYmIGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpMThuQ29tbWVudHNXYXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IGNvbW1lbnQuc291cmNlU3Bhbi5kZXRhaWxzID8gYCwgJHtjb21tZW50LnNvdXJjZVNwYW4uZGV0YWlsc31gIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKG9jb21iZSk6IHVzZSBhIGxvZyBzZXJ2aWNlIG9uY2UgdGhlcmUgaXMgYSBwdWJsaWMgb25lIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJMThuIGNvbW1lbnRzIGFyZSBkZXByZWNhdGVkLCB1c2UgYW4gPG5nLWNvbnRhaW5lcj4gZWxlbWVudCBpbnN0ZWFkICgke2NvbW1lbnQuc291cmNlU3Bhbi5zdGFydH0ke2RldGFpbHN9KWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tTdGFydERlcHRoID0gdGhpcy5fZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvY2tNZWFuaW5nQW5kRGVzYyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50LnZhbHVlLnJlcGxhY2UoX0kxOE5fQ09NTUVOVF9QUkVGSVhfUkVHRVhQLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuVHJhbnNsYXRhYmxlU2VjdGlvbihjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZXB0aCA9PSB0aGlzLl9ibG9ja1N0YXJ0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihjb21tZW50LCB0aGlzLl9ibG9ja0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luSTE4bkJsb2NrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fYWRkTWVzc2FnZSh0aGlzLl9ibG9ja0NoaWxkcmVuLCB0aGlzLl9ibG9ja01lYW5pbmdBbmREZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIGF0dHJpYnV0ZXMgaW4gc2VjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5fdHJhbnNsYXRlTWVzc2FnZShjb21tZW50LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdEFsbCh0aGlzLCBub2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihjb21tZW50LCAnSTE4TiBibG9ja3Mgc2hvdWxkIG5vdCBjcm9zcyBlbGVtZW50IGJvdW5kYXJpZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbih0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX21heUJlQWRkQmxvY2tDaGlsZHJlbihlbCk7XG4gICAgICAgIHRoaXMuX2RlcHRoKys7XG4gICAgICAgIGNvbnN0IHdhc0luSTE4bk5vZGUgPSB0aGlzLl9pbkkxOG5Ob2RlO1xuICAgICAgICBjb25zdCB3YXNJbkltcGxpY2l0Tm9kZSA9IHRoaXMuX2luSW1wbGljaXROb2RlO1xuICAgICAgICBsZXQgY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBsZXQgdHJhbnNsYXRlZENoaWxkTm9kZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEV4dHJhY3Q6XG4gICAgICAgIC8vIC0gdG9wIGxldmVsIG5vZGVzIHdpdGggdGhlIChpbXBsaWNpdCkgXCJpMThuXCIgYXR0cmlidXRlIGlmIG5vdCBhbHJlYWR5IGluIGEgc2VjdGlvblxuICAgICAgICAvLyAtIElDVSBtZXNzYWdlc1xuICAgICAgICBjb25zdCBpMThuQXR0ciA9IF9nZXRJMThuQXR0cihlbCk7XG4gICAgICAgIGNvbnN0IGkxOG5NZXRhID0gaTE4bkF0dHIgPyBpMThuQXR0ci52YWx1ZSA6ICcnO1xuICAgICAgICBjb25zdCBpc0ltcGxpY2l0ID0gdGhpcy5faW1wbGljaXRUYWdzLnNvbWUodGFnID0+IGVsLm5hbWUgPT09IHRhZykgJiYgIXRoaXMuX2luSWN1ICYmXG4gICAgICAgICAgICAhdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb247XG4gICAgICAgIGNvbnN0IGlzVG9wTGV2ZWxJbXBsaWNpdCA9ICF3YXNJbkltcGxpY2l0Tm9kZSAmJiBpc0ltcGxpY2l0O1xuICAgICAgICB0aGlzLl9pbkltcGxpY2l0Tm9kZSA9IHdhc0luSW1wbGljaXROb2RlIHx8IGlzSW1wbGljaXQ7XG4gICAgICAgIGlmICghdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24gJiYgIXRoaXMuX2luSWN1KSB7XG4gICAgICAgICAgICBpZiAoaTE4bkF0dHIgfHwgaXNUb3BMZXZlbEltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX2FkZE1lc3NhZ2UoZWwuY2hpbGRyZW4sIGkxOG5NZXRhKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVkQ2hpbGROb2RlcyA9IHRoaXMuX3RyYW5zbGF0ZU1lc3NhZ2UoZWwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGUgPT0gX1Zpc2l0b3JNb2RlLkV4dHJhY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1RyYW5zbGF0YWJsZSA9IGkxOG5BdHRyIHx8IGlzVG9wTGV2ZWxJbXBsaWNpdDtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcmFuc2xhdGFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFuc2xhdGFibGVTZWN0aW9uKGVsKTtcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhbnNsYXRhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbG9zZVRyYW5zbGF0YWJsZVNlY3Rpb24oZWwsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpMThuQXR0ciB8fCBpc1RvcExldmVsSW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgJ0NvdWxkIG5vdCBtYXJrIGFuIGVsZW1lbnQgYXMgdHJhbnNsYXRhYmxlIGluc2lkZSBhIHRyYW5zbGF0YWJsZSBzZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSA9PSBfVmlzaXRvck1vZGUuRXh0cmFjdCkge1xuICAgICAgICAgICAgICAgIC8vIERlc2NlbmQgaW50byBjaGlsZCBub2RlcyBmb3IgZXh0cmFjdGlvblxuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbW9kZSA9PT0gX1Zpc2l0b3JNb2RlLk1lcmdlKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpdE5vZGVzID0gdHJhbnNsYXRlZENoaWxkTm9kZXMgfHwgZWwuY2hpbGRyZW47XG4gICAgICAgICAgICB2aXNpdE5vZGVzLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBjaGlsZC52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZCAmJiAhdGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgY2hpbGRyZW4gZnJvbSB0cmFuc2xhdGFibGUgc2VjdGlvbnMgKD0gaTE4biBibG9ja3MgaGVyZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIGJlIGFkZGVkIGxhdGVyIGluIHRoaXMgbG9vcCB3aGVuIHRoZSBibG9jayBjbG9zZXMgKGkuZS4gb24gYDwhLS0gL2kxOG4gLS0+YClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IGNoaWxkTm9kZXMuY29uY2F0KHZpc2l0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2l0QXR0cmlidXRlc09mKGVsKTtcbiAgICAgICAgdGhpcy5fZGVwdGgtLTtcbiAgICAgICAgdGhpcy5faW5JMThuTm9kZSA9IHdhc0luSTE4bk5vZGU7XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gd2FzSW5JbXBsaWNpdE5vZGU7XG4gICAgICAgIGlmICh0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRBdHRycyA9IHRoaXMuX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50KGVsLm5hbWUsIHRyYW5zbGF0ZWRBdHRycywgY2hpbGROb2RlcywgZWwuc291cmNlU3BhbiwgZWwuc3RhcnRTb3VyY2VTcGFuLCBlbC5lbmRTb3VyY2VTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUgY29kZScpO1xuICAgIH1cbiAgICBfaW5pdChtb2RlLCBpbnRlcnBvbGF0aW9uQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLl9pbkkxOG5CbG9jayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbkkxOG5Ob2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gMDtcbiAgICAgICAgdGhpcy5faW5JY3UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMuX2luSW1wbGljaXROb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUkxOG5NZXNzYWdlID0gY3JlYXRlSTE4bk1lc3NhZ2VGYWN0b3J5KGludGVycG9sYXRpb25Db25maWcpO1xuICAgIH1cbiAgICAvLyBsb29rcyBmb3IgdHJhbnNsYXRhYmxlIGF0dHJpYnV0ZXNcbiAgICBfdmlzaXRBdHRyaWJ1dGVzT2YoZWwpIHtcbiAgICAgICAgY29uc3QgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgaW1wbGljaXRBdHRyTmFtZXMgPSB0aGlzLl9pbXBsaWNpdEF0dHJzW2VsLm5hbWVdIHx8IFtdO1xuICAgICAgICBlbC5hdHRycy5maWx0ZXIoYXR0ciA9PiBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpXG4gICAgICAgICAgICAuZm9yRWFjaChhdHRyID0+IGV4cGxpY2l0QXR0ck5hbWVUb1ZhbHVlW2F0dHIubmFtZS5zbGljZShfSTE4Tl9BVFRSX1BSRUZJWC5sZW5ndGgpXSA9XG4gICAgICAgICAgICBhdHRyLnZhbHVlKTtcbiAgICAgICAgZWwuYXR0cnMuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgaW4gZXhwbGljaXRBdHRyTmFtZVRvVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXNzYWdlKFthdHRyXSwgZXhwbGljaXRBdHRyTmFtZVRvVmFsdWVbYXR0ci5uYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbXBsaWNpdEF0dHJOYW1lcy5zb21lKG5hbWUgPT4gYXR0ci5uYW1lID09PSBuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lc3NhZ2UoW2F0dHJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIHRyYW5zbGF0YWJsZSBtZXNzYWdlXG4gICAgX2FkZE1lc3NhZ2UoYXN0LCBtc2dNZXRhKSB7XG4gICAgICAgIGlmIChhc3QubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgIGFzdC5sZW5ndGggPT0gMSAmJiBhc3RbMF0gaW5zdGFuY2VvZiBBdHRyaWJ1dGUgJiYgIWFzdFswXS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gRG8gbm90IGNyZWF0ZSBlbXB0eSBtZXNzYWdlc1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQgfSA9IF9wYXJzZU1lc3NhZ2VNZXRhKG1zZ01ldGEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY3JlYXRlSTE4bk1lc3NhZ2UoYXN0LCBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQpO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgLy8gVHJhbnNsYXRlcyB0aGUgZ2l2ZW4gbWVzc2FnZSBnaXZlbiB0aGUgYFRyYW5zbGF0aW9uQnVuZGxlYFxuICAgIC8vIFRoaXMgaXMgdXNlZCBmb3IgdHJhbnNsYXRpbmcgZWxlbWVudHMgLyBibG9ja3MgLSBzZWUgYF90cmFuc2xhdGVBdHRyaWJ1dGVzYCBmb3IgYXR0cmlidXRlc1xuICAgIC8vIG5vLW9wIHdoZW4gY2FsbGVkIGluIGV4dHJhY3Rpb24gbW9kZSAocmV0dXJucyBbXSlcbiAgICBfdHJhbnNsYXRlTWVzc2FnZShlbCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSAmJiB0aGlzLl9tb2RlID09PSBfVmlzaXRvck1vZGUuTWVyZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5fdHJhbnNsYXRpb25zLmdldChtZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBgVHJhbnNsYXRpb24gdW5hdmFpbGFibGUgZm9yIG1lc3NhZ2UgaWQ9XCIke3RoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSl9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIC8vIHRyYW5zbGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhbiBlbGVtZW50IGFuZCByZW1vdmUgaTE4biBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgX3RyYW5zbGF0ZUF0dHJpYnV0ZXMoZWwpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGVsLmF0dHJzO1xuICAgICAgICBjb25zdCBpMThuUGFyc2VkTWVzc2FnZU1ldGEgPSB7fTtcbiAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKF9JMThOX0FUVFJfUFJFRklYKSkge1xuICAgICAgICAgICAgICAgIGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWUuc2xpY2UoX0kxOE5fQVRUUl9QUkVGSVgubGVuZ3RoKV0gPVxuICAgICAgICAgICAgICAgICAgICBfcGFyc2VNZXNzYWdlTWV0YShhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZWRBdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gX0kxOE5fQVRUUiB8fCBhdHRyLm5hbWUuc3RhcnRzV2l0aChfSTE4Tl9BVFRSX1BSRUZJWCkpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBpMThuIHNwZWNpZmljIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0ci52YWx1ZSAmJiBhdHRyLnZhbHVlICE9ICcnICYmIGkxOG5QYXJzZWRNZXNzYWdlTWV0YS5oYXNPd25Qcm9wZXJ0eShhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtZWFuaW5nLCBkZXNjcmlwdGlvbiwgaWQgfSA9IGkxOG5QYXJzZWRNZXNzYWdlTWV0YVthdHRyLm5hbWVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVJMThuTWVzc2FnZShbYXR0cl0sIG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLl90cmFuc2xhdGlvbnMuZ2V0KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZWRBdHRyaWJ1dGVzLnB1c2gobmV3IEF0dHJpYnV0ZShhdHRyLm5hbWUsICcnLCBhdHRyLnNvdXJjZVNwYW4sIHVuZGVmaW5lZCAvKiBrZXlTcGFuICovLCB1bmRlZmluZWQgLyogdmFsdWVTcGFuICovLCB1bmRlZmluZWQgLyogdmFsdWVUb2tlbnMgKi8sIHVuZGVmaW5lZCAvKiBpMThuICovKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNbMF0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlKGF0dHIubmFtZSwgdmFsdWUsIGF0dHIuc291cmNlU3BhbiwgdW5kZWZpbmVkIC8qIGtleVNwYW4gKi8sIHVuZGVmaW5lZCAvKiB2YWx1ZVNwYW4gKi8sIHVuZGVmaW5lZCAvKiB2YWx1ZVRva2VucyAqLywgdW5kZWZpbmVkIC8qIGkxOG4gKi8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKGVsLCBgVW5leHBlY3RlZCB0cmFuc2xhdGlvbiBmb3IgYXR0cmlidXRlIFwiJHthdHRyLm5hbWV9XCIgKGlkPVwiJHtpZCB8fCB0aGlzLl90cmFuc2xhdGlvbnMuZGlnZXN0KG1lc3NhZ2UpfVwiKWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihlbCwgYFRyYW5zbGF0aW9uIHVuYXZhaWxhYmxlIGZvciBhdHRyaWJ1dGUgXCIke2F0dHIubmFtZX1cIiAoaWQ9XCIke2lkIHx8IHRoaXMuX3RyYW5zbGF0aW9ucy5kaWdlc3QobWVzc2FnZSl9XCIpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlZEF0dHJpYnV0ZXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVkQXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGFzIGEgY2hpbGQgb2YgdGhlIGJsb2NrIHdoZW46XG4gICAgICogLSB3ZSBhcmUgaW4gYSBibG9jayxcbiAgICAgKiAtIHdlIGFyZSBub3QgaW5zaWRlIGEgSUNVIG1lc3NhZ2UgKHRob3NlIGFyZSBoYW5kbGVkIHNlcGFyYXRlbHkpLFxuICAgICAqIC0gdGhlIG5vZGUgaXMgYSBcImRpcmVjdCBjaGlsZFwiIG9mIHRoZSBibG9ja1xuICAgICAqL1xuICAgIF9tYXlCZUFkZEJsb2NrQ2hpbGRyZW4obm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faW5JMThuQmxvY2sgJiYgIXRoaXMuX2luSWN1ICYmIHRoaXMuX2RlcHRoID09IHRoaXMuX2Jsb2NrU3RhcnREZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5fYmxvY2tDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBzdGFydCBvZiBhIHNlY3Rpb24sIHNlZSBgX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbmBcbiAgICAgKi9cbiAgICBfb3BlblRyYW5zbGF0YWJsZVNlY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAodGhpcy5faXNJblRyYW5zbGF0YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcG9ydEVycm9yKG5vZGUsICdVbmV4cGVjdGVkIHNlY3Rpb24gc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21zZ0NvdW50QXRTZWN0aW9uU3RhcnQgPSB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSB0cmFuc2xhdGFibGUgc2VjdGlvbiBjb3VsZCBiZTpcbiAgICAgKiAtIHRoZSBjb250ZW50IG9mIHRyYW5zbGF0YWJsZSBlbGVtZW50LFxuICAgICAqIC0gbm9kZXMgYmV0d2VlbiBgPCEtLSBpMThuIC0tPmAgYW5kIGA8IS0tIC9pMThuIC0tPmAgY29tbWVudHNcbiAgICAgKi9cbiAgICBnZXQgX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbXNnQ291bnRBdFNlY3Rpb25TdGFydCAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGVzIGEgc2VjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgc2VjdGlvbiBoYXMgb25seSBvbmUgc2lnbmlmaWNhbnQgY2hpbGRyZW4gKGNvbW1lbnRzIG5vdCBzaWduaWZpY2FudCkgdGhlbiB3ZSBzaG91bGQgbm90XG4gICAgICoga2VlcCB0aGUgbWVzc2FnZSBmcm9tIHRoaXMgY2hpbGRyZW46XG4gICAgICpcbiAgICAgKiBgPHAgaTE4bj1cIm1lYW5pbmd8ZGVzY3JpcHRpb25cIj57SUNVIG1lc3NhZ2V9PC9wPmAgd291bGQgcHJvZHVjZSB0d28gbWVzc2FnZXM6XG4gICAgICogLSBvbmUgZm9yIHRoZSA8cD4gY29udGVudCB3aXRoIG1lYW5pbmcgYW5kIGRlc2NyaXB0aW9uLFxuICAgICAqIC0gYW5vdGhlciBvbmUgZm9yIHRoZSBJQ1UgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSB0aGUgbGFzdCBtZXNzYWdlIGlzIGRpc2NhcmRlZCBhcyBpdCBjb250YWlucyBsZXNzIGluZm9ybWF0aW9uICh0aGUgQVNUIGlzXG4gICAgICogb3RoZXJ3aXNlIGlkZW50aWNhbCkuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2Ugc2hvdWxkIHN0aWxsIGtlZXAgbWVzc2FnZXMgZXh0cmFjdGVkIGZyb20gYXR0cmlidXRlcyBpbnNpZGUgdGhlIHNlY3Rpb24gKGllIGluIHRoZVxuICAgICAqIElDVSBtZXNzYWdlIGhlcmUpXG4gICAgICovXG4gICAgX2Nsb3NlVHJhbnNsYXRhYmxlU2VjdGlvbihub2RlLCBkaXJlY3RDaGlsZHJlbikge1xuICAgICAgICBpZiAoIXRoaXMuX2lzSW5UcmFuc2xhdGFibGVTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXBvcnRFcnJvcihub2RlLCAnVW5leHBlY3RlZCBzZWN0aW9uIGVuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0O1xuICAgICAgICBjb25zdCBzaWduaWZpY2FudENoaWxkcmVuID0gZGlyZWN0Q2hpbGRyZW4ucmVkdWNlKChjb3VudCwgbm9kZSkgPT4gY291bnQgKyAobm9kZSBpbnN0YW5jZW9mIENvbW1lbnQgPyAwIDogMSksIDApO1xuICAgICAgICBpZiAoc2lnbmlmaWNhbnRDaGlsZHJlbiA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSBzdGFydEluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3QgPSB0aGlzLl9tZXNzYWdlc1tpXS5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIShhc3QubGVuZ3RoID09IDEgJiYgYXN0WzBdIGluc3RhbmNlb2YgVGV4dCQyKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXNzYWdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tc2dDb3VudEF0U2VjdGlvblN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBfcmVwb3J0RXJyb3Iobm9kZSwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3Iobm9kZS5zb3VyY2VTcGFuLCBtc2cpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfaXNPcGVuaW5nQ29tbWVudChuKSB7XG4gICAgcmV0dXJuICEhKG4gaW5zdGFuY2VvZiBDb21tZW50ICYmIG4udmFsdWUgJiYgbi52YWx1ZS5zdGFydHNXaXRoKCdpMThuJykpO1xufVxuZnVuY3Rpb24gX2lzQ2xvc2luZ0NvbW1lbnQobikge1xuICAgIHJldHVybiAhIShuIGluc3RhbmNlb2YgQ29tbWVudCAmJiBuLnZhbHVlICYmIG4udmFsdWUgPT09ICcvaTE4bicpO1xufVxuZnVuY3Rpb24gX2dldEkxOG5BdHRyKHApIHtcbiAgICByZXR1cm4gcC5hdHRycy5maW5kKGF0dHIgPT4gYXR0ci5uYW1lID09PSBfSTE4Tl9BVFRSKSB8fCBudWxsO1xufVxuZnVuY3Rpb24gX3BhcnNlTWVzc2FnZU1ldGEoaTE4bikge1xuICAgIGlmICghaTE4bilcbiAgICAgICAgcmV0dXJuIHsgbWVhbmluZzogJycsIGRlc2NyaXB0aW9uOiAnJywgaWQ6ICcnIH07XG4gICAgY29uc3QgaWRJbmRleCA9IGkxOG4uaW5kZXhPZihJRF9TRVBBUkFUT1IpO1xuICAgIGNvbnN0IGRlc2NJbmRleCA9IGkxOG4uaW5kZXhPZihNRUFOSU5HX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW21lYW5pbmdBbmREZXNjLCBpZF0gPSAoaWRJbmRleCA+IC0xKSA/IFtpMThuLnNsaWNlKDAsIGlkSW5kZXgpLCBpMThuLnNsaWNlKGlkSW5kZXggKyAyKV0gOiBbaTE4biwgJyddO1xuICAgIGNvbnN0IFttZWFuaW5nLCBkZXNjcmlwdGlvbl0gPSAoZGVzY0luZGV4ID4gLTEpID9cbiAgICAgICAgW21lYW5pbmdBbmREZXNjLnNsaWNlKDAsIGRlc2NJbmRleCksIG1lYW5pbmdBbmREZXNjLnNsaWNlKGRlc2NJbmRleCArIDEpXSA6XG4gICAgICAgIFsnJywgbWVhbmluZ0FuZERlc2NdO1xuICAgIHJldHVybiB7IG1lYW5pbmcsIGRlc2NyaXB0aW9uLCBpZDogaWQudHJpbSgpIH07XG59XG5cbmNsYXNzIFhtbFRhZ0RlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNsb3NlZEJ5UGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNWb2lkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWdub3JlRmlyc3RMZiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblNlbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIHRoaXMucHJldmVudE5hbWVzcGFjZUluaGVyaXRhbmNlID0gZmFsc2U7XG4gICAgfVxuICAgIHJlcXVpcmVFeHRyYVBhcmVudChjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNDbG9zZWRCeUNoaWxkKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRDb250ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFRhZ0NvbnRlbnRUeXBlLlBBUlNBQkxFX0RBVEE7XG4gICAgfVxufVxuY29uc3QgX1RBR19ERUZJTklUSU9OID0gbmV3IFhtbFRhZ0RlZmluaXRpb24oKTtcbmZ1bmN0aW9uIGdldFhtbFRhZ0RlZmluaXRpb24odGFnTmFtZSkge1xuICAgIHJldHVybiBfVEFHX0RFRklOSVRJT047XG59XG5cbmNsYXNzIFhtbFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGdldFhtbFRhZ0RlZmluaXRpb24pO1xuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gc3VwZXIucGFyc2Uoc291cmNlLCB1cmwsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY29uc3QgX1ZFUlNJT04kMSA9ICcxLjInO1xuY29uc3QgX1hNTE5TJDEgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjEuMic7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuY29uc3QgX0RFRkFVTFRfU09VUkNFX0xBTkckMSA9ICdlbic7XG5jb25zdCBfUExBQ0VIT0xERVJfVEFHJDIgPSAneCc7XG5jb25zdCBfTUFSS0VSX1RBRyQxID0gJ21yayc7XG5jb25zdCBfRklMRV9UQUcgPSAnZmlsZSc7XG5jb25zdCBfU09VUkNFX1RBRyQxID0gJ3NvdXJjZSc7XG5jb25zdCBfU0VHTUVOVF9TT1VSQ0VfVEFHID0gJ3NlZy1zb3VyY2UnO1xuY29uc3QgX0FMVF9UUkFOU19UQUcgPSAnYWx0LXRyYW5zJztcbmNvbnN0IF9UQVJHRVRfVEFHJDEgPSAndGFyZ2V0JztcbmNvbnN0IF9VTklUX1RBRyQxID0gJ3RyYW5zLXVuaXQnO1xuY29uc3QgX0NPTlRFWFRfR1JPVVBfVEFHID0gJ2NvbnRleHQtZ3JvdXAnO1xuY29uc3QgX0NPTlRFWFRfVEFHID0gJ2NvbnRleHQnO1xuLy8gaHR0cHM6Ly9kb2NzLm9hc2lzLW9wZW4ub3JnL3hsaWZmL3YxLjIvb3MveGxpZmYtY29yZS5odG1sXG4vLyBodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYvdjEuMi94bGlmZi1wcm9maWxlLWh0bWwveGxpZmYtcHJvZmlsZS1odG1sLTEuMi5odG1sXG5jbGFzcyBYbGlmZiBleHRlbmRzIFNlcmlhbGl6ZXIge1xuICAgIHdyaXRlKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgdmlzaXRvciA9IG5ldyBfV3JpdGVWaXNpdG9yJDEoKTtcbiAgICAgICAgY29uc3QgdHJhbnNVbml0cyA9IFtdO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbnRleHRUYWdzID0gW107XG4gICAgICAgICAgICBtZXNzYWdlLnNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleHRHcm91cFRhZyA9IG5ldyBUYWcoX0NPTlRFWFRfR1JPVVBfVEFHLCB7IHB1cnBvc2U6ICdsb2NhdGlvbicgfSk7XG4gICAgICAgICAgICAgICAgY29udGV4dEdyb3VwVGFnLmNoaWxkcmVuLnB1c2gobmV3IENSKDEwKSwgbmV3IFRhZyhfQ09OVEVYVF9UQUcsIHsgJ2NvbnRleHQtdHlwZSc6ICdzb3VyY2VmaWxlJyB9LCBbbmV3IFRleHQkMShzb3VyY2UuZmlsZVBhdGgpXSksIG5ldyBDUigxMCksIG5ldyBUYWcoX0NPTlRFWFRfVEFHLCB7ICdjb250ZXh0LXR5cGUnOiAnbGluZW51bWJlcicgfSwgW25ldyBUZXh0JDEoYCR7c291cmNlLnN0YXJ0TGluZX1gKV0pLCBuZXcgQ1IoOCkpO1xuICAgICAgICAgICAgICAgIGNvbnRleHRUYWdzLnB1c2gobmV3IENSKDgpLCBjb250ZXh0R3JvdXBUYWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc1VuaXQgPSBuZXcgVGFnKF9VTklUX1RBRyQxLCB7IGlkOiBtZXNzYWdlLmlkLCBkYXRhdHlwZTogJ2h0bWwnIH0pO1xuICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHJDEsIHt9LCB2aXNpdG9yLnNlcmlhbGl6ZShtZXNzYWdlLm5vZGVzKSksIC4uLmNvbnRleHRUYWdzKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNVbml0LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBwcmlvcml0eTogJzEnLCBmcm9tOiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWVhbmluZykge1xuICAgICAgICAgICAgICAgIHRyYW5zVW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig4KSwgbmV3IFRhZygnbm90ZScsIHsgcHJpb3JpdHk6ICcxJywgZnJvbTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc1VuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdHJhbnNVbml0cy5wdXNoKG5ldyBDUig2KSwgdHJhbnNVbml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgVGFnKCdib2R5Jywge30sIFsuLi50cmFuc1VuaXRzLCBuZXcgQ1IoNCldKTtcbiAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBUYWcoJ2ZpbGUnLCB7XG4gICAgICAgICAgICAnc291cmNlLWxhbmd1YWdlJzogbG9jYWxlIHx8IF9ERUZBVUxUX1NPVVJDRV9MQU5HJDEsXG4gICAgICAgICAgICBkYXRhdHlwZTogJ3BsYWludGV4dCcsXG4gICAgICAgICAgICBvcmlnaW5hbDogJ25nMi50ZW1wbGF0ZScsXG4gICAgICAgIH0sIFtuZXcgQ1IoNCksIGJvZHksIG5ldyBDUigyKV0pO1xuICAgICAgICBjb25zdCB4bGlmZiA9IG5ldyBUYWcoJ3hsaWZmJywgeyB2ZXJzaW9uOiBfVkVSU0lPTiQxLCB4bWxuczogX1hNTE5TJDEgfSwgW25ldyBDUigyKSwgZmlsZSwgbmV3IENSKCldKTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbXG4gICAgICAgICAgICBuZXcgRGVjbGFyYXRpb24oeyB2ZXJzaW9uOiAnMS4wJywgZW5jb2Rpbmc6ICdVVEYtOCcgfSksIG5ldyBDUigpLCB4bGlmZiwgbmV3IENSKClcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGxvYWQoY29udGVudCwgdXJsKSB7XG4gICAgICAgIC8vIHhsaWZmIHRvIHhtbCBub2Rlc1xuICAgICAgICBjb25zdCB4bGlmZlBhcnNlciA9IG5ldyBYbGlmZlBhcnNlcigpO1xuICAgICAgICBjb25zdCB7IGxvY2FsZSwgbXNnSWRUb0h0bWwsIGVycm9ycyB9ID0geGxpZmZQYXJzZXIucGFyc2UoY29udGVudCwgdXJsKTtcbiAgICAgICAgLy8geG1sIG5vZGVzIHRvIGkxOG4gbm9kZXNcbiAgICAgICAgY29uc3QgaTE4bk5vZGVzQnlNc2dJZCA9IHt9O1xuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgWG1sVG9JMThuJDIoKTtcbiAgICAgICAgT2JqZWN0LmtleXMobXNnSWRUb0h0bWwpLmZvckVhY2gobXNnSWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpMThuTm9kZXMsIGVycm9yczogZSB9ID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpO1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goLi4uZSk7XG4gICAgICAgICAgICBpMThuTm9kZXNCeU1zZ0lkW21zZ0lkXSA9IGkxOG5Ob2RlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHhsaWZmIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGlnZXN0JDEobWVzc2FnZSk7XG4gICAgfVxufVxuY2xhc3MgX1dyaXRlVmlzaXRvciQxIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUZXh0JDEodGV4dC52YWx1ZSldO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IG5vZGVzLnB1c2goLi4ubm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtuZXcgVGV4dCQxKGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sIGApXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYCR7Y30ge2ApLCAuLi5pY3UuY2FzZXNbY10udmlzaXQodGhpcyksIG5ldyBUZXh0JDEoYH0gYCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGB9YCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY3R5cGUgPSBnZXRDdHlwZUZvclRhZyhwaC50YWcpO1xuICAgICAgICBpZiAocGguaXNWb2lkKSB7XG4gICAgICAgICAgICAvLyB2b2lkIHRhZ3MgaGF2ZSBubyBjaGlsZHJlbiBub3IgY2xvc2luZyB0YWdzXG4gICAgICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5zdGFydE5hbWUsIGN0eXBlLCAnZXF1aXYtdGV4dCc6IGA8JHtwaC50YWd9Lz5gIH0pXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFRhZ1BoID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgaWQ6IHBoLnN0YXJ0TmFtZSwgY3R5cGUsICdlcXVpdi10ZXh0JzogYDwke3BoLnRhZ30+YCB9KTtcbiAgICAgICAgY29uc3QgY2xvc2VUYWdQaCA9IG5ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQyLCB7IGlkOiBwaC5jbG9zZU5hbWUsIGN0eXBlLCAnZXF1aXYtdGV4dCc6IGA8LyR7cGgudGFnfT5gIH0pO1xuICAgICAgICByZXR1cm4gW3N0YXJ0VGFnUGgsIC4uLnRoaXMuc2VyaWFsaXplKHBoLmNoaWxkcmVuKSwgY2xvc2VUYWdQaF07XG4gICAgfVxuICAgIHZpc2l0UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMiwgeyBpZDogcGgubmFtZSwgJ2VxdWl2LXRleHQnOiBge3ske3BoLnZhbHVlfX19YCB9KV07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgZXF1aXZUZXh0ID0gYHske3BoLnZhbHVlLmV4cHJlc3Npb259LCAke3BoLnZhbHVlLnR5cGV9LCAke09iamVjdC5rZXlzKHBoLnZhbHVlLmNhc2VzKS5tYXAoKHZhbHVlKSA9PiB2YWx1ZSArICcgey4uLn0nKS5qb2luKCcgJyl9fWA7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDIsIHsgaWQ6IHBoLm5hbWUsICdlcXVpdi10ZXh0JzogZXF1aXZUZXh0IH0pXTtcbiAgICB9XG4gICAgc2VyaWFsaXplKG5vZGVzKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4ubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgIH1cbn1cbi8vIFRPRE8odmljYik6IGFkZCBlcnJvciBtYW5hZ2VtZW50IChzdHJ1Y3R1cmUpXG4vLyBFeHRyYWN0IG1lc3NhZ2VzIGFzIHhtbCBub2RlcyBmcm9tIHRoZSB4bGlmZiBmaWxlXG5jbGFzcyBYbGlmZlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIHBhcnNlKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgY29uc3QgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRyQxOlxuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRNbFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRBdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdpZCcpO1xuICAgICAgICAgICAgICAgIGlmICghaWRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGA8JHtfVU5JVF9UQUckMX0+IG1pc3NlcyB0aGUgXCJpZFwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBpZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tc2dJZFRvSHRtbC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGBEdXBsaWNhdGVkIHRyYW5zbGF0aW9ucyBmb3IgbXNnICR7aWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdW5pdE1sU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21zZ0lkVG9IdG1sW2lkXSA9IHRoaXMuX3VuaXRNbFN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsZW1lbnQsIGBNZXNzYWdlICR7aWR9IG1pc3NlcyBhIHRyYW5zbGF0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBpZ25vcmUgdGhvc2UgdGFnc1xuICAgICAgICAgICAgY2FzZSBfU09VUkNFX1RBRyQxOlxuICAgICAgICAgICAgY2FzZSBfU0VHTUVOVF9TT1VSQ0VfVEFHOlxuICAgICAgICAgICAgY2FzZSBfQUxUX1RSQU5TX1RBRzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RBUkdFVF9UQUckMTpcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRTdGFydCA9IGVsZW1lbnQuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0RW5kID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uc3RhcnQuZmlsZS5jb250ZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dCA9IGNvbnRlbnQuc2xpY2UoaW5uZXJUZXh0U3RhcnQsIGlubmVyVGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfRklMRV9UQUc6XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAndGFyZ2V0LWxhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZUF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFRPRE8odmljYik6IGFzc2VydCBmaWxlIHN0cnVjdHVyZSwgeGxpZmYgdmVyc2lvblxuICAgICAgICAgICAgICAgIC8vIEZvciBub3cgb25seSByZWN1cnNlIG9uIHVuaGFuZGxlZCBub2Rlc1xuICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0Q29tbWVudChjb21tZW50LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbihleHBhbnNpb24sIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShleHBhbnNpb25DYXNlLCBjb250ZXh0KSB7IH1cbiAgICBfYWRkRXJyb3Iobm9kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLl9lcnJvcnMucHVzaChuZXcgSTE4bkVycm9yKG5vZGUuc291cmNlU3BhbiwgbWVzc2FnZSkpO1xuICAgIH1cbn1cbi8vIENvbnZlcnQgbWwgbm9kZXMgKHhsaWZmIHN5bnRheCkgdG8gaTE4biBub2Rlc1xuY2xhc3MgWG1sVG9JMThuJDIge1xuICAgIGNvbnZlcnQobWVzc2FnZSwgdXJsKSB7XG4gICAgICAgIGNvbnN0IHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgY29uc3QgaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgeG1sSWN1LnJvb3ROb2RlcykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaTE4bk5vZGVzOiBpMThuTm9kZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuX2Vycm9ycyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRUZXh0KHRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0JDIodGV4dC52YWx1ZSwgdGV4dC5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChlbC5uYW1lID09PSBfUExBQ0VIT0xERVJfVEFHJDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgIGlmIChuYW1lQXR0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUGxhY2Vob2xkZXIoJycsIG5hbWVBdHRyLnZhbHVlLCBlbC5zb3VyY2VTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgPCR7X1BMQUNFSE9MREVSX1RBRyQyfT4gbWlzc2VzIHRoZSBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwubmFtZSA9PT0gX01BUktFUl9UQUckMSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi52aXNpdEFsbCh0aGlzLCBlbC5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgVW5leHBlY3RlZCB0YWdgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uKGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBjYXNlTWFwID0ge307XG4gICAgICAgIHZpc2l0QWxsKHRoaXMsIGljdS5jYXNlcykuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgY2FzZU1hcFtjLnZhbHVlXSA9IG5ldyBDb250YWluZXIoYy5ub2RlcywgaWN1LnNvdXJjZVNwYW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBJY3UoaWN1LnN3aXRjaFZhbHVlLCBpY3UudHlwZSwgY2FzZU1hcCwgaWN1LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoaWN1Q2FzZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGljdUNhc2UudmFsdWUsXG4gICAgICAgICAgICBub2RlczogdmlzaXRBbGwodGhpcywgaWN1Q2FzZS5leHByZXNzaW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDdHlwZUZvclRhZyh0YWcpIHtcbiAgICBzd2l0Y2ggKHRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgIHJldHVybiAnbGInO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYHgtJHt0YWd9YDtcbiAgICB9XG59XG5cbmNvbnN0IF9WRVJTSU9OID0gJzIuMCc7XG5jb25zdCBfWE1MTlMgPSAndXJuOm9hc2lzOm5hbWVzOnRjOnhsaWZmOmRvY3VtZW50OjIuMCc7XG4vLyBUT0RPKHZpY2IpOiBtYWtlIHRoaXMgYSBwYXJhbSAocy9fLy0vKVxuY29uc3QgX0RFRkFVTFRfU09VUkNFX0xBTkcgPSAnZW4nO1xuY29uc3QgX1BMQUNFSE9MREVSX1RBRyQxID0gJ3BoJztcbmNvbnN0IF9QTEFDRUhPTERFUl9TUEFOTklOR19UQUcgPSAncGMnO1xuY29uc3QgX01BUktFUl9UQUcgPSAnbXJrJztcbmNvbnN0IF9YTElGRl9UQUcgPSAneGxpZmYnO1xuY29uc3QgX1NPVVJDRV9UQUcgPSAnc291cmNlJztcbmNvbnN0IF9UQVJHRVRfVEFHID0gJ3RhcmdldCc7XG5jb25zdCBfVU5JVF9UQUcgPSAndW5pdCc7XG4vLyBodHRwczovL2RvY3Mub2FzaXMtb3Blbi5vcmcveGxpZmYveGxpZmYtY29yZS92Mi4wL29zL3hsaWZmLWNvcmUtdjIuMC1vcy5odG1sXG5jbGFzcyBYbGlmZjIgZXh0ZW5kcyBTZXJpYWxpemVyIHtcbiAgICB3cml0ZShtZXNzYWdlcywgbG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHZpc2l0b3IgPSBuZXcgX1dyaXRlVmlzaXRvcigpO1xuICAgICAgICBjb25zdCB1bml0cyA9IFtdO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgdW5pdCA9IG5ldyBUYWcoX1VOSVRfVEFHLCB7IGlkOiBtZXNzYWdlLmlkIH0pO1xuICAgICAgICAgICAgY29uc3Qgbm90ZXMgPSBuZXcgVGFnKCdub3RlcycpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gfHwgbWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXMuY2hpbGRyZW4ucHVzaChuZXcgQ1IoOCksIG5ldyBUYWcoJ25vdGUnLCB7IGNhdGVnb3J5OiAnZGVzY3JpcHRpb24nIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UuZGVzY3JpcHRpb24pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5tZWFuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ21lYW5pbmcnIH0sIFtuZXcgVGV4dCQxKG1lc3NhZ2UubWVhbmluZyldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKCdub3RlJywgeyBjYXRlZ29yeTogJ2xvY2F0aW9uJyB9LCBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBUZXh0JDEoYCR7c291cmNlLmZpbGVQYXRofToke3NvdXJjZS5zdGFydExpbmV9JHtzb3VyY2UuZW5kTGluZSAhPT0gc291cmNlLnN0YXJ0TGluZSA/ICcsJyArIHNvdXJjZS5lbmRMaW5lIDogJyd9YClcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vdGVzLmNoaWxkcmVuLnB1c2gobmV3IENSKDYpKTtcbiAgICAgICAgICAgIHVuaXQuY2hpbGRyZW4ucHVzaChuZXcgQ1IoNiksIG5vdGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBuZXcgVGFnKCdzZWdtZW50Jyk7XG4gICAgICAgICAgICBzZWdtZW50LmNoaWxkcmVuLnB1c2gobmV3IENSKDgpLCBuZXcgVGFnKF9TT1VSQ0VfVEFHLCB7fSwgdmlzaXRvci5zZXJpYWxpemUobWVzc2FnZS5ub2RlcykpLCBuZXcgQ1IoNikpO1xuICAgICAgICAgICAgdW5pdC5jaGlsZHJlbi5wdXNoKG5ldyBDUig2KSwgc2VnbWVudCwgbmV3IENSKDQpKTtcbiAgICAgICAgICAgIHVuaXRzLnB1c2gobmV3IENSKDQpLCB1bml0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgVGFnKCdmaWxlJywgeyAnb3JpZ2luYWwnOiAnbmcudGVtcGxhdGUnLCBpZDogJ25naTE4bicgfSwgWy4uLnVuaXRzLCBuZXcgQ1IoMildKTtcbiAgICAgICAgY29uc3QgeGxpZmYgPSBuZXcgVGFnKF9YTElGRl9UQUcsIHsgdmVyc2lvbjogX1ZFUlNJT04sIHhtbG5zOiBfWE1MTlMsIHNyY0xhbmc6IGxvY2FsZSB8fCBfREVGQVVMVF9TT1VSQ0VfTEFORyB9LCBbbmV3IENSKDIpLCBmaWxlLCBuZXcgQ1IoKV0pO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtcbiAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbih7IHZlcnNpb246ICcxLjAnLCBlbmNvZGluZzogJ1VURi04JyB9KSwgbmV3IENSKCksIHhsaWZmLCBuZXcgQ1IoKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgbG9hZChjb250ZW50LCB1cmwpIHtcbiAgICAgICAgLy8geGxpZmYgdG8geG1sIG5vZGVzXG4gICAgICAgIGNvbnN0IHhsaWZmMlBhcnNlciA9IG5ldyBYbGlmZjJQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHhsaWZmMlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICBjb25zdCBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4kMSgpO1xuICAgICAgICBPYmplY3Qua2V5cyhtc2dJZFRvSHRtbCkuZm9yRWFjaChtc2dJZCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGkxOG5Ob2RlcywgZXJyb3JzOiBlIH0gPSBjb252ZXJ0ZXIuY29udmVydChtc2dJZFRvSHRtbFttc2dJZF0sIHVybCk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5lKTtcbiAgICAgICAgICAgIGkxOG5Ob2Rlc0J5TXNnSWRbbXNnSWRdID0gaTE4bk5vZGVzO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgeGxpZmYyIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGVjaW1hbERpZ2VzdChtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBfV3JpdGVWaXNpdG9yIHtcbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gW25ldyBUZXh0JDEodGV4dC52YWx1ZSldO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgY29udGFpbmVyLmNoaWxkcmVuLmZvckVhY2goKG5vZGUpID0+IG5vZGVzLnB1c2goLi4ubm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0SWN1KGljdSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBub2RlcyA9IFtuZXcgVGV4dCQxKGB7JHtpY3UuZXhwcmVzc2lvblBsYWNlaG9sZGVyfSwgJHtpY3UudHlwZX0sIGApXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5ldyBUZXh0JDEoYCR7Y30ge2ApLCAuLi5pY3UuY2FzZXNbY10udmlzaXQodGhpcyksIG5ldyBUZXh0JDEoYH0gYCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChuZXcgVGV4dCQxKGB9YCkpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGdldFR5cGVGb3JUYWcocGgudGFnKTtcbiAgICAgICAgaWYgKHBoLmlzVm9pZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnUGggPSBuZXcgVGFnKF9QTEFDRUhPTERFUl9UQUckMSwge1xuICAgICAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dFBsYWNlaG9sZGVySWQrKykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlcXVpdjogcGguc3RhcnROYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgZGlzcDogYDwke3BoLnRhZ30vPmAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbdGFnUGhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1BjID0gbmV3IFRhZyhfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHLCB7XG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBlcXVpdlN0YXJ0OiBwaC5zdGFydE5hbWUsXG4gICAgICAgICAgICBlcXVpdkVuZDogcGguY2xvc2VOYW1lLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRpc3BTdGFydDogYDwke3BoLnRhZ30+YCxcbiAgICAgICAgICAgIGRpc3BFbmQ6IGA8LyR7cGgudGFnfT5gLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXS5jb25jYXQoLi4ucGguY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB0YWdQYy5jaGlsZHJlbi5wdXNoKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZ1BjLmNoaWxkcmVuLnB1c2gobmV3IFRleHQkMSgnJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGFnUGNdO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGlkU3RyID0gKHRoaXMuX25leHRQbGFjZWhvbGRlcklkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBbbmV3IFRhZyhfUExBQ0VIT0xERVJfVEFHJDEsIHtcbiAgICAgICAgICAgICAgICBpZDogaWRTdHIsXG4gICAgICAgICAgICAgICAgZXF1aXY6IHBoLm5hbWUsXG4gICAgICAgICAgICAgICAgZGlzcDogYHt7JHtwaC52YWx1ZX19fWAsXG4gICAgICAgICAgICB9KV07XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZXMgPSBPYmplY3Qua2V5cyhwaC52YWx1ZS5jYXNlcykubWFwKCh2YWx1ZSkgPT4gdmFsdWUgKyAnIHsuLi59Jykuam9pbignICcpO1xuICAgICAgICBjb25zdCBpZFN0ciA9ICh0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCsrKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gW25ldyBUYWcoX1BMQUNFSE9MREVSX1RBRyQxLCB7IGlkOiBpZFN0ciwgZXF1aXY6IHBoLm5hbWUsIGRpc3A6IGB7JHtwaC52YWx1ZS5leHByZXNzaW9ufSwgJHtwaC52YWx1ZS50eXBlfSwgJHtjYXNlc319YCB9KV07XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2Rlcykge1xuICAgICAgICB0aGlzLl9uZXh0UGxhY2Vob2xkZXJJZCA9IDA7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4ubm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkpO1xuICAgIH1cbn1cbi8vIEV4dHJhY3QgbWVzc2FnZXMgYXMgeG1sIG5vZGVzIGZyb20gdGhlIHhsaWZmIGZpbGVcbmNsYXNzIFhsaWZmMlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG51bGw7XG4gICAgfVxuICAgIHBhcnNlKHhsaWZmLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fdW5pdE1sU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWwgPSB7fTtcbiAgICAgICAgY29uc3QgeG1sID0gbmV3IFhtbFBhcnNlcigpLnBhcnNlKHhsaWZmLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9VTklUX1RBRzpcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnaWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlkQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1VOSVRfVEFHfT4gbWlzc2VzIHRoZSBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGlkQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX21zZ0lkVG9IdG1sLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYER1cGxpY2F0ZWQgdHJhbnNsYXRpb25zIGZvciBtc2cgJHtpZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl91bml0TWxTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gdGhpcy5fdW5pdE1sU3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYE1lc3NhZ2UgJHtpZH0gbWlzc2VzIGEgdHJhbnNsYXRpb25gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1NPVVJDRV9UQUc6XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9UQVJHRVRfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyVGV4dFN0YXJ0ID0gZWxlbWVudC5zdGFydFNvdXJjZVNwYW4uZW5kLm9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHRFbmQgPSBlbGVtZW50LmVuZFNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0ID0gY29udGVudC5zbGljZShpbm5lclRleHRTdGFydCwgaW5uZXJUZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bml0TWxTdHJpbmcgPSBpbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9YTElGRl9UQUc6XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAndHJnTGFuZycpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IGxvY2FsZUF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb25BdHRyID0gZWxlbWVudC5hdHRycy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICd2ZXJzaW9uJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSB2ZXJzaW9uQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09ICcyLjAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgVGhlIFhMSUZGIGZpbGUgdmVyc2lvbiAke3ZlcnNpb259IGlzIG5vdCBjb21wYXRpYmxlIHdpdGggWExJRkYgMi4wIHNlcmlhbGl6ZXJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0QWxsKHRoaXMsIGVsZW1lbnQuY2hpbGRyZW4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCBlbGVtZW50LmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4bGlmZiBzeW50YXgpIHRvIGkxOG4gbm9kZXNcbmNsYXNzIFhtbFRvSTE4biQxIHtcbiAgICBjb252ZXJ0KG1lc3NhZ2UsIHVybCkge1xuICAgICAgICBjb25zdCB4bWxJY3UgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UobWVzc2FnZSwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IHhtbEljdS5lcnJvcnM7XG4gICAgICAgIGNvbnN0IGkxOG5Ob2RlcyA9IHRoaXMuX2Vycm9ycy5sZW5ndGggPiAwIHx8IHhtbEljdS5yb290Tm9kZXMubGVuZ3RoID09IDAgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgICAgW10uY29uY2F0KC4uLnZpc2l0QWxsKHRoaXMsIHhtbEljdS5yb290Tm9kZXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgc3dpdGNoIChlbC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9QTEFDRUhPTERFUl9UQUckMTpcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lQXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFBsYWNlaG9sZGVyKCcnLCBuYW1lQXR0ci52YWx1ZSwgZWwuc291cmNlU3BhbildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlwiIGF0dHJpYnV0ZWApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBfUExBQ0VIT0xERVJfU1BBTk5JTkdfVEFHOlxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0QXR0ciA9IGVsLmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2VxdWl2U3RhcnQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRBdHRyID0gZWwuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnZXF1aXZFbmQnKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0QXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbCwgYDwke19QTEFDRUhPTERFUl9UQUckMX0+IG1pc3NlcyB0aGUgXCJlcXVpdlN0YXJ0XCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlbmRBdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgPCR7X1BMQUNFSE9MREVSX1RBRyQxfT4gbWlzc2VzIHRoZSBcImVxdWl2RW5kXCIgYXR0cmlidXRlYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydElkID0gc3RhcnRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmRJZCA9IGVuZEF0dHIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2Rlcy5jb25jYXQobmV3IFBsYWNlaG9sZGVyKCcnLCBzdGFydElkLCBlbC5zb3VyY2VTcGFuKSwgLi4uZWwuY2hpbGRyZW4ubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzLCBudWxsKSksIG5ldyBQbGFjZWhvbGRlcignJywgZW5kSWQsIGVsLnNvdXJjZVNwYW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9NQVJLRVJfVEFHOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoLi4udmlzaXRBbGwodGhpcywgZWwuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGBVbmV4cGVjdGVkIHRhZ2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgIGNhc2VNYXBbYy52YWx1ZV0gPSBuZXcgQ29udGFpbmVyKGMubm9kZXMsIGljdS5zb3VyY2VTcGFuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSWN1KGljdS5zd2l0Y2hWYWx1ZSwgaWN1LnR5cGUsIGNhc2VNYXAsIGljdS5zb3VyY2VTcGFuKTtcbiAgICB9XG4gICAgdmlzaXRFeHBhbnNpb25DYXNlKGljdUNhc2UsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBpY3VDYXNlLnZhbHVlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLmNvbmNhdCguLi52aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlRm9yVGFnKHRhZykge1xuICAgIHN3aXRjaCAodGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnYnInOlxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgcmV0dXJuICdmbXQnO1xuICAgICAgICBjYXNlICdpbWcnOlxuICAgICAgICAgICAgcmV0dXJuICdpbWFnZSc7XG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgICAgcmV0dXJuICdsaW5rJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgIH1cbn1cblxuY29uc3QgX1RSQU5TTEFUSU9OU19UQUcgPSAndHJhbnNsYXRpb25idW5kbGUnO1xuY29uc3QgX1RSQU5TTEFUSU9OX1RBRyA9ICd0cmFuc2xhdGlvbic7XG5jb25zdCBfUExBQ0VIT0xERVJfVEFHID0gJ3BoJztcbmNsYXNzIFh0YiBleHRlbmRzIFNlcmlhbGl6ZXIge1xuICAgIHdyaXRlKG1lc3NhZ2VzLCBsb2NhbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBsb2FkKGNvbnRlbnQsIHVybCkge1xuICAgICAgICAvLyB4dGIgdG8geG1sIG5vZGVzXG4gICAgICAgIGNvbnN0IHh0YlBhcnNlciA9IG5ldyBYdGJQYXJzZXIoKTtcbiAgICAgICAgY29uc3QgeyBsb2NhbGUsIG1zZ0lkVG9IdG1sLCBlcnJvcnMgfSA9IHh0YlBhcnNlci5wYXJzZShjb250ZW50LCB1cmwpO1xuICAgICAgICAvLyB4bWwgbm9kZXMgdG8gaTE4biBub2Rlc1xuICAgICAgICBjb25zdCBpMThuTm9kZXNCeU1zZ0lkID0ge307XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBYbWxUb0kxOG4oKTtcbiAgICAgICAgLy8gQmVjYXVzZSB3ZSBzaG91bGQgYmUgYWJsZSB0byBsb2FkIHh0YiBmaWxlcyB0aGF0IHJlbHkgb24gZmVhdHVyZXMgbm90IHN1cHBvcnRlZCBieSBhbmd1bGFyLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IHRoZSBjb252ZXJzaW9uIG9mIGh0bWwgdG8gaTE4biBub2RlcyBzbyB0aGF0IG5vbiBhbmd1bGFyIG1lc3NhZ2VzIGFyZSBub3RcbiAgICAgICAgLy8gY29udmVydGVkXG4gICAgICAgIE9iamVjdC5rZXlzKG1zZ0lkVG9IdG1sKS5mb3JFYWNoKG1zZ0lkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpMThuTm9kZXMsIGVycm9ycyB9ID0gY29udmVydGVyLmNvbnZlcnQobXNnSWRUb0h0bWxbbXNnSWRdLCB1cmwpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgeHRiIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkxOG5Ob2RlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjcmVhdGVMYXp5UHJvcGVydHkoaTE4bk5vZGVzQnlNc2dJZCwgbXNnSWQsIHZhbHVlRm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgeHRiIHBhcnNlIGVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBsb2NhbGU6IGxvY2FsZSwgaTE4bk5vZGVzQnlNc2dJZCB9O1xuICAgIH1cbiAgICBkaWdlc3QobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gZGlnZXN0KG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjcmVhdGVOYW1lTWFwcGVyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVQbGFjZWhvbGRlck1hcHBlcihtZXNzYWdlLCB0b1B1YmxpY05hbWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUxhenlQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHZhbHVlRm4pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVzc2FnZXMsIGlkLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlRm4oKTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXNzYWdlcywgaWQsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogXyA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBvdmVyd3JpdGUgYW4gWFRCIHRyYW5zbGF0aW9uJyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyBFeHRyYWN0IG1lc3NhZ2VzIGFzIHhtbCBub2RlcyBmcm9tIHRoZSB4dGIgZmlsZVxuY2xhc3MgWHRiUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbnVsbDtcbiAgICB9XG4gICAgcGFyc2UoeHRiLCB1cmwpIHtcbiAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGggPSAwO1xuICAgICAgICB0aGlzLl9tc2dJZFRvSHRtbCA9IHt9O1xuICAgICAgICAvLyBXZSBjYW4gbm90IHBhcnNlIHRoZSBJQ1UgbWVzc2FnZXMgYXQgdGhpcyBwb2ludCBhcyBzb21lIG1lc3NhZ2VzIG1pZ2h0IG5vdCBvcmlnaW5hdGVcbiAgICAgICAgLy8gZnJvbSBBbmd1bGFyIHRoYXQgY291bGQgbm90IGJlIGxleCdkLlxuICAgICAgICBjb25zdCB4bWwgPSBuZXcgWG1sUGFyc2VyKCkucGFyc2UoeHRiLCB1cmwpO1xuICAgICAgICB0aGlzLl9lcnJvcnMgPSB4bWwuZXJyb3JzO1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWwucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZ0lkVG9IdG1sOiB0aGlzLl9tc2dJZFRvSHRtbCxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0RWxlbWVudChlbGVtZW50LCBjb250ZXh0KSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIF9UUkFOU0xBVElPTlNfVEFHOlxuICAgICAgICAgICAgICAgIHRoaXMuX2J1bmRsZURlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2J1bmRsZURlcHRoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgPCR7X1RSQU5TTEFUSU9OU19UQUd9PiBlbGVtZW50cyBjYW4gbm90IGJlIG5lc3RlZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsYW5nQXR0ciA9IGVsZW1lbnQuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnbGFuZycpO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBsYW5nQXR0ci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmlzaXRBbGwodGhpcywgZWxlbWVudC5jaGlsZHJlbiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnVuZGxlRGVwdGgtLTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgX1RSQU5TTEFUSU9OX1RBRzpcbiAgICAgICAgICAgICAgICBjb25zdCBpZEF0dHIgPSBlbGVtZW50LmF0dHJzLmZpbmQoKGF0dHIpID0+IGF0dHIubmFtZSA9PT0gJ2lkJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZEF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWxlbWVudCwgYDwke19UUkFOU0xBVElPTl9UQUd9PiBtaXNzZXMgdGhlIFwiaWRcIiBhdHRyaWJ1dGVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gaWRBdHRyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbXNnSWRUb0h0bWwuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCBgRHVwbGljYXRlZCB0cmFuc2xhdGlvbnMgZm9yIG1zZyAke2lkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0U3RhcnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJUZXh0RW5kID0gZWxlbWVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlbGVtZW50LnN0YXJ0U291cmNlU3Bhbi5zdGFydC5maWxlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lclRleHQgPSBjb250ZW50LnNsaWNlKGlubmVyVGV4dFN0YXJ0LCBpbm5lclRleHRFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXNnSWRUb0h0bWxbaWRdID0gaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihlbGVtZW50LCAnVW5leHBlY3RlZCB0YWcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdENvbW1lbnQoY29tbWVudCwgY29udGV4dCkgeyB9XG4gICAgdmlzaXRFeHBhbnNpb24oZXhwYW5zaW9uLCBjb250ZXh0KSB7IH1cbiAgICB2aXNpdEV4cGFuc2lvbkNhc2UoZXhwYW5zaW9uQ2FzZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0IG1sIG5vZGVzICh4dGIgc3ludGF4KSB0byBpMThuIG5vZGVzXG5jbGFzcyBYbWxUb0kxOG4ge1xuICAgIGNvbnZlcnQobWVzc2FnZSwgdXJsKSB7XG4gICAgICAgIGNvbnN0IHhtbEljdSA9IG5ldyBYbWxQYXJzZXIoKS5wYXJzZShtZXNzYWdlLCB1cmwsIHsgdG9rZW5pemVFeHBhbnNpb25Gb3JtczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0geG1sSWN1LmVycm9ycztcbiAgICAgICAgY29uc3QgaTE4bk5vZGVzID0gdGhpcy5fZXJyb3JzLmxlbmd0aCA+IDAgfHwgeG1sSWN1LnJvb3ROb2Rlcy5sZW5ndGggPT0gMCA/XG4gICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICB2aXNpdEFsbCh0aGlzLCB4bWxJY3Uucm9vdE5vZGVzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGkxOG5Ob2RlcyxcbiAgICAgICAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdFRleHQodGV4dCwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHQkMih0ZXh0LnZhbHVlLCB0ZXh0LnNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdEV4cGFuc2lvbihpY3UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FzZU1hcCA9IHt9O1xuICAgICAgICB2aXNpdEFsbCh0aGlzLCBpY3UuY2FzZXMpLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjYXNlTWFwW2MudmFsdWVdID0gbmV3IENvbnRhaW5lcihjLm5vZGVzLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEljdShpY3Uuc3dpdGNoVmFsdWUsIGljdS50eXBlLCBjYXNlTWFwLCBpY3Uuc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0RXhwYW5zaW9uQ2FzZShpY3VDYXNlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaWN1Q2FzZS52YWx1ZSxcbiAgICAgICAgICAgIG5vZGVzOiB2aXNpdEFsbCh0aGlzLCBpY3VDYXNlLmV4cHJlc3Npb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGVsLm5hbWUgPT09IF9QTEFDRUhPTERFUl9UQUcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVBdHRyID0gZWwuYXR0cnMuZmluZCgoYXR0cikgPT4gYXR0ci5uYW1lID09PSAnbmFtZScpO1xuICAgICAgICAgICAgaWYgKG5hbWVBdHRyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcignJywgbmFtZUF0dHIudmFsdWUsIGVsLnNvdXJjZVNwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRkRXJyb3IoZWwsIGA8JHtfUExBQ0VIT0xERVJfVEFHfT4gbWlzc2VzIHRoZSBcIm5hbWVcIiBhdHRyaWJ1dGVgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEVycm9yKGVsLCBgVW5leHBlY3RlZCB0YWdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmlzaXRDb21tZW50KGNvbW1lbnQsIGNvbnRleHQpIHsgfVxuICAgIHZpc2l0QXR0cmlidXRlKGF0dHJpYnV0ZSwgY29udGV4dCkgeyB9XG4gICAgX2FkZEVycm9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2gobmV3IEkxOG5FcnJvcihub2RlLnNvdXJjZVNwYW4sIG1lc3NhZ2UpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQSBjb250YWluZXIgZm9yIHRyYW5zbGF0ZWQgbWVzc2FnZXNcbiAqL1xuY2xhc3MgVHJhbnNsYXRpb25CdW5kbGUge1xuICAgIGNvbnN0cnVjdG9yKF9pMThuTm9kZXNCeU1zZ0lkID0ge30sIGxvY2FsZSwgZGlnZXN0LCBtYXBwZXJGYWN0b3J5LCBtaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9IE1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5Lldhcm5pbmcsIGNvbnNvbGUpIHtcbiAgICAgICAgdGhpcy5faTE4bk5vZGVzQnlNc2dJZCA9IF9pMThuTm9kZXNCeU1zZ0lkO1xuICAgICAgICB0aGlzLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdGhpcy5tYXBwZXJGYWN0b3J5ID0gbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5faTE4blRvSHRtbCA9IG5ldyBJMThuVG9IdG1sVmlzaXRvcihfaTE4bk5vZGVzQnlNc2dJZCwgbG9jYWxlLCBkaWdlc3QsIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlcyBhIGBUcmFuc2xhdGlvbkJ1bmRsZWAgYnkgcGFyc2luZyB0aGUgZ2l2ZW4gYGNvbnRlbnRgIHdpdGggdGhlIGBzZXJpYWxpemVyYC5cbiAgICBzdGF0aWMgbG9hZChjb250ZW50LCB1cmwsIHNlcmlhbGl6ZXIsIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKSB7XG4gICAgICAgIGNvbnN0IHsgbG9jYWxlLCBpMThuTm9kZXNCeU1zZ0lkIH0gPSBzZXJpYWxpemVyLmxvYWQoY29udGVudCwgdXJsKTtcbiAgICAgICAgY29uc3QgZGlnZXN0Rm4gPSAobSkgPT4gc2VyaWFsaXplci5kaWdlc3QobSk7XG4gICAgICAgIGNvbnN0IG1hcHBlckZhY3RvcnkgPSAobSkgPT4gc2VyaWFsaXplci5jcmVhdGVOYW1lTWFwcGVyKG0pO1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zbGF0aW9uQnVuZGxlKGkxOG5Ob2Rlc0J5TXNnSWQsIGxvY2FsZSwgZGlnZXN0Rm4sIG1hcHBlckZhY3RvcnksIG1pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBjb25zb2xlKTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gYXMgSFRNTCBub2RlcyBmcm9tIHRoZSBnaXZlbiBzb3VyY2UgbWVzc2FnZS5cbiAgICBnZXQoc3JjTXNnKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB0aGlzLl9pMThuVG9IdG1sLmNvbnZlcnQoc3JjTXNnKTtcbiAgICAgICAgaWYgKGh0bWwuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGh0bWwuZXJyb3JzLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbC5ub2RlcztcbiAgICB9XG4gICAgaGFzKHNyY01zZykge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3Qoc3JjTXNnKSBpbiB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkO1xuICAgIH1cbn1cbmNsYXNzIEkxOG5Ub0h0bWxWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihfaTE4bk5vZGVzQnlNc2dJZCA9IHt9LCBfbG9jYWxlLCBfZGlnZXN0LCBfbWFwcGVyRmFjdG9yeSwgX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5LCBfY29uc29sZSkge1xuICAgICAgICB0aGlzLl9pMThuTm9kZXNCeU1zZ0lkID0gX2kxOG5Ob2Rlc0J5TXNnSWQ7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX2RpZ2VzdCA9IF9kaWdlc3Q7XG4gICAgICAgIHRoaXMuX21hcHBlckZhY3RvcnkgPSBfbWFwcGVyRmFjdG9yeTtcbiAgICAgICAgdGhpcy5fbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kgPSBfbWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2NvbnNvbGUgPSBfY29uc29sZTtcbiAgICAgICAgdGhpcy5fY29udGV4dFN0YWNrID0gW107XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgIH1cbiAgICBjb252ZXJ0KHNyY01zZykge1xuICAgICAgICB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZXJyb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIGkxOG4gdG8gdGV4dFxuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fY29udmVydFRvVGV4dChzcmNNc2cpO1xuICAgICAgICAvLyB0ZXh0IHRvIGh0bWxcbiAgICAgICAgY29uc3QgdXJsID0gc3JjTXNnLm5vZGVzWzBdLnNvdXJjZVNwYW4uc3RhcnQuZmlsZS51cmw7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBuZXcgSHRtbFBhcnNlcigpLnBhcnNlKHRleHQsIHVybCwgeyB0b2tlbml6ZUV4cGFuc2lvbkZvcm1zOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZXM6IGh0bWwucm9vdE5vZGVzLFxuICAgICAgICAgICAgZXJyb3JzOiBbLi4udGhpcy5fZXJyb3JzLCAuLi5odG1sLmVycm9yc10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0VGV4dCh0ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIC8vIGBjb252ZXJ0KClgIHVzZXMgYW4gYEh0bWxQYXJzZXJgIHRvIHJldHVybiBgaHRtbC5Ob2RlYHNcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHRoZW4gbWFrZSBzdXJlIHRoYXQgYW55IHNwZWNpYWwgY2hhcmFjdGVycyBhcmUgZXNjYXBlZFxuICAgICAgICByZXR1cm4gZXNjYXBlWG1sKHRleHQudmFsdWUpO1xuICAgIH1cbiAgICB2aXNpdENvbnRhaW5lcihjb250YWluZXIsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jaGlsZHJlbi5tYXAobiA9PiBuLnZpc2l0KHRoaXMpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgdmlzaXRJY3UoaWN1LCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNhc2VzID0gT2JqZWN0LmtleXMoaWN1LmNhc2VzKS5tYXAoayA9PiBgJHtrfSB7JHtpY3UuY2FzZXNba10udmlzaXQodGhpcyl9fWApO1xuICAgICAgICAvLyBUT0RPKHZpY2IpOiBPbmNlIGFsbCBmb3JtYXQgc3dpdGNoIHRvIHVzaW5nIGV4cHJlc3Npb24gcGxhY2Vob2xkZXJzXG4gICAgICAgIC8vIHdlIHNob3VsZCB0aHJvdyB3aGVuIHRoZSBwbGFjZWhvbGRlciBpcyBub3QgaW4gdGhlIHNvdXJjZSBtZXNzYWdlXG4gICAgICAgIGNvbnN0IGV4cCA9IHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkoaWN1LmV4cHJlc3Npb24pID9cbiAgICAgICAgICAgIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbaWN1LmV4cHJlc3Npb25dLnRleHQgOlxuICAgICAgICAgICAgaWN1LmV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBgeyR7ZXhwfSwgJHtpY3UudHlwZX0sICR7Y2FzZXMuam9pbignICcpfX1gO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBoTmFtZSA9IHRoaXMuX21hcHBlcihwaC5uYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnMuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlcnNbcGhOYW1lXS50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zcmNNc2cucGxhY2Vob2xkZXJUb01lc3NhZ2UuaGFzT3duUHJvcGVydHkocGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUb1RleHQodGhpcy5fc3JjTXNnLnBsYWNlaG9sZGVyVG9NZXNzYWdlW3BoTmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEVycm9yKHBoLCBgVW5rbm93biBwbGFjZWhvbGRlciBcIiR7cGgubmFtZX1cImApO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIExvYWRlZCBtZXNzYWdlIGNvbnRhaW5zIG9ubHkgcGxhY2Vob2xkZXJzICh2cyB0YWcgYW5kIGljdSBwbGFjZWhvbGRlcnMpLlxuICAgIC8vIEhvd2V2ZXIgd2hlbiBhIHRyYW5zbGF0aW9uIGNhbiBub3QgYmUgZm91bmQsIHdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgIC8vIHdoaWNoIGNhbiBjb250YWluIHRhZyBwbGFjZWhvbGRlcnNcbiAgICB2aXNpdFRhZ1BsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGAke3BoLnRhZ31gO1xuICAgICAgICBjb25zdCBhdHRycyA9IE9iamVjdC5rZXlzKHBoLmF0dHJzKS5tYXAobmFtZSA9PiBgJHtuYW1lfT1cIiR7cGguYXR0cnNbbmFtZV19XCJgKS5qb2luKCcgJyk7XG4gICAgICAgIGlmIChwaC5pc1ZvaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBgPCR7dGFnfSAke2F0dHJzfS8+YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBoLmNoaWxkcmVuLm1hcCgoYykgPT4gYy52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgICAgIHJldHVybiBgPCR7dGFnfSAke2F0dHJzfT4ke2NoaWxkcmVufTwvJHt0YWd9PmA7XG4gICAgfVxuICAgIC8vIExvYWRlZCBtZXNzYWdlIGNvbnRhaW5zIG9ubHkgcGxhY2Vob2xkZXJzICh2cyB0YWcgYW5kIGljdSBwbGFjZWhvbGRlcnMpLlxuICAgIC8vIEhvd2V2ZXIgd2hlbiBhIHRyYW5zbGF0aW9uIGNhbiBub3QgYmUgZm91bmQsIHdlIG5lZWQgdG8gc2VyaWFsaXplIHRoZSBzb3VyY2UgbWVzc2FnZVxuICAgIC8vIHdoaWNoIGNhbiBjb250YWluIHRhZyBwbGFjZWhvbGRlcnNcbiAgICB2aXNpdEljdVBsYWNlaG9sZGVyKHBoLCBjb250ZXh0KSB7XG4gICAgICAgIC8vIEFuIElDVSBwbGFjZWhvbGRlciByZWZlcmVuY2VzIHRoZSBzb3VyY2UgbWVzc2FnZSB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0VG9UZXh0KHRoaXMuX3NyY01zZy5wbGFjZWhvbGRlclRvTWVzc2FnZVtwaC5uYW1lXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBzb3VyY2UgbWVzc2FnZSB0byBhIHRyYW5zbGF0ZWQgdGV4dCBzdHJpbmc6XG4gICAgICogLSB0ZXh0IG5vZGVzIGFyZSByZXBsYWNlZCB3aXRoIHRoZWlyIHRyYW5zbGF0aW9uLFxuICAgICAqIC0gcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCB3aXRoIHRoZWlyIGNvbnRlbnQsXG4gICAgICogLSBJQ1Ugbm9kZXMgYXJlIGNvbnZlcnRlZCB0byBJQ1UgZXhwcmVzc2lvbnMuXG4gICAgICovXG4gICAgX2NvbnZlcnRUb1RleHQoc3JjTXNnKSB7XG4gICAgICAgIGNvbnN0IGlkID0gdGhpcy5fZGlnZXN0KHNyY01zZyk7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IHRoaXMuX21hcHBlckZhY3RvcnkgPyB0aGlzLl9tYXBwZXJGYWN0b3J5KHNyY01zZykgOiBudWxsO1xuICAgICAgICBsZXQgbm9kZXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHRTdGFjay5wdXNoKHsgbXNnOiB0aGlzLl9zcmNNc2csIG1hcHBlcjogdGhpcy5fbWFwcGVyIH0pO1xuICAgICAgICB0aGlzLl9zcmNNc2cgPSBzcmNNc2c7XG4gICAgICAgIGlmICh0aGlzLl9pMThuTm9kZXNCeU1zZ0lkLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhIHRyYW5zbGF0aW9uIHVzZSBpdHMgbm9kZXMgYXMgdGhlIHNvdXJjZVxuICAgICAgICAgICAgLy8gQW5kIGNyZWF0ZSBhIG1hcHBlciB0byBjb252ZXJ0IHNlcmlhbGl6ZWQgcGxhY2Vob2xkZXIgbmFtZXMgdG8gaW50ZXJuYWwgbmFtZXNcbiAgICAgICAgICAgIG5vZGVzID0gdGhpcy5faTE4bk5vZGVzQnlNc2dJZFtpZF07XG4gICAgICAgICAgICB0aGlzLl9tYXBwZXIgPSAobmFtZSkgPT4gbWFwcGVyID8gbWFwcGVyLnRvSW50ZXJuYWxOYW1lKG5hbWUpIDogbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gbm8gdHJhbnNsYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICAgICAgICAgIC8vIC0gcmVwb3J0IGFuIGVycm9yIC8gYSB3YXJuaW5nIC8gbm90aGluZyxcbiAgICAgICAgICAgIC8vIC0gdXNlIHRoZSBub2RlcyBmcm9tIHRoZSBvcmlnaW5hbCBtZXNzYWdlXG4gICAgICAgICAgICAvLyAtIHBsYWNlaG9sZGVycyBhcmUgYWxyZWFkeSBpbnRlcm5hbCBhbmQgbmVlZCBubyBtYXBwZXJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneSA9PT0gTWlzc2luZ1RyYW5zbGF0aW9uU3RyYXRlZ3kuRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9sb2NhbGUgPyBgIGZvciBsb2NhbGUgXCIke3RoaXMuX2xvY2FsZX1cImAgOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFcnJvcihzcmNNc2cubm9kZXNbMF0sIGBNaXNzaW5nIHRyYW5zbGF0aW9uIGZvciBtZXNzYWdlIFwiJHtpZH1cIiR7Y3R4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY29uc29sZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pc3NpbmdUcmFuc2xhdGlvblN0cmF0ZWd5ID09PSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fbG9jYWxlID8gYCBmb3IgbG9jYWxlIFwiJHt0aGlzLl9sb2NhbGV9XCJgIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uc29sZS53YXJuKGBNaXNzaW5nIHRyYW5zbGF0aW9uIGZvciBtZXNzYWdlIFwiJHtpZH1cIiR7Y3R4fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBzcmNNc2cubm9kZXM7XG4gICAgICAgICAgICB0aGlzLl9tYXBwZXIgPSAobmFtZSkgPT4gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0ID0gbm9kZXMubWFwKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSkuam9pbignJyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0U3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuX3NyY01zZyA9IGNvbnRleHQubXNnO1xuICAgICAgICB0aGlzLl9tYXBwZXIgPSBjb250ZXh0Lm1hcHBlcjtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIF9hZGRFcnJvcihlbCwgbXNnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKG5ldyBJMThuRXJyb3IoZWwuc291cmNlU3BhbiwgbXNnKSk7XG4gICAgfVxufVxuXG5jbGFzcyBJMThOSHRtbFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoX2h0bWxQYXJzZXIsIHRyYW5zbGF0aW9ucywgdHJhbnNsYXRpb25zRm9ybWF0LCBtaXNzaW5nVHJhbnNsYXRpb24gPSBNaXNzaW5nVHJhbnNsYXRpb25TdHJhdGVneS5XYXJuaW5nLCBjb25zb2xlKSB7XG4gICAgICAgIHRoaXMuX2h0bWxQYXJzZXIgPSBfaHRtbFBhcnNlcjtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IGNyZWF0ZVNlcmlhbGl6ZXIodHJhbnNsYXRpb25zRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uQnVuZGxlID1cbiAgICAgICAgICAgICAgICBUcmFuc2xhdGlvbkJ1bmRsZS5sb2FkKHRyYW5zbGF0aW9ucywgJ2kxOG4nLCBzZXJpYWxpemVyLCBtaXNzaW5nVHJhbnNsYXRpb24sIGNvbnNvbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUgPVxuICAgICAgICAgICAgICAgIG5ldyBUcmFuc2xhdGlvbkJ1bmRsZSh7fSwgbnVsbCwgZGlnZXN0JDEsIHVuZGVmaW5lZCwgbWlzc2luZ1RyYW5zbGF0aW9uLCBjb25zb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZShzb3VyY2UsIHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpb25Db25maWcgPSBvcHRpb25zLmludGVycG9sYXRpb25Db25maWcgfHwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRztcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLl9odG1sUGFyc2VyLnBhcnNlKHNvdXJjZSwgdXJsLCB7IGludGVycG9sYXRpb25Db25maWcsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgIGlmIChwYXJzZVJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhcnNlVHJlZVJlc3VsdChwYXJzZVJlc3VsdC5yb290Tm9kZXMsIHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlVHJhbnNsYXRpb25zKHBhcnNlUmVzdWx0LnJvb3ROb2RlcywgdGhpcy5fdHJhbnNsYXRpb25CdW5kbGUsIGludGVycG9sYXRpb25Db25maWcsIFtdLCB7fSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihmb3JtYXQpIHtcbiAgICBmb3JtYXQgPSAoZm9ybWF0IHx8ICd4bGYnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3htYic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhtYigpO1xuICAgICAgICBjYXNlICd4dGInOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYdGIoKTtcbiAgICAgICAgY2FzZSAneGxpZmYyJzpcbiAgICAgICAgY2FzZSAneGxmMic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmMigpO1xuICAgICAgICBjYXNlICd4bGlmZic6XG4gICAgICAgIGNhc2UgJ3hsZic6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhsaWZmKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBtZXNzYWdlIGV4dHJhY3RlZCBmcm9tIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbmNsYXNzIE1lc3NhZ2VCdW5kbGUge1xuICAgIGNvbnN0cnVjdG9yKF9odG1sUGFyc2VyLCBfaW1wbGljaXRUYWdzLCBfaW1wbGljaXRBdHRycywgX2xvY2FsZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5faHRtbFBhcnNlciA9IF9odG1sUGFyc2VyO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFRhZ3MgPSBfaW1wbGljaXRUYWdzO1xuICAgICAgICB0aGlzLl9pbXBsaWNpdEF0dHJzID0gX2ltcGxpY2l0QXR0cnM7XG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IF9sb2NhbGU7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XG4gICAgfVxuICAgIHVwZGF0ZUZyb21UZW1wbGF0ZShodG1sLCB1cmwsIGludGVycG9sYXRpb25Db25maWcpIHtcbiAgICAgICAgY29uc3QgaHRtbFBhcnNlclJlc3VsdCA9IHRoaXMuX2h0bWxQYXJzZXIucGFyc2UoaHRtbCwgdXJsLCB7IHRva2VuaXplRXhwYW5zaW9uRm9ybXM6IHRydWUsIGludGVycG9sYXRpb25Db25maWcgfSk7XG4gICAgICAgIGlmIChodG1sUGFyc2VyUmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBodG1sUGFyc2VyUmVzdWx0LmVycm9ycztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpMThuUGFyc2VyUmVzdWx0ID0gZXh0cmFjdE1lc3NhZ2VzKGh0bWxQYXJzZXJSZXN1bHQucm9vdE5vZGVzLCBpbnRlcnBvbGF0aW9uQ29uZmlnLCB0aGlzLl9pbXBsaWNpdFRhZ3MsIHRoaXMuX2ltcGxpY2l0QXR0cnMpO1xuICAgICAgICBpZiAoaTE4blBhcnNlclJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gaTE4blBhcnNlclJlc3VsdC5lcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZXMucHVzaCguLi5pMThuUGFyc2VyUmVzdWx0Lm1lc3NhZ2VzKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gdGhlIG1lc3NhZ2UgaW4gdGhlIGludGVybmFsIGZvcm1hdFxuICAgIC8vIFRoZSBwdWJsaWMgKHNlcmlhbGl6ZWQpIGZvcm1hdCBtaWdodCBiZSBkaWZmZXJlbnQsIHNlZSB0aGUgYHdyaXRlYCBtZXRob2QuXG4gICAgZ2V0TWVzc2FnZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlcztcbiAgICB9XG4gICAgd3JpdGUoc2VyaWFsaXplciwgZmlsdGVyU291cmNlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHt9O1xuICAgICAgICBjb25zdCBtYXBwZXJWaXNpdG9yID0gbmV3IE1hcFBsYWNlaG9sZGVyTmFtZXMoKTtcbiAgICAgICAgLy8gRGVkdXBsaWNhdGUgbWVzc2FnZXMgYmFzZWQgb24gdGhlaXIgSURcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2VyaWFsaXplci5kaWdlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIW1lc3NhZ2VzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW2lkXSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tpZF0uc291cmNlcy5wdXNoKC4uLm1lc3NhZ2Uuc291cmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmFuc2Zvcm0gcGxhY2Vob2xkZXIgbmFtZXMgdXNpbmcgdGhlIHNlcmlhbGl6ZXIgbWFwcGluZ1xuICAgICAgICBjb25zdCBtc2dMaXN0ID0gT2JqZWN0LmtleXMobWVzc2FnZXMpLm1hcChpZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZXIgPSBzZXJpYWxpemVyLmNyZWF0ZU5hbWVNYXBwZXIobWVzc2FnZXNbaWRdKTtcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IG1lc3NhZ2VzW2lkXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gbWFwcGVyID8gbWFwcGVyVmlzaXRvci5jb252ZXJ0KHNyYy5ub2RlcywgbWFwcGVyKSA6IHNyYy5ub2RlcztcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm1lZE1lc3NhZ2UgPSBuZXcgTWVzc2FnZShub2Rlcywge30sIHt9LCBzcmMubWVhbmluZywgc3JjLmRlc2NyaXB0aW9uLCBpZCk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcyA9IHNyYy5zb3VyY2VzO1xuICAgICAgICAgICAgaWYgKGZpbHRlclNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZE1lc3NhZ2Uuc291cmNlcy5mb3JFYWNoKChzb3VyY2UpID0+IHNvdXJjZS5maWxlUGF0aCA9IGZpbHRlclNvdXJjZXMoc291cmNlLmZpbGVQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRNZXNzYWdlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIud3JpdGUobXNnTGlzdCwgdGhpcy5fbG9jYWxlKTtcbiAgICB9XG59XG4vLyBUcmFuc2Zvcm0gYW4gaTE4biBBU1QgYnkgcmVuYW1pbmcgdGhlIHBsYWNlaG9sZGVyIG5vZGVzIHdpdGggdGhlIGdpdmVuIG1hcHBlclxuY2xhc3MgTWFwUGxhY2Vob2xkZXJOYW1lcyBleHRlbmRzIENsb25lVmlzaXRvciB7XG4gICAgY29udmVydChub2RlcywgbWFwcGVyKSB7XG4gICAgICAgIHJldHVybiBtYXBwZXIgPyBub2Rlcy5tYXAobiA9PiBuLnZpc2l0KHRoaXMsIG1hcHBlcikpIDogbm9kZXM7XG4gICAgfVxuICAgIHZpc2l0VGFnUGxhY2Vob2xkZXIocGgsIG1hcHBlcikge1xuICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLnN0YXJ0TmFtZSk7XG4gICAgICAgIGNvbnN0IGNsb3NlTmFtZSA9IHBoLmNsb3NlTmFtZSA/IG1hcHBlci50b1B1YmxpY05hbWUocGguY2xvc2VOYW1lKSA6IHBoLmNsb3NlTmFtZTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwaC5jaGlsZHJlbi5tYXAobiA9PiBuLnZpc2l0KHRoaXMsIG1hcHBlcikpO1xuICAgICAgICByZXR1cm4gbmV3IFRhZ1BsYWNlaG9sZGVyKHBoLnRhZywgcGguYXR0cnMsIHN0YXJ0TmFtZSwgY2xvc2VOYW1lLCBjaGlsZHJlbiwgcGguaXNWb2lkLCBwaC5zb3VyY2VTcGFuLCBwaC5zdGFydFNvdXJjZVNwYW4sIHBoLmVuZFNvdXJjZVNwYW4pO1xuICAgIH1cbiAgICB2aXNpdFBsYWNlaG9sZGVyKHBoLCBtYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbGFjZWhvbGRlcihwaC52YWx1ZSwgbWFwcGVyLnRvUHVibGljTmFtZShwaC5uYW1lKSwgcGguc291cmNlU3Bhbik7XG4gICAgfVxuICAgIHZpc2l0SWN1UGxhY2Vob2xkZXIocGgsIG1hcHBlcikge1xuICAgICAgICByZXR1cm4gbmV3IEljdVBsYWNlaG9sZGVyKHBoLnZhbHVlLCBtYXBwZXIudG9QdWJsaWNOYW1lKHBoLm5hbWUpLCBwaC5zb3VyY2VTcGFuKTtcbiAgICB9XG59XG5cbnZhciBGYWN0b3J5VGFyZ2V0O1xuKGZ1bmN0aW9uIChGYWN0b3J5VGFyZ2V0KSB7XG4gICAgRmFjdG9yeVRhcmdldFtGYWN0b3J5VGFyZ2V0W1wiRGlyZWN0aXZlXCJdID0gMF0gPSBcIkRpcmVjdGl2ZVwiO1xuICAgIEZhY3RvcnlUYXJnZXRbRmFjdG9yeVRhcmdldFtcIkNvbXBvbmVudFwiXSA9IDFdID0gXCJDb21wb25lbnRcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJJbmplY3RhYmxlXCJdID0gMl0gPSBcIkluamVjdGFibGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJQaXBlXCJdID0gM10gPSBcIlBpcGVcIjtcbiAgICBGYWN0b3J5VGFyZ2V0W0ZhY3RvcnlUYXJnZXRbXCJOZ01vZHVsZVwiXSA9IDRdID0gXCJOZ01vZHVsZVwiO1xufSkoRmFjdG9yeVRhcmdldCB8fCAoRmFjdG9yeVRhcmdldCA9IHt9KSk7XG5cbi8qKlxuICogUHJvY2Vzc2VzIGBUYXJnZXRgcyB3aXRoIGEgZ2l2ZW4gc2V0IG9mIGRpcmVjdGl2ZXMgYW5kIHBlcmZvcm1zIGEgYmluZGluZyBvcGVyYXRpb24sIHdoaWNoXG4gKiByZXR1cm5zIGFuIG9iamVjdCBzaW1pbGFyIHRvIFR5cGVTY3JpcHQncyBgdHMuVHlwZUNoZWNrZXJgIHRoYXQgY29udGFpbnMga25vd2xlZGdlIGFib3V0IHRoZVxuICogdGFyZ2V0LlxuICovXG5jbGFzcyBSM1RhcmdldEJpbmRlciB7XG4gICAgY29uc3RydWN0b3IoZGlyZWN0aXZlTWF0Y2hlcikge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZU1hdGNoZXIgPSBkaXJlY3RpdmVNYXRjaGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgYmluZGluZyBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGBUYXJnZXRgIGFuZCByZXR1cm4gYSBgQm91bmRUYXJnZXRgIHdoaWNoIGNvbnRhaW5zXG4gICAgICogbWV0YWRhdGEgYWJvdXQgdGhlIHR5cGVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGJpbmQodGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0LnRlbXBsYXRlKSB7XG4gICAgICAgICAgICAvLyBUT0RPKGFseGh1Yik6IGhhbmRsZSB0YXJnZXRzIHdoaWNoIGNvbnRhaW4gdGhpbmdzIGxpa2UgSG9zdEJpbmRpbmdzLCBldGMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpbmRpbmcgd2l0aG91dCBhIHRlbXBsYXRlIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QsIHBhcnNlIHRoZSB0ZW1wbGF0ZSBpbnRvIGEgYFNjb3BlYCBzdHJ1Y3R1cmUuIFRoaXMgb3BlcmF0aW9uIGNhcHR1cmVzIHRoZSBzeW50YWN0aWNcbiAgICAgICAgLy8gc2NvcGVzIGluIHRoZSB0ZW1wbGF0ZSBhbmQgbWFrZXMgdGhlbSBhdmFpbGFibGUgZm9yIGxhdGVyIHVzZS5cbiAgICAgICAgY29uc3Qgc2NvcGUgPSBTY29wZS5hcHBseSh0YXJnZXQudGVtcGxhdGUpO1xuICAgICAgICAvLyBVc2UgdGhlIGBTY29wZWAgdG8gZXh0cmFjdCB0aGUgZW50aXRpZXMgcHJlc2VudCBhdCBldmVyeSBsZXZlbCBvZiB0aGUgdGVtcGxhdGUuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlRW50aXRpZXMgPSBleHRyYWN0VGVtcGxhdGVFbnRpdGllcyhzY29wZSk7XG4gICAgICAgIC8vIE5leHQsIHBlcmZvcm0gZGlyZWN0aXZlIG1hdGNoaW5nIG9uIHRoZSB0ZW1wbGF0ZSB1c2luZyB0aGUgYERpcmVjdGl2ZUJpbmRlcmAuIFRoaXMgcmV0dXJuczpcbiAgICAgICAgLy8gICAtIGRpcmVjdGl2ZXM6IE1hcCBvZiBub2RlcyAoZWxlbWVudHMgJiBuZy10ZW1wbGF0ZXMpIHRvIHRoZSBkaXJlY3RpdmVzIG9uIHRoZW0uXG4gICAgICAgIC8vICAgLSBiaW5kaW5nczogTWFwIG9mIGlucHV0cywgb3V0cHV0cywgYW5kIGF0dHJpYnV0ZXMgdG8gdGhlIGRpcmVjdGl2ZS9lbGVtZW50IHRoYXQgY2xhaW1zXG4gICAgICAgIC8vICAgICB0aGVtLiBUT0RPKGFseGh1Yik6IGhhbmRsZSBtdWx0aXBsZSBkaXJlY3RpdmVzIGNsYWltaW5nIGFuIGlucHV0L291dHB1dC9ldGMuXG4gICAgICAgIC8vICAgLSByZWZlcmVuY2VzOiBNYXAgb2YgI3JlZmVyZW5jZXMgdG8gdGhlaXIgdGFyZ2V0cy5cbiAgICAgICAgY29uc3QgeyBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcyB9ID0gRGlyZWN0aXZlQmluZGVyLmFwcGx5KHRhcmdldC50ZW1wbGF0ZSwgdGhpcy5kaXJlY3RpdmVNYXRjaGVyKTtcbiAgICAgICAgLy8gRmluYWxseSwgcnVuIHRoZSBUZW1wbGF0ZUJpbmRlciB0byBiaW5kIHJlZmVyZW5jZXMsIHZhcmlhYmxlcywgYW5kIG90aGVyIGVudGl0aWVzIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gdGVtcGxhdGUuIFRoaXMgZXh0cmFjdHMgYWxsIHRoZSBtZXRhZGF0YSB0aGF0IGRvZXNuJ3QgZGVwZW5kIG9uIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAgICAgICAgY29uc3QgeyBleHByZXNzaW9ucywgc3ltYm9scywgbmVzdGluZ0xldmVsLCB1c2VkUGlwZXMgfSA9IFRlbXBsYXRlQmluZGVyLmFwcGx5V2l0aFNjb3BlKHRhcmdldC50ZW1wbGF0ZSwgc2NvcGUpO1xuICAgICAgICByZXR1cm4gbmV3IFIzQm91bmRUYXJnZXQodGFyZ2V0LCBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcywgZXhwcmVzc2lvbnMsIHN5bWJvbHMsIG5lc3RpbmdMZXZlbCwgdGVtcGxhdGVFbnRpdGllcywgdXNlZFBpcGVzKTtcbiAgICB9XG59XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiaW5kaW5nIHNjb3BlIHdpdGhpbiBhIHRlbXBsYXRlLlxuICpcbiAqIEFueSB2YXJpYWJsZXMsIHJlZmVyZW5jZXMsIG9yIG90aGVyIG5hbWVkIGVudGl0aWVzIGRlY2xhcmVkIHdpdGhpbiB0aGUgdGVtcGxhdGUgd2lsbFxuICogYmUgY2FwdHVyZWQgYW5kIGF2YWlsYWJsZSBieSBuYW1lIGluIGBuYW1lZEVudGl0aWVzYC4gQWRkaXRpb25hbGx5LCBjaGlsZCB0ZW1wbGF0ZXMgd2lsbFxuICogYmUgYW5hbHl6ZWQgYW5kIGhhdmUgdGhlaXIgY2hpbGQgYFNjb3BlYHMgYXZhaWxhYmxlIGluIGBjaGlsZFNjb3Blc2AuXG4gKi9cbmNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnRTY29wZSwgdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTY29wZSA9IHBhcmVudFNjb3BlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lZCBtZW1iZXJzIG9mIHRoZSBgU2NvcGVgLCBzdWNoIGFzIGBSZWZlcmVuY2VgcyBvciBgVmFyaWFibGVgcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZWRFbnRpdGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoaWxkIGBTY29wZWBzIGZvciBpbW1lZGlhdGVseSBuZXN0ZWQgYFRlbXBsYXRlYHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkU2NvcGVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGF0aWMgbmV3Um9vdFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNjb3BlKG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgdGVtcGxhdGUgKGVpdGhlciBhcyBhIGBUZW1wbGF0ZWAgc3ViLXRlbXBsYXRlIHdpdGggdmFyaWFibGVzLCBvciBhIHBsYWluIGFycmF5IG9mXG4gICAgICogdGVtcGxhdGUgYE5vZGVgcykgYW5kIGNvbnN0cnVjdCBpdHMgYFNjb3BlYC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHkodGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBTY29wZS5uZXdSb290U2NvcGUoKTtcbiAgICAgICAgc2NvcGUuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gcHJvY2VzcyB0aGUgdGVtcGxhdGUgYW5kIHBvcHVsYXRlIHRoZSBgU2NvcGVgLlxuICAgICAqL1xuICAgIGluZ2VzdCh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gVmFyaWFibGVzIG9uIGFuIDxuZy10ZW1wbGF0ZT4gYXJlIGRlZmluZWQgaW4gdGhlIGlubmVyIHNjb3BlLlxuICAgICAgICAgICAgdGVtcGxhdGUudmFyaWFibGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLnZpc2l0VmFyaWFibGUobm9kZSkpO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgbm9kZXMgb2YgdGhlIHRlbXBsYXRlLlxuICAgICAgICAgICAgdGVtcGxhdGUuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gb3ZlcmFyY2hpbmcgYFRlbXBsYXRlYCBpbnN0YW5jZSwgc28gcHJvY2VzcyB0aGUgbm9kZXMgZGlyZWN0bHkuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKG5vZGUgPT4gbm9kZS52aXNpdCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gYEVsZW1lbnRgcyBpbiB0aGUgdGVtcGxhdGUgbWF5IGhhdmUgYFJlZmVyZW5jZWBzIHdoaWNoIGFyZSBjYXB0dXJlZCBpbiB0aGUgc2NvcGUuXG4gICAgICAgIGVsZW1lbnQucmVmZXJlbmNlcy5mb3JFYWNoKG5vZGUgPT4gdGhpcy52aXNpdFJlZmVyZW5jZShub2RlKSk7XG4gICAgICAgIC8vIFJlY3Vyc2UgaW50byB0aGUgYEVsZW1lbnRgJ3MgY2hpbGRyZW4uXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFJlZmVyZW5jZXMgb24gYSA8bmctdGVtcGxhdGU+IGFyZSBkZWZpbmVkIGluIHRoZSBvdXRlciBzY29wZSwgc28gY2FwdHVyZSB0aGVtIGJlZm9yZVxuICAgICAgICAvLyBwcm9jZXNzaW5nIHRoZSB0ZW1wbGF0ZSdzIGNoaWxkIHNjb3BlLlxuICAgICAgICB0ZW1wbGF0ZS5yZWZlcmVuY2VzLmZvckVhY2gobm9kZSA9PiB0aGlzLnZpc2l0UmVmZXJlbmNlKG5vZGUpKTtcbiAgICAgICAgLy8gTmV4dCwgY3JlYXRlIGFuIGlubmVyIHNjb3BlIGFuZCBwcm9jZXNzIHRoZSB0ZW1wbGF0ZSB3aXRoaW4gaXQuXG4gICAgICAgIGNvbnN0IHNjb3BlID0gbmV3IFNjb3BlKHRoaXMsIHRlbXBsYXRlKTtcbiAgICAgICAgc2NvcGUuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5jaGlsZFNjb3Blcy5zZXQodGVtcGxhdGUsIHNjb3BlKTtcbiAgICB9XG4gICAgdmlzaXRWYXJpYWJsZSh2YXJpYWJsZSkge1xuICAgICAgICAvLyBEZWNsYXJlIHRoZSB2YXJpYWJsZSBpZiBpdCdzIG5vdCBhbHJlYWR5LlxuICAgICAgICB0aGlzLm1heWJlRGVjbGFyZSh2YXJpYWJsZSk7XG4gICAgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgICAgICAvLyBEZWNsYXJlIHRoZSB2YXJpYWJsZSBpZiBpdCdzIG5vdCBhbHJlYWR5LlxuICAgICAgICB0aGlzLm1heWJlRGVjbGFyZShyZWZlcmVuY2UpO1xuICAgIH1cbiAgICAvLyBVbnVzZWQgdmlzaXRvcnMuXG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cikgeyB9XG4gICAgdmlzaXRCb3VuZEV2ZW50KGV2ZW50KSB7IH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRUZXh0QXR0cmlidXRlKGF0dHIpIHsgfVxuICAgIHZpc2l0SWN1KGljdSkgeyB9XG4gICAgbWF5YmVEZWNsYXJlKHRoaW5nKSB7XG4gICAgICAgIC8vIERlY2xhcmUgc29tZXRoaW5nIHdpdGggYSBuYW1lLCBhcyBsb25nIGFzIHRoYXQgbmFtZSBpc24ndCB0YWtlbi5cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkRW50aXRpZXMuaGFzKHRoaW5nLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVkRW50aXRpZXMuc2V0KHRoaW5nLm5hbWUsIHRoaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rIHVwIGEgdmFyaWFibGUgd2l0aGluIHRoaXMgYFNjb3BlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIHJlY3Vyc2UgaW50byBhIHBhcmVudCBgU2NvcGVgIGlmIGl0J3MgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIGxvb2t1cChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVkRW50aXRpZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBpbiB0aGUgbG9jYWwgc2NvcGUuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZEVudGl0aWVzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBhcmVudFNjb3BlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOb3QgaW4gdGhlIGxvY2FsIHNjb3BlLCBidXQgdGhlcmUncyBhIHBhcmVudCBzY29wZSBzbyBjaGVjayB0aGVyZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjb3BlLmxvb2t1cChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF0IHRoZSB0b3AgbGV2ZWwgYW5kIGl0IHdhc24ndCBmb3VuZC5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hpbGQgc2NvcGUgZm9yIGEgYFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSBkZWZpbmVkLlxuICAgICAqL1xuICAgIGdldENoaWxkU2NvcGUodGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5jaGlsZFNjb3Blcy5nZXQodGVtcGxhdGUpO1xuICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXJ0aW9uIGVycm9yOiBjaGlsZCBzY29wZSBmb3IgJHt0ZW1wbGF0ZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vKipcbiAqIFByb2Nlc3NlcyBhIHRlbXBsYXRlIGFuZCBtYXRjaGVzIGRpcmVjdGl2ZXMgb24gbm9kZXMgKGVsZW1lbnRzIGFuZCB0ZW1wbGF0ZXMpLlxuICpcbiAqIFVzdWFsbHkgdXNlZCB2aWEgdGhlIHN0YXRpYyBgYXBwbHkoKWAgbWV0aG9kLlxuICovXG5jbGFzcyBEaXJlY3RpdmVCaW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKG1hdGNoZXIsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzKSB7XG4gICAgICAgIHRoaXMubWF0Y2hlciA9IG1hdGNoZXI7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHRlbXBsYXRlIChsaXN0IG9mIGBOb2RlYHMpIGFuZCBwZXJmb3JtIGRpcmVjdGl2ZSBtYXRjaGluZyBhZ2FpbnN0IGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSB0aGUgbGlzdCBvZiB0ZW1wbGF0ZSBgTm9kZWBzIHRvIG1hdGNoIChyZWN1cnNpdmVseSkuXG4gICAgICogQHBhcmFtIHNlbGVjdG9yTWF0Y2hlciBhIGBTZWxlY3Rvck1hdGNoZXJgIGNvbnRhaW5pbmcgdGhlIGRpcmVjdGl2ZXMgdGhhdCBhcmUgaW4gc2NvcGUgZm9yXG4gICAgICogdGhpcyB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJucyB0aHJlZSBtYXBzIHdoaWNoIGNvbnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgZGlyZWN0aXZlcyBpbiB0aGUgdGVtcGxhdGU6IHRoZVxuICAgICAqIGBkaXJlY3RpdmVzYCBtYXAgd2hpY2ggbGlzdHMgZGlyZWN0aXZlcyBtYXRjaGVkIG9uIGVhY2ggbm9kZSwgdGhlIGBiaW5kaW5nc2AgbWFwIHdoaWNoXG4gICAgICogaW5kaWNhdGVzIHdoaWNoIGRpcmVjdGl2ZXMgY2xhaW1lZCB3aGljaCBiaW5kaW5ncyAoaW5wdXRzLCBvdXRwdXRzLCBldGMpLCBhbmQgdGhlIGByZWZlcmVuY2VzYFxuICAgICAqIG1hcCB3aGljaCByZXNvbHZlcyAjcmVmZXJlbmNlcyAoYFJlZmVyZW5jZWBzKSB3aXRoaW4gdGhlIHRlbXBsYXRlIHRvIHRoZSBuYW1lZCBkaXJlY3RpdmUgb3JcbiAgICAgKiB0ZW1wbGF0ZSBub2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseSh0ZW1wbGF0ZSwgc2VsZWN0b3JNYXRjaGVyKSB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBtYXRjaGVyID0gbmV3IERpcmVjdGl2ZUJpbmRlcihzZWxlY3Rvck1hdGNoZXIsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzKTtcbiAgICAgICAgbWF0Y2hlci5pbmdlc3QodGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4geyBkaXJlY3RpdmVzLCBiaW5kaW5ncywgcmVmZXJlbmNlcyB9O1xuICAgIH1cbiAgICBpbmdlc3QodGVtcGxhdGUpIHtcbiAgICAgICAgdGVtcGxhdGUuZm9yRWFjaChub2RlID0+IG5vZGUudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoZWxlbWVudC5uYW1lLCBlbGVtZW50KTtcbiAgICB9XG4gICAgdmlzaXRUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnZpc2l0RWxlbWVudE9yVGVtcGxhdGUoJ25nLXRlbXBsYXRlJywgdGVtcGxhdGUpO1xuICAgIH1cbiAgICB2aXNpdEVsZW1lbnRPclRlbXBsYXRlKGVsZW1lbnROYW1lLCBub2RlKSB7XG4gICAgICAgIC8vIEZpcnN0LCBkZXRlcm1pbmUgdGhlIEhUTUwgc2hhcGUgb2YgdGhlIG5vZGUgZm9yIHRoZSBwdXJwb3NlIG9mIGRpcmVjdGl2ZSBtYXRjaGluZy5cbiAgICAgICAgLy8gRG8gdGhpcyBieSBidWlsZGluZyB1cCBhIGBDc3NTZWxlY3RvcmAgZm9yIHRoZSBub2RlLlxuICAgICAgICBjb25zdCBjc3NTZWxlY3RvciA9IGNyZWF0ZUNzc1NlbGVjdG9yKGVsZW1lbnROYW1lLCBnZXRBdHRyc0ZvckRpcmVjdGl2ZU1hdGNoaW5nKG5vZGUpKTtcbiAgICAgICAgLy8gTmV4dCwgdXNlIHRoZSBgU2VsZWN0b3JNYXRjaGVyYCB0byBnZXQgdGhlIGxpc3Qgb2YgZGlyZWN0aXZlcyBvbiB0aGUgbm9kZS5cbiAgICAgICAgY29uc3QgZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIubWF0Y2goY3NzU2VsZWN0b3IsIChfc2VsZWN0b3IsIHJlc3VsdHMpID0+IGRpcmVjdGl2ZXMucHVzaCguLi5yZXN1bHRzKSk7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5zZXQobm9kZSwgZGlyZWN0aXZlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSBhbnkgcmVmZXJlbmNlcyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgbm9kZS5cbiAgICAgICAgbm9kZS5yZWZlcmVuY2VzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgICAgIGxldCBkaXJUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBleHByZXNzaW9uIGlzIGVtcHR5LCB0aGVuIGl0IG1hdGNoZXMgdGhlIFwicHJpbWFyeVwiIGRpcmVjdGl2ZSBvbiB0aGUgbm9kZVxuICAgICAgICAgICAgLy8gKGlmIHRoZXJlIGlzIG9uZSkuIE90aGVyd2lzZSBpdCBtYXRjaGVzIHRoZSBob3N0IG5vZGUgaXRzZWxmIChlaXRoZXIgYW4gZWxlbWVudCBvclxuICAgICAgICAgICAgLy8gPG5nLXRlbXBsYXRlPiBub2RlKS5cbiAgICAgICAgICAgIGlmIChyZWYudmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgYSByZWZlcmVuY2UgdG8gYSBjb21wb25lbnQgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgICAgICAgIGRpclRhcmdldCA9IGRpcmVjdGl2ZXMuZmluZChkaXIgPT4gZGlyLmlzQ29tcG9uZW50KSB8fCBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYSByZWZlcmVuY2UgdG8gYSBkaXJlY3RpdmUgZXhwb3J0ZWQgdmlhIGV4cG9ydEFzLlxuICAgICAgICAgICAgICAgIGRpclRhcmdldCA9XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXMuZmluZChkaXIgPT4gZGlyLmV4cG9ydEFzICE9PSBudWxsICYmIGRpci5leHBvcnRBcy5zb21lKHZhbHVlID0+IHZhbHVlID09PSByZWYudmFsdWUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIG1hdGNoaW5nIGRpcmVjdGl2ZSB3YXMgZm91bmQuXG4gICAgICAgICAgICAgICAgaWYgKGRpclRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBtYXRjaGluZyBkaXJlY3RpdmUgd2FzIGZvdW5kIC0gdGhpcyByZWZlcmVuY2UgcG9pbnRzIHRvIGFuIHVua25vd24gdGFyZ2V0LiBMZWF2ZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyB1bm1hcHBlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlZmVyZW5jZSBwb2ludHMgdG8gYSBkaXJlY3RpdmUuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VzLnNldChyZWYsIHsgZGlyZWN0aXZlOiBkaXJUYXJnZXQsIG5vZGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlZmVyZW5jZSBwb2ludHMgdG8gdGhlIG5vZGUgaXRzZWxmLlxuICAgICAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlcy5zZXQocmVmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNldEF0dHJpYnV0ZUJpbmRpbmcgPSAoYXR0cmlidXRlLCBpb1R5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IGRpcmVjdGl2ZXMuZmluZChkaXIgPT4gZGlyW2lvVHlwZV0uaGFzQmluZGluZ1Byb3BlcnR5TmFtZShhdHRyaWJ1dGUubmFtZSkpO1xuICAgICAgICAgICAgY29uc3QgYmluZGluZyA9IGRpciAhPT0gdW5kZWZpbmVkID8gZGlyIDogbm9kZTtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3Muc2V0KGF0dHJpYnV0ZSwgYmluZGluZyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vZGUgaW5wdXRzIChib3VuZCBhdHRyaWJ1dGVzKSBhbmQgdGV4dCBhdHRyaWJ1dGVzIGNhbiBiZSBib3VuZCB0byBhblxuICAgICAgICAvLyBpbnB1dCBvbiBhIGRpcmVjdGl2ZS5cbiAgICAgICAgbm9kZS5pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGlucHV0LCAnaW5wdXRzJykpO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHNldEF0dHJpYnV0ZUJpbmRpbmcoYXR0ciwgJ2lucHV0cycpKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgbm9kZS50ZW1wbGF0ZUF0dHJzLmZvckVhY2goYXR0ciA9PiBzZXRBdHRyaWJ1dGVCaW5kaW5nKGF0dHIsICdpbnB1dHMnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9kZSBvdXRwdXRzIChib3VuZCBldmVudHMpIGNhbiBiZSBib3VuZCB0byBhbiBvdXRwdXQgb24gYSBkaXJlY3RpdmUuXG4gICAgICAgIG5vZGUub3V0cHV0cy5mb3JFYWNoKG91dHB1dCA9PiBzZXRBdHRyaWJ1dGVCaW5kaW5nKG91dHB1dCwgJ291dHB1dHMnKSk7XG4gICAgICAgIC8vIFJlY3Vyc2UgaW50byB0aGUgbm9kZSdzIGNoaWxkcmVuLlxuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQudmlzaXQodGhpcykpO1xuICAgIH1cbiAgICAvLyBVbnVzZWQgdmlzaXRvcnMuXG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHsgfVxuICAgIHZpc2l0VmFyaWFibGUodmFyaWFibGUpIHsgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkgeyB9XG4gICAgdmlzaXRUZXh0QXR0cmlidXRlKGF0dHJpYnV0ZSkgeyB9XG4gICAgdmlzaXRCb3VuZEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRFdmVudChhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGVPckV2ZW50KG5vZGUpIHsgfVxuICAgIHZpc2l0VGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEJvdW5kVGV4dCh0ZXh0KSB7IH1cbiAgICB2aXNpdEljdShpY3UpIHsgfVxufVxuLyoqXG4gKiBQcm9jZXNzZXMgYSB0ZW1wbGF0ZSBhbmQgZXh0cmFjdCBtZXRhZGF0YSBhYm91dCBleHByZXNzaW9ucyBhbmQgc3ltYm9scyB3aXRoaW4uXG4gKlxuICogVGhpcyBpcyBhIGNvbXBhbmlvbiB0byB0aGUgYERpcmVjdGl2ZUJpbmRlcmAgdGhhdCBkb2Vzbid0IHJlcXVpcmUga25vd2xlZGdlIG9mIGRpcmVjdGl2ZXMgbWF0Y2hlZFxuICogd2l0aGluIHRoZSB0ZW1wbGF0ZSBpbiBvcmRlciB0byBvcGVyYXRlLlxuICpcbiAqIEV4cHJlc3Npb25zIGFyZSB2aXNpdGVkIGJ5IHRoZSBzdXBlcmNsYXNzIGBSZWN1cnNpdmVBc3RWaXNpdG9yYCwgd2l0aCBjdXN0b20gbG9naWMgcHJvdmlkZWRcbiAqIGJ5IG92ZXJyaWRkZW4gbWV0aG9kcyBmcm9tIHRoYXQgdmlzaXRvci5cbiAqL1xuY2xhc3MgVGVtcGxhdGVCaW5kZXIgZXh0ZW5kcyBSZWN1cnNpdmVBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5ncywgc3ltYm9scywgdXNlZFBpcGVzLCBuZXN0aW5nTGV2ZWwsIHNjb3BlLCB0ZW1wbGF0ZSwgbGV2ZWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzO1xuICAgICAgICB0aGlzLnVzZWRQaXBlcyA9IHVzZWRQaXBlcztcbiAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwgPSBuZXN0aW5nTGV2ZWw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIC8vIFNhdmUgYSBiaXQgb2YgcHJvY2Vzc2luZyB0aW1lIGJ5IGNvbnN0cnVjdGluZyB0aGlzIGNsb3N1cmUgaW4gYWR2YW5jZS5cbiAgICAgICAgdGhpcy52aXNpdE5vZGUgPSAobm9kZSkgPT4gbm9kZS52aXNpdCh0aGlzKTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgZGVmaW5lZCB0byByZWNvbmNpbGUgdGhlIHR5cGUgb2YgVGVtcGxhdGVCaW5kZXIgc2luY2UgYm90aFxuICAgIC8vIFJlY3Vyc2l2ZUFzdFZpc2l0b3IgYW5kIFZpc2l0b3IgZGVmaW5lIHRoZSB2aXNpdCgpIG1ldGhvZCBpbiB0aGVpclxuICAgIC8vIGludGVyZmFjZXMuXG4gICAgdmlzaXQobm9kZSwgY29udGV4dCkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVCkge1xuICAgICAgICAgICAgbm9kZS52aXNpdCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUudmlzaXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHRlbXBsYXRlIGFuZCBleHRyYWN0IG1ldGFkYXRhIGFib3V0IGV4cHJlc3Npb25zIGFuZCBzeW1ib2xzIHdpdGhpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZW1wbGF0ZSB0aGUgbm9kZXMgb2YgdGhlIHRlbXBsYXRlIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gc2NvcGUgdGhlIGBTY29wZWAgb2YgdGhlIHRlbXBsYXRlIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgKiBAcmV0dXJucyB0aHJlZSBtYXBzIHdoaWNoIGNvbnRhaW4gbWV0YWRhdGEgYWJvdXQgdGhlIHRlbXBsYXRlOiBgZXhwcmVzc2lvbnNgIHdoaWNoIGludGVycHJldHNcbiAgICAgKiBzcGVjaWFsIGBBU1RgIG5vZGVzIGluIGV4cHJlc3Npb25zIGFzIHBvaW50aW5nIHRvIHJlZmVyZW5jZXMgb3IgdmFyaWFibGVzIGRlY2xhcmVkIHdpdGhpbiB0aGVcbiAgICAgKiB0ZW1wbGF0ZSwgYHN5bWJvbHNgIHdoaWNoIG1hcHMgdGhvc2UgdmFyaWFibGVzIGFuZCByZWZlcmVuY2VzIHRvIHRoZSBuZXN0ZWQgYFRlbXBsYXRlYCB3aGljaFxuICAgICAqIGRlY2xhcmVzIHRoZW0sIGlmIGFueSwgYW5kIGBuZXN0aW5nTGV2ZWxgIHdoaWNoIGFzc29jaWF0ZXMgZWFjaCBgVGVtcGxhdGVgIHdpdGggYSBpbnRlZ2VyXG4gICAgICogbmVzdGluZyBsZXZlbCAoaG93IG1hbnkgbGV2ZWxzIGRlZXAgd2l0aGluIHRoZSB0ZW1wbGF0ZSBzdHJ1Y3R1cmUgdGhlIGBUZW1wbGF0ZWAgaXMpLCBzdGFydGluZ1xuICAgICAqIGF0IDEuXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5V2l0aFNjb3BlKHRlbXBsYXRlLCBzY29wZSkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3Qgc3ltYm9scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgbmVzdGluZ0xldmVsID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCB1c2VkUGlwZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIFRoZSB0b3AtbGV2ZWwgdGVtcGxhdGUgaGFzIG5lc3RpbmcgbGV2ZWwgMC5cbiAgICAgICAgY29uc3QgYmluZGVyID0gbmV3IFRlbXBsYXRlQmluZGVyKGV4cHJlc3Npb25zLCBzeW1ib2xzLCB1c2VkUGlwZXMsIG5lc3RpbmdMZXZlbCwgc2NvcGUsIHRlbXBsYXRlIGluc3RhbmNlb2YgVGVtcGxhdGUgPyB0ZW1wbGF0ZSA6IG51bGwsIDApO1xuICAgICAgICBiaW5kZXIuaW5nZXN0KHRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHsgZXhwcmVzc2lvbnMsIHN5bWJvbHMsIG5lc3RpbmdMZXZlbCwgdXNlZFBpcGVzIH07XG4gICAgfVxuICAgIGluZ2VzdCh0ZW1wbGF0ZSkge1xuICAgICAgICBpZiAodGVtcGxhdGUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgLy8gRm9yIDxuZy10ZW1wbGF0ZT5zLCBwcm9jZXNzIG9ubHkgdmFyaWFibGVzIGFuZCBjaGlsZCBub2Rlcy4gSW5wdXRzLCBvdXRwdXRzLCB0ZW1wbGF0ZUF0dHJzLFxuICAgICAgICAgICAgLy8gYW5kIHJlZmVyZW5jZXMgd2VyZSBhbGwgcHJvY2Vzc2VkIGluIHRoZSBzY29wZSBvZiB0aGUgY29udGFpbmluZyB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIHRlbXBsYXRlLnZhcmlhYmxlcy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgICAgIHRlbXBsYXRlLmNoaWxkcmVuLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXN0aW5nIGxldmVsLlxuICAgICAgICAgICAgdGhpcy5uZXN0aW5nTGV2ZWwuc2V0KHRlbXBsYXRlLCB0aGlzLmxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFZpc2l0IGVhY2ggbm9kZSBmcm9tIHRoZSB0b3AtbGV2ZWwgdGVtcGxhdGUuXG4gICAgICAgICAgICB0ZW1wbGF0ZS5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBWaXNpdCB0aGUgaW5wdXRzLCBvdXRwdXRzLCBhbmQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQuXG4gICAgICAgIGVsZW1lbnQuaW5wdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICBlbGVtZW50Lm91dHB1dHMuZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4uZm9yRWFjaCh0aGlzLnZpc2l0Tm9kZSk7XG4gICAgfVxuICAgIHZpc2l0VGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgICAgLy8gRmlyc3QsIHZpc2l0IGlucHV0cywgb3V0cHV0cyBhbmQgdGVtcGxhdGUgYXR0cmlidXRlcyBvZiB0aGUgdGVtcGxhdGUgbm9kZS5cbiAgICAgICAgdGVtcGxhdGUuaW5wdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICB0ZW1wbGF0ZS5vdXRwdXRzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICB0ZW1wbGF0ZS50ZW1wbGF0ZUF0dHJzLmZvckVhY2godGhpcy52aXNpdE5vZGUpO1xuICAgICAgICAvLyBSZWZlcmVuY2VzIGFyZSBhbHNvIGV2YWx1YXRlZCBpbiB0aGUgb3V0ZXIgY29udGV4dC5cbiAgICAgICAgdGVtcGxhdGUucmVmZXJlbmNlcy5mb3JFYWNoKHRoaXMudmlzaXROb2RlKTtcbiAgICAgICAgLy8gTmV4dCwgcmVjdXJzZSBpbnRvIHRoZSB0ZW1wbGF0ZSB1c2luZyBpdHMgc2NvcGUsIGFuZCBidW1waW5nIHRoZSBuZXN0aW5nIGxldmVsIHVwIGJ5IG9uZS5cbiAgICAgICAgY29uc3QgY2hpbGRTY29wZSA9IHRoaXMuc2NvcGUuZ2V0Q2hpbGRTY29wZSh0ZW1wbGF0ZSk7XG4gICAgICAgIGNvbnN0IGJpbmRlciA9IG5ldyBUZW1wbGF0ZUJpbmRlcih0aGlzLmJpbmRpbmdzLCB0aGlzLnN5bWJvbHMsIHRoaXMudXNlZFBpcGVzLCB0aGlzLm5lc3RpbmdMZXZlbCwgY2hpbGRTY29wZSwgdGVtcGxhdGUsIHRoaXMubGV2ZWwgKyAxKTtcbiAgICAgICAgYmluZGVyLmluZ2VzdCh0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHZpc2l0VmFyaWFibGUodmFyaWFibGUpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGBWYXJpYWJsZWAgYXMgYSBzeW1ib2wgaW4gdGhlIGN1cnJlbnQgYFRlbXBsYXRlYC5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9scy5zZXQodmFyaWFibGUsIHRoaXMudGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0UmVmZXJlbmNlKHJlZmVyZW5jZSkge1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgYFJlZmVyZW5jZWAgYXMgYSBzeW1ib2wgaW4gdGhlIGN1cnJlbnQgYFRlbXBsYXRlYC5cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltYm9scy5zZXQocmVmZXJlbmNlLCB0aGlzLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVbnVzZWQgdGVtcGxhdGUgdmlzaXRvcnNcbiAgICB2aXNpdFRleHQodGV4dCkgeyB9XG4gICAgdmlzaXRDb250ZW50KGNvbnRlbnQpIHsgfVxuICAgIHZpc2l0VGV4dEF0dHJpYnV0ZShhdHRyaWJ1dGUpIHsgfVxuICAgIHZpc2l0SWN1KGljdSkge1xuICAgICAgICBPYmplY3Qua2V5cyhpY3UudmFycykuZm9yRWFjaChrZXkgPT4gaWN1LnZhcnNba2V5XS52aXNpdCh0aGlzKSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGljdS5wbGFjZWhvbGRlcnMpLmZvckVhY2goa2V5ID0+IGljdS5wbGFjZWhvbGRlcnNba2V5XS52aXNpdCh0aGlzKSk7XG4gICAgfVxuICAgIC8vIFRoZSByZW1haW5pbmcgdmlzaXRvcnMgYXJlIGNvbmNlcm5lZCB3aXRoIHByb2Nlc3NpbmcgQVNUIGV4cHJlc3Npb25zIHdpdGhpbiB0ZW1wbGF0ZSBiaW5kaW5nc1xuICAgIHZpc2l0Qm91bmRBdHRyaWJ1dGUoYXR0cmlidXRlKSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICB9XG4gICAgdmlzaXRCb3VuZEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmhhbmRsZXIudmlzaXQodGhpcyk7XG4gICAgfVxuICAgIHZpc2l0Qm91bmRUZXh0KHRleHQpIHtcbiAgICAgICAgdGV4dC52YWx1ZS52aXNpdCh0aGlzKTtcbiAgICB9XG4gICAgdmlzaXRQaXBlKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnVzZWRQaXBlcy5hZGQoYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gc3VwZXIudmlzaXRQaXBlKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIFRoZXNlIGZpdmUgdHlwZXMgb2YgQVNUIGV4cHJlc3Npb25zIGNhbiByZWZlciB0byBleHByZXNzaW9uIHJvb3RzLCB3aGljaCBjb3VsZCBiZSB2YXJpYWJsZXNcbiAgICAvLyBvciByZWZlcmVuY2VzIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICAgIHZpc2l0UHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gc3VwZXIudmlzaXRQcm9wZXJ0eVJlYWQoYXN0LCBjb250ZXh0KTtcbiAgICB9XG4gICAgdmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCkge1xuICAgICAgICB0aGlzLm1heWJlTWFwKGNvbnRleHQsIGFzdCwgYXN0Lm5hbWUpO1xuICAgICAgICByZXR1cm4gc3VwZXIudmlzaXRTYWZlUHJvcGVydHlSZWFkKGFzdCwgY29udGV4dCk7XG4gICAgfVxuICAgIHZpc2l0UHJvcGVydHlXcml0ZShhc3QsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tYXliZU1hcChjb250ZXh0LCBhc3QsIGFzdC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnZpc2l0UHJvcGVydHlXcml0ZShhc3QsIGNvbnRleHQpO1xuICAgIH1cbiAgICBtYXliZU1hcChzY29wZSwgYXN0LCBuYW1lKSB7XG4gICAgICAgIC8vIElmIHRoZSByZWNlaXZlciBvZiB0aGUgZXhwcmVzc2lvbiBpc24ndCB0aGUgYEltcGxpY2l0UmVjZWl2ZXJgLCB0aGlzIGlzbid0IHRoZSByb290IG9mIGFuXG4gICAgICAgIC8vIGBBU1RgIGV4cHJlc3Npb24gdGhhdCBtYXBzIHRvIGEgYFZhcmlhYmxlYCBvciBgUmVmZXJlbmNlYC5cbiAgICAgICAgaWYgKCEoYXN0LnJlY2VpdmVyIGluc3RhbmNlb2YgSW1wbGljaXRSZWNlaXZlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBuYW1lIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY29wZS4gSWYgc28sIG1hcCBpdC4gT3RoZXJ3aXNlLCB0aGUgbmFtZSBpc1xuICAgICAgICAvLyBwcm9iYWJseSBhIHByb3BlcnR5IG9uIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50IGNvbnRleHQuXG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnNjb3BlLmxvb2t1cChuYW1lKTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5zZXQoYXN0LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBNZXRhZGF0YSBjb250YWluZXIgZm9yIGEgYFRhcmdldGAgdGhhdCBhbGxvd3MgcXVlcmllcyBmb3Igc3BlY2lmaWMgYml0cyBvZiBtZXRhZGF0YS5cbiAqXG4gKiBTZWUgYEJvdW5kVGFyZ2V0YCBmb3IgZG9jdW1lbnRhdGlvbiBvbiB0aGUgaW5kaXZpZHVhbCBtZXRob2RzLlxuICovXG5jbGFzcyBSM0JvdW5kVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGRpcmVjdGl2ZXMsIGJpbmRpbmdzLCByZWZlcmVuY2VzLCBleHByVGFyZ2V0cywgc3ltYm9scywgbmVzdGluZ0xldmVsLCB0ZW1wbGF0ZUVudGl0aWVzLCB1c2VkUGlwZXMpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXM7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gcmVmZXJlbmNlcztcbiAgICAgICAgdGhpcy5leHByVGFyZ2V0cyA9IGV4cHJUYXJnZXRzO1xuICAgICAgICB0aGlzLnN5bWJvbHMgPSBzeW1ib2xzO1xuICAgICAgICB0aGlzLm5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbDtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZUVudGl0aWVzID0gdGVtcGxhdGVFbnRpdGllcztcbiAgICAgICAgdGhpcy51c2VkUGlwZXMgPSB1c2VkUGlwZXM7XG4gICAgfVxuICAgIGdldEVudGl0aWVzSW5UZW1wbGF0ZVNjb3BlKHRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlRW50aXRpZXMuZ2V0KHRlbXBsYXRlKSA/PyBuZXcgU2V0KCk7XG4gICAgfVxuICAgIGdldERpcmVjdGl2ZXNPZk5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3RpdmVzLmdldChub2RlKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXRSZWZlcmVuY2VUYXJnZXQocmVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZXMuZ2V0KHJlZikgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0Q29uc3VtZXJPZkJpbmRpbmcoYmluZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5iaW5kaW5ncy5nZXQoYmluZGluZykgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0RXhwcmVzc2lvblRhcmdldChleHByKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJUYXJnZXRzLmdldChleHByKSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXRUZW1wbGF0ZU9mU3ltYm9sKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xzLmdldChzeW1ib2wpIHx8IG51bGw7XG4gICAgfVxuICAgIGdldE5lc3RpbmdMZXZlbCh0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXN0aW5nTGV2ZWwuZ2V0KHRlbXBsYXRlKSB8fCAwO1xuICAgIH1cbiAgICBnZXRVc2VkRGlyZWN0aXZlcygpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChkaXJzID0+IGRpcnMuZm9yRWFjaChkaXIgPT4gc2V0LmFkZChkaXIpKSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNldC52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGdldFVzZWRQaXBlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy51c2VkUGlwZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RUZW1wbGF0ZUVudGl0aWVzKHJvb3RTY29wZSkge1xuICAgIGNvbnN0IGVudGl0eU1hcCA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBleHRyYWN0U2NvcGVFbnRpdGllcyhzY29wZSkge1xuICAgICAgICBpZiAoZW50aXR5TWFwLmhhcyhzY29wZS50ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHlNYXAuZ2V0KHNjb3BlLnRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50RW50aXRpZXMgPSBzY29wZS5uYW1lZEVudGl0aWVzO1xuICAgICAgICBsZXQgdGVtcGxhdGVFbnRpdGllcztcbiAgICAgICAgaWYgKHNjb3BlLnBhcmVudFNjb3BlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVudGl0aWVzID0gbmV3IE1hcChbLi4uZXh0cmFjdFNjb3BlRW50aXRpZXMoc2NvcGUucGFyZW50U2NvcGUpLCAuLi5jdXJyZW50RW50aXRpZXNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlRW50aXRpZXMgPSBuZXcgTWFwKGN1cnJlbnRFbnRpdGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW50aXR5TWFwLnNldChzY29wZS50ZW1wbGF0ZSwgdGVtcGxhdGVFbnRpdGllcyk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZUVudGl0aWVzO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXNUb1Byb2Nlc3MgPSBbcm9vdFNjb3BlXTtcbiAgICB3aGlsZSAoc2NvcGVzVG9Qcm9jZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSBzY29wZXNUb1Byb2Nlc3MucG9wKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGRTY29wZSBvZiBzY29wZS5jaGlsZFNjb3Blcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc2NvcGVzVG9Qcm9jZXNzLnB1c2goY2hpbGRTY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0cmFjdFNjb3BlRW50aXRpZXMoc2NvcGUpO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZUVudGl0aWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW3RlbXBsYXRlLCBlbnRpdGllc10gb2YgZW50aXR5TWFwKSB7XG4gICAgICAgIHRlbXBsYXRlRW50aXRpZXMuc2V0KHRlbXBsYXRlLCBuZXcgU2V0KGVudGl0aWVzLnZhbHVlcygpKSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZUVudGl0aWVzO1xufVxuXG5mdW5jdGlvbiBjb21waWxlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIC8vIEdlbmVyYXRlIGFuIG5nRGV2TW9kZSBndWFyZGVkIGNhbGwgdG8gc2V0Q2xhc3NNZXRhZGF0YSB3aXRoIHRoZSBjbGFzcyBpZGVudGlmaWVyIGFuZCBpdHNcbiAgICAvLyBtZXRhZGF0YS5cbiAgICBjb25zdCBmbkNhbGwgPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLnNldENsYXNzTWV0YWRhdGEpLmNhbGxGbihbXG4gICAgICAgIG1ldGFkYXRhLnR5cGUsXG4gICAgICAgIG1ldGFkYXRhLmRlY29yYXRvcnMsXG4gICAgICAgIG1ldGFkYXRhLmN0b3JQYXJhbWV0ZXJzID8/IGxpdGVyYWwobnVsbCksXG4gICAgICAgIG1ldGFkYXRhLnByb3BEZWNvcmF0b3JzID8/IGxpdGVyYWwobnVsbCksXG4gICAgXSk7XG4gICAgY29uc3QgaWlmZSA9IGZuKFtdLCBbZGV2T25seUd1YXJkZWRFeHByZXNzaW9uKGZuQ2FsbCkudG9TdG10KCldKTtcbiAgICByZXR1cm4gaWlmZS5jYWxsRm4oW10pO1xufVxuXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDYgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlQ2xhc3NNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTUuMi43JykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY29yZSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YWRhdGEudHlwZSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY29yYXRvcnMnLCBtZXRhZGF0YS5kZWNvcmF0b3JzKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnY3RvclBhcmFtZXRlcnMnLCBtZXRhZGF0YS5jdG9yUGFyYW1ldGVycyk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3Byb3BEZWNvcmF0b3JzJywgbWV0YWRhdGEucHJvcERlY29yYXRvcnMpO1xuICAgIHJldHVybiBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlY2xhcmVDbGFzc01ldGFkYXRhKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGxpdGVyYWwgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBhcnJheSwgbWFwcGluZyBhbGwgdmFsdWVzIHRvIGFuIGV4cHJlc3Npb25cbiAqIHVzaW5nIHRoZSBwcm92aWRlZCBtYXBwaW5nIGZ1bmN0aW9uLiBJZiB0aGUgYXJyYXkgaXMgZW1wdHkgb3IgbnVsbCwgdGhlbiBudWxsIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgVGhlIGFycmF5IHRvIHRyYW5zZmVyIGludG8gbGl0ZXJhbCBhcnJheSBleHByZXNzaW9uLlxuICogQHBhcmFtIG1hcHBlciBUaGUgbG9naWMgdG8gdXNlIGZvciBjcmVhdGluZyBhbiBleHByZXNzaW9uIGZvciB0aGUgYXJyYXkncyB2YWx1ZXMuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBsaXRlcmFsIGV4cHJlc3Npb24gcmVwcmVzZW50aW5nIGB2YWx1ZXNgLCBvciBudWxsIGlmIGB2YWx1ZXNgIGlzIGVtcHR5IG9yXG4gKiBpcyBpdHNlbGYgbnVsbC5cbiAqL1xuZnVuY3Rpb24gdG9PcHRpb25hbExpdGVyYWxBcnJheSh2YWx1ZXMsIG1hcHBlcikge1xuICAgIGlmICh2YWx1ZXMgPT09IG51bGwgfHwgdmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGxpdGVyYWxBcnIodmFsdWVzLm1hcCh2YWx1ZSA9PiBtYXBwZXIodmFsdWUpKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGxpdGVyYWwgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiBvYmplY3QsIG1hcHBpbmcgYWxsIHZhbHVlcyB0byBhbiBleHByZXNzaW9uXG4gKiB1c2luZyB0aGUgcHJvdmlkZWQgbWFwcGluZyBmdW5jdGlvbi4gSWYgdGhlIG9iamVjdCBoYXMgbm8ga2V5cywgdGhlbiBudWxsIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBvYmplY3QgVGhlIG9iamVjdCB0byB0cmFuc2ZlciBpbnRvIGFuIG9iamVjdCBsaXRlcmFsIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0gbWFwcGVyIFRoZSBsb2dpYyB0byB1c2UgZm9yIGNyZWF0aW5nIGFuIGV4cHJlc3Npb24gZm9yIHRoZSBvYmplY3QncyB2YWx1ZXMuXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgbGl0ZXJhbCBleHByZXNzaW9uIHJlcHJlc2VudGluZyBgb2JqZWN0YCwgb3IgbnVsbCBpZiBgb2JqZWN0YCBkb2VzIG5vdCBoYXZlXG4gKiBhbnkga2V5cy5cbiAqL1xuZnVuY3Rpb24gdG9PcHRpb25hbExpdGVyYWxNYXAob2JqZWN0LCBtYXBwZXIpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgcmV0dXJuIHsga2V5LCB2YWx1ZTogbWFwcGVyKHZhbHVlKSwgcXVvdGVkOiB0cnVlIH07XG4gICAgfSk7XG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcChlbnRyaWVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVEZXBlbmRlbmNpZXMoZGVwcykge1xuICAgIGlmIChkZXBzID09PSAnaW52YWxpZCcpIHtcbiAgICAgICAgLy8gVGhlIGBkZXBzYCBjYW4gYmUgc2V0IHRvIHRoZSBzdHJpbmcgXCJpbnZhbGlkXCIgIGJ5IHRoZSBgdW53cmFwQ29uc3RydWN0b3JEZXBlbmRlbmNpZXMoKWBcbiAgICAgICAgLy8gZnVuY3Rpb24sIHdoaWNoIHRyaWVzIHRvIGNvbnZlcnQgYENvbnN0cnVjdG9yRGVwc2AgaW50byBgUjNEZXBlbmRlbmN5TWV0YWRhdGFbXWAuXG4gICAgICAgIHJldHVybiBsaXRlcmFsKCdpbnZhbGlkJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlcHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwobnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGl0ZXJhbEFycihkZXBzLm1hcChjb21waWxlRGVwZW5kZW5jeSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXBpbGVEZXBlbmRlbmN5KGRlcCkge1xuICAgIGNvbnN0IGRlcE1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlcE1ldGEuc2V0KCd0b2tlbicsIGRlcC50b2tlbik7XG4gICAgaWYgKGRlcC5hdHRyaWJ1dGVOYW1lVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICBkZXBNZXRhLnNldCgnYXR0cmlidXRlJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIGlmIChkZXAuaG9zdCkge1xuICAgICAgICBkZXBNZXRhLnNldCgnaG9zdCcsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAoZGVwLm9wdGlvbmFsKSB7XG4gICAgICAgIGRlcE1ldGEuc2V0KCdvcHRpb25hbCcsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAoZGVwLnNlbGYpIHtcbiAgICAgICAgZGVwTWV0YS5zZXQoJ3NlbGYnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgaWYgKGRlcC5za2lwU2VsZikge1xuICAgICAgICBkZXBNZXRhLnNldCgnc2tpcFNlbGYnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcE1ldGEudG9MaXRlcmFsTWFwKCk7XG59XG5cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNSA9ICcxNC4wLjAnO1xuLyoqXG4gKiBDb21waWxlIGEgZGlyZWN0aXZlIGRlY2xhcmF0aW9uIGRlZmluZWQgYnkgdGhlIGBSM0RpcmVjdGl2ZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVEaXJlY3RpdmVGcm9tTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVEaXJlY3RpdmVEZWZpbml0aW9uTWFwKG1ldGEpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlY2xhcmVEaXJlY3RpdmUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVEaXJlY3RpdmVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBkaXJlY3RpdmUgaW50byBhIGBEZWZpbml0aW9uTWFwYC4gVGhpcyBhbGxvd3MgZm9yIHJldXNpbmdcbiAqIHRoaXMgbG9naWMgZm9yIGNvbXBvbmVudHMsIGFzIHRoZXkgZXh0ZW5kIHRoZSBkaXJlY3RpdmUgbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpcmVjdGl2ZURlZmluaXRpb25NYXAobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdtaW5WZXJzaW9uJywgbGl0ZXJhbChNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04kNSkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTUuMi43JykpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15RGlyZWN0aXZlYFxuICAgIGRlZmluaXRpb25NYXAuc2V0KCd0eXBlJywgbWV0YS5pbnRlcm5hbFR5cGUpO1xuICAgIGlmIChtZXRhLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaXNTdGFuZGFsb25lJywgbGl0ZXJhbChtZXRhLmlzU3RhbmRhbG9uZSkpO1xuICAgIH1cbiAgICAvLyBlLmcuIGBzZWxlY3RvcjogJ3NvbWUtZGlyJ2BcbiAgICBpZiAobWV0YS5zZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2VsZWN0b3InLCBsaXRlcmFsKG1ldGEuc2VsZWN0b3IpKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lucHV0cycsIGNvbmRpdGlvbmFsbHlDcmVhdGVNYXBPYmplY3RMaXRlcmFsKG1ldGEuaW5wdXRzLCB0cnVlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ291dHB1dHMnLCBjb25kaXRpb25hbGx5Q3JlYXRlTWFwT2JqZWN0TGl0ZXJhbChtZXRhLm91dHB1dHMpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnaG9zdCcsIGNvbXBpbGVIb3N0TWV0YWRhdGEobWV0YS5ob3N0KSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3Byb3ZpZGVycycsIG1ldGEucHJvdmlkZXJzKTtcbiAgICBpZiAobWV0YS5xdWVyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3F1ZXJpZXMnLCBsaXRlcmFsQXJyKG1ldGEucXVlcmllcy5tYXAoY29tcGlsZVF1ZXJ5KSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS52aWV3UXVlcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd2aWV3UXVlcmllcycsIGxpdGVyYWxBcnIobWV0YS52aWV3UXVlcmllcy5tYXAoY29tcGlsZVF1ZXJ5KSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5leHBvcnRBcyAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnZXhwb3J0QXMnLCBhc0xpdGVyYWwobWV0YS5leHBvcnRBcykpO1xuICAgIH1cbiAgICBpZiAobWV0YS51c2VzSW5oZXJpdGFuY2UpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZXNJbmhlcml0YW5jZScsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5saWZlY3ljbGUudXNlc09uQ2hhbmdlcykge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndXNlc09uQ2hhbmdlcycsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5ob3N0RGlyZWN0aXZlcz8ubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdob3N0RGlyZWN0aXZlcycsIGNyZWF0ZUhvc3REaXJlY3RpdmVzKG1ldGEuaG9zdERpcmVjdGl2ZXMpKTtcbiAgICB9XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBtZXRhZGF0YSBvZiBhIHNpbmdsZSBxdWVyeSBpbnRvIGl0cyBwYXJ0aWFsIGRlY2xhcmF0aW9uIGZvcm0gYXMgZGVjbGFyZWRcbiAqIGJ5IGBSM0RlY2xhcmVRdWVyeU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgbWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgbWV0YS5zZXQoJ3Byb3BlcnR5TmFtZScsIGxpdGVyYWwocXVlcnkucHJvcGVydHlOYW1lKSk7XG4gICAgaWYgKHF1ZXJ5LmZpcnN0KSB7XG4gICAgICAgIG1ldGEuc2V0KCdmaXJzdCcsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBtZXRhLnNldCgncHJlZGljYXRlJywgQXJyYXkuaXNBcnJheShxdWVyeS5wcmVkaWNhdGUpID8gYXNMaXRlcmFsKHF1ZXJ5LnByZWRpY2F0ZSkgOlxuICAgICAgICBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24ocXVlcnkucHJlZGljYXRlKSk7XG4gICAgaWYgKCFxdWVyeS5lbWl0RGlzdGluY3RDaGFuZ2VzT25seSkge1xuICAgICAgICAvLyBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIGlzIHNwZWNpYWwgYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gYmUgYHRydWVgLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgZXhwbGljaXRseSBlbWl0IHRoZSBmaWVsZCwgYW5kIGV4cGxpY2l0bHkgcGxhY2UgaXQgb25seSB3aGVuIGl0J3MgYGZhbHNlYC5cbiAgICAgICAgbWV0YS5zZXQoJ2VtaXREaXN0aW5jdENoYW5nZXNPbmx5JywgbGl0ZXJhbChmYWxzZSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGxpbmtlciB3aWxsIGFzc3VtZSB0aGF0IGFuIGFic2VudCBgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlgIGZsYWcgaXMgYnkgZGVmYXVsdCBgdHJ1ZWAuXG4gICAgfVxuICAgIGlmIChxdWVyeS5kZXNjZW5kYW50cykge1xuICAgICAgICBtZXRhLnNldCgnZGVzY2VuZGFudHMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgbWV0YS5zZXQoJ3JlYWQnLCBxdWVyeS5yZWFkKTtcbiAgICBpZiAocXVlcnkuc3RhdGljKSB7XG4gICAgICAgIG1ldGEuc2V0KCdzdGF0aWMnLCBsaXRlcmFsKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGEudG9MaXRlcmFsTWFwKCk7XG59XG4vKipcbiAqIENvbXBpbGVzIHRoZSBob3N0IG1ldGFkYXRhIGludG8gaXRzIHBhcnRpYWwgZGVjbGFyYXRpb24gZm9ybSBhcyBkZWNsYXJlZFxuICogaW4gYFIzRGVjbGFyZURpcmVjdGl2ZU1ldGFkYXRhWydob3N0J11gXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVIb3N0TWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGhvc3RNZXRhZGF0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgaG9zdE1ldGFkYXRhLnNldCgnYXR0cmlidXRlcycsIHRvT3B0aW9uYWxMaXRlcmFsTWFwKG1ldGEuYXR0cmlidXRlcywgZXhwcmVzc2lvbiA9PiBleHByZXNzaW9uKSk7XG4gICAgaG9zdE1ldGFkYXRhLnNldCgnbGlzdGVuZXJzJywgdG9PcHRpb25hbExpdGVyYWxNYXAobWV0YS5saXN0ZW5lcnMsIGxpdGVyYWwpKTtcbiAgICBob3N0TWV0YWRhdGEuc2V0KCdwcm9wZXJ0aWVzJywgdG9PcHRpb25hbExpdGVyYWxNYXAobWV0YS5wcm9wZXJ0aWVzLCBsaXRlcmFsKSk7XG4gICAgaWYgKG1ldGEuc3BlY2lhbEF0dHJpYnV0ZXMuc3R5bGVBdHRyKSB7XG4gICAgICAgIGhvc3RNZXRhZGF0YS5zZXQoJ3N0eWxlQXR0cmlidXRlJywgbGl0ZXJhbChtZXRhLnNwZWNpYWxBdHRyaWJ1dGVzLnN0eWxlQXR0cikpO1xuICAgIH1cbiAgICBpZiAobWV0YS5zcGVjaWFsQXR0cmlidXRlcy5jbGFzc0F0dHIpIHtcbiAgICAgICAgaG9zdE1ldGFkYXRhLnNldCgnY2xhc3NBdHRyaWJ1dGUnLCBsaXRlcmFsKG1ldGEuc3BlY2lhbEF0dHJpYnV0ZXMuY2xhc3NBdHRyKSk7XG4gICAgfVxuICAgIGlmIChob3N0TWV0YWRhdGEudmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGhvc3RNZXRhZGF0YS50b0xpdGVyYWxNYXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUhvc3REaXJlY3RpdmVzKGhvc3REaXJlY3RpdmVzKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBob3N0RGlyZWN0aXZlcy5tYXAoY3VycmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgICAgICAgICAgIGtleTogJ2RpcmVjdGl2ZScsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnQuaXNGb3J3YXJkUmVmZXJlbmNlID8gZ2VuZXJhdGVGb3J3YXJkUmVmKGN1cnJlbnQuZGlyZWN0aXZlLnR5cGUpIDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5kaXJlY3RpdmUudHlwZSxcbiAgICAgICAgICAgICAgICBxdW90ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9XTtcbiAgICAgICAgY29uc3QgaW5wdXRzTGl0ZXJhbCA9IGN1cnJlbnQuaW5wdXRzID8gY3JlYXRlSG9zdERpcmVjdGl2ZXNNYXBwaW5nQXJyYXkoY3VycmVudC5pbnB1dHMpIDogbnVsbDtcbiAgICAgICAgY29uc3Qgb3V0cHV0c0xpdGVyYWwgPSBjdXJyZW50Lm91dHB1dHMgPyBjcmVhdGVIb3N0RGlyZWN0aXZlc01hcHBpbmdBcnJheShjdXJyZW50Lm91dHB1dHMpIDogbnVsbDtcbiAgICAgICAgaWYgKGlucHV0c0xpdGVyYWwpIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7IGtleTogJ2lucHV0cycsIHZhbHVlOiBpbnB1dHNMaXRlcmFsLCBxdW90ZWQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRzTGl0ZXJhbCkge1xuICAgICAgICAgICAga2V5cy5wdXNoKHsga2V5OiAnb3V0cHV0cycsIHZhbHVlOiBvdXRwdXRzTGl0ZXJhbCwgcXVvdGVkOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGl0ZXJhbE1hcChrZXlzKTtcbiAgICB9KTtcbiAgICAvLyBJZiB0aGVyZSdzIGEgZm9yd2FyZCByZWZlcmVuY2UsIHdlIGdlbmVyYXRlIGEgYGZ1bmN0aW9uKCkgeyByZXR1cm4gW3tkaXJlY3RpdmU6IEhvc3REaXJ9XSB9YCxcbiAgICAvLyBvdGhlcndpc2Ugd2UgY2FuIHNhdmUgc29tZSBieXRlcyBieSB1c2luZyBhIHBsYWluIGFycmF5LCBlLmcuIGBbe2RpcmVjdGl2ZTogSG9zdERpcn1dYC5cbiAgICByZXR1cm4gbGl0ZXJhbEFycihleHByZXNzaW9ucyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSBhIGNvbXBvbmVudCBkZWNsYXJhdGlvbiBkZWZpbmVkIGJ5IHRoZSBgUjNDb21wb25lbnRNZXRhZGF0YWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlQ29tcG9uZW50RnJvbU1ldGFkYXRhKG1ldGEsIHRlbXBsYXRlLCBhZGRpdGlvbmFsVGVtcGxhdGVJbmZvKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IGNyZWF0ZUNvbXBvbmVudERlZmluaXRpb25NYXAobWV0YSwgdGVtcGxhdGUsIGFkZGl0aW9uYWxUZW1wbGF0ZUluZm8pO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBpbXBvcnRFeHByKElkZW50aWZpZXJzLmRlY2xhcmVDb21wb25lbnQpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVDb21wb25lbnRUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYSBjb21wb25lbnQgaW50byBhIGBEZWZpbml0aW9uTWFwYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50RGVmaW5pdGlvbk1hcChtZXRhLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IGNyZWF0ZURpcmVjdGl2ZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RlbXBsYXRlJywgZ2V0VGVtcGxhdGVFeHByZXNzaW9uKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pKTtcbiAgICBpZiAodGVtcGxhdGVJbmZvLmlzSW5saW5lKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdpc0lubGluZScsIGxpdGVyYWwodHJ1ZSkpO1xuICAgIH1cbiAgICBkZWZpbml0aW9uTWFwLnNldCgnc3R5bGVzJywgdG9PcHRpb25hbExpdGVyYWxBcnJheShtZXRhLnN0eWxlcywgbGl0ZXJhbCkpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCdkZXBlbmRlbmNpZXMnLCBjb21waWxlVXNlZERlcGVuZGVuY2llc01ldGFkYXRhKG1ldGEpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmlld1Byb3ZpZGVycycsIG1ldGEudmlld1Byb3ZpZGVycyk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2FuaW1hdGlvbnMnLCBtZXRhLmFuaW1hdGlvbnMpO1xuICAgIGlmIChtZXRhLmNoYW5nZURldGVjdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdjaGFuZ2VEZXRlY3Rpb24nLCBpbXBvcnRFeHByKElkZW50aWZpZXJzLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5KVxuICAgICAgICAgICAgLnByb3AoQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3lbbWV0YS5jaGFuZ2VEZXRlY3Rpb25dKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmVuY2Fwc3VsYXRpb24gIT09IFZpZXdFbmNhcHN1bGF0aW9uLkVtdWxhdGVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdlbmNhcHN1bGF0aW9uJywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5WaWV3RW5jYXBzdWxhdGlvbikucHJvcChWaWV3RW5jYXBzdWxhdGlvblttZXRhLmVuY2Fwc3VsYXRpb25dKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmludGVycG9sYXRpb24gIT09IERFRkFVTFRfSU5URVJQT0xBVElPTl9DT05GSUcpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2ludGVycG9sYXRpb24nLCBsaXRlcmFsQXJyKFtsaXRlcmFsKG1ldGEuaW50ZXJwb2xhdGlvbi5zdGFydCksIGxpdGVyYWwobWV0YS5pbnRlcnBvbGF0aW9uLmVuZCldKSk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZS5wcmVzZXJ2ZVdoaXRlc3BhY2VzID09PSB0cnVlKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcmVzZXJ2ZVdoaXRlc3BhY2VzJywgbGl0ZXJhbCh0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuZnVuY3Rpb24gZ2V0VGVtcGxhdGVFeHByZXNzaW9uKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8pIHtcbiAgICAvLyBJZiB0aGUgdGVtcGxhdGUgaGFzIGJlZW4gZGVmaW5lZCB1c2luZyBhIGRpcmVjdCBsaXRlcmFsLCB3ZSB1c2UgdGhhdCBleHByZXNzaW9uIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCBhbnkgbW9kaWZpY2F0aW9ucy4gVGhpcyBpcyBlbnN1cmVzIHByb3BlciBzb3VyY2UgbWFwcGluZyBmcm9tIHRoZSBwYXJ0aWFsbHlcbiAgICAvLyBjb21waWxlZCBjb2RlIHRvIHRoZSBzb3VyY2UgZmlsZSBkZWNsYXJpbmcgdGhlIHRlbXBsYXRlLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBjYXB0dXJlXG4gICAgLy8gdGVtcGxhdGUgbGl0ZXJhbHMgcmVmZXJlbmNlZCBpbmRpcmVjdGx5IHRocm91Z2ggYW4gaWRlbnRpZmllci5cbiAgICBpZiAodGVtcGxhdGVJbmZvLmlubGluZVRlbXBsYXRlTGl0ZXJhbEV4cHJlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mby5pbmxpbmVUZW1wbGF0ZUxpdGVyYWxFeHByZXNzaW9uO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgdGVtcGxhdGUgaXMgZGVmaW5lZCBpbmxpbmUgYnV0IG5vdCB0aHJvdWdoIGEgbGl0ZXJhbCwgdGhlIHRlbXBsYXRlIGhhcyBiZWVuIHJlc29sdmVkXG4gICAgLy8gdGhyb3VnaCBzdGF0aWMgaW50ZXJwcmV0YXRpb24uIFdlIGNyZWF0ZSBhIGxpdGVyYWwgYnV0IGNhbm5vdCBwcm92aWRlIGFueSBzb3VyY2Ugc3Bhbi4gTm90ZVxuICAgIC8vIHRoYXQgd2UgY2Fubm90IHVzZSB0aGUgZXhwcmVzc2lvbiBkZWZpbmluZyB0aGUgdGVtcGxhdGUgYmVjYXVzZSB0aGUgbGlua2VyIGV4cGVjdHMgdGhlIHRlbXBsYXRlXG4gICAgLy8gdG8gYmUgZGVmaW5lZCBhcyBhIGxpdGVyYWwgaW4gdGhlIGRlY2xhcmF0aW9uLlxuICAgIGlmICh0ZW1wbGF0ZUluZm8uaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwodGVtcGxhdGVJbmZvLmNvbnRlbnQsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICAvLyBUaGUgdGVtcGxhdGUgaXMgZXh0ZXJuYWwgc28gd2UgbXVzdCBzeW50aGVzaXplIGFuIGV4cHJlc3Npb24gbm9kZSB3aXRoXG4gICAgLy8gdGhlIGFwcHJvcHJpYXRlIHNvdXJjZS1zcGFuLlxuICAgIGNvbnN0IGNvbnRlbnRzID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQ7XG4gICAgY29uc3QgZmlsZSA9IG5ldyBQYXJzZVNvdXJjZUZpbGUoY29udGVudHMsIHRlbXBsYXRlSW5mby5zb3VyY2VVcmwpO1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IFBhcnNlTG9jYXRpb24oZmlsZSwgMCwgMCwgMCk7XG4gICAgY29uc3QgZW5kID0gY29tcHV0ZUVuZExvY2F0aW9uKGZpbGUsIGNvbnRlbnRzKTtcbiAgICBjb25zdCBzcGFuID0gbmV3IFBhcnNlU291cmNlU3BhbihzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gbGl0ZXJhbChjb250ZW50cywgbnVsbCwgc3Bhbik7XG59XG5mdW5jdGlvbiBjb21wdXRlRW5kTG9jYXRpb24oZmlsZSwgY29udGVudHMpIHtcbiAgICBjb25zdCBsZW5ndGggPSBjb250ZW50cy5sZW5ndGg7XG4gICAgbGV0IGxpbmVTdGFydCA9IDA7XG4gICAgbGV0IGxhc3RMaW5lU3RhcnQgPSAwO1xuICAgIGxldCBsaW5lID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGxpbmVTdGFydCA9IGNvbnRlbnRzLmluZGV4T2YoJ1xcbicsIGxhc3RMaW5lU3RhcnQpO1xuICAgICAgICBpZiAobGluZVN0YXJ0ICE9PSAtMSkge1xuICAgICAgICAgICAgbGFzdExpbmVTdGFydCA9IGxpbmVTdGFydCArIDE7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChsaW5lU3RhcnQgIT09IC0xKTtcbiAgICByZXR1cm4gbmV3IFBhcnNlTG9jYXRpb24oZmlsZSwgbGVuZ3RoLCBsaW5lLCBsZW5ndGggLSBsYXN0TGluZVN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVVc2VkRGVwZW5kZW5jaWVzTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IHdyYXBUeXBlID0gbWV0YS5kZWNsYXJhdGlvbkxpc3RFbWl0TW9kZSAhPT0gMCAvKiBEZWNsYXJhdGlvbkxpc3RFbWl0TW9kZS5EaXJlY3QgKi8gP1xuICAgICAgICBnZW5lcmF0ZUZvcndhcmRSZWYgOlxuICAgICAgICAoZXhwcikgPT4gZXhwcjtcbiAgICByZXR1cm4gdG9PcHRpb25hbExpdGVyYWxBcnJheShtZXRhLmRlY2xhcmF0aW9ucywgZGVjbCA9PiB7XG4gICAgICAgIHN3aXRjaCAoZGVjbC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5EaXJlY3RpdmU6XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyTWV0YSA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgICAgICAgICAgICAgZGlyTWV0YS5zZXQoJ2tpbmQnLCBsaXRlcmFsKGRlY2wuaXNDb21wb25lbnQgPyAnY29tcG9uZW50JyA6ICdkaXJlY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgZGlyTWV0YS5zZXQoJ3R5cGUnLCB3cmFwVHlwZShkZWNsLnR5cGUpKTtcbiAgICAgICAgICAgICAgICBkaXJNZXRhLnNldCgnc2VsZWN0b3InLCBsaXRlcmFsKGRlY2wuc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICBkaXJNZXRhLnNldCgnaW5wdXRzJywgdG9PcHRpb25hbExpdGVyYWxBcnJheShkZWNsLmlucHV0cywgbGl0ZXJhbCkpO1xuICAgICAgICAgICAgICAgIGRpck1ldGEuc2V0KCdvdXRwdXRzJywgdG9PcHRpb25hbExpdGVyYWxBcnJheShkZWNsLm91dHB1dHMsIGxpdGVyYWwpKTtcbiAgICAgICAgICAgICAgICBkaXJNZXRhLnNldCgnZXhwb3J0QXMnLCB0b09wdGlvbmFsTGl0ZXJhbEFycmF5KGRlY2wuZXhwb3J0QXMsIGxpdGVyYWwpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlyTWV0YS50b0xpdGVyYWxNYXAoKTtcbiAgICAgICAgICAgIGNhc2UgUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kLlBpcGU6XG4gICAgICAgICAgICAgICAgY29uc3QgcGlwZU1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgICAgICAgICAgICAgIHBpcGVNZXRhLnNldCgna2luZCcsIGxpdGVyYWwoJ3BpcGUnKSk7XG4gICAgICAgICAgICAgICAgcGlwZU1ldGEuc2V0KCd0eXBlJywgd3JhcFR5cGUoZGVjbC50eXBlKSk7XG4gICAgICAgICAgICAgICAgcGlwZU1ldGEuc2V0KCduYW1lJywgbGl0ZXJhbChkZWNsLm5hbWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlwZU1ldGEudG9MaXRlcmFsTWFwKCk7XG4gICAgICAgICAgICBjYXNlIFIzVGVtcGxhdGVEZXBlbmRlbmN5S2luZC5OZ01vZHVsZTpcbiAgICAgICAgICAgICAgICBjb25zdCBuZ01vZHVsZU1ldGEgPSBuZXcgRGVmaW5pdGlvbk1hcCgpO1xuICAgICAgICAgICAgICAgIG5nTW9kdWxlTWV0YS5zZXQoJ2tpbmQnLCBsaXRlcmFsKCduZ21vZHVsZScpKTtcbiAgICAgICAgICAgICAgICBuZ01vZHVsZU1ldGEuc2V0KCd0eXBlJywgd3JhcFR5cGUoZGVjbC50eXBlKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5nTW9kdWxlTWV0YS50b0xpdGVyYWxNYXAoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDQgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlRmFjdG9yeUZ1bmN0aW9uKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDQpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmVyc2lvbicsIGxpdGVyYWwoJzE1LjIuNycpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdJbXBvcnQnLCBpbXBvcnRFeHByKElkZW50aWZpZXJzLmNvcmUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnZGVwcycsIGNvbXBpbGVEZXBlbmRlbmNpZXMobWV0YS5kZXBzKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3RhcmdldCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuRmFjdG9yeVRhcmdldCkucHJvcChGYWN0b3J5VGFyZ2V0JDFbbWV0YS50YXJnZXRdKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogaW1wb3J0RXhwcihJZGVudGlmaWVycy5kZWNsYXJlRmFjdG9yeSkuY2FsbEZuKFtkZWZpbml0aW9uTWFwLnRvTGl0ZXJhbE1hcCgpXSksXG4gICAgICAgIHN0YXRlbWVudHM6IFtdLFxuICAgICAgICB0eXBlOiBjcmVhdGVGYWN0b3J5VHlwZShtZXRhKSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDMgPSAnMTIuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIEluamVjdGFibGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzSW5qZWN0YWJsZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlSW5qZWN0YWJsZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZUluamVjdGFibGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVJbmplY3RhYmxlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGEgSW5qZWN0YWJsZSBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmplY3RhYmxlRGVmaW5pdGlvbk1hcChtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTiQzKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3ZlcnNpb24nLCBsaXRlcmFsKCcxNS4yLjcnKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ25nSW1wb3J0JywgaW1wb3J0RXhwcihJZGVudGlmaWVycy5jb3JlKSk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3R5cGUnLCBtZXRhLmludGVybmFsVHlwZSk7XG4gICAgLy8gT25seSBnZW5lcmF0ZSBwcm92aWRlZEluIHByb3BlcnR5IGlmIGl0IGhhcyBhIG5vbi1udWxsIHZhbHVlXG4gICAgaWYgKG1ldGEucHJvdmlkZWRJbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVkSW4gPSBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS5wcm92aWRlZEluKTtcbiAgICAgICAgaWYgKHByb3ZpZGVkSW4udmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCdwcm92aWRlZEluJywgcHJvdmlkZWRJbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1ldGEudXNlQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgndXNlQ2xhc3MnLCBjb252ZXJ0RnJvbU1heWJlRm9yd2FyZFJlZkV4cHJlc3Npb24obWV0YS51c2VDbGFzcykpO1xuICAgIH1cbiAgICBpZiAobWV0YS51c2VFeGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb25NYXAuc2V0KCd1c2VFeGlzdGluZycsIGNvbnZlcnRGcm9tTWF5YmVGb3J3YXJkUmVmRXhwcmVzc2lvbihtZXRhLnVzZUV4aXN0aW5nKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLnVzZVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZVZhbHVlJywgY29udmVydEZyb21NYXliZUZvcndhcmRSZWZFeHByZXNzaW9uKG1ldGEudXNlVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gRmFjdG9yaWVzIGRvIG5vdCBjb250YWluIGBGb3J3YXJkUmVmYHMgc2luY2UgYW55IHR5cGVzIGFyZSBhbHJlYWR5IHdyYXBwZWQgaW4gYSBmdW5jdGlvbiBjYWxsXG4gICAgLy8gc28gdGhlIHR5cGVzIHdpbGwgbm90IGJlIGVhZ2VybHkgZXZhbHVhdGVkLiBUaGVyZWZvcmUgd2UgZG8gbm90IG5lZWQgdG8gcHJvY2VzcyB0aGlzIGV4cHJlc3Npb25cbiAgICAvLyB3aXRoIGBjb252ZXJ0RnJvbVByb3ZpZGVyRXhwcmVzc2lvbigpYC5cbiAgICBpZiAobWV0YS51c2VGYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ3VzZUZhY3RvcnknLCBtZXRhLnVzZUZhY3RvcnkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5kZXBzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlcHMnLCBsaXRlcmFsQXJyKG1ldGEuZGVwcy5tYXAoY29tcGlsZURlcGVuZGVuY3kpKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDIgPSAnMTIuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlSW5qZWN0b3JGcm9tTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVJbmplY3RvckRlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZUluamVjdG9yKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlSW5qZWN0b3JUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYW4gSW5qZWN0b3IgaW50byBhIGBEZWZpbml0aW9uTWFwYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5qZWN0b3JEZWZpbml0aW9uTWFwKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDIpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmVyc2lvbicsIGxpdGVyYWwoJzE1LjIuNycpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdJbXBvcnQnLCBpbXBvcnRFeHByKElkZW50aWZpZXJzLmNvcmUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgncHJvdmlkZXJzJywgbWV0YS5wcm92aWRlcnMpO1xuICAgIGlmIChtZXRhLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW1wb3J0cycsIGxpdGVyYWxBcnIobWV0YS5pbXBvcnRzKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vKipcbiAqIEV2ZXJ5IHRpbWUgd2UgbWFrZSBhIGJyZWFraW5nIGNoYW5nZSB0byB0aGUgZGVjbGFyYXRpb24gaW50ZXJmYWNlIG9yIHBhcnRpYWwtbGlua2VyIGJlaGF2aW9yLCB3ZVxuICogbXVzdCB1cGRhdGUgdGhpcyBjb25zdGFudCB0byBwcmV2ZW50IG9sZCBwYXJ0aWFsLWxpbmtlcnMgZnJvbSBpbmNvcnJlY3RseSBwcm9jZXNzaW5nIHRoZVxuICogZGVjbGFyYXRpb24uXG4gKlxuICogRG8gbm90IGluY2x1ZGUgYW55IHByZXJlbGVhc2UgaW4gdGhlc2UgdmVyc2lvbnMgYXMgdGhleSBhcmUgaWdub3JlZC5cbiAqL1xuY29uc3QgTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDEgPSAnMTQuMC4wJztcbmZ1bmN0aW9uIGNvbXBpbGVEZWNsYXJlTmdNb2R1bGVGcm9tTWV0YWRhdGEobWV0YSkge1xuICAgIGNvbnN0IGRlZmluaXRpb25NYXAgPSBjcmVhdGVOZ01vZHVsZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZU5nTW9kdWxlKS5jYWxsRm4oW2RlZmluaXRpb25NYXAudG9MaXRlcmFsTWFwKCldKTtcbiAgICBjb25zdCB0eXBlID0gY3JlYXRlTmdNb2R1bGVUeXBlKG1ldGEpO1xuICAgIHJldHVybiB7IGV4cHJlc3Npb24sIHR5cGUsIHN0YXRlbWVudHM6IFtdIH07XG59XG4vKipcbiAqIEdhdGhlcnMgdGhlIGRlY2xhcmF0aW9uIGZpZWxkcyBmb3IgYW4gTmdNb2R1bGUgaW50byBhIGBEZWZpbml0aW9uTWFwYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmdNb2R1bGVEZWZpbml0aW9uTWFwKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gbmV3IERlZmluaXRpb25NYXAoKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbWluVmVyc2lvbicsIGxpdGVyYWwoTUlOSU1VTV9QQVJUSUFMX0xJTktFUl9WRVJTSU9OJDEpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndmVyc2lvbicsIGxpdGVyYWwoJzE1LjIuNycpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmdJbXBvcnQnLCBpbXBvcnRFeHByKElkZW50aWZpZXJzLmNvcmUpKTtcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICAvLyBXZSBvbmx5IGdlbmVyYXRlIHRoZSBrZXlzIGluIHRoZSBtZXRhZGF0YSBpZiB0aGUgYXJyYXlzIGNvbnRhaW4gdmFsdWVzLlxuICAgIC8vIFdlIG11c3Qgd3JhcCB0aGUgYXJyYXlzIGluc2lkZSBhIGZ1bmN0aW9uIGlmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSBhIGZvcndhcmQgcmVmZXJlbmNlIHRvIGFcbiAgICAvLyBub3QteWV0LWRlY2xhcmVkIGNsYXNzLiBUaGlzIGlzIHRvIHN1cHBvcnQgSklUIGV4ZWN1dGlvbiBvZiB0aGUgYMm1ybVuZ0RlY2xhcmVOZ01vZHVsZSgpYCBjYWxsLlxuICAgIC8vIEluIHRoZSBsaW5rZXIgdGhlc2Ugd3JhcHBlcnMgYXJlIHN0cmlwcGVkIGFuZCB0aGVuIHJlYXBwbGllZCBmb3IgdGhlIGDJtcm1ZGVmaW5lTmdNb2R1bGUoKWAgY2FsbC5cbiAgICBpZiAobWV0YS5ib290c3RyYXAubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnYm9vdHN0cmFwJywgcmVmc1RvQXJyYXkobWV0YS5ib290c3RyYXAsIG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuZGVjbGFyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2RlY2xhcmF0aW9ucycsIHJlZnNUb0FycmF5KG1ldGEuZGVjbGFyYXRpb25zLCBtZXRhLmNvbnRhaW5zRm9yd2FyZERlY2xzKSk7XG4gICAgfVxuICAgIGlmIChtZXRhLmltcG9ydHMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaW1wb3J0cycsIHJlZnNUb0FycmF5KG1ldGEuaW1wb3J0cywgbWV0YS5jb250YWluc0ZvcndhcmREZWNscykpO1xuICAgIH1cbiAgICBpZiAobWV0YS5leHBvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2V4cG9ydHMnLCByZWZzVG9BcnJheShtZXRhLmV4cG9ydHMsIG1ldGEuY29udGFpbnNGb3J3YXJkRGVjbHMpKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuc2NoZW1hcyAhPT0gbnVsbCAmJiBtZXRhLnNjaGVtYXMubGVuZ3RoID4gMCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnc2NoZW1hcycsIGxpdGVyYWxBcnIobWV0YS5zY2hlbWFzLm1hcChyZWYgPT4gcmVmLnZhbHVlKSkpO1xuICAgIH1cbiAgICBpZiAobWV0YS5pZCAhPT0gbnVsbCkge1xuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgnaWQnLCBtZXRhLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb25NYXA7XG59XG5cbi8qKlxuICogRXZlcnkgdGltZSB3ZSBtYWtlIGEgYnJlYWtpbmcgY2hhbmdlIHRvIHRoZSBkZWNsYXJhdGlvbiBpbnRlcmZhY2Ugb3IgcGFydGlhbC1saW5rZXIgYmVoYXZpb3IsIHdlXG4gKiBtdXN0IHVwZGF0ZSB0aGlzIGNvbnN0YW50IHRvIHByZXZlbnQgb2xkIHBhcnRpYWwtbGlua2VycyBmcm9tIGluY29ycmVjdGx5IHByb2Nlc3NpbmcgdGhlXG4gKiBkZWNsYXJhdGlvbi5cbiAqXG4gKiBEbyBub3QgaW5jbHVkZSBhbnkgcHJlcmVsZWFzZSBpbiB0aGVzZSB2ZXJzaW9ucyBhcyB0aGV5IGFyZSBpZ25vcmVkLlxuICovXG5jb25zdCBNSU5JTVVNX1BBUlRJQUxfTElOS0VSX1ZFUlNJT04gPSAnMTQuMC4wJztcbi8qKlxuICogQ29tcGlsZSBhIFBpcGUgZGVjbGFyYXRpb24gZGVmaW5lZCBieSB0aGUgYFIzUGlwZU1ldGFkYXRhYC5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZURlY2xhcmVQaXBlRnJvbU1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uTWFwID0gY3JlYXRlUGlwZURlZmluaXRpb25NYXAobWV0YSk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IGltcG9ydEV4cHIoSWRlbnRpZmllcnMuZGVjbGFyZVBpcGUpLmNhbGxGbihbZGVmaW5pdGlvbk1hcC50b0xpdGVyYWxNYXAoKV0pO1xuICAgIGNvbnN0IHR5cGUgPSBjcmVhdGVQaXBlVHlwZShtZXRhKTtcbiAgICByZXR1cm4geyBleHByZXNzaW9uLCB0eXBlLCBzdGF0ZW1lbnRzOiBbXSB9O1xufVxuLyoqXG4gKiBHYXRoZXJzIHRoZSBkZWNsYXJhdGlvbiBmaWVsZHMgZm9yIGEgUGlwZSBpbnRvIGEgYERlZmluaXRpb25NYXBgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQaXBlRGVmaW5pdGlvbk1hcChtZXRhKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk1hcCA9IG5ldyBEZWZpbml0aW9uTWFwKCk7XG4gICAgZGVmaW5pdGlvbk1hcC5zZXQoJ21pblZlcnNpb24nLCBsaXRlcmFsKE1JTklNVU1fUEFSVElBTF9MSU5LRVJfVkVSU0lPTikpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCd2ZXJzaW9uJywgbGl0ZXJhbCgnMTUuMi43JykpO1xuICAgIGRlZmluaXRpb25NYXAuc2V0KCduZ0ltcG9ydCcsIGltcG9ydEV4cHIoSWRlbnRpZmllcnMuY29yZSkpO1xuICAgIC8vIGUuZy4gYHR5cGU6IE15UGlwZWBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgndHlwZScsIG1ldGEuaW50ZXJuYWxUeXBlKTtcbiAgICBpZiAobWV0YS5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgZGVmaW5pdGlvbk1hcC5zZXQoJ2lzU3RhbmRhbG9uZScsIGxpdGVyYWwobWV0YS5pc1N0YW5kYWxvbmUpKTtcbiAgICB9XG4gICAgLy8gZS5nLiBgbmFtZTogXCJteVBpcGVcImBcbiAgICBkZWZpbml0aW9uTWFwLnNldCgnbmFtZScsIGxpdGVyYWwobWV0YS5waXBlTmFtZSkpO1xuICAgIGlmIChtZXRhLnB1cmUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGUuZy4gYHB1cmU6IGZhbHNlYFxuICAgICAgICBkZWZpbml0aW9uTWFwLnNldCgncHVyZScsIGxpdGVyYWwobWV0YS5wdXJlKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uTWFwO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cbi8vIFRoaXMgZnVuY3Rpb24gY2FsbCBoYXMgYSBnbG9iYWwgc2lkZSBlZmZlY3RzIGFuZCBwdWJsaXNoZXMgdGhlIGNvbXBpbGVyIGludG8gZ2xvYmFsIG5hbWVzcGFjZSBmb3Jcbi8vIHRoZSBsYXRlIGJpbmRpbmcgb2YgdGhlIENvbXBpbGVyIHRvIHRoZSBAYW5ndWxhci9jb3JlIGZvciBqaXQgY29tcGlsYXRpb24uXG5wdWJsaXNoRmFjYWRlKF9nbG9iYWwpO1xuXG4vKipcbiAqIEBtb2R1bGVcbiAqIEBkZXNjcmlwdGlvblxuICogRW50cnkgcG9pbnQgZm9yIGFsbCBwdWJsaWMgQVBJcyBvZiB0aGlzIHBhY2thZ2UuXG4gKi9cbi8vIFRoaXMgZmlsZSBvbmx5IHJlZXhwb3J0cyBjb250ZW50IG9mIHRoZSBgc3JjYCBmb2xkZXIuIEtlZXAgaXQgdGhhdCB3YXkuXG5cbi8vIFRoaXMgZmlsZSBpcyBub3QgdXNlZCB0byBidWlsZCB0aGlzIG1vZHVsZS4gSXQgaXMgb25seSB1c2VkIGR1cmluZyBlZGl0aW5nXG5cbi8vIFRoaXMgZmlsZSBpcyBub3QgdXNlZCB0byBidWlsZCB0aGlzIG1vZHVsZS4gSXQgaXMgb25seSB1c2VkIGR1cmluZyBlZGl0aW5nXG5cbmV4cG9ydCB7IEFTVCwgQVNUV2l0aE5hbWUsIEFTVFdpdGhTb3VyY2UsIEFic29sdXRlU291cmNlU3BhbiwgQXJyYXlUeXBlLCBBc3RNZW1vcnlFZmZpY2llbnRUcmFuc2Zvcm1lciwgQXN0VHJhbnNmb3JtZXIsIEF0dHJpYnV0ZSwgQmluYXJ5LCBCaW5hcnlPcGVyYXRvciwgQmluYXJ5T3BlcmF0b3JFeHByLCBCaW5kaW5nUGlwZSwgQm91bmRFbGVtZW50UHJvcGVydHksIEJ1aWx0aW5UeXBlLCBCdWlsdGluVHlwZU5hbWUsIENVU1RPTV9FTEVNRU5UU19TQ0hFTUEsIENhbGwsIENoYWluLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tbWFFeHByLCBDb21tZW50LCBDb21waWxlckNvbmZpZywgQ29uZGl0aW9uYWwsIENvbmRpdGlvbmFsRXhwciwgQ29uc3RhbnRQb29sLCBDc3NTZWxlY3RvciwgREVGQVVMVF9JTlRFUlBPTEFUSU9OX0NPTkZJRywgRFlOQU1JQ19UWVBFLCBEZWNsYXJlRnVuY3Rpb25TdG10LCBEZWNsYXJlVmFyU3RtdCwgRG9tRWxlbWVudFNjaGVtYVJlZ2lzdHJ5LCBFT0YsIEVsZW1lbnQsIEVsZW1lbnRTY2hlbWFSZWdpc3RyeSwgRW1pdHRlclZpc2l0b3JDb250ZXh0LCBFbXB0eUV4cHIsIEV4cGFuc2lvbiwgRXhwYW5zaW9uQ2FzZSwgRXhwcmVzc2lvbiwgRXhwcmVzc2lvbkJpbmRpbmcsIEV4cHJlc3Npb25TdGF0ZW1lbnQsIEV4cHJlc3Npb25UeXBlLCBFeHRlcm5hbEV4cHIsIEV4dGVybmFsUmVmZXJlbmNlLCBGYWN0b3J5VGFyZ2V0JDEgYXMgRmFjdG9yeVRhcmdldCwgRnVuY3Rpb25FeHByLCBIdG1sUGFyc2VyLCBIdG1sVGFnRGVmaW5pdGlvbiwgSTE4Tkh0bWxQYXJzZXIsIElmU3RtdCwgSW1wbGljaXRSZWNlaXZlciwgSW5zdGFudGlhdGVFeHByLCBJbnRlcnBvbGF0aW9uLCBJbnRlcnBvbGF0aW9uQ29uZmlnLCBJbnZva2VGdW5jdGlvbkV4cHIsIEpTRG9jQ29tbWVudCwgSml0RXZhbHVhdG9yLCBLZXllZFJlYWQsIEtleWVkV3JpdGUsIExlYWRpbmdDb21tZW50LCBMZXhlciwgTGl0ZXJhbEFycmF5LCBMaXRlcmFsQXJyYXlFeHByLCBMaXRlcmFsRXhwciwgTGl0ZXJhbE1hcCwgTGl0ZXJhbE1hcEV4cHIsIExpdGVyYWxQcmltaXRpdmUsIExvY2FsaXplZFN0cmluZywgTWFwVHlwZSwgTWVzc2FnZUJ1bmRsZSwgTk9ORV9UWVBFLCBOT19FUlJPUlNfU0NIRU1BLCBOb2RlV2l0aEkxOG4sIE5vbk51bGxBc3NlcnQsIE5vdEV4cHIsIFBhcnNlRXJyb3IsIFBhcnNlRXJyb3JMZXZlbCwgUGFyc2VMb2NhdGlvbiwgUGFyc2VTb3VyY2VGaWxlLCBQYXJzZVNvdXJjZVNwYW4sIFBhcnNlU3BhbiwgUGFyc2VUcmVlUmVzdWx0LCBQYXJzZWRFdmVudCwgUGFyc2VkUHJvcGVydHksIFBhcnNlZFByb3BlcnR5VHlwZSwgUGFyc2VkVmFyaWFibGUsIFBhcnNlciQxIGFzIFBhcnNlciwgUGFyc2VyRXJyb3IsIFByZWZpeE5vdCwgUHJvcGVydHlSZWFkLCBQcm9wZXJ0eVdyaXRlLCBSM0JvdW5kVGFyZ2V0LCBJZGVudGlmaWVycyBhcyBSM0lkZW50aWZpZXJzLCBSM1NlbGVjdG9yU2NvcGVNb2RlLCBSM1RhcmdldEJpbmRlciwgUjNUZW1wbGF0ZURlcGVuZGVuY3lLaW5kLCBSZWFkS2V5RXhwciwgUmVhZFByb3BFeHByLCBSZWFkVmFyRXhwciwgUmVjdXJzaXZlQXN0VmlzaXRvciwgUmVjdXJzaXZlVmlzaXRvciwgUmVzb3VyY2VMb2FkZXIsIFJldHVyblN0YXRlbWVudCwgU1RSSU5HX1RZUEUsIFNhZmVDYWxsLCBTYWZlS2V5ZWRSZWFkLCBTYWZlUHJvcGVydHlSZWFkLCBTZWxlY3RvckNvbnRleHQsIFNlbGVjdG9yTGlzdENvbnRleHQsIFNlbGVjdG9yTWF0Y2hlciwgU2VyaWFsaXplciwgU3BsaXRJbnRlcnBvbGF0aW9uLCBTdGF0ZW1lbnQsIFN0bXRNb2RpZmllciwgVGFnQ29udGVudFR5cGUsIFRhZ2dlZFRlbXBsYXRlRXhwciwgVGVtcGxhdGVCaW5kaW5nUGFyc2VSZXN1bHQsIFRlbXBsYXRlTGl0ZXJhbCwgVGVtcGxhdGVMaXRlcmFsRWxlbWVudCwgVGV4dCwgVGhpc1JlY2VpdmVyLCBCb3VuZEF0dHJpYnV0ZSBhcyBUbXBsQXN0Qm91bmRBdHRyaWJ1dGUsIEJvdW5kRXZlbnQgYXMgVG1wbEFzdEJvdW5kRXZlbnQsIEJvdW5kVGV4dCBhcyBUbXBsQXN0Qm91bmRUZXh0LCBDb250ZW50IGFzIFRtcGxBc3RDb250ZW50LCBFbGVtZW50JDEgYXMgVG1wbEFzdEVsZW1lbnQsIEljdSQxIGFzIFRtcGxBc3RJY3UsIFJlY3Vyc2l2ZVZpc2l0b3IkMSBhcyBUbXBsQXN0UmVjdXJzaXZlVmlzaXRvciwgUmVmZXJlbmNlIGFzIFRtcGxBc3RSZWZlcmVuY2UsIFRlbXBsYXRlIGFzIFRtcGxBc3RUZW1wbGF0ZSwgVGV4dCQzIGFzIFRtcGxBc3RUZXh0LCBUZXh0QXR0cmlidXRlIGFzIFRtcGxBc3RUZXh0QXR0cmlidXRlLCBWYXJpYWJsZSBhcyBUbXBsQXN0VmFyaWFibGUsIFRva2VuLCBUb2tlblR5cGUsIFRyZWVFcnJvciwgVHlwZSwgVHlwZU1vZGlmaWVyLCBUeXBlb2ZFeHByLCBVbmFyeSwgVW5hcnlPcGVyYXRvciwgVW5hcnlPcGVyYXRvckV4cHIsIFZFUlNJT04sIFZhcmlhYmxlQmluZGluZywgVmVyc2lvbiwgVmlld0VuY2Fwc3VsYXRpb24sIFdyYXBwZWROb2RlRXhwciwgV3JpdGVLZXlFeHByLCBXcml0ZVByb3BFeHByLCBXcml0ZVZhckV4cHIsIFhsaWZmLCBYbGlmZjIsIFhtYiwgWG1sUGFyc2VyLCBYdGIsIF9QYXJzZUFTVCwgY29tcGlsZUNsYXNzTWV0YWRhdGEsIGNvbXBpbGVDb21wb25lbnRGcm9tTWV0YWRhdGEsIGNvbXBpbGVEZWNsYXJlQ2xhc3NNZXRhZGF0YSwgY29tcGlsZURlY2xhcmVDb21wb25lbnRGcm9tTWV0YWRhdGEsIGNvbXBpbGVEZWNsYXJlRGlyZWN0aXZlRnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZUZhY3RvcnlGdW5jdGlvbiwgY29tcGlsZURlY2xhcmVJbmplY3RhYmxlRnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZUluamVjdG9yRnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZU5nTW9kdWxlRnJvbU1ldGFkYXRhLCBjb21waWxlRGVjbGFyZVBpcGVGcm9tTWV0YWRhdGEsIGNvbXBpbGVEaXJlY3RpdmVGcm9tTWV0YWRhdGEsIGNvbXBpbGVGYWN0b3J5RnVuY3Rpb24sIGNvbXBpbGVJbmplY3RhYmxlLCBjb21waWxlSW5qZWN0b3IsIGNvbXBpbGVOZ01vZHVsZSwgY29tcGlsZVBpcGVGcm9tTWV0YWRhdGEsIGNvbXB1dGVNc2dJZCwgY29yZSwgY3JlYXRlSW5qZWN0YWJsZVR5cGUsIGNyZWF0ZU1heUJlRm9yd2FyZFJlZkV4cHJlc3Npb24sIGRldk9ubHlHdWFyZGVkRXhwcmVzc2lvbiwgZW1pdERpc3RpbmN0Q2hhbmdlc09ubHlEZWZhdWx0VmFsdWUsIGdldEh0bWxUYWdEZWZpbml0aW9uLCBnZXROc1ByZWZpeCwgZ2V0U2FmZVByb3BlcnR5QWNjZXNzU3RyaW5nLCBpZGVudGlmaWVyTmFtZSwgaXNJZGVudGlmaWVyLCBpc05nQ29udGFpbmVyLCBpc05nQ29udGVudCwgaXNOZ1RlbXBsYXRlLCBqc0RvY0NvbW1lbnQsIGxlYWRpbmdDb21tZW50LCBsaXRlcmFsTWFwLCBtYWtlQmluZGluZ1BhcnNlciwgbWVyZ2VOc0FuZE5hbWUsIG91dHB1dF9hc3QgYXMgb3V0cHV0QXN0LCBwYXJzZUhvc3RCaW5kaW5ncywgcGFyc2VUZW1wbGF0ZSwgcHJlc2VydmVXaGl0ZXNwYWNlc0RlZmF1bHQsIHB1Ymxpc2hGYWNhZGUsIHIzSml0VHlwZVNvdXJjZVNwYW4sIHNhbml0aXplSWRlbnRpZmllciwgc3BsaXROc05hbWUsIHZlcmlmeUhvc3RCaW5kaW5ncywgdmlzaXRBbGwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBpbGVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@angular/compiler/fesm2020/compiler.mjs\n");

/***/ })

}]);