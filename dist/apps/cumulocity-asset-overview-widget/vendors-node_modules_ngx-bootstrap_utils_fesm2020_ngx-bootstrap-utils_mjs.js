"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_ngx-bootstrap_utils_fesm2020_ngx-bootstrap-utils_mjs"],{

/***/ "./node_modules/ngx-bootstrap/utils/fesm2020/ngx-bootstrap-utils.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/ngx-bootstrap/utils/fesm2020/ngx-bootstrap-utils.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BsVerions\": function() { return /* binding */ BsVerions; },\n/* harmony export */   \"LinkedList\": function() { return /* binding */ LinkedList; },\n/* harmony export */   \"OnChange\": function() { return /* binding */ OnChange; },\n/* harmony export */   \"Trigger\": function() { return /* binding */ Trigger; },\n/* harmony export */   \"Utils\": function() { return /* binding */ Utils; },\n/* harmony export */   \"currentBsVersion\": function() { return /* binding */ currentBsVersion; },\n/* harmony export */   \"document\": function() { return /* binding */ document; },\n/* harmony export */   \"getBsVer\": function() { return /* binding */ getBsVer; },\n/* harmony export */   \"listenToTriggers\": function() { return /* binding */ listenToTriggers; },\n/* harmony export */   \"listenToTriggersV2\": function() { return /* binding */ listenToTriggersV2; },\n/* harmony export */   \"parseTriggers\": function() { return /* binding */ parseTriggers; },\n/* harmony export */   \"registerEscClick\": function() { return /* binding */ registerEscClick; },\n/* harmony export */   \"registerOutsideClick\": function() { return /* binding */ registerOutsideClick; },\n/* harmony export */   \"setTheme\": function() { return /* binding */ setTheme; },\n/* harmony export */   \"warnOnce\": function() { return /* binding */ warnOnce; },\n/* harmony export */   \"window\": function() { return /* binding */ win; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n\n\n/**\n * @copyright Valor Software\n * @copyright Angular ng-bootstrap team\n */\nclass Trigger {\n    constructor(open, close) {\n        this.open = open;\n        this.close = close || open;\n    }\n    isManual() {\n        return this.open === 'manual' || this.close === 'manual';\n    }\n}\n\nconst DEFAULT_ALIASES = {\n    hover: ['mouseover', 'mouseout'],\n    focus: ['focusin', 'focusout']\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction parseTriggers(triggers, aliases = DEFAULT_ALIASES) {\n    const trimmedTriggers = (triggers || '').trim();\n    if (trimmedTriggers.length === 0) {\n        return [];\n    }\n    const parsedTriggers = trimmedTriggers\n        .split(/\\s+/)\n        .map((trigger) => trigger.split(':'))\n        .map((triggerPair) => {\n        const alias = aliases[triggerPair[0]] || triggerPair;\n        return new Trigger(alias[0], alias[1]);\n    });\n    const manualTriggers = parsedTriggers.filter((triggerPair) => triggerPair.isManual());\n    if (manualTriggers.length > 1) {\n        throw new Error('Triggers parse error: only one manual trigger is allowed');\n    }\n    if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n        throw new Error('Triggers parse error: manual trigger can\\'t be mixed with other triggers');\n    }\n    return parsedTriggers;\n}\nfunction listenToTriggers(renderer, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntarget, triggers, showFn, hideFn, toggleFn) {\n    const parsedTriggers = parseTriggers(triggers);\n    const listeners = [];\n    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n        return Function.prototype;\n    }\n    parsedTriggers.forEach((trigger) => {\n        if (trigger.open === trigger.close) {\n            listeners.push(renderer.listen(target, trigger.open, toggleFn));\n            return;\n        }\n        listeners.push(renderer.listen(target, trigger.open, showFn));\n        if (trigger.close) {\n            listeners.push(renderer.listen(target, trigger.close, hideFn));\n        }\n    });\n    return () => {\n        listeners.forEach((unsubscribeFn) => unsubscribeFn());\n    };\n}\nfunction listenToTriggersV2(renderer, options) {\n    const parsedTriggers = parseTriggers(options.triggers);\n    const target = options.target;\n    // do nothing\n    if (parsedTriggers.length === 1 && parsedTriggers[0].isManual()) {\n        return Function.prototype;\n    }\n    // all listeners\n    const listeners = [];\n    // lazy listeners registration\n    const _registerHide = [];\n    const registerHide = () => {\n        // add hide listeners to unregister array\n        _registerHide.forEach((fn) => listeners.push(fn()));\n        // register hide events only once\n        _registerHide.length = 0;\n    };\n    // register open\\close\\toggle listeners\n    parsedTriggers.forEach((trigger) => {\n        const useToggle = trigger.open === trigger.close;\n        const showFn = useToggle ? options.toggle : options.show;\n        if (!useToggle && trigger.close && options.hide) {\n            const _hide = renderer.listen(target, trigger.close, options.hide);\n            _registerHide.push(() => _hide);\n        }\n        if (showFn) {\n            listeners.push(renderer.listen(target, trigger.open, () => showFn(registerHide)));\n        }\n    });\n    return () => {\n        listeners.forEach((unsubscribeFn) => unsubscribeFn());\n    };\n}\nfunction registerOutsideClick(renderer, options) {\n    if (!options.outsideClick) {\n        return Function.prototype;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return renderer.listen('document', 'click', (event) => {\n        if (options.target && options.target.contains(event.target)) {\n            return;\n        }\n        if (options.targets &&\n            options.targets.some(target => target.contains(event.target))) {\n            return;\n        }\n        if (options.hide) {\n            options.hide();\n        }\n    });\n}\nfunction registerEscClick(renderer, options) {\n    if (!options.outsideEsc) {\n        return Function.prototype;\n    }\n    return renderer.listen('document', 'keyup.esc', (event) => {\n        if (options.target && options.target.contains(event.target)) {\n            return;\n        }\n        if (options.targets &&\n            options.targets.some(target => target.contains(event.target))) {\n            return;\n        }\n        if (options.hide) {\n            options.hide();\n        }\n    });\n}\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * JS version of browser APIs. This library can only run in the browser.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst win = (typeof window !== 'undefined' && window) || {};\nconst document = win.document;\nconst location = win.location;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst gc = win.gc ? () => win.gc() : () => null;\nconst performance = win.performance ? win.performance : null;\nconst Event = win.Event;\nconst MouseEvent = win.MouseEvent;\nconst KeyboardEvent = win.KeyboardEvent;\nconst EventTarget = win.EventTarget;\nconst History = win.History;\nconst Location = win.Location;\nconst EventListener = win.EventListener;\n\nvar BsVerions;\n(function (BsVerions) {\n    BsVerions[\"isBs4\"] = \"bs4\";\n    BsVerions[\"isBs5\"] = \"bs5\";\n})(BsVerions || (BsVerions = {}));\nlet guessedVersion;\nfunction _guessBsVersion() {\n    const spanEl = win.document.createElement('span');\n    spanEl.innerText = 'testing bs version';\n    spanEl.classList.add('d-none');\n    spanEl.classList.add('pl-1');\n    win.document.head.appendChild(spanEl);\n    const checkPadding = win.getComputedStyle(spanEl).paddingLeft;\n    if (checkPadding && parseFloat(checkPadding)) {\n        win.document.head.removeChild(spanEl);\n        return 'bs4';\n    }\n    win.document.head.removeChild(spanEl);\n    return 'bs5';\n}\nfunction setTheme(theme) {\n    guessedVersion = theme;\n}\nfunction isBs4() {\n    if (guessedVersion)\n        return guessedVersion === 'bs4';\n    guessedVersion = _guessBsVersion();\n    return guessedVersion === 'bs4';\n}\nfunction isBs5() {\n    if (guessedVersion)\n        return guessedVersion === 'bs5';\n    guessedVersion = _guessBsVersion();\n    return guessedVersion === 'bs5';\n}\nfunction getBsVer() {\n    return {\n        isBs4: isBs4(),\n        isBs5: isBs5()\n    };\n}\nfunction currentBsVersion() {\n    const bsVer = getBsVer();\n    const resVersion = Object.keys(bsVer).find(key => bsVer[key]);\n    return BsVerions[resVersion];\n}\n\nclass LinkedList {\n    constructor() {\n        this.length = 0;\n        this.asArray = [];\n        // Array methods overriding END\n    }\n    get(position) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            return void 0;\n        }\n        let current = this.head;\n        for (let index = 0; index < position; index++) {\n            current = current?.next;\n        }\n        return current?.value;\n    }\n    add(value, position = this.length) {\n        if (position < 0 || position > this.length) {\n            throw new Error('Position is out of the list');\n        }\n        const node = {\n            value,\n            next: undefined,\n            previous: undefined\n        };\n        if (this.length === 0) {\n            this.head = node;\n            this.tail = node;\n            this.current = node;\n        }\n        else {\n            if (position === 0 && this.head) {\n                // first node\n                node.next = this.head;\n                this.head.previous = node;\n                this.head = node;\n            }\n            else if (position === this.length && this.tail) {\n                // last node\n                this.tail.next = node;\n                node.previous = this.tail;\n                this.tail = node;\n            }\n            else {\n                // node in middle\n                const currentPreviousNode = this.getNode(position - 1);\n                const currentNextNode = currentPreviousNode?.next;\n                if (currentPreviousNode && currentNextNode) {\n                    currentPreviousNode.next = node;\n                    currentNextNode.previous = node;\n                    node.previous = currentPreviousNode;\n                    node.next = currentNextNode;\n                }\n            }\n        }\n        this.length++;\n        this.createInternalArrayRepresentation();\n    }\n    remove(position = 0) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        if (position === 0 && this.head) {\n            // first node\n            this.head = this.head.next;\n            if (this.head) {\n                // there is no second node\n                this.head.previous = undefined;\n            }\n            else {\n                // there is no second node\n                this.tail = undefined;\n            }\n        }\n        else if (position === this.length - 1 && this.tail?.previous) {\n            // last node\n            this.tail = this.tail.previous;\n            this.tail.next = undefined;\n        }\n        else {\n            // middle node\n            const removedNode = this.getNode(position);\n            if (removedNode?.next && removedNode.previous) {\n                removedNode.next.previous = removedNode.previous;\n                removedNode.previous.next = removedNode.next;\n            }\n        }\n        this.length--;\n        this.createInternalArrayRepresentation();\n    }\n    set(position, value) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        const node = this.getNode(position);\n        if (node) {\n            node.value = value;\n            this.createInternalArrayRepresentation();\n        }\n    }\n    toArray() {\n        return this.asArray;\n    }\n    findAll(fn) {\n        let current = this.head;\n        const result = [];\n        if (!current) {\n            return result;\n        }\n        for (let index = 0; index < this.length; index++) {\n            if (!current) {\n                return result;\n            }\n            if (fn(current.value, index)) {\n                result.push({ index, value: current.value });\n            }\n            current = current.next;\n        }\n        return result;\n    }\n    // Array methods overriding start\n    push(...args) {\n        args.forEach((arg) => {\n            this.add(arg);\n        });\n        return this.length;\n    }\n    pop() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        const last = this.tail;\n        this.remove(this.length - 1);\n        return last?.value;\n    }\n    unshift(...args) {\n        args.reverse();\n        args.forEach((arg) => {\n            this.add(arg, 0);\n        });\n        return this.length;\n    }\n    shift() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        const lastItem = this.head?.value;\n        this.remove();\n        return lastItem;\n    }\n    forEach(fn) {\n        let current = this.head;\n        for (let index = 0; index < this.length; index++) {\n            if (!current) {\n                return;\n            }\n            fn(current.value, index);\n            current = current.next;\n        }\n    }\n    indexOf(value) {\n        let current = this.head;\n        let position = -1;\n        for (let index = 0; index < this.length; index++) {\n            if (!current) {\n                return position;\n            }\n            if (current.value === value) {\n                position = index;\n                break;\n            }\n            current = current.next;\n        }\n        return position;\n    }\n    some(fn) {\n        let current = this.head;\n        let result = false;\n        while (current && !result) {\n            if (fn(current.value)) {\n                result = true;\n                break;\n            }\n            current = current.next;\n        }\n        return result;\n    }\n    every(fn) {\n        let current = this.head;\n        let result = true;\n        while (current && result) {\n            if (!fn(current.value)) {\n                result = false;\n            }\n            current = current.next;\n        }\n        return result;\n    }\n    toString() {\n        return '[Linked List]';\n    }\n    find(fn) {\n        let current = this.head;\n        for (let index = 0; index < this.length; index++) {\n            if (!current) {\n                return;\n            }\n            if (fn(current.value, index)) {\n                return current.value;\n            }\n            current = current.next;\n        }\n    }\n    findIndex(fn) {\n        let current = this.head;\n        for (let index = 0; index < this.length; index++) {\n            if (!current) {\n                return -1;\n            }\n            if (fn(current.value, index)) {\n                return index;\n            }\n            current = current.next;\n        }\n        return -1;\n    }\n    getNode(position) {\n        if (this.length === 0 || position < 0 || position >= this.length) {\n            throw new Error('Position is out of the list');\n        }\n        let current = this.head;\n        for (let index = 0; index < position; index++) {\n            current = current?.next;\n        }\n        return current;\n    }\n    createInternalArrayRepresentation() {\n        const outArray = [];\n        let current = this.head;\n        while (current) {\n            outArray.push(current.value);\n            current = current.next;\n        }\n        this.asArray = outArray;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction OnChange() {\n    const sufix = 'Change';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function OnChangeHandler(target, propertyKey) {\n        const _key = ` __${propertyKey}Value`;\n        Object.defineProperty(target, propertyKey, {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            get() {\n                return this[_key];\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            set(value) {\n                const prevValue = this[_key];\n                this[_key] = value;\n                if (prevValue !== value && this[propertyKey + sufix]) {\n                    this[propertyKey + sufix].emit(value);\n                }\n            }\n        });\n    };\n}\n\nclass Utils {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static reflow(element) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((bs) => bs)(element.offsetHeight);\n    }\n    // source: https://github.com/jquery/jquery/blob/master/src/css/var/getStyles.js\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static getStyles(elem) {\n        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n        // IE throws on elements created in popups\n        // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n        let view = elem.ownerDocument.defaultView;\n        if (!view || !view.opener) {\n            view = win;\n        }\n        return view.getComputedStyle(elem);\n    }\n    static stackOverflowConfig() {\n        const bsVer = currentBsVersion();\n        return {\n            crossorigin: \"anonymous\",\n            integrity: bsVer === 'bs5' ? 'sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We' : 'sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2',\n            cdnLink: bsVer === 'bs5' ? 'https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css' : 'https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css',\n        };\n    }\n}\n\nconst _messagesHash = {};\nconst _hideMsg = typeof console === 'undefined' || !('warn' in console);\nfunction warnOnce(msg) {\n    if (!(0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.isDevMode)() || _hideMsg || msg in _messagesHash) {\n        return;\n    }\n    _messagesHash[msg] = true;\n    console.warn(msg);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=ngx-bootstrap-utils.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmd4LWJvb3RzdHJhcC91dGlscy9mZXNtMjAyMC9uZ3gtYm9vdHN0cmFwLXV0aWxzLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2N1bXVsb2NpdHktYXNzZXQtb3ZlcnZpZXctd2lkZ2V0Ly4vbm9kZV9tb2R1bGVzL25neC1ib290c3RyYXAvdXRpbHMvZmVzbTIwMjAvbmd4LWJvb3RzdHJhcC11dGlscy5tanM/ZmVhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAY29weXJpZ2h0IFZhbG9yIFNvZnR3YXJlXG4gKiBAY29weXJpZ2h0IEFuZ3VsYXIgbmctYm9vdHN0cmFwIHRlYW1cbiAqL1xuY2xhc3MgVHJpZ2dlciB7XG4gICAgY29uc3RydWN0b3Iob3BlbiwgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICAgICAgdGhpcy5jbG9zZSA9IGNsb3NlIHx8IG9wZW47XG4gICAgfVxuICAgIGlzTWFudWFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuID09PSAnbWFudWFsJyB8fCB0aGlzLmNsb3NlID09PSAnbWFudWFsJztcbiAgICB9XG59XG5cbmNvbnN0IERFRkFVTFRfQUxJQVNFUyA9IHtcbiAgICBob3ZlcjogWydtb3VzZW92ZXInLCAnbW91c2VvdXQnXSxcbiAgICBmb2N1czogWydmb2N1c2luJywgJ2ZvY3Vzb3V0J11cbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcGFyc2VUcmlnZ2Vycyh0cmlnZ2VycywgYWxpYXNlcyA9IERFRkFVTFRfQUxJQVNFUykge1xuICAgIGNvbnN0IHRyaW1tZWRUcmlnZ2VycyA9ICh0cmlnZ2VycyB8fCAnJykudHJpbSgpO1xuICAgIGlmICh0cmltbWVkVHJpZ2dlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHJpZ2dlcnMgPSB0cmltbWVkVHJpZ2dlcnNcbiAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgLm1hcCgodHJpZ2dlcikgPT4gdHJpZ2dlci5zcGxpdCgnOicpKVxuICAgICAgICAubWFwKCh0cmlnZ2VyUGFpcikgPT4ge1xuICAgICAgICBjb25zdCBhbGlhcyA9IGFsaWFzZXNbdHJpZ2dlclBhaXJbMF1dIHx8IHRyaWdnZXJQYWlyO1xuICAgICAgICByZXR1cm4gbmV3IFRyaWdnZXIoYWxpYXNbMF0sIGFsaWFzWzFdKTtcbiAgICB9KTtcbiAgICBjb25zdCBtYW51YWxUcmlnZ2VycyA9IHBhcnNlZFRyaWdnZXJzLmZpbHRlcigodHJpZ2dlclBhaXIpID0+IHRyaWdnZXJQYWlyLmlzTWFudWFsKCkpO1xuICAgIGlmIChtYW51YWxUcmlnZ2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZ2dlcnMgcGFyc2UgZXJyb3I6IG9ubHkgb25lIG1hbnVhbCB0cmlnZ2VyIGlzIGFsbG93ZWQnKTtcbiAgICB9XG4gICAgaWYgKG1hbnVhbFRyaWdnZXJzLmxlbmd0aCA9PT0gMSAmJiBwYXJzZWRUcmlnZ2Vycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZ2dlcnMgcGFyc2UgZXJyb3I6IG1hbnVhbCB0cmlnZ2VyIGNhblxcJ3QgYmUgbWl4ZWQgd2l0aCBvdGhlciB0cmlnZ2VycycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkVHJpZ2dlcnM7XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub1RyaWdnZXJzKHJlbmRlcmVyLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50YXJnZXQsIHRyaWdnZXJzLCBzaG93Rm4sIGhpZGVGbiwgdG9nZ2xlRm4pIHtcbiAgICBjb25zdCBwYXJzZWRUcmlnZ2VycyA9IHBhcnNlVHJpZ2dlcnModHJpZ2dlcnMpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIGlmIChwYXJzZWRUcmlnZ2Vycy5sZW5ndGggPT09IDEgJiYgcGFyc2VkVHJpZ2dlcnNbMF0uaXNNYW51YWwoKSkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIH1cbiAgICBwYXJzZWRUcmlnZ2Vycy5mb3JFYWNoKCh0cmlnZ2VyKSA9PiB7XG4gICAgICAgIGlmICh0cmlnZ2VyLm9wZW4gPT09IHRyaWdnZXIuY2xvc2UpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKHJlbmRlcmVyLmxpc3Rlbih0YXJnZXQsIHRyaWdnZXIub3BlbiwgdG9nZ2xlRm4pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMucHVzaChyZW5kZXJlci5saXN0ZW4odGFyZ2V0LCB0cmlnZ2VyLm9wZW4sIHNob3dGbikpO1xuICAgICAgICBpZiAodHJpZ2dlci5jbG9zZSkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gocmVuZGVyZXIubGlzdGVuKHRhcmdldCwgdHJpZ2dlci5jbG9zZSwgaGlkZUZuKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgodW5zdWJzY3JpYmVGbikgPT4gdW5zdWJzY3JpYmVGbigpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuVG9UcmlnZ2Vyc1YyKHJlbmRlcmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFyc2VkVHJpZ2dlcnMgPSBwYXJzZVRyaWdnZXJzKG9wdGlvbnMudHJpZ2dlcnMpO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgICBpZiAocGFyc2VkVHJpZ2dlcnMubGVuZ3RoID09PSAxICYmIHBhcnNlZFRyaWdnZXJzWzBdLmlzTWFudWFsKCkpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICB9XG4gICAgLy8gYWxsIGxpc3RlbmVyc1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgIC8vIGxhenkgbGlzdGVuZXJzIHJlZ2lzdHJhdGlvblxuICAgIGNvbnN0IF9yZWdpc3RlckhpZGUgPSBbXTtcbiAgICBjb25zdCByZWdpc3RlckhpZGUgPSAoKSA9PiB7XG4gICAgICAgIC8vIGFkZCBoaWRlIGxpc3RlbmVycyB0byB1bnJlZ2lzdGVyIGFycmF5XG4gICAgICAgIF9yZWdpc3RlckhpZGUuZm9yRWFjaCgoZm4pID0+IGxpc3RlbmVycy5wdXNoKGZuKCkpKTtcbiAgICAgICAgLy8gcmVnaXN0ZXIgaGlkZSBldmVudHMgb25seSBvbmNlXG4gICAgICAgIF9yZWdpc3RlckhpZGUubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIC8vIHJlZ2lzdGVyIG9wZW5cXGNsb3NlXFx0b2dnbGUgbGlzdGVuZXJzXG4gICAgcGFyc2VkVHJpZ2dlcnMuZm9yRWFjaCgodHJpZ2dlcikgPT4ge1xuICAgICAgICBjb25zdCB1c2VUb2dnbGUgPSB0cmlnZ2VyLm9wZW4gPT09IHRyaWdnZXIuY2xvc2U7XG4gICAgICAgIGNvbnN0IHNob3dGbiA9IHVzZVRvZ2dsZSA/IG9wdGlvbnMudG9nZ2xlIDogb3B0aW9ucy5zaG93O1xuICAgICAgICBpZiAoIXVzZVRvZ2dsZSAmJiB0cmlnZ2VyLmNsb3NlICYmIG9wdGlvbnMuaGlkZSkge1xuICAgICAgICAgICAgY29uc3QgX2hpZGUgPSByZW5kZXJlci5saXN0ZW4odGFyZ2V0LCB0cmlnZ2VyLmNsb3NlLCBvcHRpb25zLmhpZGUpO1xuICAgICAgICAgICAgX3JlZ2lzdGVySGlkZS5wdXNoKCgpID0+IF9oaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvd0ZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChyZW5kZXJlci5saXN0ZW4odGFyZ2V0LCB0cmlnZ2VyLm9wZW4sICgpID0+IHNob3dGbihyZWdpc3RlckhpZGUpKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgodW5zdWJzY3JpYmVGbikgPT4gdW5zdWJzY3JpYmVGbigpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJPdXRzaWRlQ2xpY2socmVuZGVyZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMub3V0c2lkZUNsaWNrKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGU7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIHJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGFyZ2V0ICYmIG9wdGlvbnMudGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50YXJnZXRzICYmXG4gICAgICAgICAgICBvcHRpb25zLnRhcmdldHMuc29tZSh0YXJnZXQgPT4gdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRXNjQ2xpY2socmVuZGVyZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMub3V0c2lkZUVzYykge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdrZXl1cC5lc2MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGFyZ2V0ICYmIG9wdGlvbnMudGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50YXJnZXRzICYmXG4gICAgICAgICAgICBvcHRpb25zLnRhcmdldHMuc29tZSh0YXJnZXQgPT4gdGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuLyoqXG4gKiBKUyB2ZXJzaW9uIG9mIGJyb3dzZXIgQVBJcy4gVGhpcyBsaWJyYXJ5IGNhbiBvbmx5IHJ1biBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHdpbiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cpIHx8IHt9O1xuY29uc3QgZG9jdW1lbnQgPSB3aW4uZG9jdW1lbnQ7XG5jb25zdCBsb2NhdGlvbiA9IHdpbi5sb2NhdGlvbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBnYyA9IHdpbi5nYyA/ICgpID0+IHdpbi5nYygpIDogKCkgPT4gbnVsbDtcbmNvbnN0IHBlcmZvcm1hbmNlID0gd2luLnBlcmZvcm1hbmNlID8gd2luLnBlcmZvcm1hbmNlIDogbnVsbDtcbmNvbnN0IEV2ZW50ID0gd2luLkV2ZW50O1xuY29uc3QgTW91c2VFdmVudCA9IHdpbi5Nb3VzZUV2ZW50O1xuY29uc3QgS2V5Ym9hcmRFdmVudCA9IHdpbi5LZXlib2FyZEV2ZW50O1xuY29uc3QgRXZlbnRUYXJnZXQgPSB3aW4uRXZlbnRUYXJnZXQ7XG5jb25zdCBIaXN0b3J5ID0gd2luLkhpc3Rvcnk7XG5jb25zdCBMb2NhdGlvbiA9IHdpbi5Mb2NhdGlvbjtcbmNvbnN0IEV2ZW50TGlzdGVuZXIgPSB3aW4uRXZlbnRMaXN0ZW5lcjtcblxudmFyIEJzVmVyaW9ucztcbihmdW5jdGlvbiAoQnNWZXJpb25zKSB7XG4gICAgQnNWZXJpb25zW1wiaXNCczRcIl0gPSBcImJzNFwiO1xuICAgIEJzVmVyaW9uc1tcImlzQnM1XCJdID0gXCJiczVcIjtcbn0pKEJzVmVyaW9ucyB8fCAoQnNWZXJpb25zID0ge30pKTtcbmxldCBndWVzc2VkVmVyc2lvbjtcbmZ1bmN0aW9uIF9ndWVzc0JzVmVyc2lvbigpIHtcbiAgICBjb25zdCBzcGFuRWwgPSB3aW4uZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHNwYW5FbC5pbm5lclRleHQgPSAndGVzdGluZyBicyB2ZXJzaW9uJztcbiAgICBzcGFuRWwuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XG4gICAgc3BhbkVsLmNsYXNzTGlzdC5hZGQoJ3BsLTEnKTtcbiAgICB3aW4uZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzcGFuRWwpO1xuICAgIGNvbnN0IGNoZWNrUGFkZGluZyA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKHNwYW5FbCkucGFkZGluZ0xlZnQ7XG4gICAgaWYgKGNoZWNrUGFkZGluZyAmJiBwYXJzZUZsb2F0KGNoZWNrUGFkZGluZykpIHtcbiAgICAgICAgd2luLmRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3BhbkVsKTtcbiAgICAgICAgcmV0dXJuICdiczQnO1xuICAgIH1cbiAgICB3aW4uZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzcGFuRWwpO1xuICAgIHJldHVybiAnYnM1Jztcbn1cbmZ1bmN0aW9uIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgZ3Vlc3NlZFZlcnNpb24gPSB0aGVtZTtcbn1cbmZ1bmN0aW9uIGlzQnM0KCkge1xuICAgIGlmIChndWVzc2VkVmVyc2lvbilcbiAgICAgICAgcmV0dXJuIGd1ZXNzZWRWZXJzaW9uID09PSAnYnM0JztcbiAgICBndWVzc2VkVmVyc2lvbiA9IF9ndWVzc0JzVmVyc2lvbigpO1xuICAgIHJldHVybiBndWVzc2VkVmVyc2lvbiA9PT0gJ2JzNCc7XG59XG5mdW5jdGlvbiBpc0JzNSgpIHtcbiAgICBpZiAoZ3Vlc3NlZFZlcnNpb24pXG4gICAgICAgIHJldHVybiBndWVzc2VkVmVyc2lvbiA9PT0gJ2JzNSc7XG4gICAgZ3Vlc3NlZFZlcnNpb24gPSBfZ3Vlc3NCc1ZlcnNpb24oKTtcbiAgICByZXR1cm4gZ3Vlc3NlZFZlcnNpb24gPT09ICdiczUnO1xufVxuZnVuY3Rpb24gZ2V0QnNWZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNCczQ6IGlzQnM0KCksXG4gICAgICAgIGlzQnM1OiBpc0JzNSgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRCc1ZlcnNpb24oKSB7XG4gICAgY29uc3QgYnNWZXIgPSBnZXRCc1ZlcigpO1xuICAgIGNvbnN0IHJlc1ZlcnNpb24gPSBPYmplY3Qua2V5cyhic1ZlcikuZmluZChrZXkgPT4gYnNWZXJba2V5XSk7XG4gICAgcmV0dXJuIEJzVmVyaW9uc1tyZXNWZXJzaW9uXTtcbn1cblxuY2xhc3MgTGlua2VkTGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5hc0FycmF5ID0gW107XG4gICAgICAgIC8vIEFycmF5IG1ldGhvZHMgb3ZlcnJpZGluZyBFTkRcbiAgICB9XG4gICAgZ2V0KHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCB8fCBwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwb3NpdGlvbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQ/Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ/LnZhbHVlO1xuICAgIH1cbiAgICBhZGQodmFsdWUsIHBvc2l0aW9uID0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIGlzIG91dCBvZiB0aGUgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHByZXZpb3VzOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3Qgbm9kZVxuICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA9PT0gdGhpcy5sZW5ndGggJiYgdGhpcy50YWlsKSB7XG4gICAgICAgICAgICAgICAgLy8gbGFzdCBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsLm5leHQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSB0aGlzLnRhaWw7XG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vZGUgaW4gbWlkZGxlXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXZpb3VzTm9kZSA9IHRoaXMuZ2V0Tm9kZShwb3NpdGlvbiAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXh0Tm9kZSA9IGN1cnJlbnRQcmV2aW91c05vZGU/Lm5leHQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQcmV2aW91c05vZGUgJiYgY3VycmVudE5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcmV2aW91c05vZGUubmV4dCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROZXh0Tm9kZS5wcmV2aW91cyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldmlvdXMgPSBjdXJyZW50UHJldmlvdXNOb2RlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBjdXJyZW50TmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgIHRoaXMuY3JlYXRlSW50ZXJuYWxBcnJheVJlcHJlc2VudGF0aW9uKCk7XG4gICAgfVxuICAgIHJlbW92ZShwb3NpdGlvbiA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwIHx8IHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb3NpdGlvbiBpcyBvdXQgb2YgdGhlIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBub2RlXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBzZWNvbmQgbm9kZVxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIHNlY29uZCBub2RlXG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID09PSB0aGlzLmxlbmd0aCAtIDEgJiYgdGhpcy50YWlsPy5wcmV2aW91cykge1xuICAgICAgICAgICAgLy8gbGFzdCBub2RlXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldmlvdXM7XG4gICAgICAgICAgICB0aGlzLnRhaWwubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG1pZGRsZSBub2RlXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkTm9kZSA9IHRoaXMuZ2V0Tm9kZShwb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGU/Lm5leHQgJiYgcmVtb3ZlZE5vZGUucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkTm9kZS5uZXh0LnByZXZpb3VzID0gcmVtb3ZlZE5vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUucHJldmlvdXMubmV4dCA9IHJlbW92ZWROb2RlLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdGhpcy5jcmVhdGVJbnRlcm5hbEFycmF5UmVwcmVzZW50YXRpb24oKTtcbiAgICB9XG4gICAgc2V0KHBvc2l0aW9uLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDAgfHwgcG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIGlzIG91dCBvZiB0aGUgbGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldE5vZGUocG9zaXRpb24pO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnRlcm5hbEFycmF5UmVwcmVzZW50YXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc0FycmF5O1xuICAgIH1cbiAgICBmaW5kQWxsKGZuKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbihjdXJyZW50LnZhbHVlLCBpbmRleCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGluZGV4LCB2YWx1ZTogY3VycmVudC52YWx1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQXJyYXkgbWV0aG9kcyBvdmVycmlkaW5nIHN0YXJ0XG4gICAgcHVzaCguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgoYXJnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZChhcmcpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy50YWlsO1xuICAgICAgICB0aGlzLnJlbW92ZSh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gbGFzdD8udmFsdWU7XG4gICAgfVxuICAgIHVuc2hpZnQoLi4uYXJncykge1xuICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGFyZywgMCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHNoaWZ0KCkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdEl0ZW0gPSB0aGlzLmhlYWQ/LnZhbHVlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gbGFzdEl0ZW07XG4gICAgfVxuICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4oY3VycmVudC52YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmRleE9mKHZhbHVlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudC52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuICAgIHNvbWUoZm4pIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgIXJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGZuKGN1cnJlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZXZlcnkoZm4pIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgICAgICB3aGlsZSAoY3VycmVudCAmJiByZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghZm4oY3VycmVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnW0xpbmtlZCBMaXN0XSc7XG4gICAgfVxuICAgIGZpbmQoZm4pIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuKGN1cnJlbnQudmFsdWUsIGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5kZXgoZm4pIHtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuKGN1cnJlbnQudmFsdWUsIGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXROb2RlKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCB8fCBwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gaXMgb3V0IG9mIHRoZSBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwb3NpdGlvbjsgaW5kZXgrKykge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQ/Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGNyZWF0ZUludGVybmFsQXJyYXlSZXByZXNlbnRhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb3V0QXJyYXkgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBvdXRBcnJheS5wdXNoKGN1cnJlbnQudmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzQXJyYXkgPSBvdXRBcnJheTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBPbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzdWZpeCA9ICdDaGFuZ2UnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZ1bmN0aW9uIE9uQ2hhbmdlSGFuZGxlcih0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgIGNvbnN0IF9rZXkgPSBgIF9fJHtwcm9wZXJ0eUtleX1WYWx1ZWA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW19rZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSB0aGlzW19rZXldO1xuICAgICAgICAgICAgICAgIHRoaXNbX2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlZhbHVlICE9PSB2YWx1ZSAmJiB0aGlzW3Byb3BlcnR5S2V5ICsgc3VmaXhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlLZXkgKyBzdWZpeF0uZW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5jbGFzcyBVdGlscyB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgcmVmbG93KGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKChicykgPT4gYnMpKGVsZW1lbnQub2Zmc2V0SGVpZ2h0KTtcbiAgICB9XG4gICAgLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvY3NzL3Zhci9nZXRTdHlsZXMuanNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBnZXRTdHlsZXMoZWxlbSkge1xuICAgICAgICAvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG4gICAgICAgIC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuICAgICAgICAvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcbiAgICAgICAgbGV0IHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIGlmICghdmlldyB8fCAhdmlldy5vcGVuZXIpIHtcbiAgICAgICAgICAgIHZpZXcgPSB3aW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgICB9XG4gICAgc3RhdGljIHN0YWNrT3ZlcmZsb3dDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IGJzVmVyID0gY3VycmVudEJzVmVyc2lvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW46IFwiYW5vbnltb3VzXCIsXG4gICAgICAgICAgICBpbnRlZ3JpdHk6IGJzVmVyID09PSAnYnM1JyA/ICdzaGEzODQtS3laWEVBZzNRaHFMTXBHOHIrOGZoQVhMUmsydnZvQzJmM0IwOXpWWG44Q0E1UUlWZlpPSjNCQ3N3MlAwcC9XZScgOiAnc2hhMzg0LVRYOHQyN0VjUkUzZS9paFU3em1ReFZuY0RBeTV1SUt6NHJFa2dJWGVNZWQ0TTBqbGZJRFB2ZzZ1cUtJMnhYcjInLFxuICAgICAgICAgICAgY2RuTGluazogYnNWZXIgPT09ICdiczUnID8gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vYm9vdHN0cmFwQDUuMS4wL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzJyA6ICdodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtL2Jvb3RzdHJhcEA0LjUuMy9kaXN0L2Nzcy9ib290c3RyYXAubWluLmNzcycsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBfbWVzc2FnZXNIYXNoID0ge307XG5jb25zdCBfaGlkZU1zZyA9IHR5cGVvZiBjb25zb2xlID09PSAndW5kZWZpbmVkJyB8fCAhKCd3YXJuJyBpbiBjb25zb2xlKTtcbmZ1bmN0aW9uIHdhcm5PbmNlKG1zZykge1xuICAgIGlmICghaXNEZXZNb2RlKCkgfHwgX2hpZGVNc2cgfHwgbXNnIGluIF9tZXNzYWdlc0hhc2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfbWVzc2FnZXNIYXNoW21zZ10gPSB0cnVlO1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEJzVmVyaW9ucywgTGlua2VkTGlzdCwgT25DaGFuZ2UsIFRyaWdnZXIsIFV0aWxzLCBjdXJyZW50QnNWZXJzaW9uLCBkb2N1bWVudCwgZ2V0QnNWZXIsIGxpc3RlblRvVHJpZ2dlcnMsIGxpc3RlblRvVHJpZ2dlcnNWMiwgcGFyc2VUcmlnZ2VycywgcmVnaXN0ZXJFc2NDbGljaywgcmVnaXN0ZXJPdXRzaWRlQ2xpY2ssIHNldFRoZW1lLCB3YXJuT25jZSwgd2luIGFzIHdpbmRvdyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmd4LWJvb3RzdHJhcC11dGlscy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ngx-bootstrap/utils/fesm2020/ngx-bootstrap-utils.mjs\n");

/***/ })

}]);