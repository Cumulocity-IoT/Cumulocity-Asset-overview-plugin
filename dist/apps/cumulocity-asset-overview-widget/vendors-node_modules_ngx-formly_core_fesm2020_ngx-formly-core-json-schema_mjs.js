"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcumulocity_asset_overview_widget"] = self["webpackChunkcumulocity_asset_overview_widget"] || []).push([["vendors-node_modules_ngx-formly_core_fesm2020_ngx-formly-core-json-schema_mjs"],{

/***/ "./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core-json-schema.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core-json-schema.mjs ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval("var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FormlyJsonschema\": function() { return /* binding */ FormlyJsonschema; }\n/* harmony export */ });\n/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ \"webpack/sharing/consume/default/@angular/core/@angular/core\");\n/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/forms */ \"webpack/sharing/consume/default/@angular/forms/@angular/forms\");\n/* harmony import */ var _ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ngx-formly/core */ \"webpack/sharing/consume/default/@ngx-formly/core/@ngx-formly/core\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ \"webpack/sharing/consume/default/rxjs/operators/rxjs/operators\");\n\n\n\n\n\n\n// https://stackoverflow.com/a/27865285\nfunction decimalPlaces(a) {\n    if (!isFinite(a)) {\n        return 0;\n    }\n    let e = 1, p = 0;\n    while (Math.round(a * e) / e !== a) {\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction isEmpty(v) {\n    return v === '' || v == null;\n}\nfunction isObject(v) {\n    return v != null && typeof v === 'object' && !Array.isArray(v);\n}\nfunction isInteger(value) {\n    return Number.isInteger ? Number.isInteger(value) : typeof value === 'number' && Math.floor(value) === value;\n}\nfunction isConst(schema) {\n    return typeof schema === 'object' && (schema.hasOwnProperty('const') || (schema.enum && schema.enum.length === 1));\n}\nfunction totalMatchedFields(field) {\n    if (!field.fieldGroup) {\n        return (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵhasKey\"])(field) && (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(field) !== undefined ? 1 : 0;\n    }\n    const total = field.fieldGroup.reduce((s, f) => totalMatchedFields(f) + s, 0);\n    if (total === 0 && (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵhasKey\"])(field)) {\n        const value = (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(field);\n        if (value === null ||\n            (value !== undefined && ((field.fieldArray && Array.isArray(value)) || (!field.fieldArray && isObject(value))))) {\n            return 1;\n        }\n    }\n    return total;\n}\nclass FormlyJsonschema {\n    toFieldConfig(schema, options) {\n        return this._toFieldConfig(schema, { schema, ...(options || {}) });\n    }\n    _toFieldConfig(schema, { key, ...options }) {\n        schema = this.resolveSchema(schema, options);\n        const types = this.guessSchemaType(schema);\n        let field = {\n            type: types[0],\n            defaultValue: schema.default,\n            props: {\n                label: schema.title,\n                readonly: schema.readOnly,\n                description: schema.description,\n            },\n        };\n        if (key != null) {\n            field.key = key;\n        }\n        if (!options.ignoreDefault && (schema.readOnly || options.readOnly)) {\n            field.props.disabled = true;\n            options = { ...options, readOnly: true };\n        }\n        if (options.resetOnHide) {\n            field.resetOnHide = true;\n        }\n        if (key && options.strict) {\n            this.addValidator(field, 'type', (c, f) => {\n                const value = (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(f);\n                if (value != null) {\n                    switch (field.type) {\n                        case 'string': {\n                            return typeof value === 'string';\n                        }\n                        case 'integer': {\n                            return isInteger(value);\n                        }\n                        case 'number': {\n                            return typeof value === 'number';\n                        }\n                        case 'object': {\n                            return isObject(value);\n                        }\n                        case 'array': {\n                            return Array.isArray(value);\n                        }\n                    }\n                }\n                return true;\n            });\n        }\n        if (options.shareFormControl === false) {\n            field.shareFormControl = false;\n        }\n        if (options.ignoreDefault) {\n            delete field.defaultValue;\n        }\n        this.addValidator(field, 'type', {\n            schemaType: types,\n            expression: ({ value }) => {\n                if (value === undefined) {\n                    return true;\n                }\n                if (value === null && types.indexOf('null') !== -1) {\n                    return true;\n                }\n                switch (types[0]) {\n                    case 'null': {\n                        return typeof value === null;\n                    }\n                    case 'string': {\n                        return typeof value === 'string';\n                    }\n                    case 'integer': {\n                        return isInteger(value);\n                    }\n                    case 'number': {\n                        return typeof value === 'number';\n                    }\n                    case 'object': {\n                        return isObject(value);\n                    }\n                    case 'array': {\n                        return Array.isArray(value);\n                    }\n                }\n                return true;\n            },\n        });\n        switch (field.type) {\n            case 'number':\n            case 'integer': {\n                field.parsers = [(v) => (isEmpty(v) ? undefined : Number(v))];\n                if (schema.hasOwnProperty('minimum')) {\n                    field.props.min = schema.minimum;\n                }\n                if (schema.hasOwnProperty('maximum')) {\n                    field.props.max = schema.maximum;\n                }\n                if (schema.hasOwnProperty('exclusiveMinimum')) {\n                    field.props.exclusiveMinimum = schema.exclusiveMinimum;\n                    this.addValidator(field, 'exclusiveMinimum', ({ value }) => isEmpty(value) || value > schema.exclusiveMinimum);\n                }\n                if (schema.hasOwnProperty('exclusiveMaximum')) {\n                    field.props.exclusiveMaximum = schema.exclusiveMaximum;\n                    this.addValidator(field, 'exclusiveMaximum', ({ value }) => isEmpty(value) || value < schema.exclusiveMaximum);\n                }\n                if (schema.hasOwnProperty('multipleOf')) {\n                    field.props.step = schema.multipleOf;\n                    this.addValidator(field, 'multipleOf', ({ value }) => {\n                        if (isEmpty(value) || typeof value !== 'number' || value === 0 || schema.multipleOf <= 0) {\n                            return true;\n                        }\n                        // https://github.com/ajv-validator/ajv/issues/652#issue-283610859\n                        const multiplier = Math.pow(10, decimalPlaces(schema.multipleOf));\n                        return Math.round(value * multiplier) % Math.round(schema.multipleOf * multiplier) === 0;\n                    });\n                }\n                break;\n            }\n            case 'string': {\n                field.parsers = [\n                    (v) => {\n                        if (types.indexOf('null') !== -1) {\n                            v = isEmpty(v) ? null : v;\n                        }\n                        else if (!field.props.required) {\n                            v = v === '' ? undefined : v;\n                        }\n                        return v;\n                    },\n                ];\n                ['minLength', 'maxLength', 'pattern'].forEach((prop) => {\n                    if (schema.hasOwnProperty(prop)) {\n                        field.props[prop] = schema[prop];\n                    }\n                });\n                break;\n            }\n            case 'object': {\n                if (!field.fieldGroup) {\n                    field.fieldGroup = [];\n                }\n                const { propDeps, schemaDeps } = this.resolveDependencies(schema);\n                Object.keys(schema.properties || {}).forEach((property) => {\n                    const isRequired = Array.isArray(schema.required) && schema.required.indexOf(property) !== -1;\n                    const f = this._toFieldConfig(schema.properties[property], {\n                        ...options,\n                        key: property,\n                        isOptional: options.isOptional || !isRequired,\n                    });\n                    field.fieldGroup.push(f);\n                    if (isRequired || propDeps[property]) {\n                        f.expressions = {\n                            ...(f.expressions || {}),\n                            'props.required': (f) => {\n                                let parent = f.parent;\n                                const model = f.fieldGroup && f.key != null ? parent.model : f.model;\n                                while (parent.key == null && parent.parent) {\n                                    parent = parent.parent;\n                                }\n                                const required = parent && parent.props ? parent.props.required : false;\n                                if (!model && !required) {\n                                    return false;\n                                }\n                                if (Array.isArray(schema.required) && schema.required.indexOf(property) !== -1) {\n                                    return true;\n                                }\n                                return propDeps[property] && f.model && propDeps[property].some((k) => !isEmpty(f.model[k]));\n                            },\n                        };\n                    }\n                    if (schemaDeps[property]) {\n                        const getConstValue = (s) => {\n                            return s.hasOwnProperty('const') ? s.const : s.enum[0];\n                        };\n                        const oneOfSchema = schemaDeps[property].oneOf;\n                        if (oneOfSchema &&\n                            oneOfSchema.every((o) => o.properties && o.properties[property] && isConst(o.properties[property]))) {\n                            oneOfSchema.forEach((oneOfSchemaItem) => {\n                                const { [property]: constSchema, ...properties } = oneOfSchemaItem.properties;\n                                field.fieldGroup.push({\n                                    ...this._toFieldConfig({ ...oneOfSchemaItem, properties }, { ...options, resetOnHide: true }),\n                                    expressions: {\n                                        hide: (f) => !f.model || getConstValue(constSchema) !== f.model[property],\n                                    },\n                                });\n                            });\n                        }\n                        else {\n                            field.fieldGroup.push({\n                                ...this._toFieldConfig(schemaDeps[property], options),\n                                expressions: {\n                                    hide: (f) => !f.model || isEmpty(f.model[property]),\n                                },\n                            });\n                        }\n                    }\n                });\n                if (schema.oneOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, shareFormControl: false }));\n                }\n                if (schema.anyOf) {\n                    field.fieldGroup.push(this.resolveMultiSchema('anyOf', schema.anyOf, options));\n                }\n                break;\n            }\n            case 'array': {\n                if (schema.hasOwnProperty('minItems')) {\n                    field.props.minItems = schema.minItems;\n                    this.addValidator(field, 'minItems', (c, f) => {\n                        const value = (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(f);\n                        return isEmpty(value) || value.length >= schema.minItems;\n                    });\n                    if (!options.isOptional && schema.minItems > 0 && field.defaultValue === undefined) {\n                        field.defaultValue = Array.from(new Array(schema.minItems));\n                    }\n                }\n                if (schema.hasOwnProperty('maxItems')) {\n                    field.props.maxItems = schema.maxItems;\n                    this.addValidator(field, 'maxItems', (c, f) => {\n                        const value = (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(f);\n                        return isEmpty(value) || value.length <= schema.maxItems;\n                    });\n                }\n                if (schema.hasOwnProperty('uniqueItems')) {\n                    field.props.uniqueItems = schema.uniqueItems;\n                    this.addValidator(field, 'uniqueItems', (c, f) => {\n                        const value = (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵgetFieldValue\"])(f);\n                        if (isEmpty(value) || !schema.uniqueItems) {\n                            return true;\n                        }\n                        const uniqueItems = Array.from(new Set(value.map((v) => JSON.stringify(v))));\n                        return uniqueItems.length === value.length;\n                    });\n                }\n                // resolve items schema needed for isEnum check\n                if (schema.items && !Array.isArray(schema.items)) {\n                    schema.items = this.resolveSchema(schema.items, options);\n                }\n                // TODO: remove isEnum check once adding an option to skip extension\n                if (!this.isEnum(schema)) {\n                    field.fieldArray = (root) => {\n                        if (!Array.isArray(schema.items)) {\n                            // When items is a single schema, the additionalItems keyword is meaningless, and it should not be used.\n                            const f = schema.items ? this._toFieldConfig(schema.items, options) : {};\n                            if (f.props) {\n                                f.props.required = true;\n                            }\n                            return f;\n                        }\n                        const length = root.fieldGroup ? root.fieldGroup.length : 0;\n                        const itemSchema = schema.items[length] ? schema.items[length] : schema.additionalItems;\n                        const f = itemSchema ? this._toFieldConfig(itemSchema, options) : {};\n                        if (f.props) {\n                            f.props.required = true;\n                        }\n                        if (schema.items[length]) {\n                            f.props.removable = false;\n                        }\n                        return f;\n                    };\n                }\n                break;\n            }\n        }\n        if (schema.hasOwnProperty('const')) {\n            field.props.const = schema.const;\n            this.addValidator(field, 'const', ({ value }) => value === schema.const);\n            if (!field.type) {\n                field.defaultValue = schema.const;\n            }\n        }\n        if (this.isEnum(schema)) {\n            field.props.multiple = field.type === 'array';\n            field.type = 'enum';\n            field.props.options = this.toEnumOptions(schema);\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        if (schema.oneOf && !field.type) {\n            delete field.key;\n            field.fieldGroup = [\n                this.resolveMultiSchema('oneOf', schema.oneOf, { ...options, key, shareFormControl: false }),\n            ];\n        }\n        // map in possible formlyConfig options from the widget property\n        if (schema.widget?.formlyConfig) {\n            field = this.mergeFields(field, schema.widget.formlyConfig);\n        }\n        field.templateOptions = field.props;\n        // if there is a map function passed in, use it to allow the user to\n        // further customize how fields are being mapped\n        return options.map ? options.map(field, schema) : field;\n    }\n    resolveSchema(schema, options) {\n        if (schema && schema.$ref) {\n            schema = this.resolveDefinition(schema, options);\n        }\n        if (schema && schema.allOf) {\n            schema = this.resolveAllOf(schema, options);\n        }\n        return schema;\n    }\n    resolveAllOf({ allOf, ...baseSchema }, options) {\n        if (!allOf.length) {\n            throw Error(`allOf array can not be empty ${allOf}.`);\n        }\n        return allOf.reduce((base, schema) => {\n            schema = this.resolveSchema(schema, options);\n            if (base.required && schema.required) {\n                base.required = [...base.required, ...schema.required];\n            }\n            if (schema.uniqueItems) {\n                base.uniqueItems = schema.uniqueItems;\n            }\n            // resolve to min value\n            ['maxLength', 'maximum', 'exclusiveMaximum', 'maxItems', 'maxProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] < schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            // resolve to max value\n            ['minLength', 'minimum', 'exclusiveMinimum', 'minItems', 'minProperties'].forEach((prop) => {\n                if (!isEmpty(base[prop]) && !isEmpty(schema[prop])) {\n                    base[prop] = base[prop] > schema[prop] ? base[prop] : schema[prop];\n                }\n            });\n            return (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵreverseDeepMerge\"])(base, schema);\n        }, baseSchema);\n    }\n    resolveMultiSchema(mode, schemas, options) {\n        return {\n            type: 'multischema',\n            fieldGroup: [\n                {\n                    type: 'enum',\n                    defaultValue: -1,\n                    props: {\n                        multiple: mode === 'anyOf',\n                        options: schemas.map((s, i) => ({ label: s.title, value: i, disabled: s.readOnly })),\n                    },\n                    hooks: {\n                        onInit: (f) => f.formControl.valueChanges.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.tap)(() => f.options.detectChanges(f.parent))),\n                    },\n                },\n                {\n                    fieldGroup: schemas.map((s, i) => ({\n                        ...this._toFieldConfig(s, { ...options, resetOnHide: true }),\n                        expressions: {\n                            hide: (f, forceUpdate) => {\n                                const control = f.parent.parent.fieldGroup[0].formControl;\n                                if (control.value === -1 || forceUpdate) {\n                                    let value = f.parent.fieldGroup\n                                        .map((f, i) => [f, i, this.isFieldValid(f, i, schemas, options)])\n                                        .sort(([f1, , f1Valid], [f2, , f2Valid]) => {\n                                        if (f1Valid !== f2Valid) {\n                                            return f2Valid ? 1 : -1;\n                                        }\n                                        const matchedFields1 = totalMatchedFields(f1);\n                                        const matchedFields2 = totalMatchedFields(f2);\n                                        if (matchedFields1 === matchedFields2) {\n                                            if (f1.props.disabled === f2.props.disabled) {\n                                                return 0;\n                                            }\n                                            return matchedFields2 > matchedFields1 ? 1 : -1;\n                                        }\n                                        return matchedFields2 > matchedFields1 ? 1 : -1;\n                                    })\n                                        .map(([, i]) => i);\n                                    if (mode === 'anyOf') {\n                                        const definedValue = value.filter((i) => totalMatchedFields(f.parent.fieldGroup[i]));\n                                        value = definedValue.length > 0 ? definedValue : [value[0] || 0];\n                                    }\n                                    value = value.length > 0 ? value : [0];\n                                    control.setValue(mode === 'anyOf' ? value : value[0]);\n                                }\n                                return Array.isArray(control.value) ? control.value.indexOf(i) === -1 : control.value !== i;\n                            },\n                        },\n                    })),\n                },\n            ],\n        };\n    }\n    resolveDefinition(schema, options) {\n        const [uri, pointer] = schema.$ref.split('#/');\n        if (uri) {\n            throw Error(`Remote schemas for ${schema.$ref} not supported yet.`);\n        }\n        const definition = !pointer\n            ? null\n            : pointer\n                .split('/')\n                .reduce((def, path) => (def?.hasOwnProperty(path) ? def[path] : null), options.schema);\n        if (!definition) {\n            throw Error(`Cannot find a definition for ${schema.$ref}.`);\n        }\n        if (definition.$ref) {\n            return this.resolveDefinition(definition, options);\n        }\n        return {\n            ...definition,\n            ...['title', 'description', 'default', 'widget'].reduce((annotation, p) => {\n                if (schema.hasOwnProperty(p)) {\n                    annotation[p] = schema[p];\n                }\n                return annotation;\n            }, {}),\n        };\n    }\n    resolveDependencies(schema) {\n        const propDeps = {};\n        const schemaDeps = {};\n        Object.keys(schema.dependencies || {}).forEach((prop) => {\n            const dependency = schema.dependencies[prop];\n            if (Array.isArray(dependency)) {\n                // Property dependencies\n                dependency.forEach((dep) => {\n                    if (!propDeps[dep]) {\n                        propDeps[dep] = [prop];\n                    }\n                    else {\n                        propDeps[dep].push(prop);\n                    }\n                });\n            }\n            else {\n                // schema dependencies\n                schemaDeps[prop] = dependency;\n            }\n        });\n        return { propDeps, schemaDeps };\n    }\n    guessSchemaType(schema) {\n        const type = schema?.type;\n        if (!type && schema?.properties) {\n            return ['object'];\n        }\n        if (Array.isArray(type)) {\n            if (type.length === 1) {\n                return type;\n            }\n            if (type.length === 2 && type.indexOf('null') !== -1) {\n                return type.sort((t1) => (t1 == 'null' ? 1 : -1));\n            }\n            return type;\n        }\n        return type ? [type] : [];\n    }\n    addValidator(field, name, validator) {\n        field.validators = field.validators || {};\n        field.validators[name] = validator;\n    }\n    isEnum(schema) {\n        return (!!schema.enum ||\n            (schema.anyOf && schema.anyOf.every(isConst)) ||\n            (schema.oneOf && schema.oneOf.every(isConst)) ||\n            (schema.uniqueItems && schema.items && !Array.isArray(schema.items) && this.isEnum(schema.items)));\n    }\n    toEnumOptions(schema) {\n        if (schema.enum) {\n            return schema.enum.map((value) => ({ value, label: value }));\n        }\n        const toEnum = (s) => {\n            const value = s.hasOwnProperty('const') ? s.const : s.enum[0];\n            const option = { value, label: s.title || value };\n            if (s.readOnly) {\n                option.disabled = true;\n            }\n            return option;\n        };\n        if (schema.anyOf) {\n            return schema.anyOf.map(toEnum);\n        }\n        if (schema.oneOf) {\n            return schema.oneOf.map(toEnum);\n        }\n        return this.toEnumOptions(schema.items);\n    }\n    isFieldValid(root, i, schemas, options) {\n        if (!root._schemasFields) {\n            Object.defineProperty(root, '_schemasFields', { enumerable: false, writable: true, configurable: true });\n            root._schemasFields = {};\n        }\n        let field = root._schemasFields[i];\n        const model = root.model ? (0,_ngx_formly_core__WEBPACK_IMPORTED_MODULE_2__[\"ɵclone\"])(root.model) : root.fieldArray ? [] : {};\n        if (!field) {\n            field = root._schemasFields[i] = root.options.build({\n                form: Array.isArray(model) ? new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormArray([]) : new _angular_forms__WEBPACK_IMPORTED_MODULE_1__.FormGroup({}),\n                fieldGroup: [\n                    this._toFieldConfig(schemas[i], {\n                        ...options,\n                        resetOnHide: true,\n                        ignoreDefault: true,\n                        map: null,\n                        strict: true,\n                    }),\n                ],\n                model,\n                options: {},\n            });\n        }\n        else {\n            field.model = model;\n            root.options.build(field);\n        }\n        return field.form.valid;\n    }\n    mergeFields(f1, f2) {\n        for (let prop in f2) {\n            const f1Prop = prop === 'templateOptions' ? 'props' : prop;\n            if (isObject(f1[f1Prop]) && isObject(f2[prop])) {\n                f1[f1Prop] = this.mergeFields(f1[f1Prop], f2[prop]);\n            }\n            else if (f2[prop] != null) {\n                f1[f1Prop] = f2[prop];\n            }\n        }\n        return f1;\n    }\n}\nFormlyJsonschema.ɵfac = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareFactory\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyJsonschema, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵFactoryTarget\"].Injectable });\nFormlyJsonschema.ɵprov = _angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareInjectable\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyJsonschema, providedIn: 'root' });\n_angular_core__WEBPACK_IMPORTED_MODULE_0__[\"ɵɵngDeclareClassMetadata\"]({ minVersion: \"12.0.0\", version: \"13.3.12\", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormlyJsonschema, decorators: [{\n            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\n//# sourceMappingURL=ngx-formly-core-json-schema.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5neC1mb3JtbHkvY29yZS9mZXNtMjAyMC9uZ3gtZm9ybWx5LWNvcmUtanNvbi1zY2hlbWEubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY3VtdWxvY2l0eS1hc3NldC1vdmVydmlldy13aWRnZXQvLi9ub2RlX21vZHVsZXMvQG5neC1mb3JtbHkvY29yZS9mZXNtMjAyMC9uZ3gtZm9ybWx5LWNvcmUtanNvbi1zY2hlbWEubWpzPzBhMmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQXJyYXksIEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IMm1aGFzS2V5LCDJtWdldEZpZWxkVmFsdWUsIMm1cmV2ZXJzZURlZXBNZXJnZSwgybVjbG9uZSB9IGZyb20gJ0BuZ3gtZm9ybWx5L2NvcmUnO1xuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjc4NjUyODVcbmZ1bmN0aW9uIGRlY2ltYWxQbGFjZXMoYSkge1xuICAgIGlmICghaXNGaW5pdGUoYSkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBlID0gMSwgcCA9IDA7XG4gICAgd2hpbGUgKE1hdGgucm91bmQoYSAqIGUpIC8gZSAhPT0gYSkge1xuICAgICAgICBlICo9IDEwO1xuICAgICAgICBwKys7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaXNFbXB0eSh2KSB7XG4gICAgcmV0dXJuIHYgPT09ICcnIHx8IHYgPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHYpIHtcbiAgICByZXR1cm4gdiAhPSBudWxsICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2KTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyID8gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgOiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzQ29uc3Qoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnICYmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2NvbnN0JykgfHwgKHNjaGVtYS5lbnVtICYmIHNjaGVtYS5lbnVtLmxlbmd0aCA9PT0gMSkpO1xufVxuZnVuY3Rpb24gdG90YWxNYXRjaGVkRmllbGRzKGZpZWxkKSB7XG4gICAgaWYgKCFmaWVsZC5maWVsZEdyb3VwKSB7XG4gICAgICAgIHJldHVybiDJtWhhc0tleShmaWVsZCkgJiYgybVnZXRGaWVsZFZhbHVlKGZpZWxkKSAhPT0gdW5kZWZpbmVkID8gMSA6IDA7XG4gICAgfVxuICAgIGNvbnN0IHRvdGFsID0gZmllbGQuZmllbGRHcm91cC5yZWR1Y2UoKHMsIGYpID0+IHRvdGFsTWF0Y2hlZEZpZWxkcyhmKSArIHMsIDApO1xuICAgIGlmICh0b3RhbCA9PT0gMCAmJiDJtWhhc0tleShmaWVsZCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSDJtWdldEZpZWxkVmFsdWUoZmllbGQpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICgoZmllbGQuZmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkgfHwgKCFmaWVsZC5maWVsZEFycmF5ICYmIGlzT2JqZWN0KHZhbHVlKSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xufVxuY2xhc3MgRm9ybWx5SnNvbnNjaGVtYSB7XG4gICAgdG9GaWVsZENvbmZpZyhzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvRmllbGRDb25maWcoc2NoZW1hLCB7IHNjaGVtYSwgLi4uKG9wdGlvbnMgfHwge30pIH0pO1xuICAgIH1cbiAgICBfdG9GaWVsZENvbmZpZyhzY2hlbWEsIHsga2V5LCAuLi5vcHRpb25zIH0pIHtcbiAgICAgICAgc2NoZW1hID0gdGhpcy5yZXNvbHZlU2NoZW1hKHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5ndWVzc1NjaGVtYVR5cGUoc2NoZW1hKTtcbiAgICAgICAgbGV0IGZpZWxkID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZXNbMF0sXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHNjaGVtYS5kZWZhdWx0LFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICBsYWJlbDogc2NoZW1hLnRpdGxlLFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5OiBzY2hlbWEucmVhZE9ubHksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgZmllbGQua2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVEZWZhdWx0ICYmIChzY2hlbWEucmVhZE9ubHkgfHwgb3B0aW9ucy5yZWFkT25seSkpIHtcbiAgICAgICAgICAgIGZpZWxkLnByb3BzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHJlYWRPbmx5OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVzZXRPbkhpZGUpIHtcbiAgICAgICAgICAgIGZpZWxkLnJlc2V0T25IaWRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ICYmIG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZFZhbGlkYXRvcihmaWVsZCwgJ3R5cGUnLCAoYywgZikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gybVnZXRGaWVsZFZhbHVlKGYpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW50ZWdlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2hhcmVGb3JtQ29udHJvbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGZpZWxkLnNoYXJlRm9ybUNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVEZWZhdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkVmFsaWRhdG9yKGZpZWxkLCAndHlwZScsIHtcbiAgICAgICAgICAgIHNjaGVtYVR5cGU6IHR5cGVzLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgdHlwZXMuaW5kZXhPZignbnVsbCcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnRlZ2VyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzSW50ZWdlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhcnJheSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICBjYXNlICdpbnRlZ2VyJzoge1xuICAgICAgICAgICAgICAgIGZpZWxkLnBhcnNlcnMgPSBbKHYpID0+IChpc0VtcHR5KHYpID8gdW5kZWZpbmVkIDogTnVtYmVyKHYpKV07XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgnbWluaW11bScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLnByb3BzLm1pbiA9IHNjaGVtYS5taW5pbXVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KCdtYXhpbXVtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucHJvcHMubWF4ID0gc2NoZW1hLm1heGltdW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2V4Y2x1c2l2ZU1pbmltdW0nKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5wcm9wcy5leGNsdXNpdmVNaW5pbXVtID0gc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmFsaWRhdG9yKGZpZWxkLCAnZXhjbHVzaXZlTWluaW11bScsICh7IHZhbHVlIH0pID0+IGlzRW1wdHkodmFsdWUpIHx8IHZhbHVlID4gc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLmhhc093blByb3BlcnR5KCdleGNsdXNpdmVNYXhpbXVtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucHJvcHMuZXhjbHVzaXZlTWF4aW11bSA9IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZhbGlkYXRvcihmaWVsZCwgJ2V4Y2x1c2l2ZU1heGltdW0nLCAoeyB2YWx1ZSB9KSA9PiBpc0VtcHR5KHZhbHVlKSB8fCB2YWx1ZSA8IHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eSgnbXVsdGlwbGVPZicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLnByb3BzLnN0ZXAgPSBzY2hlbWEubXVsdGlwbGVPZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWYWxpZGF0b3IoZmllbGQsICdtdWx0aXBsZU9mJywgKHsgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPT09IDAgfHwgc2NoZW1hLm11bHRpcGxlT2YgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy82NTIjaXNzdWUtMjgzNjEwODU5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIGRlY2ltYWxQbGFjZXMoc2NoZW1hLm11bHRpcGxlT2YpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogbXVsdGlwbGllcikgJSBNYXRoLnJvdW5kKHNjaGVtYS5tdWx0aXBsZU9mICogbXVsdGlwbGllcikgPT09IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgICAgICAgICBmaWVsZC5wYXJzZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICAodikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoJ251bGwnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gaXNFbXB0eSh2KSA/IG51bGwgOiB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpZWxkLnByb3BzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHYgPT09ICcnID8gdW5kZWZpbmVkIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgWydtaW5MZW5ndGgnLCAnbWF4TGVuZ3RoJywgJ3BhdHRlcm4nXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnByb3BzW3Byb3BdID0gc2NoZW1hW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWVsZC5maWVsZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmZpZWxkR3JvdXAgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wRGVwcywgc2NoZW1hRGVwcyB9ID0gdGhpcy5yZXNvbHZlRGVwZW5kZW5jaWVzKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NoZW1hLnByb3BlcnRpZXMgfHwge30pLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgJiYgc2NoZW1hLnJlcXVpcmVkLmluZGV4T2YocHJvcGVydHkpICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuX3RvRmllbGRDb25maWcoc2NoZW1hLnByb3BlcnRpZXNbcHJvcGVydHldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3B0aW9uYWw6IG9wdGlvbnMuaXNPcHRpb25hbCB8fCAhaXNSZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmZpZWxkR3JvdXAucHVzaChmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVxdWlyZWQgfHwgcHJvcERlcHNbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmV4cHJlc3Npb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihmLmV4cHJlc3Npb25zIHx8IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncHJvcHMucmVxdWlyZWQnOiAoZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50ID0gZi5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gZi5maWVsZEdyb3VwICYmIGYua2V5ICE9IG51bGwgPyBwYXJlbnQubW9kZWwgOiBmLm1vZGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50LmtleSA9PSBudWxsICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBwYXJlbnQgJiYgcGFyZW50LnByb3BzID8gcGFyZW50LnByb3BzLnJlcXVpcmVkIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbW9kZWwgJiYgIXJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hLnJlcXVpcmVkKSAmJiBzY2hlbWEucmVxdWlyZWQuaW5kZXhPZihwcm9wZXJ0eSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcERlcHNbcHJvcGVydHldICYmIGYubW9kZWwgJiYgcHJvcERlcHNbcHJvcGVydHldLnNvbWUoKGspID0+ICFpc0VtcHR5KGYubW9kZWxba10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hRGVwc1twcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdldENvbnN0VmFsdWUgPSAocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmhhc093blByb3BlcnR5KCdjb25zdCcpID8gcy5jb25zdCA6IHMuZW51bVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbmVPZlNjaGVtYSA9IHNjaGVtYURlcHNbcHJvcGVydHldLm9uZU9mO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZU9mU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lT2ZTY2hlbWEuZXZlcnkoKG8pID0+IG8ucHJvcGVydGllcyAmJiBvLnByb3BlcnRpZXNbcHJvcGVydHldICYmIGlzQ29uc3Qoby5wcm9wZXJ0aWVzW3Byb3BlcnR5XSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lT2ZTY2hlbWEuZm9yRWFjaCgob25lT2ZTY2hlbWFJdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgW3Byb3BlcnR5XTogY29uc3RTY2hlbWEsIC4uLnByb3BlcnRpZXMgfSA9IG9uZU9mU2NoZW1hSXRlbS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5maWVsZEdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5fdG9GaWVsZENvbmZpZyh7IC4uLm9uZU9mU2NoZW1hSXRlbSwgcHJvcGVydGllcyB9LCB7IC4uLm9wdGlvbnMsIHJlc2V0T25IaWRlOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlOiAoZikgPT4gIWYubW9kZWwgfHwgZ2V0Q29uc3RWYWx1ZShjb25zdFNjaGVtYSkgIT09IGYubW9kZWxbcHJvcGVydHldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5maWVsZEdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLl90b0ZpZWxkQ29uZmlnKHNjaGVtYURlcHNbcHJvcGVydHldLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IChmKSA9PiAhZi5tb2RlbCB8fCBpc0VtcHR5KGYubW9kZWxbcHJvcGVydHldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEub25lT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cC5wdXNoKHRoaXMucmVzb2x2ZU11bHRpU2NoZW1hKCdvbmVPZicsIHNjaGVtYS5vbmVPZiwgeyAuLi5vcHRpb25zLCBzaGFyZUZvcm1Db250cm9sOiBmYWxzZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cC5wdXNoKHRoaXMucmVzb2x2ZU11bHRpU2NoZW1hKCdhbnlPZicsIHNjaGVtYS5hbnlPZiwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FycmF5Jzoge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ21pbkl0ZW1zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucHJvcHMubWluSXRlbXMgPSBzY2hlbWEubWluSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmFsaWRhdG9yKGZpZWxkLCAnbWluSXRlbXMnLCAoYywgZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSDJtWdldEZpZWxkVmFsdWUoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID49IHNjaGVtYS5taW5JdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pc09wdGlvbmFsICYmIHNjaGVtYS5taW5JdGVtcyA+IDAgJiYgZmllbGQuZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLmRlZmF1bHRWYWx1ZSA9IEFycmF5LmZyb20obmV3IEFycmF5KHNjaGVtYS5taW5JdGVtcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ21heEl0ZW1zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucHJvcHMubWF4SXRlbXMgPSBzY2hlbWEubWF4SXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmFsaWRhdG9yKGZpZWxkLCAnbWF4SXRlbXMnLCAoYywgZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSDJtWdldEZpZWxkVmFsdWUoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoIDw9IHNjaGVtYS5tYXhJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ3VuaXF1ZUl0ZW1zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucHJvcHMudW5pcXVlSXRlbXMgPSBzY2hlbWEudW5pcXVlSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmFsaWRhdG9yKGZpZWxkLCAndW5pcXVlSXRlbXMnLCAoYywgZikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSDJtWdldEZpZWxkVmFsdWUoZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh2YWx1ZSkgfHwgIXNjaGVtYS51bmlxdWVJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlSXRlbXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWUubWFwKCh2KSA9PiBKU09OLnN0cmluZ2lmeSh2KSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmlxdWVJdGVtcy5sZW5ndGggPT09IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgaXRlbXMgc2NoZW1hIG5lZWRlZCBmb3IgaXNFbnVtIGNoZWNrXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYS5pdGVtcyA9IHRoaXMucmVzb2x2ZVNjaGVtYShzY2hlbWEuaXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgaXNFbnVtIGNoZWNrIG9uY2UgYWRkaW5nIGFuIG9wdGlvbiB0byBza2lwIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0VudW0oc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5maWVsZEFycmF5ID0gKHJvb3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBpdGVtcyBpcyBhIHNpbmdsZSBzY2hlbWEsIHRoZSBhZGRpdGlvbmFsSXRlbXMga2V5d29yZCBpcyBtZWFuaW5nbGVzcywgYW5kIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gc2NoZW1hLml0ZW1zID8gdGhpcy5fdG9GaWVsZENvbmZpZyhzY2hlbWEuaXRlbXMsIG9wdGlvbnMpIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYucHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5wcm9wcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcm9vdC5maWVsZEdyb3VwID8gcm9vdC5maWVsZEdyb3VwLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gc2NoZW1hLml0ZW1zW2xlbmd0aF0gPyBzY2hlbWEuaXRlbXNbbGVuZ3RoXSA6IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gaXRlbVNjaGVtYSA/IHRoaXMuX3RvRmllbGRDb25maWcoaXRlbVNjaGVtYSwgb3B0aW9ucykgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5wcm9wcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hLml0ZW1zW2xlbmd0aF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnByb3BzLnJlbW92YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2NvbnN0JykpIHtcbiAgICAgICAgICAgIGZpZWxkLnByb3BzLmNvbnN0ID0gc2NoZW1hLmNvbnN0O1xuICAgICAgICAgICAgdGhpcy5hZGRWYWxpZGF0b3IoZmllbGQsICdjb25zdCcsICh7IHZhbHVlIH0pID0+IHZhbHVlID09PSBzY2hlbWEuY29uc3QpO1xuICAgICAgICAgICAgaWYgKCFmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuZGVmYXVsdFZhbHVlID0gc2NoZW1hLmNvbnN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzRW51bShzY2hlbWEpKSB7XG4gICAgICAgICAgICBmaWVsZC5wcm9wcy5tdWx0aXBsZSA9IGZpZWxkLnR5cGUgPT09ICdhcnJheSc7XG4gICAgICAgICAgICBmaWVsZC50eXBlID0gJ2VudW0nO1xuICAgICAgICAgICAgZmllbGQucHJvcHMub3B0aW9ucyA9IHRoaXMudG9FbnVtT3B0aW9ucyhzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEub25lT2YgJiYgIWZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZC5rZXk7XG4gICAgICAgICAgICBmaWVsZC5maWVsZEdyb3VwID0gW1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZU11bHRpU2NoZW1hKCdvbmVPZicsIHNjaGVtYS5vbmVPZiwgeyAuLi5vcHRpb25zLCBrZXksIHNoYXJlRm9ybUNvbnRyb2w6IGZhbHNlIH0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLm9uZU9mICYmICFmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBkZWxldGUgZmllbGQua2V5O1xuICAgICAgICAgICAgZmllbGQuZmllbGRHcm91cCA9IFtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVNdWx0aVNjaGVtYSgnb25lT2YnLCBzY2hlbWEub25lT2YsIHsgLi4ub3B0aW9ucywga2V5LCBzaGFyZUZvcm1Db250cm9sOiBmYWxzZSB9KSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFwIGluIHBvc3NpYmxlIGZvcm1seUNvbmZpZyBvcHRpb25zIGZyb20gdGhlIHdpZGdldCBwcm9wZXJ0eVxuICAgICAgICBpZiAoc2NoZW1hLndpZGdldD8uZm9ybWx5Q29uZmlnKSB7XG4gICAgICAgICAgICBmaWVsZCA9IHRoaXMubWVyZ2VGaWVsZHMoZmllbGQsIHNjaGVtYS53aWRnZXQuZm9ybWx5Q29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZC50ZW1wbGF0ZU9wdGlvbnMgPSBmaWVsZC5wcm9wcztcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBtYXAgZnVuY3Rpb24gcGFzc2VkIGluLCB1c2UgaXQgdG8gYWxsb3cgdGhlIHVzZXIgdG9cbiAgICAgICAgLy8gZnVydGhlciBjdXN0b21pemUgaG93IGZpZWxkcyBhcmUgYmVpbmcgbWFwcGVkXG4gICAgICAgIHJldHVybiBvcHRpb25zLm1hcCA/IG9wdGlvbnMubWFwKGZpZWxkLCBzY2hlbWEpIDogZmllbGQ7XG4gICAgfVxuICAgIHJlc29sdmVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMucmVzb2x2ZURlZmluaXRpb24oc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgc2NoZW1hID0gdGhpcy5yZXNvbHZlQWxsT2Yoc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICByZXNvbHZlQWxsT2YoeyBhbGxPZiwgLi4uYmFzZVNjaGVtYSB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghYWxsT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgYWxsT2YgYXJyYXkgY2FuIG5vdCBiZSBlbXB0eSAke2FsbE9mfS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsT2YucmVkdWNlKChiYXNlLCBzY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHNjaGVtYSA9IHRoaXMucmVzb2x2ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGJhc2UucmVxdWlyZWQgJiYgc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgYmFzZS5yZXF1aXJlZCA9IFsuLi5iYXNlLnJlcXVpcmVkLCAuLi5zY2hlbWEucmVxdWlyZWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS51bmlxdWVJdGVtcykge1xuICAgICAgICAgICAgICAgIGJhc2UudW5pcXVlSXRlbXMgPSBzY2hlbWEudW5pcXVlSXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNvbHZlIHRvIG1pbiB2YWx1ZVxuICAgICAgICAgICAgWydtYXhMZW5ndGgnLCAnbWF4aW11bScsICdleGNsdXNpdmVNYXhpbXVtJywgJ21heEl0ZW1zJywgJ21heFByb3BlcnRpZXMnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KGJhc2VbcHJvcF0pICYmICFpc0VtcHR5KHNjaGVtYVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVtwcm9wXSA9IGJhc2VbcHJvcF0gPCBzY2hlbWFbcHJvcF0gPyBiYXNlW3Byb3BdIDogc2NoZW1hW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmVzb2x2ZSB0byBtYXggdmFsdWVcbiAgICAgICAgICAgIFsnbWluTGVuZ3RoJywgJ21pbmltdW0nLCAnZXhjbHVzaXZlTWluaW11bScsICdtaW5JdGVtcycsICdtaW5Qcm9wZXJ0aWVzJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eShiYXNlW3Byb3BdKSAmJiAhaXNFbXB0eShzY2hlbWFbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2VbcHJvcF0gPSBiYXNlW3Byb3BdID4gc2NoZW1hW3Byb3BdID8gYmFzZVtwcm9wXSA6IHNjaGVtYVtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiDJtXJldmVyc2VEZWVwTWVyZ2UoYmFzZSwgc2NoZW1hKTtcbiAgICAgICAgfSwgYmFzZVNjaGVtYSk7XG4gICAgfVxuICAgIHJlc29sdmVNdWx0aVNjaGVtYShtb2RlLCBzY2hlbWFzLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnbXVsdGlzY2hlbWEnLFxuICAgICAgICAgICAgZmllbGRHcm91cDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VudW0nLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IC0xLFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGU6IG1vZGUgPT09ICdhbnlPZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBzY2hlbWFzLm1hcCgocywgaSkgPT4gKHsgbGFiZWw6IHMudGl0bGUsIHZhbHVlOiBpLCBkaXNhYmxlZDogcy5yZWFkT25seSB9KSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGhvb2tzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkluaXQ6IChmKSA9PiBmLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKHRhcCgoKSA9PiBmLm9wdGlvbnMuZGV0ZWN0Q2hhbmdlcyhmLnBhcmVudCkpKSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRHcm91cDogc2NoZW1hcy5tYXAoKHMsIGkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50aGlzLl90b0ZpZWxkQ29uZmlnKHMsIHsgLi4ub3B0aW9ucywgcmVzZXRPbkhpZGU6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IChmLCBmb3JjZVVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sID0gZi5wYXJlbnQucGFyZW50LmZpZWxkR3JvdXBbMF0uZm9ybUNvbnRyb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sLnZhbHVlID09PSAtMSB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZi5wYXJlbnQuZmllbGRHcm91cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGYsIGkpID0+IFtmLCBpLCB0aGlzLmlzRmllbGRWYWxpZChmLCBpLCBzY2hlbWFzLCBvcHRpb25zKV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKFtmMSwgLCBmMVZhbGlkXSwgW2YyLCAsIGYyVmFsaWRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYxVmFsaWQgIT09IGYyVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGYyVmFsaWQgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRGaWVsZHMxID0gdG90YWxNYXRjaGVkRmllbGRzKGYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkRmllbGRzMiA9IHRvdGFsTWF0Y2hlZEZpZWxkcyhmMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRGaWVsZHMxID09PSBtYXRjaGVkRmllbGRzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjEucHJvcHMuZGlzYWJsZWQgPT09IGYyLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEZpZWxkczIgPiBtYXRjaGVkRmllbGRzMSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZWRGaWVsZHMyID4gbWF0Y2hlZEZpZWxkczEgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKFssIGldKSA9PiBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnYW55T2YnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmaW5lZFZhbHVlID0gdmFsdWUuZmlsdGVyKChpKSA9PiB0b3RhbE1hdGNoZWRGaWVsZHMoZi5wYXJlbnQuZmllbGRHcm91cFtpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVmaW5lZFZhbHVlLmxlbmd0aCA+IDAgPyBkZWZpbmVkVmFsdWUgOiBbdmFsdWVbMF0gfHwgMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmxlbmd0aCA+IDAgPyB2YWx1ZSA6IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuc2V0VmFsdWUobW9kZSA9PT0gJ2FueU9mJyA/IHZhbHVlIDogdmFsdWVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGNvbnRyb2wudmFsdWUpID8gY29udHJvbC52YWx1ZS5pbmRleE9mKGkpID09PSAtMSA6IGNvbnRyb2wudmFsdWUgIT09IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzb2x2ZURlZmluaXRpb24oc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IFt1cmksIHBvaW50ZXJdID0gc2NoZW1hLiRyZWYuc3BsaXQoJyMvJyk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBSZW1vdGUgc2NoZW1hcyBmb3IgJHtzY2hlbWEuJHJlZn0gbm90IHN1cHBvcnRlZCB5ZXQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9ICFwb2ludGVyXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogcG9pbnRlclxuICAgICAgICAgICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoZGVmLCBwYXRoKSA9PiAoZGVmPy5oYXNPd25Qcm9wZXJ0eShwYXRoKSA/IGRlZltwYXRoXSA6IG51bGwpLCBvcHRpb25zLnNjaGVtYSk7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCBmaW5kIGEgZGVmaW5pdGlvbiBmb3IgJHtzY2hlbWEuJHJlZn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmluaXRpb24uJHJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZURlZmluaXRpb24oZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICAgICAgICAuLi5bJ3RpdGxlJywgJ2Rlc2NyaXB0aW9uJywgJ2RlZmF1bHQnLCAnd2lkZ2V0J10ucmVkdWNlKChhbm5vdGF0aW9uLCBwKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0aW9uW3BdID0gc2NoZW1hW3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzb2x2ZURlcGVuZGVuY2llcyhzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgcHJvcERlcHMgPSB7fTtcbiAgICAgICAgY29uc3Qgc2NoZW1hRGVwcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhzY2hlbWEuZGVwZW5kZW5jaWVzIHx8IHt9KS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXBlbmRlbmN5ID0gc2NoZW1hLmRlcGVuZGVuY2llc1twcm9wXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeS5mb3JFYWNoKChkZXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wRGVwc1tkZXBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wRGVwc1tkZXBdID0gW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcERlcHNbZGVwXS5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzY2hlbWEgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgc2NoZW1hRGVwc1twcm9wXSA9IGRlcGVuZGVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyBwcm9wRGVwcywgc2NoZW1hRGVwcyB9O1xuICAgIH1cbiAgICBndWVzc1NjaGVtYVR5cGUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBzY2hlbWE/LnR5cGU7XG4gICAgICAgIGlmICghdHlwZSAmJiBzY2hlbWE/LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ29iamVjdCddO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlLmxlbmd0aCA9PT0gMiAmJiB0eXBlLmluZGV4T2YoJ251bGwnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZS5zb3J0KCh0MSkgPT4gKHQxID09ICdudWxsJyA/IDEgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPyBbdHlwZV0gOiBbXTtcbiAgICB9XG4gICAgYWRkVmFsaWRhdG9yKGZpZWxkLCBuYW1lLCB2YWxpZGF0b3IpIHtcbiAgICAgICAgZmllbGQudmFsaWRhdG9ycyA9IGZpZWxkLnZhbGlkYXRvcnMgfHwge307XG4gICAgICAgIGZpZWxkLnZhbGlkYXRvcnNbbmFtZV0gPSB2YWxpZGF0b3I7XG4gICAgfVxuICAgIGlzRW51bShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuICghIXNjaGVtYS5lbnVtIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmFueU9mICYmIHNjaGVtYS5hbnlPZi5ldmVyeShpc0NvbnN0KSkgfHxcbiAgICAgICAgICAgIChzY2hlbWEub25lT2YgJiYgc2NoZW1hLm9uZU9mLmV2ZXJ5KGlzQ29uc3QpKSB8fFxuICAgICAgICAgICAgKHNjaGVtYS51bmlxdWVJdGVtcyAmJiBzY2hlbWEuaXRlbXMgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hLml0ZW1zKSAmJiB0aGlzLmlzRW51bShzY2hlbWEuaXRlbXMpKSk7XG4gICAgfVxuICAgIHRvRW51bU9wdGlvbnMoc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5lbnVtLm1hcCgodmFsdWUpID0+ICh7IHZhbHVlLCBsYWJlbDogdmFsdWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvRW51bSA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0JykgPyBzLmNvbnN0IDogcy5lbnVtWzBdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0geyB2YWx1ZSwgbGFiZWw6IHMudGl0bGUgfHwgdmFsdWUgfTtcbiAgICAgICAgICAgIGlmIChzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb247XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuYW55T2YubWFwKHRvRW51bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5vbmVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5vbmVPZi5tYXAodG9FbnVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b0VudW1PcHRpb25zKHNjaGVtYS5pdGVtcyk7XG4gICAgfVxuICAgIGlzRmllbGRWYWxpZChyb290LCBpLCBzY2hlbWFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghcm9vdC5fc2NoZW1hc0ZpZWxkcykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QsICdfc2NoZW1hc0ZpZWxkcycsIHsgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgICAgICAgICByb290Ll9zY2hlbWFzRmllbGRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkID0gcm9vdC5fc2NoZW1hc0ZpZWxkc1tpXTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSByb290Lm1vZGVsID8gybVjbG9uZShyb290Lm1vZGVsKSA6IHJvb3QuZmllbGRBcnJheSA/IFtdIDoge307XG4gICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIGZpZWxkID0gcm9vdC5fc2NoZW1hc0ZpZWxkc1tpXSA9IHJvb3Qub3B0aW9ucy5idWlsZCh7XG4gICAgICAgICAgICAgICAgZm9ybTogQXJyYXkuaXNBcnJheShtb2RlbCkgPyBuZXcgRm9ybUFycmF5KFtdKSA6IG5ldyBGb3JtR3JvdXAoe30pLFxuICAgICAgICAgICAgICAgIGZpZWxkR3JvdXA6IFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9GaWVsZENvbmZpZyhzY2hlbWFzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRPbkhpZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVEZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWVsZC5tb2RlbCA9IG1vZGVsO1xuICAgICAgICAgICAgcm9vdC5vcHRpb25zLmJ1aWxkKGZpZWxkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGQuZm9ybS52YWxpZDtcbiAgICB9XG4gICAgbWVyZ2VGaWVsZHMoZjEsIGYyKSB7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gZjIpIHtcbiAgICAgICAgICAgIGNvbnN0IGYxUHJvcCA9IHByb3AgPT09ICd0ZW1wbGF0ZU9wdGlvbnMnID8gJ3Byb3BzJyA6IHByb3A7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZjFbZjFQcm9wXSkgJiYgaXNPYmplY3QoZjJbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgZjFbZjFQcm9wXSA9IHRoaXMubWVyZ2VGaWVsZHMoZjFbZjFQcm9wXSwgZjJbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZjJbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGYxW2YxUHJvcF0gPSBmMltwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjE7XG4gICAgfVxufVxuRm9ybWx5SnNvbnNjaGVtYS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxMy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybWx5SnNvbnNjaGVtYSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkZvcm1seUpzb25zY2hlbWEuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjEzLjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtbHlKc29uc2NoZW1hLCBwcm92aWRlZEluOiAncm9vdCcgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTMuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1seUpzb25zY2hlbWEsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3sgcHJvdmlkZWRJbjogJ3Jvb3QnIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEZvcm1seUpzb25zY2hlbWEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5neC1mb3JtbHktY29yZS1qc29uLXNjaGVtYS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@ngx-formly/core/fesm2020/ngx-formly-core-json-schema.mjs\n");

/***/ })

}]);